multiline_comment|/*&n; * Some generic hashing helpers.&n; */
macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;hash.h&quot;
multiline_comment|/*&n; * Look up a hash entry in the hash table. Return the pointer to&n; * the existing entry, or the empty slot if none existed. The caller&n; * can then look at the (*ptr) to see whether it existed or not.&n; */
DECL|function|lookup_hash_entry
r_static
r_struct
id|hash_table_entry
op_star
id|lookup_hash_entry
c_func
(paren
r_int
r_int
id|hash
comma
r_struct
id|hash_table
op_star
id|table
)paren
(brace
r_int
r_int
id|size
op_assign
id|table-&gt;size
comma
id|nr
op_assign
id|hash
op_mod
id|size
suffix:semicolon
r_struct
id|hash_table_entry
op_star
id|array
op_assign
id|table-&gt;array
suffix:semicolon
r_while
c_loop
(paren
id|array
(braket
id|nr
)braket
dot
id|ptr
)paren
(brace
r_if
c_cond
(paren
id|array
(braket
id|nr
)braket
dot
id|hash
op_eq
id|hash
)paren
r_break
suffix:semicolon
id|nr
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|nr
op_ge
id|size
)paren
id|nr
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|array
op_plus
id|nr
suffix:semicolon
)brace
multiline_comment|/*&n; * Insert a new hash entry pointer into the table.&n; *&n; * If that hash entry already existed, return the pointer to&n; * the existing entry (and the caller can create a list of the&n; * pointers or do anything else). If it didn&squot;t exist, return&n; * NULL (and the caller knows the pointer has been inserted).&n; */
DECL|function|insert_hash_entry
r_static
r_void
op_star
op_star
id|insert_hash_entry
c_func
(paren
r_int
r_int
id|hash
comma
r_void
op_star
id|ptr
comma
r_struct
id|hash_table
op_star
id|table
)paren
(brace
r_struct
id|hash_table_entry
op_star
id|entry
op_assign
id|lookup_hash_entry
c_func
(paren
id|hash
comma
id|table
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;ptr
)paren
(brace
id|entry-&gt;ptr
op_assign
id|ptr
suffix:semicolon
id|entry-&gt;hash
op_assign
id|hash
suffix:semicolon
id|table-&gt;nr
op_increment
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
op_amp
id|entry-&gt;ptr
suffix:semicolon
)brace
DECL|function|grow_hash_table
r_static
r_void
id|grow_hash_table
c_func
(paren
r_struct
id|hash_table
op_star
id|table
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
r_int
id|old_size
op_assign
id|table-&gt;size
comma
id|new_size
suffix:semicolon
r_struct
id|hash_table_entry
op_star
id|old_array
op_assign
id|table-&gt;array
comma
op_star
id|new_array
suffix:semicolon
id|new_size
op_assign
id|alloc_nr
c_func
(paren
id|old_size
)paren
suffix:semicolon
id|new_array
op_assign
id|xcalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|hash_table_entry
)paren
comma
id|new_size
)paren
suffix:semicolon
id|table-&gt;size
op_assign
id|new_size
suffix:semicolon
id|table-&gt;array
op_assign
id|new_array
suffix:semicolon
id|table-&gt;nr
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|old_size
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|hash
op_assign
id|old_array
(braket
id|i
)braket
dot
id|hash
suffix:semicolon
r_void
op_star
id|ptr
op_assign
id|old_array
(braket
id|i
)braket
dot
id|ptr
suffix:semicolon
r_if
c_cond
(paren
id|ptr
)paren
id|insert_hash_entry
c_func
(paren
id|hash
comma
id|ptr
comma
id|table
)paren
suffix:semicolon
)brace
id|free
c_func
(paren
id|old_array
)paren
suffix:semicolon
)brace
DECL|function|lookup_hash
r_void
op_star
id|lookup_hash
c_func
(paren
r_int
r_int
id|hash
comma
r_struct
id|hash_table
op_star
id|table
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|table-&gt;array
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
op_amp
id|lookup_hash_entry
c_func
(paren
id|hash
comma
id|table
)paren
op_member_access_from_pointer
id|ptr
suffix:semicolon
)brace
DECL|function|insert_hash
r_void
op_star
op_star
id|insert_hash
c_func
(paren
r_int
r_int
id|hash
comma
r_void
op_star
id|ptr
comma
r_struct
id|hash_table
op_star
id|table
)paren
(brace
r_int
r_int
id|nr
op_assign
id|table-&gt;nr
suffix:semicolon
r_if
c_cond
(paren
id|nr
op_ge
id|table-&gt;size
op_div
l_int|2
)paren
id|grow_hash_table
c_func
(paren
id|table
)paren
suffix:semicolon
r_return
id|insert_hash_entry
c_func
(paren
id|hash
comma
id|ptr
comma
id|table
)paren
suffix:semicolon
)brace
DECL|function|for_each_hash
r_int
id|for_each_hash
c_func
(paren
r_struct
id|hash_table
op_star
id|table
comma
r_int
(paren
op_star
id|fn
)paren
(paren
r_void
op_star
)paren
)paren
(brace
r_int
id|sum
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_int
r_int
id|size
op_assign
id|table-&gt;size
suffix:semicolon
r_struct
id|hash_table_entry
op_star
id|array
op_assign
id|table-&gt;array
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|size
suffix:semicolon
id|i
op_increment
)paren
(brace
r_void
op_star
id|ptr
op_assign
id|array-&gt;ptr
suffix:semicolon
id|array
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|ptr
)paren
(brace
r_int
id|val
op_assign
id|fn
c_func
(paren
id|ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val
OL
l_int|0
)paren
r_return
id|val
suffix:semicolon
id|sum
op_add_assign
id|val
suffix:semicolon
)brace
)brace
r_return
id|sum
suffix:semicolon
)brace
DECL|function|free_hash
r_void
id|free_hash
c_func
(paren
r_struct
id|hash_table
op_star
id|table
)paren
(brace
id|free
c_func
(paren
id|table-&gt;array
)paren
suffix:semicolon
id|table-&gt;array
op_assign
l_int|NULL
suffix:semicolon
id|table-&gt;size
op_assign
l_int|0
suffix:semicolon
id|table-&gt;nr
op_assign
l_int|0
suffix:semicolon
)brace
eof
