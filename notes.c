macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;notes.h&quot;
macro_line|#include &quot;blob.h&quot;
macro_line|#include &quot;tree.h&quot;
macro_line|#include &quot;utf8.h&quot;
macro_line|#include &quot;strbuf.h&quot;
macro_line|#include &quot;tree-walk.h&quot;
macro_line|#include &quot;string-list.h&quot;
macro_line|#include &quot;refs.h&quot;
multiline_comment|/*&n; * Use a non-balancing simple 16-tree structure with struct int_node as&n; * internal nodes, and struct leaf_node as leaf nodes. Each int_node has a&n; * 16-array of pointers to its children.&n; * The bottom 2 bits of each pointer is used to identify the pointer type&n; * - ptr &amp; 3 == 0 - NULL pointer, assert(ptr == NULL)&n; * - ptr &amp; 3 == 1 - pointer to next internal node - cast to struct int_node *&n; * - ptr &amp; 3 == 2 - pointer to note entry - cast to struct leaf_node *&n; * - ptr &amp; 3 == 3 - pointer to subtree entry - cast to struct leaf_node *&n; *&n; * The root node is a statically allocated struct int_node.&n; */
DECL|struct|int_node
r_struct
id|int_node
(brace
DECL|member|a
r_void
op_star
id|a
(braket
l_int|16
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Leaf nodes come in two variants, note entries and subtree entries,&n; * distinguished by the LSb of the leaf node pointer (see above).&n; * As a note entry, the key is the SHA1 of the referenced object, and the&n; * value is the SHA1 of the note object.&n; * As a subtree entry, the key is the prefix SHA1 (w/trailing NULs) of the&n; * referenced object, using the last byte of the key to store the length of&n; * the prefix. The value is the SHA1 of the tree object containing the notes&n; * subtree.&n; */
DECL|struct|leaf_node
r_struct
id|leaf_node
(brace
DECL|member|key_sha1
r_int
r_char
id|key_sha1
(braket
l_int|20
)braket
suffix:semicolon
DECL|member|val_sha1
r_int
r_char
id|val_sha1
(braket
l_int|20
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * A notes tree may contain entries that are not notes, and that do not follow&n; * the naming conventions of notes. There are typically none/few of these, but&n; * we still need to keep track of them. Keep a simple linked list sorted alpha-&n; * betically on the non-note path. The list is populated when parsing tree&n; * objects in load_subtree(), and the non-notes are correctly written back into&n; * the tree objects produced by write_notes_tree().&n; */
DECL|struct|non_note
r_struct
id|non_note
(brace
DECL|member|next
r_struct
id|non_note
op_star
id|next
suffix:semicolon
multiline_comment|/* grounded (last-&gt;next == NULL) */
DECL|member|path
r_char
op_star
id|path
suffix:semicolon
DECL|member|mode
r_int
r_int
id|mode
suffix:semicolon
DECL|member|sha1
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|PTR_TYPE_NULL
mdefine_line|#define PTR_TYPE_NULL     0
DECL|macro|PTR_TYPE_INTERNAL
mdefine_line|#define PTR_TYPE_INTERNAL 1
DECL|macro|PTR_TYPE_NOTE
mdefine_line|#define PTR_TYPE_NOTE     2
DECL|macro|PTR_TYPE_SUBTREE
mdefine_line|#define PTR_TYPE_SUBTREE  3
DECL|macro|GET_PTR_TYPE
mdefine_line|#define GET_PTR_TYPE(ptr)       ((uintptr_t) (ptr) &amp; 3)
DECL|macro|CLR_PTR_TYPE
mdefine_line|#define CLR_PTR_TYPE(ptr)       ((void *) ((uintptr_t) (ptr) &amp; ~3))
DECL|macro|SET_PTR_TYPE
mdefine_line|#define SET_PTR_TYPE(ptr, type) ((void *) ((uintptr_t) (ptr) | (type)))
DECL|macro|GET_NIBBLE
mdefine_line|#define GET_NIBBLE(n, sha1) (((sha1[(n) &gt;&gt; 1]) &gt;&gt; ((~(n) &amp; 0x01) &lt;&lt; 2)) &amp; 0x0f)
DECL|macro|SUBTREE_SHA1_PREFIXCMP
mdefine_line|#define SUBTREE_SHA1_PREFIXCMP(key_sha1, subtree_sha1) &bslash;&n;&t;(memcmp(key_sha1, subtree_sha1, subtree_sha1[19]))
DECL|variable|default_notes_tree
r_struct
id|notes_tree
id|default_notes_tree
suffix:semicolon
DECL|variable|display_notes_refs
r_static
r_struct
id|string_list
id|display_notes_refs
suffix:semicolon
DECL|variable|display_notes_trees
r_static
r_struct
id|notes_tree
op_star
op_star
id|display_notes_trees
suffix:semicolon
r_static
r_void
id|load_subtree
c_func
(paren
r_struct
id|notes_tree
op_star
id|t
comma
r_struct
id|leaf_node
op_star
id|subtree
comma
r_struct
id|int_node
op_star
id|node
comma
r_int
r_int
id|n
)paren
suffix:semicolon
multiline_comment|/*&n; * Search the tree until the appropriate location for the given key is found:&n; * 1. Start at the root node, with n = 0&n; * 2. If a[0] at the current level is a matching subtree entry, unpack that&n; *    subtree entry and remove it; restart search at the current level.&n; * 3. Use the nth nibble of the key as an index into a:&n; *    - If a[n] is an int_node, recurse from #2 into that node and increment n&n; *    - If a matching subtree entry, unpack that subtree entry (and remove it);&n; *      restart search at the current level.&n; *    - Otherwise, we have found one of the following:&n; *      - a subtree entry which does not match the key&n; *      - a note entry which may or may not match the key&n; *      - an unused leaf node (NULL)&n; *      In any case, set *tree and *n, and return pointer to the tree location.&n; */
DECL|function|note_tree_search
r_static
r_void
op_star
op_star
id|note_tree_search
c_func
(paren
r_struct
id|notes_tree
op_star
id|t
comma
r_struct
id|int_node
op_star
op_star
id|tree
comma
r_int
r_char
op_star
id|n
comma
r_const
r_int
r_char
op_star
id|key_sha1
)paren
(brace
r_struct
id|leaf_node
op_star
id|l
suffix:semicolon
r_int
r_char
id|i
suffix:semicolon
r_void
op_star
id|p
op_assign
(paren
op_star
id|tree
)paren
op_member_access_from_pointer
id|a
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|GET_PTR_TYPE
c_func
(paren
id|p
)paren
op_eq
id|PTR_TYPE_SUBTREE
)paren
(brace
id|l
op_assign
(paren
r_struct
id|leaf_node
op_star
)paren
id|CLR_PTR_TYPE
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SUBTREE_SHA1_PREFIXCMP
c_func
(paren
id|key_sha1
comma
id|l-&gt;key_sha1
)paren
)paren
(brace
multiline_comment|/* unpack tree and resume search */
(paren
op_star
id|tree
)paren
op_member_access_from_pointer
id|a
(braket
l_int|0
)braket
op_assign
l_int|NULL
suffix:semicolon
id|load_subtree
c_func
(paren
id|t
comma
id|l
comma
op_star
id|tree
comma
op_star
id|n
)paren
suffix:semicolon
id|free
c_func
(paren
id|l
)paren
suffix:semicolon
r_return
id|note_tree_search
c_func
(paren
id|t
comma
id|tree
comma
id|n
comma
id|key_sha1
)paren
suffix:semicolon
)brace
)brace
id|i
op_assign
id|GET_NIBBLE
c_func
(paren
op_star
id|n
comma
id|key_sha1
)paren
suffix:semicolon
id|p
op_assign
(paren
op_star
id|tree
)paren
op_member_access_from_pointer
id|a
(braket
id|i
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|GET_PTR_TYPE
c_func
(paren
id|p
)paren
)paren
(brace
r_case
id|PTR_TYPE_INTERNAL
suffix:colon
op_star
id|tree
op_assign
id|CLR_PTR_TYPE
c_func
(paren
id|p
)paren
suffix:semicolon
(paren
op_star
id|n
)paren
op_increment
suffix:semicolon
r_return
id|note_tree_search
c_func
(paren
id|t
comma
id|tree
comma
id|n
comma
id|key_sha1
)paren
suffix:semicolon
r_case
id|PTR_TYPE_SUBTREE
suffix:colon
id|l
op_assign
(paren
r_struct
id|leaf_node
op_star
)paren
id|CLR_PTR_TYPE
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SUBTREE_SHA1_PREFIXCMP
c_func
(paren
id|key_sha1
comma
id|l-&gt;key_sha1
)paren
)paren
(brace
multiline_comment|/* unpack tree and resume search */
(paren
op_star
id|tree
)paren
op_member_access_from_pointer
id|a
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|load_subtree
c_func
(paren
id|t
comma
id|l
comma
op_star
id|tree
comma
op_star
id|n
)paren
suffix:semicolon
id|free
c_func
(paren
id|l
)paren
suffix:semicolon
r_return
id|note_tree_search
c_func
(paren
id|t
comma
id|tree
comma
id|n
comma
id|key_sha1
)paren
suffix:semicolon
)brace
multiline_comment|/* fall through */
r_default
suffix:colon
r_return
op_amp
(paren
(paren
op_star
id|tree
)paren
op_member_access_from_pointer
id|a
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * To find a leaf_node:&n; * Search to the tree location appropriate for the given key:&n; * If a note entry with matching key, return the note entry, else return NULL.&n; */
DECL|function|note_tree_find
r_static
r_struct
id|leaf_node
op_star
id|note_tree_find
c_func
(paren
r_struct
id|notes_tree
op_star
id|t
comma
r_struct
id|int_node
op_star
id|tree
comma
r_int
r_char
id|n
comma
r_const
r_int
r_char
op_star
id|key_sha1
)paren
(brace
r_void
op_star
op_star
id|p
op_assign
id|note_tree_search
c_func
(paren
id|t
comma
op_amp
id|tree
comma
op_amp
id|n
comma
id|key_sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GET_PTR_TYPE
c_func
(paren
op_star
id|p
)paren
op_eq
id|PTR_TYPE_NOTE
)paren
(brace
r_struct
id|leaf_node
op_star
id|l
op_assign
(paren
r_struct
id|leaf_node
op_star
)paren
id|CLR_PTR_TYPE
c_func
(paren
op_star
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hashcmp
c_func
(paren
id|key_sha1
comma
id|l-&gt;key_sha1
)paren
)paren
r_return
id|l
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * To insert a leaf_node:&n; * Search to the tree location appropriate for the given leaf_node&squot;s key:&n; * - If location is unused (NULL), store the tweaked pointer directly there&n; * - If location holds a note entry that matches the note-to-be-inserted, then&n; *   combine the two notes (by calling the given combine_notes function).&n; * - If location holds a note entry that matches the subtree-to-be-inserted,&n; *   then unpack the subtree-to-be-inserted into the location.&n; * - If location holds a matching subtree entry, unpack the subtree at that&n; *   location, and restart the insert operation from that level.&n; * - Else, create a new int_node, holding both the node-at-location and the&n; *   node-to-be-inserted, and store the new int_node into the location.&n; */
DECL|function|note_tree_insert
r_static
r_void
id|note_tree_insert
c_func
(paren
r_struct
id|notes_tree
op_star
id|t
comma
r_struct
id|int_node
op_star
id|tree
comma
r_int
r_char
id|n
comma
r_struct
id|leaf_node
op_star
id|entry
comma
r_int
r_char
id|type
comma
id|combine_notes_fn
id|combine_notes
)paren
(brace
r_struct
id|int_node
op_star
id|new_node
suffix:semicolon
r_struct
id|leaf_node
op_star
id|l
suffix:semicolon
r_void
op_star
op_star
id|p
op_assign
id|note_tree_search
c_func
(paren
id|t
comma
op_amp
id|tree
comma
op_amp
id|n
comma
id|entry-&gt;key_sha1
)paren
suffix:semicolon
m_assert
(paren
id|GET_PTR_TYPE
c_func
(paren
id|entry
)paren
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/* no type bits set */
id|l
op_assign
(paren
r_struct
id|leaf_node
op_star
)paren
id|CLR_PTR_TYPE
c_func
(paren
op_star
id|p
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|GET_PTR_TYPE
c_func
(paren
op_star
id|p
)paren
)paren
(brace
r_case
id|PTR_TYPE_NULL
suffix:colon
m_assert
(paren
op_logical_neg
op_star
id|p
)paren
suffix:semicolon
op_star
id|p
op_assign
id|SET_PTR_TYPE
c_func
(paren
id|entry
comma
id|type
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|PTR_TYPE_NOTE
suffix:colon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|PTR_TYPE_NOTE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|hashcmp
c_func
(paren
id|l-&gt;key_sha1
comma
id|entry-&gt;key_sha1
)paren
)paren
(brace
multiline_comment|/* skip concatenation if l == entry */
r_if
c_cond
(paren
op_logical_neg
id|hashcmp
c_func
(paren
id|l-&gt;val_sha1
comma
id|entry-&gt;val_sha1
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|combine_notes
c_func
(paren
id|l-&gt;val_sha1
comma
id|entry-&gt;val_sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;failed to combine notes %s and %s&quot;
l_string|&quot; for object %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|l-&gt;val_sha1
)paren
comma
id|sha1_to_hex
c_func
(paren
id|entry-&gt;val_sha1
)paren
comma
id|sha1_to_hex
c_func
(paren
id|l-&gt;key_sha1
)paren
)paren
suffix:semicolon
id|free
c_func
(paren
id|entry
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|PTR_TYPE_SUBTREE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|SUBTREE_SHA1_PREFIXCMP
c_func
(paren
id|l-&gt;key_sha1
comma
id|entry-&gt;key_sha1
)paren
)paren
(brace
multiline_comment|/* unpack &squot;entry&squot; */
id|load_subtree
c_func
(paren
id|t
comma
id|entry
comma
id|tree
comma
id|n
)paren
suffix:semicolon
id|free
c_func
(paren
id|entry
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|PTR_TYPE_SUBTREE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|SUBTREE_SHA1_PREFIXCMP
c_func
(paren
id|entry-&gt;key_sha1
comma
id|l-&gt;key_sha1
)paren
)paren
(brace
multiline_comment|/* unpack &squot;l&squot; and restart insert */
op_star
id|p
op_assign
l_int|NULL
suffix:semicolon
id|load_subtree
c_func
(paren
id|t
comma
id|l
comma
id|tree
comma
id|n
)paren
suffix:semicolon
id|free
c_func
(paren
id|l
)paren
suffix:semicolon
id|note_tree_insert
c_func
(paren
id|t
comma
id|tree
comma
id|n
comma
id|entry
comma
id|type
comma
id|combine_notes
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/* non-matching leaf_node */
m_assert
(paren
id|GET_PTR_TYPE
c_func
(paren
op_star
id|p
)paren
op_eq
id|PTR_TYPE_NOTE
op_logical_or
id|GET_PTR_TYPE
c_func
(paren
op_star
id|p
)paren
op_eq
id|PTR_TYPE_SUBTREE
)paren
suffix:semicolon
id|new_node
op_assign
(paren
r_struct
id|int_node
op_star
)paren
id|xcalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|int_node
)paren
comma
l_int|1
)paren
suffix:semicolon
id|note_tree_insert
c_func
(paren
id|t
comma
id|new_node
comma
id|n
op_plus
l_int|1
comma
id|l
comma
id|GET_PTR_TYPE
c_func
(paren
op_star
id|p
)paren
comma
id|combine_notes
)paren
suffix:semicolon
op_star
id|p
op_assign
id|SET_PTR_TYPE
c_func
(paren
id|new_node
comma
id|PTR_TYPE_INTERNAL
)paren
suffix:semicolon
id|note_tree_insert
c_func
(paren
id|t
comma
id|new_node
comma
id|n
op_plus
l_int|1
comma
id|entry
comma
id|type
comma
id|combine_notes
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * How to consolidate an int_node:&n; * If there are &gt; 1 non-NULL entries, give up and return non-zero.&n; * Otherwise replace the int_node at the given index in the given parent node&n; * with the only entry (or a NULL entry if no entries) from the given tree,&n; * and return 0.&n; */
DECL|function|note_tree_consolidate
r_static
r_int
id|note_tree_consolidate
c_func
(paren
r_struct
id|int_node
op_star
id|tree
comma
r_struct
id|int_node
op_star
id|parent
comma
r_int
r_char
id|index
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_void
op_star
id|p
op_assign
l_int|NULL
suffix:semicolon
m_assert
(paren
id|tree
op_logical_and
id|parent
)paren
suffix:semicolon
m_assert
(paren
id|CLR_PTR_TYPE
c_func
(paren
id|parent-&gt;a
(braket
id|index
)braket
)paren
op_eq
id|tree
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|GET_PTR_TYPE
c_func
(paren
id|tree-&gt;a
(braket
id|i
)braket
)paren
op_ne
id|PTR_TYPE_NULL
)paren
(brace
r_if
c_cond
(paren
id|p
)paren
multiline_comment|/* more than one entry */
r_return
l_int|2
suffix:semicolon
id|p
op_assign
id|tree-&gt;a
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
multiline_comment|/* replace tree with p in parent[index] */
id|parent-&gt;a
(braket
id|index
)braket
op_assign
id|p
suffix:semicolon
id|free
c_func
(paren
id|tree
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * To remove a leaf_node:&n; * Search to the tree location appropriate for the given leaf_node&squot;s key:&n; * - If location does not hold a matching entry, abort and do nothing.&n; * - Replace the matching leaf_node with a NULL entry (and free the leaf_node).&n; * - Consolidate int_nodes repeatedly, while walking up the tree towards root.&n; */
DECL|function|note_tree_remove
r_static
r_void
id|note_tree_remove
c_func
(paren
r_struct
id|notes_tree
op_star
id|t
comma
r_struct
id|int_node
op_star
id|tree
comma
r_int
r_char
id|n
comma
r_struct
id|leaf_node
op_star
id|entry
)paren
(brace
r_struct
id|leaf_node
op_star
id|l
suffix:semicolon
r_struct
id|int_node
op_star
id|parent_stack
(braket
l_int|20
)braket
suffix:semicolon
r_int
r_char
id|i
comma
id|j
suffix:semicolon
r_void
op_star
op_star
id|p
op_assign
id|note_tree_search
c_func
(paren
id|t
comma
op_amp
id|tree
comma
op_amp
id|n
comma
id|entry-&gt;key_sha1
)paren
suffix:semicolon
m_assert
(paren
id|GET_PTR_TYPE
c_func
(paren
id|entry
)paren
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/* no type bits set */
r_if
c_cond
(paren
id|GET_PTR_TYPE
c_func
(paren
op_star
id|p
)paren
op_ne
id|PTR_TYPE_NOTE
)paren
r_return
suffix:semicolon
multiline_comment|/* type mismatch, nothing to remove */
id|l
op_assign
(paren
r_struct
id|leaf_node
op_star
)paren
id|CLR_PTR_TYPE
c_func
(paren
op_star
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hashcmp
c_func
(paren
id|l-&gt;key_sha1
comma
id|entry-&gt;key_sha1
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* key mismatch, nothing to remove */
multiline_comment|/* we have found a matching entry */
id|free
c_func
(paren
id|l
)paren
suffix:semicolon
op_star
id|p
op_assign
id|SET_PTR_TYPE
c_func
(paren
l_int|NULL
comma
id|PTR_TYPE_NULL
)paren
suffix:semicolon
multiline_comment|/* consolidate this tree level, and parent levels, if possible */
r_if
c_cond
(paren
op_logical_neg
id|n
)paren
r_return
suffix:semicolon
multiline_comment|/* cannot consolidate top level */
multiline_comment|/* first, build stack of ancestors between root and current node */
id|parent_stack
(braket
l_int|0
)braket
op_assign
id|t-&gt;root
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
(brace
id|j
op_assign
id|GET_NIBBLE
c_func
(paren
id|i
comma
id|entry-&gt;key_sha1
)paren
suffix:semicolon
id|parent_stack
(braket
id|i
op_plus
l_int|1
)braket
op_assign
id|CLR_PTR_TYPE
c_func
(paren
id|parent_stack
(braket
id|i
)braket
op_member_access_from_pointer
id|a
(braket
id|j
)braket
)paren
suffix:semicolon
)brace
m_assert
(paren
id|i
op_eq
id|n
op_logical_and
id|parent_stack
(braket
id|i
)braket
op_eq
id|tree
)paren
suffix:semicolon
multiline_comment|/* next, unwind stack until note_tree_consolidate() is done */
r_while
c_loop
(paren
id|i
OG
l_int|0
op_logical_and
op_logical_neg
id|note_tree_consolidate
c_func
(paren
id|parent_stack
(braket
id|i
)braket
comma
id|parent_stack
(braket
id|i
l_int|1
)braket
comma
id|GET_NIBBLE
c_func
(paren
id|i
l_int|1
comma
id|entry-&gt;key_sha1
)paren
)paren
)paren
id|i
op_decrement
suffix:semicolon
)brace
multiline_comment|/* Free the entire notes data contained in the given tree */
DECL|function|note_tree_free
r_static
r_void
id|note_tree_free
c_func
(paren
r_struct
id|int_node
op_star
id|tree
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
r_void
op_star
id|p
op_assign
id|tree-&gt;a
(braket
id|i
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|GET_PTR_TYPE
c_func
(paren
id|p
)paren
)paren
(brace
r_case
id|PTR_TYPE_INTERNAL
suffix:colon
id|note_tree_free
c_func
(paren
id|CLR_PTR_TYPE
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
multiline_comment|/* fall through */
r_case
id|PTR_TYPE_NOTE
suffix:colon
r_case
id|PTR_TYPE_SUBTREE
suffix:colon
id|free
c_func
(paren
id|CLR_PTR_TYPE
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Convert a partial SHA1 hex string to the corresponding partial SHA1 value.&n; * - hex      - Partial SHA1 segment in ASCII hex format&n; * - hex_len  - Length of above segment. Must be multiple of 2 between 0 and 40&n; * - sha1     - Partial SHA1 value is written here&n; * - sha1_len - Max #bytes to store in sha1, Must be &gt;= hex_len / 2, and &lt; 20&n; * Returns -1 on error (invalid arguments or invalid SHA1 (not in hex format)).&n; * Otherwise, returns number of bytes written to sha1 (i.e. hex_len / 2).&n; * Pads sha1 with NULs up to sha1_len (not included in returned length).&n; */
DECL|function|get_sha1_hex_segment
r_static
r_int
id|get_sha1_hex_segment
c_func
(paren
r_const
r_char
op_star
id|hex
comma
r_int
r_int
id|hex_len
comma
r_int
r_char
op_star
id|sha1
comma
r_int
r_int
id|sha1_len
)paren
(brace
r_int
r_int
id|i
comma
id|len
op_assign
id|hex_len
op_rshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|hex_len
op_mod
l_int|2
op_ne
l_int|0
op_logical_or
id|len
OG
id|sha1_len
)paren
r_return
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|val
op_assign
(paren
id|hexval
c_func
(paren
id|hex
(braket
l_int|0
)braket
)paren
op_lshift
l_int|4
)paren
op_or
id|hexval
c_func
(paren
id|hex
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val
op_amp
op_complement
l_int|0xff
)paren
r_return
l_int|1
suffix:semicolon
op_star
id|sha1
op_increment
op_assign
id|val
suffix:semicolon
id|hex
op_add_assign
l_int|2
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
id|sha1_len
suffix:semicolon
id|i
op_increment
)paren
op_star
id|sha1
op_increment
op_assign
l_int|0
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
DECL|function|non_note_cmp
r_static
r_int
id|non_note_cmp
c_func
(paren
r_const
r_struct
id|non_note
op_star
id|a
comma
r_const
r_struct
id|non_note
op_star
id|b
)paren
(brace
r_return
id|strcmp
c_func
(paren
id|a-&gt;path
comma
id|b-&gt;path
)paren
suffix:semicolon
)brace
DECL|function|add_non_note
r_static
r_void
id|add_non_note
c_func
(paren
r_struct
id|notes_tree
op_star
id|t
comma
r_const
r_char
op_star
id|path
comma
r_int
r_int
id|mode
comma
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_struct
id|non_note
op_star
id|p
op_assign
id|t-&gt;prev_non_note
comma
op_star
id|n
suffix:semicolon
id|n
op_assign
(paren
r_struct
id|non_note
op_star
)paren
id|xmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|non_note
)paren
)paren
suffix:semicolon
id|n-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|n-&gt;path
op_assign
id|xstrdup
c_func
(paren
id|path
)paren
suffix:semicolon
id|n-&gt;mode
op_assign
id|mode
suffix:semicolon
id|hashcpy
c_func
(paren
id|n-&gt;sha1
comma
id|sha1
)paren
suffix:semicolon
id|t-&gt;prev_non_note
op_assign
id|n
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|t-&gt;first_non_note
)paren
(brace
id|t-&gt;first_non_note
op_assign
id|n
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|non_note_cmp
c_func
(paren
id|p
comma
id|n
)paren
OL
l_int|0
)paren
suffix:semicolon
multiline_comment|/* do nothing  */
r_else
r_if
c_cond
(paren
id|non_note_cmp
c_func
(paren
id|t-&gt;first_non_note
comma
id|n
)paren
op_le
l_int|0
)paren
id|p
op_assign
id|t-&gt;first_non_note
suffix:semicolon
r_else
(brace
multiline_comment|/* n sorts before t-&gt;first_non_note */
id|n-&gt;next
op_assign
id|t-&gt;first_non_note
suffix:semicolon
id|t-&gt;first_non_note
op_assign
id|n
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* n sorts equal or after p */
r_while
c_loop
(paren
id|p-&gt;next
op_logical_and
id|non_note_cmp
c_func
(paren
id|p-&gt;next
comma
id|n
)paren
op_le
l_int|0
)paren
id|p
op_assign
id|p-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|non_note_cmp
c_func
(paren
id|p
comma
id|n
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* n ~= p; overwrite p with n */
m_assert
(paren
id|strcmp
c_func
(paren
id|p-&gt;path
comma
id|n-&gt;path
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|p-&gt;mode
op_assign
id|n-&gt;mode
suffix:semicolon
id|hashcpy
c_func
(paren
id|p-&gt;sha1
comma
id|n-&gt;sha1
)paren
suffix:semicolon
id|free
c_func
(paren
id|n
)paren
suffix:semicolon
id|t-&gt;prev_non_note
op_assign
id|p
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* n sorts between p and p-&gt;next */
id|n-&gt;next
op_assign
id|p-&gt;next
suffix:semicolon
id|p-&gt;next
op_assign
id|n
suffix:semicolon
)brace
DECL|function|load_subtree
r_static
r_void
id|load_subtree
c_func
(paren
r_struct
id|notes_tree
op_star
id|t
comma
r_struct
id|leaf_node
op_star
id|subtree
comma
r_struct
id|int_node
op_star
id|node
comma
r_int
r_int
id|n
)paren
(brace
r_int
r_char
id|object_sha1
(braket
l_int|20
)braket
suffix:semicolon
r_int
r_int
id|prefix_len
suffix:semicolon
r_void
op_star
id|buf
suffix:semicolon
r_struct
id|tree_desc
id|desc
suffix:semicolon
r_struct
id|name_entry
id|entry
suffix:semicolon
r_int
id|len
comma
id|path_len
suffix:semicolon
r_int
r_char
id|type
suffix:semicolon
r_struct
id|leaf_node
op_star
id|l
suffix:semicolon
id|buf
op_assign
id|fill_tree_descriptor
c_func
(paren
op_amp
id|desc
comma
id|subtree-&gt;val_sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
id|die
c_func
(paren
l_string|&quot;Could not read %s for notes-index&quot;
comma
id|sha1_to_hex
c_func
(paren
id|subtree-&gt;val_sha1
)paren
)paren
suffix:semicolon
id|prefix_len
op_assign
id|subtree-&gt;key_sha1
(braket
l_int|19
)braket
suffix:semicolon
m_assert
(paren
id|prefix_len
op_star
l_int|2
op_ge
id|n
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|object_sha1
comma
id|subtree-&gt;key_sha1
comma
id|prefix_len
)paren
suffix:semicolon
r_while
c_loop
(paren
id|tree_entry
c_func
(paren
op_amp
id|desc
comma
op_amp
id|entry
)paren
)paren
(brace
id|path_len
op_assign
id|strlen
c_func
(paren
id|entry.path
)paren
suffix:semicolon
id|len
op_assign
id|get_sha1_hex_segment
c_func
(paren
id|entry.path
comma
id|path_len
comma
id|object_sha1
op_plus
id|prefix_len
comma
l_int|20
id|prefix_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
r_goto
id|handle_non_note
suffix:semicolon
multiline_comment|/* entry.path is not a SHA1 */
id|len
op_add_assign
id|prefix_len
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If object SHA1 is complete (len == 20), assume note object&n;&t;&t; * If object SHA1 is incomplete (len &lt; 20), and current&n;&t;&t; * component consists of 2 hex chars, assume note subtree&n;&t;&t; */
r_if
c_cond
(paren
id|len
op_le
l_int|20
)paren
(brace
id|type
op_assign
id|PTR_TYPE_NOTE
suffix:semicolon
id|l
op_assign
(paren
r_struct
id|leaf_node
op_star
)paren
id|xcalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|leaf_node
)paren
comma
l_int|1
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|l-&gt;key_sha1
comma
id|object_sha1
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|l-&gt;val_sha1
comma
id|entry.sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|20
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|S_ISDIR
c_func
(paren
id|entry.mode
)paren
op_logical_or
id|path_len
op_ne
l_int|2
)paren
r_goto
id|handle_non_note
suffix:semicolon
multiline_comment|/* not subtree */
id|l-&gt;key_sha1
(braket
l_int|19
)braket
op_assign
(paren
r_int
r_char
)paren
id|len
suffix:semicolon
id|type
op_assign
id|PTR_TYPE_SUBTREE
suffix:semicolon
)brace
id|note_tree_insert
c_func
(paren
id|t
comma
id|node
comma
id|n
comma
id|l
comma
id|type
comma
id|combine_notes_concatenate
)paren
suffix:semicolon
)brace
r_continue
suffix:semicolon
id|handle_non_note
suffix:colon
multiline_comment|/*&n;&t;&t; * Determine full path for this non-note entry:&n;&t;&t; * The filename is already found in entry.path, but the&n;&t;&t; * directory part of the path must be deduced from the subtree&n;&t;&t; * containing this entry. We assume here that the overall notes&n;&t;&t; * tree follows a strict byte-based progressive fanout&n;&t;&t; * structure (i.e. using 2/38, 2/2/36, etc. fanouts, and not&n;&t;&t; * e.g. 4/36 fanout). This means that if a non-note is found at&n;&t;&t; * path &quot;dead/beef&quot;, the following code will register it as&n;&t;&t; * being found on &quot;de/ad/beef&quot;.&n;&t;&t; * On the other hand, if you use such non-obvious non-note&n;&t;&t; * paths in the middle of a notes tree, you deserve what&squot;s&n;&t;&t; * coming to you ;). Note that for non-notes that are not&n;&t;&t; * SHA1-like at the top level, there will be no problems.&n;&t;&t; *&n;&t;&t; * To conclude, it is strongly advised to make sure non-notes&n;&t;&t; * have at least one non-hex character in the top-level path&n;&t;&t; * component.&n;&t;&t; */
(brace
r_char
id|non_note_path
(braket
id|PATH_MAX
)braket
suffix:semicolon
r_char
op_star
id|p
op_assign
id|non_note_path
suffix:semicolon
r_const
r_char
op_star
id|q
op_assign
id|sha1_to_hex
c_func
(paren
id|subtree-&gt;key_sha1
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|prefix_len
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|p
op_increment
op_assign
op_star
id|q
op_increment
suffix:semicolon
op_star
id|p
op_increment
op_assign
op_star
id|q
op_increment
suffix:semicolon
op_star
id|p
op_increment
op_assign
l_char|&squot;/&squot;
suffix:semicolon
)brace
id|strcpy
c_func
(paren
id|p
comma
id|entry.path
)paren
suffix:semicolon
id|add_non_note
c_func
(paren
id|t
comma
id|non_note_path
comma
id|entry.mode
comma
id|entry.sha1
)paren
suffix:semicolon
)brace
)brace
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Determine optimal on-disk fanout for this part of the notes tree&n; *&n; * Given a (sub)tree and the level in the internal tree structure, determine&n; * whether or not the given existing fanout should be expanded for this&n; * (sub)tree.&n; *&n; * Values of the &squot;fanout&squot; variable:&n; * - 0: No fanout (all notes are stored directly in the root notes tree)&n; * - 1: 2/38 fanout&n; * - 2: 2/2/36 fanout&n; * - 3: 2/2/2/34 fanout&n; * etc.&n; */
DECL|function|determine_fanout
r_static
r_int
r_char
id|determine_fanout
c_func
(paren
r_struct
id|int_node
op_star
id|tree
comma
r_int
r_char
id|n
comma
r_int
r_char
id|fanout
)paren
(brace
multiline_comment|/*&n;&t; * The following is a simple heuristic that works well in practice:&n;&t; * For each even-numbered 16-tree level (remember that each on-disk&n;&t; * fanout level corresponds to _two_ 16-tree levels), peek at all 16&n;&t; * entries at that tree level. If all of them are either int_nodes or&n;&t; * subtree entries, then there are likely plenty of notes below this&n;&t; * level, so we return an incremented fanout.&n;&t; */
r_int
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
id|n
op_mod
l_int|2
)paren
op_logical_or
(paren
id|n
OG
l_int|2
op_star
id|fanout
)paren
)paren
r_return
id|fanout
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
r_switch
c_cond
(paren
id|GET_PTR_TYPE
c_func
(paren
id|tree-&gt;a
(braket
id|i
)braket
)paren
)paren
(brace
r_case
id|PTR_TYPE_SUBTREE
suffix:colon
r_case
id|PTR_TYPE_INTERNAL
suffix:colon
r_continue
suffix:semicolon
r_default
suffix:colon
r_return
id|fanout
suffix:semicolon
)brace
)brace
r_return
id|fanout
op_plus
l_int|1
suffix:semicolon
)brace
DECL|function|construct_path_with_fanout
r_static
r_void
id|construct_path_with_fanout
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
r_char
id|fanout
comma
r_char
op_star
id|path
)paren
(brace
r_int
r_int
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
suffix:semicolon
r_const
r_char
op_star
id|hex_sha1
op_assign
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
suffix:semicolon
m_assert
(paren
id|fanout
OL
l_int|20
)paren
suffix:semicolon
r_while
c_loop
(paren
id|fanout
)paren
(brace
id|path
(braket
id|i
op_increment
)braket
op_assign
id|hex_sha1
(braket
id|j
op_increment
)braket
suffix:semicolon
id|path
(braket
id|i
op_increment
)braket
op_assign
id|hex_sha1
(braket
id|j
op_increment
)braket
suffix:semicolon
id|path
(braket
id|i
op_increment
)braket
op_assign
l_char|&squot;/&squot;
suffix:semicolon
id|fanout
op_decrement
suffix:semicolon
)brace
id|strcpy
c_func
(paren
id|path
op_plus
id|i
comma
id|hex_sha1
op_plus
id|j
)paren
suffix:semicolon
)brace
DECL|function|for_each_note_helper
r_static
r_int
id|for_each_note_helper
c_func
(paren
r_struct
id|notes_tree
op_star
id|t
comma
r_struct
id|int_node
op_star
id|tree
comma
r_int
r_char
id|n
comma
r_int
r_char
id|fanout
comma
r_int
id|flags
comma
id|each_note_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_void
op_star
id|p
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_struct
id|leaf_node
op_star
id|l
suffix:semicolon
r_static
r_char
id|path
(braket
l_int|40
op_plus
l_int|19
op_plus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* hex SHA1 + 19 * &squot;/&squot; + NUL */
id|fanout
op_assign
id|determine_fanout
c_func
(paren
id|tree
comma
id|n
comma
id|fanout
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|redo
suffix:colon
id|p
op_assign
id|tree-&gt;a
(braket
id|i
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|GET_PTR_TYPE
c_func
(paren
id|p
)paren
)paren
(brace
r_case
id|PTR_TYPE_INTERNAL
suffix:colon
multiline_comment|/* recurse into int_node */
id|ret
op_assign
id|for_each_note_helper
c_func
(paren
id|t
comma
id|CLR_PTR_TYPE
c_func
(paren
id|p
)paren
comma
id|n
op_plus
l_int|1
comma
id|fanout
comma
id|flags
comma
id|fn
comma
id|cb_data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PTR_TYPE_SUBTREE
suffix:colon
id|l
op_assign
(paren
r_struct
id|leaf_node
op_star
)paren
id|CLR_PTR_TYPE
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Subtree entries in the note tree represent parts of&n;&t;&t;&t; * the note tree that have not yet been explored. There&n;&t;&t;&t; * is a direct relationship between subtree entries at&n;&t;&t;&t; * level &squot;n&squot; in the tree, and the &squot;fanout&squot; variable:&n;&t;&t;&t; * Subtree entries at level &squot;n &lt;= 2 * fanout&squot; should be&n;&t;&t;&t; * preserved, since they correspond exactly to a fanout&n;&t;&t;&t; * directory in the on-disk structure. However, subtree&n;&t;&t;&t; * entries at level &squot;n &gt; 2 * fanout&squot; should NOT be&n;&t;&t;&t; * preserved, but rather consolidated into the above&n;&t;&t;&t; * notes tree level. We achieve this by unconditionally&n;&t;&t;&t; * unpacking subtree entries that exist below the&n;&t;&t;&t; * threshold level at &squot;n = 2 * fanout&squot;.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|n
op_le
l_int|2
op_star
id|fanout
op_logical_and
id|flags
op_amp
id|FOR_EACH_NOTE_YIELD_SUBTREES
)paren
(brace
multiline_comment|/* invoke callback with subtree */
r_int
r_int
id|path_len
op_assign
id|l-&gt;key_sha1
(braket
l_int|19
)braket
op_star
l_int|2
op_plus
id|fanout
suffix:semicolon
m_assert
(paren
id|path_len
OL
l_int|40
op_plus
l_int|19
)paren
suffix:semicolon
id|construct_path_with_fanout
c_func
(paren
id|l-&gt;key_sha1
comma
id|fanout
comma
id|path
)paren
suffix:semicolon
multiline_comment|/* Create trailing slash, if needed */
r_if
c_cond
(paren
id|path
(braket
id|path_len
l_int|1
)braket
op_ne
l_char|&squot;/&squot;
)paren
id|path
(braket
id|path_len
op_increment
)braket
op_assign
l_char|&squot;/&squot;
suffix:semicolon
id|path
(braket
id|path_len
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|ret
op_assign
id|fn
c_func
(paren
id|l-&gt;key_sha1
comma
id|l-&gt;val_sha1
comma
id|path
comma
id|cb_data
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|n
OG
id|fanout
op_star
l_int|2
op_logical_or
op_logical_neg
(paren
id|flags
op_amp
id|FOR_EACH_NOTE_DONT_UNPACK_SUBTREES
)paren
)paren
(brace
multiline_comment|/* unpack subtree and resume traversal */
id|tree-&gt;a
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|load_subtree
c_func
(paren
id|t
comma
id|l
comma
id|tree
comma
id|n
)paren
suffix:semicolon
id|free
c_func
(paren
id|l
)paren
suffix:semicolon
r_goto
id|redo
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|PTR_TYPE_NOTE
suffix:colon
id|l
op_assign
(paren
r_struct
id|leaf_node
op_star
)paren
id|CLR_PTR_TYPE
c_func
(paren
id|p
)paren
suffix:semicolon
id|construct_path_with_fanout
c_func
(paren
id|l-&gt;key_sha1
comma
id|fanout
comma
id|path
)paren
suffix:semicolon
id|ret
op_assign
id|fn
c_func
(paren
id|l-&gt;key_sha1
comma
id|l-&gt;val_sha1
comma
id|path
comma
id|cb_data
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|struct|tree_write_stack
r_struct
id|tree_write_stack
(brace
DECL|member|next
r_struct
id|tree_write_stack
op_star
id|next
suffix:semicolon
DECL|member|buf
r_struct
id|strbuf
id|buf
suffix:semicolon
DECL|member|path
r_char
id|path
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* path to subtree in next, if any */
)brace
suffix:semicolon
DECL|function|matches_tree_write_stack
r_static
r_inline
r_int
id|matches_tree_write_stack
c_func
(paren
r_struct
id|tree_write_stack
op_star
id|tws
comma
r_const
r_char
op_star
id|full_path
)paren
(brace
r_return
id|full_path
(braket
l_int|0
)braket
op_eq
id|tws-&gt;path
(braket
l_int|0
)braket
op_logical_and
id|full_path
(braket
l_int|1
)braket
op_eq
id|tws-&gt;path
(braket
l_int|1
)braket
op_logical_and
id|full_path
(braket
l_int|2
)braket
op_eq
l_char|&squot;/&squot;
suffix:semicolon
)brace
DECL|function|write_tree_entry
r_static
r_void
id|write_tree_entry
c_func
(paren
r_struct
id|strbuf
op_star
id|buf
comma
r_int
r_int
id|mode
comma
r_const
r_char
op_star
id|path
comma
r_int
r_int
id|path_len
comma
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
id|strbuf_addf
c_func
(paren
id|buf
comma
l_string|&quot;%o %.*s%c&quot;
comma
id|mode
comma
id|path_len
comma
id|path
comma
l_char|&squot;&bslash;0&squot;
)paren
suffix:semicolon
id|strbuf_add
c_func
(paren
id|buf
comma
id|sha1
comma
l_int|20
)paren
suffix:semicolon
)brace
DECL|function|tree_write_stack_init_subtree
r_static
r_void
id|tree_write_stack_init_subtree
c_func
(paren
r_struct
id|tree_write_stack
op_star
id|tws
comma
r_const
r_char
op_star
id|path
)paren
(brace
r_struct
id|tree_write_stack
op_star
id|n
suffix:semicolon
m_assert
(paren
op_logical_neg
id|tws-&gt;next
)paren
suffix:semicolon
m_assert
(paren
id|tws-&gt;path
(braket
l_int|0
)braket
op_eq
l_char|&squot;&bslash;0&squot;
op_logical_and
id|tws-&gt;path
(braket
l_int|1
)braket
op_eq
l_char|&squot;&bslash;0&squot;
)paren
suffix:semicolon
id|n
op_assign
(paren
r_struct
id|tree_write_stack
op_star
)paren
id|xmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|tree_write_stack
)paren
)paren
suffix:semicolon
id|n-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|n-&gt;buf
comma
l_int|256
op_star
(paren
l_int|32
op_plus
l_int|40
)paren
)paren
suffix:semicolon
multiline_comment|/* assume 256 entries per tree */
id|n-&gt;path
(braket
l_int|0
)braket
op_assign
id|n-&gt;path
(braket
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|tws-&gt;next
op_assign
id|n
suffix:semicolon
id|tws-&gt;path
(braket
l_int|0
)braket
op_assign
id|path
(braket
l_int|0
)braket
suffix:semicolon
id|tws-&gt;path
(braket
l_int|1
)braket
op_assign
id|path
(braket
l_int|1
)braket
suffix:semicolon
)brace
DECL|function|tree_write_stack_finish_subtree
r_static
r_int
id|tree_write_stack_finish_subtree
c_func
(paren
r_struct
id|tree_write_stack
op_star
id|tws
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|tree_write_stack
op_star
id|n
op_assign
id|tws-&gt;next
suffix:semicolon
r_int
r_char
id|s
(braket
l_int|20
)braket
suffix:semicolon
r_if
c_cond
(paren
id|n
)paren
(brace
id|ret
op_assign
id|tree_write_stack_finish_subtree
c_func
(paren
id|n
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
id|ret
op_assign
id|write_sha1_file
c_func
(paren
id|n-&gt;buf.buf
comma
id|n-&gt;buf.len
comma
id|tree_type
comma
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|n-&gt;buf
)paren
suffix:semicolon
id|free
c_func
(paren
id|n
)paren
suffix:semicolon
id|tws-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|write_tree_entry
c_func
(paren
op_amp
id|tws-&gt;buf
comma
l_int|040000
comma
id|tws-&gt;path
comma
l_int|2
comma
id|s
)paren
suffix:semicolon
id|tws-&gt;path
(braket
l_int|0
)braket
op_assign
id|tws-&gt;path
(braket
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|write_each_note_helper
r_static
r_int
id|write_each_note_helper
c_func
(paren
r_struct
id|tree_write_stack
op_star
id|tws
comma
r_const
r_char
op_star
id|path
comma
r_int
r_int
id|mode
comma
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_int
id|path_len
op_assign
id|strlen
c_func
(paren
id|path
)paren
suffix:semicolon
r_int
r_int
id|n
op_assign
l_int|0
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* Determine common part of tree write stack */
r_while
c_loop
(paren
id|tws
op_logical_and
l_int|3
op_star
id|n
OL
id|path_len
op_logical_and
id|matches_tree_write_stack
c_func
(paren
id|tws
comma
id|path
op_plus
l_int|3
op_star
id|n
)paren
)paren
(brace
id|n
op_increment
suffix:semicolon
id|tws
op_assign
id|tws-&gt;next
suffix:semicolon
)brace
multiline_comment|/* tws point to last matching tree_write_stack entry */
id|ret
op_assign
id|tree_write_stack_finish_subtree
c_func
(paren
id|tws
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
multiline_comment|/* Start subtrees needed to satisfy path */
r_while
c_loop
(paren
l_int|3
op_star
id|n
op_plus
l_int|2
OL
id|path_len
op_logical_and
id|path
(braket
l_int|3
op_star
id|n
op_plus
l_int|2
)braket
op_eq
l_char|&squot;/&squot;
)paren
(brace
id|tree_write_stack_init_subtree
c_func
(paren
id|tws
comma
id|path
op_plus
l_int|3
op_star
id|n
)paren
suffix:semicolon
id|n
op_increment
suffix:semicolon
id|tws
op_assign
id|tws-&gt;next
suffix:semicolon
)brace
multiline_comment|/* There should be no more directory components in the given path */
m_assert
(paren
id|memchr
c_func
(paren
id|path
op_plus
l_int|3
op_star
id|n
comma
l_char|&squot;/&squot;
comma
id|path_len
(paren
l_int|3
op_star
id|n
)paren
)paren
op_eq
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Finally add given entry to the current tree object */
id|write_tree_entry
c_func
(paren
op_amp
id|tws-&gt;buf
comma
id|mode
comma
id|path
op_plus
l_int|3
op_star
id|n
comma
id|path_len
(paren
l_int|3
op_star
id|n
)paren
comma
id|sha1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|struct|write_each_note_data
r_struct
id|write_each_note_data
(brace
DECL|member|root
r_struct
id|tree_write_stack
op_star
id|root
suffix:semicolon
DECL|member|next_non_note
r_struct
id|non_note
op_star
id|next_non_note
suffix:semicolon
)brace
suffix:semicolon
DECL|function|write_each_non_note_until
r_static
r_int
id|write_each_non_note_until
c_func
(paren
r_const
r_char
op_star
id|note_path
comma
r_struct
id|write_each_note_data
op_star
id|d
)paren
(brace
r_struct
id|non_note
op_star
id|n
op_assign
id|d-&gt;next_non_note
suffix:semicolon
r_int
id|cmp
op_assign
l_int|0
comma
id|ret
suffix:semicolon
r_while
c_loop
(paren
id|n
op_logical_and
(paren
op_logical_neg
id|note_path
op_logical_or
(paren
id|cmp
op_assign
id|strcmp
c_func
(paren
id|n-&gt;path
comma
id|note_path
)paren
)paren
op_le
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|note_path
op_logical_and
id|cmp
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/* do nothing, prefer note to non-note */
r_else
(brace
id|ret
op_assign
id|write_each_note_helper
c_func
(paren
id|d-&gt;root
comma
id|n-&gt;path
comma
id|n-&gt;mode
comma
id|n-&gt;sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
)brace
id|n
op_assign
id|n-&gt;next
suffix:semicolon
)brace
id|d-&gt;next_non_note
op_assign
id|n
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|write_each_note
r_static
r_int
id|write_each_note
c_func
(paren
r_const
r_int
r_char
op_star
id|object_sha1
comma
r_const
r_int
r_char
op_star
id|note_sha1
comma
r_char
op_star
id|note_path
comma
r_void
op_star
id|cb_data
)paren
(brace
r_struct
id|write_each_note_data
op_star
id|d
op_assign
(paren
r_struct
id|write_each_note_data
op_star
)paren
id|cb_data
suffix:semicolon
r_int
id|note_path_len
op_assign
id|strlen
c_func
(paren
id|note_path
)paren
suffix:semicolon
r_int
r_int
id|mode
op_assign
l_int|0100644
suffix:semicolon
r_if
c_cond
(paren
id|note_path
(braket
id|note_path_len
l_int|1
)braket
op_eq
l_char|&squot;/&squot;
)paren
(brace
multiline_comment|/* subtree entry */
id|note_path_len
op_decrement
suffix:semicolon
id|note_path
(braket
id|note_path_len
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|mode
op_assign
l_int|040000
suffix:semicolon
)brace
m_assert
(paren
id|note_path_len
op_le
l_int|40
op_plus
l_int|19
)paren
suffix:semicolon
multiline_comment|/* Weave non-note entries into note entries */
r_return
id|write_each_non_note_until
c_func
(paren
id|note_path
comma
id|d
)paren
op_logical_or
id|write_each_note_helper
c_func
(paren
id|d-&gt;root
comma
id|note_path
comma
id|mode
comma
id|note_sha1
)paren
suffix:semicolon
)brace
DECL|struct|note_delete_list
r_struct
id|note_delete_list
(brace
DECL|member|next
r_struct
id|note_delete_list
op_star
id|next
suffix:semicolon
DECL|member|sha1
r_const
r_int
r_char
op_star
id|sha1
suffix:semicolon
)brace
suffix:semicolon
DECL|function|prune_notes_helper
r_static
r_int
id|prune_notes_helper
c_func
(paren
r_const
r_int
r_char
op_star
id|object_sha1
comma
r_const
r_int
r_char
op_star
id|note_sha1
comma
r_char
op_star
id|note_path
comma
r_void
op_star
id|cb_data
)paren
(brace
r_struct
id|note_delete_list
op_star
op_star
id|l
op_assign
(paren
r_struct
id|note_delete_list
op_star
op_star
)paren
id|cb_data
suffix:semicolon
r_struct
id|note_delete_list
op_star
id|n
suffix:semicolon
r_if
c_cond
(paren
id|has_sha1_file
c_func
(paren
id|object_sha1
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* nothing to do for this note */
multiline_comment|/* failed to find object =&gt; prune this note */
id|n
op_assign
(paren
r_struct
id|note_delete_list
op_star
)paren
id|xmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|n
)paren
)paren
suffix:semicolon
id|n-&gt;next
op_assign
op_star
id|l
suffix:semicolon
id|n-&gt;sha1
op_assign
id|object_sha1
suffix:semicolon
op_star
id|l
op_assign
id|n
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|combine_notes_concatenate
r_int
id|combine_notes_concatenate
c_func
(paren
r_int
r_char
op_star
id|cur_sha1
comma
r_const
r_int
r_char
op_star
id|new_sha1
)paren
(brace
r_char
op_star
id|cur_msg
op_assign
l_int|NULL
comma
op_star
id|new_msg
op_assign
l_int|NULL
comma
op_star
id|buf
suffix:semicolon
r_int
r_int
id|cur_len
comma
id|new_len
comma
id|buf_len
suffix:semicolon
r_enum
id|object_type
id|cur_type
comma
id|new_type
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* read in both note blob objects */
r_if
c_cond
(paren
op_logical_neg
id|is_null_sha1
c_func
(paren
id|new_sha1
)paren
)paren
id|new_msg
op_assign
id|read_sha1_file
c_func
(paren
id|new_sha1
comma
op_amp
id|new_type
comma
op_amp
id|new_len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_msg
op_logical_or
op_logical_neg
id|new_len
op_logical_or
id|new_type
op_ne
id|OBJ_BLOB
)paren
(brace
id|free
c_func
(paren
id|new_msg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|is_null_sha1
c_func
(paren
id|cur_sha1
)paren
)paren
id|cur_msg
op_assign
id|read_sha1_file
c_func
(paren
id|cur_sha1
comma
op_amp
id|cur_type
comma
op_amp
id|cur_len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cur_msg
op_logical_or
op_logical_neg
id|cur_len
op_logical_or
id|cur_type
op_ne
id|OBJ_BLOB
)paren
(brace
id|free
c_func
(paren
id|cur_msg
)paren
suffix:semicolon
id|free
c_func
(paren
id|new_msg
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|cur_sha1
comma
id|new_sha1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* we will separate the notes by a newline anyway */
r_if
c_cond
(paren
id|cur_msg
(braket
id|cur_len
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|cur_len
op_decrement
suffix:semicolon
multiline_comment|/* concatenate cur_msg and new_msg into buf */
id|buf_len
op_assign
id|cur_len
op_plus
l_int|1
op_plus
id|new_len
suffix:semicolon
id|buf
op_assign
(paren
r_char
op_star
)paren
id|xmalloc
c_func
(paren
id|buf_len
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|buf
comma
id|cur_msg
comma
id|cur_len
)paren
suffix:semicolon
id|buf
(braket
id|cur_len
)braket
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
id|memcpy
c_func
(paren
id|buf
op_plus
id|cur_len
op_plus
l_int|1
comma
id|new_msg
comma
id|new_len
)paren
suffix:semicolon
id|free
c_func
(paren
id|cur_msg
)paren
suffix:semicolon
id|free
c_func
(paren
id|new_msg
)paren
suffix:semicolon
multiline_comment|/* create a new blob object from buf */
id|ret
op_assign
id|write_sha1_file
c_func
(paren
id|buf
comma
id|buf_len
comma
id|blob_type
comma
id|cur_sha1
)paren
suffix:semicolon
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|combine_notes_overwrite
r_int
id|combine_notes_overwrite
c_func
(paren
r_int
r_char
op_star
id|cur_sha1
comma
r_const
r_int
r_char
op_star
id|new_sha1
)paren
(brace
id|hashcpy
c_func
(paren
id|cur_sha1
comma
id|new_sha1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|combine_notes_ignore
r_int
id|combine_notes_ignore
c_func
(paren
r_int
r_char
op_star
id|cur_sha1
comma
r_const
r_int
r_char
op_star
id|new_sha1
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|string_list_add_one_ref
r_static
r_int
id|string_list_add_one_ref
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
id|flag
comma
r_void
op_star
id|cb
)paren
(brace
r_struct
id|string_list
op_star
id|refs
op_assign
id|cb
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|unsorted_string_list_has_string
c_func
(paren
id|refs
comma
id|path
)paren
)paren
id|string_list_append
c_func
(paren
id|path
comma
id|refs
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|string_list_add_refs_by_glob
r_void
id|string_list_add_refs_by_glob
c_func
(paren
r_struct
id|string_list
op_star
id|list
comma
r_const
r_char
op_star
id|glob
)paren
(brace
r_if
c_cond
(paren
id|has_glob_specials
c_func
(paren
id|glob
)paren
)paren
(brace
id|for_each_glob_ref
c_func
(paren
id|string_list_add_one_ref
comma
id|glob
comma
id|list
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1
c_func
(paren
id|glob
comma
id|sha1
)paren
)paren
id|warning
c_func
(paren
l_string|&quot;notes ref %s is invalid&quot;
comma
id|glob
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|unsorted_string_list_has_string
c_func
(paren
id|list
comma
id|glob
)paren
)paren
id|string_list_append
c_func
(paren
id|glob
comma
id|list
)paren
suffix:semicolon
)brace
)brace
DECL|function|string_list_add_refs_from_colon_sep
r_void
id|string_list_add_refs_from_colon_sep
c_func
(paren
r_struct
id|string_list
op_star
id|list
comma
r_const
r_char
op_star
id|globs
)paren
(brace
r_struct
id|strbuf
id|globbuf
op_assign
id|STRBUF_INIT
suffix:semicolon
r_struct
id|strbuf
op_star
op_star
id|split
suffix:semicolon
r_int
id|i
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|globbuf
comma
id|globs
)paren
suffix:semicolon
id|split
op_assign
id|strbuf_split
c_func
(paren
op_amp
id|globbuf
comma
l_char|&squot;:&squot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|split
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|split
(braket
id|i
)braket
op_member_access_from_pointer
id|len
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|split
(braket
id|i
)braket
op_member_access_from_pointer
id|buf
(braket
id|split
(braket
id|i
)braket
op_member_access_from_pointer
id|len
op_minus
l_int|1
)braket
op_eq
l_char|&squot;:&squot;
)paren
id|strbuf_setlen
c_func
(paren
id|split
(braket
id|i
)braket
comma
id|split
(braket
id|i
)braket
op_member_access_from_pointer
id|len
op_minus
l_int|1
)paren
suffix:semicolon
id|string_list_add_refs_by_glob
c_func
(paren
id|list
comma
id|split
(braket
id|i
)braket
op_member_access_from_pointer
id|buf
)paren
suffix:semicolon
)brace
id|strbuf_list_free
c_func
(paren
id|split
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|globbuf
)paren
suffix:semicolon
)brace
DECL|function|string_list_add_refs_from_list
r_static
r_int
id|string_list_add_refs_from_list
c_func
(paren
r_struct
id|string_list_item
op_star
id|item
comma
r_void
op_star
id|cb
)paren
(brace
r_struct
id|string_list
op_star
id|list
op_assign
id|cb
suffix:semicolon
id|string_list_add_refs_by_glob
c_func
(paren
id|list
comma
id|item-&gt;string
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|notes_display_config
r_static
r_int
id|notes_display_config
c_func
(paren
r_const
r_char
op_star
id|k
comma
r_const
r_char
op_star
id|v
comma
r_void
op_star
id|cb
)paren
(brace
r_int
op_star
id|load_refs
op_assign
id|cb
suffix:semicolon
r_if
c_cond
(paren
op_star
id|load_refs
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|k
comma
l_string|&quot;notes.displayref&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|v
)paren
id|config_error_nonbool
c_func
(paren
id|k
)paren
suffix:semicolon
id|string_list_add_refs_by_glob
c_func
(paren
op_amp
id|display_notes_refs
comma
id|v
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|default_notes_ref
r_static
r_const
r_char
op_star
id|default_notes_ref
c_func
(paren
r_void
)paren
(brace
r_const
r_char
op_star
id|notes_ref
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|notes_ref
)paren
id|notes_ref
op_assign
id|getenv
c_func
(paren
id|GIT_NOTES_REF_ENVIRONMENT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|notes_ref
)paren
id|notes_ref
op_assign
id|notes_ref_name
suffix:semicolon
multiline_comment|/* value of core.notesRef config */
r_if
c_cond
(paren
op_logical_neg
id|notes_ref
)paren
id|notes_ref
op_assign
id|GIT_NOTES_DEFAULT_REF
suffix:semicolon
r_return
id|notes_ref
suffix:semicolon
)brace
DECL|function|init_notes
r_void
id|init_notes
c_func
(paren
r_struct
id|notes_tree
op_star
id|t
comma
r_const
r_char
op_star
id|notes_ref
comma
id|combine_notes_fn
id|combine_notes
comma
r_int
id|flags
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
comma
id|object_sha1
(braket
l_int|20
)braket
suffix:semicolon
r_int
id|mode
suffix:semicolon
r_struct
id|leaf_node
id|root_tree
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|t
)paren
id|t
op_assign
op_amp
id|default_notes_tree
suffix:semicolon
m_assert
(paren
op_logical_neg
id|t-&gt;initialized
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|notes_ref
)paren
id|notes_ref
op_assign
id|default_notes_ref
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|combine_notes
)paren
id|combine_notes
op_assign
id|combine_notes_concatenate
suffix:semicolon
id|t-&gt;root
op_assign
(paren
r_struct
id|int_node
op_star
)paren
id|xcalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|int_node
)paren
comma
l_int|1
)paren
suffix:semicolon
id|t-&gt;first_non_note
op_assign
l_int|NULL
suffix:semicolon
id|t-&gt;prev_non_note
op_assign
l_int|NULL
suffix:semicolon
id|t-&gt;ref
op_assign
id|notes_ref
ques
c_cond
id|xstrdup
c_func
(paren
id|notes_ref
)paren
suffix:colon
l_int|NULL
suffix:semicolon
id|t-&gt;combine_notes
op_assign
id|combine_notes
suffix:semicolon
id|t-&gt;initialized
op_assign
l_int|1
suffix:semicolon
id|t-&gt;dirty
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|NOTES_INIT_EMPTY
op_logical_or
op_logical_neg
id|notes_ref
op_logical_or
id|read_ref
c_func
(paren
id|notes_ref
comma
id|object_sha1
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|get_tree_entry
c_func
(paren
id|object_sha1
comma
l_string|&quot;&quot;
comma
id|sha1
comma
op_amp
id|mode
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Failed to read notes tree referenced by %s (%s)&quot;
comma
id|notes_ref
comma
id|object_sha1
)paren
suffix:semicolon
id|hashclr
c_func
(paren
id|root_tree.key_sha1
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|root_tree.val_sha1
comma
id|sha1
)paren
suffix:semicolon
id|load_subtree
c_func
(paren
id|t
comma
op_amp
id|root_tree
comma
id|t-&gt;root
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|struct|load_notes_cb_data
r_struct
id|load_notes_cb_data
(brace
DECL|member|counter
r_int
id|counter
suffix:semicolon
DECL|member|trees
r_struct
id|notes_tree
op_star
op_star
id|trees
suffix:semicolon
)brace
suffix:semicolon
DECL|function|load_one_display_note_ref
r_static
r_int
id|load_one_display_note_ref
c_func
(paren
r_struct
id|string_list_item
op_star
id|item
comma
r_void
op_star
id|cb_data
)paren
(brace
r_struct
id|load_notes_cb_data
op_star
id|c
op_assign
id|cb_data
suffix:semicolon
r_struct
id|notes_tree
op_star
id|t
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|notes_tree
)paren
)paren
suffix:semicolon
id|init_notes
c_func
(paren
id|t
comma
id|item-&gt;string
comma
id|combine_notes_ignore
comma
l_int|0
)paren
suffix:semicolon
id|c-&gt;trees
(braket
id|c-&gt;counter
op_increment
)braket
op_assign
id|t
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|load_notes_trees
r_struct
id|notes_tree
op_star
op_star
id|load_notes_trees
c_func
(paren
r_struct
id|string_list
op_star
id|refs
)paren
(brace
r_struct
id|notes_tree
op_star
op_star
id|trees
suffix:semicolon
r_struct
id|load_notes_cb_data
id|cb_data
suffix:semicolon
id|trees
op_assign
id|xmalloc
c_func
(paren
(paren
id|refs-&gt;nr
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
r_struct
id|notes_tree
op_star
)paren
)paren
suffix:semicolon
id|cb_data.counter
op_assign
l_int|0
suffix:semicolon
id|cb_data.trees
op_assign
id|trees
suffix:semicolon
id|for_each_string_list
c_func
(paren
id|load_one_display_note_ref
comma
id|refs
comma
op_amp
id|cb_data
)paren
suffix:semicolon
id|trees
(braket
id|cb_data.counter
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
id|trees
suffix:semicolon
)brace
DECL|function|init_display_notes
r_void
id|init_display_notes
c_func
(paren
r_struct
id|display_notes_opt
op_star
id|opt
)paren
(brace
r_char
op_star
id|display_ref_env
suffix:semicolon
r_int
id|load_config_refs
op_assign
l_int|0
suffix:semicolon
id|display_notes_refs.strdup_strings
op_assign
l_int|1
suffix:semicolon
m_assert
(paren
op_logical_neg
id|display_notes_trees
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|opt
op_logical_or
op_logical_neg
id|opt-&gt;suppress_default_notes
)paren
(brace
id|string_list_append
c_func
(paren
id|default_notes_ref
c_func
(paren
)paren
comma
op_amp
id|display_notes_refs
)paren
suffix:semicolon
id|display_ref_env
op_assign
id|getenv
c_func
(paren
id|GIT_NOTES_DISPLAY_REF_ENVIRONMENT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|display_ref_env
)paren
(brace
id|string_list_add_refs_from_colon_sep
c_func
(paren
op_amp
id|display_notes_refs
comma
id|display_ref_env
)paren
suffix:semicolon
id|load_config_refs
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|load_config_refs
op_assign
l_int|1
suffix:semicolon
)brace
id|git_config
c_func
(paren
id|notes_display_config
comma
op_amp
id|load_config_refs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opt
op_logical_and
id|opt-&gt;extra_notes_refs
)paren
id|for_each_string_list
c_func
(paren
id|string_list_add_refs_from_list
comma
id|opt-&gt;extra_notes_refs
comma
op_amp
id|display_notes_refs
)paren
suffix:semicolon
id|display_notes_trees
op_assign
id|load_notes_trees
c_func
(paren
op_amp
id|display_notes_refs
)paren
suffix:semicolon
id|string_list_clear
c_func
(paren
op_amp
id|display_notes_refs
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|add_note
r_void
id|add_note
c_func
(paren
r_struct
id|notes_tree
op_star
id|t
comma
r_const
r_int
r_char
op_star
id|object_sha1
comma
r_const
r_int
r_char
op_star
id|note_sha1
comma
id|combine_notes_fn
id|combine_notes
)paren
(brace
r_struct
id|leaf_node
op_star
id|l
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|t
)paren
id|t
op_assign
op_amp
id|default_notes_tree
suffix:semicolon
m_assert
(paren
id|t-&gt;initialized
)paren
suffix:semicolon
id|t-&gt;dirty
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|combine_notes
)paren
id|combine_notes
op_assign
id|t-&gt;combine_notes
suffix:semicolon
id|l
op_assign
(paren
r_struct
id|leaf_node
op_star
)paren
id|xmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|leaf_node
)paren
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|l-&gt;key_sha1
comma
id|object_sha1
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|l-&gt;val_sha1
comma
id|note_sha1
)paren
suffix:semicolon
id|note_tree_insert
c_func
(paren
id|t
comma
id|t-&gt;root
comma
l_int|0
comma
id|l
comma
id|PTR_TYPE_NOTE
comma
id|combine_notes
)paren
suffix:semicolon
)brace
DECL|function|remove_note
r_void
id|remove_note
c_func
(paren
r_struct
id|notes_tree
op_star
id|t
comma
r_const
r_int
r_char
op_star
id|object_sha1
)paren
(brace
r_struct
id|leaf_node
id|l
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|t
)paren
id|t
op_assign
op_amp
id|default_notes_tree
suffix:semicolon
m_assert
(paren
id|t-&gt;initialized
)paren
suffix:semicolon
id|t-&gt;dirty
op_assign
l_int|1
suffix:semicolon
id|hashcpy
c_func
(paren
id|l.key_sha1
comma
id|object_sha1
)paren
suffix:semicolon
id|hashclr
c_func
(paren
id|l.val_sha1
)paren
suffix:semicolon
id|note_tree_remove
c_func
(paren
id|t
comma
id|t-&gt;root
comma
l_int|0
comma
op_amp
id|l
)paren
suffix:semicolon
)brace
DECL|function|get_note
r_const
r_int
r_char
op_star
id|get_note
c_func
(paren
r_struct
id|notes_tree
op_star
id|t
comma
r_const
r_int
r_char
op_star
id|object_sha1
)paren
(brace
r_struct
id|leaf_node
op_star
id|found
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|t
)paren
id|t
op_assign
op_amp
id|default_notes_tree
suffix:semicolon
m_assert
(paren
id|t-&gt;initialized
)paren
suffix:semicolon
id|found
op_assign
id|note_tree_find
c_func
(paren
id|t
comma
id|t-&gt;root
comma
l_int|0
comma
id|object_sha1
)paren
suffix:semicolon
r_return
id|found
ques
c_cond
id|found-&gt;val_sha1
suffix:colon
l_int|NULL
suffix:semicolon
)brace
DECL|function|for_each_note
r_int
id|for_each_note
c_func
(paren
r_struct
id|notes_tree
op_star
id|t
comma
r_int
id|flags
comma
id|each_note_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|t
)paren
id|t
op_assign
op_amp
id|default_notes_tree
suffix:semicolon
m_assert
(paren
id|t-&gt;initialized
)paren
suffix:semicolon
r_return
id|for_each_note_helper
c_func
(paren
id|t
comma
id|t-&gt;root
comma
l_int|0
comma
l_int|0
comma
id|flags
comma
id|fn
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|write_notes_tree
r_int
id|write_notes_tree
c_func
(paren
r_struct
id|notes_tree
op_star
id|t
comma
r_int
r_char
op_star
id|result
)paren
(brace
r_struct
id|tree_write_stack
id|root
suffix:semicolon
r_struct
id|write_each_note_data
id|cb_data
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|t
)paren
id|t
op_assign
op_amp
id|default_notes_tree
suffix:semicolon
m_assert
(paren
id|t-&gt;initialized
)paren
suffix:semicolon
multiline_comment|/* Prepare for traversal of current notes tree */
id|root.next
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* last forward entry in list is grounded */
id|strbuf_init
c_func
(paren
op_amp
id|root.buf
comma
l_int|256
op_star
(paren
l_int|32
op_plus
l_int|40
)paren
)paren
suffix:semicolon
multiline_comment|/* assume 256 entries */
id|root.path
(braket
l_int|0
)braket
op_assign
id|root.path
(braket
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|cb_data.root
op_assign
op_amp
id|root
suffix:semicolon
id|cb_data.next_non_note
op_assign
id|t-&gt;first_non_note
suffix:semicolon
multiline_comment|/* Write tree objects representing current notes tree */
id|ret
op_assign
id|for_each_note
c_func
(paren
id|t
comma
id|FOR_EACH_NOTE_DONT_UNPACK_SUBTREES
op_or
id|FOR_EACH_NOTE_YIELD_SUBTREES
comma
id|write_each_note
comma
op_amp
id|cb_data
)paren
op_logical_or
id|write_each_non_note_until
c_func
(paren
l_int|NULL
comma
op_amp
id|cb_data
)paren
op_logical_or
id|tree_write_stack_finish_subtree
c_func
(paren
op_amp
id|root
)paren
op_logical_or
id|write_sha1_file
c_func
(paren
id|root.buf.buf
comma
id|root.buf.len
comma
id|tree_type
comma
id|result
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|root.buf
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|prune_notes
r_void
id|prune_notes
c_func
(paren
r_struct
id|notes_tree
op_star
id|t
comma
r_int
id|flags
)paren
(brace
r_struct
id|note_delete_list
op_star
id|l
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|t
)paren
id|t
op_assign
op_amp
id|default_notes_tree
suffix:semicolon
m_assert
(paren
id|t-&gt;initialized
)paren
suffix:semicolon
id|for_each_note
c_func
(paren
id|t
comma
l_int|0
comma
id|prune_notes_helper
comma
op_amp
id|l
)paren
suffix:semicolon
r_while
c_loop
(paren
id|l
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|NOTES_PRUNE_VERBOSE
)paren
id|printf
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|l-&gt;sha1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|NOTES_PRUNE_DRYRUN
)paren
)paren
id|remove_note
c_func
(paren
id|t
comma
id|l-&gt;sha1
)paren
suffix:semicolon
id|l
op_assign
id|l-&gt;next
suffix:semicolon
)brace
)brace
DECL|function|free_notes
r_void
id|free_notes
c_func
(paren
r_struct
id|notes_tree
op_star
id|t
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|t
)paren
id|t
op_assign
op_amp
id|default_notes_tree
suffix:semicolon
r_if
c_cond
(paren
id|t-&gt;root
)paren
id|note_tree_free
c_func
(paren
id|t-&gt;root
)paren
suffix:semicolon
id|free
c_func
(paren
id|t-&gt;root
)paren
suffix:semicolon
r_while
c_loop
(paren
id|t-&gt;first_non_note
)paren
(brace
id|t-&gt;prev_non_note
op_assign
id|t-&gt;first_non_note-&gt;next
suffix:semicolon
id|free
c_func
(paren
id|t-&gt;first_non_note-&gt;path
)paren
suffix:semicolon
id|free
c_func
(paren
id|t-&gt;first_non_note
)paren
suffix:semicolon
id|t-&gt;first_non_note
op_assign
id|t-&gt;prev_non_note
suffix:semicolon
)brace
id|free
c_func
(paren
id|t-&gt;ref
)paren
suffix:semicolon
id|memset
c_func
(paren
id|t
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|notes_tree
)paren
)paren
suffix:semicolon
)brace
DECL|function|format_note
r_void
id|format_note
c_func
(paren
r_struct
id|notes_tree
op_star
id|t
comma
r_const
r_int
r_char
op_star
id|object_sha1
comma
r_struct
id|strbuf
op_star
id|sb
comma
r_const
r_char
op_star
id|output_encoding
comma
r_int
id|flags
)paren
(brace
r_static
r_const
r_char
id|utf8
(braket
)braket
op_assign
l_string|&quot;utf-8&quot;
suffix:semicolon
r_const
r_int
r_char
op_star
id|sha1
suffix:semicolon
r_char
op_star
id|msg
comma
op_star
id|msg_p
suffix:semicolon
r_int
r_int
id|linelen
comma
id|msglen
suffix:semicolon
r_enum
id|object_type
id|type
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|t
)paren
id|t
op_assign
op_amp
id|default_notes_tree
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|t-&gt;initialized
)paren
id|init_notes
c_func
(paren
id|t
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|sha1
op_assign
id|get_note
c_func
(paren
id|t
comma
id|object_sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sha1
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|msg
op_assign
id|read_sha1_file
c_func
(paren
id|sha1
comma
op_amp
id|type
comma
op_amp
id|msglen
)paren
)paren
op_logical_or
op_logical_neg
id|msglen
op_logical_or
id|type
op_ne
id|OBJ_BLOB
)paren
(brace
id|free
c_func
(paren
id|msg
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|output_encoding
op_logical_and
op_star
id|output_encoding
op_logical_and
id|strcmp
c_func
(paren
id|utf8
comma
id|output_encoding
)paren
)paren
(brace
r_char
op_star
id|reencoded
op_assign
id|reencode_string
c_func
(paren
id|msg
comma
id|output_encoding
comma
id|utf8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reencoded
)paren
(brace
id|free
c_func
(paren
id|msg
)paren
suffix:semicolon
id|msg
op_assign
id|reencoded
suffix:semicolon
id|msglen
op_assign
id|strlen
c_func
(paren
id|msg
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* we will end the annotation by a newline anyway */
r_if
c_cond
(paren
id|msglen
op_logical_and
id|msg
(braket
id|msglen
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|msglen
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|NOTES_SHOW_HEADER
)paren
(brace
r_const
r_char
op_star
id|ref
op_assign
id|t-&gt;ref
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ref
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|ref
comma
id|GIT_NOTES_DEFAULT_REF
)paren
)paren
(brace
id|strbuf_addstr
c_func
(paren
id|sb
comma
l_string|&quot;&bslash;nNotes:&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|ref
comma
l_string|&quot;refs/&quot;
)paren
)paren
id|ref
op_add_assign
l_int|5
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|ref
comma
l_string|&quot;notes/&quot;
)paren
)paren
id|ref
op_add_assign
l_int|6
suffix:semicolon
id|strbuf_addf
c_func
(paren
id|sb
comma
l_string|&quot;&bslash;nNotes (%s):&bslash;n&quot;
comma
id|ref
)paren
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|msg_p
op_assign
id|msg
suffix:semicolon
id|msg_p
OL
id|msg
op_plus
id|msglen
suffix:semicolon
id|msg_p
op_add_assign
id|linelen
op_plus
l_int|1
)paren
(brace
id|linelen
op_assign
id|strchrnul
c_func
(paren
id|msg_p
comma
l_char|&squot;&bslash;n&squot;
)paren
id|msg_p
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|NOTES_INDENT
)paren
id|strbuf_addstr
c_func
(paren
id|sb
comma
l_string|&quot;    &quot;
)paren
suffix:semicolon
id|strbuf_add
c_func
(paren
id|sb
comma
id|msg_p
comma
id|linelen
)paren
suffix:semicolon
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
id|free
c_func
(paren
id|msg
)paren
suffix:semicolon
)brace
DECL|function|format_display_notes
r_void
id|format_display_notes
c_func
(paren
r_const
r_int
r_char
op_star
id|object_sha1
comma
r_struct
id|strbuf
op_star
id|sb
comma
r_const
r_char
op_star
id|output_encoding
comma
r_int
id|flags
)paren
(brace
r_int
id|i
suffix:semicolon
m_assert
(paren
id|display_notes_trees
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|display_notes_trees
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
id|format_note
c_func
(paren
id|display_notes_trees
(braket
id|i
)braket
comma
id|object_sha1
comma
id|sb
comma
id|output_encoding
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|copy_note
r_int
id|copy_note
c_func
(paren
r_struct
id|notes_tree
op_star
id|t
comma
r_const
r_int
r_char
op_star
id|from_obj
comma
r_const
r_int
r_char
op_star
id|to_obj
comma
r_int
id|force
comma
id|combine_notes_fn
id|combine_fn
)paren
(brace
r_const
r_int
r_char
op_star
id|note
op_assign
id|get_note
c_func
(paren
id|t
comma
id|from_obj
)paren
suffix:semicolon
r_const
r_int
r_char
op_star
id|existing_note
op_assign
id|get_note
c_func
(paren
id|t
comma
id|to_obj
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|force
op_logical_and
id|existing_note
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|note
)paren
id|add_note
c_func
(paren
id|t
comma
id|to_obj
comma
id|note
comma
id|combine_fn
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|existing_note
)paren
id|add_note
c_func
(paren
id|t
comma
id|to_obj
comma
id|null_sha1
comma
id|combine_fn
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
