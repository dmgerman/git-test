multiline_comment|/*&n; * Another stupid program, this one parsing the headers of an&n; * email to figure out authorship and subject&n; */
DECL|macro|_GNU_SOURCE
mdefine_line|#define _GNU_SOURCE
macro_line|#include &lt;stdio.h&gt;
macro_line|#include &lt;stdlib.h&gt;
macro_line|#include &lt;string.h&gt;
macro_line|#include &lt;ctype.h&gt;
macro_line|#ifndef NO_ICONV
macro_line|#include &lt;iconv.h&gt;
macro_line|#endif
macro_line|#include &quot;git-compat-util.h&quot;
macro_line|#include &quot;cache.h&quot;
DECL|variable|cmitmsg
DECL|variable|patchfile
r_static
id|FILE
op_star
id|cmitmsg
comma
op_star
id|patchfile
suffix:semicolon
DECL|variable|keep_subject
r_static
r_int
id|keep_subject
op_assign
l_int|0
suffix:semicolon
DECL|variable|metainfo_charset
r_static
r_char
op_star
id|metainfo_charset
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|line
r_static
r_char
id|line
(braket
l_int|1000
)braket
suffix:semicolon
DECL|variable|date
r_static
r_char
id|date
(braket
l_int|1000
)braket
suffix:semicolon
DECL|variable|name
r_static
r_char
id|name
(braket
l_int|1000
)braket
suffix:semicolon
DECL|variable|email
r_static
r_char
id|email
(braket
l_int|1000
)braket
suffix:semicolon
DECL|variable|subject
r_static
r_char
id|subject
(braket
l_int|1000
)braket
suffix:semicolon
r_static
r_enum
(brace
DECL|enumerator|TE_DONTCARE
DECL|enumerator|TE_QP
DECL|enumerator|TE_BASE64
id|TE_DONTCARE
comma
id|TE_QP
comma
id|TE_BASE64
comma
DECL|variable|transfer_encoding
)brace
id|transfer_encoding
suffix:semicolon
DECL|variable|charset
r_static
r_char
id|charset
(braket
l_int|256
)braket
suffix:semicolon
DECL|variable|multipart_boundary
r_static
r_char
id|multipart_boundary
(braket
l_int|1000
)braket
suffix:semicolon
DECL|variable|multipart_boundary_len
r_static
r_int
id|multipart_boundary_len
suffix:semicolon
DECL|variable|patch_lines
r_static
r_int
id|patch_lines
op_assign
l_int|0
suffix:semicolon
DECL|function|sanity_check
r_static
r_char
op_star
id|sanity_check
c_func
(paren
r_char
op_star
id|name
comma
r_char
op_star
id|email
)paren
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
template_param
l_int|60
)paren
r_return
id|email
suffix:semicolon
r_if
c_cond
(paren
id|strchr
c_func
(paren
id|name
comma
l_char|&squot;@&squot;
)paren
op_logical_or
id|strchr
c_func
(paren
id|name
comma
l_char|&squot;&lt;&squot;
)paren
op_logical_or
id|strchr
c_func
(paren
id|name
comma
l_char|&squot;&gt;&squot;
)paren
)paren
r_return
id|email
suffix:semicolon
r_return
id|name
suffix:semicolon
)brace
DECL|function|bogus_from
r_static
r_int
id|bogus_from
c_func
(paren
r_char
op_star
id|line
)paren
(brace
multiline_comment|/* John Doe &lt;johndoe&gt; */
r_char
op_star
id|bra
comma
op_star
id|ket
comma
op_star
id|dst
comma
op_star
id|cp
suffix:semicolon
multiline_comment|/* This is fallback, so do not bother if we already have an&n;&t; * e-mail address.&n;&t; */
r_if
c_cond
(paren
op_star
id|email
)paren
r_return
l_int|0
suffix:semicolon
id|bra
op_assign
id|strchr
c_func
(paren
id|line
comma
l_char|&squot;&lt;&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bra
)paren
r_return
l_int|0
suffix:semicolon
id|ket
op_assign
id|strchr
c_func
(paren
id|bra
comma
l_char|&squot;&gt;&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ket
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|dst
op_assign
id|email
comma
id|cp
op_assign
id|bra
op_plus
l_int|1
suffix:semicolon
id|cp
OL
id|ket
suffix:semicolon
)paren
op_star
id|dst
op_increment
op_assign
op_star
id|cp
op_increment
suffix:semicolon
op_star
id|dst
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|cp
op_assign
id|line
suffix:semicolon
id|isspace
c_func
(paren
op_star
id|cp
)paren
suffix:semicolon
id|cp
op_increment
)paren
suffix:semicolon
r_for
c_loop
(paren
id|bra
op_decrement
suffix:semicolon
id|isspace
c_func
(paren
op_star
id|bra
)paren
suffix:semicolon
id|bra
op_decrement
)paren
op_star
id|bra
op_assign
l_int|0
suffix:semicolon
id|cp
op_assign
id|sanity_check
c_func
(paren
id|cp
comma
id|email
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|name
comma
id|cp
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|handle_from
r_static
r_int
id|handle_from
c_func
(paren
r_char
op_star
id|in_line
)paren
(brace
r_char
id|line
(braket
l_int|1000
)braket
suffix:semicolon
r_char
op_star
id|at
suffix:semicolon
r_char
op_star
id|dst
suffix:semicolon
id|strcpy
c_func
(paren
id|line
comma
id|in_line
)paren
suffix:semicolon
id|at
op_assign
id|strchr
c_func
(paren
id|line
comma
l_char|&squot;@&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|at
)paren
r_return
id|bogus_from
c_func
(paren
id|line
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we already have one email, don&squot;t take any confusing lines&n;&t; */
r_if
c_cond
(paren
op_star
id|email
op_logical_and
id|strchr
c_func
(paren
id|at
op_plus
l_int|1
comma
l_char|&squot;@&squot;
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Pick up the string around &squot;@&squot;, possibly delimited with &lt;&gt;&n;&t; * pair; that is the email part.  White them out while copying.&n;&t; */
r_while
c_loop
(paren
id|at
OG
id|line
)paren
(brace
r_char
id|c
op_assign
id|at
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|isspace
c_func
(paren
id|c
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&lt;&squot;
)paren
(brace
id|at
(braket
l_int|1
)braket
op_assign
l_char|&squot; &squot;
suffix:semicolon
r_break
suffix:semicolon
)brace
id|at
op_decrement
suffix:semicolon
)brace
id|dst
op_assign
id|email
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
r_char
id|c
op_assign
op_star
id|at
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
op_logical_or
id|c
op_eq
l_char|&squot;&gt;&squot;
op_logical_or
id|isspace
c_func
(paren
id|c
)paren
)paren
(brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&gt;&squot;
)paren
op_star
id|at
op_assign
l_char|&squot; &squot;
suffix:semicolon
r_break
suffix:semicolon
)brace
op_star
id|at
op_increment
op_assign
l_char|&squot; &squot;
suffix:semicolon
op_star
id|dst
op_increment
op_assign
id|c
suffix:semicolon
)brace
op_star
id|dst
op_increment
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* The remainder is name.  It could be &quot;John Doe &lt;john.doe@xz&gt;&quot;&n;&t; * or &quot;john.doe@xz (John Doe)&quot;, but we have whited out the&n;&t; * email part, so trim from both ends, possibly removing&n;&t; * the () pair at the end.&n;&t; */
id|at
op_assign
id|line
op_plus
id|strlen
c_func
(paren
id|line
)paren
suffix:semicolon
r_while
c_loop
(paren
id|at
OG
id|line
)paren
(brace
r_int
r_char
id|c
op_assign
op_star
op_decrement
id|at
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|isspace
c_func
(paren
id|c
)paren
)paren
(brace
id|at
(braket
(paren
id|c
op_eq
l_char|&squot;)&squot;
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|at
op_assign
id|line
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
r_char
id|c
op_assign
op_star
id|at
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
op_logical_or
op_logical_neg
id|isspace
c_func
(paren
id|c
)paren
)paren
(brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;(&squot;
)paren
id|at
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
id|at
op_increment
suffix:semicolon
)brace
id|at
op_assign
id|sanity_check
c_func
(paren
id|at
comma
id|email
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|name
comma
id|at
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|handle_date
r_static
r_int
id|handle_date
c_func
(paren
r_char
op_star
id|line
)paren
(brace
id|strcpy
c_func
(paren
id|date
comma
id|line
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|handle_subject
r_static
r_int
id|handle_subject
c_func
(paren
r_char
op_star
id|line
)paren
(brace
id|strcpy
c_func
(paren
id|subject
comma
id|line
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* NOTE NOTE NOTE.  We do not claim we do full MIME.  We just attempt&n; * to have enough heuristics to grok MIME encoded patches often found&n; * on our mailing lists.  For example, we do not even treat header lines&n; * case insensitively.&n; */
DECL|function|slurp_attr
r_static
r_int
id|slurp_attr
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_const
r_char
op_star
id|name
comma
r_char
op_star
id|attr
)paren
(brace
r_char
op_star
id|ends
comma
op_star
id|ap
op_assign
id|strcasestr
c_func
(paren
id|line
comma
id|name
)paren
suffix:semicolon
r_int
id|sz
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ap
)paren
(brace
op_star
id|attr
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ap
op_add_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|ap
op_eq
l_char|&squot;&quot;&squot;
)paren
(brace
id|ap
op_increment
suffix:semicolon
id|ends
op_assign
l_string|&quot;&bslash;&quot;&quot;
suffix:semicolon
)brace
r_else
id|ends
op_assign
l_string|&quot;; &bslash;t&quot;
suffix:semicolon
id|sz
op_assign
id|strcspn
c_func
(paren
id|ap
comma
id|ends
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|attr
comma
id|ap
comma
id|sz
)paren
suffix:semicolon
id|attr
(braket
id|sz
)braket
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|handle_subcontent_type
r_static
r_int
id|handle_subcontent_type
c_func
(paren
r_char
op_star
id|line
)paren
(brace
multiline_comment|/* We do not want to mess with boundary.  Note that we do not&n;&t; * handle nested multipart.&n;&t; */
r_if
c_cond
(paren
id|strcasestr
c_func
(paren
id|line
comma
l_string|&quot;boundary=&quot;
)paren
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Not handling nested multipart message.&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|slurp_attr
c_func
(paren
id|line
comma
l_string|&quot;charset=&quot;
comma
id|charset
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|charset
)paren
(brace
r_int
id|i
comma
id|c
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|c
op_assign
id|charset
(braket
id|i
)braket
)paren
op_ne
l_int|0
suffix:semicolon
id|i
op_increment
)paren
id|charset
(braket
id|i
)braket
op_assign
id|tolower
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|handle_content_type
r_static
r_int
id|handle_content_type
c_func
(paren
r_char
op_star
id|line
)paren
(brace
op_star
id|multipart_boundary
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|slurp_attr
c_func
(paren
id|line
comma
l_string|&quot;boundary=&quot;
comma
id|multipart_boundary
op_plus
l_int|2
)paren
)paren
(brace
id|memcpy
c_func
(paren
id|multipart_boundary
comma
l_string|&quot;--&quot;
comma
l_int|2
)paren
suffix:semicolon
id|multipart_boundary_len
op_assign
id|strlen
c_func
(paren
id|multipart_boundary
)paren
suffix:semicolon
)brace
id|slurp_attr
c_func
(paren
id|line
comma
l_string|&quot;charset=&quot;
comma
id|charset
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|handle_content_transfer_encoding
r_static
r_int
id|handle_content_transfer_encoding
c_func
(paren
r_char
op_star
id|line
)paren
(brace
r_if
c_cond
(paren
id|strcasestr
c_func
(paren
id|line
comma
l_string|&quot;base64&quot;
)paren
)paren
id|transfer_encoding
op_assign
id|TE_BASE64
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcasestr
c_func
(paren
id|line
comma
l_string|&quot;quoted-printable&quot;
)paren
)paren
id|transfer_encoding
op_assign
id|TE_QP
suffix:semicolon
r_else
id|transfer_encoding
op_assign
id|TE_DONTCARE
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|is_multipart_boundary
r_static
r_int
id|is_multipart_boundary
c_func
(paren
r_const
r_char
op_star
id|line
)paren
(brace
r_return
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|line
comma
id|multipart_boundary
comma
id|multipart_boundary_len
)paren
)paren
suffix:semicolon
)brace
DECL|function|eatspace
r_static
r_int
id|eatspace
c_func
(paren
r_char
op_star
id|line
)paren
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|line
)paren
suffix:semicolon
r_while
c_loop
(paren
id|len
OG
l_int|0
op_logical_and
id|isspace
c_func
(paren
id|line
(braket
id|len
op_minus
l_int|1
)braket
)paren
)paren
id|line
(braket
op_decrement
id|len
)braket
op_assign
l_int|0
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
DECL|macro|SEEN_FROM
mdefine_line|#define SEEN_FROM 01
DECL|macro|SEEN_DATE
mdefine_line|#define SEEN_DATE 02
DECL|macro|SEEN_SUBJECT
mdefine_line|#define SEEN_SUBJECT 04
DECL|macro|SEEN_BOGUS_UNIX_FROM
mdefine_line|#define SEEN_BOGUS_UNIX_FROM 010
DECL|macro|SEEN_PREFIX
mdefine_line|#define SEEN_PREFIX  020
multiline_comment|/* First lines of body can have From:, Date:, and Subject: or empty */
DECL|function|handle_inbody_header
r_static
r_void
id|handle_inbody_header
c_func
(paren
r_int
op_star
id|seen
comma
r_char
op_star
id|line
)paren
(brace
r_if
c_cond
(paren
op_star
id|seen
op_amp
id|SEEN_PREFIX
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|isspace
c_func
(paren
op_star
id|line
)paren
)paren
(brace
r_char
op_star
id|cp
suffix:semicolon
r_for
c_loop
(paren
id|cp
op_assign
id|line
op_plus
l_int|1
suffix:semicolon
op_star
id|cp
suffix:semicolon
id|cp
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|isspace
c_func
(paren
op_star
id|cp
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|cp
)paren
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;&gt;From&quot;
comma
id|line
comma
l_int|5
)paren
op_logical_and
id|isspace
c_func
(paren
id|line
(braket
l_int|5
)braket
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|seen
op_amp
id|SEEN_BOGUS_UNIX_FROM
)paren
)paren
(brace
op_star
id|seen
op_or_assign
id|SEEN_BOGUS_UNIX_FROM
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;From:&quot;
comma
id|line
comma
l_int|5
)paren
op_logical_and
id|isspace
c_func
(paren
id|line
(braket
l_int|5
)braket
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|seen
op_amp
id|SEEN_FROM
)paren
op_logical_and
id|handle_from
c_func
(paren
id|line
op_plus
l_int|6
)paren
)paren
(brace
op_star
id|seen
op_or_assign
id|SEEN_FROM
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;Date:&quot;
comma
id|line
comma
l_int|5
)paren
op_logical_and
id|isspace
c_func
(paren
id|line
(braket
l_int|5
)braket
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|seen
op_amp
id|SEEN_DATE
)paren
)paren
(brace
id|handle_date
c_func
(paren
id|line
op_plus
l_int|6
)paren
suffix:semicolon
op_star
id|seen
op_or_assign
id|SEEN_DATE
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;Subject:&quot;
comma
id|line
comma
l_int|8
)paren
op_logical_and
id|isspace
c_func
(paren
id|line
(braket
l_int|8
)braket
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|seen
op_amp
id|SEEN_SUBJECT
)paren
)paren
(brace
id|handle_subject
c_func
(paren
id|line
op_plus
l_int|9
)paren
suffix:semicolon
op_star
id|seen
op_or_assign
id|SEEN_SUBJECT
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;[PATCH]&quot;
comma
id|line
comma
l_int|7
)paren
op_logical_and
id|isspace
c_func
(paren
id|line
(braket
l_int|7
)braket
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|seen
op_amp
id|SEEN_SUBJECT
)paren
)paren
(brace
id|handle_subject
c_func
(paren
id|line
)paren
suffix:semicolon
op_star
id|seen
op_or_assign
id|SEEN_SUBJECT
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
op_star
id|seen
op_or_assign
id|SEEN_PREFIX
suffix:semicolon
)brace
DECL|function|cleanup_subject
r_static
r_char
op_star
id|cleanup_subject
c_func
(paren
r_char
op_star
id|subject
)paren
(brace
r_if
c_cond
(paren
id|keep_subject
)paren
r_return
id|subject
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_char
op_star
id|p
suffix:semicolon
r_int
id|len
comma
id|remove
suffix:semicolon
r_switch
c_cond
(paren
op_star
id|subject
)paren
(brace
r_case
l_char|&squot;r&squot;
suffix:colon
r_case
l_char|&squot;R&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;e:&quot;
comma
id|subject
op_plus
l_int|1
comma
l_int|2
)paren
)paren
(brace
id|subject
op_add_assign
l_int|3
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_char|&squot; &squot;
suffix:colon
r_case
l_char|&squot;&bslash;t&squot;
suffix:colon
r_case
l_char|&squot;:&squot;
suffix:colon
id|subject
op_increment
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;[&squot;
suffix:colon
id|p
op_assign
id|strchr
c_func
(paren
id|subject
comma
l_char|&squot;]&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
(brace
id|subject
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|len
op_assign
id|strlen
c_func
(paren
id|p
)paren
suffix:semicolon
id|remove
op_assign
id|p
id|subject
suffix:semicolon
r_if
c_cond
(paren
id|remove
op_le
id|len
op_star
l_int|2
)paren
(brace
id|subject
op_assign
id|p
op_plus
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
id|eatspace
c_func
(paren
id|subject
)paren
suffix:semicolon
r_return
id|subject
suffix:semicolon
)brace
)brace
DECL|function|cleanup_space
r_static
r_void
id|cleanup_space
c_func
(paren
r_char
op_star
id|buf
)paren
(brace
r_int
r_char
id|c
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
op_star
id|buf
)paren
op_ne
l_int|0
)paren
(brace
id|buf
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|isspace
c_func
(paren
id|c
)paren
)paren
(brace
id|buf
(braket
l_int|1
)braket
op_assign
l_char|&squot; &squot;
suffix:semicolon
id|c
op_assign
op_star
id|buf
suffix:semicolon
r_while
c_loop
(paren
id|isspace
c_func
(paren
id|c
)paren
)paren
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|buf
)paren
suffix:semicolon
id|memmove
c_func
(paren
id|buf
comma
id|buf
op_plus
l_int|1
comma
id|len
)paren
suffix:semicolon
id|c
op_assign
op_star
id|buf
suffix:semicolon
)brace
)brace
)brace
)brace
r_static
r_void
id|decode_header_bq
c_func
(paren
r_char
op_star
id|it
)paren
suffix:semicolon
DECL|typedef|header_fn_t
r_typedef
r_int
(paren
op_star
id|header_fn_t
)paren
(paren
r_char
op_star
)paren
suffix:semicolon
DECL|struct|header_def
r_struct
id|header_def
(brace
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
DECL|member|func
id|header_fn_t
id|func
suffix:semicolon
DECL|member|namelen
r_int
id|namelen
suffix:semicolon
)brace
suffix:semicolon
DECL|function|check_header
r_static
r_void
id|check_header
c_func
(paren
r_char
op_star
id|line
comma
r_struct
id|header_def
op_star
id|header
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|header
(braket
l_int|0
)braket
dot
id|namelen
op_le
l_int|0
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|header
(braket
id|i
)braket
dot
id|name
suffix:semicolon
id|i
op_increment
)paren
id|header
(braket
id|i
)braket
dot
id|namelen
op_assign
id|strlen
c_func
(paren
id|header
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|header
(braket
id|i
)braket
dot
id|name
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|len
op_assign
id|header
(braket
id|i
)braket
dot
id|namelen
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncasecmp
c_func
(paren
id|line
comma
id|header
(braket
id|i
)braket
dot
id|name
comma
id|len
)paren
op_logical_and
id|line
(braket
id|len
)braket
op_eq
l_char|&squot;:&squot;
op_logical_and
id|isspace
c_func
(paren
id|line
(braket
id|len
op_plus
l_int|1
)braket
)paren
)paren
(brace
multiline_comment|/* Unwrap inline B and Q encoding, and optionally&n;&t;&t;&t; * normalize the meta information to utf8.&n;&t;&t;&t; */
id|decode_header_bq
c_func
(paren
id|line
op_plus
id|len
op_plus
l_int|2
)paren
suffix:semicolon
id|header
(braket
id|i
)braket
dot
id|func
c_func
(paren
id|line
op_plus
id|len
op_plus
l_int|2
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
DECL|function|check_subheader_line
r_static
r_void
id|check_subheader_line
c_func
(paren
r_char
op_star
id|line
)paren
(brace
r_static
r_struct
id|header_def
id|header
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;Content-Type&quot;
comma
id|handle_subcontent_type
)brace
comma
(brace
l_string|&quot;Content-Transfer-Encoding&quot;
comma
id|handle_content_transfer_encoding
)brace
comma
(brace
l_int|NULL
)brace
comma
)brace
suffix:semicolon
id|check_header
c_func
(paren
id|line
comma
id|header
)paren
suffix:semicolon
)brace
DECL|function|check_header_line
r_static
r_void
id|check_header_line
c_func
(paren
r_char
op_star
id|line
)paren
(brace
r_static
r_struct
id|header_def
id|header
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;From&quot;
comma
id|handle_from
)brace
comma
(brace
l_string|&quot;Date&quot;
comma
id|handle_date
)brace
comma
(brace
l_string|&quot;Subject&quot;
comma
id|handle_subject
)brace
comma
(brace
l_string|&quot;Content-Type&quot;
comma
id|handle_content_type
)brace
comma
(brace
l_string|&quot;Content-Transfer-Encoding&quot;
comma
id|handle_content_transfer_encoding
)brace
comma
(brace
l_int|NULL
)brace
comma
)brace
suffix:semicolon
id|check_header
c_func
(paren
id|line
comma
id|header
)paren
suffix:semicolon
)brace
DECL|function|is_rfc2822_header
r_static
r_int
id|is_rfc2822_header
c_func
(paren
r_char
op_star
id|line
)paren
(brace
multiline_comment|/*&n;&t; * The section that defines the loosest possible&n;&t; * field name is &quot;3.6.8 Optional fields&quot;.&n;&t; *&n;&t; * optional-field = field-name &quot;:&quot; unstructured CRLF&n;&t; * field-name = 1*ftext&n;&t; * ftext = %d33-57 / %59-126&n;&t; */
r_int
id|ch
suffix:semicolon
r_char
op_star
id|cp
op_assign
id|line
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ch
op_assign
op_star
id|cp
op_increment
)paren
)paren
(brace
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;:&squot;
)paren
r_return
id|cp
op_ne
id|line
suffix:semicolon
r_if
c_cond
(paren
(paren
l_int|33
op_le
id|ch
op_logical_and
id|ch
op_le
l_int|57
)paren
op_logical_or
(paren
l_int|59
op_le
id|ch
op_logical_and
id|ch
op_le
l_int|126
)paren
)paren
r_continue
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|read_one_header_line
r_static
r_int
id|read_one_header_line
c_func
(paren
r_char
op_star
id|line
comma
r_int
id|sz
comma
id|FILE
op_star
id|in
)paren
(brace
r_int
id|ofs
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|ofs
OL
id|sz
)paren
(brace
r_int
id|peek
comma
id|len
suffix:semicolon
r_if
c_cond
(paren
id|fgets
c_func
(paren
id|line
op_plus
id|ofs
comma
id|sz
id|ofs
comma
id|in
)paren
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|len
op_assign
id|eatspace
c_func
(paren
id|line
op_plus
id|ofs
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_eq
l_int|0
)paren
op_logical_or
op_logical_neg
id|is_rfc2822_header
c_func
(paren
id|line
)paren
)paren
(brace
multiline_comment|/* Re-add the newline */
id|line
(braket
id|ofs
op_plus
id|len
)braket
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
id|line
(braket
id|ofs
op_plus
id|len
op_plus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ofs
op_add_assign
id|len
suffix:semicolon
multiline_comment|/* Yuck, 2822 header &quot;folding&quot; */
id|peek
op_assign
id|fgetc
c_func
(paren
id|in
)paren
suffix:semicolon
id|ungetc
c_func
(paren
id|peek
comma
id|in
)paren
suffix:semicolon
r_if
c_cond
(paren
id|peek
op_ne
l_char|&squot; &squot;
op_logical_and
id|peek
op_ne
l_char|&squot;&bslash;t&squot;
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* Count mbox From headers as headers */
r_if
c_cond
(paren
op_logical_neg
id|ofs
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|line
comma
l_string|&quot;From &quot;
comma
l_int|5
)paren
)paren
id|ofs
op_assign
l_int|1
suffix:semicolon
r_return
id|ofs
suffix:semicolon
)brace
DECL|function|hexval
r_static
r_int
id|hexval
c_func
(paren
r_int
id|c
)paren
(brace
r_if
c_cond
(paren
id|c
op_ge
l_char|&squot;0&squot;
op_logical_and
id|c
op_le
l_char|&squot;9&squot;
)paren
r_return
id|c
l_char|&squot;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|c
op_ge
l_char|&squot;a&squot;
op_logical_and
id|c
op_le
l_char|&squot;f&squot;
)paren
r_return
id|c
l_char|&squot;a&squot;
op_plus
l_int|10
suffix:semicolon
r_if
c_cond
(paren
id|c
op_ge
l_char|&squot;A&squot;
op_logical_and
id|c
op_le
l_char|&squot;F&squot;
)paren
r_return
id|c
l_char|&squot;A&squot;
op_plus
l_int|10
suffix:semicolon
r_return
op_complement
l_int|0
suffix:semicolon
)brace
DECL|function|decode_q_segment
r_static
r_int
id|decode_q_segment
c_func
(paren
r_char
op_star
id|in
comma
r_char
op_star
id|ot
comma
r_char
op_star
id|ep
comma
r_int
id|rfc2047
)paren
(brace
r_int
id|c
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
op_star
id|in
op_increment
)paren
op_ne
l_int|0
op_logical_and
(paren
id|in
op_le
id|ep
)paren
)paren
(brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;=&squot;
)paren
(brace
r_int
id|d
op_assign
op_star
id|in
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|d
op_eq
l_char|&squot;&bslash;n&squot;
op_logical_or
op_logical_neg
id|d
)paren
r_break
suffix:semicolon
multiline_comment|/* drop trailing newline */
op_star
id|ot
op_increment
op_assign
(paren
(paren
id|hexval
c_func
(paren
id|d
)paren
op_lshift
l_int|4
)paren
op_or
id|hexval
c_func
(paren
op_star
id|in
op_increment
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rfc2047
op_logical_and
id|c
op_eq
l_char|&squot;_&squot;
)paren
multiline_comment|/* rfc2047 4.2 (2) */
id|c
op_assign
l_int|0x20
suffix:semicolon
op_star
id|ot
op_increment
op_assign
id|c
suffix:semicolon
)brace
op_star
id|ot
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|decode_b_segment
r_static
r_int
id|decode_b_segment
c_func
(paren
r_char
op_star
id|in
comma
r_char
op_star
id|ot
comma
r_char
op_star
id|ep
)paren
(brace
multiline_comment|/* Decode in..ep, possibly in-place to ot */
r_int
id|c
comma
id|pos
op_assign
l_int|0
comma
id|acc
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
op_star
id|in
op_increment
)paren
op_ne
l_int|0
op_logical_and
(paren
id|in
op_le
id|ep
)paren
)paren
(brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;+&squot;
)paren
id|c
op_assign
l_int|62
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;/&squot;
)paren
id|c
op_assign
l_int|63
suffix:semicolon
r_else
r_if
c_cond
(paren
l_char|&squot;A&squot;
op_le
id|c
op_logical_and
id|c
op_le
l_char|&squot;Z&squot;
)paren
id|c
op_sub_assign
l_char|&squot;A&squot;
suffix:semicolon
r_else
r_if
c_cond
(paren
l_char|&squot;a&squot;
op_le
id|c
op_logical_and
id|c
op_le
l_char|&squot;z&squot;
)paren
id|c
op_sub_assign
l_char|&squot;a&squot;
l_int|26
suffix:semicolon
r_else
r_if
c_cond
(paren
l_char|&squot;0&squot;
op_le
id|c
op_logical_and
id|c
op_le
l_char|&squot;9&squot;
)paren
id|c
op_sub_assign
l_char|&squot;0&squot;
l_int|52
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;=&squot;
)paren
(brace
multiline_comment|/* padding is almost like (c == 0), except we do&n;&t;&t;&t; * not output NUL resulting only from it;&n;&t;&t;&t; * for now we just trust the data.&n;&t;&t;&t; */
id|c
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_continue
suffix:semicolon
multiline_comment|/* garbage */
r_switch
c_cond
(paren
id|pos
op_increment
)paren
(brace
r_case
l_int|0
suffix:colon
id|acc
op_assign
(paren
id|c
op_lshift
l_int|2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
op_star
id|ot
op_increment
op_assign
(paren
id|acc
op_or
(paren
id|c
op_rshift
l_int|4
)paren
)paren
suffix:semicolon
id|acc
op_assign
(paren
id|c
op_amp
l_int|15
)paren
op_lshift
l_int|4
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
op_star
id|ot
op_increment
op_assign
(paren
id|acc
op_or
(paren
id|c
op_rshift
l_int|2
)paren
)paren
suffix:semicolon
id|acc
op_assign
(paren
id|c
op_amp
l_int|3
)paren
op_lshift
l_int|6
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
op_star
id|ot
op_increment
op_assign
(paren
id|acc
op_or
id|c
)paren
suffix:semicolon
id|acc
op_assign
id|pos
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
op_star
id|ot
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|convert_to_utf8
r_static
r_void
id|convert_to_utf8
c_func
(paren
r_char
op_star
id|line
comma
r_char
op_star
id|charset
)paren
(brace
macro_line|#ifndef NO_ICONV
r_char
op_star
id|in
comma
op_star
id|out
suffix:semicolon
r_int
id|insize
comma
id|outsize
comma
id|nrc
suffix:semicolon
r_char
id|outbuf
(braket
l_int|4096
)braket
suffix:semicolon
multiline_comment|/* cheat */
r_static
r_char
id|latin_one
(braket
)braket
op_assign
l_string|&quot;latin1&quot;
suffix:semicolon
r_char
op_star
id|input_charset
op_assign
op_star
id|charset
ques
c_cond
id|charset
suffix:colon
id|latin_one
suffix:semicolon
id|iconv_t
id|conv
op_assign
id|iconv_open
c_func
(paren
id|metainfo_charset
comma
id|input_charset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conv
op_eq
(paren
id|iconv_t
)paren
l_int|1
)paren
(brace
r_static
r_int
id|warned_latin1_once
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|input_charset
op_ne
id|latin_one
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;cannot convert from %s to %s&bslash;n&quot;
comma
id|input_charset
comma
id|metainfo_charset
)paren
suffix:semicolon
op_star
id|charset
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|warned_latin1_once
)paren
(brace
id|warned_latin1_once
op_assign
l_int|1
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;tried to convert from %s to %s, &quot;
l_string|&quot;but your iconv does not work with it.&bslash;n&quot;
comma
id|input_charset
comma
id|metainfo_charset
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
id|in
op_assign
id|line
suffix:semicolon
id|insize
op_assign
id|strlen
c_func
(paren
id|in
)paren
suffix:semicolon
id|out
op_assign
id|outbuf
suffix:semicolon
id|outsize
op_assign
r_sizeof
(paren
id|outbuf
)paren
suffix:semicolon
id|nrc
op_assign
id|iconv
c_func
(paren
id|conv
comma
op_amp
id|in
comma
op_amp
id|insize
comma
op_amp
id|out
comma
op_amp
id|outsize
)paren
suffix:semicolon
id|iconv_close
c_func
(paren
id|conv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nrc
op_eq
(paren
r_int
)paren
l_int|1
)paren
r_return
suffix:semicolon
op_star
id|out
op_assign
l_int|0
suffix:semicolon
id|strcpy
c_func
(paren
id|line
comma
id|outbuf
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|decode_header_bq
r_static
r_void
id|decode_header_bq
c_func
(paren
r_char
op_star
id|it
)paren
(brace
r_char
op_star
id|in
comma
op_star
id|out
comma
op_star
id|ep
comma
op_star
id|cp
comma
op_star
id|sp
suffix:semicolon
r_char
id|outbuf
(braket
l_int|1000
)braket
suffix:semicolon
id|in
op_assign
id|it
suffix:semicolon
id|out
op_assign
id|outbuf
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ep
op_assign
id|strstr
c_func
(paren
id|in
comma
l_string|&quot;=?&quot;
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_int
id|sz
comma
id|encoding
suffix:semicolon
r_char
id|charset_q
(braket
l_int|256
)braket
comma
id|piecebuf
(braket
l_int|256
)braket
suffix:semicolon
r_if
c_cond
(paren
id|in
op_ne
id|ep
)paren
(brace
id|sz
op_assign
id|ep
id|in
suffix:semicolon
id|memcpy
c_func
(paren
id|out
comma
id|in
comma
id|sz
)paren
suffix:semicolon
id|out
op_add_assign
id|sz
suffix:semicolon
id|in
op_add_assign
id|sz
suffix:semicolon
)brace
multiline_comment|/* E.g.&n;&t;&t; * ep : &quot;=?iso-2022-jp?B?GyR...?= foo&quot;&n;&t;&t; * ep : &quot;=?ISO-8859-1?Q?Foo=FCbar?= baz&quot;&n;&t;&t; */
id|ep
op_add_assign
l_int|2
suffix:semicolon
id|cp
op_assign
id|strchr
c_func
(paren
id|ep
comma
l_char|&squot;?&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_return
suffix:semicolon
multiline_comment|/* no munging */
r_for
c_loop
(paren
id|sp
op_assign
id|ep
suffix:semicolon
id|sp
OL
id|cp
suffix:semicolon
id|sp
op_increment
)paren
id|charset_q
(braket
id|sp
id|ep
)braket
op_assign
id|tolower
c_func
(paren
op_star
id|sp
)paren
suffix:semicolon
id|charset_q
(braket
id|cp
id|ep
)braket
op_assign
l_int|0
suffix:semicolon
id|encoding
op_assign
id|cp
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|encoding
op_logical_or
id|cp
(braket
l_int|2
)braket
op_ne
l_char|&squot;?&squot;
)paren
r_return
suffix:semicolon
multiline_comment|/* no munging */
id|ep
op_assign
id|strstr
c_func
(paren
id|cp
op_plus
l_int|3
comma
l_string|&quot;?=&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ep
)paren
r_return
suffix:semicolon
multiline_comment|/* no munging */
r_switch
c_cond
(paren
id|tolower
c_func
(paren
id|encoding
)paren
)paren
(brace
r_default
suffix:colon
r_return
suffix:semicolon
multiline_comment|/* no munging */
r_case
l_char|&squot;b&squot;
suffix:colon
id|sz
op_assign
id|decode_b_segment
c_func
(paren
id|cp
op_plus
l_int|3
comma
id|piecebuf
comma
id|ep
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;q&squot;
suffix:colon
id|sz
op_assign
id|decode_q_segment
c_func
(paren
id|cp
op_plus
l_int|3
comma
id|piecebuf
comma
id|ep
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sz
OL
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|metainfo_charset
)paren
id|convert_to_utf8
c_func
(paren
id|piecebuf
comma
id|charset_q
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|out
comma
id|piecebuf
)paren
suffix:semicolon
id|out
op_add_assign
id|strlen
c_func
(paren
id|out
)paren
suffix:semicolon
id|in
op_assign
id|ep
op_plus
l_int|2
suffix:semicolon
)brace
id|strcpy
c_func
(paren
id|out
comma
id|in
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|it
comma
id|outbuf
)paren
suffix:semicolon
)brace
DECL|function|decode_transfer_encoding
r_static
r_void
id|decode_transfer_encoding
c_func
(paren
r_char
op_star
id|line
)paren
(brace
r_char
op_star
id|ep
suffix:semicolon
r_switch
c_cond
(paren
id|transfer_encoding
)paren
(brace
r_case
id|TE_QP
suffix:colon
id|ep
op_assign
id|line
op_plus
id|strlen
c_func
(paren
id|line
)paren
suffix:semicolon
id|decode_q_segment
c_func
(paren
id|line
comma
id|line
comma
id|ep
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TE_BASE64
suffix:colon
id|ep
op_assign
id|line
op_plus
id|strlen
c_func
(paren
id|line
)paren
suffix:semicolon
id|decode_b_segment
c_func
(paren
id|line
comma
id|line
comma
id|ep
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TE_DONTCARE
suffix:colon
r_break
suffix:semicolon
)brace
)brace
DECL|function|handle_info
r_static
r_void
id|handle_info
c_func
(paren
r_void
)paren
(brace
r_char
op_star
id|sub
suffix:semicolon
id|sub
op_assign
id|cleanup_subject
c_func
(paren
id|subject
)paren
suffix:semicolon
id|cleanup_space
c_func
(paren
id|name
)paren
suffix:semicolon
id|cleanup_space
c_func
(paren
id|date
)paren
suffix:semicolon
id|cleanup_space
c_func
(paren
id|email
)paren
suffix:semicolon
id|cleanup_space
c_func
(paren
id|sub
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Author: %s&bslash;nEmail: %s&bslash;nSubject: %s&bslash;nDate: %s&bslash;n&bslash;n&quot;
comma
id|name
comma
id|email
comma
id|sub
comma
id|date
)paren
suffix:semicolon
)brace
multiline_comment|/* We are inside message body and have read line[] already.&n; * Spit out the commit log.&n; */
DECL|function|handle_commit_msg
r_static
r_int
id|handle_commit_msg
c_func
(paren
r_int
op_star
id|seen
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cmitmsg
)paren
r_return
l_int|0
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;diff -&quot;
comma
id|line
comma
l_int|6
)paren
op_logical_or
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;---&quot;
comma
id|line
comma
l_int|3
)paren
op_logical_or
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;Index: &quot;
comma
id|line
comma
l_int|7
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
(paren
id|multipart_boundary
(braket
l_int|0
)braket
op_logical_and
id|is_multipart_boundary
c_func
(paren
id|line
)paren
)paren
)paren
(brace
multiline_comment|/* We come here when the first part had only&n;&t;&t;&t; * the commit message without any patch.  We&n;&t;&t;&t; * pretend we have not seen this line yet, and&n;&t;&t;&t; * go back to the loop.&n;&t;&t;&t; */
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Unwrap transfer encoding and optionally&n;&t;&t; * normalize the log message to UTF-8.&n;&t;&t; */
id|decode_transfer_encoding
c_func
(paren
id|line
)paren
suffix:semicolon
r_if
c_cond
(paren
id|metainfo_charset
)paren
id|convert_to_utf8
c_func
(paren
id|line
comma
id|charset
)paren
suffix:semicolon
id|handle_inbody_header
c_func
(paren
id|seen
comma
id|line
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|seen
op_amp
id|SEEN_PREFIX
)paren
)paren
r_continue
suffix:semicolon
id|fputs
c_func
(paren
id|line
comma
id|cmitmsg
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|fgets
c_func
(paren
id|line
comma
r_sizeof
(paren
id|line
)paren
comma
id|stdin
)paren
op_ne
l_int|NULL
)paren
suffix:semicolon
id|fclose
c_func
(paren
id|cmitmsg
)paren
suffix:semicolon
id|cmitmsg
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* We have done the commit message and have the first&n; * line of the patch in line[].&n; */
DECL|function|handle_patch
r_static
r_void
id|handle_patch
c_func
(paren
r_void
)paren
(brace
r_do
(brace
r_if
c_cond
(paren
id|multipart_boundary
(braket
l_int|0
)braket
op_logical_and
id|is_multipart_boundary
c_func
(paren
id|line
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* Only unwrap transfer encoding but otherwise do not&n;&t;&t; * do anything.  We do *NOT* want UTF-8 conversion&n;&t;&t; * here; we are dealing with the user payload.&n;&t;&t; */
id|decode_transfer_encoding
c_func
(paren
id|line
)paren
suffix:semicolon
id|fputs
c_func
(paren
id|line
comma
id|patchfile
)paren
suffix:semicolon
id|patch_lines
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|fgets
c_func
(paren
id|line
comma
r_sizeof
(paren
id|line
)paren
comma
id|stdin
)paren
op_ne
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/* multipart boundary and transfer encoding are set up for us, and we&n; * are at the end of the sub header.  do equivalent of handle_body up&n; * to the next boundary without closing patchfile --- we will expect&n; * that the first part to contain commit message and a patch, and&n; * handle other parts as pure patches.&n; */
DECL|function|handle_multipart_one_part
r_static
r_int
id|handle_multipart_one_part
c_func
(paren
r_int
op_star
id|seen
)paren
(brace
r_int
id|n
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|fgets
c_func
(paren
id|line
comma
r_sizeof
(paren
id|line
)paren
comma
id|stdin
)paren
op_ne
l_int|NULL
)paren
(brace
id|again
suffix:colon
id|n
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|is_multipart_boundary
c_func
(paren
id|line
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|handle_commit_msg
c_func
(paren
id|seen
)paren
)paren
r_goto
id|again
suffix:semicolon
id|handle_patch
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|n
op_eq
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|handle_multipart_body
r_static
r_void
id|handle_multipart_body
c_func
(paren
r_void
)paren
(brace
r_int
id|seen
op_assign
l_int|0
suffix:semicolon
r_int
id|part_num
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Skip up to the first boundary */
r_while
c_loop
(paren
id|fgets
c_func
(paren
id|line
comma
r_sizeof
(paren
id|line
)paren
comma
id|stdin
)paren
op_ne
l_int|NULL
)paren
r_if
c_cond
(paren
id|is_multipart_boundary
c_func
(paren
id|line
)paren
)paren
(brace
id|part_num
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|part_num
)paren
r_return
suffix:semicolon
multiline_comment|/* We are on boundary line.  Start slurping the subhead. */
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_int
id|hdr
op_assign
id|read_one_header_line
c_func
(paren
id|line
comma
r_sizeof
(paren
id|line
)paren
comma
id|stdin
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hdr
)paren
(brace
r_if
c_cond
(paren
id|handle_multipart_one_part
c_func
(paren
op_amp
id|seen
)paren
OL
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* Reset per part headers */
id|transfer_encoding
op_assign
id|TE_DONTCARE
suffix:semicolon
id|charset
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|check_subheader_line
c_func
(paren
id|line
)paren
suffix:semicolon
)brace
id|fclose
c_func
(paren
id|patchfile
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|patch_lines
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;No patch found&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Non multipart message */
DECL|function|handle_body
r_static
r_void
id|handle_body
c_func
(paren
r_void
)paren
(brace
r_int
id|seen
op_assign
l_int|0
suffix:semicolon
id|handle_commit_msg
c_func
(paren
op_amp
id|seen
)paren
suffix:semicolon
id|handle_patch
c_func
(paren
)paren
suffix:semicolon
id|fclose
c_func
(paren
id|patchfile
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|patch_lines
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;No patch found&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
)brace
DECL|variable|mailinfo_usage
r_static
r_const
r_char
id|mailinfo_usage
(braket
)braket
op_assign
l_string|&quot;git-mailinfo [-k] [-u | --encoding=&lt;encoding&gt;] msg patch &lt;mail &gt;info&quot;
suffix:semicolon
DECL|function|main
r_int
id|main
c_func
(paren
r_int
id|argc
comma
r_char
op_star
op_star
id|argv
)paren
(brace
multiline_comment|/* NEEDSWORK: might want to do the optional .git/ directory&n;&t; * discovery&n;&t; */
id|git_config
c_func
(paren
id|git_default_config
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
OL
id|argc
op_logical_and
id|argv
(braket
l_int|1
)braket
(braket
l_int|0
)braket
op_eq
l_char|&squot;-&squot;
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
l_string|&quot;-k&quot;
)paren
)paren
id|keep_subject
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
l_string|&quot;-u&quot;
)paren
)paren
id|metainfo_charset
op_assign
id|git_commit_encoding
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
l_string|&quot;--encoding=&quot;
comma
l_int|11
)paren
)paren
id|metainfo_charset
op_assign
id|argv
(braket
l_int|1
)braket
op_plus
l_int|11
suffix:semicolon
r_else
id|usage
c_func
(paren
id|mailinfo_usage
)paren
suffix:semicolon
id|argc
op_decrement
suffix:semicolon
id|argv
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|argc
op_ne
l_int|3
)paren
id|usage
c_func
(paren
id|mailinfo_usage
)paren
suffix:semicolon
id|cmitmsg
op_assign
id|fopen
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
l_string|&quot;w&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmitmsg
)paren
(brace
id|perror
c_func
(paren
id|argv
(braket
l_int|1
)braket
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|patchfile
op_assign
id|fopen
c_func
(paren
id|argv
(braket
l_int|2
)braket
comma
l_string|&quot;w&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|patchfile
)paren
(brace
id|perror
c_func
(paren
id|argv
(braket
l_int|2
)braket
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_int
id|hdr
op_assign
id|read_one_header_line
c_func
(paren
id|line
comma
r_sizeof
(paren
id|line
)paren
comma
id|stdin
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hdr
)paren
(brace
r_if
c_cond
(paren
id|multipart_boundary
(braket
l_int|0
)braket
)paren
id|handle_multipart_body
c_func
(paren
)paren
suffix:semicolon
r_else
id|handle_body
c_func
(paren
)paren
suffix:semicolon
id|handle_info
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|check_header_line
c_func
(paren
id|line
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
