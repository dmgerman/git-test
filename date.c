multiline_comment|/*&n; * GIT - The information manager from hell&n; *&n; * Copyright (C) Linus Torvalds, 2005&n; */
macro_line|#include &quot;cache.h&quot;
multiline_comment|/*&n; * This is like mktime, but without normalization of tm_wday and tm_yday.&n; */
DECL|function|tm_to_time_t
r_static
id|time_t
id|tm_to_time_t
c_func
(paren
r_const
r_struct
id|tm
op_star
id|tm
)paren
(brace
r_static
r_const
r_int
id|mdays
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|31
comma
l_int|59
comma
l_int|90
comma
l_int|120
comma
l_int|151
comma
l_int|181
comma
l_int|212
comma
l_int|243
comma
l_int|273
comma
l_int|304
comma
l_int|334
)brace
suffix:semicolon
r_int
id|year
op_assign
id|tm-&gt;tm_year
l_int|70
suffix:semicolon
r_int
id|month
op_assign
id|tm-&gt;tm_mon
suffix:semicolon
r_int
id|day
op_assign
id|tm-&gt;tm_mday
suffix:semicolon
r_if
c_cond
(paren
id|year
template_param
l_int|129
)paren
multiline_comment|/* algo only works for 1970-2099 */
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|month
template_param
l_int|11
)paren
multiline_comment|/* array bounds */
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|month
OL
l_int|2
op_logical_or
(paren
id|year
op_plus
l_int|2
)paren
op_mod
l_int|4
)paren
id|day
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|tm-&gt;tm_hour
OL
l_int|0
op_logical_or
id|tm-&gt;tm_min
OL
l_int|0
op_logical_or
id|tm-&gt;tm_sec
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_return
(paren
id|year
op_star
l_int|365
op_plus
(paren
id|year
op_plus
l_int|1
)paren
op_div
l_int|4
op_plus
id|mdays
(braket
id|month
)braket
op_plus
id|day
)paren
op_star
l_int|24
op_star
l_int|60
op_star
l_int|60UL
op_plus
id|tm-&gt;tm_hour
op_star
l_int|60
op_star
l_int|60
op_plus
id|tm-&gt;tm_min
op_star
l_int|60
op_plus
id|tm-&gt;tm_sec
suffix:semicolon
)brace
DECL|variable|month_names
r_static
r_const
r_char
op_star
id|month_names
(braket
)braket
op_assign
(brace
l_string|&quot;January&quot;
comma
l_string|&quot;February&quot;
comma
l_string|&quot;March&quot;
comma
l_string|&quot;April&quot;
comma
l_string|&quot;May&quot;
comma
l_string|&quot;June&quot;
comma
l_string|&quot;July&quot;
comma
l_string|&quot;August&quot;
comma
l_string|&quot;September&quot;
comma
l_string|&quot;October&quot;
comma
l_string|&quot;November&quot;
comma
l_string|&quot;December&quot;
)brace
suffix:semicolon
DECL|variable|weekday_names
r_static
r_const
r_char
op_star
id|weekday_names
(braket
)braket
op_assign
(brace
l_string|&quot;Sundays&quot;
comma
l_string|&quot;Mondays&quot;
comma
l_string|&quot;Tuesdays&quot;
comma
l_string|&quot;Wednesdays&quot;
comma
l_string|&quot;Thursdays&quot;
comma
l_string|&quot;Fridays&quot;
comma
l_string|&quot;Saturdays&quot;
)brace
suffix:semicolon
DECL|function|gm_time_t
r_static
id|time_t
id|gm_time_t
c_func
(paren
r_int
r_int
id|time
comma
r_int
id|tz
)paren
(brace
r_int
id|minutes
suffix:semicolon
id|minutes
op_assign
id|tz
OL
l_int|0
ques
c_cond
id|tz
suffix:colon
id|tz
suffix:semicolon
id|minutes
op_assign
(paren
id|minutes
op_div
l_int|100
)paren
op_star
l_int|60
op_plus
(paren
id|minutes
op_mod
l_int|100
)paren
suffix:semicolon
id|minutes
op_assign
id|tz
OL
l_int|0
ques
c_cond
id|minutes
suffix:colon
id|minutes
suffix:semicolon
r_return
id|time
op_plus
id|minutes
op_star
l_int|60
suffix:semicolon
)brace
multiline_comment|/*&n; * The &quot;tz&quot; thing is passed in as this strange &quot;decimal parse of tz&quot;&n; * thing, which means that tz -0100 is passed in as the integer -100,&n; * even though it means &quot;sixty minutes off&quot;&n; */
DECL|function|time_to_tm
r_static
r_struct
id|tm
op_star
id|time_to_tm
c_func
(paren
r_int
r_int
id|time
comma
r_int
id|tz
)paren
(brace
id|time_t
id|t
op_assign
id|gm_time_t
c_func
(paren
id|time
comma
id|tz
)paren
suffix:semicolon
r_return
id|gmtime
c_func
(paren
op_amp
id|t
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * What value of &quot;tz&quot; was in effect back then at &quot;time&quot; in the&n; * local timezone?&n; */
DECL|function|local_tzoffset
r_static
r_int
id|local_tzoffset
c_func
(paren
r_int
r_int
id|time
)paren
(brace
id|time_t
id|t
comma
id|t_local
suffix:semicolon
r_struct
id|tm
id|tm
suffix:semicolon
r_int
id|offset
comma
id|eastwest
suffix:semicolon
id|t
op_assign
id|time
suffix:semicolon
id|localtime_r
c_func
(paren
op_amp
id|t
comma
op_amp
id|tm
)paren
suffix:semicolon
id|t_local
op_assign
id|tm_to_time_t
c_func
(paren
op_amp
id|tm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t_local
OL
id|t
)paren
(brace
id|eastwest
op_assign
l_int|1
suffix:semicolon
id|offset
op_assign
id|t
id|t_local
suffix:semicolon
)brace
r_else
(brace
id|eastwest
op_assign
l_int|1
suffix:semicolon
id|offset
op_assign
id|t_local
id|t
suffix:semicolon
)brace
id|offset
op_div_assign
l_int|60
suffix:semicolon
multiline_comment|/* in minutes */
id|offset
op_assign
(paren
id|offset
op_mod
l_int|60
)paren
op_plus
(paren
(paren
id|offset
op_div
l_int|60
)paren
op_star
l_int|100
)paren
suffix:semicolon
r_return
id|offset
op_star
id|eastwest
suffix:semicolon
)brace
DECL|function|show_date_relative
r_void
id|show_date_relative
c_func
(paren
r_int
r_int
id|time
comma
r_int
id|tz
comma
r_const
r_struct
id|timeval
op_star
id|now
comma
r_struct
id|strbuf
op_star
id|timebuf
)paren
(brace
r_int
r_int
id|diff
suffix:semicolon
r_if
c_cond
(paren
id|now-&gt;tv_sec
OL
id|time
)paren
(brace
id|strbuf_addstr
c_func
(paren
id|timebuf
comma
id|_
c_func
(paren
l_string|&quot;in the future&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|diff
op_assign
id|now-&gt;tv_sec
id|time
suffix:semicolon
r_if
c_cond
(paren
id|diff
OL
l_int|90
)paren
(brace
id|strbuf_addf
c_func
(paren
id|timebuf
comma
id|Q_
c_func
(paren
l_string|&quot;%lu second ago&quot;
comma
l_string|&quot;%lu seconds ago&quot;
comma
id|diff
)paren
comma
id|diff
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Turn it into minutes */
id|diff
op_assign
(paren
id|diff
op_plus
l_int|30
)paren
op_div
l_int|60
suffix:semicolon
r_if
c_cond
(paren
id|diff
OL
l_int|90
)paren
(brace
id|strbuf_addf
c_func
(paren
id|timebuf
comma
id|Q_
c_func
(paren
l_string|&quot;%lu minute ago&quot;
comma
l_string|&quot;%lu minutes ago&quot;
comma
id|diff
)paren
comma
id|diff
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Turn it into hours */
id|diff
op_assign
(paren
id|diff
op_plus
l_int|30
)paren
op_div
l_int|60
suffix:semicolon
r_if
c_cond
(paren
id|diff
OL
l_int|36
)paren
(brace
id|strbuf_addf
c_func
(paren
id|timebuf
comma
id|Q_
c_func
(paren
l_string|&quot;%lu hour ago&quot;
comma
l_string|&quot;%lu hours ago&quot;
comma
id|diff
)paren
comma
id|diff
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* We deal with number of days from here on */
id|diff
op_assign
(paren
id|diff
op_plus
l_int|12
)paren
op_div
l_int|24
suffix:semicolon
r_if
c_cond
(paren
id|diff
OL
l_int|14
)paren
(brace
id|strbuf_addf
c_func
(paren
id|timebuf
comma
id|Q_
c_func
(paren
l_string|&quot;%lu day ago&quot;
comma
l_string|&quot;%lu days ago&quot;
comma
id|diff
)paren
comma
id|diff
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Say weeks for the past 10 weeks or so */
r_if
c_cond
(paren
id|diff
OL
l_int|70
)paren
(brace
id|strbuf_addf
c_func
(paren
id|timebuf
comma
id|Q_
c_func
(paren
l_string|&quot;%lu week ago&quot;
comma
l_string|&quot;%lu weeks ago&quot;
comma
(paren
id|diff
op_plus
l_int|3
)paren
op_div
l_int|7
)paren
comma
(paren
id|diff
op_plus
l_int|3
)paren
op_div
l_int|7
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Say months for the past 12 months or so */
r_if
c_cond
(paren
id|diff
OL
l_int|365
)paren
(brace
id|strbuf_addf
c_func
(paren
id|timebuf
comma
id|Q_
c_func
(paren
l_string|&quot;%lu month ago&quot;
comma
l_string|&quot;%lu months ago&quot;
comma
(paren
id|diff
op_plus
l_int|15
)paren
op_div
l_int|30
)paren
comma
(paren
id|diff
op_plus
l_int|15
)paren
op_div
l_int|30
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Give years and months for 5 years or so */
r_if
c_cond
(paren
id|diff
OL
l_int|1825
)paren
(brace
r_int
r_int
id|totalmonths
op_assign
(paren
id|diff
op_star
l_int|12
op_star
l_int|2
op_plus
l_int|365
)paren
op_div
(paren
l_int|365
op_star
l_int|2
)paren
suffix:semicolon
r_int
r_int
id|years
op_assign
id|totalmonths
op_div
l_int|12
suffix:semicolon
r_int
r_int
id|months
op_assign
id|totalmonths
op_mod
l_int|12
suffix:semicolon
r_if
c_cond
(paren
id|months
)paren
(brace
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
id|sb
comma
id|Q_
c_func
(paren
l_string|&quot;%lu year&quot;
comma
l_string|&quot;%lu years&quot;
comma
id|years
)paren
comma
id|years
)paren
suffix:semicolon
id|strbuf_addf
c_func
(paren
id|timebuf
comma
multiline_comment|/* TRANSLATORS: &quot;%s&quot; is &quot;&lt;n&gt; years&quot; */
id|Q_
c_func
(paren
l_string|&quot;%s, %lu month ago&quot;
comma
l_string|&quot;%s, %lu months ago&quot;
comma
id|months
)paren
comma
id|sb.buf
comma
id|months
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
)brace
r_else
id|strbuf_addf
c_func
(paren
id|timebuf
comma
id|Q_
c_func
(paren
l_string|&quot;%lu year ago&quot;
comma
l_string|&quot;%lu years ago&quot;
comma
id|years
)paren
comma
id|years
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Otherwise, just years. Centuries is probably overkill. */
id|strbuf_addf
c_func
(paren
id|timebuf
comma
id|Q_
c_func
(paren
l_string|&quot;%lu year ago&quot;
comma
l_string|&quot;%lu years ago&quot;
comma
(paren
id|diff
op_plus
l_int|183
)paren
op_div
l_int|365
)paren
comma
(paren
id|diff
op_plus
l_int|183
)paren
op_div
l_int|365
)paren
suffix:semicolon
)brace
DECL|function|show_date
r_const
r_char
op_star
id|show_date
c_func
(paren
r_int
r_int
id|time
comma
r_int
id|tz
comma
r_enum
id|date_mode
id|mode
)paren
(brace
r_struct
id|tm
op_star
id|tm
suffix:semicolon
r_static
r_struct
id|strbuf
id|timebuf
op_assign
id|STRBUF_INIT
suffix:semicolon
r_if
c_cond
(paren
id|mode
op_eq
id|DATE_RAW
)paren
(brace
id|strbuf_reset
c_func
(paren
op_amp
id|timebuf
)paren
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
id|timebuf
comma
l_string|&quot;%lu %+05d&quot;
comma
id|time
comma
id|tz
)paren
suffix:semicolon
r_return
id|timebuf.buf
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mode
op_eq
id|DATE_RELATIVE
)paren
(brace
r_struct
id|timeval
id|now
suffix:semicolon
id|strbuf_reset
c_func
(paren
op_amp
id|timebuf
)paren
suffix:semicolon
id|gettimeofday
c_func
(paren
op_amp
id|now
comma
l_int|NULL
)paren
suffix:semicolon
id|show_date_relative
c_func
(paren
id|time
comma
id|tz
comma
op_amp
id|now
comma
op_amp
id|timebuf
)paren
suffix:semicolon
r_return
id|timebuf.buf
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mode
op_eq
id|DATE_LOCAL
)paren
id|tz
op_assign
id|local_tzoffset
c_func
(paren
id|time
)paren
suffix:semicolon
id|tm
op_assign
id|time_to_tm
c_func
(paren
id|time
comma
id|tz
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tm
)paren
(brace
id|tm
op_assign
id|time_to_tm
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|tz
op_assign
l_int|0
suffix:semicolon
)brace
id|strbuf_reset
c_func
(paren
op_amp
id|timebuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mode
op_eq
id|DATE_SHORT
)paren
id|strbuf_addf
c_func
(paren
op_amp
id|timebuf
comma
l_string|&quot;%04d-%02d-%02d&quot;
comma
id|tm-&gt;tm_year
op_plus
l_int|1900
comma
id|tm-&gt;tm_mon
op_plus
l_int|1
comma
id|tm-&gt;tm_mday
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|mode
op_eq
id|DATE_ISO8601
)paren
id|strbuf_addf
c_func
(paren
op_amp
id|timebuf
comma
l_string|&quot;%04d-%02d-%02d %02d:%02d:%02d %+05d&quot;
comma
id|tm-&gt;tm_year
op_plus
l_int|1900
comma
id|tm-&gt;tm_mon
op_plus
l_int|1
comma
id|tm-&gt;tm_mday
comma
id|tm-&gt;tm_hour
comma
id|tm-&gt;tm_min
comma
id|tm-&gt;tm_sec
comma
id|tz
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|mode
op_eq
id|DATE_RFC2822
)paren
id|strbuf_addf
c_func
(paren
op_amp
id|timebuf
comma
l_string|&quot;%.3s, %d %.3s %d %02d:%02d:%02d %+05d&quot;
comma
id|weekday_names
(braket
id|tm-&gt;tm_wday
)braket
comma
id|tm-&gt;tm_mday
comma
id|month_names
(braket
id|tm-&gt;tm_mon
)braket
comma
id|tm-&gt;tm_year
op_plus
l_int|1900
comma
id|tm-&gt;tm_hour
comma
id|tm-&gt;tm_min
comma
id|tm-&gt;tm_sec
comma
id|tz
)paren
suffix:semicolon
r_else
id|strbuf_addf
c_func
(paren
op_amp
id|timebuf
comma
l_string|&quot;%.3s %.3s %d %02d:%02d:%02d %d%c%+05d&quot;
comma
id|weekday_names
(braket
id|tm-&gt;tm_wday
)braket
comma
id|month_names
(braket
id|tm-&gt;tm_mon
)braket
comma
id|tm-&gt;tm_mday
comma
id|tm-&gt;tm_hour
comma
id|tm-&gt;tm_min
comma
id|tm-&gt;tm_sec
comma
id|tm-&gt;tm_year
op_plus
l_int|1900
comma
(paren
id|mode
op_eq
id|DATE_LOCAL
)paren
ques
c_cond
l_int|0
suffix:colon
l_char|&squot; &squot;
comma
id|tz
)paren
suffix:semicolon
r_return
id|timebuf.buf
suffix:semicolon
)brace
multiline_comment|/*&n; * Check these. And note how it doesn&squot;t do the summer-time conversion.&n; *&n; * In my world, it&squot;s always summer, and things are probably a bit off&n; * in other ways too.&n; */
r_static
r_const
r_struct
(brace
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
DECL|member|offset
r_int
id|offset
suffix:semicolon
DECL|member|dst
r_int
id|dst
suffix:semicolon
DECL|variable|timezone_names
)brace
id|timezone_names
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;IDLW&quot;
comma
l_int|12
comma
l_int|0
comma
)brace
comma
multiline_comment|/* International Date Line West */
(brace
l_string|&quot;NT&quot;
comma
l_int|11
comma
l_int|0
comma
)brace
comma
multiline_comment|/* Nome */
(brace
l_string|&quot;CAT&quot;
comma
l_int|10
comma
l_int|0
comma
)brace
comma
multiline_comment|/* Central Alaska */
(brace
l_string|&quot;HST&quot;
comma
l_int|10
comma
l_int|0
comma
)brace
comma
multiline_comment|/* Hawaii Standard */
(brace
l_string|&quot;HDT&quot;
comma
l_int|10
comma
l_int|1
comma
)brace
comma
multiline_comment|/* Hawaii Daylight */
(brace
l_string|&quot;YST&quot;
comma
l_int|9
comma
l_int|0
comma
)brace
comma
multiline_comment|/* Yukon Standard */
(brace
l_string|&quot;YDT&quot;
comma
l_int|9
comma
l_int|1
comma
)brace
comma
multiline_comment|/* Yukon Daylight */
(brace
l_string|&quot;PST&quot;
comma
l_int|8
comma
l_int|0
comma
)brace
comma
multiline_comment|/* Pacific Standard */
(brace
l_string|&quot;PDT&quot;
comma
l_int|8
comma
l_int|1
comma
)brace
comma
multiline_comment|/* Pacific Daylight */
(brace
l_string|&quot;MST&quot;
comma
l_int|7
comma
l_int|0
comma
)brace
comma
multiline_comment|/* Mountain Standard */
(brace
l_string|&quot;MDT&quot;
comma
l_int|7
comma
l_int|1
comma
)brace
comma
multiline_comment|/* Mountain Daylight */
(brace
l_string|&quot;CST&quot;
comma
l_int|6
comma
l_int|0
comma
)brace
comma
multiline_comment|/* Central Standard */
(brace
l_string|&quot;CDT&quot;
comma
l_int|6
comma
l_int|1
comma
)brace
comma
multiline_comment|/* Central Daylight */
(brace
l_string|&quot;EST&quot;
comma
l_int|5
comma
l_int|0
comma
)brace
comma
multiline_comment|/* Eastern Standard */
(brace
l_string|&quot;EDT&quot;
comma
l_int|5
comma
l_int|1
comma
)brace
comma
multiline_comment|/* Eastern Daylight */
(brace
l_string|&quot;AST&quot;
comma
l_int|3
comma
l_int|0
comma
)brace
comma
multiline_comment|/* Atlantic Standard */
(brace
l_string|&quot;ADT&quot;
comma
l_int|3
comma
l_int|1
comma
)brace
comma
multiline_comment|/* Atlantic Daylight */
(brace
l_string|&quot;WAT&quot;
comma
l_int|1
comma
l_int|0
comma
)brace
comma
multiline_comment|/* West Africa */
(brace
l_string|&quot;GMT&quot;
comma
l_int|0
comma
l_int|0
comma
)brace
comma
multiline_comment|/* Greenwich Mean */
(brace
l_string|&quot;UTC&quot;
comma
l_int|0
comma
l_int|0
comma
)brace
comma
multiline_comment|/* Universal (Coordinated) */
(brace
l_string|&quot;Z&quot;
comma
l_int|0
comma
l_int|0
comma
)brace
comma
multiline_comment|/* Zulu, alias for UTC */
(brace
l_string|&quot;WET&quot;
comma
l_int|0
comma
l_int|0
comma
)brace
comma
multiline_comment|/* Western European */
(brace
l_string|&quot;BST&quot;
comma
l_int|0
comma
l_int|1
comma
)brace
comma
multiline_comment|/* British Summer */
(brace
l_string|&quot;CET&quot;
comma
op_plus
l_int|1
comma
l_int|0
comma
)brace
comma
multiline_comment|/* Central European */
(brace
l_string|&quot;MET&quot;
comma
op_plus
l_int|1
comma
l_int|0
comma
)brace
comma
multiline_comment|/* Middle European */
(brace
l_string|&quot;MEWT&quot;
comma
op_plus
l_int|1
comma
l_int|0
comma
)brace
comma
multiline_comment|/* Middle European Winter */
(brace
l_string|&quot;MEST&quot;
comma
op_plus
l_int|1
comma
l_int|1
comma
)brace
comma
multiline_comment|/* Middle European Summer */
(brace
l_string|&quot;CEST&quot;
comma
op_plus
l_int|1
comma
l_int|1
comma
)brace
comma
multiline_comment|/* Central European Summer */
(brace
l_string|&quot;MESZ&quot;
comma
op_plus
l_int|1
comma
l_int|1
comma
)brace
comma
multiline_comment|/* Middle European Summer */
(brace
l_string|&quot;FWT&quot;
comma
op_plus
l_int|1
comma
l_int|0
comma
)brace
comma
multiline_comment|/* French Winter */
(brace
l_string|&quot;FST&quot;
comma
op_plus
l_int|1
comma
l_int|1
comma
)brace
comma
multiline_comment|/* French Summer */
(brace
l_string|&quot;EET&quot;
comma
op_plus
l_int|2
comma
l_int|0
comma
)brace
comma
multiline_comment|/* Eastern Europe, USSR Zone 1 */
(brace
l_string|&quot;EEST&quot;
comma
op_plus
l_int|2
comma
l_int|1
comma
)brace
comma
multiline_comment|/* Eastern European Daylight */
(brace
l_string|&quot;WAST&quot;
comma
op_plus
l_int|7
comma
l_int|0
comma
)brace
comma
multiline_comment|/* West Australian Standard */
(brace
l_string|&quot;WADT&quot;
comma
op_plus
l_int|7
comma
l_int|1
comma
)brace
comma
multiline_comment|/* West Australian Daylight */
(brace
l_string|&quot;CCT&quot;
comma
op_plus
l_int|8
comma
l_int|0
comma
)brace
comma
multiline_comment|/* China Coast, USSR Zone 7 */
(brace
l_string|&quot;JST&quot;
comma
op_plus
l_int|9
comma
l_int|0
comma
)brace
comma
multiline_comment|/* Japan Standard, USSR Zone 8 */
(brace
l_string|&quot;EAST&quot;
comma
op_plus
l_int|10
comma
l_int|0
comma
)brace
comma
multiline_comment|/* Eastern Australian Standard */
(brace
l_string|&quot;EADT&quot;
comma
op_plus
l_int|10
comma
l_int|1
comma
)brace
comma
multiline_comment|/* Eastern Australian Daylight */
(brace
l_string|&quot;GST&quot;
comma
op_plus
l_int|10
comma
l_int|0
comma
)brace
comma
multiline_comment|/* Guam Standard, USSR Zone 9 */
(brace
l_string|&quot;NZT&quot;
comma
op_plus
l_int|12
comma
l_int|0
comma
)brace
comma
multiline_comment|/* New Zealand */
(brace
l_string|&quot;NZST&quot;
comma
op_plus
l_int|12
comma
l_int|0
comma
)brace
comma
multiline_comment|/* New Zealand Standard */
(brace
l_string|&quot;NZDT&quot;
comma
op_plus
l_int|12
comma
l_int|1
comma
)brace
comma
multiline_comment|/* New Zealand Daylight */
(brace
l_string|&quot;IDLE&quot;
comma
op_plus
l_int|12
comma
l_int|0
comma
)brace
comma
multiline_comment|/* International Date Line East */
)brace
suffix:semicolon
DECL|function|match_string
r_static
r_int
id|match_string
c_func
(paren
r_const
r_char
op_star
id|date
comma
r_const
r_char
op_star
id|str
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
op_star
id|date
suffix:semicolon
id|date
op_increment
comma
id|str
op_increment
comma
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_star
id|date
op_eq
op_star
id|str
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|toupper
c_func
(paren
op_star
id|date
)paren
op_eq
id|toupper
c_func
(paren
op_star
id|str
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|isalnum
c_func
(paren
op_star
id|date
)paren
)paren
r_break
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|i
suffix:semicolon
)brace
DECL|function|skip_alpha
r_static
r_int
id|skip_alpha
c_func
(paren
r_const
r_char
op_star
id|date
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|i
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|isalpha
c_func
(paren
id|date
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/*&n;* Parse month, weekday, or timezone name&n;*/
DECL|function|match_alpha
r_static
r_int
id|match_alpha
c_func
(paren
r_const
r_char
op_star
id|date
comma
r_struct
id|tm
op_star
id|tm
comma
r_int
op_star
id|offset
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|12
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|match
op_assign
id|match_string
c_func
(paren
id|date
comma
id|month_names
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|match
op_ge
l_int|3
)paren
(brace
id|tm-&gt;tm_mon
op_assign
id|i
suffix:semicolon
r_return
id|match
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|7
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|match
op_assign
id|match_string
c_func
(paren
id|date
comma
id|weekday_names
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|match
op_ge
l_int|3
)paren
(brace
id|tm-&gt;tm_wday
op_assign
id|i
suffix:semicolon
r_return
id|match
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|timezone_names
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|match
op_assign
id|match_string
c_func
(paren
id|date
comma
id|timezone_names
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|match
op_ge
l_int|3
op_logical_or
id|match
op_eq
id|strlen
c_func
(paren
id|timezone_names
(braket
id|i
)braket
dot
id|name
)paren
)paren
(brace
r_int
id|off
op_assign
id|timezone_names
(braket
id|i
)braket
dot
id|offset
suffix:semicolon
multiline_comment|/* This is bogus, but we like summer */
id|off
op_add_assign
id|timezone_names
(braket
id|i
)braket
dot
id|dst
suffix:semicolon
multiline_comment|/* Only use the tz name offset if we don&squot;t have anything better */
r_if
c_cond
(paren
op_star
id|offset
op_eq
l_int|1
)paren
op_star
id|offset
op_assign
l_int|60
op_star
id|off
suffix:semicolon
r_return
id|match
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|match_string
c_func
(paren
id|date
comma
l_string|&quot;PM&quot;
)paren
op_eq
l_int|2
)paren
(brace
id|tm-&gt;tm_hour
op_assign
(paren
id|tm-&gt;tm_hour
op_mod
l_int|12
)paren
op_plus
l_int|12
suffix:semicolon
r_return
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|match_string
c_func
(paren
id|date
comma
l_string|&quot;AM&quot;
)paren
op_eq
l_int|2
)paren
(brace
id|tm-&gt;tm_hour
op_assign
(paren
id|tm-&gt;tm_hour
op_mod
l_int|12
)paren
op_plus
l_int|0
suffix:semicolon
r_return
l_int|2
suffix:semicolon
)brace
multiline_comment|/* BAD CRAP */
r_return
id|skip_alpha
c_func
(paren
id|date
)paren
suffix:semicolon
)brace
DECL|function|is_date
r_static
r_int
id|is_date
c_func
(paren
r_int
id|year
comma
r_int
id|month
comma
r_int
id|day
comma
r_struct
id|tm
op_star
id|now_tm
comma
id|time_t
id|now
comma
r_struct
id|tm
op_star
id|tm
)paren
(brace
r_if
c_cond
(paren
id|month
OG
l_int|0
op_logical_and
id|month
template_param
l_int|0
op_logical_and
id|day
OL
l_int|32
)paren
(brace
r_struct
id|tm
id|check
op_assign
op_star
id|tm
suffix:semicolon
r_struct
id|tm
op_star
id|r
op_assign
(paren
id|now_tm
ques
c_cond
op_amp
id|check
suffix:colon
id|tm
)paren
suffix:semicolon
id|time_t
id|specified
suffix:semicolon
id|r-&gt;tm_mon
op_assign
id|month
l_int|1
suffix:semicolon
id|r-&gt;tm_mday
op_assign
id|day
suffix:semicolon
r_if
c_cond
(paren
id|year
op_eq
l_int|1
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|now_tm
)paren
r_return
l_int|1
suffix:semicolon
id|r-&gt;tm_year
op_assign
id|now_tm-&gt;tm_year
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|year
op_ge
l_int|1970
op_logical_and
id|year
OL
l_int|2100
)paren
id|r-&gt;tm_year
op_assign
id|year
l_int|1900
suffix:semicolon
r_else
r_if
c_cond
(paren
id|year
OG
l_int|70
op_logical_and
id|year
OL
l_int|100
)paren
id|r-&gt;tm_year
op_assign
id|year
suffix:semicolon
r_else
r_if
c_cond
(paren
id|year
OL
l_int|38
)paren
id|r-&gt;tm_year
op_assign
id|year
op_plus
l_int|100
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|now_tm
)paren
r_return
l_int|1
suffix:semicolon
id|specified
op_assign
id|tm_to_time_t
c_func
(paren
id|r
)paren
suffix:semicolon
multiline_comment|/* Be it commit time or author time, it does not make&n;&t;&t; * sense to specify timestamp way into the future.  Make&n;&t;&t; * sure it is not later than ten days from now...&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|specified
op_ne
l_int|1
)paren
op_logical_and
(paren
id|now
op_plus
l_int|10
op_star
l_int|24
op_star
l_int|3600
OL
id|specified
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|tm-&gt;tm_mon
op_assign
id|r-&gt;tm_mon
suffix:semicolon
id|tm-&gt;tm_mday
op_assign
id|r-&gt;tm_mday
suffix:semicolon
r_if
c_cond
(paren
id|year
op_ne
l_int|1
)paren
id|tm-&gt;tm_year
op_assign
id|r-&gt;tm_year
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|match_multi_number
r_static
r_int
id|match_multi_number
c_func
(paren
r_int
r_int
id|num
comma
r_char
id|c
comma
r_const
r_char
op_star
id|date
comma
r_char
op_star
id|end
comma
r_struct
id|tm
op_star
id|tm
)paren
(brace
id|time_t
id|now
suffix:semicolon
r_struct
id|tm
id|now_tm
suffix:semicolon
r_struct
id|tm
op_star
id|refuse_future
suffix:semicolon
r_int
id|num2
comma
id|num3
suffix:semicolon
id|num2
op_assign
id|strtol
c_func
(paren
id|end
op_plus
l_int|1
comma
op_amp
id|end
comma
l_int|10
)paren
suffix:semicolon
id|num3
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_star
id|end
op_eq
id|c
op_logical_and
id|isdigit
c_func
(paren
id|end
(braket
l_int|1
)braket
)paren
)paren
id|num3
op_assign
id|strtol
c_func
(paren
id|end
op_plus
l_int|1
comma
op_amp
id|end
comma
l_int|10
)paren
suffix:semicolon
multiline_comment|/* Time? Date? */
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
l_char|&squot;:&squot;
suffix:colon
r_if
c_cond
(paren
id|num3
OL
l_int|0
)paren
id|num3
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|num
OL
l_int|25
op_logical_and
id|num2
op_ge
l_int|0
op_logical_and
id|num2
OL
l_int|60
op_logical_and
id|num3
op_ge
l_int|0
op_logical_and
id|num3
op_le
l_int|60
)paren
(brace
id|tm-&gt;tm_hour
op_assign
id|num
suffix:semicolon
id|tm-&gt;tm_min
op_assign
id|num2
suffix:semicolon
id|tm-&gt;tm_sec
op_assign
id|num3
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
l_char|&squot;-&squot;
suffix:colon
r_case
l_char|&squot;/&squot;
suffix:colon
r_case
l_char|&squot;.&squot;
suffix:colon
id|now
op_assign
id|time
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
id|refuse_future
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|gmtime_r
c_func
(paren
op_amp
id|now
comma
op_amp
id|now_tm
)paren
)paren
id|refuse_future
op_assign
op_amp
id|now_tm
suffix:semicolon
r_if
c_cond
(paren
id|num
OG
l_int|70
)paren
(brace
multiline_comment|/* yyyy-mm-dd? */
r_if
c_cond
(paren
id|is_date
c_func
(paren
id|num
comma
id|num2
comma
id|num3
comma
id|refuse_future
comma
id|now
comma
id|tm
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* yyyy-dd-mm? */
r_if
c_cond
(paren
id|is_date
c_func
(paren
id|num
comma
id|num3
comma
id|num2
comma
id|refuse_future
comma
id|now
comma
id|tm
)paren
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* Our eastern European friends say dd.mm.yy[yy]&n;&t;&t; * is the norm there, so giving precedence to&n;&t;&t; * mm/dd/yy[yy] form only when separator is not &squot;.&squot;&n;&t;&t; */
r_if
c_cond
(paren
id|c
op_ne
l_char|&squot;.&squot;
op_logical_and
id|is_date
c_func
(paren
id|num3
comma
id|num
comma
id|num2
comma
id|refuse_future
comma
id|now
comma
id|tm
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* European dd.mm.yy[yy] or funny US dd/mm/yy[yy] */
r_if
c_cond
(paren
id|is_date
c_func
(paren
id|num3
comma
id|num2
comma
id|num
comma
id|refuse_future
comma
id|now
comma
id|tm
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* Funny European mm.dd.yy */
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;.&squot;
op_logical_and
id|is_date
c_func
(paren
id|num3
comma
id|num
comma
id|num2
comma
id|refuse_future
comma
id|now
comma
id|tm
)paren
)paren
r_break
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|end
id|date
suffix:semicolon
)brace
multiline_comment|/*&n; * Have we filled in any part of the time/date yet?&n; * We just do a binary &squot;and&squot; to see if the sign bit&n; * is set in all the values.&n; */
DECL|function|nodate
r_static
r_inline
r_int
id|nodate
c_func
(paren
r_struct
id|tm
op_star
id|tm
)paren
(brace
r_return
(paren
id|tm-&gt;tm_year
op_amp
id|tm-&gt;tm_mon
op_amp
id|tm-&gt;tm_mday
op_amp
id|tm-&gt;tm_hour
op_amp
id|tm-&gt;tm_min
op_amp
id|tm-&gt;tm_sec
)paren
OL
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * We&squot;ve seen a digit. Time? Year? Date?&n; */
DECL|function|match_digit
r_static
r_int
id|match_digit
c_func
(paren
r_const
r_char
op_star
id|date
comma
r_struct
id|tm
op_star
id|tm
comma
r_int
op_star
id|offset
comma
r_int
op_star
id|tm_gmt
)paren
(brace
r_int
id|n
suffix:semicolon
r_char
op_star
id|end
suffix:semicolon
r_int
r_int
id|num
suffix:semicolon
id|num
op_assign
id|strtoul
c_func
(paren
id|date
comma
op_amp
id|end
comma
l_int|10
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Seconds since 1970? We trigger on that for any numbers with&n;&t; * more than 8 digits. This is because we don&squot;t want to rule out&n;&t; * numbers like 20070606 as a YYYYMMDD date.&n;&t; */
r_if
c_cond
(paren
id|num
op_ge
l_int|100000000
op_logical_and
id|nodate
c_func
(paren
id|tm
)paren
)paren
(brace
id|time_t
id|time
op_assign
id|num
suffix:semicolon
r_if
c_cond
(paren
id|gmtime_r
c_func
(paren
op_amp
id|time
comma
id|tm
)paren
)paren
(brace
op_star
id|tm_gmt
op_assign
l_int|1
suffix:semicolon
r_return
id|end
id|date
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Check for special formats: num[-.:/]num[same]num&n;&t; */
r_switch
c_cond
(paren
op_star
id|end
)paren
(brace
r_case
l_char|&squot;:&squot;
suffix:colon
r_case
l_char|&squot;.&squot;
suffix:colon
r_case
l_char|&squot;/&squot;
suffix:colon
r_case
l_char|&squot;-&squot;
suffix:colon
r_if
c_cond
(paren
id|isdigit
c_func
(paren
id|end
(braket
l_int|1
)braket
)paren
)paren
(brace
r_int
id|match
op_assign
id|match_multi_number
c_func
(paren
id|num
comma
op_star
id|end
comma
id|date
comma
id|end
comma
id|tm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|match
)paren
r_return
id|match
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * None of the special formats? Try to guess what&n;&t; * the number meant. We use the number of digits&n;&t; * to make a more educated guess..&n;&t; */
id|n
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|n
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|isdigit
c_func
(paren
id|date
(braket
id|n
)braket
)paren
)paren
suffix:semicolon
multiline_comment|/* Four-digit year or a timezone? */
r_if
c_cond
(paren
id|n
op_eq
l_int|4
)paren
(brace
r_if
c_cond
(paren
id|num
op_le
l_int|1400
op_logical_and
op_star
id|offset
op_eq
l_int|1
)paren
(brace
r_int
r_int
id|minutes
op_assign
id|num
op_mod
l_int|100
suffix:semicolon
r_int
r_int
id|hours
op_assign
id|num
op_div
l_int|100
suffix:semicolon
op_star
id|offset
op_assign
id|hours
op_star
l_int|60
op_plus
id|minutes
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|num
OG
l_int|1900
op_logical_and
id|num
OL
l_int|2100
)paren
id|tm-&gt;tm_year
op_assign
id|num
l_int|1900
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Ignore lots of numerals. We took care of 4-digit years above.&n;&t; * Days or months must be one or two digits.&n;&t; */
r_if
c_cond
(paren
id|n
OG
l_int|2
)paren
r_return
id|n
suffix:semicolon
multiline_comment|/*&n;&t; * NOTE! We will give precedence to day-of-month over month or&n;&t; * year numbers in the 1-12 range. So 05 is always &quot;mday 5&quot;,&n;&t; * unless we already have a mday..&n;&t; *&n;&t; * IOW, 01 Apr 05 parses as &quot;April 1st, 2005&quot;.&n;&t; */
r_if
c_cond
(paren
id|num
OG
l_int|0
op_logical_and
id|num
OL
l_int|32
op_logical_and
id|tm-&gt;tm_mday
OL
l_int|0
)paren
(brace
id|tm-&gt;tm_mday
op_assign
id|num
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
multiline_comment|/* Two-digit year? */
r_if
c_cond
(paren
id|n
op_eq
l_int|2
op_logical_and
id|tm-&gt;tm_year
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|num
OL
l_int|10
op_logical_and
id|tm-&gt;tm_mday
op_ge
l_int|0
)paren
(brace
id|tm-&gt;tm_year
op_assign
id|num
op_plus
l_int|100
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
r_if
c_cond
(paren
id|num
op_ge
l_int|70
)paren
(brace
id|tm-&gt;tm_year
op_assign
id|num
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|num
OG
l_int|0
op_logical_and
id|num
OL
l_int|13
op_logical_and
id|tm-&gt;tm_mon
OL
l_int|0
)paren
id|tm-&gt;tm_mon
op_assign
id|num
op_minus
l_int|1
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
DECL|function|match_tz
r_static
r_int
id|match_tz
c_func
(paren
r_const
r_char
op_star
id|date
comma
r_int
op_star
id|offp
)paren
(brace
r_char
op_star
id|end
suffix:semicolon
r_int
id|hour
op_assign
id|strtoul
c_func
(paren
id|date
op_plus
l_int|1
comma
op_amp
id|end
comma
l_int|10
)paren
suffix:semicolon
r_int
id|n
op_assign
id|end
(paren
id|date
op_plus
l_int|1
)paren
suffix:semicolon
r_int
id|min
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|n
op_eq
l_int|4
)paren
(brace
multiline_comment|/* hhmm */
id|min
op_assign
id|hour
op_mod
l_int|100
suffix:semicolon
id|hour
op_assign
id|hour
op_div
l_int|100
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|n
op_ne
l_int|2
)paren
(brace
id|min
op_assign
l_int|99
suffix:semicolon
multiline_comment|/* random crap */
)brace
r_else
r_if
c_cond
(paren
op_star
id|end
op_eq
l_char|&squot;:&squot;
)paren
(brace
multiline_comment|/* hh:mm? */
id|min
op_assign
id|strtoul
c_func
(paren
id|end
op_plus
l_int|1
comma
op_amp
id|end
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|end
(paren
id|date
op_plus
l_int|1
)paren
op_ne
l_int|5
)paren
id|min
op_assign
l_int|99
suffix:semicolon
multiline_comment|/* random crap */
)brace
multiline_comment|/* otherwise we parsed &quot;hh&quot; */
multiline_comment|/*&n;&t; * Don&squot;t accept any random crap. Even though some places have&n;&t; * offset larger than 12 hours (e.g. Pacific/Kiritimati is at&n;&t; * UTC+14), there is something wrong if hour part is much&n;&t; * larger than that. We might also want to check that the&n;&t; * minutes are divisible by 15 or something too. (Offset of&n;&t; * Kathmandu, Nepal is UTC+5:45)&n;&t; */
r_if
c_cond
(paren
id|min
OL
l_int|60
op_logical_and
id|hour
OL
l_int|24
)paren
(brace
r_int
id|offset
op_assign
id|hour
op_star
l_int|60
op_plus
id|min
suffix:semicolon
r_if
c_cond
(paren
op_star
id|date
op_eq
l_char|&squot;-&squot;
)paren
id|offset
op_assign
id|offset
suffix:semicolon
op_star
id|offp
op_assign
id|offset
suffix:semicolon
)brace
r_return
id|end
id|date
suffix:semicolon
)brace
DECL|function|date_string
r_static
r_int
id|date_string
c_func
(paren
r_int
r_int
id|date
comma
r_int
id|offset
comma
r_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_int
id|sign
op_assign
l_char|&squot;+&squot;
suffix:semicolon
r_if
c_cond
(paren
id|offset
OL
l_int|0
)paren
(brace
id|offset
op_assign
id|offset
suffix:semicolon
id|sign
op_assign
l_char|&squot;-&squot;
suffix:semicolon
)brace
r_return
id|snprintf
c_func
(paren
id|buf
comma
id|len
comma
l_string|&quot;%lu %c%02d%02d&quot;
comma
id|date
comma
id|sign
comma
id|offset
op_div
l_int|60
comma
id|offset
op_mod
l_int|60
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Parse a string like &quot;0 +0000&quot; as ancient timestamp near epoch, but&n; * only when it appears not as part of any other string.&n; */
DECL|function|match_object_header_date
r_static
r_int
id|match_object_header_date
c_func
(paren
r_const
r_char
op_star
id|date
comma
r_int
r_int
op_star
id|timestamp
comma
r_int
op_star
id|offset
)paren
(brace
r_char
op_star
id|end
suffix:semicolon
r_int
r_int
id|stamp
suffix:semicolon
r_int
id|ofs
suffix:semicolon
r_if
c_cond
(paren
op_star
id|date
OL
l_char|&squot;0&squot;
op_logical_or
l_char|&squot;9&squot;
OL
op_star
id|date
)paren
r_return
l_int|1
suffix:semicolon
id|stamp
op_assign
id|strtoul
c_func
(paren
id|date
comma
op_amp
id|end
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|end
op_ne
l_char|&squot; &squot;
op_logical_or
id|stamp
op_eq
id|ULONG_MAX
op_logical_or
(paren
id|end
(braket
l_int|1
)braket
op_ne
l_char|&squot;+&squot;
op_logical_and
id|end
(braket
l_int|1
)braket
op_ne
l_char|&squot;-&squot;
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|date
op_assign
id|end
op_plus
l_int|2
suffix:semicolon
id|ofs
op_assign
id|strtol
c_func
(paren
id|date
comma
op_amp
id|end
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|end
op_ne
l_char|&squot;&bslash;0&squot;
op_logical_and
(paren
op_star
id|end
op_ne
l_char|&squot;&bslash;n&squot;
)paren
)paren
op_logical_or
id|end
op_ne
id|date
op_plus
l_int|4
)paren
r_return
l_int|1
suffix:semicolon
id|ofs
op_assign
(paren
id|ofs
op_div
l_int|100
)paren
op_star
l_int|60
op_plus
(paren
id|ofs
op_mod
l_int|100
)paren
suffix:semicolon
r_if
c_cond
(paren
id|date
(braket
l_int|1
)braket
op_eq
l_char|&squot;-&squot;
)paren
id|ofs
op_assign
id|ofs
suffix:semicolon
op_star
id|timestamp
op_assign
id|stamp
suffix:semicolon
op_star
id|offset
op_assign
id|ofs
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Gr. strptime is crap for this; it doesn&squot;t have a way to require RFC2822&n;   (i.e. English) day/month names, and it doesn&squot;t work correctly with %z. */
DECL|function|parse_date_basic
r_int
id|parse_date_basic
c_func
(paren
r_const
r_char
op_star
id|date
comma
r_int
r_int
op_star
id|timestamp
comma
r_int
op_star
id|offset
)paren
(brace
r_struct
id|tm
id|tm
suffix:semicolon
r_int
id|tm_gmt
suffix:semicolon
r_int
r_int
id|dummy_timestamp
suffix:semicolon
r_int
id|dummy_offset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|timestamp
)paren
id|timestamp
op_assign
op_amp
id|dummy_timestamp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|offset
)paren
id|offset
op_assign
op_amp
id|dummy_offset
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|tm
comma
l_int|0
comma
r_sizeof
(paren
id|tm
)paren
)paren
suffix:semicolon
id|tm.tm_year
op_assign
l_int|1
suffix:semicolon
id|tm.tm_mon
op_assign
l_int|1
suffix:semicolon
id|tm.tm_mday
op_assign
l_int|1
suffix:semicolon
id|tm.tm_isdst
op_assign
l_int|1
suffix:semicolon
id|tm.tm_hour
op_assign
l_int|1
suffix:semicolon
id|tm.tm_min
op_assign
l_int|1
suffix:semicolon
id|tm.tm_sec
op_assign
l_int|1
suffix:semicolon
op_star
id|offset
op_assign
l_int|1
suffix:semicolon
id|tm_gmt
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_star
id|date
op_eq
l_char|&squot;@&squot;
op_logical_and
op_logical_neg
id|match_object_header_date
c_func
(paren
id|date
op_plus
l_int|1
comma
id|timestamp
comma
id|offset
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* success */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|match
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|c
op_assign
op_star
id|date
suffix:semicolon
multiline_comment|/* Stop at end of string or newline */
r_if
c_cond
(paren
op_logical_neg
id|c
op_logical_or
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|isalpha
c_func
(paren
id|c
)paren
)paren
id|match
op_assign
id|match_alpha
c_func
(paren
id|date
comma
op_amp
id|tm
comma
id|offset
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|isdigit
c_func
(paren
id|c
)paren
)paren
id|match
op_assign
id|match_digit
c_func
(paren
id|date
comma
op_amp
id|tm
comma
id|offset
comma
op_amp
id|tm_gmt
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|c
op_eq
l_char|&squot;-&squot;
op_logical_or
id|c
op_eq
l_char|&squot;+&squot;
)paren
op_logical_and
id|isdigit
c_func
(paren
id|date
(braket
l_int|1
)braket
)paren
)paren
id|match
op_assign
id|match_tz
c_func
(paren
id|date
comma
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|match
)paren
(brace
multiline_comment|/* BAD CRAP */
id|match
op_assign
l_int|1
suffix:semicolon
)brace
id|date
op_add_assign
id|match
suffix:semicolon
)brace
multiline_comment|/* mktime uses local timezone */
op_star
id|timestamp
op_assign
id|tm_to_time_t
c_func
(paren
op_amp
id|tm
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|timestamp
op_eq
l_int|1
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_star
id|offset
op_eq
l_int|1
)paren
(brace
id|time_t
id|temp_time
op_assign
id|mktime
c_func
(paren
op_amp
id|tm
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|time_t
)paren
op_star
id|timestamp
OG
id|temp_time
)paren
(brace
op_star
id|offset
op_assign
(paren
(paren
id|time_t
)paren
op_star
id|timestamp
id|temp_time
)paren
op_div
l_int|60
suffix:semicolon
)brace
r_else
(brace
op_star
id|offset
op_assign
(paren
r_int
)paren
(paren
(paren
id|temp_time
(paren
id|time_t
)paren
op_star
id|timestamp
)paren
op_div
l_int|60
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|tm_gmt
)paren
op_star
id|timestamp
op_sub_assign
op_star
id|offset
op_star
l_int|60
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* success */
)brace
DECL|function|parse_expiry_date
r_int
id|parse_expiry_date
c_func
(paren
r_const
r_char
op_star
id|date
comma
r_int
r_int
op_star
id|timestamp
)paren
(brace
r_int
id|errors
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|date
comma
l_string|&quot;never&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|date
comma
l_string|&quot;false&quot;
)paren
)paren
op_star
id|timestamp
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|date
comma
l_string|&quot;all&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|date
comma
l_string|&quot;now&quot;
)paren
)paren
multiline_comment|/*&n;&t;&t; * We take over &quot;now&quot; here, which usually translates&n;&t;&t; * to the current timestamp.  This is because the user&n;&t;&t; * really means to expire everything she has done in&n;&t;&t; * the past, and by definition reflogs are the record&n;&t;&t; * of the past, and there is nothing from the future&n;&t;&t; * to be kept.&n;&t;&t; */
op_star
id|timestamp
op_assign
id|ULONG_MAX
suffix:semicolon
r_else
op_star
id|timestamp
op_assign
id|approxidate_careful
c_func
(paren
id|date
comma
op_amp
id|errors
)paren
suffix:semicolon
r_return
id|errors
suffix:semicolon
)brace
DECL|function|parse_date
r_int
id|parse_date
c_func
(paren
r_const
r_char
op_star
id|date
comma
r_char
op_star
id|result
comma
r_int
id|maxlen
)paren
(brace
r_int
r_int
id|timestamp
suffix:semicolon
r_int
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|parse_date_basic
c_func
(paren
id|date
comma
op_amp
id|timestamp
comma
op_amp
id|offset
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
id|date_string
c_func
(paren
id|timestamp
comma
id|offset
comma
id|result
comma
id|maxlen
)paren
suffix:semicolon
)brace
DECL|function|parse_date_format
r_enum
id|date_mode
id|parse_date_format
c_func
(paren
r_const
r_char
op_star
id|format
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|format
comma
l_string|&quot;relative&quot;
)paren
)paren
r_return
id|DATE_RELATIVE
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|format
comma
l_string|&quot;iso8601&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|format
comma
l_string|&quot;iso&quot;
)paren
)paren
r_return
id|DATE_ISO8601
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|format
comma
l_string|&quot;rfc2822&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|format
comma
l_string|&quot;rfc&quot;
)paren
)paren
r_return
id|DATE_RFC2822
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|format
comma
l_string|&quot;short&quot;
)paren
)paren
r_return
id|DATE_SHORT
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|format
comma
l_string|&quot;local&quot;
)paren
)paren
r_return
id|DATE_LOCAL
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|format
comma
l_string|&quot;default&quot;
)paren
)paren
r_return
id|DATE_NORMAL
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|format
comma
l_string|&quot;raw&quot;
)paren
)paren
r_return
id|DATE_RAW
suffix:semicolon
r_else
id|die
c_func
(paren
l_string|&quot;unknown date format %s&quot;
comma
id|format
)paren
suffix:semicolon
)brace
DECL|function|datestamp
r_void
id|datestamp
c_func
(paren
r_char
op_star
id|buf
comma
r_int
id|bufsize
)paren
(brace
id|time_t
id|now
suffix:semicolon
r_int
id|offset
suffix:semicolon
id|time
c_func
(paren
op_amp
id|now
)paren
suffix:semicolon
id|offset
op_assign
id|tm_to_time_t
c_func
(paren
id|localtime
c_func
(paren
op_amp
id|now
)paren
)paren
id|now
suffix:semicolon
id|offset
op_div_assign
l_int|60
suffix:semicolon
id|date_string
c_func
(paren
id|now
comma
id|offset
comma
id|buf
comma
id|bufsize
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Relative time update (eg &quot;2 days ago&quot;).  If we haven&squot;t set the time&n; * yet, we need to set it from current time.&n; */
DECL|function|update_tm
r_static
r_int
r_int
id|update_tm
c_func
(paren
r_struct
id|tm
op_star
id|tm
comma
r_struct
id|tm
op_star
id|now
comma
r_int
r_int
id|sec
)paren
(brace
id|time_t
id|n
suffix:semicolon
r_if
c_cond
(paren
id|tm-&gt;tm_mday
OL
l_int|0
)paren
id|tm-&gt;tm_mday
op_assign
id|now-&gt;tm_mday
suffix:semicolon
r_if
c_cond
(paren
id|tm-&gt;tm_mon
OL
l_int|0
)paren
id|tm-&gt;tm_mon
op_assign
id|now-&gt;tm_mon
suffix:semicolon
r_if
c_cond
(paren
id|tm-&gt;tm_year
OL
l_int|0
)paren
(brace
id|tm-&gt;tm_year
op_assign
id|now-&gt;tm_year
suffix:semicolon
r_if
c_cond
(paren
id|tm-&gt;tm_mon
OG
id|now-&gt;tm_mon
)paren
id|tm-&gt;tm_year
op_decrement
suffix:semicolon
)brace
id|n
op_assign
id|mktime
c_func
(paren
id|tm
)paren
id|sec
suffix:semicolon
id|localtime_r
c_func
(paren
op_amp
id|n
comma
id|tm
)paren
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
DECL|function|date_now
r_static
r_void
id|date_now
c_func
(paren
r_struct
id|tm
op_star
id|tm
comma
r_struct
id|tm
op_star
id|now
comma
r_int
op_star
id|num
)paren
(brace
id|update_tm
c_func
(paren
id|tm
comma
id|now
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|date_yesterday
r_static
r_void
id|date_yesterday
c_func
(paren
r_struct
id|tm
op_star
id|tm
comma
r_struct
id|tm
op_star
id|now
comma
r_int
op_star
id|num
)paren
(brace
id|update_tm
c_func
(paren
id|tm
comma
id|now
comma
l_int|24
op_star
l_int|60
op_star
l_int|60
)paren
suffix:semicolon
)brace
DECL|function|date_time
r_static
r_void
id|date_time
c_func
(paren
r_struct
id|tm
op_star
id|tm
comma
r_struct
id|tm
op_star
id|now
comma
r_int
id|hour
)paren
(brace
r_if
c_cond
(paren
id|tm-&gt;tm_hour
OL
id|hour
)paren
id|date_yesterday
c_func
(paren
id|tm
comma
id|now
comma
l_int|NULL
)paren
suffix:semicolon
id|tm-&gt;tm_hour
op_assign
id|hour
suffix:semicolon
id|tm-&gt;tm_min
op_assign
l_int|0
suffix:semicolon
id|tm-&gt;tm_sec
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|date_midnight
r_static
r_void
id|date_midnight
c_func
(paren
r_struct
id|tm
op_star
id|tm
comma
r_struct
id|tm
op_star
id|now
comma
r_int
op_star
id|num
)paren
(brace
id|date_time
c_func
(paren
id|tm
comma
id|now
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|date_noon
r_static
r_void
id|date_noon
c_func
(paren
r_struct
id|tm
op_star
id|tm
comma
r_struct
id|tm
op_star
id|now
comma
r_int
op_star
id|num
)paren
(brace
id|date_time
c_func
(paren
id|tm
comma
id|now
comma
l_int|12
)paren
suffix:semicolon
)brace
DECL|function|date_tea
r_static
r_void
id|date_tea
c_func
(paren
r_struct
id|tm
op_star
id|tm
comma
r_struct
id|tm
op_star
id|now
comma
r_int
op_star
id|num
)paren
(brace
id|date_time
c_func
(paren
id|tm
comma
id|now
comma
l_int|17
)paren
suffix:semicolon
)brace
DECL|function|date_pm
r_static
r_void
id|date_pm
c_func
(paren
r_struct
id|tm
op_star
id|tm
comma
r_struct
id|tm
op_star
id|now
comma
r_int
op_star
id|num
)paren
(brace
r_int
id|hour
comma
id|n
op_assign
op_star
id|num
suffix:semicolon
op_star
id|num
op_assign
l_int|0
suffix:semicolon
id|hour
op_assign
id|tm-&gt;tm_hour
suffix:semicolon
r_if
c_cond
(paren
id|n
)paren
(brace
id|hour
op_assign
id|n
suffix:semicolon
id|tm-&gt;tm_min
op_assign
l_int|0
suffix:semicolon
id|tm-&gt;tm_sec
op_assign
l_int|0
suffix:semicolon
)brace
id|tm-&gt;tm_hour
op_assign
(paren
id|hour
op_mod
l_int|12
)paren
op_plus
l_int|12
suffix:semicolon
)brace
DECL|function|date_am
r_static
r_void
id|date_am
c_func
(paren
r_struct
id|tm
op_star
id|tm
comma
r_struct
id|tm
op_star
id|now
comma
r_int
op_star
id|num
)paren
(brace
r_int
id|hour
comma
id|n
op_assign
op_star
id|num
suffix:semicolon
op_star
id|num
op_assign
l_int|0
suffix:semicolon
id|hour
op_assign
id|tm-&gt;tm_hour
suffix:semicolon
r_if
c_cond
(paren
id|n
)paren
(brace
id|hour
op_assign
id|n
suffix:semicolon
id|tm-&gt;tm_min
op_assign
l_int|0
suffix:semicolon
id|tm-&gt;tm_sec
op_assign
l_int|0
suffix:semicolon
)brace
id|tm-&gt;tm_hour
op_assign
(paren
id|hour
op_mod
l_int|12
)paren
suffix:semicolon
)brace
DECL|function|date_never
r_static
r_void
id|date_never
c_func
(paren
r_struct
id|tm
op_star
id|tm
comma
r_struct
id|tm
op_star
id|now
comma
r_int
op_star
id|num
)paren
(brace
id|time_t
id|n
op_assign
l_int|0
suffix:semicolon
id|localtime_r
c_func
(paren
op_amp
id|n
comma
id|tm
)paren
suffix:semicolon
)brace
DECL|struct|special
r_static
r_const
r_struct
id|special
(brace
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
DECL|member|fn
r_void
(paren
op_star
id|fn
)paren
(paren
r_struct
id|tm
op_star
comma
r_struct
id|tm
op_star
comma
r_int
op_star
)paren
suffix:semicolon
DECL|variable|special
)brace
id|special
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;yesterday&quot;
comma
id|date_yesterday
)brace
comma
(brace
l_string|&quot;noon&quot;
comma
id|date_noon
)brace
comma
(brace
l_string|&quot;midnight&quot;
comma
id|date_midnight
)brace
comma
(brace
l_string|&quot;tea&quot;
comma
id|date_tea
)brace
comma
(brace
l_string|&quot;PM&quot;
comma
id|date_pm
)brace
comma
(brace
l_string|&quot;AM&quot;
comma
id|date_am
)brace
comma
(brace
l_string|&quot;never&quot;
comma
id|date_never
)brace
comma
(brace
l_string|&quot;now&quot;
comma
id|date_now
)brace
comma
(brace
l_int|NULL
)brace
)brace
suffix:semicolon
DECL|variable|number_name
r_static
r_const
r_char
op_star
id|number_name
(braket
)braket
op_assign
(brace
l_string|&quot;zero&quot;
comma
l_string|&quot;one&quot;
comma
l_string|&quot;two&quot;
comma
l_string|&quot;three&quot;
comma
l_string|&quot;four&quot;
comma
l_string|&quot;five&quot;
comma
l_string|&quot;six&quot;
comma
l_string|&quot;seven&quot;
comma
l_string|&quot;eight&quot;
comma
l_string|&quot;nine&quot;
comma
l_string|&quot;ten&quot;
comma
)brace
suffix:semicolon
DECL|struct|typelen
r_static
r_const
r_struct
id|typelen
(brace
DECL|member|type
r_const
r_char
op_star
id|type
suffix:semicolon
DECL|member|length
r_int
id|length
suffix:semicolon
DECL|variable|typelen
)brace
id|typelen
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;seconds&quot;
comma
l_int|1
)brace
comma
(brace
l_string|&quot;minutes&quot;
comma
l_int|60
)brace
comma
(brace
l_string|&quot;hours&quot;
comma
l_int|60
op_star
l_int|60
)brace
comma
(brace
l_string|&quot;days&quot;
comma
l_int|24
op_star
l_int|60
op_star
l_int|60
)brace
comma
(brace
l_string|&quot;weeks&quot;
comma
l_int|7
op_star
l_int|24
op_star
l_int|60
op_star
l_int|60
)brace
comma
(brace
l_int|NULL
)brace
)brace
suffix:semicolon
DECL|function|approxidate_alpha
r_static
r_const
r_char
op_star
id|approxidate_alpha
c_func
(paren
r_const
r_char
op_star
id|date
comma
r_struct
id|tm
op_star
id|tm
comma
r_struct
id|tm
op_star
id|now
comma
r_int
op_star
id|num
comma
r_int
op_star
id|touched
)paren
(brace
r_const
r_struct
id|typelen
op_star
id|tl
suffix:semicolon
r_const
r_struct
id|special
op_star
id|s
suffix:semicolon
r_const
r_char
op_star
id|end
op_assign
id|date
suffix:semicolon
r_int
id|i
suffix:semicolon
r_while
c_loop
(paren
id|isalpha
c_func
(paren
op_star
op_increment
id|end
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|12
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|match
op_assign
id|match_string
c_func
(paren
id|date
comma
id|month_names
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|match
op_ge
l_int|3
)paren
(brace
id|tm-&gt;tm_mon
op_assign
id|i
suffix:semicolon
op_star
id|touched
op_assign
l_int|1
suffix:semicolon
r_return
id|end
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|s
op_assign
id|special
suffix:semicolon
id|s-&gt;name
suffix:semicolon
id|s
op_increment
)paren
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|s-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|match_string
c_func
(paren
id|date
comma
id|s-&gt;name
)paren
op_eq
id|len
)paren
(brace
id|s
op_member_access_from_pointer
id|fn
c_func
(paren
id|tm
comma
id|now
comma
id|num
)paren
suffix:semicolon
op_star
id|touched
op_assign
l_int|1
suffix:semicolon
r_return
id|end
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|num
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|11
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|number_name
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|match_string
c_func
(paren
id|date
comma
id|number_name
(braket
id|i
)braket
)paren
op_eq
id|len
)paren
(brace
op_star
id|num
op_assign
id|i
suffix:semicolon
op_star
id|touched
op_assign
l_int|1
suffix:semicolon
r_return
id|end
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|match_string
c_func
(paren
id|date
comma
l_string|&quot;last&quot;
)paren
op_eq
l_int|4
)paren
(brace
op_star
id|num
op_assign
l_int|1
suffix:semicolon
op_star
id|touched
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|end
suffix:semicolon
)brace
id|tl
op_assign
id|typelen
suffix:semicolon
r_while
c_loop
(paren
id|tl-&gt;type
)paren
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|tl-&gt;type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|match_string
c_func
(paren
id|date
comma
id|tl-&gt;type
)paren
op_ge
id|len
op_minus
l_int|1
)paren
(brace
id|update_tm
c_func
(paren
id|tm
comma
id|now
comma
id|tl-&gt;length
op_star
op_star
id|num
)paren
suffix:semicolon
op_star
id|num
op_assign
l_int|0
suffix:semicolon
op_star
id|touched
op_assign
l_int|1
suffix:semicolon
r_return
id|end
suffix:semicolon
)brace
id|tl
op_increment
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|7
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|match
op_assign
id|match_string
c_func
(paren
id|date
comma
id|weekday_names
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|match
op_ge
l_int|3
)paren
(brace
r_int
id|diff
comma
id|n
op_assign
op_star
id|num
l_int|1
suffix:semicolon
op_star
id|num
op_assign
l_int|0
suffix:semicolon
id|diff
op_assign
id|tm-&gt;tm_wday
id|i
suffix:semicolon
r_if
c_cond
(paren
id|diff
op_le
l_int|0
)paren
id|n
op_increment
suffix:semicolon
id|diff
op_add_assign
l_int|7
op_star
id|n
suffix:semicolon
id|update_tm
c_func
(paren
id|tm
comma
id|now
comma
id|diff
op_star
l_int|24
op_star
l_int|60
op_star
l_int|60
)paren
suffix:semicolon
op_star
id|touched
op_assign
l_int|1
suffix:semicolon
r_return
id|end
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|match_string
c_func
(paren
id|date
comma
l_string|&quot;months&quot;
)paren
op_ge
l_int|5
)paren
(brace
r_int
id|n
suffix:semicolon
id|update_tm
c_func
(paren
id|tm
comma
id|now
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* fill in date fields if needed */
id|n
op_assign
id|tm-&gt;tm_mon
op_star
id|num
suffix:semicolon
op_star
id|num
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|n
OL
l_int|0
)paren
(brace
id|n
op_add_assign
l_int|12
suffix:semicolon
id|tm-&gt;tm_year
op_decrement
suffix:semicolon
)brace
id|tm-&gt;tm_mon
op_assign
id|n
suffix:semicolon
op_star
id|touched
op_assign
l_int|1
suffix:semicolon
r_return
id|end
suffix:semicolon
)brace
r_if
c_cond
(paren
id|match_string
c_func
(paren
id|date
comma
l_string|&quot;years&quot;
)paren
op_ge
l_int|4
)paren
(brace
id|update_tm
c_func
(paren
id|tm
comma
id|now
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* fill in date fields if needed */
id|tm-&gt;tm_year
op_sub_assign
op_star
id|num
suffix:semicolon
op_star
id|num
op_assign
l_int|0
suffix:semicolon
op_star
id|touched
op_assign
l_int|1
suffix:semicolon
r_return
id|end
suffix:semicolon
)brace
r_return
id|end
suffix:semicolon
)brace
DECL|function|approxidate_digit
r_static
r_const
r_char
op_star
id|approxidate_digit
c_func
(paren
r_const
r_char
op_star
id|date
comma
r_struct
id|tm
op_star
id|tm
comma
r_int
op_star
id|num
)paren
(brace
r_char
op_star
id|end
suffix:semicolon
r_int
r_int
id|number
op_assign
id|strtoul
c_func
(paren
id|date
comma
op_amp
id|end
comma
l_int|10
)paren
suffix:semicolon
r_switch
c_cond
(paren
op_star
id|end
)paren
(brace
r_case
l_char|&squot;:&squot;
suffix:colon
r_case
l_char|&squot;.&squot;
suffix:colon
r_case
l_char|&squot;/&squot;
suffix:colon
r_case
l_char|&squot;-&squot;
suffix:colon
r_if
c_cond
(paren
id|isdigit
c_func
(paren
id|end
(braket
l_int|1
)braket
)paren
)paren
(brace
r_int
id|match
op_assign
id|match_multi_number
c_func
(paren
id|number
comma
op_star
id|end
comma
id|date
comma
id|end
comma
id|tm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|match
)paren
r_return
id|date
op_plus
id|match
suffix:semicolon
)brace
)brace
multiline_comment|/* Accept zero-padding only for small numbers (&quot;Dec 02&quot;, never &quot;Dec 0002&quot;) */
r_if
c_cond
(paren
id|date
(braket
l_int|0
)braket
op_ne
l_char|&squot;0&squot;
op_logical_or
id|end
id|date
op_le
l_int|2
)paren
op_star
id|num
op_assign
id|number
suffix:semicolon
r_return
id|end
suffix:semicolon
)brace
multiline_comment|/*&n; * Do we have a pending number at the end, or when&n; * we see a new one? Let&squot;s assume it&squot;s a month day,&n; * as in &quot;Dec 6, 1992&quot;&n; */
DECL|function|pending_number
r_static
r_void
id|pending_number
c_func
(paren
r_struct
id|tm
op_star
id|tm
comma
r_int
op_star
id|num
)paren
(brace
r_int
id|number
op_assign
op_star
id|num
suffix:semicolon
r_if
c_cond
(paren
id|number
)paren
(brace
op_star
id|num
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tm-&gt;tm_mday
OL
l_int|0
op_logical_and
id|number
OL
l_int|32
)paren
id|tm-&gt;tm_mday
op_assign
id|number
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tm-&gt;tm_mon
OL
l_int|0
op_logical_and
id|number
OL
l_int|13
)paren
id|tm-&gt;tm_mon
op_assign
id|number
op_minus
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tm-&gt;tm_year
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|number
OG
l_int|1969
op_logical_and
id|number
OL
l_int|2100
)paren
id|tm-&gt;tm_year
op_assign
id|number
l_int|1900
suffix:semicolon
r_else
r_if
c_cond
(paren
id|number
OG
l_int|69
op_logical_and
id|number
OL
l_int|100
)paren
id|tm-&gt;tm_year
op_assign
id|number
suffix:semicolon
r_else
r_if
c_cond
(paren
id|number
OL
l_int|38
)paren
id|tm-&gt;tm_year
op_assign
l_int|100
op_plus
id|number
suffix:semicolon
multiline_comment|/* We screw up for number = 00 ? */
)brace
)brace
)brace
DECL|function|approxidate_str
r_static
r_int
r_int
id|approxidate_str
c_func
(paren
r_const
r_char
op_star
id|date
comma
r_const
r_struct
id|timeval
op_star
id|tv
comma
r_int
op_star
id|error_ret
)paren
(brace
r_int
id|number
op_assign
l_int|0
suffix:semicolon
r_int
id|touched
op_assign
l_int|0
suffix:semicolon
r_struct
id|tm
id|tm
comma
id|now
suffix:semicolon
id|time_t
id|time_sec
suffix:semicolon
id|time_sec
op_assign
id|tv-&gt;tv_sec
suffix:semicolon
id|localtime_r
c_func
(paren
op_amp
id|time_sec
comma
op_amp
id|tm
)paren
suffix:semicolon
id|now
op_assign
id|tm
suffix:semicolon
id|tm.tm_year
op_assign
l_int|1
suffix:semicolon
id|tm.tm_mon
op_assign
l_int|1
suffix:semicolon
id|tm.tm_mday
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
r_char
id|c
op_assign
op_star
id|date
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
r_break
suffix:semicolon
id|date
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|isdigit
c_func
(paren
id|c
)paren
)paren
(brace
id|pending_number
c_func
(paren
op_amp
id|tm
comma
op_amp
id|number
)paren
suffix:semicolon
id|date
op_assign
id|approxidate_digit
c_func
(paren
id|date
op_minus
l_int|1
comma
op_amp
id|tm
comma
op_amp
id|number
)paren
suffix:semicolon
id|touched
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|isalpha
c_func
(paren
id|c
)paren
)paren
id|date
op_assign
id|approxidate_alpha
c_func
(paren
id|date
op_minus
l_int|1
comma
op_amp
id|tm
comma
op_amp
id|now
comma
op_amp
id|number
comma
op_amp
id|touched
)paren
suffix:semicolon
)brace
id|pending_number
c_func
(paren
op_amp
id|tm
comma
op_amp
id|number
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|touched
)paren
op_star
id|error_ret
op_assign
l_int|1
suffix:semicolon
r_return
id|update_tm
c_func
(paren
op_amp
id|tm
comma
op_amp
id|now
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|approxidate_relative
r_int
r_int
id|approxidate_relative
c_func
(paren
r_const
r_char
op_star
id|date
comma
r_const
r_struct
id|timeval
op_star
id|tv
)paren
(brace
r_int
r_int
id|timestamp
suffix:semicolon
r_int
id|offset
suffix:semicolon
r_int
id|errors
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parse_date_basic
c_func
(paren
id|date
comma
op_amp
id|timestamp
comma
op_amp
id|offset
)paren
)paren
r_return
id|timestamp
suffix:semicolon
r_return
id|approxidate_str
c_func
(paren
id|date
comma
id|tv
comma
op_amp
id|errors
)paren
suffix:semicolon
)brace
DECL|function|approxidate_careful
r_int
r_int
id|approxidate_careful
c_func
(paren
r_const
r_char
op_star
id|date
comma
r_int
op_star
id|error_ret
)paren
(brace
r_struct
id|timeval
id|tv
suffix:semicolon
r_int
r_int
id|timestamp
suffix:semicolon
r_int
id|offset
suffix:semicolon
r_int
id|dummy
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error_ret
)paren
id|error_ret
op_assign
op_amp
id|dummy
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parse_date_basic
c_func
(paren
id|date
comma
op_amp
id|timestamp
comma
op_amp
id|offset
)paren
)paren
(brace
op_star
id|error_ret
op_assign
l_int|0
suffix:semicolon
r_return
id|timestamp
suffix:semicolon
)brace
id|gettimeofday
c_func
(paren
op_amp
id|tv
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|approxidate_str
c_func
(paren
id|date
comma
op_amp
id|tv
comma
id|error_ret
)paren
suffix:semicolon
)brace
DECL|function|date_overflows
r_int
id|date_overflows
c_func
(paren
r_int
r_int
id|t
)paren
(brace
id|time_t
id|sys
suffix:semicolon
multiline_comment|/* If we overflowed our unsigned long, that&squot;s bad... */
r_if
c_cond
(paren
id|t
op_eq
id|ULONG_MAX
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * ...but we also are going to feed the result to system&n;&t; * functions that expect time_t, which is often &quot;signed long&quot;.&n;&t; * Make sure that we fit into time_t, as well.&n;&t; */
id|sys
op_assign
id|t
suffix:semicolon
r_return
id|t
op_ne
id|sys
op_logical_or
(paren
id|t
OL
l_int|1
)paren
op_ne
(paren
id|sys
OL
l_int|1
)paren
suffix:semicolon
)brace
eof
