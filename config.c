multiline_comment|/*&n; * GIT - The information manager from hell&n; *&n; * Copyright (C) Linus Torvalds, 2005&n; * Copyright (C) Johannes Schindelin, 2005&n; *&n; */
macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;exec_cmd.h&quot;
macro_line|#include &quot;strbuf.h&quot;
macro_line|#include &quot;quote.h&quot;
DECL|struct|config_file
r_typedef
r_struct
id|config_file
(brace
DECL|member|prev
r_struct
id|config_file
op_star
id|prev
suffix:semicolon
DECL|member|f
id|FILE
op_star
id|f
suffix:semicolon
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
DECL|member|linenr
r_int
id|linenr
suffix:semicolon
DECL|member|eof
r_int
id|eof
suffix:semicolon
DECL|member|value
r_struct
id|strbuf
id|value
suffix:semicolon
DECL|member|var
r_struct
id|strbuf
id|var
suffix:semicolon
DECL|typedef|config_file
)brace
id|config_file
suffix:semicolon
DECL|variable|cf
r_static
id|config_file
op_star
id|cf
suffix:semicolon
DECL|variable|zlib_compression_seen
r_static
r_int
id|zlib_compression_seen
suffix:semicolon
DECL|macro|MAX_INCLUDE_DEPTH
mdefine_line|#define MAX_INCLUDE_DEPTH 10
DECL|variable|include_depth_advice
r_static
r_const
r_char
id|include_depth_advice
(braket
)braket
op_assign
l_string|&quot;exceeded maximum include depth (%d) while including&bslash;n&quot;
l_string|&quot;&t;%s&bslash;n&quot;
l_string|&quot;from&bslash;n&quot;
l_string|&quot;&t;%s&bslash;n&quot;
l_string|&quot;Do you have circular includes?&quot;
suffix:semicolon
DECL|function|handle_path_include
r_static
r_int
id|handle_path_include
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_struct
id|config_include_data
op_star
id|inc
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_struct
id|strbuf
id|buf
op_assign
id|STRBUF_INIT
suffix:semicolon
r_char
op_star
id|expanded
op_assign
id|expand_user_path
c_func
(paren
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|expanded
)paren
r_return
id|error
c_func
(paren
l_string|&quot;Could not expand include path &squot;%s&squot;&quot;
comma
id|path
)paren
suffix:semicolon
id|path
op_assign
id|expanded
suffix:semicolon
multiline_comment|/*&n;&t; * Use an absolute path as-is, but interpret relative paths&n;&t; * based on the including config file.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|is_absolute_path
c_func
(paren
id|path
)paren
)paren
(brace
r_char
op_star
id|slash
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cf
op_logical_or
op_logical_neg
id|cf-&gt;name
)paren
r_return
id|error
c_func
(paren
l_string|&quot;relative config includes must come from files&quot;
)paren
suffix:semicolon
id|slash
op_assign
id|find_last_dir_sep
c_func
(paren
id|cf-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slash
)paren
id|strbuf_add
c_func
(paren
op_amp
id|buf
comma
id|cf-&gt;name
comma
id|slash
id|cf-&gt;name
op_plus
l_int|1
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|buf
comma
id|path
)paren
suffix:semicolon
id|path
op_assign
id|buf.buf
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|access_or_die
c_func
(paren
id|path
comma
id|R_OK
comma
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
op_increment
id|inc-&gt;depth
OG
id|MAX_INCLUDE_DEPTH
)paren
id|die
c_func
(paren
id|include_depth_advice
comma
id|MAX_INCLUDE_DEPTH
comma
id|path
comma
id|cf
op_logical_and
id|cf-&gt;name
ques
c_cond
id|cf-&gt;name
suffix:colon
l_string|&quot;the command line&quot;
)paren
suffix:semicolon
id|ret
op_assign
id|git_config_from_file
c_func
(paren
id|git_config_include
comma
id|path
comma
id|inc
)paren
suffix:semicolon
id|inc-&gt;depth
op_decrement
suffix:semicolon
)brace
id|strbuf_release
c_func
(paren
op_amp
id|buf
)paren
suffix:semicolon
id|free
c_func
(paren
id|expanded
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|git_config_include
r_int
id|git_config_include
c_func
(paren
r_const
r_char
op_star
id|var
comma
r_const
r_char
op_star
id|value
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|config_include_data
op_star
id|inc
op_assign
id|data
suffix:semicolon
r_const
r_char
op_star
id|type
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/*&n;&t; * Pass along all values, including &quot;include&quot; directives; this makes it&n;&t; * possible to query information on the includes themselves.&n;&t; */
id|ret
op_assign
id|inc
op_member_access_from_pointer
id|fn
c_func
(paren
id|var
comma
id|value
comma
id|inc-&gt;data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_return
id|ret
suffix:semicolon
id|type
op_assign
id|skip_prefix
c_func
(paren
id|var
comma
l_string|&quot;include.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|type
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|type
comma
l_string|&quot;path&quot;
)paren
)paren
id|ret
op_assign
id|handle_path_include
c_func
(paren
id|value
comma
id|inc
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|lowercase
r_static
r_void
id|lowercase
c_func
(paren
r_char
op_star
id|p
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
op_star
id|p
suffix:semicolon
id|p
op_increment
)paren
op_star
id|p
op_assign
id|tolower
c_func
(paren
op_star
id|p
)paren
suffix:semicolon
)brace
DECL|function|git_config_push_parameter
r_void
id|git_config_push_parameter
c_func
(paren
r_const
r_char
op_star
id|text
)paren
(brace
r_struct
id|strbuf
id|env
op_assign
id|STRBUF_INIT
suffix:semicolon
r_const
r_char
op_star
id|old
op_assign
id|getenv
c_func
(paren
id|CONFIG_DATA_ENVIRONMENT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old
)paren
(brace
id|strbuf_addstr
c_func
(paren
op_amp
id|env
comma
id|old
)paren
suffix:semicolon
id|strbuf_addch
c_func
(paren
op_amp
id|env
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
)brace
id|sq_quote_buf
c_func
(paren
op_amp
id|env
comma
id|text
)paren
suffix:semicolon
id|setenv
c_func
(paren
id|CONFIG_DATA_ENVIRONMENT
comma
id|env.buf
comma
l_int|1
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|env
)paren
suffix:semicolon
)brace
DECL|function|git_config_parse_parameter
r_int
id|git_config_parse_parameter
c_func
(paren
r_const
r_char
op_star
id|text
comma
id|config_fn_t
id|fn
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|strbuf
op_star
op_star
id|pair
suffix:semicolon
id|pair
op_assign
id|strbuf_split_str
c_func
(paren
id|text
comma
l_char|&squot;=&squot;
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pair
(braket
l_int|0
)braket
)paren
r_return
id|error
c_func
(paren
l_string|&quot;bogus config parameter: %s&quot;
comma
id|text
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pair
(braket
l_int|0
)braket
op_member_access_from_pointer
id|len
op_logical_and
id|pair
(braket
l_int|0
)braket
op_member_access_from_pointer
id|buf
(braket
id|pair
(braket
l_int|0
)braket
op_member_access_from_pointer
id|len
l_int|1
)braket
op_eq
l_char|&squot;=&squot;
)paren
id|strbuf_setlen
c_func
(paren
id|pair
(braket
l_int|0
)braket
comma
id|pair
(braket
l_int|0
)braket
op_member_access_from_pointer
id|len
l_int|1
)paren
suffix:semicolon
id|strbuf_trim
c_func
(paren
id|pair
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pair
(braket
l_int|0
)braket
op_member_access_from_pointer
id|len
)paren
(brace
id|strbuf_list_free
c_func
(paren
id|pair
)paren
suffix:semicolon
r_return
id|error
c_func
(paren
l_string|&quot;bogus config parameter: %s&quot;
comma
id|text
)paren
suffix:semicolon
)brace
id|lowercase
c_func
(paren
id|pair
(braket
l_int|0
)braket
op_member_access_from_pointer
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fn
c_func
(paren
id|pair
(braket
l_int|0
)braket
op_member_access_from_pointer
id|buf
comma
id|pair
(braket
l_int|1
)braket
ques
c_cond
id|pair
(braket
l_int|1
)braket
op_member_access_from_pointer
id|buf
suffix:colon
l_int|NULL
comma
id|data
)paren
OL
l_int|0
)paren
(brace
id|strbuf_list_free
c_func
(paren
id|pair
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|strbuf_list_free
c_func
(paren
id|pair
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|git_config_from_parameters
r_int
id|git_config_from_parameters
c_func
(paren
id|config_fn_t
id|fn
comma
r_void
op_star
id|data
)paren
(brace
r_const
r_char
op_star
id|env
op_assign
id|getenv
c_func
(paren
id|CONFIG_DATA_ENVIRONMENT
)paren
suffix:semicolon
r_char
op_star
id|envw
suffix:semicolon
r_const
r_char
op_star
op_star
id|argv
op_assign
l_int|NULL
suffix:semicolon
r_int
id|nr
op_assign
l_int|0
comma
id|alloc
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|env
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* sq_dequote will write over it */
id|envw
op_assign
id|xstrdup
c_func
(paren
id|env
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sq_dequote_to_argv
c_func
(paren
id|envw
comma
op_amp
id|argv
comma
op_amp
id|nr
comma
op_amp
id|alloc
)paren
OL
l_int|0
)paren
(brace
id|free
c_func
(paren
id|envw
)paren
suffix:semicolon
r_return
id|error
c_func
(paren
l_string|&quot;bogus format in &quot;
id|CONFIG_DATA_ENVIRONMENT
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|git_config_parse_parameter
c_func
(paren
id|argv
(braket
id|i
)braket
comma
id|fn
comma
id|data
)paren
OL
l_int|0
)paren
(brace
id|free
c_func
(paren
id|argv
)paren
suffix:semicolon
id|free
c_func
(paren
id|envw
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
id|free
c_func
(paren
id|argv
)paren
suffix:semicolon
id|free
c_func
(paren
id|envw
)paren
suffix:semicolon
r_return
id|nr
OG
l_int|0
suffix:semicolon
)brace
DECL|function|get_next_char
r_static
r_int
id|get_next_char
c_func
(paren
r_void
)paren
(brace
r_int
id|c
suffix:semicolon
id|FILE
op_star
id|f
suffix:semicolon
id|c
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
r_if
c_cond
(paren
id|cf
op_logical_and
(paren
(paren
id|f
op_assign
id|cf-&gt;f
)paren
op_ne
l_int|NULL
)paren
)paren
(brace
id|c
op_assign
id|fgetc
c_func
(paren
id|f
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;r&squot;
)paren
(brace
multiline_comment|/* DOS like systems */
id|c
op_assign
id|fgetc
c_func
(paren
id|f
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|ungetc
c_func
(paren
id|c
comma
id|f
)paren
suffix:semicolon
id|c
op_assign
l_char|&squot;&bslash;r&squot;
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|cf-&gt;linenr
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
id|EOF
)paren
(brace
id|cf-&gt;eof
op_assign
l_int|1
suffix:semicolon
id|c
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
)brace
)brace
r_return
id|c
suffix:semicolon
)brace
DECL|function|parse_value
r_static
r_char
op_star
id|parse_value
c_func
(paren
r_void
)paren
(brace
r_int
id|quote
op_assign
l_int|0
comma
id|comment
op_assign
l_int|0
comma
id|space
op_assign
l_int|0
suffix:semicolon
id|strbuf_reset
c_func
(paren
op_amp
id|cf-&gt;value
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|c
op_assign
id|get_next_char
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
r_if
c_cond
(paren
id|quote
)paren
(brace
id|cf-&gt;linenr
op_decrement
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|cf-&gt;value.buf
suffix:semicolon
)brace
r_if
c_cond
(paren
id|comment
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|isspace
c_func
(paren
id|c
)paren
op_logical_and
op_logical_neg
id|quote
)paren
(brace
r_if
c_cond
(paren
id|cf-&gt;value.len
)paren
id|space
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|quote
)paren
(brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;;&squot;
op_logical_or
id|c
op_eq
l_char|&squot;#&squot;
)paren
(brace
id|comment
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
suffix:semicolon
id|space
suffix:semicolon
id|space
op_decrement
)paren
id|strbuf_addch
c_func
(paren
op_amp
id|cf-&gt;value
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;&bslash;&squot;
)paren
(brace
id|c
op_assign
id|get_next_char
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
l_char|&squot;&bslash;n&squot;
suffix:colon
r_continue
suffix:semicolon
r_case
l_char|&squot;t&squot;
suffix:colon
id|c
op_assign
l_char|&squot;&bslash;t&squot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;b&squot;
suffix:colon
id|c
op_assign
l_char|&squot;&bslash;b&squot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;n&squot;
suffix:colon
id|c
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Some characters escape as themselves */
r_case
l_char|&squot;&bslash;&bslash;&squot;
suffix:colon
r_case
l_char|&squot;&quot;&squot;
suffix:colon
r_break
suffix:semicolon
multiline_comment|/* Reject unknown escape sequences */
r_default
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
id|strbuf_addch
c_func
(paren
op_amp
id|cf-&gt;value
comma
id|c
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&quot;&squot;
)paren
(brace
id|quote
op_assign
l_int|1
op_minus
id|quote
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|strbuf_addch
c_func
(paren
op_amp
id|cf-&gt;value
comma
id|c
)paren
suffix:semicolon
)brace
)brace
DECL|function|iskeychar
r_static
r_inline
r_int
id|iskeychar
c_func
(paren
r_int
id|c
)paren
(brace
r_return
id|isalnum
c_func
(paren
id|c
)paren
op_logical_or
id|c
op_eq
l_char|&squot;-&squot;
suffix:semicolon
)brace
DECL|function|get_value
r_static
r_int
id|get_value
c_func
(paren
id|config_fn_t
id|fn
comma
r_void
op_star
id|data
comma
r_struct
id|strbuf
op_star
id|name
)paren
(brace
r_int
id|c
suffix:semicolon
r_char
op_star
id|value
suffix:semicolon
multiline_comment|/* Get the full name */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|c
op_assign
id|get_next_char
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cf-&gt;eof
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|iskeychar
c_func
(paren
id|c
)paren
)paren
r_break
suffix:semicolon
id|strbuf_addch
c_func
(paren
id|name
comma
id|tolower
c_func
(paren
id|c
)paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|c
op_eq
l_char|&squot; &squot;
op_logical_or
id|c
op_eq
l_char|&squot;&bslash;t&squot;
)paren
id|c
op_assign
id|get_next_char
c_func
(paren
)paren
suffix:semicolon
id|value
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|c
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
r_if
c_cond
(paren
id|c
op_ne
l_char|&squot;=&squot;
)paren
r_return
l_int|1
suffix:semicolon
id|value
op_assign
id|parse_value
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
id|fn
c_func
(paren
id|name-&gt;buf
comma
id|value
comma
id|data
)paren
suffix:semicolon
)brace
DECL|function|get_extended_base_var
r_static
r_int
id|get_extended_base_var
c_func
(paren
r_struct
id|strbuf
op_star
id|name
comma
r_int
id|c
)paren
(brace
r_do
(brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
r_goto
id|error_incomplete_line
suffix:semicolon
id|c
op_assign
id|get_next_char
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|isspace
c_func
(paren
id|c
)paren
)paren
suffix:semicolon
multiline_comment|/* We require the format to be &squot;[base &quot;extension&quot;]&squot; */
r_if
c_cond
(paren
id|c
op_ne
l_char|&squot;&quot;&squot;
)paren
r_return
l_int|1
suffix:semicolon
id|strbuf_addch
c_func
(paren
id|name
comma
l_char|&squot;.&squot;
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|c
op_assign
id|get_next_char
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
r_goto
id|error_incomplete_line
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&quot;&squot;
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;&bslash;&squot;
)paren
(brace
id|c
op_assign
id|get_next_char
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
r_goto
id|error_incomplete_line
suffix:semicolon
)brace
id|strbuf_addch
c_func
(paren
id|name
comma
id|c
)paren
suffix:semicolon
)brace
multiline_comment|/* Final &squot;]&squot; */
r_if
c_cond
(paren
id|get_next_char
c_func
(paren
)paren
op_ne
l_char|&squot;]&squot;
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|error_incomplete_line
suffix:colon
id|cf-&gt;linenr
op_decrement
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|get_base_var
r_static
r_int
id|get_base_var
c_func
(paren
r_struct
id|strbuf
op_star
id|name
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|c
op_assign
id|get_next_char
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cf-&gt;eof
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;]&squot;
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|isspace
c_func
(paren
id|c
)paren
)paren
r_return
id|get_extended_base_var
c_func
(paren
id|name
comma
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|iskeychar
c_func
(paren
id|c
)paren
op_logical_and
id|c
op_ne
l_char|&squot;.&squot;
)paren
r_return
l_int|1
suffix:semicolon
id|strbuf_addch
c_func
(paren
id|name
comma
id|tolower
c_func
(paren
id|c
)paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|git_parse_file
r_static
r_int
id|git_parse_file
c_func
(paren
id|config_fn_t
id|fn
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|comment
op_assign
l_int|0
suffix:semicolon
r_int
id|baselen
op_assign
l_int|0
suffix:semicolon
r_struct
id|strbuf
op_star
id|var
op_assign
op_amp
id|cf-&gt;var
suffix:semicolon
multiline_comment|/* U+FEFF Byte Order Mark in UTF8 */
r_static
r_const
r_int
r_char
op_star
id|utf8_bom
op_assign
(paren
r_int
r_char
op_star
)paren
l_string|&quot;&bslash;xef&bslash;xbb&bslash;xbf&quot;
suffix:semicolon
r_const
r_int
r_char
op_star
id|bomptr
op_assign
id|utf8_bom
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|c
op_assign
id|get_next_char
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bomptr
op_logical_and
op_star
id|bomptr
)paren
(brace
multiline_comment|/* We are at the file beginning; skip UTF8-encoded BOM&n;&t;&t;&t; * if present. Sane editors won&squot;t put this in on their&n;&t;&t;&t; * own, but e.g. Windows Notepad will do it happily. */
r_if
c_cond
(paren
(paren
r_int
r_char
)paren
id|c
op_eq
op_star
id|bomptr
)paren
(brace
id|bomptr
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Do not tolerate partial BOM. */
r_if
c_cond
(paren
id|bomptr
op_ne
id|utf8_bom
)paren
r_break
suffix:semicolon
multiline_comment|/* No BOM at file beginning. Cool. */
id|bomptr
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
r_if
c_cond
(paren
id|cf-&gt;eof
)paren
r_return
l_int|0
suffix:semicolon
id|comment
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|comment
op_logical_or
id|isspace
c_func
(paren
id|c
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;#&squot;
op_logical_or
id|c
op_eq
l_char|&squot;;&squot;
)paren
(brace
id|comment
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;[&squot;
)paren
(brace
multiline_comment|/* Reset prior to determining a new stem */
id|strbuf_reset
c_func
(paren
id|var
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_base_var
c_func
(paren
id|var
)paren
OL
l_int|0
op_logical_or
id|var-&gt;len
OL
l_int|1
)paren
r_break
suffix:semicolon
id|strbuf_addch
c_func
(paren
id|var
comma
l_char|&squot;.&squot;
)paren
suffix:semicolon
id|baselen
op_assign
id|var-&gt;len
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|isalpha
c_func
(paren
id|c
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Truncate the var name back to the section header&n;&t;&t; * stem prior to grabbing the suffix part of the name&n;&t;&t; * and the value.&n;&t;&t; */
id|strbuf_setlen
c_func
(paren
id|var
comma
id|baselen
)paren
suffix:semicolon
id|strbuf_addch
c_func
(paren
id|var
comma
id|tolower
c_func
(paren
id|c
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_value
c_func
(paren
id|fn
comma
id|data
comma
id|var
)paren
OL
l_int|0
)paren
r_break
suffix:semicolon
)brace
id|die
c_func
(paren
l_string|&quot;bad config file line %d in %s&quot;
comma
id|cf-&gt;linenr
comma
id|cf-&gt;name
)paren
suffix:semicolon
)brace
DECL|function|parse_unit_factor
r_static
r_int
id|parse_unit_factor
c_func
(paren
r_const
r_char
op_star
id|end
comma
r_uintmax
op_star
id|val
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|end
)paren
r_return
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcasecmp
c_func
(paren
id|end
comma
l_string|&quot;k&quot;
)paren
)paren
(brace
op_star
id|val
op_mul_assign
l_int|1024
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcasecmp
c_func
(paren
id|end
comma
l_string|&quot;m&quot;
)paren
)paren
(brace
op_star
id|val
op_mul_assign
l_int|1024
op_star
l_int|1024
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcasecmp
c_func
(paren
id|end
comma
l_string|&quot;g&quot;
)paren
)paren
(brace
op_star
id|val
op_mul_assign
l_int|1024
op_star
l_int|1024
op_star
l_int|1024
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|git_parse_long
r_static
r_int
id|git_parse_long
c_func
(paren
r_const
r_char
op_star
id|value
comma
r_int
op_star
id|ret
)paren
(brace
r_if
c_cond
(paren
id|value
op_logical_and
op_star
id|value
)paren
(brace
r_char
op_star
id|end
suffix:semicolon
r_intmax
id|val
suffix:semicolon
r_uintmax
id|uval
suffix:semicolon
r_uintmax
id|factor
op_assign
l_int|1
suffix:semicolon
id|errno
op_assign
l_int|0
suffix:semicolon
id|val
op_assign
id|strtoimax
c_func
(paren
id|value
comma
op_amp
id|end
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|errno
op_eq
id|ERANGE
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parse_unit_factor
c_func
(paren
id|end
comma
op_amp
id|factor
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|uval
op_assign
id|abs
c_func
(paren
id|val
)paren
suffix:semicolon
id|uval
op_mul_assign
id|factor
suffix:semicolon
r_if
c_cond
(paren
(paren
id|uval
OG
id|maximum_signed_value_of_type
c_func
(paren
r_int
)paren
)paren
op_logical_or
(paren
id|abs
c_func
(paren
id|val
)paren
OG
id|uval
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|val
op_mul_assign
id|factor
suffix:semicolon
op_star
id|ret
op_assign
id|val
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|git_parse_ulong
r_int
id|git_parse_ulong
c_func
(paren
r_const
r_char
op_star
id|value
comma
r_int
r_int
op_star
id|ret
)paren
(brace
r_if
c_cond
(paren
id|value
op_logical_and
op_star
id|value
)paren
(brace
r_char
op_star
id|end
suffix:semicolon
r_uintmax
id|val
suffix:semicolon
r_uintmax
id|oldval
suffix:semicolon
id|errno
op_assign
l_int|0
suffix:semicolon
id|val
op_assign
id|strtoumax
c_func
(paren
id|value
comma
op_amp
id|end
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|errno
op_eq
id|ERANGE
)paren
r_return
l_int|0
suffix:semicolon
id|oldval
op_assign
id|val
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parse_unit_factor
c_func
(paren
id|end
comma
op_amp
id|val
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|val
OG
id|maximum_unsigned_value_of_type
c_func
(paren
r_int
)paren
)paren
op_logical_or
(paren
id|oldval
OG
id|val
)paren
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|ret
op_assign
id|val
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|die_bad_config
r_static
r_void
id|die_bad_config
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_if
c_cond
(paren
id|cf
op_logical_and
id|cf-&gt;name
)paren
id|die
c_func
(paren
l_string|&quot;bad config value for &squot;%s&squot; in %s&quot;
comma
id|name
comma
id|cf-&gt;name
)paren
suffix:semicolon
id|die
c_func
(paren
l_string|&quot;bad config value for &squot;%s&squot;&quot;
comma
id|name
)paren
suffix:semicolon
)brace
DECL|function|git_config_int
r_int
id|git_config_int
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|git_parse_long
c_func
(paren
id|value
comma
op_amp
id|ret
)paren
)paren
id|die_bad_config
c_func
(paren
id|name
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|git_config_ulong
r_int
r_int
id|git_config_ulong
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_int
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|git_parse_ulong
c_func
(paren
id|value
comma
op_amp
id|ret
)paren
)paren
id|die_bad_config
c_func
(paren
id|name
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|git_config_maybe_bool_text
r_static
r_int
id|git_config_maybe_bool_text
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|value
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;true&quot;
)paren
op_logical_or
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;yes&quot;
)paren
op_logical_or
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;on&quot;
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;false&quot;
)paren
op_logical_or
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;no&quot;
)paren
op_logical_or
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;off&quot;
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|git_config_maybe_bool
r_int
id|git_config_maybe_bool
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_int
id|v
op_assign
id|git_config_maybe_bool_text
c_func
(paren
id|name
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_le
id|v
)paren
r_return
id|v
suffix:semicolon
r_if
c_cond
(paren
id|git_parse_long
c_func
(paren
id|value
comma
op_amp
id|v
)paren
)paren
r_return
op_logical_neg
op_logical_neg
id|v
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|git_config_bool_or_int
r_int
id|git_config_bool_or_int
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_const
r_char
op_star
id|value
comma
r_int
op_star
id|is_bool
)paren
(brace
r_int
id|v
op_assign
id|git_config_maybe_bool_text
c_func
(paren
id|name
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_le
id|v
)paren
(brace
op_star
id|is_bool
op_assign
l_int|1
suffix:semicolon
r_return
id|v
suffix:semicolon
)brace
op_star
id|is_bool
op_assign
l_int|0
suffix:semicolon
r_return
id|git_config_int
c_func
(paren
id|name
comma
id|value
)paren
suffix:semicolon
)brace
DECL|function|git_config_bool
r_int
id|git_config_bool
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_int
id|discard
suffix:semicolon
r_return
op_logical_neg
op_logical_neg
id|git_config_bool_or_int
c_func
(paren
id|name
comma
id|value
comma
op_amp
id|discard
)paren
suffix:semicolon
)brace
DECL|function|git_config_string
r_int
id|git_config_string
c_func
(paren
r_const
r_char
op_star
op_star
id|dest
comma
r_const
r_char
op_star
id|var
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
r_return
id|config_error_nonbool
c_func
(paren
id|var
)paren
suffix:semicolon
op_star
id|dest
op_assign
id|xstrdup
c_func
(paren
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|git_config_pathname
r_int
id|git_config_pathname
c_func
(paren
r_const
r_char
op_star
op_star
id|dest
comma
r_const
r_char
op_star
id|var
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
r_return
id|config_error_nonbool
c_func
(paren
id|var
)paren
suffix:semicolon
op_star
id|dest
op_assign
id|expand_user_path
c_func
(paren
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|dest
)paren
id|die
c_func
(paren
l_string|&quot;Failed to expand user dir in: &squot;%s&squot;&quot;
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|git_default_core_config
r_static
r_int
id|git_default_core_config
c_func
(paren
r_const
r_char
op_star
id|var
comma
r_const
r_char
op_star
id|value
)paren
(brace
multiline_comment|/* This needs a better name */
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.filemode&quot;
)paren
)paren
(brace
id|trust_executable_bit
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.trustctime&quot;
)paren
)paren
(brace
id|trust_ctime
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.statinfo&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.checkstat&quot;
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * NEEDSWORK: statinfo was a typo in v1.8.2 that has&n;&t;&t; * never been advertised.  we will remove it at Git&n;&t;&t; * 2.0 boundary.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.statinfo&quot;
)paren
)paren
(brace
r_static
r_int
id|warned
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|warned
op_increment
)paren
(brace
id|warning
c_func
(paren
l_string|&quot;&squot;core.statinfo&squot; will be removed in Git 2.0; &quot;
l_string|&quot;use &squot;core.checkstat&squot; instead.&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;default&quot;
)paren
)paren
id|check_stat
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;minimal&quot;
)paren
)paren
id|check_stat
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.quotepath&quot;
)paren
)paren
(brace
id|quote_path_fully
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.symlinks&quot;
)paren
)paren
(brace
id|has_symlinks
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.ignorecase&quot;
)paren
)paren
(brace
id|ignore_case
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.attributesfile&quot;
)paren
)paren
r_return
id|git_config_pathname
c_func
(paren
op_amp
id|git_attributes_file
comma
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.bare&quot;
)paren
)paren
(brace
id|is_bare_repository_cfg
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.ignorestat&quot;
)paren
)paren
(brace
id|assume_unchanged
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.prefersymlinkrefs&quot;
)paren
)paren
(brace
id|prefer_symlink_refs
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.logallrefupdates&quot;
)paren
)paren
(brace
id|log_all_ref_updates
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.warnambiguousrefs&quot;
)paren
)paren
(brace
id|warn_ambiguous_refs
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.abbrev&quot;
)paren
)paren
(brace
r_int
id|abbrev
op_assign
id|git_config_int
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|abbrev
template_param
l_int|40
)paren
r_return
l_int|1
suffix:semicolon
id|default_abbrev
op_assign
id|abbrev
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.loosecompression&quot;
)paren
)paren
(brace
r_int
id|level
op_assign
id|git_config_int
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|level
op_eq
l_int|1
)paren
id|level
op_assign
id|Z_DEFAULT_COMPRESSION
suffix:semicolon
r_else
r_if
c_cond
(paren
id|level
template_param
id|Z_BEST_COMPRESSION
)paren
id|die
c_func
(paren
l_string|&quot;bad zlib compression level %d&quot;
comma
id|level
)paren
suffix:semicolon
id|zlib_compression_level
op_assign
id|level
suffix:semicolon
id|zlib_compression_seen
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.compression&quot;
)paren
)paren
(brace
r_int
id|level
op_assign
id|git_config_int
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|level
op_eq
l_int|1
)paren
id|level
op_assign
id|Z_DEFAULT_COMPRESSION
suffix:semicolon
r_else
r_if
c_cond
(paren
id|level
template_param
id|Z_BEST_COMPRESSION
)paren
id|die
c_func
(paren
l_string|&quot;bad zlib compression level %d&quot;
comma
id|level
)paren
suffix:semicolon
id|core_compression_level
op_assign
id|level
suffix:semicolon
id|core_compression_seen
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|zlib_compression_seen
)paren
id|zlib_compression_level
op_assign
id|level
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.packedgitwindowsize&quot;
)paren
)paren
(brace
r_int
id|pgsz_x2
op_assign
id|getpagesize
c_func
(paren
)paren
op_star
l_int|2
suffix:semicolon
id|packed_git_window_size
op_assign
id|git_config_ulong
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
multiline_comment|/* This value must be multiple of (pagesize * 2) */
id|packed_git_window_size
op_div_assign
id|pgsz_x2
suffix:semicolon
r_if
c_cond
(paren
id|packed_git_window_size
OL
l_int|1
)paren
id|packed_git_window_size
op_assign
l_int|1
suffix:semicolon
id|packed_git_window_size
op_mul_assign
id|pgsz_x2
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.bigfilethreshold&quot;
)paren
)paren
(brace
id|big_file_threshold
op_assign
id|git_config_ulong
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.packedgitlimit&quot;
)paren
)paren
(brace
id|packed_git_limit
op_assign
id|git_config_ulong
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.deltabasecachelimit&quot;
)paren
)paren
(brace
id|delta_base_cache_limit
op_assign
id|git_config_ulong
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.logpackaccess&quot;
)paren
)paren
r_return
id|git_config_string
c_func
(paren
op_amp
id|log_pack_access
comma
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.autocrlf&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|value
op_logical_and
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;input&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|core_eol
op_eq
id|EOL_CRLF
)paren
r_return
id|error
c_func
(paren
l_string|&quot;core.autocrlf=input conflicts with core.eol=crlf&quot;
)paren
suffix:semicolon
id|auto_crlf
op_assign
id|AUTO_CRLF_INPUT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|auto_crlf
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.safecrlf&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|value
op_logical_and
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;warn&quot;
)paren
)paren
(brace
id|safe_crlf
op_assign
id|SAFE_CRLF_WARN
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|safe_crlf
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.eol&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|value
op_logical_and
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;lf&quot;
)paren
)paren
id|core_eol
op_assign
id|EOL_LF
suffix:semicolon
r_else
r_if
c_cond
(paren
id|value
op_logical_and
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;crlf&quot;
)paren
)paren
id|core_eol
op_assign
id|EOL_CRLF
suffix:semicolon
r_else
r_if
c_cond
(paren
id|value
op_logical_and
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;native&quot;
)paren
)paren
id|core_eol
op_assign
id|EOL_NATIVE
suffix:semicolon
r_else
id|core_eol
op_assign
id|EOL_UNSET
suffix:semicolon
r_if
c_cond
(paren
id|core_eol
op_eq
id|EOL_CRLF
op_logical_and
id|auto_crlf
op_eq
id|AUTO_CRLF_INPUT
)paren
r_return
id|error
c_func
(paren
l_string|&quot;core.autocrlf=input conflicts with core.eol=crlf&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.notesref&quot;
)paren
)paren
(brace
id|notes_ref_name
op_assign
id|xstrdup
c_func
(paren
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.pager&quot;
)paren
)paren
r_return
id|git_config_string
c_func
(paren
op_amp
id|pager_program
comma
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.editor&quot;
)paren
)paren
r_return
id|git_config_string
c_func
(paren
op_amp
id|editor_program
comma
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.commentchar&quot;
)paren
)paren
(brace
r_const
r_char
op_star
id|comment
suffix:semicolon
r_int
id|ret
op_assign
id|git_config_string
c_func
(paren
op_amp
id|comment
comma
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|comment_line_char
op_assign
id|comment
(braket
l_int|0
)braket
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.askpass&quot;
)paren
)paren
r_return
id|git_config_string
c_func
(paren
op_amp
id|askpass_program
comma
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.excludesfile&quot;
)paren
)paren
r_return
id|git_config_pathname
c_func
(paren
op_amp
id|excludes_file
comma
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.whitespace&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
r_return
id|config_error_nonbool
c_func
(paren
id|var
)paren
suffix:semicolon
id|whitespace_rule_cfg
op_assign
id|parse_whitespace_rule
c_func
(paren
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.fsyncobjectfiles&quot;
)paren
)paren
(brace
id|fsync_object_files
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.preloadindex&quot;
)paren
)paren
(brace
id|core_preload_index
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.createobject&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|value
comma
l_string|&quot;rename&quot;
)paren
)paren
id|object_creation_mode
op_assign
id|OBJECT_CREATION_USES_RENAMES
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|value
comma
l_string|&quot;link&quot;
)paren
)paren
id|object_creation_mode
op_assign
id|OBJECT_CREATION_USES_HARDLINKS
suffix:semicolon
r_else
id|die
c_func
(paren
l_string|&quot;Invalid mode for object creation: %s&quot;
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.sparsecheckout&quot;
)paren
)paren
(brace
id|core_apply_sparse_checkout
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.precomposeunicode&quot;
)paren
)paren
(brace
id|precomposed_unicode
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Add other config variables here and to Documentation/config.txt. */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|git_default_i18n_config
r_static
r_int
id|git_default_i18n_config
c_func
(paren
r_const
r_char
op_star
id|var
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;i18n.commitencoding&quot;
)paren
)paren
r_return
id|git_config_string
c_func
(paren
op_amp
id|git_commit_encoding
comma
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;i18n.logoutputencoding&quot;
)paren
)paren
r_return
id|git_config_string
c_func
(paren
op_amp
id|git_log_output_encoding
comma
id|var
comma
id|value
)paren
suffix:semicolon
multiline_comment|/* Add other config variables here and to Documentation/config.txt. */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|git_default_branch_config
r_static
r_int
id|git_default_branch_config
c_func
(paren
r_const
r_char
op_star
id|var
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;branch.autosetupmerge&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|value
op_logical_and
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;always&quot;
)paren
)paren
(brace
id|git_branch_track
op_assign
id|BRANCH_TRACK_ALWAYS
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|git_branch_track
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;branch.autosetuprebase&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
r_return
id|config_error_nonbool
c_func
(paren
id|var
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|value
comma
l_string|&quot;never&quot;
)paren
)paren
id|autorebase
op_assign
id|AUTOREBASE_NEVER
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|value
comma
l_string|&quot;local&quot;
)paren
)paren
id|autorebase
op_assign
id|AUTOREBASE_LOCAL
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|value
comma
l_string|&quot;remote&quot;
)paren
)paren
id|autorebase
op_assign
id|AUTOREBASE_REMOTE
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|value
comma
l_string|&quot;always&quot;
)paren
)paren
id|autorebase
op_assign
id|AUTOREBASE_ALWAYS
suffix:semicolon
r_else
r_return
id|error
c_func
(paren
l_string|&quot;Malformed value for %s&quot;
comma
id|var
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Add other config variables here and to Documentation/config.txt. */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|git_default_push_config
r_static
r_int
id|git_default_push_config
c_func
(paren
r_const
r_char
op_star
id|var
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;push.default&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
r_return
id|config_error_nonbool
c_func
(paren
id|var
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|value
comma
l_string|&quot;nothing&quot;
)paren
)paren
id|push_default
op_assign
id|PUSH_DEFAULT_NOTHING
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|value
comma
l_string|&quot;matching&quot;
)paren
)paren
id|push_default
op_assign
id|PUSH_DEFAULT_MATCHING
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|value
comma
l_string|&quot;simple&quot;
)paren
)paren
id|push_default
op_assign
id|PUSH_DEFAULT_SIMPLE
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|value
comma
l_string|&quot;upstream&quot;
)paren
)paren
id|push_default
op_assign
id|PUSH_DEFAULT_UPSTREAM
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|value
comma
l_string|&quot;tracking&quot;
)paren
)paren
multiline_comment|/* deprecated */
id|push_default
op_assign
id|PUSH_DEFAULT_UPSTREAM
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|value
comma
l_string|&quot;current&quot;
)paren
)paren
id|push_default
op_assign
id|PUSH_DEFAULT_CURRENT
suffix:semicolon
r_else
(brace
id|error
c_func
(paren
l_string|&quot;Malformed value for %s: %s&quot;
comma
id|var
comma
id|value
)paren
suffix:semicolon
r_return
id|error
c_func
(paren
l_string|&quot;Must be one of nothing, matching, simple, &quot;
l_string|&quot;upstream or current.&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Add other config variables here and to Documentation/config.txt. */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|git_default_mailmap_config
r_static
r_int
id|git_default_mailmap_config
c_func
(paren
r_const
r_char
op_star
id|var
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;mailmap.file&quot;
)paren
)paren
r_return
id|git_config_string
c_func
(paren
op_amp
id|git_mailmap_file
comma
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;mailmap.blob&quot;
)paren
)paren
r_return
id|git_config_string
c_func
(paren
op_amp
id|git_mailmap_blob
comma
id|var
comma
id|value
)paren
suffix:semicolon
multiline_comment|/* Add other config variables here and to Documentation/config.txt. */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|git_default_config
r_int
id|git_default_config
c_func
(paren
r_const
r_char
op_star
id|var
comma
r_const
r_char
op_star
id|value
comma
r_void
op_star
id|dummy
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|var
comma
l_string|&quot;core.&quot;
)paren
)paren
r_return
id|git_default_core_config
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|var
comma
l_string|&quot;user.&quot;
)paren
)paren
r_return
id|git_ident_config
c_func
(paren
id|var
comma
id|value
comma
id|dummy
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|var
comma
l_string|&quot;i18n.&quot;
)paren
)paren
r_return
id|git_default_i18n_config
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|var
comma
l_string|&quot;branch.&quot;
)paren
)paren
r_return
id|git_default_branch_config
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|var
comma
l_string|&quot;push.&quot;
)paren
)paren
r_return
id|git_default_push_config
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|var
comma
l_string|&quot;mailmap.&quot;
)paren
)paren
r_return
id|git_default_mailmap_config
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|var
comma
l_string|&quot;advice.&quot;
)paren
)paren
r_return
id|git_default_advice_config
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;pager.color&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;color.pager&quot;
)paren
)paren
(brace
id|pager_use_color
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;pack.packsizelimit&quot;
)paren
)paren
(brace
id|pack_size_limit_cfg
op_assign
id|git_config_ulong
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Add other config variables here and to Documentation/config.txt. */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|git_config_from_file
r_int
id|git_config_from_file
c_func
(paren
id|config_fn_t
id|fn
comma
r_const
r_char
op_star
id|filename
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|ret
suffix:semicolon
id|FILE
op_star
id|f
op_assign
id|fopen
c_func
(paren
id|filename
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|f
)paren
(brace
id|config_file
id|top
suffix:semicolon
multiline_comment|/* push config-file parsing state stack */
id|top.prev
op_assign
id|cf
suffix:semicolon
id|top.f
op_assign
id|f
suffix:semicolon
id|top.name
op_assign
id|filename
suffix:semicolon
id|top.linenr
op_assign
l_int|1
suffix:semicolon
id|top.eof
op_assign
l_int|0
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|top.value
comma
l_int|1024
)paren
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|top.var
comma
l_int|1024
)paren
suffix:semicolon
id|cf
op_assign
op_amp
id|top
suffix:semicolon
id|ret
op_assign
id|git_parse_file
c_func
(paren
id|fn
comma
id|data
)paren
suffix:semicolon
multiline_comment|/* pop config-file parsing state stack */
id|strbuf_release
c_func
(paren
op_amp
id|top.value
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|top.var
)paren
suffix:semicolon
id|cf
op_assign
id|top.prev
suffix:semicolon
id|fclose
c_func
(paren
id|f
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|git_etc_gitconfig
r_const
r_char
op_star
id|git_etc_gitconfig
c_func
(paren
r_void
)paren
(brace
r_static
r_const
r_char
op_star
id|system_wide
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|system_wide
)paren
id|system_wide
op_assign
id|system_path
c_func
(paren
id|ETC_GITCONFIG
)paren
suffix:semicolon
r_return
id|system_wide
suffix:semicolon
)brace
DECL|function|git_env_bool
r_int
id|git_env_bool
c_func
(paren
r_const
r_char
op_star
id|k
comma
r_int
id|def
)paren
(brace
r_const
r_char
op_star
id|v
op_assign
id|getenv
c_func
(paren
id|k
)paren
suffix:semicolon
r_return
id|v
ques
c_cond
id|git_config_bool
c_func
(paren
id|k
comma
id|v
)paren
suffix:colon
id|def
suffix:semicolon
)brace
DECL|function|git_config_system
r_int
id|git_config_system
c_func
(paren
r_void
)paren
(brace
r_return
op_logical_neg
id|git_env_bool
c_func
(paren
l_string|&quot;GIT_CONFIG_NOSYSTEM&quot;
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|git_config_early
r_int
id|git_config_early
c_func
(paren
id|config_fn_t
id|fn
comma
r_void
op_star
id|data
comma
r_const
r_char
op_star
id|repo_config
)paren
(brace
r_int
id|ret
op_assign
l_int|0
comma
id|found
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|xdg_config
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
id|user_config
op_assign
l_int|NULL
suffix:semicolon
id|home_config_paths
c_func
(paren
op_amp
id|user_config
comma
op_amp
id|xdg_config
comma
l_string|&quot;config&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|git_config_system
c_func
(paren
)paren
op_logical_and
op_logical_neg
id|access_or_die
c_func
(paren
id|git_etc_gitconfig
c_func
(paren
)paren
comma
id|R_OK
comma
l_int|0
)paren
)paren
(brace
id|ret
op_add_assign
id|git_config_from_file
c_func
(paren
id|fn
comma
id|git_etc_gitconfig
c_func
(paren
)paren
comma
id|data
)paren
suffix:semicolon
id|found
op_add_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|xdg_config
op_logical_and
op_logical_neg
id|access_or_die
c_func
(paren
id|xdg_config
comma
id|R_OK
comma
id|ACCESS_EACCES_OK
)paren
)paren
(brace
id|ret
op_add_assign
id|git_config_from_file
c_func
(paren
id|fn
comma
id|xdg_config
comma
id|data
)paren
suffix:semicolon
id|found
op_add_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|user_config
op_logical_and
op_logical_neg
id|access_or_die
c_func
(paren
id|user_config
comma
id|R_OK
comma
id|ACCESS_EACCES_OK
)paren
)paren
(brace
id|ret
op_add_assign
id|git_config_from_file
c_func
(paren
id|fn
comma
id|user_config
comma
id|data
)paren
suffix:semicolon
id|found
op_add_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|repo_config
op_logical_and
op_logical_neg
id|access_or_die
c_func
(paren
id|repo_config
comma
id|R_OK
comma
l_int|0
)paren
)paren
(brace
id|ret
op_add_assign
id|git_config_from_file
c_func
(paren
id|fn
comma
id|repo_config
comma
id|data
)paren
suffix:semicolon
id|found
op_add_assign
l_int|1
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|git_config_from_parameters
c_func
(paren
id|fn
comma
id|data
)paren
)paren
(brace
r_case
l_int|1
suffix:colon
multiline_comment|/* error */
id|die
c_func
(paren
l_string|&quot;unable to parse command-line config&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
multiline_comment|/* found nothing */
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* found at least one item */
id|found
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
id|free
c_func
(paren
id|xdg_config
)paren
suffix:semicolon
id|free
c_func
(paren
id|user_config
)paren
suffix:semicolon
r_return
id|ret
op_eq
l_int|0
ques
c_cond
id|found
suffix:colon
id|ret
suffix:semicolon
)brace
DECL|function|git_config_with_options
r_int
id|git_config_with_options
c_func
(paren
id|config_fn_t
id|fn
comma
r_void
op_star
id|data
comma
r_const
r_char
op_star
id|filename
comma
r_int
id|respect_includes
)paren
(brace
r_char
op_star
id|repo_config
op_assign
l_int|NULL
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_struct
id|config_include_data
id|inc
op_assign
id|CONFIG_INCLUDE_INIT
suffix:semicolon
r_if
c_cond
(paren
id|respect_includes
)paren
(brace
id|inc.fn
op_assign
id|fn
suffix:semicolon
id|inc.data
op_assign
id|data
suffix:semicolon
id|fn
op_assign
id|git_config_include
suffix:semicolon
id|data
op_assign
op_amp
id|inc
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we have a specific filename, use it. Otherwise, follow the&n;&t; * regular lookup sequence.&n;&t; */
r_if
c_cond
(paren
id|filename
)paren
r_return
id|git_config_from_file
c_func
(paren
id|fn
comma
id|filename
comma
id|data
)paren
suffix:semicolon
id|repo_config
op_assign
id|git_pathdup
c_func
(paren
l_string|&quot;config&quot;
)paren
suffix:semicolon
id|ret
op_assign
id|git_config_early
c_func
(paren
id|fn
comma
id|data
comma
id|repo_config
)paren
suffix:semicolon
r_if
c_cond
(paren
id|repo_config
)paren
id|free
c_func
(paren
id|repo_config
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|git_config
r_int
id|git_config
c_func
(paren
id|config_fn_t
id|fn
comma
r_void
op_star
id|data
)paren
(brace
r_return
id|git_config_with_options
c_func
(paren
id|fn
comma
id|data
comma
l_int|NULL
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Find all the stuff for git_config_set() below.&n; */
DECL|macro|MAX_MATCHES
mdefine_line|#define MAX_MATCHES 512
r_static
r_struct
(brace
DECL|member|baselen
r_int
id|baselen
suffix:semicolon
DECL|member|key
r_char
op_star
id|key
suffix:semicolon
DECL|member|do_not_match
r_int
id|do_not_match
suffix:semicolon
DECL|member|value_regex
id|regex_t
op_star
id|value_regex
suffix:semicolon
DECL|member|multi_replace
r_int
id|multi_replace
suffix:semicolon
DECL|member|offset
r_int
id|offset
(braket
id|MAX_MATCHES
)braket
suffix:semicolon
DECL|enumerator|START
DECL|enumerator|SECTION_SEEN
DECL|enumerator|SECTION_END_SEEN
DECL|enumerator|KEY_SEEN
DECL|member|state
r_enum
(brace
id|START
comma
id|SECTION_SEEN
comma
id|SECTION_END_SEEN
comma
id|KEY_SEEN
)brace
id|state
suffix:semicolon
DECL|member|seen
r_int
id|seen
suffix:semicolon
DECL|variable|store
)brace
id|store
suffix:semicolon
DECL|function|matches
r_static
r_int
id|matches
c_func
(paren
r_const
r_char
op_star
id|key
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_return
op_logical_neg
id|strcmp
c_func
(paren
id|key
comma
id|store.key
)paren
op_logical_and
(paren
id|store.value_regex
op_eq
l_int|NULL
op_logical_or
(paren
id|store.do_not_match
op_xor
op_logical_neg
id|regexec
c_func
(paren
id|store.value_regex
comma
id|value
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
)paren
)paren
)paren
suffix:semicolon
)brace
DECL|function|store_aux
r_static
r_int
id|store_aux
c_func
(paren
r_const
r_char
op_star
id|key
comma
r_const
r_char
op_star
id|value
comma
r_void
op_star
id|cb
)paren
(brace
r_const
r_char
op_star
id|ep
suffix:semicolon
r_int
id|section_len
suffix:semicolon
id|FILE
op_star
id|f
op_assign
id|cf-&gt;f
suffix:semicolon
r_switch
c_cond
(paren
id|store.state
)paren
(brace
r_case
id|KEY_SEEN
suffix:colon
r_if
c_cond
(paren
id|matches
c_func
(paren
id|key
comma
id|value
)paren
)paren
(brace
r_if
c_cond
(paren
id|store.seen
op_eq
l_int|1
op_logical_and
id|store.multi_replace
op_eq
l_int|0
)paren
(brace
id|warning
c_func
(paren
l_string|&quot;%s has multiple values&quot;
comma
id|key
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|store.seen
op_ge
id|MAX_MATCHES
)paren
(brace
id|error
c_func
(paren
l_string|&quot;too many matches for %s&quot;
comma
id|key
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|store.offset
(braket
id|store.seen
)braket
op_assign
id|ftell
c_func
(paren
id|f
)paren
suffix:semicolon
id|store.seen
op_increment
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SECTION_SEEN
suffix:colon
multiline_comment|/*&n;&t;&t; * What we are looking for is in store.key (both&n;&t;&t; * section and var), and its section part is baselen&n;&t;&t; * long.  We found key (again, both section and var).&n;&t;&t; * We would want to know if this key is in the same&n;&t;&t; * section as what we are looking for.  We already&n;&t;&t; * know we are in the same section as what should&n;&t;&t; * hold store.key.&n;&t;&t; */
id|ep
op_assign
id|strrchr
c_func
(paren
id|key
comma
l_char|&squot;.&squot;
)paren
suffix:semicolon
id|section_len
op_assign
id|ep
id|key
suffix:semicolon
r_if
c_cond
(paren
(paren
id|section_len
op_ne
id|store.baselen
)paren
op_logical_or
id|memcmp
c_func
(paren
id|key
comma
id|store.key
comma
id|section_len
op_plus
l_int|1
)paren
)paren
(brace
id|store.state
op_assign
id|SECTION_END_SEEN
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Do not increment matches: this is no match, but we&n;&t;&t; * just made sure we are in the desired section.&n;&t;&t; */
id|store.offset
(braket
id|store.seen
)braket
op_assign
id|ftell
c_func
(paren
id|f
)paren
suffix:semicolon
multiline_comment|/* fallthru */
r_case
id|SECTION_END_SEEN
suffix:colon
r_case
id|START
suffix:colon
r_if
c_cond
(paren
id|matches
c_func
(paren
id|key
comma
id|value
)paren
)paren
(brace
id|store.offset
(braket
id|store.seen
)braket
op_assign
id|ftell
c_func
(paren
id|f
)paren
suffix:semicolon
id|store.state
op_assign
id|KEY_SEEN
suffix:semicolon
id|store.seen
op_increment
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|strrchr
c_func
(paren
id|key
comma
l_char|&squot;.&squot;
)paren
id|key
op_eq
id|store.baselen
op_logical_and
op_logical_neg
id|strncmp
c_func
(paren
id|key
comma
id|store.key
comma
id|store.baselen
)paren
)paren
(brace
id|store.state
op_assign
id|SECTION_SEEN
suffix:semicolon
id|store.offset
(braket
id|store.seen
)braket
op_assign
id|ftell
c_func
(paren
id|f
)paren
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|write_error
r_static
r_int
id|write_error
c_func
(paren
r_const
r_char
op_star
id|filename
)paren
(brace
id|error
c_func
(paren
l_string|&quot;failed to write new configuration file %s&quot;
comma
id|filename
)paren
suffix:semicolon
multiline_comment|/* Same error code as &quot;failed to rename&quot;. */
r_return
l_int|4
suffix:semicolon
)brace
DECL|function|store_write_section
r_static
r_int
id|store_write_section
c_func
(paren
r_int
id|fd
comma
r_const
r_char
op_star
id|key
)paren
(brace
r_const
r_char
op_star
id|dot
suffix:semicolon
r_int
id|i
comma
id|success
suffix:semicolon
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
id|dot
op_assign
id|memchr
c_func
(paren
id|key
comma
l_char|&squot;.&squot;
comma
id|store.baselen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dot
)paren
(brace
id|strbuf_addf
c_func
(paren
op_amp
id|sb
comma
l_string|&quot;[%.*s &bslash;&quot;&quot;
comma
(paren
r_int
)paren
(paren
id|dot
id|key
)paren
comma
id|key
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|dot
id|key
op_plus
l_int|1
suffix:semicolon
id|i
OL
id|store.baselen
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|key
(braket
id|i
)braket
op_eq
l_char|&squot;&quot;&squot;
op_logical_or
id|key
(braket
id|i
)braket
op_eq
l_char|&squot;&bslash;&bslash;&squot;
)paren
id|strbuf_addch
c_func
(paren
op_amp
id|sb
comma
l_char|&squot;&bslash;&bslash;&squot;
)paren
suffix:semicolon
id|strbuf_addch
c_func
(paren
op_amp
id|sb
comma
id|key
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|strbuf_addstr
c_func
(paren
op_amp
id|sb
comma
l_string|&quot;&bslash;&quot;]&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|strbuf_addf
c_func
(paren
op_amp
id|sb
comma
l_string|&quot;[%.*s]&bslash;n&quot;
comma
id|store.baselen
comma
id|key
)paren
suffix:semicolon
)brace
id|success
op_assign
id|write_in_full
c_func
(paren
id|fd
comma
id|sb.buf
comma
id|sb.len
)paren
op_eq
id|sb.len
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
r_return
id|success
suffix:semicolon
)brace
DECL|function|store_write_pair
r_static
r_int
id|store_write_pair
c_func
(paren
r_int
id|fd
comma
r_const
r_char
op_star
id|key
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_int
id|i
comma
id|success
suffix:semicolon
r_int
id|length
op_assign
id|strlen
c_func
(paren
id|key
op_plus
id|store.baselen
op_plus
l_int|1
)paren
suffix:semicolon
r_const
r_char
op_star
id|quote
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
multiline_comment|/*&n;&t; * Check to see if the value needs to be surrounded with a dq pair.&n;&t; * Note that problematic characters are always backslash-quoted; this&n;&t; * check is about not losing leading or trailing SP and strings that&n;&t; * follow beginning-of-comment characters (i.e. &squot;;&squot; and &squot;#&squot;) by the&n;&t; * configuration parser.&n;&t; */
r_if
c_cond
(paren
id|value
(braket
l_int|0
)braket
op_eq
l_char|&squot; &squot;
)paren
id|quote
op_assign
l_string|&quot;&bslash;&quot;&quot;
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|value
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|value
(braket
id|i
)braket
op_eq
l_char|&squot;;&squot;
op_logical_or
id|value
(braket
id|i
)braket
op_eq
l_char|&squot;#&squot;
)paren
id|quote
op_assign
l_string|&quot;&bslash;&quot;&quot;
suffix:semicolon
r_if
c_cond
(paren
id|i
op_logical_and
id|value
(braket
id|i
l_int|1
)braket
op_eq
l_char|&squot; &squot;
)paren
id|quote
op_assign
l_string|&quot;&bslash;&quot;&quot;
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
id|sb
comma
l_string|&quot;&bslash;t%.*s = %s&quot;
comma
id|length
comma
id|key
op_plus
id|store.baselen
op_plus
l_int|1
comma
id|quote
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|value
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
r_switch
c_cond
(paren
id|value
(braket
id|i
)braket
)paren
(brace
r_case
l_char|&squot;&bslash;n&squot;
suffix:colon
id|strbuf_addstr
c_func
(paren
op_amp
id|sb
comma
l_string|&quot;&bslash;&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;&bslash;t&squot;
suffix:colon
id|strbuf_addstr
c_func
(paren
op_amp
id|sb
comma
l_string|&quot;&bslash;&bslash;t&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;&quot;&squot;
suffix:colon
r_case
l_char|&squot;&bslash;&bslash;&squot;
suffix:colon
id|strbuf_addch
c_func
(paren
op_amp
id|sb
comma
l_char|&squot;&bslash;&bslash;&squot;
)paren
suffix:semicolon
r_default
suffix:colon
id|strbuf_addch
c_func
(paren
op_amp
id|sb
comma
id|value
(braket
id|i
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|strbuf_addf
c_func
(paren
op_amp
id|sb
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|quote
)paren
suffix:semicolon
id|success
op_assign
id|write_in_full
c_func
(paren
id|fd
comma
id|sb.buf
comma
id|sb.len
)paren
op_eq
id|sb.len
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
r_return
id|success
suffix:semicolon
)brace
DECL|function|find_beginning_of_line
r_static
id|ssize_t
id|find_beginning_of_line
c_func
(paren
r_const
r_char
op_star
id|contents
comma
r_int
id|size
comma
r_int
id|offset_
comma
r_int
op_star
id|found_bracket
)paren
(brace
r_int
id|equal_offset
op_assign
id|size
comma
id|bracket_offset
op_assign
id|size
suffix:semicolon
id|ssize_t
id|offset
suffix:semicolon
id|contline
suffix:colon
r_for
c_loop
(paren
id|offset
op_assign
id|offset_
op_minus
l_int|2
suffix:semicolon
id|offset
OG
l_int|0
op_logical_and
id|contents
(braket
id|offset
)braket
op_ne
l_char|&squot;&bslash;n&squot;
suffix:semicolon
id|offset
op_decrement
)paren
r_switch
c_cond
(paren
id|contents
(braket
id|offset
)braket
)paren
(brace
r_case
l_char|&squot;=&squot;
suffix:colon
id|equal_offset
op_assign
id|offset
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;]&squot;
suffix:colon
id|bracket_offset
op_assign
id|offset
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|offset
OG
l_int|0
op_logical_and
id|contents
(braket
id|offset
op_minus
l_int|1
)braket
op_eq
l_char|&squot;&bslash;&bslash;&squot;
)paren
(brace
id|offset_
op_assign
id|offset
suffix:semicolon
r_goto
id|contline
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bracket_offset
OL
id|equal_offset
)paren
(brace
op_star
id|found_bracket
op_assign
l_int|1
suffix:semicolon
id|offset
op_assign
id|bracket_offset
op_plus
l_int|1
suffix:semicolon
)brace
r_else
id|offset
op_increment
suffix:semicolon
r_return
id|offset
suffix:semicolon
)brace
DECL|function|git_config_set_in_file
r_int
id|git_config_set_in_file
c_func
(paren
r_const
r_char
op_star
id|config_filename
comma
r_const
r_char
op_star
id|key
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_return
id|git_config_set_multivar_in_file
c_func
(paren
id|config_filename
comma
id|key
comma
id|value
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|git_config_set
r_int
id|git_config_set
c_func
(paren
r_const
r_char
op_star
id|key
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_return
id|git_config_set_multivar
c_func
(paren
id|key
comma
id|value
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Auxiliary function to sanity-check and split the key into the section&n; * identifier and variable name.&n; *&n; * Returns 0 on success, -1 when there is an invalid character in the key and&n; * -2 if there is no section name in the key.&n; *&n; * store_key - pointer to char* which will hold a copy of the key with&n; *             lowercase section and variable name&n; * baselen - pointer to int which will hold the length of the&n; *           section + subsection part, can be NULL&n; */
DECL|function|git_config_parse_key
r_int
id|git_config_parse_key
c_func
(paren
r_const
r_char
op_star
id|key
comma
r_char
op_star
op_star
id|store_key
comma
r_int
op_star
id|baselen_
)paren
(brace
r_int
id|i
comma
id|dot
comma
id|baselen
suffix:semicolon
r_const
r_char
op_star
id|last_dot
op_assign
id|strrchr
c_func
(paren
id|key
comma
l_char|&squot;.&squot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Since &quot;key&quot; actually contains the section name and the real&n;&t; * key name separated by a dot, we have to know where the dot is.&n;&t; */
r_if
c_cond
(paren
id|last_dot
op_eq
l_int|NULL
op_logical_or
id|last_dot
op_eq
id|key
)paren
(brace
id|error
c_func
(paren
l_string|&quot;key does not contain a section: %s&quot;
comma
id|key
)paren
suffix:semicolon
r_return
id|CONFIG_NO_SECTION_OR_NAME
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|last_dot
(braket
l_int|1
)braket
)paren
(brace
id|error
c_func
(paren
l_string|&quot;key does not contain variable name: %s&quot;
comma
id|key
)paren
suffix:semicolon
r_return
id|CONFIG_NO_SECTION_OR_NAME
suffix:semicolon
)brace
id|baselen
op_assign
id|last_dot
id|key
suffix:semicolon
r_if
c_cond
(paren
id|baselen_
)paren
op_star
id|baselen_
op_assign
id|baselen
suffix:semicolon
multiline_comment|/*&n;&t; * Validate the key and while at it, lower case it for matching.&n;&t; */
op_star
id|store_key
op_assign
id|xmalloc
c_func
(paren
id|strlen
c_func
(paren
id|key
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|dot
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|key
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_char
id|c
op_assign
id|key
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;.&squot;
)paren
id|dot
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Leave the extended basename untouched.. */
r_if
c_cond
(paren
op_logical_neg
id|dot
op_logical_or
id|i
OG
id|baselen
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|iskeychar
c_func
(paren
id|c
)paren
op_logical_or
(paren
id|i
op_eq
id|baselen
op_plus
l_int|1
op_logical_and
op_logical_neg
id|isalpha
c_func
(paren
id|c
)paren
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;invalid key: %s&quot;
comma
id|key
)paren
suffix:semicolon
r_goto
id|out_free_ret_1
suffix:semicolon
)brace
id|c
op_assign
id|tolower
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|error
c_func
(paren
l_string|&quot;invalid key (newline): %s&quot;
comma
id|key
)paren
suffix:semicolon
r_goto
id|out_free_ret_1
suffix:semicolon
)brace
(paren
op_star
id|store_key
)paren
(braket
id|i
)braket
op_assign
id|c
suffix:semicolon
)brace
(paren
op_star
id|store_key
)paren
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_free_ret_1
suffix:colon
id|free
c_func
(paren
op_star
id|store_key
)paren
suffix:semicolon
op_star
id|store_key
op_assign
l_int|NULL
suffix:semicolon
r_return
id|CONFIG_INVALID_KEY
suffix:semicolon
)brace
multiline_comment|/*&n; * If value==NULL, unset in (remove from) config,&n; * if value_regex!=NULL, disregard key/value pairs where value does not match.&n; * if multi_replace==0, nothing, or only one matching key/value is replaced,&n; *     else all matching key/values (regardless how many) are removed,&n; *     before the new pair is written.&n; *&n; * Returns 0 on success.&n; *&n; * This function does this:&n; *&n; * - it locks the config file by creating &quot;.git/config.lock&quot;&n; *&n; * - it then parses the config using store_aux() as validator to find&n; *   the position on the key/value pair to replace. If it is to be unset,&n; *   it must be found exactly once.&n; *&n; * - the config file is mmap()ed and the part before the match (if any) is&n; *   written to the lock file, then the changed part and the rest.&n; *&n; * - the config file is removed and the lock file rename()d to it.&n; *&n; */
DECL|function|git_config_set_multivar_in_file
r_int
id|git_config_set_multivar_in_file
c_func
(paren
r_const
r_char
op_star
id|config_filename
comma
r_const
r_char
op_star
id|key
comma
r_const
r_char
op_star
id|value
comma
r_const
r_char
op_star
id|value_regex
comma
r_int
id|multi_replace
)paren
(brace
r_int
id|fd
op_assign
l_int|1
comma
id|in_fd
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_struct
id|lock_file
op_star
id|lock
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
id|filename_buf
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* parse-key returns negative; flip the sign to feed exit(3) */
id|ret
op_assign
l_int|0
id|git_config_parse_key
c_func
(paren
id|key
comma
op_amp
id|store.key
comma
op_amp
id|store.baselen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out_free
suffix:semicolon
id|store.multi_replace
op_assign
id|multi_replace
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|config_filename
)paren
id|config_filename
op_assign
id|filename_buf
op_assign
id|git_pathdup
c_func
(paren
l_string|&quot;config&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The lock serves a purpose in addition to locking: the new&n;&t; * contents of .git/config will be written into it.&n;&t; */
id|lock
op_assign
id|xcalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|lock_file
)paren
comma
l_int|1
)paren
suffix:semicolon
id|fd
op_assign
id|hold_lock_file_for_update
c_func
(paren
id|lock
comma
id|config_filename
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
(brace
id|error
c_func
(paren
l_string|&quot;could not lock config file %s: %s&quot;
comma
id|config_filename
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
id|free
c_func
(paren
id|store.key
)paren
suffix:semicolon
id|ret
op_assign
id|CONFIG_NO_LOCK
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If .git/config does not exist yet, write a minimal version.&n;&t; */
id|in_fd
op_assign
id|open
c_func
(paren
id|config_filename
comma
id|O_RDONLY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in_fd
OL
l_int|0
)paren
(brace
id|free
c_func
(paren
id|store.key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ENOENT
op_ne
id|errno
)paren
(brace
id|error
c_func
(paren
l_string|&quot;opening %s: %s&quot;
comma
id|config_filename
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|CONFIG_INVALID_FILE
suffix:semicolon
multiline_comment|/* same as &quot;invalid config file&quot; */
r_goto
id|out_free
suffix:semicolon
)brace
multiline_comment|/* if nothing to unset, error out */
r_if
c_cond
(paren
id|value
op_eq
l_int|NULL
)paren
(brace
id|ret
op_assign
id|CONFIG_NOTHING_SET
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
id|store.key
op_assign
(paren
r_char
op_star
)paren
id|key
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|store_write_section
c_func
(paren
id|fd
comma
id|key
)paren
op_logical_or
op_logical_neg
id|store_write_pair
c_func
(paren
id|fd
comma
id|key
comma
id|value
)paren
)paren
r_goto
id|write_err_out
suffix:semicolon
)brace
r_else
(brace
r_struct
id|stat
id|st
suffix:semicolon
r_char
op_star
id|contents
suffix:semicolon
r_int
id|contents_sz
comma
id|copy_begin
comma
id|copy_end
suffix:semicolon
r_int
id|i
comma
id|new_line
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|value_regex
op_eq
l_int|NULL
)paren
id|store.value_regex
op_assign
l_int|NULL
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|value_regex
(braket
l_int|0
)braket
op_eq
l_char|&squot;!&squot;
)paren
(brace
id|store.do_not_match
op_assign
l_int|1
suffix:semicolon
id|value_regex
op_increment
suffix:semicolon
)brace
r_else
id|store.do_not_match
op_assign
l_int|0
suffix:semicolon
id|store.value_regex
op_assign
(paren
id|regex_t
op_star
)paren
id|xmalloc
c_func
(paren
r_sizeof
(paren
id|regex_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|regcomp
c_func
(paren
id|store.value_regex
comma
id|value_regex
comma
id|REG_EXTENDED
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;invalid pattern: %s&quot;
comma
id|value_regex
)paren
suffix:semicolon
id|free
c_func
(paren
id|store.value_regex
)paren
suffix:semicolon
id|ret
op_assign
id|CONFIG_INVALID_PATTERN
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
)brace
id|store.offset
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|store.state
op_assign
id|START
suffix:semicolon
id|store.seen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * After this, store.offset will contain the *end* offset&n;&t;&t; * of the last match, or remain at 0 if no match was found.&n;&t;&t; * As a side effect, we make sure to transform only a valid&n;&t;&t; * existing config file.&n;&t;&t; */
r_if
c_cond
(paren
id|git_config_from_file
c_func
(paren
id|store_aux
comma
id|config_filename
comma
l_int|NULL
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;invalid config file %s&quot;
comma
id|config_filename
)paren
suffix:semicolon
id|free
c_func
(paren
id|store.key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|store.value_regex
op_ne
l_int|NULL
)paren
(brace
id|regfree
c_func
(paren
id|store.value_regex
)paren
suffix:semicolon
id|free
c_func
(paren
id|store.value_regex
)paren
suffix:semicolon
)brace
id|ret
op_assign
id|CONFIG_INVALID_FILE
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
id|free
c_func
(paren
id|store.key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|store.value_regex
op_ne
l_int|NULL
)paren
(brace
id|regfree
c_func
(paren
id|store.value_regex
)paren
suffix:semicolon
id|free
c_func
(paren
id|store.value_regex
)paren
suffix:semicolon
)brace
multiline_comment|/* if nothing to unset, or too many matches, error out */
r_if
c_cond
(paren
(paren
id|store.seen
op_eq
l_int|0
op_logical_and
id|value
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|store.seen
OG
l_int|1
op_logical_and
id|multi_replace
op_eq
l_int|0
)paren
)paren
(brace
id|ret
op_assign
id|CONFIG_NOTHING_SET
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
id|fstat
c_func
(paren
id|in_fd
comma
op_amp
id|st
)paren
suffix:semicolon
id|contents_sz
op_assign
id|xsize_t
c_func
(paren
id|st.st_size
)paren
suffix:semicolon
id|contents
op_assign
id|xmmap
c_func
(paren
l_int|NULL
comma
id|contents_sz
comma
id|PROT_READ
comma
id|MAP_PRIVATE
comma
id|in_fd
comma
l_int|0
)paren
suffix:semicolon
id|close
c_func
(paren
id|in_fd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|store.seen
op_eq
l_int|0
)paren
id|store.seen
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|copy_begin
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|store.seen
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|store.offset
(braket
id|i
)braket
op_eq
l_int|0
)paren
(brace
id|store.offset
(braket
id|i
)braket
op_assign
id|copy_end
op_assign
id|contents_sz
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|store.state
op_ne
id|KEY_SEEN
)paren
(brace
id|copy_end
op_assign
id|store.offset
(braket
id|i
)braket
suffix:semicolon
)brace
r_else
id|copy_end
op_assign
id|find_beginning_of_line
c_func
(paren
id|contents
comma
id|contents_sz
comma
id|store.offset
(braket
id|i
)braket
l_int|2
comma
op_amp
id|new_line
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_end
OG
l_int|0
op_logical_and
id|contents
(braket
id|copy_end
op_minus
l_int|1
)braket
op_ne
l_char|&squot;&bslash;n&squot;
)paren
id|new_line
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* write the first part of the config */
r_if
c_cond
(paren
id|copy_end
OG
id|copy_begin
)paren
(brace
r_if
c_cond
(paren
id|write_in_full
c_func
(paren
id|fd
comma
id|contents
op_plus
id|copy_begin
comma
id|copy_end
id|copy_begin
)paren
OL
id|copy_end
id|copy_begin
)paren
r_goto
id|write_err_out
suffix:semicolon
r_if
c_cond
(paren
id|new_line
op_logical_and
id|write_str_in_full
c_func
(paren
id|fd
comma
l_string|&quot;&bslash;n&quot;
)paren
op_ne
l_int|1
)paren
r_goto
id|write_err_out
suffix:semicolon
)brace
id|copy_begin
op_assign
id|store.offset
(braket
id|i
)braket
suffix:semicolon
)brace
multiline_comment|/* write the pair (value == NULL means unset) */
r_if
c_cond
(paren
id|value
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|store.state
op_eq
id|START
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|store_write_section
c_func
(paren
id|fd
comma
id|key
)paren
)paren
r_goto
id|write_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|store_write_pair
c_func
(paren
id|fd
comma
id|key
comma
id|value
)paren
)paren
r_goto
id|write_err_out
suffix:semicolon
)brace
multiline_comment|/* write the rest of the config */
r_if
c_cond
(paren
id|copy_begin
OL
id|contents_sz
)paren
r_if
c_cond
(paren
id|write_in_full
c_func
(paren
id|fd
comma
id|contents
op_plus
id|copy_begin
comma
id|contents_sz
id|copy_begin
)paren
OL
id|contents_sz
id|copy_begin
)paren
r_goto
id|write_err_out
suffix:semicolon
id|munmap
c_func
(paren
id|contents
comma
id|contents_sz
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|commit_lock_file
c_func
(paren
id|lock
)paren
OL
l_int|0
)paren
(brace
id|error
c_func
(paren
l_string|&quot;could not commit config file %s&quot;
comma
id|config_filename
)paren
suffix:semicolon
id|ret
op_assign
id|CONFIG_NO_WRITE
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * lock is committed, so don&squot;t try to roll it back below.&n;&t; * NOTE: Since lockfile.c keeps a linked list of all created&n;&t; * lock_file structures, it isn&squot;t safe to free(lock).  It&squot;s&n;&t; * better to just leave it hanging around.&n;&t; */
id|lock
op_assign
l_int|NULL
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
id|out_free
suffix:colon
r_if
c_cond
(paren
id|lock
)paren
id|rollback_lock_file
c_func
(paren
id|lock
)paren
suffix:semicolon
id|free
c_func
(paren
id|filename_buf
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
id|write_err_out
suffix:colon
id|ret
op_assign
id|write_error
c_func
(paren
id|lock-&gt;filename
)paren
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
DECL|function|git_config_set_multivar
r_int
id|git_config_set_multivar
c_func
(paren
r_const
r_char
op_star
id|key
comma
r_const
r_char
op_star
id|value
comma
r_const
r_char
op_star
id|value_regex
comma
r_int
id|multi_replace
)paren
(brace
r_return
id|git_config_set_multivar_in_file
c_func
(paren
l_int|NULL
comma
id|key
comma
id|value
comma
id|value_regex
comma
id|multi_replace
)paren
suffix:semicolon
)brace
DECL|function|section_name_match
r_static
r_int
id|section_name_match
(paren
r_const
r_char
op_star
id|buf
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_int
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
comma
id|dot
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|buf
(braket
id|i
)braket
op_ne
l_char|&squot;[&squot;
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|buf
(braket
id|i
)braket
op_logical_and
id|buf
(braket
id|i
)braket
op_ne
l_char|&squot;]&squot;
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dot
op_logical_and
id|isspace
c_func
(paren
id|buf
(braket
id|i
)braket
)paren
)paren
(brace
id|dot
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|name
(braket
id|j
op_increment
)braket
op_ne
l_char|&squot;.&squot;
)paren
r_break
suffix:semicolon
r_for
c_loop
(paren
id|i
op_increment
suffix:semicolon
id|isspace
c_func
(paren
id|buf
(braket
id|i
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
suffix:semicolon
multiline_comment|/* do nothing */
r_if
c_cond
(paren
id|buf
(braket
id|i
)braket
op_ne
l_char|&squot;&quot;&squot;
)paren
r_break
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buf
(braket
id|i
)braket
op_eq
l_char|&squot;&bslash;&bslash;&squot;
op_logical_and
id|dot
)paren
id|i
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|buf
(braket
id|i
)braket
op_eq
l_char|&squot;&quot;&squot;
op_logical_and
id|dot
)paren
(brace
r_for
c_loop
(paren
id|i
op_increment
suffix:semicolon
id|isspace
c_func
(paren
id|buf
(braket
id|i
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
suffix:semicolon
multiline_comment|/* do_nothing */
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buf
(braket
id|i
)braket
op_ne
id|name
(braket
id|j
op_increment
)braket
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buf
(braket
id|i
)braket
op_eq
l_char|&squot;]&squot;
op_logical_and
id|name
(braket
id|j
)braket
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * We match, now just find the right length offset by&n;&t;&t; * gobbling up any whitespace after it, as well&n;&t;&t; */
id|i
op_increment
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|buf
(braket
id|i
)braket
op_logical_and
id|isspace
c_func
(paren
id|buf
(braket
id|i
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
suffix:semicolon
multiline_comment|/* do nothing */
r_return
id|i
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|section_name_is_ok
r_static
r_int
id|section_name_is_ok
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
multiline_comment|/* Empty section names are bogus. */
r_if
c_cond
(paren
op_logical_neg
op_star
id|name
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Before a dot, we must be alphanumeric or dash. After the first dot,&n;&t; * anything goes, so we can stop checking.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
op_star
id|name
op_logical_and
op_star
id|name
op_ne
l_char|&squot;.&squot;
suffix:semicolon
id|name
op_increment
)paren
r_if
c_cond
(paren
op_star
id|name
op_ne
l_char|&squot;-&squot;
op_logical_and
op_logical_neg
id|isalnum
c_func
(paren
op_star
id|name
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* if new_name == NULL, the section is removed instead */
DECL|function|git_config_rename_section_in_file
r_int
id|git_config_rename_section_in_file
c_func
(paren
r_const
r_char
op_star
id|config_filename
comma
r_const
r_char
op_star
id|old_name
comma
r_const
r_char
op_star
id|new_name
)paren
(brace
r_int
id|ret
op_assign
l_int|0
comma
id|remove
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|filename_buf
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|lock_file
op_star
id|lock
suffix:semicolon
r_int
id|out_fd
suffix:semicolon
r_char
id|buf
(braket
l_int|1024
)braket
suffix:semicolon
id|FILE
op_star
id|config_file
suffix:semicolon
r_if
c_cond
(paren
id|new_name
op_logical_and
op_logical_neg
id|section_name_is_ok
c_func
(paren
id|new_name
)paren
)paren
(brace
id|ret
op_assign
id|error
c_func
(paren
l_string|&quot;invalid section name: %s&quot;
comma
id|new_name
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|config_filename
)paren
id|config_filename
op_assign
id|filename_buf
op_assign
id|git_pathdup
c_func
(paren
l_string|&quot;config&quot;
)paren
suffix:semicolon
id|lock
op_assign
id|xcalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|lock_file
)paren
comma
l_int|1
)paren
suffix:semicolon
id|out_fd
op_assign
id|hold_lock_file_for_update
c_func
(paren
id|lock
comma
id|config_filename
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|out_fd
OL
l_int|0
)paren
(brace
id|ret
op_assign
id|error
c_func
(paren
l_string|&quot;could not lock config file %s&quot;
comma
id|config_filename
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|config_file
op_assign
id|fopen
c_func
(paren
id|config_filename
comma
l_string|&quot;rb&quot;
)paren
)paren
)paren
(brace
multiline_comment|/* no config file means nothing to rename, no error */
r_goto
id|unlock_and_out
suffix:semicolon
)brace
r_while
c_loop
(paren
id|fgets
c_func
(paren
id|buf
comma
r_sizeof
(paren
id|buf
)paren
comma
id|config_file
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|length
suffix:semicolon
r_char
op_star
id|output
op_assign
id|buf
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|buf
(braket
id|i
)braket
op_logical_and
id|isspace
c_func
(paren
id|buf
(braket
id|i
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
suffix:semicolon
multiline_comment|/* do nothing */
r_if
c_cond
(paren
id|buf
(braket
id|i
)braket
op_eq
l_char|&squot;[&squot;
)paren
(brace
multiline_comment|/* it&squot;s a section */
r_int
id|offset
op_assign
id|section_name_match
c_func
(paren
op_amp
id|buf
(braket
id|i
)braket
comma
id|old_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
OG
l_int|0
)paren
(brace
id|ret
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|new_name
op_eq
l_int|NULL
)paren
(brace
id|remove
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|store.baselen
op_assign
id|strlen
c_func
(paren
id|new_name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|store_write_section
c_func
(paren
id|out_fd
comma
id|new_name
)paren
)paren
(brace
id|ret
op_assign
id|write_error
c_func
(paren
id|lock-&gt;filename
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * We wrote out the new section, with&n;&t;&t;&t;&t; * a newline, now skip the old&n;&t;&t;&t;&t; * section&squot;s length&n;&t;&t;&t;&t; */
id|output
op_add_assign
id|offset
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
id|strlen
c_func
(paren
id|output
)paren
OG
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * More content means there&squot;s&n;&t;&t;&t;&t;&t; * a declaration to put on the&n;&t;&t;&t;&t;&t; * next line; indent with a&n;&t;&t;&t;&t;&t; * tab&n;&t;&t;&t;&t;&t; */
id|output
op_sub_assign
l_int|1
suffix:semicolon
id|output
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;t&squot;
suffix:semicolon
)brace
)brace
id|remove
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|remove
)paren
r_continue
suffix:semicolon
id|length
op_assign
id|strlen
c_func
(paren
id|output
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write_in_full
c_func
(paren
id|out_fd
comma
id|output
comma
id|length
)paren
op_ne
id|length
)paren
(brace
id|ret
op_assign
id|write_error
c_func
(paren
id|lock-&gt;filename
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
id|fclose
c_func
(paren
id|config_file
)paren
suffix:semicolon
id|unlock_and_out
suffix:colon
r_if
c_cond
(paren
id|commit_lock_file
c_func
(paren
id|lock
)paren
OL
l_int|0
)paren
id|ret
op_assign
id|error
c_func
(paren
l_string|&quot;could not commit config file %s&quot;
comma
id|config_filename
)paren
suffix:semicolon
id|out
suffix:colon
id|free
c_func
(paren
id|filename_buf
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|git_config_rename_section
r_int
id|git_config_rename_section
c_func
(paren
r_const
r_char
op_star
id|old_name
comma
r_const
r_char
op_star
id|new_name
)paren
(brace
r_return
id|git_config_rename_section_in_file
c_func
(paren
l_int|NULL
comma
id|old_name
comma
id|new_name
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Call this to report error for your variable that should not&n; * get a boolean value (i.e. &quot;[my] var&quot; means &quot;true&quot;).&n; */
DECL|macro|config_error_nonbool
macro_line|#undef config_error_nonbool
DECL|function|config_error_nonbool
r_int
id|config_error_nonbool
c_func
(paren
r_const
r_char
op_star
id|var
)paren
(brace
r_return
id|error
c_func
(paren
l_string|&quot;Missing value for &squot;%s&squot;&quot;
comma
id|var
)paren
suffix:semicolon
)brace
DECL|function|parse_config_key
r_int
id|parse_config_key
c_func
(paren
r_const
r_char
op_star
id|var
comma
r_const
r_char
op_star
id|section
comma
r_const
r_char
op_star
op_star
id|subsection
comma
r_int
op_star
id|subsection_len
comma
r_const
r_char
op_star
op_star
id|key
)paren
(brace
r_int
id|section_len
op_assign
id|strlen
c_func
(paren
id|section
)paren
suffix:semicolon
r_const
r_char
op_star
id|dot
suffix:semicolon
multiline_comment|/* Does it start with &quot;section.&quot; ? */
r_if
c_cond
(paren
id|prefixcmp
c_func
(paren
id|var
comma
id|section
)paren
op_logical_or
id|var
(braket
id|section_len
)braket
op_ne
l_char|&squot;.&squot;
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Find the key; we don&squot;t know yet if we have a subsection, but we must&n;&t; * parse backwards from the end, since the subsection may have dots in&n;&t; * it, too.&n;&t; */
id|dot
op_assign
id|strrchr
c_func
(paren
id|var
comma
l_char|&squot;.&squot;
)paren
suffix:semicolon
op_star
id|key
op_assign
id|dot
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Did we have a subsection at all? */
r_if
c_cond
(paren
id|dot
op_eq
id|var
op_plus
id|section_len
)paren
(brace
op_star
id|subsection
op_assign
l_int|NULL
suffix:semicolon
op_star
id|subsection_len
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
op_star
id|subsection
op_assign
id|var
op_plus
id|section_len
op_plus
l_int|1
suffix:semicolon
op_star
id|subsection_len
op_assign
id|dot
op_star
id|subsection
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
