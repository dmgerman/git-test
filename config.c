multiline_comment|/*&n; * GIT - The information manager from hell&n; *&n; * Copyright (C) Linus Torvalds, 2005&n; * Copyright (C) Johannes Schindelin, 2005&n; *&n; */
macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;exec_cmd.h&quot;
macro_line|#include &quot;strbuf.h&quot;
macro_line|#include &quot;quote.h&quot;
DECL|macro|MAXNAME
mdefine_line|#define MAXNAME (256)
DECL|variable|config_file
r_static
id|FILE
op_star
id|config_file
suffix:semicolon
DECL|variable|config_file_name
r_static
r_const
r_char
op_star
id|config_file_name
suffix:semicolon
DECL|variable|config_linenr
r_static
r_int
id|config_linenr
suffix:semicolon
DECL|variable|config_file_eof
r_static
r_int
id|config_file_eof
suffix:semicolon
DECL|variable|zlib_compression_seen
r_static
r_int
id|zlib_compression_seen
suffix:semicolon
DECL|variable|config_exclusive_filename
r_const
r_char
op_star
id|config_exclusive_filename
op_assign
l_int|NULL
suffix:semicolon
DECL|function|lowercase
r_static
r_void
id|lowercase
c_func
(paren
r_char
op_star
id|p
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
op_star
id|p
suffix:semicolon
id|p
op_increment
)paren
op_star
id|p
op_assign
id|tolower
c_func
(paren
op_star
id|p
)paren
suffix:semicolon
)brace
DECL|function|git_config_push_parameter
r_void
id|git_config_push_parameter
c_func
(paren
r_const
r_char
op_star
id|text
)paren
(brace
r_struct
id|strbuf
id|env
op_assign
id|STRBUF_INIT
suffix:semicolon
r_const
r_char
op_star
id|old
op_assign
id|getenv
c_func
(paren
id|CONFIG_DATA_ENVIRONMENT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old
)paren
(brace
id|strbuf_addstr
c_func
(paren
op_amp
id|env
comma
id|old
)paren
suffix:semicolon
id|strbuf_addch
c_func
(paren
op_amp
id|env
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
)brace
id|sq_quote_buf
c_func
(paren
op_amp
id|env
comma
id|text
)paren
suffix:semicolon
id|setenv
c_func
(paren
id|CONFIG_DATA_ENVIRONMENT
comma
id|env.buf
comma
l_int|1
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|env
)paren
suffix:semicolon
)brace
DECL|function|git_config_parse_parameter
r_static
r_int
id|git_config_parse_parameter
c_func
(paren
r_const
r_char
op_star
id|text
comma
id|config_fn_t
id|fn
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|strbuf
id|tmp
op_assign
id|STRBUF_INIT
suffix:semicolon
r_struct
id|strbuf
op_star
op_star
id|pair
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|tmp
comma
id|text
)paren
suffix:semicolon
id|pair
op_assign
id|strbuf_split_max
c_func
(paren
op_amp
id|tmp
comma
l_char|&squot;=&squot;
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pair
(braket
l_int|0
)braket
)paren
r_return
id|error
c_func
(paren
l_string|&quot;bogus config parameter: %s&quot;
comma
id|text
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pair
(braket
l_int|0
)braket
op_member_access_from_pointer
id|len
op_logical_and
id|pair
(braket
l_int|0
)braket
op_member_access_from_pointer
id|buf
(braket
id|pair
(braket
l_int|0
)braket
op_member_access_from_pointer
id|len
l_int|1
)braket
op_eq
l_char|&squot;=&squot;
)paren
id|strbuf_setlen
c_func
(paren
id|pair
(braket
l_int|0
)braket
comma
id|pair
(braket
l_int|0
)braket
op_member_access_from_pointer
id|len
l_int|1
)paren
suffix:semicolon
id|strbuf_trim
c_func
(paren
id|pair
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pair
(braket
l_int|0
)braket
op_member_access_from_pointer
id|len
)paren
(brace
id|strbuf_list_free
c_func
(paren
id|pair
)paren
suffix:semicolon
r_return
id|error
c_func
(paren
l_string|&quot;bogus config parameter: %s&quot;
comma
id|text
)paren
suffix:semicolon
)brace
id|lowercase
c_func
(paren
id|pair
(braket
l_int|0
)braket
op_member_access_from_pointer
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fn
c_func
(paren
id|pair
(braket
l_int|0
)braket
op_member_access_from_pointer
id|buf
comma
id|pair
(braket
l_int|1
)braket
ques
c_cond
id|pair
(braket
l_int|1
)braket
op_member_access_from_pointer
id|buf
suffix:colon
l_int|NULL
comma
id|data
)paren
OL
l_int|0
)paren
(brace
id|strbuf_list_free
c_func
(paren
id|pair
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|strbuf_list_free
c_func
(paren
id|pair
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|git_config_from_parameters
r_int
id|git_config_from_parameters
c_func
(paren
id|config_fn_t
id|fn
comma
r_void
op_star
id|data
)paren
(brace
r_const
r_char
op_star
id|env
op_assign
id|getenv
c_func
(paren
id|CONFIG_DATA_ENVIRONMENT
)paren
suffix:semicolon
r_char
op_star
id|envw
suffix:semicolon
r_const
r_char
op_star
op_star
id|argv
op_assign
l_int|NULL
suffix:semicolon
r_int
id|nr
op_assign
l_int|0
comma
id|alloc
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|env
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* sq_dequote will write over it */
id|envw
op_assign
id|xstrdup
c_func
(paren
id|env
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sq_dequote_to_argv
c_func
(paren
id|envw
comma
op_amp
id|argv
comma
op_amp
id|nr
comma
op_amp
id|alloc
)paren
OL
l_int|0
)paren
(brace
id|free
c_func
(paren
id|envw
)paren
suffix:semicolon
r_return
id|error
c_func
(paren
l_string|&quot;bogus format in &quot;
id|CONFIG_DATA_ENVIRONMENT
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|git_config_parse_parameter
c_func
(paren
id|argv
(braket
id|i
)braket
comma
id|fn
comma
id|data
)paren
OL
l_int|0
)paren
(brace
id|free
c_func
(paren
id|argv
)paren
suffix:semicolon
id|free
c_func
(paren
id|envw
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
id|free
c_func
(paren
id|argv
)paren
suffix:semicolon
id|free
c_func
(paren
id|envw
)paren
suffix:semicolon
r_return
id|nr
OG
l_int|0
suffix:semicolon
)brace
DECL|function|get_next_char
r_static
r_int
id|get_next_char
c_func
(paren
r_void
)paren
(brace
r_int
id|c
suffix:semicolon
id|FILE
op_star
id|f
suffix:semicolon
id|c
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
r_if
c_cond
(paren
(paren
id|f
op_assign
id|config_file
)paren
op_ne
l_int|NULL
)paren
(brace
id|c
op_assign
id|fgetc
c_func
(paren
id|f
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;r&squot;
)paren
(brace
multiline_comment|/* DOS like systems */
id|c
op_assign
id|fgetc
c_func
(paren
id|f
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|ungetc
c_func
(paren
id|c
comma
id|f
)paren
suffix:semicolon
id|c
op_assign
l_char|&squot;&bslash;r&squot;
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|config_linenr
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
id|EOF
)paren
(brace
id|config_file_eof
op_assign
l_int|1
suffix:semicolon
id|c
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
)brace
)brace
r_return
id|c
suffix:semicolon
)brace
DECL|function|parse_value
r_static
r_char
op_star
id|parse_value
c_func
(paren
r_void
)paren
(brace
r_static
r_char
id|value
(braket
l_int|1024
)braket
suffix:semicolon
r_int
id|quote
op_assign
l_int|0
comma
id|comment
op_assign
l_int|0
comma
id|len
op_assign
l_int|0
comma
id|space
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|c
op_assign
id|get_next_char
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ge
r_sizeof
(paren
id|value
)paren
l_int|1
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
r_if
c_cond
(paren
id|quote
)paren
r_return
l_int|NULL
suffix:semicolon
id|value
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
r_return
id|value
suffix:semicolon
)brace
r_if
c_cond
(paren
id|comment
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|isspace
c_func
(paren
id|c
)paren
op_logical_and
op_logical_neg
id|quote
)paren
(brace
r_if
c_cond
(paren
id|len
)paren
id|space
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|quote
)paren
(brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;;&squot;
op_logical_or
id|c
op_eq
l_char|&squot;#&squot;
)paren
(brace
id|comment
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
suffix:semicolon
id|space
suffix:semicolon
id|space
op_decrement
)paren
id|value
(braket
id|len
op_increment
)braket
op_assign
l_char|&squot; &squot;
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;&bslash;&squot;
)paren
(brace
id|c
op_assign
id|get_next_char
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
l_char|&squot;&bslash;n&squot;
suffix:colon
r_continue
suffix:semicolon
r_case
l_char|&squot;t&squot;
suffix:colon
id|c
op_assign
l_char|&squot;&bslash;t&squot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;b&squot;
suffix:colon
id|c
op_assign
l_char|&squot;&bslash;b&squot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;n&squot;
suffix:colon
id|c
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Some characters escape as themselves */
r_case
l_char|&squot;&bslash;&bslash;&squot;
suffix:colon
r_case
l_char|&squot;&quot;&squot;
suffix:colon
r_break
suffix:semicolon
multiline_comment|/* Reject unknown escape sequences */
r_default
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
id|value
(braket
id|len
op_increment
)braket
op_assign
id|c
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&quot;&squot;
)paren
(brace
id|quote
op_assign
l_int|1
op_minus
id|quote
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|value
(braket
id|len
op_increment
)braket
op_assign
id|c
suffix:semicolon
)brace
)brace
DECL|function|iskeychar
r_static
r_inline
r_int
id|iskeychar
c_func
(paren
r_int
id|c
)paren
(brace
r_return
id|isalnum
c_func
(paren
id|c
)paren
op_logical_or
id|c
op_eq
l_char|&squot;-&squot;
suffix:semicolon
)brace
DECL|function|get_value
r_static
r_int
id|get_value
c_func
(paren
id|config_fn_t
id|fn
comma
r_void
op_star
id|data
comma
r_char
op_star
id|name
comma
r_int
r_int
id|len
)paren
(brace
r_int
id|c
suffix:semicolon
r_char
op_star
id|value
suffix:semicolon
multiline_comment|/* Get the full name */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|c
op_assign
id|get_next_char
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|config_file_eof
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|iskeychar
c_func
(paren
id|c
)paren
)paren
r_break
suffix:semicolon
id|name
(braket
id|len
op_increment
)braket
op_assign
id|tolower
c_func
(paren
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ge
id|MAXNAME
)paren
r_return
l_int|1
suffix:semicolon
)brace
id|name
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|c
op_eq
l_char|&squot; &squot;
op_logical_or
id|c
op_eq
l_char|&squot;&bslash;t&squot;
)paren
id|c
op_assign
id|get_next_char
c_func
(paren
)paren
suffix:semicolon
id|value
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|c
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
r_if
c_cond
(paren
id|c
op_ne
l_char|&squot;=&squot;
)paren
r_return
l_int|1
suffix:semicolon
id|value
op_assign
id|parse_value
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
id|fn
c_func
(paren
id|name
comma
id|value
comma
id|data
)paren
suffix:semicolon
)brace
DECL|function|get_extended_base_var
r_static
r_int
id|get_extended_base_var
c_func
(paren
r_char
op_star
id|name
comma
r_int
id|baselen
comma
r_int
id|c
)paren
(brace
r_do
(brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
r_return
l_int|1
suffix:semicolon
id|c
op_assign
id|get_next_char
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|isspace
c_func
(paren
id|c
)paren
)paren
suffix:semicolon
multiline_comment|/* We require the format to be &squot;[base &quot;extension&quot;]&squot; */
r_if
c_cond
(paren
id|c
op_ne
l_char|&squot;&quot;&squot;
)paren
r_return
l_int|1
suffix:semicolon
id|name
(braket
id|baselen
op_increment
)braket
op_assign
l_char|&squot;.&squot;
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|c
op_assign
id|get_next_char
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&quot;&squot;
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;&bslash;&squot;
)paren
(brace
id|c
op_assign
id|get_next_char
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
r_return
l_int|1
suffix:semicolon
)brace
id|name
(braket
id|baselen
op_increment
)braket
op_assign
id|c
suffix:semicolon
r_if
c_cond
(paren
id|baselen
OG
id|MAXNAME
op_div
l_int|2
)paren
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Final &squot;]&squot; */
r_if
c_cond
(paren
id|get_next_char
c_func
(paren
)paren
op_ne
l_char|&squot;]&squot;
)paren
r_return
l_int|1
suffix:semicolon
r_return
id|baselen
suffix:semicolon
)brace
DECL|function|get_base_var
r_static
r_int
id|get_base_var
c_func
(paren
r_char
op_star
id|name
)paren
(brace
r_int
id|baselen
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|c
op_assign
id|get_next_char
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|config_file_eof
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;]&squot;
)paren
r_return
id|baselen
suffix:semicolon
r_if
c_cond
(paren
id|isspace
c_func
(paren
id|c
)paren
)paren
r_return
id|get_extended_base_var
c_func
(paren
id|name
comma
id|baselen
comma
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|iskeychar
c_func
(paren
id|c
)paren
op_logical_and
id|c
op_ne
l_char|&squot;.&squot;
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|baselen
OG
id|MAXNAME
op_div
l_int|2
)paren
r_return
l_int|1
suffix:semicolon
id|name
(braket
id|baselen
op_increment
)braket
op_assign
id|tolower
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
)brace
DECL|function|git_parse_file
r_static
r_int
id|git_parse_file
c_func
(paren
id|config_fn_t
id|fn
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|comment
op_assign
l_int|0
suffix:semicolon
r_int
id|baselen
op_assign
l_int|0
suffix:semicolon
r_static
r_char
id|var
(braket
id|MAXNAME
)braket
suffix:semicolon
multiline_comment|/* U+FEFF Byte Order Mark in UTF8 */
r_static
r_const
r_int
r_char
op_star
id|utf8_bom
op_assign
(paren
r_int
r_char
op_star
)paren
l_string|&quot;&bslash;xef&bslash;xbb&bslash;xbf&quot;
suffix:semicolon
r_const
r_int
r_char
op_star
id|bomptr
op_assign
id|utf8_bom
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|c
op_assign
id|get_next_char
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bomptr
op_logical_and
op_star
id|bomptr
)paren
(brace
multiline_comment|/* We are at the file beginning; skip UTF8-encoded BOM&n;&t;&t;&t; * if present. Sane editors won&squot;t put this in on their&n;&t;&t;&t; * own, but e.g. Windows Notepad will do it happily. */
r_if
c_cond
(paren
(paren
r_int
r_char
)paren
id|c
op_eq
op_star
id|bomptr
)paren
(brace
id|bomptr
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Do not tolerate partial BOM. */
r_if
c_cond
(paren
id|bomptr
op_ne
id|utf8_bom
)paren
r_break
suffix:semicolon
multiline_comment|/* No BOM at file beginning. Cool. */
id|bomptr
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
r_if
c_cond
(paren
id|config_file_eof
)paren
r_return
l_int|0
suffix:semicolon
id|comment
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|comment
op_logical_or
id|isspace
c_func
(paren
id|c
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;#&squot;
op_logical_or
id|c
op_eq
l_char|&squot;;&squot;
)paren
(brace
id|comment
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;[&squot;
)paren
(brace
id|baselen
op_assign
id|get_base_var
c_func
(paren
id|var
)paren
suffix:semicolon
r_if
c_cond
(paren
id|baselen
op_le
l_int|0
)paren
r_break
suffix:semicolon
id|var
(braket
id|baselen
op_increment
)braket
op_assign
l_char|&squot;.&squot;
suffix:semicolon
id|var
(braket
id|baselen
)braket
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|isalpha
c_func
(paren
id|c
)paren
)paren
r_break
suffix:semicolon
id|var
(braket
id|baselen
)braket
op_assign
id|tolower
c_func
(paren
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_value
c_func
(paren
id|fn
comma
id|data
comma
id|var
comma
id|baselen
op_plus
l_int|1
)paren
OL
l_int|0
)paren
r_break
suffix:semicolon
)brace
id|die
c_func
(paren
l_string|&quot;bad config file line %d in %s&quot;
comma
id|config_linenr
comma
id|config_file_name
)paren
suffix:semicolon
)brace
DECL|function|parse_unit_factor
r_static
r_int
id|parse_unit_factor
c_func
(paren
r_const
r_char
op_star
id|end
comma
r_int
r_int
op_star
id|val
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|end
)paren
r_return
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcasecmp
c_func
(paren
id|end
comma
l_string|&quot;k&quot;
)paren
)paren
(brace
op_star
id|val
op_mul_assign
l_int|1024
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcasecmp
c_func
(paren
id|end
comma
l_string|&quot;m&quot;
)paren
)paren
(brace
op_star
id|val
op_mul_assign
l_int|1024
op_star
l_int|1024
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcasecmp
c_func
(paren
id|end
comma
l_string|&quot;g&quot;
)paren
)paren
(brace
op_star
id|val
op_mul_assign
l_int|1024
op_star
l_int|1024
op_star
l_int|1024
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|git_parse_long
r_static
r_int
id|git_parse_long
c_func
(paren
r_const
r_char
op_star
id|value
comma
r_int
op_star
id|ret
)paren
(brace
r_if
c_cond
(paren
id|value
op_logical_and
op_star
id|value
)paren
(brace
r_char
op_star
id|end
suffix:semicolon
r_int
id|val
op_assign
id|strtol
c_func
(paren
id|value
comma
op_amp
id|end
comma
l_int|0
)paren
suffix:semicolon
r_int
r_int
id|factor
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parse_unit_factor
c_func
(paren
id|end
comma
op_amp
id|factor
)paren
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|ret
op_assign
id|val
op_star
id|factor
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|git_parse_ulong
r_int
id|git_parse_ulong
c_func
(paren
r_const
r_char
op_star
id|value
comma
r_int
r_int
op_star
id|ret
)paren
(brace
r_if
c_cond
(paren
id|value
op_logical_and
op_star
id|value
)paren
(brace
r_char
op_star
id|end
suffix:semicolon
r_int
r_int
id|val
op_assign
id|strtoul
c_func
(paren
id|value
comma
op_amp
id|end
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parse_unit_factor
c_func
(paren
id|end
comma
op_amp
id|val
)paren
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|ret
op_assign
id|val
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|die_bad_config
r_static
r_void
id|die_bad_config
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_if
c_cond
(paren
id|config_file_name
)paren
id|die
c_func
(paren
l_string|&quot;bad config value for &squot;%s&squot; in %s&quot;
comma
id|name
comma
id|config_file_name
)paren
suffix:semicolon
id|die
c_func
(paren
l_string|&quot;bad config value for &squot;%s&squot;&quot;
comma
id|name
)paren
suffix:semicolon
)brace
DECL|function|git_config_int
r_int
id|git_config_int
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|git_parse_long
c_func
(paren
id|value
comma
op_amp
id|ret
)paren
)paren
id|die_bad_config
c_func
(paren
id|name
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|git_config_ulong
r_int
r_int
id|git_config_ulong
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_int
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|git_parse_ulong
c_func
(paren
id|value
comma
op_amp
id|ret
)paren
)paren
id|die_bad_config
c_func
(paren
id|name
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|git_config_maybe_bool_text
r_static
r_int
id|git_config_maybe_bool_text
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|value
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;true&quot;
)paren
op_logical_or
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;yes&quot;
)paren
op_logical_or
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;on&quot;
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;false&quot;
)paren
op_logical_or
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;no&quot;
)paren
op_logical_or
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;off&quot;
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|git_config_maybe_bool
r_int
id|git_config_maybe_bool
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_int
id|v
op_assign
id|git_config_maybe_bool_text
c_func
(paren
id|name
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_le
id|v
)paren
r_return
id|v
suffix:semicolon
r_if
c_cond
(paren
id|git_parse_long
c_func
(paren
id|value
comma
op_amp
id|v
)paren
)paren
r_return
op_logical_neg
op_logical_neg
id|v
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|git_config_bool_or_int
r_int
id|git_config_bool_or_int
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_const
r_char
op_star
id|value
comma
r_int
op_star
id|is_bool
)paren
(brace
r_int
id|v
op_assign
id|git_config_maybe_bool_text
c_func
(paren
id|name
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_le
id|v
)paren
(brace
op_star
id|is_bool
op_assign
l_int|1
suffix:semicolon
r_return
id|v
suffix:semicolon
)brace
op_star
id|is_bool
op_assign
l_int|0
suffix:semicolon
r_return
id|git_config_int
c_func
(paren
id|name
comma
id|value
)paren
suffix:semicolon
)brace
DECL|function|git_config_bool
r_int
id|git_config_bool
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_int
id|discard
suffix:semicolon
r_return
op_logical_neg
op_logical_neg
id|git_config_bool_or_int
c_func
(paren
id|name
comma
id|value
comma
op_amp
id|discard
)paren
suffix:semicolon
)brace
DECL|function|git_config_string
r_int
id|git_config_string
c_func
(paren
r_const
r_char
op_star
op_star
id|dest
comma
r_const
r_char
op_star
id|var
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
r_return
id|config_error_nonbool
c_func
(paren
id|var
)paren
suffix:semicolon
op_star
id|dest
op_assign
id|xstrdup
c_func
(paren
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|git_config_pathname
r_int
id|git_config_pathname
c_func
(paren
r_const
r_char
op_star
op_star
id|dest
comma
r_const
r_char
op_star
id|var
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
r_return
id|config_error_nonbool
c_func
(paren
id|var
)paren
suffix:semicolon
op_star
id|dest
op_assign
id|expand_user_path
c_func
(paren
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|dest
)paren
id|die
c_func
(paren
l_string|&quot;Failed to expand user dir in: &squot;%s&squot;&quot;
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|git_default_core_config
r_static
r_int
id|git_default_core_config
c_func
(paren
r_const
r_char
op_star
id|var
comma
r_const
r_char
op_star
id|value
)paren
(brace
multiline_comment|/* This needs a better name */
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.filemode&quot;
)paren
)paren
(brace
id|trust_executable_bit
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.trustctime&quot;
)paren
)paren
(brace
id|trust_ctime
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.quotepath&quot;
)paren
)paren
(brace
id|quote_path_fully
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.symlinks&quot;
)paren
)paren
(brace
id|has_symlinks
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.ignorecase&quot;
)paren
)paren
(brace
id|ignore_case
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.bare&quot;
)paren
)paren
(brace
id|is_bare_repository_cfg
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.ignorestat&quot;
)paren
)paren
(brace
id|assume_unchanged
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.prefersymlinkrefs&quot;
)paren
)paren
(brace
id|prefer_symlink_refs
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.logallrefupdates&quot;
)paren
)paren
(brace
id|log_all_ref_updates
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.warnambiguousrefs&quot;
)paren
)paren
(brace
id|warn_ambiguous_refs
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.abbrev&quot;
)paren
)paren
(brace
r_int
id|abbrev
op_assign
id|git_config_int
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|abbrev
template_param
l_int|40
)paren
r_return
l_int|1
suffix:semicolon
id|default_abbrev
op_assign
id|abbrev
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.loosecompression&quot;
)paren
)paren
(brace
r_int
id|level
op_assign
id|git_config_int
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|level
op_eq
l_int|1
)paren
id|level
op_assign
id|Z_DEFAULT_COMPRESSION
suffix:semicolon
r_else
r_if
c_cond
(paren
id|level
template_param
id|Z_BEST_COMPRESSION
)paren
id|die
c_func
(paren
l_string|&quot;bad zlib compression level %d&quot;
comma
id|level
)paren
suffix:semicolon
id|zlib_compression_level
op_assign
id|level
suffix:semicolon
id|zlib_compression_seen
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.compression&quot;
)paren
)paren
(brace
r_int
id|level
op_assign
id|git_config_int
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|level
op_eq
l_int|1
)paren
id|level
op_assign
id|Z_DEFAULT_COMPRESSION
suffix:semicolon
r_else
r_if
c_cond
(paren
id|level
template_param
id|Z_BEST_COMPRESSION
)paren
id|die
c_func
(paren
l_string|&quot;bad zlib compression level %d&quot;
comma
id|level
)paren
suffix:semicolon
id|core_compression_level
op_assign
id|level
suffix:semicolon
id|core_compression_seen
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|zlib_compression_seen
)paren
id|zlib_compression_level
op_assign
id|level
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.packedgitwindowsize&quot;
)paren
)paren
(brace
r_int
id|pgsz_x2
op_assign
id|getpagesize
c_func
(paren
)paren
op_star
l_int|2
suffix:semicolon
id|packed_git_window_size
op_assign
id|git_config_int
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
multiline_comment|/* This value must be multiple of (pagesize * 2) */
id|packed_git_window_size
op_div_assign
id|pgsz_x2
suffix:semicolon
r_if
c_cond
(paren
id|packed_git_window_size
OL
l_int|1
)paren
id|packed_git_window_size
op_assign
l_int|1
suffix:semicolon
id|packed_git_window_size
op_mul_assign
id|pgsz_x2
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.bigfilethreshold&quot;
)paren
)paren
(brace
r_int
id|n
op_assign
id|git_config_int
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
id|big_file_threshold
op_assign
l_int|0
OL
id|n
ques
c_cond
id|n
suffix:colon
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.packedgitlimit&quot;
)paren
)paren
(brace
id|packed_git_limit
op_assign
id|git_config_int
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.deltabasecachelimit&quot;
)paren
)paren
(brace
id|delta_base_cache_limit
op_assign
id|git_config_int
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.autocrlf&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|value
op_logical_and
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;input&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|eol
op_eq
id|EOL_CRLF
)paren
r_return
id|error
c_func
(paren
l_string|&quot;core.autocrlf=input conflicts with core.eol=crlf&quot;
)paren
suffix:semicolon
id|auto_crlf
op_assign
id|AUTO_CRLF_INPUT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|auto_crlf
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.safecrlf&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|value
op_logical_and
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;warn&quot;
)paren
)paren
(brace
id|safe_crlf
op_assign
id|SAFE_CRLF_WARN
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|safe_crlf
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.eol&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|value
op_logical_and
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;lf&quot;
)paren
)paren
id|eol
op_assign
id|EOL_LF
suffix:semicolon
r_else
r_if
c_cond
(paren
id|value
op_logical_and
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;crlf&quot;
)paren
)paren
id|eol
op_assign
id|EOL_CRLF
suffix:semicolon
r_else
r_if
c_cond
(paren
id|value
op_logical_and
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;native&quot;
)paren
)paren
id|eol
op_assign
id|EOL_NATIVE
suffix:semicolon
r_else
id|eol
op_assign
id|EOL_UNSET
suffix:semicolon
r_if
c_cond
(paren
id|eol
op_eq
id|EOL_CRLF
op_logical_and
id|auto_crlf
op_eq
id|AUTO_CRLF_INPUT
)paren
r_return
id|error
c_func
(paren
l_string|&quot;core.autocrlf=input conflicts with core.eol=crlf&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.notesref&quot;
)paren
)paren
(brace
id|notes_ref_name
op_assign
id|xstrdup
c_func
(paren
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.pager&quot;
)paren
)paren
r_return
id|git_config_string
c_func
(paren
op_amp
id|pager_program
comma
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.editor&quot;
)paren
)paren
r_return
id|git_config_string
c_func
(paren
op_amp
id|editor_program
comma
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.askpass&quot;
)paren
)paren
r_return
id|git_config_string
c_func
(paren
op_amp
id|askpass_program
comma
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.excludesfile&quot;
)paren
)paren
r_return
id|git_config_pathname
c_func
(paren
op_amp
id|excludes_file
comma
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.whitespace&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
r_return
id|config_error_nonbool
c_func
(paren
id|var
)paren
suffix:semicolon
id|whitespace_rule_cfg
op_assign
id|parse_whitespace_rule
c_func
(paren
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.fsyncobjectfiles&quot;
)paren
)paren
(brace
id|fsync_object_files
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.preloadindex&quot;
)paren
)paren
(brace
id|core_preload_index
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.createobject&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|value
comma
l_string|&quot;rename&quot;
)paren
)paren
id|object_creation_mode
op_assign
id|OBJECT_CREATION_USES_RENAMES
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|value
comma
l_string|&quot;link&quot;
)paren
)paren
id|object_creation_mode
op_assign
id|OBJECT_CREATION_USES_HARDLINKS
suffix:semicolon
r_else
id|die
c_func
(paren
l_string|&quot;Invalid mode for object creation: %s&quot;
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.sparsecheckout&quot;
)paren
)paren
(brace
id|core_apply_sparse_checkout
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Add other config variables here and to Documentation/config.txt. */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|git_default_user_config
r_static
r_int
id|git_default_user_config
c_func
(paren
r_const
r_char
op_star
id|var
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;user.name&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
r_return
id|config_error_nonbool
c_func
(paren
id|var
)paren
suffix:semicolon
id|strlcpy
c_func
(paren
id|git_default_name
comma
id|value
comma
r_sizeof
(paren
id|git_default_name
)paren
)paren
suffix:semicolon
id|user_ident_explicitly_given
op_or_assign
id|IDENT_NAME_GIVEN
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;user.email&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
r_return
id|config_error_nonbool
c_func
(paren
id|var
)paren
suffix:semicolon
id|strlcpy
c_func
(paren
id|git_default_email
comma
id|value
comma
r_sizeof
(paren
id|git_default_email
)paren
)paren
suffix:semicolon
id|user_ident_explicitly_given
op_or_assign
id|IDENT_MAIL_GIVEN
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Add other config variables here and to Documentation/config.txt. */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|git_default_i18n_config
r_static
r_int
id|git_default_i18n_config
c_func
(paren
r_const
r_char
op_star
id|var
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;i18n.commitencoding&quot;
)paren
)paren
r_return
id|git_config_string
c_func
(paren
op_amp
id|git_commit_encoding
comma
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;i18n.logoutputencoding&quot;
)paren
)paren
r_return
id|git_config_string
c_func
(paren
op_amp
id|git_log_output_encoding
comma
id|var
comma
id|value
)paren
suffix:semicolon
multiline_comment|/* Add other config variables here and to Documentation/config.txt. */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|git_default_branch_config
r_static
r_int
id|git_default_branch_config
c_func
(paren
r_const
r_char
op_star
id|var
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;branch.autosetupmerge&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|value
op_logical_and
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;always&quot;
)paren
)paren
(brace
id|git_branch_track
op_assign
id|BRANCH_TRACK_ALWAYS
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|git_branch_track
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;branch.autosetuprebase&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
r_return
id|config_error_nonbool
c_func
(paren
id|var
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|value
comma
l_string|&quot;never&quot;
)paren
)paren
id|autorebase
op_assign
id|AUTOREBASE_NEVER
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|value
comma
l_string|&quot;local&quot;
)paren
)paren
id|autorebase
op_assign
id|AUTOREBASE_LOCAL
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|value
comma
l_string|&quot;remote&quot;
)paren
)paren
id|autorebase
op_assign
id|AUTOREBASE_REMOTE
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|value
comma
l_string|&quot;always&quot;
)paren
)paren
id|autorebase
op_assign
id|AUTOREBASE_ALWAYS
suffix:semicolon
r_else
r_return
id|error
c_func
(paren
l_string|&quot;Malformed value for %s&quot;
comma
id|var
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Add other config variables here and to Documentation/config.txt. */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|git_default_push_config
r_static
r_int
id|git_default_push_config
c_func
(paren
r_const
r_char
op_star
id|var
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;push.default&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
r_return
id|config_error_nonbool
c_func
(paren
id|var
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|value
comma
l_string|&quot;nothing&quot;
)paren
)paren
id|push_default
op_assign
id|PUSH_DEFAULT_NOTHING
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|value
comma
l_string|&quot;matching&quot;
)paren
)paren
id|push_default
op_assign
id|PUSH_DEFAULT_MATCHING
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|value
comma
l_string|&quot;upstream&quot;
)paren
)paren
id|push_default
op_assign
id|PUSH_DEFAULT_UPSTREAM
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|value
comma
l_string|&quot;tracking&quot;
)paren
)paren
multiline_comment|/* deprecated */
id|push_default
op_assign
id|PUSH_DEFAULT_UPSTREAM
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|value
comma
l_string|&quot;current&quot;
)paren
)paren
id|push_default
op_assign
id|PUSH_DEFAULT_CURRENT
suffix:semicolon
r_else
(brace
id|error
c_func
(paren
l_string|&quot;Malformed value for %s: %s&quot;
comma
id|var
comma
id|value
)paren
suffix:semicolon
r_return
id|error
c_func
(paren
l_string|&quot;Must be one of nothing, matching, &quot;
l_string|&quot;tracking or current.&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Add other config variables here and to Documentation/config.txt. */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|git_default_mailmap_config
r_static
r_int
id|git_default_mailmap_config
c_func
(paren
r_const
r_char
op_star
id|var
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;mailmap.file&quot;
)paren
)paren
r_return
id|git_config_string
c_func
(paren
op_amp
id|git_mailmap_file
comma
id|var
comma
id|value
)paren
suffix:semicolon
multiline_comment|/* Add other config variables here and to Documentation/config.txt. */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|git_default_config
r_int
id|git_default_config
c_func
(paren
r_const
r_char
op_star
id|var
comma
r_const
r_char
op_star
id|value
comma
r_void
op_star
id|dummy
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|var
comma
l_string|&quot;core.&quot;
)paren
)paren
r_return
id|git_default_core_config
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|var
comma
l_string|&quot;user.&quot;
)paren
)paren
r_return
id|git_default_user_config
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|var
comma
l_string|&quot;i18n.&quot;
)paren
)paren
r_return
id|git_default_i18n_config
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|var
comma
l_string|&quot;branch.&quot;
)paren
)paren
r_return
id|git_default_branch_config
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|var
comma
l_string|&quot;push.&quot;
)paren
)paren
r_return
id|git_default_push_config
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|var
comma
l_string|&quot;mailmap.&quot;
)paren
)paren
r_return
id|git_default_mailmap_config
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|var
comma
l_string|&quot;advice.&quot;
)paren
)paren
r_return
id|git_default_advice_config
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;pager.color&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;color.pager&quot;
)paren
)paren
(brace
id|pager_use_color
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Add other config variables here and to Documentation/config.txt. */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|git_config_from_file
r_int
id|git_config_from_file
c_func
(paren
id|config_fn_t
id|fn
comma
r_const
r_char
op_star
id|filename
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|ret
suffix:semicolon
id|FILE
op_star
id|f
op_assign
id|fopen
c_func
(paren
id|filename
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|f
)paren
(brace
id|config_file
op_assign
id|f
suffix:semicolon
id|config_file_name
op_assign
id|filename
suffix:semicolon
id|config_linenr
op_assign
l_int|1
suffix:semicolon
id|config_file_eof
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
id|git_parse_file
c_func
(paren
id|fn
comma
id|data
)paren
suffix:semicolon
id|fclose
c_func
(paren
id|f
)paren
suffix:semicolon
id|config_file_name
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|git_etc_gitconfig
r_const
r_char
op_star
id|git_etc_gitconfig
c_func
(paren
r_void
)paren
(brace
r_static
r_const
r_char
op_star
id|system_wide
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|system_wide
)paren
id|system_wide
op_assign
id|system_path
c_func
(paren
id|ETC_GITCONFIG
)paren
suffix:semicolon
r_return
id|system_wide
suffix:semicolon
)brace
DECL|function|git_env_bool
r_int
id|git_env_bool
c_func
(paren
r_const
r_char
op_star
id|k
comma
r_int
id|def
)paren
(brace
r_const
r_char
op_star
id|v
op_assign
id|getenv
c_func
(paren
id|k
)paren
suffix:semicolon
r_return
id|v
ques
c_cond
id|git_config_bool
c_func
(paren
id|k
comma
id|v
)paren
suffix:colon
id|def
suffix:semicolon
)brace
DECL|function|git_config_system
r_int
id|git_config_system
c_func
(paren
r_void
)paren
(brace
r_return
op_logical_neg
id|git_env_bool
c_func
(paren
l_string|&quot;GIT_CONFIG_NOSYSTEM&quot;
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|git_config_early
r_int
id|git_config_early
c_func
(paren
id|config_fn_t
id|fn
comma
r_void
op_star
id|data
comma
r_const
r_char
op_star
id|repo_config
)paren
(brace
r_int
id|ret
op_assign
l_int|0
comma
id|found
op_assign
l_int|0
suffix:semicolon
r_const
r_char
op_star
id|home
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Setting $GIT_CONFIG makes git read _only_ the given config file. */
r_if
c_cond
(paren
id|config_exclusive_filename
)paren
r_return
id|git_config_from_file
c_func
(paren
id|fn
comma
id|config_exclusive_filename
comma
id|data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|git_config_system
c_func
(paren
)paren
op_logical_and
op_logical_neg
id|access
c_func
(paren
id|git_etc_gitconfig
c_func
(paren
)paren
comma
id|R_OK
)paren
)paren
(brace
id|ret
op_add_assign
id|git_config_from_file
c_func
(paren
id|fn
comma
id|git_etc_gitconfig
c_func
(paren
)paren
comma
id|data
)paren
suffix:semicolon
id|found
op_add_assign
l_int|1
suffix:semicolon
)brace
id|home
op_assign
id|getenv
c_func
(paren
l_string|&quot;HOME&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|home
)paren
(brace
r_char
op_star
id|user_config
op_assign
id|xstrdup
c_func
(paren
id|mkpath
c_func
(paren
l_string|&quot;%s/.gitconfig&quot;
comma
id|home
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access
c_func
(paren
id|user_config
comma
id|R_OK
)paren
)paren
(brace
id|ret
op_add_assign
id|git_config_from_file
c_func
(paren
id|fn
comma
id|user_config
comma
id|data
)paren
suffix:semicolon
id|found
op_add_assign
l_int|1
suffix:semicolon
)brace
id|free
c_func
(paren
id|user_config
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|repo_config
op_logical_and
op_logical_neg
id|access
c_func
(paren
id|repo_config
comma
id|R_OK
)paren
)paren
(brace
id|ret
op_add_assign
id|git_config_from_file
c_func
(paren
id|fn
comma
id|repo_config
comma
id|data
)paren
suffix:semicolon
id|found
op_add_assign
l_int|1
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|git_config_from_parameters
c_func
(paren
id|fn
comma
id|data
)paren
)paren
(brace
r_case
l_int|1
suffix:colon
multiline_comment|/* error */
id|die
c_func
(paren
l_string|&quot;unable to parse command-line config&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
multiline_comment|/* found nothing */
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* found at least one item */
id|found
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
op_eq
l_int|0
ques
c_cond
id|found
suffix:colon
id|ret
suffix:semicolon
)brace
DECL|function|git_config
r_int
id|git_config
c_func
(paren
id|config_fn_t
id|fn
comma
r_void
op_star
id|data
)paren
(brace
r_char
op_star
id|repo_config
op_assign
l_int|NULL
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|repo_config
op_assign
id|git_pathdup
c_func
(paren
l_string|&quot;config&quot;
)paren
suffix:semicolon
id|ret
op_assign
id|git_config_early
c_func
(paren
id|fn
comma
id|data
comma
id|repo_config
)paren
suffix:semicolon
r_if
c_cond
(paren
id|repo_config
)paren
id|free
c_func
(paren
id|repo_config
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Find all the stuff for git_config_set() below.&n; */
DECL|macro|MAX_MATCHES
mdefine_line|#define MAX_MATCHES 512
r_static
r_struct
(brace
DECL|member|baselen
r_int
id|baselen
suffix:semicolon
DECL|member|key
r_char
op_star
id|key
suffix:semicolon
DECL|member|do_not_match
r_int
id|do_not_match
suffix:semicolon
DECL|member|value_regex
id|regex_t
op_star
id|value_regex
suffix:semicolon
DECL|member|multi_replace
r_int
id|multi_replace
suffix:semicolon
DECL|member|offset
r_int
id|offset
(braket
id|MAX_MATCHES
)braket
suffix:semicolon
DECL|enumerator|START
DECL|enumerator|SECTION_SEEN
DECL|enumerator|SECTION_END_SEEN
DECL|enumerator|KEY_SEEN
DECL|member|state
r_enum
(brace
id|START
comma
id|SECTION_SEEN
comma
id|SECTION_END_SEEN
comma
id|KEY_SEEN
)brace
id|state
suffix:semicolon
DECL|member|seen
r_int
id|seen
suffix:semicolon
DECL|variable|store
)brace
id|store
suffix:semicolon
DECL|function|matches
r_static
r_int
id|matches
c_func
(paren
r_const
r_char
op_star
id|key
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_return
op_logical_neg
id|strcmp
c_func
(paren
id|key
comma
id|store.key
)paren
op_logical_and
(paren
id|store.value_regex
op_eq
l_int|NULL
op_logical_or
(paren
id|store.do_not_match
op_xor
op_logical_neg
id|regexec
c_func
(paren
id|store.value_regex
comma
id|value
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
)paren
)paren
)paren
suffix:semicolon
)brace
DECL|function|store_aux
r_static
r_int
id|store_aux
c_func
(paren
r_const
r_char
op_star
id|key
comma
r_const
r_char
op_star
id|value
comma
r_void
op_star
id|cb
)paren
(brace
r_const
r_char
op_star
id|ep
suffix:semicolon
r_int
id|section_len
suffix:semicolon
r_switch
c_cond
(paren
id|store.state
)paren
(brace
r_case
id|KEY_SEEN
suffix:colon
r_if
c_cond
(paren
id|matches
c_func
(paren
id|key
comma
id|value
)paren
)paren
(brace
r_if
c_cond
(paren
id|store.seen
op_eq
l_int|1
op_logical_and
id|store.multi_replace
op_eq
l_int|0
)paren
(brace
id|warning
c_func
(paren
l_string|&quot;%s has multiple values&quot;
comma
id|key
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|store.seen
op_ge
id|MAX_MATCHES
)paren
(brace
id|error
c_func
(paren
l_string|&quot;too many matches for %s&quot;
comma
id|key
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|store.offset
(braket
id|store.seen
)braket
op_assign
id|ftell
c_func
(paren
id|config_file
)paren
suffix:semicolon
id|store.seen
op_increment
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SECTION_SEEN
suffix:colon
multiline_comment|/*&n;&t;&t; * What we are looking for is in store.key (both&n;&t;&t; * section and var), and its section part is baselen&n;&t;&t; * long.  We found key (again, both section and var).&n;&t;&t; * We would want to know if this key is in the same&n;&t;&t; * section as what we are looking for.  We already&n;&t;&t; * know we are in the same section as what should&n;&t;&t; * hold store.key.&n;&t;&t; */
id|ep
op_assign
id|strrchr
c_func
(paren
id|key
comma
l_char|&squot;.&squot;
)paren
suffix:semicolon
id|section_len
op_assign
id|ep
id|key
suffix:semicolon
r_if
c_cond
(paren
(paren
id|section_len
op_ne
id|store.baselen
)paren
op_logical_or
id|memcmp
c_func
(paren
id|key
comma
id|store.key
comma
id|section_len
op_plus
l_int|1
)paren
)paren
(brace
id|store.state
op_assign
id|SECTION_END_SEEN
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Do not increment matches: this is no match, but we&n;&t;&t; * just made sure we are in the desired section.&n;&t;&t; */
id|store.offset
(braket
id|store.seen
)braket
op_assign
id|ftell
c_func
(paren
id|config_file
)paren
suffix:semicolon
multiline_comment|/* fallthru */
r_case
id|SECTION_END_SEEN
suffix:colon
r_case
id|START
suffix:colon
r_if
c_cond
(paren
id|matches
c_func
(paren
id|key
comma
id|value
)paren
)paren
(brace
id|store.offset
(braket
id|store.seen
)braket
op_assign
id|ftell
c_func
(paren
id|config_file
)paren
suffix:semicolon
id|store.state
op_assign
id|KEY_SEEN
suffix:semicolon
id|store.seen
op_increment
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|strrchr
c_func
(paren
id|key
comma
l_char|&squot;.&squot;
)paren
id|key
op_eq
id|store.baselen
op_logical_and
op_logical_neg
id|strncmp
c_func
(paren
id|key
comma
id|store.key
comma
id|store.baselen
)paren
)paren
(brace
id|store.state
op_assign
id|SECTION_SEEN
suffix:semicolon
id|store.offset
(braket
id|store.seen
)braket
op_assign
id|ftell
c_func
(paren
id|config_file
)paren
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|write_error
r_static
r_int
id|write_error
c_func
(paren
r_const
r_char
op_star
id|filename
)paren
(brace
id|error
c_func
(paren
l_string|&quot;failed to write new configuration file %s&quot;
comma
id|filename
)paren
suffix:semicolon
multiline_comment|/* Same error code as &quot;failed to rename&quot;. */
r_return
l_int|4
suffix:semicolon
)brace
DECL|function|store_write_section
r_static
r_int
id|store_write_section
c_func
(paren
r_int
id|fd
comma
r_const
r_char
op_star
id|key
)paren
(brace
r_const
r_char
op_star
id|dot
suffix:semicolon
r_int
id|i
comma
id|success
suffix:semicolon
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
id|dot
op_assign
id|memchr
c_func
(paren
id|key
comma
l_char|&squot;.&squot;
comma
id|store.baselen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dot
)paren
(brace
id|strbuf_addf
c_func
(paren
op_amp
id|sb
comma
l_string|&quot;[%.*s &bslash;&quot;&quot;
comma
(paren
r_int
)paren
(paren
id|dot
id|key
)paren
comma
id|key
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|dot
id|key
op_plus
l_int|1
suffix:semicolon
id|i
OL
id|store.baselen
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|key
(braket
id|i
)braket
op_eq
l_char|&squot;&quot;&squot;
op_logical_or
id|key
(braket
id|i
)braket
op_eq
l_char|&squot;&bslash;&bslash;&squot;
)paren
id|strbuf_addch
c_func
(paren
op_amp
id|sb
comma
l_char|&squot;&bslash;&bslash;&squot;
)paren
suffix:semicolon
id|strbuf_addch
c_func
(paren
op_amp
id|sb
comma
id|key
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|strbuf_addstr
c_func
(paren
op_amp
id|sb
comma
l_string|&quot;&bslash;&quot;]&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|strbuf_addf
c_func
(paren
op_amp
id|sb
comma
l_string|&quot;[%.*s]&bslash;n&quot;
comma
id|store.baselen
comma
id|key
)paren
suffix:semicolon
)brace
id|success
op_assign
id|write_in_full
c_func
(paren
id|fd
comma
id|sb.buf
comma
id|sb.len
)paren
op_eq
id|sb.len
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
r_return
id|success
suffix:semicolon
)brace
DECL|function|store_write_pair
r_static
r_int
id|store_write_pair
c_func
(paren
r_int
id|fd
comma
r_const
r_char
op_star
id|key
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_int
id|i
comma
id|success
suffix:semicolon
r_int
id|length
op_assign
id|strlen
c_func
(paren
id|key
op_plus
id|store.baselen
op_plus
l_int|1
)paren
suffix:semicolon
r_const
r_char
op_star
id|quote
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
multiline_comment|/*&n;&t; * Check to see if the value needs to be surrounded with a dq pair.&n;&t; * Note that problematic characters are always backslash-quoted; this&n;&t; * check is about not losing leading or trailing SP and strings that&n;&t; * follow beginning-of-comment characters (i.e. &squot;;&squot; and &squot;#&squot;) by the&n;&t; * configuration parser.&n;&t; */
r_if
c_cond
(paren
id|value
(braket
l_int|0
)braket
op_eq
l_char|&squot; &squot;
)paren
id|quote
op_assign
l_string|&quot;&bslash;&quot;&quot;
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|value
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|value
(braket
id|i
)braket
op_eq
l_char|&squot;;&squot;
op_logical_or
id|value
(braket
id|i
)braket
op_eq
l_char|&squot;#&squot;
)paren
id|quote
op_assign
l_string|&quot;&bslash;&quot;&quot;
suffix:semicolon
r_if
c_cond
(paren
id|i
op_logical_and
id|value
(braket
id|i
l_int|1
)braket
op_eq
l_char|&squot; &squot;
)paren
id|quote
op_assign
l_string|&quot;&bslash;&quot;&quot;
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
id|sb
comma
l_string|&quot;&bslash;t%.*s = %s&quot;
comma
id|length
comma
id|key
op_plus
id|store.baselen
op_plus
l_int|1
comma
id|quote
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|value
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
r_switch
c_cond
(paren
id|value
(braket
id|i
)braket
)paren
(brace
r_case
l_char|&squot;&bslash;n&squot;
suffix:colon
id|strbuf_addstr
c_func
(paren
op_amp
id|sb
comma
l_string|&quot;&bslash;&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;&bslash;t&squot;
suffix:colon
id|strbuf_addstr
c_func
(paren
op_amp
id|sb
comma
l_string|&quot;&bslash;&bslash;t&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;&quot;&squot;
suffix:colon
r_case
l_char|&squot;&bslash;&bslash;&squot;
suffix:colon
id|strbuf_addch
c_func
(paren
op_amp
id|sb
comma
l_char|&squot;&bslash;&bslash;&squot;
)paren
suffix:semicolon
r_default
suffix:colon
id|strbuf_addch
c_func
(paren
op_amp
id|sb
comma
id|value
(braket
id|i
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|strbuf_addf
c_func
(paren
op_amp
id|sb
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|quote
)paren
suffix:semicolon
id|success
op_assign
id|write_in_full
c_func
(paren
id|fd
comma
id|sb.buf
comma
id|sb.len
)paren
op_eq
id|sb.len
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
r_return
id|success
suffix:semicolon
)brace
DECL|function|find_beginning_of_line
r_static
id|ssize_t
id|find_beginning_of_line
c_func
(paren
r_const
r_char
op_star
id|contents
comma
r_int
id|size
comma
r_int
id|offset_
comma
r_int
op_star
id|found_bracket
)paren
(brace
r_int
id|equal_offset
op_assign
id|size
comma
id|bracket_offset
op_assign
id|size
suffix:semicolon
id|ssize_t
id|offset
suffix:semicolon
id|contline
suffix:colon
r_for
c_loop
(paren
id|offset
op_assign
id|offset_
op_minus
l_int|2
suffix:semicolon
id|offset
OG
l_int|0
op_logical_and
id|contents
(braket
id|offset
)braket
op_ne
l_char|&squot;&bslash;n&squot;
suffix:semicolon
id|offset
op_decrement
)paren
r_switch
c_cond
(paren
id|contents
(braket
id|offset
)braket
)paren
(brace
r_case
l_char|&squot;=&squot;
suffix:colon
id|equal_offset
op_assign
id|offset
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;]&squot;
suffix:colon
id|bracket_offset
op_assign
id|offset
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|offset
OG
l_int|0
op_logical_and
id|contents
(braket
id|offset
op_minus
l_int|1
)braket
op_eq
l_char|&squot;&bslash;&bslash;&squot;
)paren
(brace
id|offset_
op_assign
id|offset
suffix:semicolon
r_goto
id|contline
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bracket_offset
OL
id|equal_offset
)paren
(brace
op_star
id|found_bracket
op_assign
l_int|1
suffix:semicolon
id|offset
op_assign
id|bracket_offset
op_plus
l_int|1
suffix:semicolon
)brace
r_else
id|offset
op_increment
suffix:semicolon
r_return
id|offset
suffix:semicolon
)brace
DECL|function|git_config_set
r_int
id|git_config_set
c_func
(paren
r_const
r_char
op_star
id|key
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_return
id|git_config_set_multivar
c_func
(paren
id|key
comma
id|value
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Auxiliary function to sanity-check and split the key into the section&n; * identifier and variable name.&n; *&n; * Returns 0 on success, -1 when there is an invalid character in the key and&n; * -2 if there is no section name in the key.&n; *&n; * store_key - pointer to char* which will hold a copy of the key with&n; *             lowercase section and variable name&n; * baselen - pointer to int which will hold the length of the&n; *           section + subsection part, can be NULL&n; */
DECL|function|git_config_parse_key
r_int
id|git_config_parse_key
c_func
(paren
r_const
r_char
op_star
id|key
comma
r_char
op_star
op_star
id|store_key
comma
r_int
op_star
id|baselen_
)paren
(brace
r_int
id|i
comma
id|dot
comma
id|baselen
suffix:semicolon
r_const
r_char
op_star
id|last_dot
op_assign
id|strrchr
c_func
(paren
id|key
comma
l_char|&squot;.&squot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Since &quot;key&quot; actually contains the section name and the real&n;&t; * key name separated by a dot, we have to know where the dot is.&n;&t; */
r_if
c_cond
(paren
id|last_dot
op_eq
l_int|NULL
op_logical_or
id|last_dot
op_eq
id|key
)paren
(brace
id|error
c_func
(paren
l_string|&quot;key does not contain a section: %s&quot;
comma
id|key
)paren
suffix:semicolon
r_return
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|last_dot
(braket
l_int|1
)braket
)paren
(brace
id|error
c_func
(paren
l_string|&quot;key does not contain variable name: %s&quot;
comma
id|key
)paren
suffix:semicolon
r_return
l_int|2
suffix:semicolon
)brace
id|baselen
op_assign
id|last_dot
id|key
suffix:semicolon
r_if
c_cond
(paren
id|baselen_
)paren
op_star
id|baselen_
op_assign
id|baselen
suffix:semicolon
multiline_comment|/*&n;&t; * Validate the key and while at it, lower case it for matching.&n;&t; */
op_star
id|store_key
op_assign
id|xmalloc
c_func
(paren
id|strlen
c_func
(paren
id|key
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|dot
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|key
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_char
id|c
op_assign
id|key
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;.&squot;
)paren
id|dot
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Leave the extended basename untouched.. */
r_if
c_cond
(paren
op_logical_neg
id|dot
op_logical_or
id|i
OG
id|baselen
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|iskeychar
c_func
(paren
id|c
)paren
op_logical_or
(paren
id|i
op_eq
id|baselen
op_plus
l_int|1
op_logical_and
op_logical_neg
id|isalpha
c_func
(paren
id|c
)paren
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;invalid key: %s&quot;
comma
id|key
)paren
suffix:semicolon
r_goto
id|out_free_ret_1
suffix:semicolon
)brace
id|c
op_assign
id|tolower
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|error
c_func
(paren
l_string|&quot;invalid key (newline): %s&quot;
comma
id|key
)paren
suffix:semicolon
r_goto
id|out_free_ret_1
suffix:semicolon
)brace
(paren
op_star
id|store_key
)paren
(braket
id|i
)braket
op_assign
id|c
suffix:semicolon
)brace
(paren
op_star
id|store_key
)paren
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_free_ret_1
suffix:colon
id|free
c_func
(paren
op_star
id|store_key
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * If value==NULL, unset in (remove from) config,&n; * if value_regex!=NULL, disregard key/value pairs where value does not match.&n; * if multi_replace==0, nothing, or only one matching key/value is replaced,&n; *     else all matching key/values (regardless how many) are removed,&n; *     before the new pair is written.&n; *&n; * Returns 0 on success.&n; *&n; * This function does this:&n; *&n; * - it locks the config file by creating &quot;.git/config.lock&quot;&n; *&n; * - it then parses the config using store_aux() as validator to find&n; *   the position on the key/value pair to replace. If it is to be unset,&n; *   it must be found exactly once.&n; *&n; * - the config file is mmap()ed and the part before the match (if any) is&n; *   written to the lock file, then the changed part and the rest.&n; *&n; * - the config file is removed and the lock file rename()d to it.&n; *&n; */
DECL|function|git_config_set_multivar
r_int
id|git_config_set_multivar
c_func
(paren
r_const
r_char
op_star
id|key
comma
r_const
r_char
op_star
id|value
comma
r_const
r_char
op_star
id|value_regex
comma
r_int
id|multi_replace
)paren
(brace
r_int
id|fd
op_assign
l_int|1
comma
id|in_fd
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_char
op_star
id|config_filename
suffix:semicolon
r_struct
id|lock_file
op_star
id|lock
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|config_exclusive_filename
)paren
id|config_filename
op_assign
id|xstrdup
c_func
(paren
id|config_exclusive_filename
)paren
suffix:semicolon
r_else
id|config_filename
op_assign
id|git_pathdup
c_func
(paren
l_string|&quot;config&quot;
)paren
suffix:semicolon
multiline_comment|/* parse-key returns negative; flip the sign to feed exit(3) */
id|ret
op_assign
l_int|0
id|git_config_parse_key
c_func
(paren
id|key
comma
op_amp
id|store.key
comma
op_amp
id|store.baselen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out_free
suffix:semicolon
id|store.multi_replace
op_assign
id|multi_replace
suffix:semicolon
multiline_comment|/*&n;&t; * The lock serves a purpose in addition to locking: the new&n;&t; * contents of .git/config will be written into it.&n;&t; */
id|lock
op_assign
id|xcalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|lock_file
)paren
comma
l_int|1
)paren
suffix:semicolon
id|fd
op_assign
id|hold_lock_file_for_update
c_func
(paren
id|lock
comma
id|config_filename
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
(brace
id|error
c_func
(paren
l_string|&quot;could not lock config file %s: %s&quot;
comma
id|config_filename
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
id|free
c_func
(paren
id|store.key
)paren
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If .git/config does not exist yet, write a minimal version.&n;&t; */
id|in_fd
op_assign
id|open
c_func
(paren
id|config_filename
comma
id|O_RDONLY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in_fd
OL
l_int|0
)paren
(brace
id|free
c_func
(paren
id|store.key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ENOENT
op_ne
id|errno
)paren
(brace
id|error
c_func
(paren
l_string|&quot;opening %s: %s&quot;
comma
id|config_filename
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
id|ret
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* same as &quot;invalid config file&quot; */
r_goto
id|out_free
suffix:semicolon
)brace
multiline_comment|/* if nothing to unset, error out */
r_if
c_cond
(paren
id|value
op_eq
l_int|NULL
)paren
(brace
id|ret
op_assign
l_int|5
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
id|store.key
op_assign
(paren
r_char
op_star
)paren
id|key
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|store_write_section
c_func
(paren
id|fd
comma
id|key
)paren
op_logical_or
op_logical_neg
id|store_write_pair
c_func
(paren
id|fd
comma
id|key
comma
id|value
)paren
)paren
r_goto
id|write_err_out
suffix:semicolon
)brace
r_else
(brace
r_struct
id|stat
id|st
suffix:semicolon
r_char
op_star
id|contents
suffix:semicolon
r_int
id|contents_sz
comma
id|copy_begin
comma
id|copy_end
suffix:semicolon
r_int
id|i
comma
id|new_line
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|value_regex
op_eq
l_int|NULL
)paren
id|store.value_regex
op_assign
l_int|NULL
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|value_regex
(braket
l_int|0
)braket
op_eq
l_char|&squot;!&squot;
)paren
(brace
id|store.do_not_match
op_assign
l_int|1
suffix:semicolon
id|value_regex
op_increment
suffix:semicolon
)brace
r_else
id|store.do_not_match
op_assign
l_int|0
suffix:semicolon
id|store.value_regex
op_assign
(paren
id|regex_t
op_star
)paren
id|xmalloc
c_func
(paren
r_sizeof
(paren
id|regex_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|regcomp
c_func
(paren
id|store.value_regex
comma
id|value_regex
comma
id|REG_EXTENDED
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;invalid pattern: %s&quot;
comma
id|value_regex
)paren
suffix:semicolon
id|free
c_func
(paren
id|store.value_regex
)paren
suffix:semicolon
id|ret
op_assign
l_int|6
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
)brace
id|store.offset
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|store.state
op_assign
id|START
suffix:semicolon
id|store.seen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * After this, store.offset will contain the *end* offset&n;&t;&t; * of the last match, or remain at 0 if no match was found.&n;&t;&t; * As a side effect, we make sure to transform only a valid&n;&t;&t; * existing config file.&n;&t;&t; */
r_if
c_cond
(paren
id|git_config_from_file
c_func
(paren
id|store_aux
comma
id|config_filename
comma
l_int|NULL
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;invalid config file %s&quot;
comma
id|config_filename
)paren
suffix:semicolon
id|free
c_func
(paren
id|store.key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|store.value_regex
op_ne
l_int|NULL
)paren
(brace
id|regfree
c_func
(paren
id|store.value_regex
)paren
suffix:semicolon
id|free
c_func
(paren
id|store.value_regex
)paren
suffix:semicolon
)brace
id|ret
op_assign
l_int|3
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
id|free
c_func
(paren
id|store.key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|store.value_regex
op_ne
l_int|NULL
)paren
(brace
id|regfree
c_func
(paren
id|store.value_regex
)paren
suffix:semicolon
id|free
c_func
(paren
id|store.value_regex
)paren
suffix:semicolon
)brace
multiline_comment|/* if nothing to unset, or too many matches, error out */
r_if
c_cond
(paren
(paren
id|store.seen
op_eq
l_int|0
op_logical_and
id|value
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|store.seen
OG
l_int|1
op_logical_and
id|multi_replace
op_eq
l_int|0
)paren
)paren
(brace
id|ret
op_assign
l_int|5
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
id|fstat
c_func
(paren
id|in_fd
comma
op_amp
id|st
)paren
suffix:semicolon
id|contents_sz
op_assign
id|xsize_t
c_func
(paren
id|st.st_size
)paren
suffix:semicolon
id|contents
op_assign
id|xmmap
c_func
(paren
l_int|NULL
comma
id|contents_sz
comma
id|PROT_READ
comma
id|MAP_PRIVATE
comma
id|in_fd
comma
l_int|0
)paren
suffix:semicolon
id|close
c_func
(paren
id|in_fd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|store.seen
op_eq
l_int|0
)paren
id|store.seen
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|copy_begin
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|store.seen
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|store.offset
(braket
id|i
)braket
op_eq
l_int|0
)paren
(brace
id|store.offset
(braket
id|i
)braket
op_assign
id|copy_end
op_assign
id|contents_sz
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|store.state
op_ne
id|KEY_SEEN
)paren
(brace
id|copy_end
op_assign
id|store.offset
(braket
id|i
)braket
suffix:semicolon
)brace
r_else
id|copy_end
op_assign
id|find_beginning_of_line
c_func
(paren
id|contents
comma
id|contents_sz
comma
id|store.offset
(braket
id|i
)braket
l_int|2
comma
op_amp
id|new_line
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_end
OG
l_int|0
op_logical_and
id|contents
(braket
id|copy_end
op_minus
l_int|1
)braket
op_ne
l_char|&squot;&bslash;n&squot;
)paren
id|new_line
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* write the first part of the config */
r_if
c_cond
(paren
id|copy_end
OG
id|copy_begin
)paren
(brace
r_if
c_cond
(paren
id|write_in_full
c_func
(paren
id|fd
comma
id|contents
op_plus
id|copy_begin
comma
id|copy_end
id|copy_begin
)paren
OL
id|copy_end
id|copy_begin
)paren
r_goto
id|write_err_out
suffix:semicolon
r_if
c_cond
(paren
id|new_line
op_logical_and
id|write_str_in_full
c_func
(paren
id|fd
comma
l_string|&quot;&bslash;n&quot;
)paren
op_ne
l_int|1
)paren
r_goto
id|write_err_out
suffix:semicolon
)brace
id|copy_begin
op_assign
id|store.offset
(braket
id|i
)braket
suffix:semicolon
)brace
multiline_comment|/* write the pair (value == NULL means unset) */
r_if
c_cond
(paren
id|value
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|store.state
op_eq
id|START
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|store_write_section
c_func
(paren
id|fd
comma
id|key
)paren
)paren
r_goto
id|write_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|store_write_pair
c_func
(paren
id|fd
comma
id|key
comma
id|value
)paren
)paren
r_goto
id|write_err_out
suffix:semicolon
)brace
multiline_comment|/* write the rest of the config */
r_if
c_cond
(paren
id|copy_begin
OL
id|contents_sz
)paren
r_if
c_cond
(paren
id|write_in_full
c_func
(paren
id|fd
comma
id|contents
op_plus
id|copy_begin
comma
id|contents_sz
id|copy_begin
)paren
OL
id|contents_sz
id|copy_begin
)paren
r_goto
id|write_err_out
suffix:semicolon
id|munmap
c_func
(paren
id|contents
comma
id|contents_sz
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|commit_lock_file
c_func
(paren
id|lock
)paren
OL
l_int|0
)paren
(brace
id|error
c_func
(paren
l_string|&quot;could not commit config file %s&quot;
comma
id|config_filename
)paren
suffix:semicolon
id|ret
op_assign
l_int|4
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * lock is committed, so don&squot;t try to roll it back below.&n;&t; * NOTE: Since lockfile.c keeps a linked list of all created&n;&t; * lock_file structures, it isn&squot;t safe to free(lock).  It&squot;s&n;&t; * better to just leave it hanging around.&n;&t; */
id|lock
op_assign
l_int|NULL
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
id|out_free
suffix:colon
r_if
c_cond
(paren
id|lock
)paren
id|rollback_lock_file
c_func
(paren
id|lock
)paren
suffix:semicolon
id|free
c_func
(paren
id|config_filename
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
id|write_err_out
suffix:colon
id|ret
op_assign
id|write_error
c_func
(paren
id|lock-&gt;filename
)paren
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
DECL|function|section_name_match
r_static
r_int
id|section_name_match
(paren
r_const
r_char
op_star
id|buf
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_int
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
comma
id|dot
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|buf
(braket
id|i
)braket
op_ne
l_char|&squot;[&squot;
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|buf
(braket
id|i
)braket
op_logical_and
id|buf
(braket
id|i
)braket
op_ne
l_char|&squot;]&squot;
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dot
op_logical_and
id|isspace
c_func
(paren
id|buf
(braket
id|i
)braket
)paren
)paren
(brace
id|dot
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|name
(braket
id|j
op_increment
)braket
op_ne
l_char|&squot;.&squot;
)paren
r_break
suffix:semicolon
r_for
c_loop
(paren
id|i
op_increment
suffix:semicolon
id|isspace
c_func
(paren
id|buf
(braket
id|i
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
suffix:semicolon
multiline_comment|/* do nothing */
r_if
c_cond
(paren
id|buf
(braket
id|i
)braket
op_ne
l_char|&squot;&quot;&squot;
)paren
r_break
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buf
(braket
id|i
)braket
op_eq
l_char|&squot;&bslash;&bslash;&squot;
op_logical_and
id|dot
)paren
id|i
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|buf
(braket
id|i
)braket
op_eq
l_char|&squot;&quot;&squot;
op_logical_and
id|dot
)paren
(brace
r_for
c_loop
(paren
id|i
op_increment
suffix:semicolon
id|isspace
c_func
(paren
id|buf
(braket
id|i
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
suffix:semicolon
multiline_comment|/* do_nothing */
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buf
(braket
id|i
)braket
op_ne
id|name
(braket
id|j
op_increment
)braket
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buf
(braket
id|i
)braket
op_eq
l_char|&squot;]&squot;
op_logical_and
id|name
(braket
id|j
)braket
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * We match, now just find the right length offset by&n;&t;&t; * gobbling up any whitespace after it, as well&n;&t;&t; */
id|i
op_increment
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|buf
(braket
id|i
)braket
op_logical_and
id|isspace
c_func
(paren
id|buf
(braket
id|i
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
suffix:semicolon
multiline_comment|/* do nothing */
r_return
id|i
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* if new_name == NULL, the section is removed instead */
DECL|function|git_config_rename_section
r_int
id|git_config_rename_section
c_func
(paren
r_const
r_char
op_star
id|old_name
comma
r_const
r_char
op_star
id|new_name
)paren
(brace
r_int
id|ret
op_assign
l_int|0
comma
id|remove
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|config_filename
suffix:semicolon
r_struct
id|lock_file
op_star
id|lock
op_assign
id|xcalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|lock_file
)paren
comma
l_int|1
)paren
suffix:semicolon
r_int
id|out_fd
suffix:semicolon
r_char
id|buf
(braket
l_int|1024
)braket
suffix:semicolon
r_if
c_cond
(paren
id|config_exclusive_filename
)paren
id|config_filename
op_assign
id|xstrdup
c_func
(paren
id|config_exclusive_filename
)paren
suffix:semicolon
r_else
id|config_filename
op_assign
id|git_pathdup
c_func
(paren
l_string|&quot;config&quot;
)paren
suffix:semicolon
id|out_fd
op_assign
id|hold_lock_file_for_update
c_func
(paren
id|lock
comma
id|config_filename
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|out_fd
OL
l_int|0
)paren
(brace
id|ret
op_assign
id|error
c_func
(paren
l_string|&quot;could not lock config file %s&quot;
comma
id|config_filename
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|config_file
op_assign
id|fopen
c_func
(paren
id|config_filename
comma
l_string|&quot;rb&quot;
)paren
)paren
)paren
(brace
multiline_comment|/* no config file means nothing to rename, no error */
r_goto
id|unlock_and_out
suffix:semicolon
)brace
r_while
c_loop
(paren
id|fgets
c_func
(paren
id|buf
comma
r_sizeof
(paren
id|buf
)paren
comma
id|config_file
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|length
suffix:semicolon
r_char
op_star
id|output
op_assign
id|buf
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|buf
(braket
id|i
)braket
op_logical_and
id|isspace
c_func
(paren
id|buf
(braket
id|i
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
suffix:semicolon
multiline_comment|/* do nothing */
r_if
c_cond
(paren
id|buf
(braket
id|i
)braket
op_eq
l_char|&squot;[&squot;
)paren
(brace
multiline_comment|/* it&squot;s a section */
r_int
id|offset
op_assign
id|section_name_match
c_func
(paren
op_amp
id|buf
(braket
id|i
)braket
comma
id|old_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
OG
l_int|0
)paren
(brace
id|ret
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|new_name
op_eq
l_int|NULL
)paren
(brace
id|remove
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|store.baselen
op_assign
id|strlen
c_func
(paren
id|new_name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|store_write_section
c_func
(paren
id|out_fd
comma
id|new_name
)paren
)paren
(brace
id|ret
op_assign
id|write_error
c_func
(paren
id|lock-&gt;filename
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * We wrote out the new section, with&n;&t;&t;&t;&t; * a newline, now skip the old&n;&t;&t;&t;&t; * section&squot;s length&n;&t;&t;&t;&t; */
id|output
op_add_assign
id|offset
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
id|strlen
c_func
(paren
id|output
)paren
OG
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * More content means there&squot;s&n;&t;&t;&t;&t;&t; * a declaration to put on the&n;&t;&t;&t;&t;&t; * next line; indent with a&n;&t;&t;&t;&t;&t; * tab&n;&t;&t;&t;&t;&t; */
id|output
op_sub_assign
l_int|1
suffix:semicolon
id|output
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;t&squot;
suffix:semicolon
)brace
)brace
id|remove
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|remove
)paren
r_continue
suffix:semicolon
id|length
op_assign
id|strlen
c_func
(paren
id|output
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write_in_full
c_func
(paren
id|out_fd
comma
id|output
comma
id|length
)paren
op_ne
id|length
)paren
(brace
id|ret
op_assign
id|write_error
c_func
(paren
id|lock-&gt;filename
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
id|fclose
c_func
(paren
id|config_file
)paren
suffix:semicolon
id|unlock_and_out
suffix:colon
r_if
c_cond
(paren
id|commit_lock_file
c_func
(paren
id|lock
)paren
OL
l_int|0
)paren
id|ret
op_assign
id|error
c_func
(paren
l_string|&quot;could not commit config file %s&quot;
comma
id|config_filename
)paren
suffix:semicolon
id|out
suffix:colon
id|free
c_func
(paren
id|config_filename
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Call this to report error for your variable that should not&n; * get a boolean value (i.e. &quot;[my] var&quot; means &quot;true&quot;).&n; */
DECL|function|config_error_nonbool
r_int
id|config_error_nonbool
c_func
(paren
r_const
r_char
op_star
id|var
)paren
(brace
r_return
id|error
c_func
(paren
l_string|&quot;Missing value for &squot;%s&squot;&quot;
comma
id|var
)paren
suffix:semicolon
)brace
eof
