multiline_comment|/*&n; * GIT - The information manager from hell&n; *&n; * Copyright (C) Linus Torvalds, 2005&n; * Copyright (C) Johannes Schindelin, 2005&n; *&n; */
macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;lockfile.h&quot;
macro_line|#include &quot;exec_cmd.h&quot;
macro_line|#include &quot;strbuf.h&quot;
macro_line|#include &quot;quote.h&quot;
macro_line|#include &quot;hashmap.h&quot;
macro_line|#include &quot;string-list.h&quot;
macro_line|#include &quot;utf8.h&quot;
DECL|struct|config_source
r_struct
id|config_source
(brace
DECL|member|prev
r_struct
id|config_source
op_star
id|prev
suffix:semicolon
r_union
(brace
DECL|member|file
id|FILE
op_star
id|file
suffix:semicolon
DECL|struct|config_buf
r_struct
id|config_buf
(brace
DECL|member|buf
r_const
r_char
op_star
id|buf
suffix:semicolon
DECL|member|len
r_int
id|len
suffix:semicolon
DECL|member|pos
r_int
id|pos
suffix:semicolon
DECL|member|buf
)brace
id|buf
suffix:semicolon
DECL|member|u
)brace
id|u
suffix:semicolon
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
DECL|member|path
r_const
r_char
op_star
id|path
suffix:semicolon
DECL|member|die_on_error
r_int
id|die_on_error
suffix:semicolon
DECL|member|linenr
r_int
id|linenr
suffix:semicolon
DECL|member|eof
r_int
id|eof
suffix:semicolon
DECL|member|value
r_struct
id|strbuf
id|value
suffix:semicolon
DECL|member|var
r_struct
id|strbuf
id|var
suffix:semicolon
DECL|member|do_fgetc
r_int
(paren
op_star
id|do_fgetc
)paren
(paren
r_struct
id|config_source
op_star
id|c
)paren
suffix:semicolon
DECL|member|do_ungetc
r_int
(paren
op_star
id|do_ungetc
)paren
(paren
r_int
id|c
comma
r_struct
id|config_source
op_star
id|conf
)paren
suffix:semicolon
DECL|member|do_ftell
r_int
(paren
op_star
id|do_ftell
)paren
(paren
r_struct
id|config_source
op_star
id|c
)paren
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|cf
r_static
r_struct
id|config_source
op_star
id|cf
suffix:semicolon
DECL|variable|zlib_compression_seen
r_static
r_int
id|zlib_compression_seen
suffix:semicolon
multiline_comment|/*&n; * Default config_set that contains key-value pairs from the usual set of config&n; * config files (i.e repo specific .git/config, user wide ~/.gitconfig, XDG&n; * config file and the global /etc/gitconfig)&n; */
DECL|variable|the_config_set
r_static
r_struct
id|config_set
id|the_config_set
suffix:semicolon
DECL|function|config_file_fgetc
r_static
r_int
id|config_file_fgetc
c_func
(paren
r_struct
id|config_source
op_star
id|conf
)paren
(brace
r_return
id|getc_unlocked
c_func
(paren
id|conf-&gt;u.file
)paren
suffix:semicolon
)brace
DECL|function|config_file_ungetc
r_static
r_int
id|config_file_ungetc
c_func
(paren
r_int
id|c
comma
r_struct
id|config_source
op_star
id|conf
)paren
(brace
r_return
id|ungetc
c_func
(paren
id|c
comma
id|conf-&gt;u.file
)paren
suffix:semicolon
)brace
DECL|function|config_file_ftell
r_static
r_int
id|config_file_ftell
c_func
(paren
r_struct
id|config_source
op_star
id|conf
)paren
(brace
r_return
id|ftell
c_func
(paren
id|conf-&gt;u.file
)paren
suffix:semicolon
)brace
DECL|function|config_buf_fgetc
r_static
r_int
id|config_buf_fgetc
c_func
(paren
r_struct
id|config_source
op_star
id|conf
)paren
(brace
r_if
c_cond
(paren
id|conf-&gt;u.buf.pos
OL
id|conf-&gt;u.buf.len
)paren
r_return
id|conf-&gt;u.buf.buf
(braket
id|conf-&gt;u.buf.pos
op_increment
)braket
suffix:semicolon
r_return
id|EOF
suffix:semicolon
)brace
DECL|function|config_buf_ungetc
r_static
r_int
id|config_buf_ungetc
c_func
(paren
r_int
id|c
comma
r_struct
id|config_source
op_star
id|conf
)paren
(brace
r_if
c_cond
(paren
id|conf-&gt;u.buf.pos
OG
l_int|0
)paren
(brace
id|conf-&gt;u.buf.pos
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;u.buf.buf
(braket
id|conf-&gt;u.buf.pos
)braket
op_ne
id|c
)paren
id|die
c_func
(paren
l_string|&quot;BUG: config_buf can only ungetc the same character&quot;
)paren
suffix:semicolon
r_return
id|c
suffix:semicolon
)brace
r_return
id|EOF
suffix:semicolon
)brace
DECL|function|config_buf_ftell
r_static
r_int
id|config_buf_ftell
c_func
(paren
r_struct
id|config_source
op_star
id|conf
)paren
(brace
r_return
id|conf-&gt;u.buf.pos
suffix:semicolon
)brace
DECL|macro|MAX_INCLUDE_DEPTH
mdefine_line|#define MAX_INCLUDE_DEPTH 10
DECL|variable|include_depth_advice
r_static
r_const
r_char
id|include_depth_advice
(braket
)braket
op_assign
l_string|&quot;exceeded maximum include depth (%d) while including&bslash;n&quot;
l_string|&quot;&t;%s&bslash;n&quot;
l_string|&quot;from&bslash;n&quot;
l_string|&quot;&t;%s&bslash;n&quot;
l_string|&quot;Do you have circular includes?&quot;
suffix:semicolon
DECL|function|handle_path_include
r_static
r_int
id|handle_path_include
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_struct
id|config_include_data
op_star
id|inc
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_struct
id|strbuf
id|buf
op_assign
id|STRBUF_INIT
suffix:semicolon
r_char
op_star
id|expanded
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|path
)paren
r_return
id|config_error_nonbool
c_func
(paren
l_string|&quot;include.path&quot;
)paren
suffix:semicolon
id|expanded
op_assign
id|expand_user_path
c_func
(paren
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|expanded
)paren
r_return
id|error
c_func
(paren
l_string|&quot;Could not expand include path &squot;%s&squot;&quot;
comma
id|path
)paren
suffix:semicolon
id|path
op_assign
id|expanded
suffix:semicolon
multiline_comment|/*&n;&t; * Use an absolute path as-is, but interpret relative paths&n;&t; * based on the including config file.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|is_absolute_path
c_func
(paren
id|path
)paren
)paren
(brace
r_char
op_star
id|slash
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cf
op_logical_or
op_logical_neg
id|cf-&gt;path
)paren
r_return
id|error
c_func
(paren
l_string|&quot;relative config includes must come from files&quot;
)paren
suffix:semicolon
id|slash
op_assign
id|find_last_dir_sep
c_func
(paren
id|cf-&gt;path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slash
)paren
id|strbuf_add
c_func
(paren
op_amp
id|buf
comma
id|cf-&gt;path
comma
id|slash
id|cf-&gt;path
op_plus
l_int|1
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|buf
comma
id|path
)paren
suffix:semicolon
id|path
op_assign
id|buf.buf
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|access_or_die
c_func
(paren
id|path
comma
id|R_OK
comma
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
op_increment
id|inc-&gt;depth
OG
id|MAX_INCLUDE_DEPTH
)paren
id|die
c_func
(paren
id|include_depth_advice
comma
id|MAX_INCLUDE_DEPTH
comma
id|path
comma
id|cf
op_logical_and
id|cf-&gt;name
ques
c_cond
id|cf-&gt;name
suffix:colon
l_string|&quot;the command line&quot;
)paren
suffix:semicolon
id|ret
op_assign
id|git_config_from_file
c_func
(paren
id|git_config_include
comma
id|path
comma
id|inc
)paren
suffix:semicolon
id|inc-&gt;depth
op_decrement
suffix:semicolon
)brace
id|strbuf_release
c_func
(paren
op_amp
id|buf
)paren
suffix:semicolon
id|free
c_func
(paren
id|expanded
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|git_config_include
r_int
id|git_config_include
c_func
(paren
r_const
r_char
op_star
id|var
comma
r_const
r_char
op_star
id|value
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|config_include_data
op_star
id|inc
op_assign
id|data
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/*&n;&t; * Pass along all values, including &quot;include&quot; directives; this makes it&n;&t; * possible to query information on the includes themselves.&n;&t; */
id|ret
op_assign
id|inc
op_member_access_from_pointer
id|fn
c_func
(paren
id|var
comma
id|value
comma
id|inc-&gt;data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;include.path&quot;
)paren
)paren
id|ret
op_assign
id|handle_path_include
c_func
(paren
id|value
comma
id|inc
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|git_config_push_parameter
r_void
id|git_config_push_parameter
c_func
(paren
r_const
r_char
op_star
id|text
)paren
(brace
r_struct
id|strbuf
id|env
op_assign
id|STRBUF_INIT
suffix:semicolon
r_const
r_char
op_star
id|old
op_assign
id|getenv
c_func
(paren
id|CONFIG_DATA_ENVIRONMENT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old
)paren
(brace
id|strbuf_addstr
c_func
(paren
op_amp
id|env
comma
id|old
)paren
suffix:semicolon
id|strbuf_addch
c_func
(paren
op_amp
id|env
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
)brace
id|sq_quote_buf
c_func
(paren
op_amp
id|env
comma
id|text
)paren
suffix:semicolon
id|setenv
c_func
(paren
id|CONFIG_DATA_ENVIRONMENT
comma
id|env.buf
comma
l_int|1
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|env
)paren
suffix:semicolon
)brace
DECL|function|git_config_parse_parameter
r_int
id|git_config_parse_parameter
c_func
(paren
r_const
r_char
op_star
id|text
comma
id|config_fn_t
id|fn
comma
r_void
op_star
id|data
)paren
(brace
r_const
r_char
op_star
id|value
suffix:semicolon
r_struct
id|strbuf
op_star
op_star
id|pair
suffix:semicolon
id|pair
op_assign
id|strbuf_split_str
c_func
(paren
id|text
comma
l_char|&squot;=&squot;
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pair
(braket
l_int|0
)braket
)paren
r_return
id|error
c_func
(paren
l_string|&quot;bogus config parameter: %s&quot;
comma
id|text
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pair
(braket
l_int|0
)braket
op_member_access_from_pointer
id|len
op_logical_and
id|pair
(braket
l_int|0
)braket
op_member_access_from_pointer
id|buf
(braket
id|pair
(braket
l_int|0
)braket
op_member_access_from_pointer
id|len
l_int|1
)braket
op_eq
l_char|&squot;=&squot;
)paren
(brace
id|strbuf_setlen
c_func
(paren
id|pair
(braket
l_int|0
)braket
comma
id|pair
(braket
l_int|0
)braket
op_member_access_from_pointer
id|len
l_int|1
)paren
suffix:semicolon
id|value
op_assign
id|pair
(braket
l_int|1
)braket
ques
c_cond
id|pair
(braket
l_int|1
)braket
op_member_access_from_pointer
id|buf
suffix:colon
l_string|&quot;&quot;
suffix:semicolon
)brace
r_else
(brace
id|value
op_assign
l_int|NULL
suffix:semicolon
)brace
id|strbuf_trim
c_func
(paren
id|pair
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pair
(braket
l_int|0
)braket
op_member_access_from_pointer
id|len
)paren
(brace
id|strbuf_list_free
c_func
(paren
id|pair
)paren
suffix:semicolon
r_return
id|error
c_func
(paren
l_string|&quot;bogus config parameter: %s&quot;
comma
id|text
)paren
suffix:semicolon
)brace
id|strbuf_tolower
c_func
(paren
id|pair
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fn
c_func
(paren
id|pair
(braket
l_int|0
)braket
op_member_access_from_pointer
id|buf
comma
id|value
comma
id|data
)paren
OL
l_int|0
)paren
(brace
id|strbuf_list_free
c_func
(paren
id|pair
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|strbuf_list_free
c_func
(paren
id|pair
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|git_config_from_parameters
r_int
id|git_config_from_parameters
c_func
(paren
id|config_fn_t
id|fn
comma
r_void
op_star
id|data
)paren
(brace
r_const
r_char
op_star
id|env
op_assign
id|getenv
c_func
(paren
id|CONFIG_DATA_ENVIRONMENT
)paren
suffix:semicolon
r_char
op_star
id|envw
suffix:semicolon
r_const
r_char
op_star
op_star
id|argv
op_assign
l_int|NULL
suffix:semicolon
r_int
id|nr
op_assign
l_int|0
comma
id|alloc
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|env
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* sq_dequote will write over it */
id|envw
op_assign
id|xstrdup
c_func
(paren
id|env
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sq_dequote_to_argv
c_func
(paren
id|envw
comma
op_amp
id|argv
comma
op_amp
id|nr
comma
op_amp
id|alloc
)paren
OL
l_int|0
)paren
(brace
id|free
c_func
(paren
id|envw
)paren
suffix:semicolon
r_return
id|error
c_func
(paren
l_string|&quot;bogus format in &quot;
id|CONFIG_DATA_ENVIRONMENT
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|git_config_parse_parameter
c_func
(paren
id|argv
(braket
id|i
)braket
comma
id|fn
comma
id|data
)paren
OL
l_int|0
)paren
(brace
id|free
c_func
(paren
id|argv
)paren
suffix:semicolon
id|free
c_func
(paren
id|envw
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
id|free
c_func
(paren
id|argv
)paren
suffix:semicolon
id|free
c_func
(paren
id|envw
)paren
suffix:semicolon
r_return
id|nr
OG
l_int|0
suffix:semicolon
)brace
DECL|function|get_next_char
r_static
r_int
id|get_next_char
c_func
(paren
r_void
)paren
(brace
r_int
id|c
op_assign
id|cf
op_member_access_from_pointer
id|do_fgetc
c_func
(paren
id|cf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;r&squot;
)paren
(brace
multiline_comment|/* DOS like systems */
id|c
op_assign
id|cf
op_member_access_from_pointer
id|do_fgetc
c_func
(paren
id|cf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
r_if
c_cond
(paren
id|c
op_ne
id|EOF
)paren
id|cf
op_member_access_from_pointer
id|do_ungetc
c_func
(paren
id|c
comma
id|cf
)paren
suffix:semicolon
id|c
op_assign
l_char|&squot;&bslash;r&squot;
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|cf-&gt;linenr
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
id|EOF
)paren
(brace
id|cf-&gt;eof
op_assign
l_int|1
suffix:semicolon
id|cf-&gt;linenr
op_increment
suffix:semicolon
id|c
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
)brace
r_return
id|c
suffix:semicolon
)brace
DECL|function|parse_value
r_static
r_char
op_star
id|parse_value
c_func
(paren
r_void
)paren
(brace
r_int
id|quote
op_assign
l_int|0
comma
id|comment
op_assign
l_int|0
comma
id|space
op_assign
l_int|0
suffix:semicolon
id|strbuf_reset
c_func
(paren
op_amp
id|cf-&gt;value
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|c
op_assign
id|get_next_char
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
r_if
c_cond
(paren
id|quote
)paren
(brace
id|cf-&gt;linenr
op_decrement
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|cf-&gt;value.buf
suffix:semicolon
)brace
r_if
c_cond
(paren
id|comment
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|isspace
c_func
(paren
id|c
)paren
op_logical_and
op_logical_neg
id|quote
)paren
(brace
r_if
c_cond
(paren
id|cf-&gt;value.len
)paren
id|space
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|quote
)paren
(brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;;&squot;
op_logical_or
id|c
op_eq
l_char|&squot;#&squot;
)paren
(brace
id|comment
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
suffix:semicolon
id|space
suffix:semicolon
id|space
op_decrement
)paren
id|strbuf_addch
c_func
(paren
op_amp
id|cf-&gt;value
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;&bslash;&squot;
)paren
(brace
id|c
op_assign
id|get_next_char
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
l_char|&squot;&bslash;n&squot;
suffix:colon
r_continue
suffix:semicolon
r_case
l_char|&squot;t&squot;
suffix:colon
id|c
op_assign
l_char|&squot;&bslash;t&squot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;b&squot;
suffix:colon
id|c
op_assign
l_char|&squot;&bslash;b&squot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;n&squot;
suffix:colon
id|c
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Some characters escape as themselves */
r_case
l_char|&squot;&bslash;&bslash;&squot;
suffix:colon
r_case
l_char|&squot;&quot;&squot;
suffix:colon
r_break
suffix:semicolon
multiline_comment|/* Reject unknown escape sequences */
r_default
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
id|strbuf_addch
c_func
(paren
op_amp
id|cf-&gt;value
comma
id|c
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&quot;&squot;
)paren
(brace
id|quote
op_assign
l_int|1
op_minus
id|quote
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|strbuf_addch
c_func
(paren
op_amp
id|cf-&gt;value
comma
id|c
)paren
suffix:semicolon
)brace
)brace
DECL|function|iskeychar
r_static
r_inline
r_int
id|iskeychar
c_func
(paren
r_int
id|c
)paren
(brace
r_return
id|isalnum
c_func
(paren
id|c
)paren
op_logical_or
id|c
op_eq
l_char|&squot;-&squot;
suffix:semicolon
)brace
DECL|function|get_value
r_static
r_int
id|get_value
c_func
(paren
id|config_fn_t
id|fn
comma
r_void
op_star
id|data
comma
r_struct
id|strbuf
op_star
id|name
)paren
(brace
r_int
id|c
suffix:semicolon
r_char
op_star
id|value
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* Get the full name */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|c
op_assign
id|get_next_char
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cf-&gt;eof
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|iskeychar
c_func
(paren
id|c
)paren
)paren
r_break
suffix:semicolon
id|strbuf_addch
c_func
(paren
id|name
comma
id|tolower
c_func
(paren
id|c
)paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|c
op_eq
l_char|&squot; &squot;
op_logical_or
id|c
op_eq
l_char|&squot;&bslash;t&squot;
)paren
id|c
op_assign
id|get_next_char
c_func
(paren
)paren
suffix:semicolon
id|value
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|c
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
r_if
c_cond
(paren
id|c
op_ne
l_char|&squot;=&squot;
)paren
r_return
l_int|1
suffix:semicolon
id|value
op_assign
id|parse_value
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We already consumed the &bslash;n, but we need linenr to point to&n;&t; * the line we just parsed during the call to fn to get&n;&t; * accurate line number in error messages.&n;&t; */
id|cf-&gt;linenr
op_decrement
suffix:semicolon
id|ret
op_assign
id|fn
c_func
(paren
id|name-&gt;buf
comma
id|value
comma
id|data
)paren
suffix:semicolon
id|cf-&gt;linenr
op_increment
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|get_extended_base_var
r_static
r_int
id|get_extended_base_var
c_func
(paren
r_struct
id|strbuf
op_star
id|name
comma
r_int
id|c
)paren
(brace
r_do
(brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
r_goto
id|error_incomplete_line
suffix:semicolon
id|c
op_assign
id|get_next_char
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|isspace
c_func
(paren
id|c
)paren
)paren
suffix:semicolon
multiline_comment|/* We require the format to be &squot;[base &quot;extension&quot;]&squot; */
r_if
c_cond
(paren
id|c
op_ne
l_char|&squot;&quot;&squot;
)paren
r_return
l_int|1
suffix:semicolon
id|strbuf_addch
c_func
(paren
id|name
comma
l_char|&squot;.&squot;
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|c
op_assign
id|get_next_char
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
r_goto
id|error_incomplete_line
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&quot;&squot;
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;&bslash;&squot;
)paren
(brace
id|c
op_assign
id|get_next_char
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
r_goto
id|error_incomplete_line
suffix:semicolon
)brace
id|strbuf_addch
c_func
(paren
id|name
comma
id|c
)paren
suffix:semicolon
)brace
multiline_comment|/* Final &squot;]&squot; */
r_if
c_cond
(paren
id|get_next_char
c_func
(paren
)paren
op_ne
l_char|&squot;]&squot;
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|error_incomplete_line
suffix:colon
id|cf-&gt;linenr
op_decrement
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|get_base_var
r_static
r_int
id|get_base_var
c_func
(paren
r_struct
id|strbuf
op_star
id|name
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|c
op_assign
id|get_next_char
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cf-&gt;eof
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;]&squot;
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|isspace
c_func
(paren
id|c
)paren
)paren
r_return
id|get_extended_base_var
c_func
(paren
id|name
comma
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|iskeychar
c_func
(paren
id|c
)paren
op_logical_and
id|c
op_ne
l_char|&squot;.&squot;
)paren
r_return
l_int|1
suffix:semicolon
id|strbuf_addch
c_func
(paren
id|name
comma
id|tolower
c_func
(paren
id|c
)paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|git_parse_source
r_static
r_int
id|git_parse_source
c_func
(paren
id|config_fn_t
id|fn
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|comment
op_assign
l_int|0
suffix:semicolon
r_int
id|baselen
op_assign
l_int|0
suffix:semicolon
r_struct
id|strbuf
op_star
id|var
op_assign
op_amp
id|cf-&gt;var
suffix:semicolon
multiline_comment|/* U+FEFF Byte Order Mark in UTF8 */
r_const
r_char
op_star
id|bomptr
op_assign
id|utf8_bom
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|c
op_assign
id|get_next_char
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bomptr
op_logical_and
op_star
id|bomptr
)paren
(brace
multiline_comment|/* We are at the file beginning; skip UTF8-encoded BOM&n;&t;&t;&t; * if present. Sane editors won&squot;t put this in on their&n;&t;&t;&t; * own, but e.g. Windows Notepad will do it happily. */
r_if
c_cond
(paren
id|c
op_eq
(paren
op_star
id|bomptr
op_amp
l_int|0377
)paren
)paren
(brace
id|bomptr
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Do not tolerate partial BOM. */
r_if
c_cond
(paren
id|bomptr
op_ne
id|utf8_bom
)paren
r_break
suffix:semicolon
multiline_comment|/* No BOM at file beginning. Cool. */
id|bomptr
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
r_if
c_cond
(paren
id|cf-&gt;eof
)paren
r_return
l_int|0
suffix:semicolon
id|comment
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|comment
op_logical_or
id|isspace
c_func
(paren
id|c
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;#&squot;
op_logical_or
id|c
op_eq
l_char|&squot;;&squot;
)paren
(brace
id|comment
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;[&squot;
)paren
(brace
multiline_comment|/* Reset prior to determining a new stem */
id|strbuf_reset
c_func
(paren
id|var
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_base_var
c_func
(paren
id|var
)paren
OL
l_int|0
op_logical_or
id|var-&gt;len
OL
l_int|1
)paren
r_break
suffix:semicolon
id|strbuf_addch
c_func
(paren
id|var
comma
l_char|&squot;.&squot;
)paren
suffix:semicolon
id|baselen
op_assign
id|var-&gt;len
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|isalpha
c_func
(paren
id|c
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Truncate the var name back to the section header&n;&t;&t; * stem prior to grabbing the suffix part of the name&n;&t;&t; * and the value.&n;&t;&t; */
id|strbuf_setlen
c_func
(paren
id|var
comma
id|baselen
)paren
suffix:semicolon
id|strbuf_addch
c_func
(paren
id|var
comma
id|tolower
c_func
(paren
id|c
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_value
c_func
(paren
id|fn
comma
id|data
comma
id|var
)paren
OL
l_int|0
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cf-&gt;die_on_error
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;bad config file line %d in %s&quot;
)paren
comma
id|cf-&gt;linenr
comma
id|cf-&gt;name
)paren
suffix:semicolon
r_else
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;bad config file line %d in %s&quot;
)paren
comma
id|cf-&gt;linenr
comma
id|cf-&gt;name
)paren
suffix:semicolon
)brace
DECL|function|parse_unit_factor
r_static
r_int
id|parse_unit_factor
c_func
(paren
r_const
r_char
op_star
id|end
comma
r_uintmax
op_star
id|val
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|end
)paren
r_return
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcasecmp
c_func
(paren
id|end
comma
l_string|&quot;k&quot;
)paren
)paren
(brace
op_star
id|val
op_mul_assign
l_int|1024
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcasecmp
c_func
(paren
id|end
comma
l_string|&quot;m&quot;
)paren
)paren
(brace
op_star
id|val
op_mul_assign
l_int|1024
op_star
l_int|1024
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcasecmp
c_func
(paren
id|end
comma
l_string|&quot;g&quot;
)paren
)paren
(brace
op_star
id|val
op_mul_assign
l_int|1024
op_star
l_int|1024
op_star
l_int|1024
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|git_parse_signed
r_static
r_int
id|git_parse_signed
c_func
(paren
r_const
r_char
op_star
id|value
comma
r_intmax
op_star
id|ret
comma
r_intmax
id|max
)paren
(brace
r_if
c_cond
(paren
id|value
op_logical_and
op_star
id|value
)paren
(brace
r_char
op_star
id|end
suffix:semicolon
r_intmax
id|val
suffix:semicolon
r_uintmax
id|uval
suffix:semicolon
r_uintmax
id|factor
op_assign
l_int|1
suffix:semicolon
id|errno
op_assign
l_int|0
suffix:semicolon
id|val
op_assign
id|strtoimax
c_func
(paren
id|value
comma
op_amp
id|end
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|errno
op_eq
id|ERANGE
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parse_unit_factor
c_func
(paren
id|end
comma
op_amp
id|factor
)paren
)paren
(brace
id|errno
op_assign
id|EINVAL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|uval
op_assign
id|labs
c_func
(paren
id|val
)paren
suffix:semicolon
id|uval
op_mul_assign
id|factor
suffix:semicolon
r_if
c_cond
(paren
id|uval
OG
id|max
op_logical_or
id|labs
c_func
(paren
id|val
)paren
OG
id|uval
)paren
(brace
id|errno
op_assign
id|ERANGE
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|val
op_mul_assign
id|factor
suffix:semicolon
op_star
id|ret
op_assign
id|val
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|errno
op_assign
id|EINVAL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|git_parse_unsigned
r_static
r_int
id|git_parse_unsigned
c_func
(paren
r_const
r_char
op_star
id|value
comma
r_uintmax
op_star
id|ret
comma
r_uintmax
id|max
)paren
(brace
r_if
c_cond
(paren
id|value
op_logical_and
op_star
id|value
)paren
(brace
r_char
op_star
id|end
suffix:semicolon
r_uintmax
id|val
suffix:semicolon
r_uintmax
id|oldval
suffix:semicolon
id|errno
op_assign
l_int|0
suffix:semicolon
id|val
op_assign
id|strtoumax
c_func
(paren
id|value
comma
op_amp
id|end
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|errno
op_eq
id|ERANGE
)paren
r_return
l_int|0
suffix:semicolon
id|oldval
op_assign
id|val
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parse_unit_factor
c_func
(paren
id|end
comma
op_amp
id|val
)paren
)paren
(brace
id|errno
op_assign
id|EINVAL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|val
OG
id|max
op_logical_or
id|oldval
OG
id|val
)paren
(brace
id|errno
op_assign
id|ERANGE
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
op_star
id|ret
op_assign
id|val
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|errno
op_assign
id|EINVAL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|git_parse_int
r_static
r_int
id|git_parse_int
c_func
(paren
r_const
r_char
op_star
id|value
comma
r_int
op_star
id|ret
)paren
(brace
r_intmax
id|tmp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|git_parse_signed
c_func
(paren
id|value
comma
op_amp
id|tmp
comma
id|maximum_signed_value_of_type
c_func
(paren
r_int
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|ret
op_assign
id|tmp
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|git_parse_int64
r_static
r_int
id|git_parse_int64
c_func
(paren
r_const
r_char
op_star
id|value
comma
r_int64
op_star
id|ret
)paren
(brace
r_intmax
id|tmp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|git_parse_signed
c_func
(paren
id|value
comma
op_amp
id|tmp
comma
id|maximum_signed_value_of_type
c_func
(paren
r_int64
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|ret
op_assign
id|tmp
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|git_parse_ulong
r_int
id|git_parse_ulong
c_func
(paren
r_const
r_char
op_star
id|value
comma
r_int
r_int
op_star
id|ret
)paren
(brace
r_uintmax
id|tmp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|git_parse_unsigned
c_func
(paren
id|value
comma
op_amp
id|tmp
comma
id|maximum_unsigned_value_of_type
c_func
(paren
r_int
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|ret
op_assign
id|tmp
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|NORETURN
DECL|function|die_bad_number
r_static
r_void
id|die_bad_number
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_const
r_char
op_star
id|reason
op_assign
id|errno
op_eq
id|ERANGE
ques
c_cond
l_string|&quot;out of range&quot;
suffix:colon
l_string|&quot;invalid unit&quot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
id|value
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_if
c_cond
(paren
id|cf
op_logical_and
id|cf-&gt;name
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;bad numeric config value &squot;%s&squot; for &squot;%s&squot; in %s: %s&quot;
)paren
comma
id|value
comma
id|name
comma
id|cf-&gt;name
comma
id|reason
)paren
suffix:semicolon
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;bad numeric config value &squot;%s&squot; for &squot;%s&squot;: %s&quot;
)paren
comma
id|value
comma
id|name
comma
id|reason
)paren
suffix:semicolon
)brace
DECL|function|git_config_int
r_int
id|git_config_int
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|git_parse_int
c_func
(paren
id|value
comma
op_amp
id|ret
)paren
)paren
id|die_bad_number
c_func
(paren
id|name
comma
id|value
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|git_config_int64
r_int64
id|git_config_int64
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_int64
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|git_parse_int64
c_func
(paren
id|value
comma
op_amp
id|ret
)paren
)paren
id|die_bad_number
c_func
(paren
id|name
comma
id|value
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|git_config_ulong
r_int
r_int
id|git_config_ulong
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_int
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|git_parse_ulong
c_func
(paren
id|value
comma
op_amp
id|ret
)paren
)paren
id|die_bad_number
c_func
(paren
id|name
comma
id|value
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|git_config_maybe_bool_text
r_static
r_int
id|git_config_maybe_bool_text
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|value
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;true&quot;
)paren
op_logical_or
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;yes&quot;
)paren
op_logical_or
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;on&quot;
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;false&quot;
)paren
op_logical_or
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;no&quot;
)paren
op_logical_or
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;off&quot;
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|git_config_maybe_bool
r_int
id|git_config_maybe_bool
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_int
id|v
op_assign
id|git_config_maybe_bool_text
c_func
(paren
id|name
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_le
id|v
)paren
r_return
id|v
suffix:semicolon
r_if
c_cond
(paren
id|git_parse_int
c_func
(paren
id|value
comma
op_amp
id|v
)paren
)paren
r_return
op_logical_neg
op_logical_neg
id|v
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|git_config_bool_or_int
r_int
id|git_config_bool_or_int
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_const
r_char
op_star
id|value
comma
r_int
op_star
id|is_bool
)paren
(brace
r_int
id|v
op_assign
id|git_config_maybe_bool_text
c_func
(paren
id|name
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_le
id|v
)paren
(brace
op_star
id|is_bool
op_assign
l_int|1
suffix:semicolon
r_return
id|v
suffix:semicolon
)brace
op_star
id|is_bool
op_assign
l_int|0
suffix:semicolon
r_return
id|git_config_int
c_func
(paren
id|name
comma
id|value
)paren
suffix:semicolon
)brace
DECL|function|git_config_bool
r_int
id|git_config_bool
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_int
id|discard
suffix:semicolon
r_return
op_logical_neg
op_logical_neg
id|git_config_bool_or_int
c_func
(paren
id|name
comma
id|value
comma
op_amp
id|discard
)paren
suffix:semicolon
)brace
DECL|function|git_config_string
r_int
id|git_config_string
c_func
(paren
r_const
r_char
op_star
op_star
id|dest
comma
r_const
r_char
op_star
id|var
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
r_return
id|config_error_nonbool
c_func
(paren
id|var
)paren
suffix:semicolon
op_star
id|dest
op_assign
id|xstrdup
c_func
(paren
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|git_config_pathname
r_int
id|git_config_pathname
c_func
(paren
r_const
r_char
op_star
op_star
id|dest
comma
r_const
r_char
op_star
id|var
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
r_return
id|config_error_nonbool
c_func
(paren
id|var
)paren
suffix:semicolon
op_star
id|dest
op_assign
id|expand_user_path
c_func
(paren
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|dest
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;failed to expand user dir in: &squot;%s&squot;&quot;
)paren
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|git_default_core_config
r_static
r_int
id|git_default_core_config
c_func
(paren
r_const
r_char
op_star
id|var
comma
r_const
r_char
op_star
id|value
)paren
(brace
multiline_comment|/* This needs a better name */
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.filemode&quot;
)paren
)paren
(brace
id|trust_executable_bit
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.trustctime&quot;
)paren
)paren
(brace
id|trust_ctime
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.checkstat&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;default&quot;
)paren
)paren
id|check_stat
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;minimal&quot;
)paren
)paren
id|check_stat
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.quotepath&quot;
)paren
)paren
(brace
id|quote_path_fully
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.symlinks&quot;
)paren
)paren
(brace
id|has_symlinks
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.ignorecase&quot;
)paren
)paren
(brace
id|ignore_case
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.attributesfile&quot;
)paren
)paren
r_return
id|git_config_pathname
c_func
(paren
op_amp
id|git_attributes_file
comma
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.bare&quot;
)paren
)paren
(brace
id|is_bare_repository_cfg
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.ignorestat&quot;
)paren
)paren
(brace
id|assume_unchanged
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.prefersymlinkrefs&quot;
)paren
)paren
(brace
id|prefer_symlink_refs
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.logallrefupdates&quot;
)paren
)paren
(brace
id|log_all_ref_updates
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.warnambiguousrefs&quot;
)paren
)paren
(brace
id|warn_ambiguous_refs
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.abbrev&quot;
)paren
)paren
(brace
r_int
id|abbrev
op_assign
id|git_config_int
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|abbrev
template_param
l_int|40
)paren
r_return
l_int|1
suffix:semicolon
id|default_abbrev
op_assign
id|abbrev
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.loosecompression&quot;
)paren
)paren
(brace
r_int
id|level
op_assign
id|git_config_int
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|level
op_eq
l_int|1
)paren
id|level
op_assign
id|Z_DEFAULT_COMPRESSION
suffix:semicolon
r_else
r_if
c_cond
(paren
id|level
template_param
id|Z_BEST_COMPRESSION
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;bad zlib compression level %d&quot;
)paren
comma
id|level
)paren
suffix:semicolon
id|zlib_compression_level
op_assign
id|level
suffix:semicolon
id|zlib_compression_seen
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.compression&quot;
)paren
)paren
(brace
r_int
id|level
op_assign
id|git_config_int
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|level
op_eq
l_int|1
)paren
id|level
op_assign
id|Z_DEFAULT_COMPRESSION
suffix:semicolon
r_else
r_if
c_cond
(paren
id|level
template_param
id|Z_BEST_COMPRESSION
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;bad zlib compression level %d&quot;
)paren
comma
id|level
)paren
suffix:semicolon
id|core_compression_level
op_assign
id|level
suffix:semicolon
id|core_compression_seen
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|zlib_compression_seen
)paren
id|zlib_compression_level
op_assign
id|level
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.packedgitwindowsize&quot;
)paren
)paren
(brace
r_int
id|pgsz_x2
op_assign
id|getpagesize
c_func
(paren
)paren
op_star
l_int|2
suffix:semicolon
id|packed_git_window_size
op_assign
id|git_config_ulong
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
multiline_comment|/* This value must be multiple of (pagesize * 2) */
id|packed_git_window_size
op_div_assign
id|pgsz_x2
suffix:semicolon
r_if
c_cond
(paren
id|packed_git_window_size
OL
l_int|1
)paren
id|packed_git_window_size
op_assign
l_int|1
suffix:semicolon
id|packed_git_window_size
op_mul_assign
id|pgsz_x2
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.bigfilethreshold&quot;
)paren
)paren
(brace
id|big_file_threshold
op_assign
id|git_config_ulong
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.packedgitlimit&quot;
)paren
)paren
(brace
id|packed_git_limit
op_assign
id|git_config_ulong
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.deltabasecachelimit&quot;
)paren
)paren
(brace
id|delta_base_cache_limit
op_assign
id|git_config_ulong
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.autocrlf&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|value
op_logical_and
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;input&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|core_eol
op_eq
id|EOL_CRLF
)paren
r_return
id|error
c_func
(paren
l_string|&quot;core.autocrlf=input conflicts with core.eol=crlf&quot;
)paren
suffix:semicolon
id|auto_crlf
op_assign
id|AUTO_CRLF_INPUT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|auto_crlf
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.safecrlf&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|value
op_logical_and
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;warn&quot;
)paren
)paren
(brace
id|safe_crlf
op_assign
id|SAFE_CRLF_WARN
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|safe_crlf
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.eol&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|value
op_logical_and
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;lf&quot;
)paren
)paren
id|core_eol
op_assign
id|EOL_LF
suffix:semicolon
r_else
r_if
c_cond
(paren
id|value
op_logical_and
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;crlf&quot;
)paren
)paren
id|core_eol
op_assign
id|EOL_CRLF
suffix:semicolon
r_else
r_if
c_cond
(paren
id|value
op_logical_and
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;native&quot;
)paren
)paren
id|core_eol
op_assign
id|EOL_NATIVE
suffix:semicolon
r_else
id|core_eol
op_assign
id|EOL_UNSET
suffix:semicolon
r_if
c_cond
(paren
id|core_eol
op_eq
id|EOL_CRLF
op_logical_and
id|auto_crlf
op_eq
id|AUTO_CRLF_INPUT
)paren
r_return
id|error
c_func
(paren
l_string|&quot;core.autocrlf=input conflicts with core.eol=crlf&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.notesref&quot;
)paren
)paren
(brace
id|notes_ref_name
op_assign
id|xstrdup
c_func
(paren
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.pager&quot;
)paren
)paren
r_return
id|git_config_string
c_func
(paren
op_amp
id|pager_program
comma
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.editor&quot;
)paren
)paren
r_return
id|git_config_string
c_func
(paren
op_amp
id|editor_program
comma
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.commentchar&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
r_return
id|config_error_nonbool
c_func
(paren
id|var
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;auto&quot;
)paren
)paren
id|auto_comment_line_char
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|value
(braket
l_int|0
)braket
op_logical_and
op_logical_neg
id|value
(braket
l_int|1
)braket
)paren
(brace
id|comment_line_char
op_assign
id|value
(braket
l_int|0
)braket
suffix:semicolon
id|auto_comment_line_char
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_return
id|error
c_func
(paren
l_string|&quot;core.commentChar should only be one character&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.askpass&quot;
)paren
)paren
r_return
id|git_config_string
c_func
(paren
op_amp
id|askpass_program
comma
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.excludesfile&quot;
)paren
)paren
r_return
id|git_config_pathname
c_func
(paren
op_amp
id|excludes_file
comma
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.whitespace&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
r_return
id|config_error_nonbool
c_func
(paren
id|var
)paren
suffix:semicolon
id|whitespace_rule_cfg
op_assign
id|parse_whitespace_rule
c_func
(paren
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.fsyncobjectfiles&quot;
)paren
)paren
(brace
id|fsync_object_files
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.preloadindex&quot;
)paren
)paren
(brace
id|core_preload_index
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.createobject&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|value
comma
l_string|&quot;rename&quot;
)paren
)paren
id|object_creation_mode
op_assign
id|OBJECT_CREATION_USES_RENAMES
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|value
comma
l_string|&quot;link&quot;
)paren
)paren
id|object_creation_mode
op_assign
id|OBJECT_CREATION_USES_HARDLINKS
suffix:semicolon
r_else
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;invalid mode for object creation: %s&quot;
)paren
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.sparsecheckout&quot;
)paren
)paren
(brace
id|core_apply_sparse_checkout
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.precomposeunicode&quot;
)paren
)paren
(brace
id|precomposed_unicode
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.protecthfs&quot;
)paren
)paren
(brace
id|protect_hfs
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;core.protectntfs&quot;
)paren
)paren
(brace
id|protect_ntfs
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Add other config variables here and to Documentation/config.txt. */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|git_default_i18n_config
r_static
r_int
id|git_default_i18n_config
c_func
(paren
r_const
r_char
op_star
id|var
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;i18n.commitencoding&quot;
)paren
)paren
r_return
id|git_config_string
c_func
(paren
op_amp
id|git_commit_encoding
comma
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;i18n.logoutputencoding&quot;
)paren
)paren
r_return
id|git_config_string
c_func
(paren
op_amp
id|git_log_output_encoding
comma
id|var
comma
id|value
)paren
suffix:semicolon
multiline_comment|/* Add other config variables here and to Documentation/config.txt. */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|git_default_branch_config
r_static
r_int
id|git_default_branch_config
c_func
(paren
r_const
r_char
op_star
id|var
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;branch.autosetupmerge&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|value
op_logical_and
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;always&quot;
)paren
)paren
(brace
id|git_branch_track
op_assign
id|BRANCH_TRACK_ALWAYS
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|git_branch_track
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;branch.autosetuprebase&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
r_return
id|config_error_nonbool
c_func
(paren
id|var
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|value
comma
l_string|&quot;never&quot;
)paren
)paren
id|autorebase
op_assign
id|AUTOREBASE_NEVER
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|value
comma
l_string|&quot;local&quot;
)paren
)paren
id|autorebase
op_assign
id|AUTOREBASE_LOCAL
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|value
comma
l_string|&quot;remote&quot;
)paren
)paren
id|autorebase
op_assign
id|AUTOREBASE_REMOTE
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|value
comma
l_string|&quot;always&quot;
)paren
)paren
id|autorebase
op_assign
id|AUTOREBASE_ALWAYS
suffix:semicolon
r_else
r_return
id|error
c_func
(paren
l_string|&quot;Malformed value for %s&quot;
comma
id|var
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Add other config variables here and to Documentation/config.txt. */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|git_default_push_config
r_static
r_int
id|git_default_push_config
c_func
(paren
r_const
r_char
op_star
id|var
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;push.default&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
r_return
id|config_error_nonbool
c_func
(paren
id|var
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|value
comma
l_string|&quot;nothing&quot;
)paren
)paren
id|push_default
op_assign
id|PUSH_DEFAULT_NOTHING
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|value
comma
l_string|&quot;matching&quot;
)paren
)paren
id|push_default
op_assign
id|PUSH_DEFAULT_MATCHING
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|value
comma
l_string|&quot;simple&quot;
)paren
)paren
id|push_default
op_assign
id|PUSH_DEFAULT_SIMPLE
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|value
comma
l_string|&quot;upstream&quot;
)paren
)paren
id|push_default
op_assign
id|PUSH_DEFAULT_UPSTREAM
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|value
comma
l_string|&quot;tracking&quot;
)paren
)paren
multiline_comment|/* deprecated */
id|push_default
op_assign
id|PUSH_DEFAULT_UPSTREAM
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|value
comma
l_string|&quot;current&quot;
)paren
)paren
id|push_default
op_assign
id|PUSH_DEFAULT_CURRENT
suffix:semicolon
r_else
(brace
id|error
c_func
(paren
l_string|&quot;Malformed value for %s: %s&quot;
comma
id|var
comma
id|value
)paren
suffix:semicolon
r_return
id|error
c_func
(paren
l_string|&quot;Must be one of nothing, matching, simple, &quot;
l_string|&quot;upstream or current.&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Add other config variables here and to Documentation/config.txt. */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|git_default_mailmap_config
r_static
r_int
id|git_default_mailmap_config
c_func
(paren
r_const
r_char
op_star
id|var
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;mailmap.file&quot;
)paren
)paren
r_return
id|git_config_pathname
c_func
(paren
op_amp
id|git_mailmap_file
comma
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;mailmap.blob&quot;
)paren
)paren
r_return
id|git_config_string
c_func
(paren
op_amp
id|git_mailmap_blob
comma
id|var
comma
id|value
)paren
suffix:semicolon
multiline_comment|/* Add other config variables here and to Documentation/config.txt. */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|git_default_config
r_int
id|git_default_config
c_func
(paren
r_const
r_char
op_star
id|var
comma
r_const
r_char
op_star
id|value
comma
r_void
op_star
id|dummy
)paren
(brace
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|var
comma
l_string|&quot;core.&quot;
)paren
)paren
r_return
id|git_default_core_config
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|var
comma
l_string|&quot;user.&quot;
)paren
)paren
r_return
id|git_ident_config
c_func
(paren
id|var
comma
id|value
comma
id|dummy
)paren
suffix:semicolon
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|var
comma
l_string|&quot;i18n.&quot;
)paren
)paren
r_return
id|git_default_i18n_config
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|var
comma
l_string|&quot;branch.&quot;
)paren
)paren
r_return
id|git_default_branch_config
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|var
comma
l_string|&quot;push.&quot;
)paren
)paren
r_return
id|git_default_push_config
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|var
comma
l_string|&quot;mailmap.&quot;
)paren
)paren
r_return
id|git_default_mailmap_config
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|var
comma
l_string|&quot;advice.&quot;
)paren
)paren
r_return
id|git_default_advice_config
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;pager.color&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;color.pager&quot;
)paren
)paren
(brace
id|pager_use_color
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;pack.packsizelimit&quot;
)paren
)paren
(brace
id|pack_size_limit_cfg
op_assign
id|git_config_ulong
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Add other config variables here and to Documentation/config.txt. */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * All source specific fields in the union, die_on_error, name and the callbacks&n; * fgetc, ungetc, ftell of top need to be initialized before calling&n; * this function.&n; */
DECL|function|do_config_from
r_static
r_int
id|do_config_from
c_func
(paren
r_struct
id|config_source
op_star
id|top
comma
id|config_fn_t
id|fn
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|ret
suffix:semicolon
multiline_comment|/* push config-file parsing state stack */
id|top-&gt;prev
op_assign
id|cf
suffix:semicolon
id|top-&gt;linenr
op_assign
l_int|1
suffix:semicolon
id|top-&gt;eof
op_assign
l_int|0
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|top-&gt;value
comma
l_int|1024
)paren
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|top-&gt;var
comma
l_int|1024
)paren
suffix:semicolon
id|cf
op_assign
id|top
suffix:semicolon
id|ret
op_assign
id|git_parse_source
c_func
(paren
id|fn
comma
id|data
)paren
suffix:semicolon
multiline_comment|/* pop config-file parsing state stack */
id|strbuf_release
c_func
(paren
op_amp
id|top-&gt;value
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|top-&gt;var
)paren
suffix:semicolon
id|cf
op_assign
id|top-&gt;prev
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|do_config_from_file
r_static
r_int
id|do_config_from_file
c_func
(paren
id|config_fn_t
id|fn
comma
r_const
r_char
op_star
id|name
comma
r_const
r_char
op_star
id|path
comma
id|FILE
op_star
id|f
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|config_source
id|top
suffix:semicolon
id|top.u.file
op_assign
id|f
suffix:semicolon
id|top.name
op_assign
id|name
suffix:semicolon
id|top.path
op_assign
id|path
suffix:semicolon
id|top.die_on_error
op_assign
l_int|1
suffix:semicolon
id|top.do_fgetc
op_assign
id|config_file_fgetc
suffix:semicolon
id|top.do_ungetc
op_assign
id|config_file_ungetc
suffix:semicolon
id|top.do_ftell
op_assign
id|config_file_ftell
suffix:semicolon
r_return
id|do_config_from
c_func
(paren
op_amp
id|top
comma
id|fn
comma
id|data
)paren
suffix:semicolon
)brace
DECL|function|git_config_from_stdin
r_static
r_int
id|git_config_from_stdin
c_func
(paren
id|config_fn_t
id|fn
comma
r_void
op_star
id|data
)paren
(brace
r_return
id|do_config_from_file
c_func
(paren
id|fn
comma
l_string|&quot;&lt;stdin&gt;&quot;
comma
l_int|NULL
comma
id|stdin
comma
id|data
)paren
suffix:semicolon
)brace
DECL|function|git_config_from_file
r_int
id|git_config_from_file
c_func
(paren
id|config_fn_t
id|fn
comma
r_const
r_char
op_star
id|filename
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|ret
op_assign
l_int|1
suffix:semicolon
id|FILE
op_star
id|f
suffix:semicolon
id|f
op_assign
id|fopen
c_func
(paren
id|filename
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|f
)paren
(brace
id|flockfile
c_func
(paren
id|f
)paren
suffix:semicolon
id|ret
op_assign
id|do_config_from_file
c_func
(paren
id|fn
comma
id|filename
comma
id|filename
comma
id|f
comma
id|data
)paren
suffix:semicolon
id|funlockfile
c_func
(paren
id|f
)paren
suffix:semicolon
id|fclose
c_func
(paren
id|f
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|git_config_from_buf
r_int
id|git_config_from_buf
c_func
(paren
id|config_fn_t
id|fn
comma
r_const
r_char
op_star
id|name
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|len
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|config_source
id|top
suffix:semicolon
id|top.u.buf.buf
op_assign
id|buf
suffix:semicolon
id|top.u.buf.len
op_assign
id|len
suffix:semicolon
id|top.u.buf.pos
op_assign
l_int|0
suffix:semicolon
id|top.name
op_assign
id|name
suffix:semicolon
id|top.path
op_assign
l_int|NULL
suffix:semicolon
id|top.die_on_error
op_assign
l_int|0
suffix:semicolon
id|top.do_fgetc
op_assign
id|config_buf_fgetc
suffix:semicolon
id|top.do_ungetc
op_assign
id|config_buf_ungetc
suffix:semicolon
id|top.do_ftell
op_assign
id|config_buf_ftell
suffix:semicolon
r_return
id|do_config_from
c_func
(paren
op_amp
id|top
comma
id|fn
comma
id|data
)paren
suffix:semicolon
)brace
DECL|function|git_config_from_blob_sha1
r_static
r_int
id|git_config_from_blob_sha1
c_func
(paren
id|config_fn_t
id|fn
comma
r_const
r_char
op_star
id|name
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_void
op_star
id|data
)paren
(brace
r_enum
id|object_type
id|type
suffix:semicolon
r_char
op_star
id|buf
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|buf
op_assign
id|read_sha1_file
c_func
(paren
id|sha1
comma
op_amp
id|type
comma
op_amp
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
r_return
id|error
c_func
(paren
l_string|&quot;unable to load config blob object &squot;%s&squot;&quot;
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
id|OBJ_BLOB
)paren
(brace
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
id|error
c_func
(paren
l_string|&quot;reference &squot;%s&squot; does not point to a blob&quot;
comma
id|name
)paren
suffix:semicolon
)brace
id|ret
op_assign
id|git_config_from_buf
c_func
(paren
id|fn
comma
id|name
comma
id|buf
comma
id|size
comma
id|data
)paren
suffix:semicolon
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|git_config_from_blob_ref
r_static
r_int
id|git_config_from_blob_ref
c_func
(paren
id|config_fn_t
id|fn
comma
r_const
r_char
op_star
id|name
comma
r_void
op_star
id|data
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1
c_func
(paren
id|name
comma
id|sha1
)paren
OL
l_int|0
)paren
r_return
id|error
c_func
(paren
l_string|&quot;unable to resolve config blob &squot;%s&squot;&quot;
comma
id|name
)paren
suffix:semicolon
r_return
id|git_config_from_blob_sha1
c_func
(paren
id|fn
comma
id|name
comma
id|sha1
comma
id|data
)paren
suffix:semicolon
)brace
DECL|function|git_etc_gitconfig
r_const
r_char
op_star
id|git_etc_gitconfig
c_func
(paren
r_void
)paren
(brace
r_static
r_const
r_char
op_star
id|system_wide
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|system_wide
)paren
id|system_wide
op_assign
id|system_path
c_func
(paren
id|ETC_GITCONFIG
)paren
suffix:semicolon
r_return
id|system_wide
suffix:semicolon
)brace
multiline_comment|/*&n; * Parse environment variable &squot;k&squot; as a boolean (in various&n; * possible spellings); if missing, use the default value &squot;def&squot;.&n; */
DECL|function|git_env_bool
r_int
id|git_env_bool
c_func
(paren
r_const
r_char
op_star
id|k
comma
r_int
id|def
)paren
(brace
r_const
r_char
op_star
id|v
op_assign
id|getenv
c_func
(paren
id|k
)paren
suffix:semicolon
r_return
id|v
ques
c_cond
id|git_config_bool
c_func
(paren
id|k
comma
id|v
)paren
suffix:colon
id|def
suffix:semicolon
)brace
multiline_comment|/*&n; * Parse environment variable &squot;k&squot; as ulong with possibly a unit&n; * suffix; if missing, use the default value &squot;val&squot;.&n; */
DECL|function|git_env_ulong
r_int
r_int
id|git_env_ulong
c_func
(paren
r_const
r_char
op_star
id|k
comma
r_int
r_int
id|val
)paren
(brace
r_const
r_char
op_star
id|v
op_assign
id|getenv
c_func
(paren
id|k
)paren
suffix:semicolon
r_if
c_cond
(paren
id|v
op_logical_and
op_logical_neg
id|git_parse_ulong
c_func
(paren
id|v
comma
op_amp
id|val
)paren
)paren
id|die
c_func
(paren
l_string|&quot;failed to parse %s&quot;
comma
id|k
)paren
suffix:semicolon
r_return
id|val
suffix:semicolon
)brace
DECL|function|git_config_system
r_int
id|git_config_system
c_func
(paren
r_void
)paren
(brace
r_return
op_logical_neg
id|git_env_bool
c_func
(paren
l_string|&quot;GIT_CONFIG_NOSYSTEM&quot;
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|git_config_early
r_int
id|git_config_early
c_func
(paren
id|config_fn_t
id|fn
comma
r_void
op_star
id|data
comma
r_const
r_char
op_star
id|repo_config
)paren
(brace
r_int
id|ret
op_assign
l_int|0
comma
id|found
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|xdg_config
op_assign
id|xdg_config_home
c_func
(paren
l_string|&quot;config&quot;
)paren
suffix:semicolon
r_char
op_star
id|user_config
op_assign
id|expand_user_path
c_func
(paren
l_string|&quot;~/.gitconfig&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|git_config_system
c_func
(paren
)paren
op_logical_and
op_logical_neg
id|access_or_die
c_func
(paren
id|git_etc_gitconfig
c_func
(paren
)paren
comma
id|R_OK
comma
l_int|0
)paren
)paren
(brace
id|ret
op_add_assign
id|git_config_from_file
c_func
(paren
id|fn
comma
id|git_etc_gitconfig
c_func
(paren
)paren
comma
id|data
)paren
suffix:semicolon
id|found
op_add_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|xdg_config
op_logical_and
op_logical_neg
id|access_or_die
c_func
(paren
id|xdg_config
comma
id|R_OK
comma
id|ACCESS_EACCES_OK
)paren
)paren
(brace
id|ret
op_add_assign
id|git_config_from_file
c_func
(paren
id|fn
comma
id|xdg_config
comma
id|data
)paren
suffix:semicolon
id|found
op_add_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|user_config
op_logical_and
op_logical_neg
id|access_or_die
c_func
(paren
id|user_config
comma
id|R_OK
comma
id|ACCESS_EACCES_OK
)paren
)paren
(brace
id|ret
op_add_assign
id|git_config_from_file
c_func
(paren
id|fn
comma
id|user_config
comma
id|data
)paren
suffix:semicolon
id|found
op_add_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|repo_config
op_logical_and
op_logical_neg
id|access_or_die
c_func
(paren
id|repo_config
comma
id|R_OK
comma
l_int|0
)paren
)paren
(brace
id|ret
op_add_assign
id|git_config_from_file
c_func
(paren
id|fn
comma
id|repo_config
comma
id|data
)paren
suffix:semicolon
id|found
op_add_assign
l_int|1
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|git_config_from_parameters
c_func
(paren
id|fn
comma
id|data
)paren
)paren
(brace
r_case
l_int|1
suffix:colon
multiline_comment|/* error */
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;unable to parse command-line config&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
multiline_comment|/* found nothing */
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* found at least one item */
id|found
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
id|free
c_func
(paren
id|xdg_config
)paren
suffix:semicolon
id|free
c_func
(paren
id|user_config
)paren
suffix:semicolon
r_return
id|ret
op_eq
l_int|0
ques
c_cond
id|found
suffix:colon
id|ret
suffix:semicolon
)brace
DECL|function|git_config_with_options
r_int
id|git_config_with_options
c_func
(paren
id|config_fn_t
id|fn
comma
r_void
op_star
id|data
comma
r_struct
id|git_config_source
op_star
id|config_source
comma
r_int
id|respect_includes
)paren
(brace
r_char
op_star
id|repo_config
op_assign
l_int|NULL
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_struct
id|config_include_data
id|inc
op_assign
id|CONFIG_INCLUDE_INIT
suffix:semicolon
r_if
c_cond
(paren
id|respect_includes
)paren
(brace
id|inc.fn
op_assign
id|fn
suffix:semicolon
id|inc.data
op_assign
id|data
suffix:semicolon
id|fn
op_assign
id|git_config_include
suffix:semicolon
id|data
op_assign
op_amp
id|inc
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we have a specific filename, use it. Otherwise, follow the&n;&t; * regular lookup sequence.&n;&t; */
r_if
c_cond
(paren
id|config_source
op_logical_and
id|config_source-&gt;use_stdin
)paren
r_return
id|git_config_from_stdin
c_func
(paren
id|fn
comma
id|data
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|config_source
op_logical_and
id|config_source-&gt;file
)paren
r_return
id|git_config_from_file
c_func
(paren
id|fn
comma
id|config_source-&gt;file
comma
id|data
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|config_source
op_logical_and
id|config_source-&gt;blob
)paren
r_return
id|git_config_from_blob_ref
c_func
(paren
id|fn
comma
id|config_source-&gt;blob
comma
id|data
)paren
suffix:semicolon
id|repo_config
op_assign
id|git_pathdup
c_func
(paren
l_string|&quot;config&quot;
)paren
suffix:semicolon
id|ret
op_assign
id|git_config_early
c_func
(paren
id|fn
comma
id|data
comma
id|repo_config
)paren
suffix:semicolon
r_if
c_cond
(paren
id|repo_config
)paren
id|free
c_func
(paren
id|repo_config
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|git_config_raw
r_static
r_void
id|git_config_raw
c_func
(paren
id|config_fn_t
id|fn
comma
r_void
op_star
id|data
)paren
(brace
r_if
c_cond
(paren
id|git_config_with_options
c_func
(paren
id|fn
comma
id|data
comma
l_int|NULL
comma
l_int|1
)paren
OL
l_int|0
)paren
multiline_comment|/*&n;&t;&t; * git_config_with_options() normally returns only&n;&t;&t; * positive values, as most errors are fatal, and&n;&t;&t; * non-fatal potential errors are guarded by &quot;if&quot;&n;&t;&t; * statements that are entered only when no error is&n;&t;&t; * possible.&n;&t;&t; *&n;&t;&t; * If we ever encounter a non-fatal error, it means&n;&t;&t; * something went really wrong and we should stop&n;&t;&t; * immediately.&n;&t;&t; */
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;unknown error occured while reading the configuration files&quot;
)paren
)paren
suffix:semicolon
)brace
DECL|function|configset_iter
r_static
r_void
id|configset_iter
c_func
(paren
r_struct
id|config_set
op_star
id|cs
comma
id|config_fn_t
id|fn
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|i
comma
id|value_index
suffix:semicolon
r_struct
id|string_list
op_star
id|values
suffix:semicolon
r_struct
id|config_set_element
op_star
id|entry
suffix:semicolon
r_struct
id|configset_list
op_star
id|list
op_assign
op_amp
id|cs-&gt;list
suffix:semicolon
r_struct
id|key_value_info
op_star
id|kv_info
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|list-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
id|entry
op_assign
id|list-&gt;items
(braket
id|i
)braket
dot
id|e
suffix:semicolon
id|value_index
op_assign
id|list-&gt;items
(braket
id|i
)braket
dot
id|value_index
suffix:semicolon
id|values
op_assign
op_amp
id|entry-&gt;value_list
suffix:semicolon
r_if
c_cond
(paren
id|fn
c_func
(paren
id|entry-&gt;key
comma
id|values-&gt;items
(braket
id|value_index
)braket
dot
id|string
comma
id|data
)paren
OL
l_int|0
)paren
(brace
id|kv_info
op_assign
id|values-&gt;items
(braket
id|value_index
)braket
dot
id|util
suffix:semicolon
id|git_die_config_linenr
c_func
(paren
id|entry-&gt;key
comma
id|kv_info-&gt;filename
comma
id|kv_info-&gt;linenr
)paren
suffix:semicolon
)brace
)brace
)brace
r_static
r_void
id|git_config_check_init
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|function|git_config
r_void
id|git_config
c_func
(paren
id|config_fn_t
id|fn
comma
r_void
op_star
id|data
)paren
(brace
id|git_config_check_init
c_func
(paren
)paren
suffix:semicolon
id|configset_iter
c_func
(paren
op_amp
id|the_config_set
comma
id|fn
comma
id|data
)paren
suffix:semicolon
)brace
DECL|function|configset_find_element
r_static
r_struct
id|config_set_element
op_star
id|configset_find_element
c_func
(paren
r_struct
id|config_set
op_star
id|cs
comma
r_const
r_char
op_star
id|key
)paren
(brace
r_struct
id|config_set_element
id|k
suffix:semicolon
r_struct
id|config_set_element
op_star
id|found_entry
suffix:semicolon
r_char
op_star
id|normalized_key
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/*&n;&t; * `key` may come from the user, so normalize it before using it&n;&t; * for querying entries from the hashmap.&n;&t; */
id|ret
op_assign
id|git_config_parse_key
c_func
(paren
id|key
comma
op_amp
id|normalized_key
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
l_int|NULL
suffix:semicolon
id|hashmap_entry_init
c_func
(paren
op_amp
id|k
comma
id|strhash
c_func
(paren
id|normalized_key
)paren
)paren
suffix:semicolon
id|k.key
op_assign
id|normalized_key
suffix:semicolon
id|found_entry
op_assign
id|hashmap_get
c_func
(paren
op_amp
id|cs-&gt;config_hash
comma
op_amp
id|k
comma
l_int|NULL
)paren
suffix:semicolon
id|free
c_func
(paren
id|normalized_key
)paren
suffix:semicolon
r_return
id|found_entry
suffix:semicolon
)brace
DECL|function|configset_add_value
r_static
r_int
id|configset_add_value
c_func
(paren
r_struct
id|config_set
op_star
id|cs
comma
r_const
r_char
op_star
id|key
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_struct
id|config_set_element
op_star
id|e
suffix:semicolon
r_struct
id|string_list_item
op_star
id|si
suffix:semicolon
r_struct
id|configset_list_item
op_star
id|l_item
suffix:semicolon
r_struct
id|key_value_info
op_star
id|kv_info
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|kv_info
)paren
)paren
suffix:semicolon
id|e
op_assign
id|configset_find_element
c_func
(paren
id|cs
comma
id|key
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Since the keys are being fed by git_config*() callback mechanism, they&n;&t; * are already normalized. So simply add them without any further munging.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|e
)paren
(brace
id|e
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|e
)paren
)paren
suffix:semicolon
id|hashmap_entry_init
c_func
(paren
id|e
comma
id|strhash
c_func
(paren
id|key
)paren
)paren
suffix:semicolon
id|e-&gt;key
op_assign
id|xstrdup
c_func
(paren
id|key
)paren
suffix:semicolon
id|string_list_init
c_func
(paren
op_amp
id|e-&gt;value_list
comma
l_int|1
)paren
suffix:semicolon
id|hashmap_add
c_func
(paren
op_amp
id|cs-&gt;config_hash
comma
id|e
)paren
suffix:semicolon
)brace
id|si
op_assign
id|string_list_append_nodup
c_func
(paren
op_amp
id|e-&gt;value_list
comma
id|xstrdup_or_null
c_func
(paren
id|value
)paren
)paren
suffix:semicolon
id|ALLOC_GROW
c_func
(paren
id|cs-&gt;list.items
comma
id|cs-&gt;list.nr
op_plus
l_int|1
comma
id|cs-&gt;list.alloc
)paren
suffix:semicolon
id|l_item
op_assign
op_amp
id|cs-&gt;list.items
(braket
id|cs-&gt;list.nr
op_increment
)braket
suffix:semicolon
id|l_item-&gt;e
op_assign
id|e
suffix:semicolon
id|l_item-&gt;value_index
op_assign
id|e-&gt;value_list.nr
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cf
)paren
(brace
id|kv_info-&gt;filename
op_assign
id|strintern
c_func
(paren
id|cf-&gt;name
)paren
suffix:semicolon
id|kv_info-&gt;linenr
op_assign
id|cf-&gt;linenr
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* for values read from `git_config_from_parameters()` */
id|kv_info-&gt;filename
op_assign
l_int|NULL
suffix:semicolon
id|kv_info-&gt;linenr
op_assign
l_int|1
suffix:semicolon
)brace
id|si-&gt;util
op_assign
id|kv_info
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|config_set_element_cmp
r_static
r_int
id|config_set_element_cmp
c_func
(paren
r_const
r_struct
id|config_set_element
op_star
id|e1
comma
r_const
r_struct
id|config_set_element
op_star
id|e2
comma
r_const
r_void
op_star
id|unused
)paren
(brace
r_return
id|strcmp
c_func
(paren
id|e1-&gt;key
comma
id|e2-&gt;key
)paren
suffix:semicolon
)brace
DECL|function|git_configset_init
r_void
id|git_configset_init
c_func
(paren
r_struct
id|config_set
op_star
id|cs
)paren
(brace
id|hashmap_init
c_func
(paren
op_amp
id|cs-&gt;config_hash
comma
(paren
id|hashmap_cmp_fn
)paren
id|config_set_element_cmp
comma
l_int|0
)paren
suffix:semicolon
id|cs-&gt;hash_initialized
op_assign
l_int|1
suffix:semicolon
id|cs-&gt;list.nr
op_assign
l_int|0
suffix:semicolon
id|cs-&gt;list.alloc
op_assign
l_int|0
suffix:semicolon
id|cs-&gt;list.items
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|git_configset_clear
r_void
id|git_configset_clear
c_func
(paren
r_struct
id|config_set
op_star
id|cs
)paren
(brace
r_struct
id|config_set_element
op_star
id|entry
suffix:semicolon
r_struct
id|hashmap_iter
id|iter
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cs-&gt;hash_initialized
)paren
r_return
suffix:semicolon
id|hashmap_iter_init
c_func
(paren
op_amp
id|cs-&gt;config_hash
comma
op_amp
id|iter
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|entry
op_assign
id|hashmap_iter_next
c_func
(paren
op_amp
id|iter
)paren
)paren
)paren
(brace
id|free
c_func
(paren
id|entry-&gt;key
)paren
suffix:semicolon
id|string_list_clear
c_func
(paren
op_amp
id|entry-&gt;value_list
comma
l_int|1
)paren
suffix:semicolon
)brace
id|hashmap_free
c_func
(paren
op_amp
id|cs-&gt;config_hash
comma
l_int|1
)paren
suffix:semicolon
id|cs-&gt;hash_initialized
op_assign
l_int|0
suffix:semicolon
id|free
c_func
(paren
id|cs-&gt;list.items
)paren
suffix:semicolon
id|cs-&gt;list.nr
op_assign
l_int|0
suffix:semicolon
id|cs-&gt;list.alloc
op_assign
l_int|0
suffix:semicolon
id|cs-&gt;list.items
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|config_set_callback
r_static
r_int
id|config_set_callback
c_func
(paren
r_const
r_char
op_star
id|key
comma
r_const
r_char
op_star
id|value
comma
r_void
op_star
id|cb
)paren
(brace
r_struct
id|config_set
op_star
id|cs
op_assign
id|cb
suffix:semicolon
id|configset_add_value
c_func
(paren
id|cs
comma
id|key
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|git_configset_add_file
r_int
id|git_configset_add_file
c_func
(paren
r_struct
id|config_set
op_star
id|cs
comma
r_const
r_char
op_star
id|filename
)paren
(brace
r_return
id|git_config_from_file
c_func
(paren
id|config_set_callback
comma
id|filename
comma
id|cs
)paren
suffix:semicolon
)brace
DECL|function|git_configset_get_value
r_int
id|git_configset_get_value
c_func
(paren
r_struct
id|config_set
op_star
id|cs
comma
r_const
r_char
op_star
id|key
comma
r_const
r_char
op_star
op_star
id|value
)paren
(brace
r_const
r_struct
id|string_list
op_star
id|values
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Follows &quot;last one wins&quot; semantic, i.e., if there are multiple matches for the&n;&t; * queried key in the files of the configset, the value returned will be the last&n;&t; * value in the value list for that key.&n;&t; */
id|values
op_assign
id|git_configset_get_value_multi
c_func
(paren
id|cs
comma
id|key
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|values
)paren
r_return
l_int|1
suffix:semicolon
m_assert
(paren
id|values-&gt;nr
OG
l_int|0
)paren
suffix:semicolon
op_star
id|value
op_assign
id|values-&gt;items
(braket
id|values-&gt;nr
l_int|1
)braket
dot
id|string
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|git_configset_get_value_multi
r_const
r_struct
id|string_list
op_star
id|git_configset_get_value_multi
c_func
(paren
r_struct
id|config_set
op_star
id|cs
comma
r_const
r_char
op_star
id|key
)paren
(brace
r_struct
id|config_set_element
op_star
id|e
op_assign
id|configset_find_element
c_func
(paren
id|cs
comma
id|key
)paren
suffix:semicolon
r_return
id|e
ques
c_cond
op_amp
id|e-&gt;value_list
suffix:colon
l_int|NULL
suffix:semicolon
)brace
DECL|function|git_configset_get_string_const
r_int
id|git_configset_get_string_const
c_func
(paren
r_struct
id|config_set
op_star
id|cs
comma
r_const
r_char
op_star
id|key
comma
r_const
r_char
op_star
op_star
id|dest
)paren
(brace
r_const
r_char
op_star
id|value
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|git_configset_get_value
c_func
(paren
id|cs
comma
id|key
comma
op_amp
id|value
)paren
)paren
r_return
id|git_config_string
c_func
(paren
id|dest
comma
id|key
comma
id|value
)paren
suffix:semicolon
r_else
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|git_configset_get_string
r_int
id|git_configset_get_string
c_func
(paren
r_struct
id|config_set
op_star
id|cs
comma
r_const
r_char
op_star
id|key
comma
r_char
op_star
op_star
id|dest
)paren
(brace
r_return
id|git_configset_get_string_const
c_func
(paren
id|cs
comma
id|key
comma
(paren
r_const
r_char
op_star
op_star
)paren
id|dest
)paren
suffix:semicolon
)brace
DECL|function|git_configset_get_int
r_int
id|git_configset_get_int
c_func
(paren
r_struct
id|config_set
op_star
id|cs
comma
r_const
r_char
op_star
id|key
comma
r_int
op_star
id|dest
)paren
(brace
r_const
r_char
op_star
id|value
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|git_configset_get_value
c_func
(paren
id|cs
comma
id|key
comma
op_amp
id|value
)paren
)paren
(brace
op_star
id|dest
op_assign
id|git_config_int
c_func
(paren
id|key
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|git_configset_get_ulong
r_int
id|git_configset_get_ulong
c_func
(paren
r_struct
id|config_set
op_star
id|cs
comma
r_const
r_char
op_star
id|key
comma
r_int
r_int
op_star
id|dest
)paren
(brace
r_const
r_char
op_star
id|value
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|git_configset_get_value
c_func
(paren
id|cs
comma
id|key
comma
op_amp
id|value
)paren
)paren
(brace
op_star
id|dest
op_assign
id|git_config_ulong
c_func
(paren
id|key
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|git_configset_get_bool
r_int
id|git_configset_get_bool
c_func
(paren
r_struct
id|config_set
op_star
id|cs
comma
r_const
r_char
op_star
id|key
comma
r_int
op_star
id|dest
)paren
(brace
r_const
r_char
op_star
id|value
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|git_configset_get_value
c_func
(paren
id|cs
comma
id|key
comma
op_amp
id|value
)paren
)paren
(brace
op_star
id|dest
op_assign
id|git_config_bool
c_func
(paren
id|key
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|git_configset_get_bool_or_int
r_int
id|git_configset_get_bool_or_int
c_func
(paren
r_struct
id|config_set
op_star
id|cs
comma
r_const
r_char
op_star
id|key
comma
r_int
op_star
id|is_bool
comma
r_int
op_star
id|dest
)paren
(brace
r_const
r_char
op_star
id|value
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|git_configset_get_value
c_func
(paren
id|cs
comma
id|key
comma
op_amp
id|value
)paren
)paren
(brace
op_star
id|dest
op_assign
id|git_config_bool_or_int
c_func
(paren
id|key
comma
id|value
comma
id|is_bool
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|git_configset_get_maybe_bool
r_int
id|git_configset_get_maybe_bool
c_func
(paren
r_struct
id|config_set
op_star
id|cs
comma
r_const
r_char
op_star
id|key
comma
r_int
op_star
id|dest
)paren
(brace
r_const
r_char
op_star
id|value
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|git_configset_get_value
c_func
(paren
id|cs
comma
id|key
comma
op_amp
id|value
)paren
)paren
(brace
op_star
id|dest
op_assign
id|git_config_maybe_bool
c_func
(paren
id|key
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|dest
op_eq
l_int|1
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|git_configset_get_pathname
r_int
id|git_configset_get_pathname
c_func
(paren
r_struct
id|config_set
op_star
id|cs
comma
r_const
r_char
op_star
id|key
comma
r_const
r_char
op_star
op_star
id|dest
)paren
(brace
r_const
r_char
op_star
id|value
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|git_configset_get_value
c_func
(paren
id|cs
comma
id|key
comma
op_amp
id|value
)paren
)paren
r_return
id|git_config_pathname
c_func
(paren
id|dest
comma
id|key
comma
id|value
)paren
suffix:semicolon
r_else
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|git_config_check_init
r_static
r_void
id|git_config_check_init
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|the_config_set.hash_initialized
)paren
r_return
suffix:semicolon
id|git_configset_init
c_func
(paren
op_amp
id|the_config_set
)paren
suffix:semicolon
id|git_config_raw
c_func
(paren
id|config_set_callback
comma
op_amp
id|the_config_set
)paren
suffix:semicolon
)brace
DECL|function|git_config_clear
r_void
id|git_config_clear
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|the_config_set.hash_initialized
)paren
r_return
suffix:semicolon
id|git_configset_clear
c_func
(paren
op_amp
id|the_config_set
)paren
suffix:semicolon
)brace
DECL|function|git_config_get_value
r_int
id|git_config_get_value
c_func
(paren
r_const
r_char
op_star
id|key
comma
r_const
r_char
op_star
op_star
id|value
)paren
(brace
id|git_config_check_init
c_func
(paren
)paren
suffix:semicolon
r_return
id|git_configset_get_value
c_func
(paren
op_amp
id|the_config_set
comma
id|key
comma
id|value
)paren
suffix:semicolon
)brace
DECL|function|git_config_get_value_multi
r_const
r_struct
id|string_list
op_star
id|git_config_get_value_multi
c_func
(paren
r_const
r_char
op_star
id|key
)paren
(brace
id|git_config_check_init
c_func
(paren
)paren
suffix:semicolon
r_return
id|git_configset_get_value_multi
c_func
(paren
op_amp
id|the_config_set
comma
id|key
)paren
suffix:semicolon
)brace
DECL|function|git_config_get_string_const
r_int
id|git_config_get_string_const
c_func
(paren
r_const
r_char
op_star
id|key
comma
r_const
r_char
op_star
op_star
id|dest
)paren
(brace
r_int
id|ret
suffix:semicolon
id|git_config_check_init
c_func
(paren
)paren
suffix:semicolon
id|ret
op_assign
id|git_configset_get_string_const
c_func
(paren
op_amp
id|the_config_set
comma
id|key
comma
id|dest
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
id|git_die_config
c_func
(paren
id|key
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|git_config_get_string
r_int
id|git_config_get_string
c_func
(paren
r_const
r_char
op_star
id|key
comma
r_char
op_star
op_star
id|dest
)paren
(brace
id|git_config_check_init
c_func
(paren
)paren
suffix:semicolon
r_return
id|git_config_get_string_const
c_func
(paren
id|key
comma
(paren
r_const
r_char
op_star
op_star
)paren
id|dest
)paren
suffix:semicolon
)brace
DECL|function|git_config_get_int
r_int
id|git_config_get_int
c_func
(paren
r_const
r_char
op_star
id|key
comma
r_int
op_star
id|dest
)paren
(brace
id|git_config_check_init
c_func
(paren
)paren
suffix:semicolon
r_return
id|git_configset_get_int
c_func
(paren
op_amp
id|the_config_set
comma
id|key
comma
id|dest
)paren
suffix:semicolon
)brace
DECL|function|git_config_get_ulong
r_int
id|git_config_get_ulong
c_func
(paren
r_const
r_char
op_star
id|key
comma
r_int
r_int
op_star
id|dest
)paren
(brace
id|git_config_check_init
c_func
(paren
)paren
suffix:semicolon
r_return
id|git_configset_get_ulong
c_func
(paren
op_amp
id|the_config_set
comma
id|key
comma
id|dest
)paren
suffix:semicolon
)brace
DECL|function|git_config_get_bool
r_int
id|git_config_get_bool
c_func
(paren
r_const
r_char
op_star
id|key
comma
r_int
op_star
id|dest
)paren
(brace
id|git_config_check_init
c_func
(paren
)paren
suffix:semicolon
r_return
id|git_configset_get_bool
c_func
(paren
op_amp
id|the_config_set
comma
id|key
comma
id|dest
)paren
suffix:semicolon
)brace
DECL|function|git_config_get_bool_or_int
r_int
id|git_config_get_bool_or_int
c_func
(paren
r_const
r_char
op_star
id|key
comma
r_int
op_star
id|is_bool
comma
r_int
op_star
id|dest
)paren
(brace
id|git_config_check_init
c_func
(paren
)paren
suffix:semicolon
r_return
id|git_configset_get_bool_or_int
c_func
(paren
op_amp
id|the_config_set
comma
id|key
comma
id|is_bool
comma
id|dest
)paren
suffix:semicolon
)brace
DECL|function|git_config_get_maybe_bool
r_int
id|git_config_get_maybe_bool
c_func
(paren
r_const
r_char
op_star
id|key
comma
r_int
op_star
id|dest
)paren
(brace
id|git_config_check_init
c_func
(paren
)paren
suffix:semicolon
r_return
id|git_configset_get_maybe_bool
c_func
(paren
op_amp
id|the_config_set
comma
id|key
comma
id|dest
)paren
suffix:semicolon
)brace
DECL|function|git_config_get_pathname
r_int
id|git_config_get_pathname
c_func
(paren
r_const
r_char
op_star
id|key
comma
r_const
r_char
op_star
op_star
id|dest
)paren
(brace
r_int
id|ret
suffix:semicolon
id|git_config_check_init
c_func
(paren
)paren
suffix:semicolon
id|ret
op_assign
id|git_configset_get_pathname
c_func
(paren
op_amp
id|the_config_set
comma
id|key
comma
id|dest
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
id|git_die_config
c_func
(paren
id|key
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|NORETURN
DECL|function|git_die_config_linenr
r_void
id|git_die_config_linenr
c_func
(paren
r_const
r_char
op_star
id|key
comma
r_const
r_char
op_star
id|filename
comma
r_int
id|linenr
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|filename
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;unable to parse &squot;%s&squot; from command-line config&quot;
)paren
comma
id|key
)paren
suffix:semicolon
r_else
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;bad config variable &squot;%s&squot; in file &squot;%s&squot; at line %d&quot;
)paren
comma
id|key
comma
id|filename
comma
id|linenr
)paren
suffix:semicolon
)brace
id|NORETURN
id|__attribute__
c_func
(paren
(paren
id|format
c_func
(paren
id|printf
comma
l_int|2
comma
l_int|3
)paren
)paren
)paren
DECL|function|git_die_config
r_void
id|git_die_config
c_func
(paren
r_const
r_char
op_star
id|key
comma
r_const
r_char
op_star
id|err
comma
dot
dot
dot
)paren
(brace
r_const
r_struct
id|string_list
op_star
id|values
suffix:semicolon
r_struct
id|key_value_info
op_star
id|kv_info
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|va_list
id|params
suffix:semicolon
id|va_start
c_func
(paren
id|params
comma
id|err
)paren
suffix:semicolon
id|vreportf
c_func
(paren
l_string|&quot;error: &quot;
comma
id|err
comma
id|params
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|params
)paren
suffix:semicolon
)brace
id|values
op_assign
id|git_config_get_value_multi
c_func
(paren
id|key
)paren
suffix:semicolon
id|kv_info
op_assign
id|values-&gt;items
(braket
id|values-&gt;nr
l_int|1
)braket
dot
id|util
suffix:semicolon
id|git_die_config_linenr
c_func
(paren
id|key
comma
id|kv_info-&gt;filename
comma
id|kv_info-&gt;linenr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Find all the stuff for git_config_set() below.&n; */
r_static
r_struct
(brace
DECL|member|baselen
r_int
id|baselen
suffix:semicolon
DECL|member|key
r_char
op_star
id|key
suffix:semicolon
DECL|member|do_not_match
r_int
id|do_not_match
suffix:semicolon
DECL|member|value_regex
id|regex_t
op_star
id|value_regex
suffix:semicolon
DECL|member|multi_replace
r_int
id|multi_replace
suffix:semicolon
DECL|member|offset
r_int
op_star
id|offset
suffix:semicolon
DECL|member|offset_alloc
r_int
r_int
id|offset_alloc
suffix:semicolon
DECL|enumerator|START
DECL|enumerator|SECTION_SEEN
DECL|enumerator|SECTION_END_SEEN
DECL|enumerator|KEY_SEEN
DECL|member|state
r_enum
(brace
id|START
comma
id|SECTION_SEEN
comma
id|SECTION_END_SEEN
comma
id|KEY_SEEN
)brace
id|state
suffix:semicolon
DECL|member|seen
r_int
id|seen
suffix:semicolon
DECL|variable|store
)brace
id|store
suffix:semicolon
DECL|function|matches
r_static
r_int
id|matches
c_func
(paren
r_const
r_char
op_star
id|key
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|key
comma
id|store.key
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* not ours */
r_if
c_cond
(paren
op_logical_neg
id|store.value_regex
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* always matches */
r_if
c_cond
(paren
id|store.value_regex
op_eq
id|CONFIG_REGEX_NONE
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* never matches */
r_return
id|store.do_not_match
op_xor
(paren
id|value
op_logical_and
op_logical_neg
id|regexec
c_func
(paren
id|store.value_regex
comma
id|value
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
)paren
)paren
suffix:semicolon
)brace
DECL|function|store_aux
r_static
r_int
id|store_aux
c_func
(paren
r_const
r_char
op_star
id|key
comma
r_const
r_char
op_star
id|value
comma
r_void
op_star
id|cb
)paren
(brace
r_const
r_char
op_star
id|ep
suffix:semicolon
r_int
id|section_len
suffix:semicolon
r_switch
c_cond
(paren
id|store.state
)paren
(brace
r_case
id|KEY_SEEN
suffix:colon
r_if
c_cond
(paren
id|matches
c_func
(paren
id|key
comma
id|value
)paren
)paren
(brace
r_if
c_cond
(paren
id|store.seen
op_eq
l_int|1
op_logical_and
id|store.multi_replace
op_eq
l_int|0
)paren
(brace
id|warning
c_func
(paren
id|_
c_func
(paren
l_string|&quot;%s has multiple values&quot;
)paren
comma
id|key
)paren
suffix:semicolon
)brace
id|ALLOC_GROW
c_func
(paren
id|store.offset
comma
id|store.seen
op_plus
l_int|1
comma
id|store.offset_alloc
)paren
suffix:semicolon
id|store.offset
(braket
id|store.seen
)braket
op_assign
id|cf
op_member_access_from_pointer
id|do_ftell
c_func
(paren
id|cf
)paren
suffix:semicolon
id|store.seen
op_increment
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SECTION_SEEN
suffix:colon
multiline_comment|/*&n;&t;&t; * What we are looking for is in store.key (both&n;&t;&t; * section and var), and its section part is baselen&n;&t;&t; * long.  We found key (again, both section and var).&n;&t;&t; * We would want to know if this key is in the same&n;&t;&t; * section as what we are looking for.  We already&n;&t;&t; * know we are in the same section as what should&n;&t;&t; * hold store.key.&n;&t;&t; */
id|ep
op_assign
id|strrchr
c_func
(paren
id|key
comma
l_char|&squot;.&squot;
)paren
suffix:semicolon
id|section_len
op_assign
id|ep
id|key
suffix:semicolon
r_if
c_cond
(paren
(paren
id|section_len
op_ne
id|store.baselen
)paren
op_logical_or
id|memcmp
c_func
(paren
id|key
comma
id|store.key
comma
id|section_len
op_plus
l_int|1
)paren
)paren
(brace
id|store.state
op_assign
id|SECTION_END_SEEN
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Do not increment matches: this is no match, but we&n;&t;&t; * just made sure we are in the desired section.&n;&t;&t; */
id|ALLOC_GROW
c_func
(paren
id|store.offset
comma
id|store.seen
op_plus
l_int|1
comma
id|store.offset_alloc
)paren
suffix:semicolon
id|store.offset
(braket
id|store.seen
)braket
op_assign
id|cf
op_member_access_from_pointer
id|do_ftell
c_func
(paren
id|cf
)paren
suffix:semicolon
multiline_comment|/* fallthru */
r_case
id|SECTION_END_SEEN
suffix:colon
r_case
id|START
suffix:colon
r_if
c_cond
(paren
id|matches
c_func
(paren
id|key
comma
id|value
)paren
)paren
(brace
id|ALLOC_GROW
c_func
(paren
id|store.offset
comma
id|store.seen
op_plus
l_int|1
comma
id|store.offset_alloc
)paren
suffix:semicolon
id|store.offset
(braket
id|store.seen
)braket
op_assign
id|cf
op_member_access_from_pointer
id|do_ftell
c_func
(paren
id|cf
)paren
suffix:semicolon
id|store.state
op_assign
id|KEY_SEEN
suffix:semicolon
id|store.seen
op_increment
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|strrchr
c_func
(paren
id|key
comma
l_char|&squot;.&squot;
)paren
id|key
op_eq
id|store.baselen
op_logical_and
op_logical_neg
id|strncmp
c_func
(paren
id|key
comma
id|store.key
comma
id|store.baselen
)paren
)paren
(brace
id|store.state
op_assign
id|SECTION_SEEN
suffix:semicolon
id|ALLOC_GROW
c_func
(paren
id|store.offset
comma
id|store.seen
op_plus
l_int|1
comma
id|store.offset_alloc
)paren
suffix:semicolon
id|store.offset
(braket
id|store.seen
)braket
op_assign
id|cf
op_member_access_from_pointer
id|do_ftell
c_func
(paren
id|cf
)paren
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|write_error
r_static
r_int
id|write_error
c_func
(paren
r_const
r_char
op_star
id|filename
)paren
(brace
id|error
c_func
(paren
l_string|&quot;failed to write new configuration file %s&quot;
comma
id|filename
)paren
suffix:semicolon
multiline_comment|/* Same error code as &quot;failed to rename&quot;. */
r_return
l_int|4
suffix:semicolon
)brace
DECL|function|store_write_section
r_static
r_int
id|store_write_section
c_func
(paren
r_int
id|fd
comma
r_const
r_char
op_star
id|key
)paren
(brace
r_const
r_char
op_star
id|dot
suffix:semicolon
r_int
id|i
comma
id|success
suffix:semicolon
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
id|dot
op_assign
id|memchr
c_func
(paren
id|key
comma
l_char|&squot;.&squot;
comma
id|store.baselen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dot
)paren
(brace
id|strbuf_addf
c_func
(paren
op_amp
id|sb
comma
l_string|&quot;[%.*s &bslash;&quot;&quot;
comma
(paren
r_int
)paren
(paren
id|dot
id|key
)paren
comma
id|key
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|dot
id|key
op_plus
l_int|1
suffix:semicolon
id|i
OL
id|store.baselen
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|key
(braket
id|i
)braket
op_eq
l_char|&squot;&quot;&squot;
op_logical_or
id|key
(braket
id|i
)braket
op_eq
l_char|&squot;&bslash;&bslash;&squot;
)paren
id|strbuf_addch
c_func
(paren
op_amp
id|sb
comma
l_char|&squot;&bslash;&bslash;&squot;
)paren
suffix:semicolon
id|strbuf_addch
c_func
(paren
op_amp
id|sb
comma
id|key
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|strbuf_addstr
c_func
(paren
op_amp
id|sb
comma
l_string|&quot;&bslash;&quot;]&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|strbuf_addf
c_func
(paren
op_amp
id|sb
comma
l_string|&quot;[%.*s]&bslash;n&quot;
comma
id|store.baselen
comma
id|key
)paren
suffix:semicolon
)brace
id|success
op_assign
id|write_in_full
c_func
(paren
id|fd
comma
id|sb.buf
comma
id|sb.len
)paren
op_eq
id|sb.len
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
r_return
id|success
suffix:semicolon
)brace
DECL|function|store_write_pair
r_static
r_int
id|store_write_pair
c_func
(paren
r_int
id|fd
comma
r_const
r_char
op_star
id|key
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_int
id|i
comma
id|success
suffix:semicolon
r_int
id|length
op_assign
id|strlen
c_func
(paren
id|key
op_plus
id|store.baselen
op_plus
l_int|1
)paren
suffix:semicolon
r_const
r_char
op_star
id|quote
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
multiline_comment|/*&n;&t; * Check to see if the value needs to be surrounded with a dq pair.&n;&t; * Note that problematic characters are always backslash-quoted; this&n;&t; * check is about not losing leading or trailing SP and strings that&n;&t; * follow beginning-of-comment characters (i.e. &squot;;&squot; and &squot;#&squot;) by the&n;&t; * configuration parser.&n;&t; */
r_if
c_cond
(paren
id|value
(braket
l_int|0
)braket
op_eq
l_char|&squot; &squot;
)paren
id|quote
op_assign
l_string|&quot;&bslash;&quot;&quot;
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|value
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|value
(braket
id|i
)braket
op_eq
l_char|&squot;;&squot;
op_logical_or
id|value
(braket
id|i
)braket
op_eq
l_char|&squot;#&squot;
)paren
id|quote
op_assign
l_string|&quot;&bslash;&quot;&quot;
suffix:semicolon
r_if
c_cond
(paren
id|i
op_logical_and
id|value
(braket
id|i
l_int|1
)braket
op_eq
l_char|&squot; &squot;
)paren
id|quote
op_assign
l_string|&quot;&bslash;&quot;&quot;
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
id|sb
comma
l_string|&quot;&bslash;t%.*s = %s&quot;
comma
id|length
comma
id|key
op_plus
id|store.baselen
op_plus
l_int|1
comma
id|quote
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|value
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
r_switch
c_cond
(paren
id|value
(braket
id|i
)braket
)paren
(brace
r_case
l_char|&squot;&bslash;n&squot;
suffix:colon
id|strbuf_addstr
c_func
(paren
op_amp
id|sb
comma
l_string|&quot;&bslash;&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;&bslash;t&squot;
suffix:colon
id|strbuf_addstr
c_func
(paren
op_amp
id|sb
comma
l_string|&quot;&bslash;&bslash;t&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;&quot;&squot;
suffix:colon
r_case
l_char|&squot;&bslash;&bslash;&squot;
suffix:colon
id|strbuf_addch
c_func
(paren
op_amp
id|sb
comma
l_char|&squot;&bslash;&bslash;&squot;
)paren
suffix:semicolon
r_default
suffix:colon
id|strbuf_addch
c_func
(paren
op_amp
id|sb
comma
id|value
(braket
id|i
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|strbuf_addf
c_func
(paren
op_amp
id|sb
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|quote
)paren
suffix:semicolon
id|success
op_assign
id|write_in_full
c_func
(paren
id|fd
comma
id|sb.buf
comma
id|sb.len
)paren
op_eq
id|sb.len
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
r_return
id|success
suffix:semicolon
)brace
DECL|function|find_beginning_of_line
r_static
id|ssize_t
id|find_beginning_of_line
c_func
(paren
r_const
r_char
op_star
id|contents
comma
r_int
id|size
comma
r_int
id|offset_
comma
r_int
op_star
id|found_bracket
)paren
(brace
r_int
id|equal_offset
op_assign
id|size
comma
id|bracket_offset
op_assign
id|size
suffix:semicolon
id|ssize_t
id|offset
suffix:semicolon
id|contline
suffix:colon
r_for
c_loop
(paren
id|offset
op_assign
id|offset_
op_minus
l_int|2
suffix:semicolon
id|offset
OG
l_int|0
op_logical_and
id|contents
(braket
id|offset
)braket
op_ne
l_char|&squot;&bslash;n&squot;
suffix:semicolon
id|offset
op_decrement
)paren
r_switch
c_cond
(paren
id|contents
(braket
id|offset
)braket
)paren
(brace
r_case
l_char|&squot;=&squot;
suffix:colon
id|equal_offset
op_assign
id|offset
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;]&squot;
suffix:colon
id|bracket_offset
op_assign
id|offset
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|offset
OG
l_int|0
op_logical_and
id|contents
(braket
id|offset
op_minus
l_int|1
)braket
op_eq
l_char|&squot;&bslash;&bslash;&squot;
)paren
(brace
id|offset_
op_assign
id|offset
suffix:semicolon
r_goto
id|contline
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bracket_offset
OL
id|equal_offset
)paren
(brace
op_star
id|found_bracket
op_assign
l_int|1
suffix:semicolon
id|offset
op_assign
id|bracket_offset
op_plus
l_int|1
suffix:semicolon
)brace
r_else
id|offset
op_increment
suffix:semicolon
r_return
id|offset
suffix:semicolon
)brace
DECL|function|git_config_set_in_file
r_int
id|git_config_set_in_file
c_func
(paren
r_const
r_char
op_star
id|config_filename
comma
r_const
r_char
op_star
id|key
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_return
id|git_config_set_multivar_in_file
c_func
(paren
id|config_filename
comma
id|key
comma
id|value
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|git_config_set
r_int
id|git_config_set
c_func
(paren
r_const
r_char
op_star
id|key
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_return
id|git_config_set_multivar
c_func
(paren
id|key
comma
id|value
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Auxiliary function to sanity-check and split the key into the section&n; * identifier and variable name.&n; *&n; * Returns 0 on success, -1 when there is an invalid character in the key and&n; * -2 if there is no section name in the key.&n; *&n; * store_key - pointer to char* which will hold a copy of the key with&n; *             lowercase section and variable name&n; * baselen - pointer to int which will hold the length of the&n; *           section + subsection part, can be NULL&n; */
DECL|function|git_config_parse_key
r_int
id|git_config_parse_key
c_func
(paren
r_const
r_char
op_star
id|key
comma
r_char
op_star
op_star
id|store_key
comma
r_int
op_star
id|baselen_
)paren
(brace
r_int
id|i
comma
id|dot
comma
id|baselen
suffix:semicolon
r_const
r_char
op_star
id|last_dot
op_assign
id|strrchr
c_func
(paren
id|key
comma
l_char|&squot;.&squot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Since &quot;key&quot; actually contains the section name and the real&n;&t; * key name separated by a dot, we have to know where the dot is.&n;&t; */
r_if
c_cond
(paren
id|last_dot
op_eq
l_int|NULL
op_logical_or
id|last_dot
op_eq
id|key
)paren
(brace
id|error
c_func
(paren
l_string|&quot;key does not contain a section: %s&quot;
comma
id|key
)paren
suffix:semicolon
r_return
id|CONFIG_NO_SECTION_OR_NAME
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|last_dot
(braket
l_int|1
)braket
)paren
(brace
id|error
c_func
(paren
l_string|&quot;key does not contain variable name: %s&quot;
comma
id|key
)paren
suffix:semicolon
r_return
id|CONFIG_NO_SECTION_OR_NAME
suffix:semicolon
)brace
id|baselen
op_assign
id|last_dot
id|key
suffix:semicolon
r_if
c_cond
(paren
id|baselen_
)paren
op_star
id|baselen_
op_assign
id|baselen
suffix:semicolon
multiline_comment|/*&n;&t; * Validate the key and while at it, lower case it for matching.&n;&t; */
op_star
id|store_key
op_assign
id|xmalloc
c_func
(paren
id|strlen
c_func
(paren
id|key
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|dot
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|key
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_char
id|c
op_assign
id|key
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;.&squot;
)paren
id|dot
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Leave the extended basename untouched.. */
r_if
c_cond
(paren
op_logical_neg
id|dot
op_logical_or
id|i
OG
id|baselen
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|iskeychar
c_func
(paren
id|c
)paren
op_logical_or
(paren
id|i
op_eq
id|baselen
op_plus
l_int|1
op_logical_and
op_logical_neg
id|isalpha
c_func
(paren
id|c
)paren
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;invalid key: %s&quot;
comma
id|key
)paren
suffix:semicolon
r_goto
id|out_free_ret_1
suffix:semicolon
)brace
id|c
op_assign
id|tolower
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|error
c_func
(paren
l_string|&quot;invalid key (newline): %s&quot;
comma
id|key
)paren
suffix:semicolon
r_goto
id|out_free_ret_1
suffix:semicolon
)brace
(paren
op_star
id|store_key
)paren
(braket
id|i
)braket
op_assign
id|c
suffix:semicolon
)brace
(paren
op_star
id|store_key
)paren
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_free_ret_1
suffix:colon
id|free
c_func
(paren
op_star
id|store_key
)paren
suffix:semicolon
op_star
id|store_key
op_assign
l_int|NULL
suffix:semicolon
r_return
id|CONFIG_INVALID_KEY
suffix:semicolon
)brace
multiline_comment|/*&n; * If value==NULL, unset in (remove from) config,&n; * if value_regex!=NULL, disregard key/value pairs where value does not match.&n; * if value_regex==CONFIG_REGEX_NONE, do not match any existing values&n; *     (only add a new one)&n; * if multi_replace==0, nothing, or only one matching key/value is replaced,&n; *     else all matching key/values (regardless how many) are removed,&n; *     before the new pair is written.&n; *&n; * Returns 0 on success.&n; *&n; * This function does this:&n; *&n; * - it locks the config file by creating &quot;.git/config.lock&quot;&n; *&n; * - it then parses the config using store_aux() as validator to find&n; *   the position on the key/value pair to replace. If it is to be unset,&n; *   it must be found exactly once.&n; *&n; * - the config file is mmap()ed and the part before the match (if any) is&n; *   written to the lock file, then the changed part and the rest.&n; *&n; * - the config file is removed and the lock file rename()d to it.&n; *&n; */
DECL|function|git_config_set_multivar_in_file
r_int
id|git_config_set_multivar_in_file
c_func
(paren
r_const
r_char
op_star
id|config_filename
comma
r_const
r_char
op_star
id|key
comma
r_const
r_char
op_star
id|value
comma
r_const
r_char
op_star
id|value_regex
comma
r_int
id|multi_replace
)paren
(brace
r_int
id|fd
op_assign
l_int|1
comma
id|in_fd
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_struct
id|lock_file
op_star
id|lock
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
id|filename_buf
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* parse-key returns negative; flip the sign to feed exit(3) */
id|ret
op_assign
l_int|0
id|git_config_parse_key
c_func
(paren
id|key
comma
op_amp
id|store.key
comma
op_amp
id|store.baselen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out_free
suffix:semicolon
id|store.multi_replace
op_assign
id|multi_replace
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|config_filename
)paren
id|config_filename
op_assign
id|filename_buf
op_assign
id|git_pathdup
c_func
(paren
l_string|&quot;config&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The lock serves a purpose in addition to locking: the new&n;&t; * contents of .git/config will be written into it.&n;&t; */
id|lock
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|lock_file
)paren
)paren
suffix:semicolon
id|fd
op_assign
id|hold_lock_file_for_update
c_func
(paren
id|lock
comma
id|config_filename
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
(brace
id|error
c_func
(paren
l_string|&quot;could not lock config file %s: %s&quot;
comma
id|config_filename
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
id|free
c_func
(paren
id|store.key
)paren
suffix:semicolon
id|ret
op_assign
id|CONFIG_NO_LOCK
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If .git/config does not exist yet, write a minimal version.&n;&t; */
id|in_fd
op_assign
id|open
c_func
(paren
id|config_filename
comma
id|O_RDONLY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in_fd
OL
l_int|0
)paren
(brace
id|free
c_func
(paren
id|store.key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ENOENT
op_ne
id|errno
)paren
(brace
id|error
c_func
(paren
l_string|&quot;opening %s: %s&quot;
comma
id|config_filename
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|CONFIG_INVALID_FILE
suffix:semicolon
multiline_comment|/* same as &quot;invalid config file&quot; */
r_goto
id|out_free
suffix:semicolon
)brace
multiline_comment|/* if nothing to unset, error out */
r_if
c_cond
(paren
id|value
op_eq
l_int|NULL
)paren
(brace
id|ret
op_assign
id|CONFIG_NOTHING_SET
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
id|store.key
op_assign
(paren
r_char
op_star
)paren
id|key
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|store_write_section
c_func
(paren
id|fd
comma
id|key
)paren
op_logical_or
op_logical_neg
id|store_write_pair
c_func
(paren
id|fd
comma
id|key
comma
id|value
)paren
)paren
r_goto
id|write_err_out
suffix:semicolon
)brace
r_else
(brace
r_struct
id|stat
id|st
suffix:semicolon
r_char
op_star
id|contents
suffix:semicolon
r_int
id|contents_sz
comma
id|copy_begin
comma
id|copy_end
suffix:semicolon
r_int
id|i
comma
id|new_line
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|value_regex
op_eq
l_int|NULL
)paren
id|store.value_regex
op_assign
l_int|NULL
suffix:semicolon
r_else
r_if
c_cond
(paren
id|value_regex
op_eq
id|CONFIG_REGEX_NONE
)paren
id|store.value_regex
op_assign
id|CONFIG_REGEX_NONE
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|value_regex
(braket
l_int|0
)braket
op_eq
l_char|&squot;!&squot;
)paren
(brace
id|store.do_not_match
op_assign
l_int|1
suffix:semicolon
id|value_regex
op_increment
suffix:semicolon
)brace
r_else
id|store.do_not_match
op_assign
l_int|0
suffix:semicolon
id|store.value_regex
op_assign
(paren
id|regex_t
op_star
)paren
id|xmalloc
c_func
(paren
r_sizeof
(paren
id|regex_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|regcomp
c_func
(paren
id|store.value_regex
comma
id|value_regex
comma
id|REG_EXTENDED
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;invalid pattern: %s&quot;
comma
id|value_regex
)paren
suffix:semicolon
id|free
c_func
(paren
id|store.value_regex
)paren
suffix:semicolon
id|ret
op_assign
id|CONFIG_INVALID_PATTERN
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
)brace
id|ALLOC_GROW
c_func
(paren
id|store.offset
comma
l_int|1
comma
id|store.offset_alloc
)paren
suffix:semicolon
id|store.offset
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|store.state
op_assign
id|START
suffix:semicolon
id|store.seen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * After this, store.offset will contain the *end* offset&n;&t;&t; * of the last match, or remain at 0 if no match was found.&n;&t;&t; * As a side effect, we make sure to transform only a valid&n;&t;&t; * existing config file.&n;&t;&t; */
r_if
c_cond
(paren
id|git_config_from_file
c_func
(paren
id|store_aux
comma
id|config_filename
comma
l_int|NULL
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;invalid config file %s&quot;
comma
id|config_filename
)paren
suffix:semicolon
id|free
c_func
(paren
id|store.key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|store.value_regex
op_ne
l_int|NULL
op_logical_and
id|store.value_regex
op_ne
id|CONFIG_REGEX_NONE
)paren
(brace
id|regfree
c_func
(paren
id|store.value_regex
)paren
suffix:semicolon
id|free
c_func
(paren
id|store.value_regex
)paren
suffix:semicolon
)brace
id|ret
op_assign
id|CONFIG_INVALID_FILE
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
id|free
c_func
(paren
id|store.key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|store.value_regex
op_ne
l_int|NULL
op_logical_and
id|store.value_regex
op_ne
id|CONFIG_REGEX_NONE
)paren
(brace
id|regfree
c_func
(paren
id|store.value_regex
)paren
suffix:semicolon
id|free
c_func
(paren
id|store.value_regex
)paren
suffix:semicolon
)brace
multiline_comment|/* if nothing to unset, or too many matches, error out */
r_if
c_cond
(paren
(paren
id|store.seen
op_eq
l_int|0
op_logical_and
id|value
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|store.seen
OG
l_int|1
op_logical_and
id|multi_replace
op_eq
l_int|0
)paren
)paren
(brace
id|ret
op_assign
id|CONFIG_NOTHING_SET
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
id|fstat
c_func
(paren
id|in_fd
comma
op_amp
id|st
)paren
suffix:semicolon
id|contents_sz
op_assign
id|xsize_t
c_func
(paren
id|st.st_size
)paren
suffix:semicolon
id|contents
op_assign
id|xmmap
c_func
(paren
l_int|NULL
comma
id|contents_sz
comma
id|PROT_READ
comma
id|MAP_PRIVATE
comma
id|in_fd
comma
l_int|0
)paren
suffix:semicolon
id|close
c_func
(paren
id|in_fd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chmod
c_func
(paren
id|get_lock_file_path
c_func
(paren
id|lock
)paren
comma
id|st.st_mode
op_amp
l_int|07777
)paren
OL
l_int|0
)paren
(brace
id|error
c_func
(paren
l_string|&quot;chmod on %s failed: %s&quot;
comma
id|get_lock_file_path
c_func
(paren
id|lock
)paren
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|CONFIG_NO_WRITE
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
r_if
c_cond
(paren
id|store.seen
op_eq
l_int|0
)paren
id|store.seen
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|copy_begin
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|store.seen
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|store.offset
(braket
id|i
)braket
op_eq
l_int|0
)paren
(brace
id|store.offset
(braket
id|i
)braket
op_assign
id|copy_end
op_assign
id|contents_sz
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|store.state
op_ne
id|KEY_SEEN
)paren
(brace
id|copy_end
op_assign
id|store.offset
(braket
id|i
)braket
suffix:semicolon
)brace
r_else
id|copy_end
op_assign
id|find_beginning_of_line
c_func
(paren
id|contents
comma
id|contents_sz
comma
id|store.offset
(braket
id|i
)braket
l_int|2
comma
op_amp
id|new_line
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_end
OG
l_int|0
op_logical_and
id|contents
(braket
id|copy_end
op_minus
l_int|1
)braket
op_ne
l_char|&squot;&bslash;n&squot;
)paren
id|new_line
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* write the first part of the config */
r_if
c_cond
(paren
id|copy_end
OG
id|copy_begin
)paren
(brace
r_if
c_cond
(paren
id|write_in_full
c_func
(paren
id|fd
comma
id|contents
op_plus
id|copy_begin
comma
id|copy_end
id|copy_begin
)paren
OL
id|copy_end
id|copy_begin
)paren
r_goto
id|write_err_out
suffix:semicolon
r_if
c_cond
(paren
id|new_line
op_logical_and
id|write_str_in_full
c_func
(paren
id|fd
comma
l_string|&quot;&bslash;n&quot;
)paren
op_ne
l_int|1
)paren
r_goto
id|write_err_out
suffix:semicolon
)brace
id|copy_begin
op_assign
id|store.offset
(braket
id|i
)braket
suffix:semicolon
)brace
multiline_comment|/* write the pair (value == NULL means unset) */
r_if
c_cond
(paren
id|value
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|store.state
op_eq
id|START
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|store_write_section
c_func
(paren
id|fd
comma
id|key
)paren
)paren
r_goto
id|write_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|store_write_pair
c_func
(paren
id|fd
comma
id|key
comma
id|value
)paren
)paren
r_goto
id|write_err_out
suffix:semicolon
)brace
multiline_comment|/* write the rest of the config */
r_if
c_cond
(paren
id|copy_begin
OL
id|contents_sz
)paren
r_if
c_cond
(paren
id|write_in_full
c_func
(paren
id|fd
comma
id|contents
op_plus
id|copy_begin
comma
id|contents_sz
id|copy_begin
)paren
OL
id|contents_sz
id|copy_begin
)paren
r_goto
id|write_err_out
suffix:semicolon
id|munmap
c_func
(paren
id|contents
comma
id|contents_sz
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|commit_lock_file
c_func
(paren
id|lock
)paren
OL
l_int|0
)paren
(brace
id|error
c_func
(paren
l_string|&quot;could not commit config file %s&quot;
comma
id|config_filename
)paren
suffix:semicolon
id|ret
op_assign
id|CONFIG_NO_WRITE
suffix:semicolon
id|lock
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * lock is committed, so don&squot;t try to roll it back below.&n;&t; * NOTE: Since lockfile.c keeps a linked list of all created&n;&t; * lock_file structures, it isn&squot;t safe to free(lock).  It&squot;s&n;&t; * better to just leave it hanging around.&n;&t; */
id|lock
op_assign
l_int|NULL
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Invalidate the config cache */
id|git_config_clear
c_func
(paren
)paren
suffix:semicolon
id|out_free
suffix:colon
r_if
c_cond
(paren
id|lock
)paren
id|rollback_lock_file
c_func
(paren
id|lock
)paren
suffix:semicolon
id|free
c_func
(paren
id|filename_buf
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
id|write_err_out
suffix:colon
id|ret
op_assign
id|write_error
c_func
(paren
id|get_lock_file_path
c_func
(paren
id|lock
)paren
)paren
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
DECL|function|git_config_set_multivar
r_int
id|git_config_set_multivar
c_func
(paren
r_const
r_char
op_star
id|key
comma
r_const
r_char
op_star
id|value
comma
r_const
r_char
op_star
id|value_regex
comma
r_int
id|multi_replace
)paren
(brace
r_return
id|git_config_set_multivar_in_file
c_func
(paren
l_int|NULL
comma
id|key
comma
id|value
comma
id|value_regex
comma
id|multi_replace
)paren
suffix:semicolon
)brace
DECL|function|section_name_match
r_static
r_int
id|section_name_match
(paren
r_const
r_char
op_star
id|buf
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_int
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
comma
id|dot
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|buf
(braket
id|i
)braket
op_ne
l_char|&squot;[&squot;
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|buf
(braket
id|i
)braket
op_logical_and
id|buf
(braket
id|i
)braket
op_ne
l_char|&squot;]&squot;
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dot
op_logical_and
id|isspace
c_func
(paren
id|buf
(braket
id|i
)braket
)paren
)paren
(brace
id|dot
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|name
(braket
id|j
op_increment
)braket
op_ne
l_char|&squot;.&squot;
)paren
r_break
suffix:semicolon
r_for
c_loop
(paren
id|i
op_increment
suffix:semicolon
id|isspace
c_func
(paren
id|buf
(braket
id|i
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
suffix:semicolon
multiline_comment|/* do nothing */
r_if
c_cond
(paren
id|buf
(braket
id|i
)braket
op_ne
l_char|&squot;&quot;&squot;
)paren
r_break
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buf
(braket
id|i
)braket
op_eq
l_char|&squot;&bslash;&bslash;&squot;
op_logical_and
id|dot
)paren
id|i
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|buf
(braket
id|i
)braket
op_eq
l_char|&squot;&quot;&squot;
op_logical_and
id|dot
)paren
(brace
r_for
c_loop
(paren
id|i
op_increment
suffix:semicolon
id|isspace
c_func
(paren
id|buf
(braket
id|i
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
suffix:semicolon
multiline_comment|/* do_nothing */
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buf
(braket
id|i
)braket
op_ne
id|name
(braket
id|j
op_increment
)braket
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buf
(braket
id|i
)braket
op_eq
l_char|&squot;]&squot;
op_logical_and
id|name
(braket
id|j
)braket
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * We match, now just find the right length offset by&n;&t;&t; * gobbling up any whitespace after it, as well&n;&t;&t; */
id|i
op_increment
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|buf
(braket
id|i
)braket
op_logical_and
id|isspace
c_func
(paren
id|buf
(braket
id|i
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
suffix:semicolon
multiline_comment|/* do nothing */
r_return
id|i
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|section_name_is_ok
r_static
r_int
id|section_name_is_ok
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
multiline_comment|/* Empty section names are bogus. */
r_if
c_cond
(paren
op_logical_neg
op_star
id|name
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Before a dot, we must be alphanumeric or dash. After the first dot,&n;&t; * anything goes, so we can stop checking.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
op_star
id|name
op_logical_and
op_star
id|name
op_ne
l_char|&squot;.&squot;
suffix:semicolon
id|name
op_increment
)paren
r_if
c_cond
(paren
op_star
id|name
op_ne
l_char|&squot;-&squot;
op_logical_and
op_logical_neg
id|isalnum
c_func
(paren
op_star
id|name
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* if new_name == NULL, the section is removed instead */
DECL|function|git_config_rename_section_in_file
r_int
id|git_config_rename_section_in_file
c_func
(paren
r_const
r_char
op_star
id|config_filename
comma
r_const
r_char
op_star
id|old_name
comma
r_const
r_char
op_star
id|new_name
)paren
(brace
r_int
id|ret
op_assign
l_int|0
comma
id|remove
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|filename_buf
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|lock_file
op_star
id|lock
suffix:semicolon
r_int
id|out_fd
suffix:semicolon
r_char
id|buf
(braket
l_int|1024
)braket
suffix:semicolon
id|FILE
op_star
id|config_file
suffix:semicolon
r_struct
id|stat
id|st
suffix:semicolon
r_if
c_cond
(paren
id|new_name
op_logical_and
op_logical_neg
id|section_name_is_ok
c_func
(paren
id|new_name
)paren
)paren
(brace
id|ret
op_assign
id|error
c_func
(paren
l_string|&quot;invalid section name: %s&quot;
comma
id|new_name
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|config_filename
)paren
id|config_filename
op_assign
id|filename_buf
op_assign
id|git_pathdup
c_func
(paren
l_string|&quot;config&quot;
)paren
suffix:semicolon
id|lock
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|lock_file
)paren
)paren
suffix:semicolon
id|out_fd
op_assign
id|hold_lock_file_for_update
c_func
(paren
id|lock
comma
id|config_filename
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|out_fd
OL
l_int|0
)paren
(brace
id|ret
op_assign
id|error
c_func
(paren
l_string|&quot;could not lock config file %s&quot;
comma
id|config_filename
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|config_file
op_assign
id|fopen
c_func
(paren
id|config_filename
comma
l_string|&quot;rb&quot;
)paren
)paren
)paren
(brace
multiline_comment|/* no config file means nothing to rename, no error */
r_goto
id|unlock_and_out
suffix:semicolon
)brace
id|fstat
c_func
(paren
id|fileno
c_func
(paren
id|config_file
)paren
comma
op_amp
id|st
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chmod
c_func
(paren
id|get_lock_file_path
c_func
(paren
id|lock
)paren
comma
id|st.st_mode
op_amp
l_int|07777
)paren
OL
l_int|0
)paren
(brace
id|ret
op_assign
id|error
c_func
(paren
l_string|&quot;chmod on %s failed: %s&quot;
comma
id|get_lock_file_path
c_func
(paren
id|lock
)paren
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_while
c_loop
(paren
id|fgets
c_func
(paren
id|buf
comma
r_sizeof
(paren
id|buf
)paren
comma
id|config_file
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|length
suffix:semicolon
r_char
op_star
id|output
op_assign
id|buf
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|buf
(braket
id|i
)braket
op_logical_and
id|isspace
c_func
(paren
id|buf
(braket
id|i
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
suffix:semicolon
multiline_comment|/* do nothing */
r_if
c_cond
(paren
id|buf
(braket
id|i
)braket
op_eq
l_char|&squot;[&squot;
)paren
(brace
multiline_comment|/* it&squot;s a section */
r_int
id|offset
op_assign
id|section_name_match
c_func
(paren
op_amp
id|buf
(braket
id|i
)braket
comma
id|old_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
OG
l_int|0
)paren
(brace
id|ret
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|new_name
op_eq
l_int|NULL
)paren
(brace
id|remove
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|store.baselen
op_assign
id|strlen
c_func
(paren
id|new_name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|store_write_section
c_func
(paren
id|out_fd
comma
id|new_name
)paren
)paren
(brace
id|ret
op_assign
id|write_error
c_func
(paren
id|get_lock_file_path
c_func
(paren
id|lock
)paren
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * We wrote out the new section, with&n;&t;&t;&t;&t; * a newline, now skip the old&n;&t;&t;&t;&t; * section&squot;s length&n;&t;&t;&t;&t; */
id|output
op_add_assign
id|offset
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
id|strlen
c_func
(paren
id|output
)paren
OG
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * More content means there&squot;s&n;&t;&t;&t;&t;&t; * a declaration to put on the&n;&t;&t;&t;&t;&t; * next line; indent with a&n;&t;&t;&t;&t;&t; * tab&n;&t;&t;&t;&t;&t; */
id|output
op_sub_assign
l_int|1
suffix:semicolon
id|output
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;t&squot;
suffix:semicolon
)brace
)brace
id|remove
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|remove
)paren
r_continue
suffix:semicolon
id|length
op_assign
id|strlen
c_func
(paren
id|output
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write_in_full
c_func
(paren
id|out_fd
comma
id|output
comma
id|length
)paren
op_ne
id|length
)paren
(brace
id|ret
op_assign
id|write_error
c_func
(paren
id|get_lock_file_path
c_func
(paren
id|lock
)paren
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
id|fclose
c_func
(paren
id|config_file
)paren
suffix:semicolon
id|unlock_and_out
suffix:colon
r_if
c_cond
(paren
id|commit_lock_file
c_func
(paren
id|lock
)paren
OL
l_int|0
)paren
id|ret
op_assign
id|error
c_func
(paren
l_string|&quot;could not commit config file %s&quot;
comma
id|config_filename
)paren
suffix:semicolon
id|out
suffix:colon
id|free
c_func
(paren
id|filename_buf
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|git_config_rename_section
r_int
id|git_config_rename_section
c_func
(paren
r_const
r_char
op_star
id|old_name
comma
r_const
r_char
op_star
id|new_name
)paren
(brace
r_return
id|git_config_rename_section_in_file
c_func
(paren
l_int|NULL
comma
id|old_name
comma
id|new_name
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Call this to report error for your variable that should not&n; * get a boolean value (i.e. &quot;[my] var&quot; means &quot;true&quot;).&n; */
DECL|macro|config_error_nonbool
macro_line|#undef config_error_nonbool
DECL|function|config_error_nonbool
r_int
id|config_error_nonbool
c_func
(paren
r_const
r_char
op_star
id|var
)paren
(brace
r_return
id|error
c_func
(paren
l_string|&quot;Missing value for &squot;%s&squot;&quot;
comma
id|var
)paren
suffix:semicolon
)brace
DECL|function|parse_config_key
r_int
id|parse_config_key
c_func
(paren
r_const
r_char
op_star
id|var
comma
r_const
r_char
op_star
id|section
comma
r_const
r_char
op_star
op_star
id|subsection
comma
r_int
op_star
id|subsection_len
comma
r_const
r_char
op_star
op_star
id|key
)paren
(brace
r_int
id|section_len
op_assign
id|strlen
c_func
(paren
id|section
)paren
suffix:semicolon
r_const
r_char
op_star
id|dot
suffix:semicolon
multiline_comment|/* Does it start with &quot;section.&quot; ? */
r_if
c_cond
(paren
op_logical_neg
id|starts_with
c_func
(paren
id|var
comma
id|section
)paren
op_logical_or
id|var
(braket
id|section_len
)braket
op_ne
l_char|&squot;.&squot;
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Find the key; we don&squot;t know yet if we have a subsection, but we must&n;&t; * parse backwards from the end, since the subsection may have dots in&n;&t; * it, too.&n;&t; */
id|dot
op_assign
id|strrchr
c_func
(paren
id|var
comma
l_char|&squot;.&squot;
)paren
suffix:semicolon
op_star
id|key
op_assign
id|dot
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Did we have a subsection at all? */
r_if
c_cond
(paren
id|dot
op_eq
id|var
op_plus
id|section_len
)paren
(brace
op_star
id|subsection
op_assign
l_int|NULL
suffix:semicolon
op_star
id|subsection_len
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
op_star
id|subsection
op_assign
id|var
op_plus
id|section_len
op_plus
l_int|1
suffix:semicolon
op_star
id|subsection_len
op_assign
id|dot
op_star
id|subsection
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
