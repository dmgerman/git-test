macro_line|#include &quot;rabinpoly.h&quot;
macro_line|#include &quot;gsimm.h&quot;
multiline_comment|/* Has to be power of two. Since the Rabin hash only has 63&n;   usable bits, the number of hashes is limited to 32.&n;   Lower powers of two could be used for speeding up processing&n;   of very large files.  */
DECL|macro|NUM_HASHES_PER_CHAR
mdefine_line|#define NUM_HASHES_PER_CHAR 32
multiline_comment|/* Size of cache used to eliminate duplicate substrings.&n;   Make small enough to comfortably fit in L1 cache.  */
DECL|macro|DUP_CACHE_SIZE
mdefine_line|#define DUP_CACHE_SIZE 256
multiline_comment|/* For the final counting, do not count each bit individually, but&n;   group them. Must be power of two, at most NUM_HASHES_PER_CHAR.&n;   However, larger sizes result in higher cache usage. Use 8 bits&n;   per group for efficient processing of large files on fast machines&n;   with decent caches, or 4 bits for faster processing of small files&n;   and for machines with small caches.  */
DECL|macro|GROUP_BITS
mdefine_line|#define GROUP_BITS 4
DECL|macro|GROUP_COUNTERS
mdefine_line|#define GROUP_COUNTERS (1&lt;&lt;GROUP_BITS)
DECL|function|freq_to_md
r_static
r_void
id|freq_to_md
c_func
(paren
id|u_char
op_star
id|md
comma
r_int
op_star
id|freq
)paren
(brace
r_int
id|j
comma
id|k
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|MD_LENGTH
suffix:semicolon
id|j
op_increment
)paren
(brace
id|u_char
id|ch
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
l_int|8
suffix:semicolon
id|k
op_increment
)paren
id|ch
op_assign
l_int|2
op_star
id|ch
op_plus
(paren
id|freq
(braket
l_int|8
op_star
id|j
op_plus
id|k
)braket
OG
l_int|0
)paren
suffix:semicolon
id|md
(braket
id|j
)braket
op_assign
id|ch
suffix:semicolon
)brace
id|bzero
(paren
id|freq
comma
r_sizeof
(paren
id|freq
(braket
l_int|0
)braket
)paren
op_star
id|MD_BITS
)paren
suffix:semicolon
)brace
DECL|function|gb_simm_process
r_void
id|gb_simm_process
c_func
(paren
id|u_char
op_star
id|data
comma
r_int
id|len
comma
id|u_char
op_star
id|md
)paren
(brace
r_int
id|j
op_assign
l_int|0
suffix:semicolon
id|u_int32_t
id|ofs
suffix:semicolon
id|u_int32_t
id|dup_cache
(braket
id|DUP_CACHE_SIZE
)braket
suffix:semicolon
id|u_int32_t
id|count
(braket
id|MD_BITS
op_star
(paren
id|GROUP_COUNTERS
op_div
id|GROUP_BITS
)paren
)braket
suffix:semicolon
r_int
id|freq
(braket
id|MD_BITS
)braket
suffix:semicolon
id|bzero
(paren
id|freq
comma
r_sizeof
(paren
id|freq
(braket
l_int|0
)braket
)paren
op_star
id|MD_BITS
)paren
suffix:semicolon
id|bzero
(paren
id|dup_cache
comma
id|DUP_CACHE_SIZE
op_star
r_sizeof
(paren
id|u_int32_t
)paren
)paren
suffix:semicolon
id|bzero
(paren
id|count
comma
(paren
id|MD_BITS
op_star
(paren
id|GROUP_COUNTERS
op_div
id|GROUP_BITS
)paren
op_star
r_sizeof
(paren
id|u_int32_t
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Ignore incomplete substrings */
r_while
c_loop
(paren
id|j
OL
id|len
op_logical_and
id|j
OL
id|RABIN_WINDOW_SIZE
)paren
id|rabin_slide8
(paren
id|data
(braket
id|j
op_increment
)braket
)paren
suffix:semicolon
r_while
c_loop
(paren
id|j
OL
id|len
)paren
(brace
id|u_int64_t
id|hash
suffix:semicolon
id|u_int32_t
id|ofs
comma
id|sum
suffix:semicolon
id|u_char
id|idx
suffix:semicolon
r_int
id|k
suffix:semicolon
id|hash
op_assign
id|rabin_slide8
(paren
id|data
(braket
id|j
op_increment
)braket
)paren
suffix:semicolon
multiline_comment|/* In order to update a much larger frequency table&n;       with only 32 bits of checksum, randomly select a&n;       part of the table to update. The selection should&n;       only depend on the content of the represented data,&n;       and be independent of the bits used for the update.&n;&n;       Instead of updating 32 individual counters, process&n;       the checksum in MD_BITS / GROUP_BITS groups of&n;       GROUP_BITS bits, and count the frequency of each bit pattern.&n;    */
id|idx
op_assign
(paren
id|hash
op_rshift
l_int|32
)paren
suffix:semicolon
id|sum
op_assign
(paren
id|u_int32_t
)paren
id|hash
suffix:semicolon
id|ofs
op_assign
id|idx
op_mod
(paren
id|MD_BITS
op_div
id|NUM_HASHES_PER_CHAR
)paren
op_star
id|NUM_HASHES_PER_CHAR
suffix:semicolon
id|idx
op_mod_assign
id|DUP_CACHE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|dup_cache
(braket
id|idx
)braket
op_ne
id|sum
)paren
(brace
id|dup_cache
(braket
id|idx
)braket
op_assign
id|sum
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|NUM_HASHES_PER_CHAR
op_div
id|GROUP_BITS
suffix:semicolon
id|k
op_increment
)paren
(brace
id|count
(braket
id|ofs
op_star
id|GROUP_COUNTERS
op_div
id|GROUP_BITS
op_plus
(paren
id|sum
op_mod
id|GROUP_COUNTERS
)paren
)braket
op_increment
suffix:semicolon
id|ofs
op_add_assign
id|GROUP_BITS
suffix:semicolon
id|sum
op_rshift_assign
id|GROUP_BITS
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Distribute the occurrences of each bit group over the frequency table. */
r_for
c_loop
(paren
id|ofs
op_assign
l_int|0
suffix:semicolon
id|ofs
OL
id|MD_BITS
suffix:semicolon
id|ofs
op_add_assign
id|GROUP_BITS
)paren
(brace
r_int
id|j
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|GROUP_COUNTERS
suffix:semicolon
id|j
op_increment
)paren
(brace
r_int
id|k
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|GROUP_BITS
suffix:semicolon
id|k
op_increment
)paren
(brace
id|freq
(braket
id|ofs
op_plus
id|k
)braket
op_add_assign
(paren
(paren
l_int|1
op_lshift
id|k
)paren
op_amp
id|j
)paren
ques
c_cond
id|count
(braket
id|ofs
op_star
id|GROUP_COUNTERS
op_div
id|GROUP_BITS
op_plus
id|j
)braket
suffix:colon
id|count
(braket
id|ofs
op_star
id|GROUP_COUNTERS
op_div
id|GROUP_BITS
op_plus
id|j
)braket
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|md
)paren
(brace
id|rabin_reset
c_func
(paren
)paren
suffix:semicolon
id|freq_to_md
(paren
id|md
comma
id|freq
)paren
suffix:semicolon
)brace
)brace
eof
