macro_line|#include &quot;../cache.h&quot;
macro_line|#include &quot;../refs.h&quot;
macro_line|#include &quot;refs-internal.h&quot;
macro_line|#include &quot;../lockfile.h&quot;
macro_line|#include &quot;../object.h&quot;
macro_line|#include &quot;../dir.h&quot;
DECL|struct|ref_lock
r_struct
id|ref_lock
(brace
DECL|member|ref_name
r_char
op_star
id|ref_name
suffix:semicolon
DECL|member|orig_ref_name
r_char
op_star
id|orig_ref_name
suffix:semicolon
DECL|member|lk
r_struct
id|lock_file
op_star
id|lk
suffix:semicolon
DECL|member|old_oid
r_struct
id|object_id
id|old_oid
suffix:semicolon
)brace
suffix:semicolon
r_struct
id|ref_entry
suffix:semicolon
multiline_comment|/*&n; * Information used (along with the information in ref_entry) to&n; * describe a single cached reference.  This data structure only&n; * occurs embedded in a union in struct ref_entry, and only when&n; * (ref_entry-&gt;flag &amp; REF_DIR) is zero.&n; */
DECL|struct|ref_value
r_struct
id|ref_value
(brace
multiline_comment|/*&n;&t; * The name of the object to which this reference resolves&n;&t; * (which may be a tag object).  If REF_ISBROKEN, this is&n;&t; * null.  If REF_ISSYMREF, then this is the name of the object&n;&t; * referred to by the last reference in the symlink chain.&n;&t; */
DECL|member|oid
r_struct
id|object_id
id|oid
suffix:semicolon
multiline_comment|/*&n;&t; * If REF_KNOWS_PEELED, then this field holds the peeled value&n;&t; * of this reference, or null if the reference is known not to&n;&t; * be peelable.  See the documentation for peel_ref() for an&n;&t; * exact definition of &quot;peelable&quot;.&n;&t; */
DECL|member|peeled
r_struct
id|object_id
id|peeled
suffix:semicolon
)brace
suffix:semicolon
r_struct
id|ref_cache
suffix:semicolon
multiline_comment|/*&n; * Information used (along with the information in ref_entry) to&n; * describe a level in the hierarchy of references.  This data&n; * structure only occurs embedded in a union in struct ref_entry, and&n; * only when (ref_entry.flag &amp; REF_DIR) is set.  In that case,&n; * (ref_entry.flag &amp; REF_INCOMPLETE) determines whether the references&n; * in the directory have already been read:&n; *&n; *     (ref_entry.flag &amp; REF_INCOMPLETE) unset -- a directory of loose&n; *         or packed references, already read.&n; *&n; *     (ref_entry.flag &amp; REF_INCOMPLETE) set -- a directory of loose&n; *         references that hasn&squot;t been read yet (nor has any of its&n; *         subdirectories).&n; *&n; * Entries within a directory are stored within a growable array of&n; * pointers to ref_entries (entries, nr, alloc).  Entries 0 &lt;= i &lt;&n; * sorted are sorted by their component name in strcmp() order and the&n; * remaining entries are unsorted.&n; *&n; * Loose references are read lazily, one directory at a time.  When a&n; * directory of loose references is read, then all of the references&n; * in that directory are stored, and REF_INCOMPLETE stubs are created&n; * for any subdirectories, but the subdirectories themselves are not&n; * read.  The reading is triggered by get_ref_dir().&n; */
DECL|struct|ref_dir
r_struct
id|ref_dir
(brace
DECL|member|nr
DECL|member|alloc
r_int
id|nr
comma
id|alloc
suffix:semicolon
multiline_comment|/*&n;&t; * Entries with index 0 &lt;= i &lt; sorted are sorted by name.  New&n;&t; * entries are appended to the list unsorted, and are sorted&n;&t; * only when required; thus we avoid the need to sort the list&n;&t; * after the addition of every reference.&n;&t; */
DECL|member|sorted
r_int
id|sorted
suffix:semicolon
multiline_comment|/* A pointer to the ref_cache that contains this ref_dir. */
DECL|member|ref_cache
r_struct
id|ref_cache
op_star
id|ref_cache
suffix:semicolon
DECL|member|entries
r_struct
id|ref_entry
op_star
op_star
id|entries
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Bit values for ref_entry::flag.  REF_ISSYMREF=0x01,&n; * REF_ISPACKED=0x02, REF_ISBROKEN=0x04 and REF_BAD_NAME=0x08 are&n; * public values; see refs.h.&n; */
multiline_comment|/*&n; * The field ref_entry-&gt;u.value.peeled of this value entry contains&n; * the correct peeled value for the reference, which might be&n; * null_sha1 if the reference is not a tag or if it is broken.&n; */
DECL|macro|REF_KNOWS_PEELED
mdefine_line|#define REF_KNOWS_PEELED 0x10
multiline_comment|/* ref_entry represents a directory of references */
DECL|macro|REF_DIR
mdefine_line|#define REF_DIR 0x20
multiline_comment|/*&n; * Entry has not yet been read from disk (used only for REF_DIR&n; * entries representing loose references)&n; */
DECL|macro|REF_INCOMPLETE
mdefine_line|#define REF_INCOMPLETE 0x40
multiline_comment|/*&n; * A ref_entry represents either a reference or a &quot;subdirectory&quot; of&n; * references.&n; *&n; * Each directory in the reference namespace is represented by a&n; * ref_entry with (flags &amp; REF_DIR) set and containing a subdir member&n; * that holds the entries in that directory that have been read so&n; * far.  If (flags &amp; REF_INCOMPLETE) is set, then the directory and&n; * its subdirectories haven&squot;t been read yet.  REF_INCOMPLETE is only&n; * used for loose reference directories.&n; *&n; * References are represented by a ref_entry with (flags &amp; REF_DIR)&n; * unset and a value member that describes the reference&squot;s value.  The&n; * flag member is at the ref_entry level, but it is also needed to&n; * interpret the contents of the value field (in other words, a&n; * ref_value object is not very much use without the enclosing&n; * ref_entry).&n; *&n; * Reference names cannot end with slash and directories&squot; names are&n; * always stored with a trailing slash (except for the top-level&n; * directory, which is always denoted by &quot;&quot;).  This has two nice&n; * consequences: (1) when the entries in each subdir are sorted&n; * lexicographically by name (as they usually are), the references in&n; * a whole tree can be generated in lexicographic order by traversing&n; * the tree in left-to-right, depth-first order; (2) the names of&n; * references and subdirectories cannot conflict, and therefore the&n; * presence of an empty subdirectory does not block the creation of a&n; * similarly-named reference.  (The fact that reference names with the&n; * same leading components can conflict *with each other* is a&n; * separate issue that is regulated by verify_refname_available().)&n; *&n; * Please note that the name field contains the fully-qualified&n; * reference (or subdirectory) name.  Space could be saved by only&n; * storing the relative names.  But that would require the full names&n; * to be generated on the fly when iterating in do_for_each_ref(), and&n; * would break callback functions, who have always been able to assume&n; * that the name strings that they are passed will not be freed during&n; * the iteration.&n; */
DECL|struct|ref_entry
r_struct
id|ref_entry
(brace
DECL|member|flag
r_int
r_char
id|flag
suffix:semicolon
multiline_comment|/* ISSYMREF? ISPACKED? */
r_union
(brace
DECL|member|value
r_struct
id|ref_value
id|value
suffix:semicolon
multiline_comment|/* if not (flags&amp;REF_DIR) */
DECL|member|subdir
r_struct
id|ref_dir
id|subdir
suffix:semicolon
multiline_comment|/* if (flags&amp;REF_DIR) */
DECL|member|u
)brace
id|u
suffix:semicolon
multiline_comment|/*&n;&t; * The full name of the reference (e.g., &quot;refs/heads/master&quot;)&n;&t; * or the full name of the directory with a trailing slash&n;&t; * (e.g., &quot;refs/heads/&quot;):&n;&t; */
DECL|member|name
r_char
id|name
(braket
id|FLEX_ARRAY
)braket
suffix:semicolon
)brace
suffix:semicolon
r_static
r_void
id|read_loose_refs
c_func
(paren
r_const
r_char
op_star
id|dirname
comma
r_struct
id|ref_dir
op_star
id|dir
)paren
suffix:semicolon
r_static
r_int
id|search_ref_dir
c_func
(paren
r_struct
id|ref_dir
op_star
id|dir
comma
r_const
r_char
op_star
id|refname
comma
r_int
id|len
)paren
suffix:semicolon
r_static
r_struct
id|ref_entry
op_star
id|create_dir_entry
c_func
(paren
r_struct
id|ref_cache
op_star
id|ref_cache
comma
r_const
r_char
op_star
id|dirname
comma
r_int
id|len
comma
r_int
id|incomplete
)paren
suffix:semicolon
r_static
r_void
id|add_entry_to_dir
c_func
(paren
r_struct
id|ref_dir
op_star
id|dir
comma
r_struct
id|ref_entry
op_star
id|entry
)paren
suffix:semicolon
DECL|function|get_ref_dir
r_static
r_struct
id|ref_dir
op_star
id|get_ref_dir
c_func
(paren
r_struct
id|ref_entry
op_star
id|entry
)paren
(brace
r_struct
id|ref_dir
op_star
id|dir
suffix:semicolon
m_assert
(paren
id|entry-&gt;flag
op_amp
id|REF_DIR
)paren
suffix:semicolon
id|dir
op_assign
op_amp
id|entry-&gt;u.subdir
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;flag
op_amp
id|REF_INCOMPLETE
)paren
(brace
id|read_loose_refs
c_func
(paren
id|entry-&gt;name
comma
id|dir
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Manually add refs/bisect, which, being&n;&t;&t; * per-worktree, might not appear in the directory&n;&t;&t; * listing for refs/ in the main repo.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|entry-&gt;name
comma
l_string|&quot;refs/&quot;
)paren
)paren
(brace
r_int
id|pos
op_assign
id|search_ref_dir
c_func
(paren
id|dir
comma
l_string|&quot;refs/bisect/&quot;
comma
l_int|12
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
l_int|0
)paren
(brace
r_struct
id|ref_entry
op_star
id|child_entry
suffix:semicolon
id|child_entry
op_assign
id|create_dir_entry
c_func
(paren
id|dir-&gt;ref_cache
comma
l_string|&quot;refs/bisect/&quot;
comma
l_int|12
comma
l_int|1
)paren
suffix:semicolon
id|add_entry_to_dir
c_func
(paren
id|dir
comma
id|child_entry
)paren
suffix:semicolon
id|read_loose_refs
c_func
(paren
l_string|&quot;refs/bisect&quot;
comma
op_amp
id|child_entry-&gt;u.subdir
)paren
suffix:semicolon
)brace
)brace
id|entry-&gt;flag
op_and_assign
op_complement
id|REF_INCOMPLETE
suffix:semicolon
)brace
r_return
id|dir
suffix:semicolon
)brace
DECL|function|create_ref_entry
r_static
r_struct
id|ref_entry
op_star
id|create_ref_entry
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
id|flag
comma
r_int
id|check_name
)paren
(brace
r_int
id|len
suffix:semicolon
r_struct
id|ref_entry
op_star
id|ref
suffix:semicolon
r_if
c_cond
(paren
id|check_name
op_logical_and
id|check_refname_format
c_func
(paren
id|refname
comma
id|REFNAME_ALLOW_ONELEVEL
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Reference has invalid format: &squot;%s&squot;&quot;
comma
id|refname
)paren
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|refname
)paren
op_plus
l_int|1
suffix:semicolon
id|ref
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ref_entry
)paren
op_plus
id|len
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|ref-&gt;u.value.oid.hash
comma
id|sha1
)paren
suffix:semicolon
id|oidclr
c_func
(paren
op_amp
id|ref-&gt;u.value.peeled
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ref-&gt;name
comma
id|refname
comma
id|len
)paren
suffix:semicolon
id|ref-&gt;flag
op_assign
id|flag
suffix:semicolon
r_return
id|ref
suffix:semicolon
)brace
r_static
r_void
id|clear_ref_dir
c_func
(paren
r_struct
id|ref_dir
op_star
id|dir
)paren
suffix:semicolon
DECL|function|free_ref_entry
r_static
r_void
id|free_ref_entry
c_func
(paren
r_struct
id|ref_entry
op_star
id|entry
)paren
(brace
r_if
c_cond
(paren
id|entry-&gt;flag
op_amp
id|REF_DIR
)paren
(brace
multiline_comment|/*&n;&t;&t; * Do not use get_ref_dir() here, as that might&n;&t;&t; * trigger the reading of loose refs.&n;&t;&t; */
id|clear_ref_dir
c_func
(paren
op_amp
id|entry-&gt;u.subdir
)paren
suffix:semicolon
)brace
id|free
c_func
(paren
id|entry
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a ref_entry to the end of dir (unsorted).  Entry is always&n; * stored directly in dir; no recursion into subdirectories is&n; * done.&n; */
DECL|function|add_entry_to_dir
r_static
r_void
id|add_entry_to_dir
c_func
(paren
r_struct
id|ref_dir
op_star
id|dir
comma
r_struct
id|ref_entry
op_star
id|entry
)paren
(brace
id|ALLOC_GROW
c_func
(paren
id|dir-&gt;entries
comma
id|dir-&gt;nr
op_plus
l_int|1
comma
id|dir-&gt;alloc
)paren
suffix:semicolon
id|dir-&gt;entries
(braket
id|dir-&gt;nr
op_increment
)braket
op_assign
id|entry
suffix:semicolon
multiline_comment|/* optimize for the case that entries are added in order */
r_if
c_cond
(paren
id|dir-&gt;nr
op_eq
l_int|1
op_logical_or
(paren
id|dir-&gt;nr
op_eq
id|dir-&gt;sorted
op_plus
l_int|1
op_logical_and
id|strcmp
c_func
(paren
id|dir-&gt;entries
(braket
id|dir-&gt;nr
l_int|2
)braket
op_member_access_from_pointer
id|name
comma
id|dir-&gt;entries
(braket
id|dir-&gt;nr
l_int|1
)braket
op_member_access_from_pointer
id|name
)paren
OL
l_int|0
)paren
)paren
id|dir-&gt;sorted
op_assign
id|dir-&gt;nr
suffix:semicolon
)brace
multiline_comment|/*&n; * Clear and free all entries in dir, recursively.&n; */
DECL|function|clear_ref_dir
r_static
r_void
id|clear_ref_dir
c_func
(paren
r_struct
id|ref_dir
op_star
id|dir
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dir-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
id|free_ref_entry
c_func
(paren
id|dir-&gt;entries
(braket
id|i
)braket
)paren
suffix:semicolon
id|free
c_func
(paren
id|dir-&gt;entries
)paren
suffix:semicolon
id|dir-&gt;sorted
op_assign
id|dir-&gt;nr
op_assign
id|dir-&gt;alloc
op_assign
l_int|0
suffix:semicolon
id|dir-&gt;entries
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Create a struct ref_entry object for the specified dirname.&n; * dirname is the name of the directory with a trailing slash (e.g.,&n; * &quot;refs/heads/&quot;) or &quot;&quot; for the top-level directory.&n; */
DECL|function|create_dir_entry
r_static
r_struct
id|ref_entry
op_star
id|create_dir_entry
c_func
(paren
r_struct
id|ref_cache
op_star
id|ref_cache
comma
r_const
r_char
op_star
id|dirname
comma
r_int
id|len
comma
r_int
id|incomplete
)paren
(brace
r_struct
id|ref_entry
op_star
id|direntry
suffix:semicolon
id|direntry
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|ref_entry
)paren
op_plus
id|len
op_plus
l_int|1
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|direntry-&gt;name
comma
id|dirname
comma
id|len
)paren
suffix:semicolon
id|direntry-&gt;name
(braket
id|len
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|direntry-&gt;u.subdir.ref_cache
op_assign
id|ref_cache
suffix:semicolon
id|direntry-&gt;flag
op_assign
id|REF_DIR
op_or
(paren
id|incomplete
ques
c_cond
id|REF_INCOMPLETE
suffix:colon
l_int|0
)paren
suffix:semicolon
r_return
id|direntry
suffix:semicolon
)brace
DECL|function|ref_entry_cmp
r_static
r_int
id|ref_entry_cmp
c_func
(paren
r_const
r_void
op_star
id|a
comma
r_const
r_void
op_star
id|b
)paren
(brace
r_struct
id|ref_entry
op_star
id|one
op_assign
op_star
(paren
r_struct
id|ref_entry
op_star
op_star
)paren
id|a
suffix:semicolon
r_struct
id|ref_entry
op_star
id|two
op_assign
op_star
(paren
r_struct
id|ref_entry
op_star
op_star
)paren
id|b
suffix:semicolon
r_return
id|strcmp
c_func
(paren
id|one-&gt;name
comma
id|two-&gt;name
)paren
suffix:semicolon
)brace
r_static
r_void
id|sort_ref_dir
c_func
(paren
r_struct
id|ref_dir
op_star
id|dir
)paren
suffix:semicolon
DECL|struct|string_slice
r_struct
id|string_slice
(brace
DECL|member|len
r_int
id|len
suffix:semicolon
DECL|member|str
r_const
r_char
op_star
id|str
suffix:semicolon
)brace
suffix:semicolon
DECL|function|ref_entry_cmp_sslice
r_static
r_int
id|ref_entry_cmp_sslice
c_func
(paren
r_const
r_void
op_star
id|key_
comma
r_const
r_void
op_star
id|ent_
)paren
(brace
r_const
r_struct
id|string_slice
op_star
id|key
op_assign
id|key_
suffix:semicolon
r_const
r_struct
id|ref_entry
op_star
id|ent
op_assign
op_star
(paren
r_const
r_struct
id|ref_entry
op_star
r_const
op_star
)paren
id|ent_
suffix:semicolon
r_int
id|cmp
op_assign
id|strncmp
c_func
(paren
id|key-&gt;str
comma
id|ent-&gt;name
comma
id|key-&gt;len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmp
)paren
r_return
id|cmp
suffix:semicolon
r_return
l_char|&squot;&bslash;0&squot;
(paren
r_int
r_char
)paren
id|ent-&gt;name
(braket
id|key-&gt;len
)braket
suffix:semicolon
)brace
multiline_comment|/*&n; * Return the index of the entry with the given refname from the&n; * ref_dir (non-recursively), sorting dir if necessary.  Return -1 if&n; * no such entry is found.  dir must already be complete.&n; */
DECL|function|search_ref_dir
r_static
r_int
id|search_ref_dir
c_func
(paren
r_struct
id|ref_dir
op_star
id|dir
comma
r_const
r_char
op_star
id|refname
comma
r_int
id|len
)paren
(brace
r_struct
id|ref_entry
op_star
op_star
id|r
suffix:semicolon
r_struct
id|string_slice
id|key
suffix:semicolon
r_if
c_cond
(paren
id|refname
op_eq
l_int|NULL
op_logical_or
op_logical_neg
id|dir-&gt;nr
)paren
r_return
l_int|1
suffix:semicolon
id|sort_ref_dir
c_func
(paren
id|dir
)paren
suffix:semicolon
id|key.len
op_assign
id|len
suffix:semicolon
id|key.str
op_assign
id|refname
suffix:semicolon
id|r
op_assign
id|bsearch
c_func
(paren
op_amp
id|key
comma
id|dir-&gt;entries
comma
id|dir-&gt;nr
comma
r_sizeof
(paren
op_star
id|dir-&gt;entries
)paren
comma
id|ref_entry_cmp_sslice
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_eq
l_int|NULL
)paren
r_return
l_int|1
suffix:semicolon
r_return
id|r
id|dir-&gt;entries
suffix:semicolon
)brace
multiline_comment|/*&n; * Search for a directory entry directly within dir (without&n; * recursing).  Sort dir if necessary.  subdirname must be a directory&n; * name (i.e., end in &squot;/&squot;).  If mkdir is set, then create the&n; * directory if it is missing; otherwise, return NULL if the desired&n; * directory cannot be found.  dir must already be complete.&n; */
DECL|function|search_for_subdir
r_static
r_struct
id|ref_dir
op_star
id|search_for_subdir
c_func
(paren
r_struct
id|ref_dir
op_star
id|dir
comma
r_const
r_char
op_star
id|subdirname
comma
r_int
id|len
comma
r_int
id|mkdir
)paren
(brace
r_int
id|entry_index
op_assign
id|search_ref_dir
c_func
(paren
id|dir
comma
id|subdirname
comma
id|len
)paren
suffix:semicolon
r_struct
id|ref_entry
op_star
id|entry
suffix:semicolon
r_if
c_cond
(paren
id|entry_index
op_eq
l_int|1
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|mkdir
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Since dir is complete, the absence of a subdir&n;&t;&t; * means that the subdir really doesn&squot;t exist;&n;&t;&t; * therefore, create an empty record for it but mark&n;&t;&t; * the record complete.&n;&t;&t; */
id|entry
op_assign
id|create_dir_entry
c_func
(paren
id|dir-&gt;ref_cache
comma
id|subdirname
comma
id|len
comma
l_int|0
)paren
suffix:semicolon
id|add_entry_to_dir
c_func
(paren
id|dir
comma
id|entry
)paren
suffix:semicolon
)brace
r_else
(brace
id|entry
op_assign
id|dir-&gt;entries
(braket
id|entry_index
)braket
suffix:semicolon
)brace
r_return
id|get_ref_dir
c_func
(paren
id|entry
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * If refname is a reference name, find the ref_dir within the dir&n; * tree that should hold refname.  If refname is a directory name&n; * (i.e., ends in &squot;/&squot;), then return that ref_dir itself.  dir must&n; * represent the top-level directory and must already be complete.&n; * Sort ref_dirs and recurse into subdirectories as necessary.  If&n; * mkdir is set, then create any missing directories; otherwise,&n; * return NULL if the desired directory cannot be found.&n; */
DECL|function|find_containing_dir
r_static
r_struct
id|ref_dir
op_star
id|find_containing_dir
c_func
(paren
r_struct
id|ref_dir
op_star
id|dir
comma
r_const
r_char
op_star
id|refname
comma
r_int
id|mkdir
)paren
(brace
r_const
r_char
op_star
id|slash
suffix:semicolon
r_for
c_loop
(paren
id|slash
op_assign
id|strchr
c_func
(paren
id|refname
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
id|slash
suffix:semicolon
id|slash
op_assign
id|strchr
c_func
(paren
id|slash
op_plus
l_int|1
comma
l_char|&squot;/&squot;
)paren
)paren
(brace
r_int
id|dirnamelen
op_assign
id|slash
id|refname
op_plus
l_int|1
suffix:semicolon
r_struct
id|ref_dir
op_star
id|subdir
suffix:semicolon
id|subdir
op_assign
id|search_for_subdir
c_func
(paren
id|dir
comma
id|refname
comma
id|dirnamelen
comma
id|mkdir
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|subdir
)paren
(brace
id|dir
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
id|dir
op_assign
id|subdir
suffix:semicolon
)brace
r_return
id|dir
suffix:semicolon
)brace
multiline_comment|/*&n; * Find the value entry with the given name in dir, sorting ref_dirs&n; * and recursing into subdirectories as necessary.  If the name is not&n; * found or it corresponds to a directory entry, return NULL.&n; */
DECL|function|find_ref
r_static
r_struct
id|ref_entry
op_star
id|find_ref
c_func
(paren
r_struct
id|ref_dir
op_star
id|dir
comma
r_const
r_char
op_star
id|refname
)paren
(brace
r_int
id|entry_index
suffix:semicolon
r_struct
id|ref_entry
op_star
id|entry
suffix:semicolon
id|dir
op_assign
id|find_containing_dir
c_func
(paren
id|dir
comma
id|refname
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir
)paren
r_return
l_int|NULL
suffix:semicolon
id|entry_index
op_assign
id|search_ref_dir
c_func
(paren
id|dir
comma
id|refname
comma
id|strlen
c_func
(paren
id|refname
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry_index
op_eq
l_int|1
)paren
r_return
l_int|NULL
suffix:semicolon
id|entry
op_assign
id|dir-&gt;entries
(braket
id|entry_index
)braket
suffix:semicolon
r_return
(paren
id|entry-&gt;flag
op_amp
id|REF_DIR
)paren
ques
c_cond
l_int|NULL
suffix:colon
id|entry
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove the entry with the given name from dir, recursing into&n; * subdirectories as necessary.  If refname is the name of a directory&n; * (i.e., ends with &squot;/&squot;), then remove the directory and its contents.&n; * If the removal was successful, return the number of entries&n; * remaining in the directory entry that contained the deleted entry.&n; * If the name was not found, return -1.  Please note that this&n; * function only deletes the entry from the cache; it does not delete&n; * it from the filesystem or ensure that other cache entries (which&n; * might be symbolic references to the removed entry) are updated.&n; * Nor does it remove any containing dir entries that might be made&n; * empty by the removal.  dir must represent the top-level directory&n; * and must already be complete.&n; */
DECL|function|remove_entry
r_static
r_int
id|remove_entry
c_func
(paren
r_struct
id|ref_dir
op_star
id|dir
comma
r_const
r_char
op_star
id|refname
)paren
(brace
r_int
id|refname_len
op_assign
id|strlen
c_func
(paren
id|refname
)paren
suffix:semicolon
r_int
id|entry_index
suffix:semicolon
r_struct
id|ref_entry
op_star
id|entry
suffix:semicolon
r_int
id|is_dir
op_assign
id|refname
(braket
id|refname_len
l_int|1
)braket
op_eq
l_char|&squot;/&squot;
suffix:semicolon
r_if
c_cond
(paren
id|is_dir
)paren
(brace
multiline_comment|/*&n;&t;&t; * refname represents a reference directory.  Remove&n;&t;&t; * the trailing slash; otherwise we will get the&n;&t;&t; * directory *representing* refname rather than the&n;&t;&t; * one *containing* it.&n;&t;&t; */
r_char
op_star
id|dirname
op_assign
id|xmemdupz
c_func
(paren
id|refname
comma
id|refname_len
l_int|1
)paren
suffix:semicolon
id|dir
op_assign
id|find_containing_dir
c_func
(paren
id|dir
comma
id|dirname
comma
l_int|0
)paren
suffix:semicolon
id|free
c_func
(paren
id|dirname
)paren
suffix:semicolon
)brace
r_else
(brace
id|dir
op_assign
id|find_containing_dir
c_func
(paren
id|dir
comma
id|refname
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|dir
)paren
r_return
l_int|1
suffix:semicolon
id|entry_index
op_assign
id|search_ref_dir
c_func
(paren
id|dir
comma
id|refname
comma
id|refname_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry_index
op_eq
l_int|1
)paren
r_return
l_int|1
suffix:semicolon
id|entry
op_assign
id|dir-&gt;entries
(braket
id|entry_index
)braket
suffix:semicolon
id|memmove
c_func
(paren
op_amp
id|dir-&gt;entries
(braket
id|entry_index
)braket
comma
op_amp
id|dir-&gt;entries
(braket
id|entry_index
op_plus
l_int|1
)braket
comma
(paren
id|dir-&gt;nr
id|entry_index
l_int|1
)paren
op_star
r_sizeof
(paren
op_star
id|dir-&gt;entries
)paren
)paren
suffix:semicolon
id|dir-&gt;nr
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;sorted
OG
id|entry_index
)paren
id|dir-&gt;sorted
op_decrement
suffix:semicolon
id|free_ref_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
r_return
id|dir-&gt;nr
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a ref_entry to the ref_dir (unsorted), recursing into&n; * subdirectories as necessary.  dir must represent the top-level&n; * directory.  Return 0 on success.&n; */
DECL|function|add_ref
r_static
r_int
id|add_ref
c_func
(paren
r_struct
id|ref_dir
op_star
id|dir
comma
r_struct
id|ref_entry
op_star
id|ref
)paren
(brace
id|dir
op_assign
id|find_containing_dir
c_func
(paren
id|dir
comma
id|ref-&gt;name
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir
)paren
r_return
l_int|1
suffix:semicolon
id|add_entry_to_dir
c_func
(paren
id|dir
comma
id|ref
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Emit a warning and return true iff ref1 and ref2 have the same name&n; * and the same sha1.  Die if they have the same name but different&n; * sha1s.&n; */
DECL|function|is_dup_ref
r_static
r_int
id|is_dup_ref
c_func
(paren
r_const
r_struct
id|ref_entry
op_star
id|ref1
comma
r_const
r_struct
id|ref_entry
op_star
id|ref2
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|ref1-&gt;name
comma
id|ref2-&gt;name
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Duplicate name; make sure that they don&squot;t conflict: */
r_if
c_cond
(paren
(paren
id|ref1-&gt;flag
op_amp
id|REF_DIR
)paren
op_logical_or
(paren
id|ref2-&gt;flag
op_amp
id|REF_DIR
)paren
)paren
multiline_comment|/* This is impossible by construction */
id|die
c_func
(paren
l_string|&quot;Reference directory conflict: %s&quot;
comma
id|ref1-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|oidcmp
c_func
(paren
op_amp
id|ref1-&gt;u.value.oid
comma
op_amp
id|ref2-&gt;u.value.oid
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Duplicated ref, and SHA1s don&squot;t match: %s&quot;
comma
id|ref1-&gt;name
)paren
suffix:semicolon
id|warning
c_func
(paren
l_string|&quot;Duplicated ref: %s&quot;
comma
id|ref1-&gt;name
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Sort the entries in dir non-recursively (if they are not already&n; * sorted) and remove any duplicate entries.&n; */
DECL|function|sort_ref_dir
r_static
r_void
id|sort_ref_dir
c_func
(paren
r_struct
id|ref_dir
op_star
id|dir
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_struct
id|ref_entry
op_star
id|last
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * This check also prevents passing a zero-length array to qsort(),&n;&t; * which is a problem on some platforms.&n;&t; */
r_if
c_cond
(paren
id|dir-&gt;sorted
op_eq
id|dir-&gt;nr
)paren
r_return
suffix:semicolon
id|qsort
c_func
(paren
id|dir-&gt;entries
comma
id|dir-&gt;nr
comma
r_sizeof
(paren
op_star
id|dir-&gt;entries
)paren
comma
id|ref_entry_cmp
)paren
suffix:semicolon
multiline_comment|/* Remove any duplicates: */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|dir-&gt;nr
suffix:semicolon
id|j
op_increment
)paren
(brace
r_struct
id|ref_entry
op_star
id|entry
op_assign
id|dir-&gt;entries
(braket
id|j
)braket
suffix:semicolon
r_if
c_cond
(paren
id|last
op_logical_and
id|is_dup_ref
c_func
(paren
id|last
comma
id|entry
)paren
)paren
id|free_ref_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
r_else
id|last
op_assign
id|dir-&gt;entries
(braket
id|i
op_increment
)braket
op_assign
id|entry
suffix:semicolon
)brace
id|dir-&gt;sorted
op_assign
id|dir-&gt;nr
op_assign
id|i
suffix:semicolon
)brace
multiline_comment|/* Include broken references in a do_for_each_ref*() iteration: */
DECL|macro|DO_FOR_EACH_INCLUDE_BROKEN
mdefine_line|#define DO_FOR_EACH_INCLUDE_BROKEN 0x01
multiline_comment|/*&n; * Return true iff the reference described by entry can be resolved to&n; * an object in the database.  Emit a warning if the referred-to&n; * object does not exist.&n; */
DECL|function|ref_resolves_to_object
r_static
r_int
id|ref_resolves_to_object
c_func
(paren
r_struct
id|ref_entry
op_star
id|entry
)paren
(brace
r_if
c_cond
(paren
id|entry-&gt;flag
op_amp
id|REF_ISBROKEN
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|has_sha1_file
c_func
(paren
id|entry-&gt;u.value.oid.hash
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;%s does not point to a valid object!&quot;
comma
id|entry-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * current_ref is a performance hack: when iterating over references&n; * using the for_each_ref*() functions, current_ref is set to the&n; * current reference&squot;s entry before calling the callback function.  If&n; * the callback function calls peel_ref(), then peel_ref() first&n; * checks whether the reference to be peeled is the current reference&n; * (it usually is) and if so, returns that reference&squot;s peeled version&n; * if it is available.  This avoids a refname lookup in a common case.&n; */
DECL|variable|current_ref
r_static
r_struct
id|ref_entry
op_star
id|current_ref
suffix:semicolon
DECL|typedef|each_ref_entry_fn
r_typedef
r_int
id|each_ref_entry_fn
c_func
(paren
r_struct
id|ref_entry
op_star
id|entry
comma
r_void
op_star
id|cb_data
)paren
suffix:semicolon
DECL|struct|ref_entry_cb
r_struct
id|ref_entry_cb
(brace
DECL|member|base
r_const
r_char
op_star
id|base
suffix:semicolon
DECL|member|trim
r_int
id|trim
suffix:semicolon
DECL|member|flags
r_int
id|flags
suffix:semicolon
DECL|member|fn
id|each_ref_fn
op_star
id|fn
suffix:semicolon
DECL|member|cb_data
r_void
op_star
id|cb_data
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Handle one reference in a do_for_each_ref*()-style iteration,&n; * calling an each_ref_fn for each entry.&n; */
DECL|function|do_one_ref
r_static
r_int
id|do_one_ref
c_func
(paren
r_struct
id|ref_entry
op_star
id|entry
comma
r_void
op_star
id|cb_data
)paren
(brace
r_struct
id|ref_entry_cb
op_star
id|data
op_assign
id|cb_data
suffix:semicolon
r_struct
id|ref_entry
op_star
id|old_current_ref
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|starts_with
c_func
(paren
id|entry-&gt;name
comma
id|data-&gt;base
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|data-&gt;flags
op_amp
id|DO_FOR_EACH_INCLUDE_BROKEN
)paren
op_logical_and
op_logical_neg
id|ref_resolves_to_object
c_func
(paren
id|entry
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Store the old value, in case this is a recursive call: */
id|old_current_ref
op_assign
id|current_ref
suffix:semicolon
id|current_ref
op_assign
id|entry
suffix:semicolon
id|retval
op_assign
id|data
op_member_access_from_pointer
id|fn
c_func
(paren
id|entry-&gt;name
op_plus
id|data-&gt;trim
comma
op_amp
id|entry-&gt;u.value.oid
comma
id|entry-&gt;flag
comma
id|data-&gt;cb_data
)paren
suffix:semicolon
id|current_ref
op_assign
id|old_current_ref
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Call fn for each reference in dir that has index in the range&n; * offset &lt;= index &lt; dir-&gt;nr.  Recurse into subdirectories that are in&n; * that index range, sorting them before iterating.  This function&n; * does not sort dir itself; it should be sorted beforehand.  fn is&n; * called for all references, including broken ones.&n; */
DECL|function|do_for_each_entry_in_dir
r_static
r_int
id|do_for_each_entry_in_dir
c_func
(paren
r_struct
id|ref_dir
op_star
id|dir
comma
r_int
id|offset
comma
id|each_ref_entry_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_int
id|i
suffix:semicolon
m_assert
(paren
id|dir-&gt;sorted
op_eq
id|dir-&gt;nr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|offset
suffix:semicolon
id|i
OL
id|dir-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|ref_entry
op_star
id|entry
op_assign
id|dir-&gt;entries
(braket
id|i
)braket
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;flag
op_amp
id|REF_DIR
)paren
(brace
r_struct
id|ref_dir
op_star
id|subdir
op_assign
id|get_ref_dir
c_func
(paren
id|entry
)paren
suffix:semicolon
id|sort_ref_dir
c_func
(paren
id|subdir
)paren
suffix:semicolon
id|retval
op_assign
id|do_for_each_entry_in_dir
c_func
(paren
id|subdir
comma
l_int|0
comma
id|fn
comma
id|cb_data
)paren
suffix:semicolon
)brace
r_else
(brace
id|retval
op_assign
id|fn
c_func
(paren
id|entry
comma
id|cb_data
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Call fn for each reference in the union of dir1 and dir2, in order&n; * by refname.  Recurse into subdirectories.  If a value entry appears&n; * in both dir1 and dir2, then only process the version that is in&n; * dir2.  The input dirs must already be sorted, but subdirs will be&n; * sorted as needed.  fn is called for all references, including&n; * broken ones.&n; */
DECL|function|do_for_each_entry_in_dirs
r_static
r_int
id|do_for_each_entry_in_dirs
c_func
(paren
r_struct
id|ref_dir
op_star
id|dir1
comma
r_struct
id|ref_dir
op_star
id|dir2
comma
id|each_ref_entry_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_int
id|retval
suffix:semicolon
r_int
id|i1
op_assign
l_int|0
comma
id|i2
op_assign
l_int|0
suffix:semicolon
m_assert
(paren
id|dir1-&gt;sorted
op_eq
id|dir1-&gt;nr
)paren
suffix:semicolon
m_assert
(paren
id|dir2-&gt;sorted
op_eq
id|dir2-&gt;nr
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_struct
id|ref_entry
op_star
id|e1
comma
op_star
id|e2
suffix:semicolon
r_int
id|cmp
suffix:semicolon
r_if
c_cond
(paren
id|i1
op_eq
id|dir1-&gt;nr
)paren
(brace
r_return
id|do_for_each_entry_in_dir
c_func
(paren
id|dir2
comma
id|i2
comma
id|fn
comma
id|cb_data
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i2
op_eq
id|dir2-&gt;nr
)paren
(brace
r_return
id|do_for_each_entry_in_dir
c_func
(paren
id|dir1
comma
id|i1
comma
id|fn
comma
id|cb_data
)paren
suffix:semicolon
)brace
id|e1
op_assign
id|dir1-&gt;entries
(braket
id|i1
)braket
suffix:semicolon
id|e2
op_assign
id|dir2-&gt;entries
(braket
id|i2
)braket
suffix:semicolon
id|cmp
op_assign
id|strcmp
c_func
(paren
id|e1-&gt;name
comma
id|e2-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmp
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|e1-&gt;flag
op_amp
id|REF_DIR
)paren
op_logical_and
(paren
id|e2-&gt;flag
op_amp
id|REF_DIR
)paren
)paren
(brace
multiline_comment|/* Both are directories; descend them in parallel. */
r_struct
id|ref_dir
op_star
id|subdir1
op_assign
id|get_ref_dir
c_func
(paren
id|e1
)paren
suffix:semicolon
r_struct
id|ref_dir
op_star
id|subdir2
op_assign
id|get_ref_dir
c_func
(paren
id|e2
)paren
suffix:semicolon
id|sort_ref_dir
c_func
(paren
id|subdir1
)paren
suffix:semicolon
id|sort_ref_dir
c_func
(paren
id|subdir2
)paren
suffix:semicolon
id|retval
op_assign
id|do_for_each_entry_in_dirs
c_func
(paren
id|subdir1
comma
id|subdir2
comma
id|fn
comma
id|cb_data
)paren
suffix:semicolon
id|i1
op_increment
suffix:semicolon
id|i2
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|e1-&gt;flag
op_amp
id|REF_DIR
)paren
op_logical_and
op_logical_neg
(paren
id|e2-&gt;flag
op_amp
id|REF_DIR
)paren
)paren
(brace
multiline_comment|/* Both are references; ignore the one from dir1. */
id|retval
op_assign
id|fn
c_func
(paren
id|e2
comma
id|cb_data
)paren
suffix:semicolon
id|i1
op_increment
suffix:semicolon
id|i2
op_increment
suffix:semicolon
)brace
r_else
(brace
id|die
c_func
(paren
l_string|&quot;conflict between reference and directory: %s&quot;
comma
id|e1-&gt;name
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_struct
id|ref_entry
op_star
id|e
suffix:semicolon
r_if
c_cond
(paren
id|cmp
OL
l_int|0
)paren
(brace
id|e
op_assign
id|e1
suffix:semicolon
id|i1
op_increment
suffix:semicolon
)brace
r_else
(brace
id|e
op_assign
id|e2
suffix:semicolon
id|i2
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e-&gt;flag
op_amp
id|REF_DIR
)paren
(brace
r_struct
id|ref_dir
op_star
id|subdir
op_assign
id|get_ref_dir
c_func
(paren
id|e
)paren
suffix:semicolon
id|sort_ref_dir
c_func
(paren
id|subdir
)paren
suffix:semicolon
id|retval
op_assign
id|do_for_each_entry_in_dir
c_func
(paren
id|subdir
comma
l_int|0
comma
id|fn
comma
id|cb_data
)paren
suffix:semicolon
)brace
r_else
(brace
id|retval
op_assign
id|fn
c_func
(paren
id|e
comma
id|cb_data
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Load all of the refs from the dir into our in-memory cache. The hard work&n; * of loading loose refs is done by get_ref_dir(), so we just need to recurse&n; * through all of the sub-directories. We do not even need to care about&n; * sorting, as traversal order does not matter to us.&n; */
DECL|function|prime_ref_dir
r_static
r_void
id|prime_ref_dir
c_func
(paren
r_struct
id|ref_dir
op_star
id|dir
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dir-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|ref_entry
op_star
id|entry
op_assign
id|dir-&gt;entries
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;flag
op_amp
id|REF_DIR
)paren
id|prime_ref_dir
c_func
(paren
id|get_ref_dir
c_func
(paren
id|entry
)paren
)paren
suffix:semicolon
)brace
)brace
DECL|struct|nonmatching_ref_data
r_struct
id|nonmatching_ref_data
(brace
DECL|member|skip
r_const
r_struct
id|string_list
op_star
id|skip
suffix:semicolon
DECL|member|conflicting_refname
r_const
r_char
op_star
id|conflicting_refname
suffix:semicolon
)brace
suffix:semicolon
DECL|function|nonmatching_ref_fn
r_static
r_int
id|nonmatching_ref_fn
c_func
(paren
r_struct
id|ref_entry
op_star
id|entry
comma
r_void
op_star
id|vdata
)paren
(brace
r_struct
id|nonmatching_ref_data
op_star
id|data
op_assign
id|vdata
suffix:semicolon
r_if
c_cond
(paren
id|data-&gt;skip
op_logical_and
id|string_list_has_string
c_func
(paren
id|data-&gt;skip
comma
id|entry-&gt;name
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|data-&gt;conflicting_refname
op_assign
id|entry-&gt;name
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Return 0 if a reference named refname could be created without&n; * conflicting with the name of an existing reference in dir.&n; * See verify_refname_available for more information.&n; */
DECL|function|verify_refname_available_dir
r_static
r_int
id|verify_refname_available_dir
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_const
r_struct
id|string_list
op_star
id|extras
comma
r_const
r_struct
id|string_list
op_star
id|skip
comma
r_struct
id|ref_dir
op_star
id|dir
comma
r_struct
id|strbuf
op_star
id|err
)paren
(brace
r_const
r_char
op_star
id|slash
suffix:semicolon
r_int
id|pos
suffix:semicolon
r_struct
id|strbuf
id|dirname
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|ret
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * For the sake of comments in this function, suppose that&n;&t; * refname is &quot;refs/foo/bar&quot;.&n;&t; */
m_assert
(paren
id|err
)paren
suffix:semicolon
id|strbuf_grow
c_func
(paren
op_amp
id|dirname
comma
id|strlen
c_func
(paren
id|refname
)paren
op_plus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|slash
op_assign
id|strchr
c_func
(paren
id|refname
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
id|slash
suffix:semicolon
id|slash
op_assign
id|strchr
c_func
(paren
id|slash
op_plus
l_int|1
comma
l_char|&squot;/&squot;
)paren
)paren
(brace
multiline_comment|/* Expand dirname to the new prefix, not including the trailing slash: */
id|strbuf_add
c_func
(paren
op_amp
id|dirname
comma
id|refname
op_plus
id|dirname.len
comma
id|slash
id|refname
id|dirname.len
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We are still at a leading dir of the refname (e.g.,&n;&t;&t; * &quot;refs/foo&quot;; if there is a reference with that name,&n;&t;&t; * it is a conflict, *unless* it is in skip.&n;&t;&t; */
r_if
c_cond
(paren
id|dir
)paren
(brace
id|pos
op_assign
id|search_ref_dir
c_func
(paren
id|dir
comma
id|dirname.buf
comma
id|dirname.len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_ge
l_int|0
op_logical_and
(paren
op_logical_neg
id|skip
op_logical_or
op_logical_neg
id|string_list_has_string
c_func
(paren
id|skip
comma
id|dirname.buf
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * We found a reference whose name is&n;&t;&t;&t;&t; * a proper prefix of refname; e.g.,&n;&t;&t;&t;&t; * &quot;refs/foo&quot;, and is not in skip.&n;&t;&t;&t;&t; */
id|strbuf_addf
c_func
(paren
id|err
comma
l_string|&quot;&squot;%s&squot; exists; cannot create &squot;%s&squot;&quot;
comma
id|dirname.buf
comma
id|refname
)paren
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|extras
op_logical_and
id|string_list_has_string
c_func
(paren
id|extras
comma
id|dirname.buf
)paren
op_logical_and
(paren
op_logical_neg
id|skip
op_logical_or
op_logical_neg
id|string_list_has_string
c_func
(paren
id|skip
comma
id|dirname.buf
)paren
)paren
)paren
(brace
id|strbuf_addf
c_func
(paren
id|err
comma
l_string|&quot;cannot process &squot;%s&squot; and &squot;%s&squot; at the same time&quot;
comma
id|refname
comma
id|dirname.buf
)paren
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Otherwise, we can try to continue our search with&n;&t;&t; * the next component. So try to look up the&n;&t;&t; * directory, e.g., &quot;refs/foo/&quot;. If we come up empty,&n;&t;&t; * we know there is nothing under this whole prefix,&n;&t;&t; * but even in that case we still have to continue the&n;&t;&t; * search for conflicts with extras.&n;&t;&t; */
id|strbuf_addch
c_func
(paren
op_amp
id|dirname
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dir
)paren
(brace
id|pos
op_assign
id|search_ref_dir
c_func
(paren
id|dir
comma
id|dirname.buf
comma
id|dirname.len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * There was no directory &quot;refs/foo/&quot;,&n;&t;&t;&t;&t; * so there is nothing under this&n;&t;&t;&t;&t; * whole prefix. So there is no need&n;&t;&t;&t;&t; * to continue looking for conflicting&n;&t;&t;&t;&t; * references. But we need to continue&n;&t;&t;&t;&t; * looking for conflicting extras.&n;&t;&t;&t;&t; */
id|dir
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|dir
op_assign
id|get_ref_dir
c_func
(paren
id|dir-&gt;entries
(braket
id|pos
)braket
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * We are at the leaf of our refname (e.g., &quot;refs/foo/bar&quot;).&n;&t; * There is no point in searching for a reference with that&n;&t; * name, because a refname isn&squot;t considered to conflict with&n;&t; * itself. But we still need to check for references whose&n;&t; * names are in the &quot;refs/foo/bar/&quot; namespace, because they&n;&t; * *do* conflict.&n;&t; */
id|strbuf_addstr
c_func
(paren
op_amp
id|dirname
comma
id|refname
op_plus
id|dirname.len
)paren
suffix:semicolon
id|strbuf_addch
c_func
(paren
op_amp
id|dirname
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dir
)paren
(brace
id|pos
op_assign
id|search_ref_dir
c_func
(paren
id|dir
comma
id|dirname.buf
comma
id|dirname.len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_ge
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * We found a directory named &quot;$refname/&quot;&n;&t;&t;&t; * (e.g., &quot;refs/foo/bar/&quot;). It is a problem&n;&t;&t;&t; * iff it contains any ref that is not in&n;&t;&t;&t; * &quot;skip&quot;.&n;&t;&t;&t; */
r_struct
id|nonmatching_ref_data
id|data
suffix:semicolon
id|data.skip
op_assign
id|skip
suffix:semicolon
id|data.conflicting_refname
op_assign
l_int|NULL
suffix:semicolon
id|dir
op_assign
id|get_ref_dir
c_func
(paren
id|dir-&gt;entries
(braket
id|pos
)braket
)paren
suffix:semicolon
id|sort_ref_dir
c_func
(paren
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|do_for_each_entry_in_dir
c_func
(paren
id|dir
comma
l_int|0
comma
id|nonmatching_ref_fn
comma
op_amp
id|data
)paren
)paren
(brace
id|strbuf_addf
c_func
(paren
id|err
comma
l_string|&quot;&squot;%s&squot; exists; cannot create &squot;%s&squot;&quot;
comma
id|data.conflicting_refname
comma
id|refname
)paren
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|extras
)paren
(brace
multiline_comment|/*&n;&t;&t; * Check for entries in extras that start with&n;&t;&t; * &quot;$refname/&quot;. We do that by looking for the place&n;&t;&t; * where &quot;$refname/&quot; would be inserted in extras. If&n;&t;&t; * there is an entry at that position that starts with&n;&t;&t; * &quot;$refname/&quot; and is not in skip, then we have a&n;&t;&t; * conflict.&n;&t;&t; */
r_for
c_loop
(paren
id|pos
op_assign
id|string_list_find_insert_index
c_func
(paren
id|extras
comma
id|dirname.buf
comma
l_int|0
)paren
suffix:semicolon
id|pos
OL
id|extras-&gt;nr
suffix:semicolon
id|pos
op_increment
)paren
(brace
r_const
r_char
op_star
id|extra_refname
op_assign
id|extras-&gt;items
(braket
id|pos
)braket
dot
id|string
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|starts_with
c_func
(paren
id|extra_refname
comma
id|dirname.buf
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skip
op_logical_or
op_logical_neg
id|string_list_has_string
c_func
(paren
id|skip
comma
id|extra_refname
)paren
)paren
(brace
id|strbuf_addf
c_func
(paren
id|err
comma
l_string|&quot;cannot process &squot;%s&squot; and &squot;%s&squot; at the same time&quot;
comma
id|refname
comma
id|extra_refname
)paren
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* No conflicts were found */
id|ret
op_assign
l_int|0
suffix:semicolon
id|cleanup
suffix:colon
id|strbuf_release
c_func
(paren
op_amp
id|dirname
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|struct|packed_ref_cache
r_struct
id|packed_ref_cache
(brace
DECL|member|root
r_struct
id|ref_entry
op_star
id|root
suffix:semicolon
multiline_comment|/*&n;&t; * Count of references to the data structure in this instance,&n;&t; * including the pointer from ref_cache::packed if any.  The&n;&t; * data will not be freed as long as the reference count is&n;&t; * nonzero.&n;&t; */
DECL|member|referrers
r_int
r_int
id|referrers
suffix:semicolon
multiline_comment|/*&n;&t; * Iff the packed-refs file associated with this instance is&n;&t; * currently locked for writing, this points at the associated&n;&t; * lock (which is owned by somebody else).  The referrer count&n;&t; * is also incremented when the file is locked and decremented&n;&t; * when it is unlocked.&n;&t; */
DECL|member|lock
r_struct
id|lock_file
op_star
id|lock
suffix:semicolon
multiline_comment|/* The metadata from when this packed-refs cache was read */
DECL|member|validity
r_struct
id|stat_validity
id|validity
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Future: need to be in &quot;struct repository&quot;&n; * when doing a full libification.&n; */
DECL|struct|ref_cache
r_static
r_struct
id|ref_cache
(brace
DECL|member|next
r_struct
id|ref_cache
op_star
id|next
suffix:semicolon
DECL|member|loose
r_struct
id|ref_entry
op_star
id|loose
suffix:semicolon
DECL|member|packed
r_struct
id|packed_ref_cache
op_star
id|packed
suffix:semicolon
multiline_comment|/*&n;&t; * The submodule name, or &quot;&quot; for the main repo.  We allocate&n;&t; * length 1 rather than FLEX_ARRAY so that the main ref_cache&n;&t; * is initialized correctly.&n;&t; */
DECL|member|name
r_char
id|name
(braket
l_int|1
)braket
suffix:semicolon
DECL|variable|ref_cache
DECL|variable|submodule_ref_caches
)brace
id|ref_cache
comma
op_star
id|submodule_ref_caches
suffix:semicolon
multiline_comment|/* Lock used for the main packed-refs file: */
DECL|variable|packlock
r_static
r_struct
id|lock_file
id|packlock
suffix:semicolon
multiline_comment|/*&n; * Increment the reference count of *packed_refs.&n; */
DECL|function|acquire_packed_ref_cache
r_static
r_void
id|acquire_packed_ref_cache
c_func
(paren
r_struct
id|packed_ref_cache
op_star
id|packed_refs
)paren
(brace
id|packed_refs-&gt;referrers
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; * Decrease the reference count of *packed_refs.  If it goes to zero,&n; * free *packed_refs and return true; otherwise return false.&n; */
DECL|function|release_packed_ref_cache
r_static
r_int
id|release_packed_ref_cache
c_func
(paren
r_struct
id|packed_ref_cache
op_star
id|packed_refs
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|packed_refs-&gt;referrers
)paren
(brace
id|free_ref_entry
c_func
(paren
id|packed_refs-&gt;root
)paren
suffix:semicolon
id|stat_validity_clear
c_func
(paren
op_amp
id|packed_refs-&gt;validity
)paren
suffix:semicolon
id|free
c_func
(paren
id|packed_refs
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|clear_packed_ref_cache
r_static
r_void
id|clear_packed_ref_cache
c_func
(paren
r_struct
id|ref_cache
op_star
id|refs
)paren
(brace
r_if
c_cond
(paren
id|refs-&gt;packed
)paren
(brace
r_struct
id|packed_ref_cache
op_star
id|packed_refs
op_assign
id|refs-&gt;packed
suffix:semicolon
r_if
c_cond
(paren
id|packed_refs-&gt;lock
)paren
id|die
c_func
(paren
l_string|&quot;internal error: packed-ref cache cleared while locked&quot;
)paren
suffix:semicolon
id|refs-&gt;packed
op_assign
l_int|NULL
suffix:semicolon
id|release_packed_ref_cache
c_func
(paren
id|packed_refs
)paren
suffix:semicolon
)brace
)brace
DECL|function|clear_loose_ref_cache
r_static
r_void
id|clear_loose_ref_cache
c_func
(paren
r_struct
id|ref_cache
op_star
id|refs
)paren
(brace
r_if
c_cond
(paren
id|refs-&gt;loose
)paren
(brace
id|free_ref_entry
c_func
(paren
id|refs-&gt;loose
)paren
suffix:semicolon
id|refs-&gt;loose
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
DECL|function|create_ref_cache
r_static
r_struct
id|ref_cache
op_star
id|create_ref_cache
c_func
(paren
r_const
r_char
op_star
id|submodule
)paren
(brace
r_int
id|len
suffix:semicolon
r_struct
id|ref_cache
op_star
id|refs
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|submodule
)paren
id|submodule
op_assign
l_string|&quot;&quot;
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|submodule
)paren
op_plus
l_int|1
suffix:semicolon
id|refs
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|ref_cache
)paren
op_plus
id|len
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|refs-&gt;name
comma
id|submodule
comma
id|len
)paren
suffix:semicolon
r_return
id|refs
suffix:semicolon
)brace
multiline_comment|/*&n; * Return a pointer to a ref_cache for the specified submodule. For&n; * the main repository, use submodule==NULL. The returned structure&n; * will be allocated and initialized but not necessarily populated; it&n; * should not be freed.&n; */
DECL|function|get_ref_cache
r_static
r_struct
id|ref_cache
op_star
id|get_ref_cache
c_func
(paren
r_const
r_char
op_star
id|submodule
)paren
(brace
r_struct
id|ref_cache
op_star
id|refs
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|submodule
op_logical_or
op_logical_neg
op_star
id|submodule
)paren
r_return
op_amp
id|ref_cache
suffix:semicolon
r_for
c_loop
(paren
id|refs
op_assign
id|submodule_ref_caches
suffix:semicolon
id|refs
suffix:semicolon
id|refs
op_assign
id|refs-&gt;next
)paren
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|submodule
comma
id|refs-&gt;name
)paren
)paren
r_return
id|refs
suffix:semicolon
id|refs
op_assign
id|create_ref_cache
c_func
(paren
id|submodule
)paren
suffix:semicolon
id|refs-&gt;next
op_assign
id|submodule_ref_caches
suffix:semicolon
id|submodule_ref_caches
op_assign
id|refs
suffix:semicolon
r_return
id|refs
suffix:semicolon
)brace
multiline_comment|/* The length of a peeled reference line in packed-refs, including EOL: */
DECL|macro|PEELED_LINE_LENGTH
mdefine_line|#define PEELED_LINE_LENGTH 42
multiline_comment|/*&n; * The packed-refs header line that we write out.  Perhaps other&n; * traits will be added later.  The trailing space is required.&n; */
DECL|variable|PACKED_REFS_HEADER
r_static
r_const
r_char
id|PACKED_REFS_HEADER
(braket
)braket
op_assign
l_string|&quot;# pack-refs with: peeled fully-peeled &bslash;n&quot;
suffix:semicolon
multiline_comment|/*&n; * Parse one line from a packed-refs file.  Write the SHA1 to sha1.&n; * Return a pointer to the refname within the line (null-terminated),&n; * or NULL if there was a problem.&n; */
DECL|function|parse_ref_line
r_static
r_const
r_char
op_star
id|parse_ref_line
c_func
(paren
r_struct
id|strbuf
op_star
id|line
comma
r_int
r_char
op_star
id|sha1
)paren
(brace
r_const
r_char
op_star
id|ref
suffix:semicolon
multiline_comment|/*&n;&t; * 42: the answer to everything.&n;&t; *&n;&t; * In this case, it happens to be the answer to&n;&t; *  40 (length of sha1 hex representation)&n;&t; *  +1 (space in between hex and name)&n;&t; *  +1 (newline at the end of the line)&n;&t; */
r_if
c_cond
(paren
id|line-&gt;len
op_le
l_int|42
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|line-&gt;buf
comma
id|sha1
)paren
OL
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|isspace
c_func
(paren
id|line-&gt;buf
(braket
l_int|40
)braket
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|ref
op_assign
id|line-&gt;buf
op_plus
l_int|41
suffix:semicolon
r_if
c_cond
(paren
id|isspace
c_func
(paren
op_star
id|ref
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|line-&gt;buf
(braket
id|line-&gt;len
l_int|1
)braket
op_ne
l_char|&squot;&bslash;n&squot;
)paren
r_return
l_int|NULL
suffix:semicolon
id|line-&gt;buf
(braket
op_decrement
id|line-&gt;len
)braket
op_assign
l_int|0
suffix:semicolon
r_return
id|ref
suffix:semicolon
)brace
multiline_comment|/*&n; * Read f, which is a packed-refs file, into dir.&n; *&n; * A comment line of the form &quot;# pack-refs with: &quot; may contain zero or&n; * more traits. We interpret the traits as follows:&n; *&n; *   No traits:&n; *&n; *      Probably no references are peeled. But if the file contains a&n; *      peeled value for a reference, we will use it.&n; *&n; *   peeled:&n; *&n; *      References under &quot;refs/tags/&quot;, if they *can* be peeled, *are*&n; *      peeled in this file. References outside of &quot;refs/tags/&quot; are&n; *      probably not peeled even if they could have been, but if we find&n; *      a peeled value for such a reference we will use it.&n; *&n; *   fully-peeled:&n; *&n; *      All references in the file that can be peeled are peeled.&n; *      Inversely (and this is more important), any references in the&n; *      file for which no peeled value is recorded is not peelable. This&n; *      trait should typically be written alongside &quot;peeled&quot; for&n; *      compatibility with older clients, but we do not require it&n; *      (i.e., &quot;peeled&quot; is a no-op if &quot;fully-peeled&quot; is set).&n; */
DECL|function|read_packed_refs
r_static
r_void
id|read_packed_refs
c_func
(paren
id|FILE
op_star
id|f
comma
r_struct
id|ref_dir
op_star
id|dir
)paren
(brace
r_struct
id|ref_entry
op_star
id|last
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|strbuf
id|line
op_assign
id|STRBUF_INIT
suffix:semicolon
r_enum
(brace
id|PEELED_NONE
comma
id|PEELED_TAGS
comma
id|PEELED_FULLY
)brace
id|peeled
op_assign
id|PEELED_NONE
suffix:semicolon
r_while
c_loop
(paren
id|strbuf_getwholeline
c_func
(paren
op_amp
id|line
comma
id|f
comma
l_char|&squot;&bslash;n&squot;
)paren
op_ne
id|EOF
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_const
r_char
op_star
id|refname
suffix:semicolon
r_const
r_char
op_star
id|traits
suffix:semicolon
r_if
c_cond
(paren
id|skip_prefix
c_func
(paren
id|line.buf
comma
l_string|&quot;# pack-refs with:&quot;
comma
op_amp
id|traits
)paren
)paren
(brace
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|traits
comma
l_string|&quot; fully-peeled &quot;
)paren
)paren
id|peeled
op_assign
id|PEELED_FULLY
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|traits
comma
l_string|&quot; peeled &quot;
)paren
)paren
id|peeled
op_assign
id|PEELED_TAGS
suffix:semicolon
multiline_comment|/* perhaps other traits later as well */
r_continue
suffix:semicolon
)brace
id|refname
op_assign
id|parse_ref_line
c_func
(paren
op_amp
id|line
comma
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|refname
)paren
(brace
r_int
id|flag
op_assign
id|REF_ISPACKED
suffix:semicolon
r_if
c_cond
(paren
id|check_refname_format
c_func
(paren
id|refname
comma
id|REFNAME_ALLOW_ONELEVEL
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|refname_is_safe
c_func
(paren
id|refname
)paren
)paren
id|die
c_func
(paren
l_string|&quot;packed refname is dangerous: %s&quot;
comma
id|refname
)paren
suffix:semicolon
id|hashclr
c_func
(paren
id|sha1
)paren
suffix:semicolon
id|flag
op_or_assign
id|REF_BAD_NAME
op_or
id|REF_ISBROKEN
suffix:semicolon
)brace
id|last
op_assign
id|create_ref_entry
c_func
(paren
id|refname
comma
id|sha1
comma
id|flag
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|peeled
op_eq
id|PEELED_FULLY
op_logical_or
(paren
id|peeled
op_eq
id|PEELED_TAGS
op_logical_and
id|starts_with
c_func
(paren
id|refname
comma
l_string|&quot;refs/tags/&quot;
)paren
)paren
)paren
id|last-&gt;flag
op_or_assign
id|REF_KNOWS_PEELED
suffix:semicolon
id|add_ref
c_func
(paren
id|dir
comma
id|last
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|last
op_logical_and
id|line.buf
(braket
l_int|0
)braket
op_eq
l_char|&squot;^&squot;
op_logical_and
id|line.len
op_eq
id|PEELED_LINE_LENGTH
op_logical_and
id|line.buf
(braket
id|PEELED_LINE_LENGTH
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
op_logical_and
op_logical_neg
id|get_sha1_hex
c_func
(paren
id|line.buf
op_plus
l_int|1
comma
id|sha1
)paren
)paren
(brace
id|hashcpy
c_func
(paren
id|last-&gt;u.value.peeled.hash
comma
id|sha1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Regardless of what the file header said,&n;&t;&t;&t; * we definitely know the value of *this*&n;&t;&t;&t; * reference:&n;&t;&t;&t; */
id|last-&gt;flag
op_or_assign
id|REF_KNOWS_PEELED
suffix:semicolon
)brace
)brace
id|strbuf_release
c_func
(paren
op_amp
id|line
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Get the packed_ref_cache for the specified ref_cache, creating it&n; * if necessary.&n; */
DECL|function|get_packed_ref_cache
r_static
r_struct
id|packed_ref_cache
op_star
id|get_packed_ref_cache
c_func
(paren
r_struct
id|ref_cache
op_star
id|refs
)paren
(brace
r_char
op_star
id|packed_refs_file
suffix:semicolon
r_if
c_cond
(paren
op_star
id|refs-&gt;name
)paren
id|packed_refs_file
op_assign
id|git_pathdup_submodule
c_func
(paren
id|refs-&gt;name
comma
l_string|&quot;packed-refs&quot;
)paren
suffix:semicolon
r_else
id|packed_refs_file
op_assign
id|git_pathdup
c_func
(paren
l_string|&quot;packed-refs&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|refs-&gt;packed
op_logical_and
op_logical_neg
id|stat_validity_check
c_func
(paren
op_amp
id|refs-&gt;packed-&gt;validity
comma
id|packed_refs_file
)paren
)paren
id|clear_packed_ref_cache
c_func
(paren
id|refs
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|refs-&gt;packed
)paren
(brace
id|FILE
op_star
id|f
suffix:semicolon
id|refs-&gt;packed
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|refs-&gt;packed
)paren
)paren
suffix:semicolon
id|acquire_packed_ref_cache
c_func
(paren
id|refs-&gt;packed
)paren
suffix:semicolon
id|refs-&gt;packed-&gt;root
op_assign
id|create_dir_entry
c_func
(paren
id|refs
comma
l_string|&quot;&quot;
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|f
op_assign
id|fopen
c_func
(paren
id|packed_refs_file
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|f
)paren
(brace
id|stat_validity_update
c_func
(paren
op_amp
id|refs-&gt;packed-&gt;validity
comma
id|fileno
c_func
(paren
id|f
)paren
)paren
suffix:semicolon
id|read_packed_refs
c_func
(paren
id|f
comma
id|get_ref_dir
c_func
(paren
id|refs-&gt;packed-&gt;root
)paren
)paren
suffix:semicolon
id|fclose
c_func
(paren
id|f
)paren
suffix:semicolon
)brace
)brace
id|free
c_func
(paren
id|packed_refs_file
)paren
suffix:semicolon
r_return
id|refs-&gt;packed
suffix:semicolon
)brace
DECL|function|get_packed_ref_dir
r_static
r_struct
id|ref_dir
op_star
id|get_packed_ref_dir
c_func
(paren
r_struct
id|packed_ref_cache
op_star
id|packed_ref_cache
)paren
(brace
r_return
id|get_ref_dir
c_func
(paren
id|packed_ref_cache-&gt;root
)paren
suffix:semicolon
)brace
DECL|function|get_packed_refs
r_static
r_struct
id|ref_dir
op_star
id|get_packed_refs
c_func
(paren
r_struct
id|ref_cache
op_star
id|refs
)paren
(brace
r_return
id|get_packed_ref_dir
c_func
(paren
id|get_packed_ref_cache
c_func
(paren
id|refs
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a reference to the in-memory packed reference cache.  This may&n; * only be called while the packed-refs file is locked (see&n; * lock_packed_refs()).  To actually write the packed-refs file, call&n; * commit_packed_refs().&n; */
DECL|function|add_packed_ref
r_static
r_void
id|add_packed_ref
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_struct
id|packed_ref_cache
op_star
id|packed_ref_cache
op_assign
id|get_packed_ref_cache
c_func
(paren
op_amp
id|ref_cache
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|packed_ref_cache-&gt;lock
)paren
id|die
c_func
(paren
l_string|&quot;internal error: packed refs not locked&quot;
)paren
suffix:semicolon
id|add_ref
c_func
(paren
id|get_packed_ref_dir
c_func
(paren
id|packed_ref_cache
)paren
comma
id|create_ref_entry
c_func
(paren
id|refname
comma
id|sha1
comma
id|REF_ISPACKED
comma
l_int|1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Read the loose references from the namespace dirname into dir&n; * (without recursing).  dirname must end with &squot;/&squot;.  dir must be the&n; * directory entry corresponding to dirname.&n; */
DECL|function|read_loose_refs
r_static
r_void
id|read_loose_refs
c_func
(paren
r_const
r_char
op_star
id|dirname
comma
r_struct
id|ref_dir
op_star
id|dir
)paren
(brace
r_struct
id|ref_cache
op_star
id|refs
op_assign
id|dir-&gt;ref_cache
suffix:semicolon
id|DIR
op_star
id|d
suffix:semicolon
r_struct
id|dirent
op_star
id|de
suffix:semicolon
r_int
id|dirnamelen
op_assign
id|strlen
c_func
(paren
id|dirname
)paren
suffix:semicolon
r_struct
id|strbuf
id|refname
suffix:semicolon
r_struct
id|strbuf
id|path
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|path_baselen
suffix:semicolon
r_if
c_cond
(paren
op_star
id|refs-&gt;name
)paren
id|strbuf_git_path_submodule
c_func
(paren
op_amp
id|path
comma
id|refs-&gt;name
comma
l_string|&quot;%s&quot;
comma
id|dirname
)paren
suffix:semicolon
r_else
id|strbuf_git_path
c_func
(paren
op_amp
id|path
comma
l_string|&quot;%s&quot;
comma
id|dirname
)paren
suffix:semicolon
id|path_baselen
op_assign
id|path.len
suffix:semicolon
id|d
op_assign
id|opendir
c_func
(paren
id|path.buf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|d
)paren
(brace
id|strbuf_release
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|strbuf_init
c_func
(paren
op_amp
id|refname
comma
id|dirnamelen
op_plus
l_int|257
)paren
suffix:semicolon
id|strbuf_add
c_func
(paren
op_amp
id|refname
comma
id|dirname
comma
id|dirnamelen
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|de
op_assign
id|readdir
c_func
(paren
id|d
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_struct
id|stat
id|st
suffix:semicolon
r_int
id|flag
suffix:semicolon
r_if
c_cond
(paren
id|de-&gt;d_name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|ends_with
c_func
(paren
id|de-&gt;d_name
comma
l_string|&quot;.lock&quot;
)paren
)paren
r_continue
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|refname
comma
id|de-&gt;d_name
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|path
comma
id|de-&gt;d_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
c_func
(paren
id|path.buf
comma
op_amp
id|st
)paren
OL
l_int|0
)paren
(brace
suffix:semicolon
multiline_comment|/* silently ignore */
)brace
r_else
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|st.st_mode
)paren
)paren
(brace
id|strbuf_addch
c_func
(paren
op_amp
id|refname
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
id|add_entry_to_dir
c_func
(paren
id|dir
comma
id|create_dir_entry
c_func
(paren
id|refs
comma
id|refname.buf
comma
id|refname.len
comma
l_int|1
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|read_ok
suffix:semicolon
r_if
c_cond
(paren
op_star
id|refs-&gt;name
)paren
(brace
id|hashclr
c_func
(paren
id|sha1
)paren
suffix:semicolon
id|flag
op_assign
l_int|0
suffix:semicolon
id|read_ok
op_assign
op_logical_neg
id|resolve_gitlink_ref
c_func
(paren
id|refs-&gt;name
comma
id|refname.buf
comma
id|sha1
)paren
suffix:semicolon
)brace
r_else
(brace
id|read_ok
op_assign
op_logical_neg
id|read_ref_full
c_func
(paren
id|refname.buf
comma
id|RESOLVE_REF_READING
comma
id|sha1
comma
op_amp
id|flag
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|read_ok
)paren
(brace
id|hashclr
c_func
(paren
id|sha1
)paren
suffix:semicolon
id|flag
op_or_assign
id|REF_ISBROKEN
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|is_null_sha1
c_func
(paren
id|sha1
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * It is so astronomically unlikely&n;&t;&t;&t;&t; * that NULL_SHA1 is the SHA-1 of an&n;&t;&t;&t;&t; * actual object that we consider its&n;&t;&t;&t;&t; * appearance in a loose reference&n;&t;&t;&t;&t; * file to be repo corruption&n;&t;&t;&t;&t; * (probably due to a software bug).&n;&t;&t;&t;&t; */
id|flag
op_or_assign
id|REF_ISBROKEN
suffix:semicolon
)brace
r_if
c_cond
(paren
id|check_refname_format
c_func
(paren
id|refname.buf
comma
id|REFNAME_ALLOW_ONELEVEL
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|refname_is_safe
c_func
(paren
id|refname.buf
)paren
)paren
id|die
c_func
(paren
l_string|&quot;loose refname is dangerous: %s&quot;
comma
id|refname.buf
)paren
suffix:semicolon
id|hashclr
c_func
(paren
id|sha1
)paren
suffix:semicolon
id|flag
op_or_assign
id|REF_BAD_NAME
op_or
id|REF_ISBROKEN
suffix:semicolon
)brace
id|add_entry_to_dir
c_func
(paren
id|dir
comma
id|create_ref_entry
c_func
(paren
id|refname.buf
comma
id|sha1
comma
id|flag
comma
l_int|0
)paren
)paren
suffix:semicolon
)brace
id|strbuf_setlen
c_func
(paren
op_amp
id|refname
comma
id|dirnamelen
)paren
suffix:semicolon
id|strbuf_setlen
c_func
(paren
op_amp
id|path
comma
id|path_baselen
)paren
suffix:semicolon
)brace
id|strbuf_release
c_func
(paren
op_amp
id|refname
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
id|closedir
c_func
(paren
id|d
)paren
suffix:semicolon
)brace
DECL|function|get_loose_refs
r_static
r_struct
id|ref_dir
op_star
id|get_loose_refs
c_func
(paren
r_struct
id|ref_cache
op_star
id|refs
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|refs-&gt;loose
)paren
(brace
multiline_comment|/*&n;&t;&t; * Mark the top-level directory complete because we&n;&t;&t; * are about to read the only subdirectory that can&n;&t;&t; * hold references:&n;&t;&t; */
id|refs-&gt;loose
op_assign
id|create_dir_entry
c_func
(paren
id|refs
comma
l_string|&quot;&quot;
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Create an incomplete entry for &quot;refs/&quot;:&n;&t;&t; */
id|add_entry_to_dir
c_func
(paren
id|get_ref_dir
c_func
(paren
id|refs-&gt;loose
)paren
comma
id|create_dir_entry
c_func
(paren
id|refs
comma
l_string|&quot;refs/&quot;
comma
l_int|5
comma
l_int|1
)paren
)paren
suffix:semicolon
)brace
r_return
id|get_ref_dir
c_func
(paren
id|refs-&gt;loose
)paren
suffix:semicolon
)brace
multiline_comment|/* We allow &quot;recursive&quot; symbolic refs. Only within reason, though */
DECL|macro|MAXDEPTH
mdefine_line|#define MAXDEPTH 5
DECL|macro|MAXREFLEN
mdefine_line|#define MAXREFLEN (1024)
multiline_comment|/*&n; * Called by resolve_gitlink_ref_recursive() after it failed to read&n; * from the loose refs in ref_cache refs. Find &lt;refname&gt; in the&n; * packed-refs file for the submodule.&n; */
DECL|function|resolve_gitlink_packed_ref
r_static
r_int
id|resolve_gitlink_packed_ref
c_func
(paren
r_struct
id|ref_cache
op_star
id|refs
comma
r_const
r_char
op_star
id|refname
comma
r_int
r_char
op_star
id|sha1
)paren
(brace
r_struct
id|ref_entry
op_star
id|ref
suffix:semicolon
r_struct
id|ref_dir
op_star
id|dir
op_assign
id|get_packed_refs
c_func
(paren
id|refs
)paren
suffix:semicolon
id|ref
op_assign
id|find_ref
c_func
(paren
id|dir
comma
id|refname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ref
op_eq
l_int|NULL
)paren
r_return
l_int|1
suffix:semicolon
id|hashcpy
c_func
(paren
id|sha1
comma
id|ref-&gt;u.value.oid.hash
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|resolve_gitlink_ref_recursive
r_static
r_int
id|resolve_gitlink_ref_recursive
c_func
(paren
r_struct
id|ref_cache
op_star
id|refs
comma
r_const
r_char
op_star
id|refname
comma
r_int
r_char
op_star
id|sha1
comma
r_int
id|recursion
)paren
(brace
r_int
id|fd
comma
id|len
suffix:semicolon
r_char
id|buffer
(braket
l_int|128
)braket
comma
op_star
id|p
suffix:semicolon
r_char
op_star
id|path
suffix:semicolon
r_if
c_cond
(paren
id|recursion
OG
id|MAXDEPTH
op_logical_or
id|strlen
c_func
(paren
id|refname
)paren
OG
id|MAXREFLEN
)paren
r_return
l_int|1
suffix:semicolon
id|path
op_assign
op_star
id|refs-&gt;name
ques
c_cond
id|git_pathdup_submodule
c_func
(paren
id|refs-&gt;name
comma
l_string|&quot;%s&quot;
comma
id|refname
)paren
suffix:colon
id|git_pathdup
c_func
(paren
l_string|&quot;%s&quot;
comma
id|refname
)paren
suffix:semicolon
id|fd
op_assign
id|open
c_func
(paren
id|path
comma
id|O_RDONLY
)paren
suffix:semicolon
id|free
c_func
(paren
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
r_return
id|resolve_gitlink_packed_ref
c_func
(paren
id|refs
comma
id|refname
comma
id|sha1
)paren
suffix:semicolon
id|len
op_assign
id|read
c_func
(paren
id|fd
comma
id|buffer
comma
r_sizeof
(paren
id|buffer
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|len
op_logical_and
id|isspace
c_func
(paren
id|buffer
(braket
id|len
op_minus
l_int|1
)braket
)paren
)paren
id|len
op_decrement
suffix:semicolon
id|buffer
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Was it a detached head or an old-fashioned symlink? */
r_if
c_cond
(paren
op_logical_neg
id|get_sha1_hex
c_func
(paren
id|buffer
comma
id|sha1
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Symref? */
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|buffer
comma
l_string|&quot;ref:&quot;
comma
l_int|4
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|p
op_assign
id|buffer
op_plus
l_int|4
suffix:semicolon
r_while
c_loop
(paren
id|isspace
c_func
(paren
op_star
id|p
)paren
)paren
id|p
op_increment
suffix:semicolon
r_return
id|resolve_gitlink_ref_recursive
c_func
(paren
id|refs
comma
id|p
comma
id|sha1
comma
id|recursion
op_plus
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|resolve_gitlink_ref
r_int
id|resolve_gitlink_ref
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_const
r_char
op_star
id|refname
comma
r_int
r_char
op_star
id|sha1
)paren
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|path
)paren
comma
id|retval
suffix:semicolon
r_char
op_star
id|submodule
suffix:semicolon
r_struct
id|ref_cache
op_star
id|refs
suffix:semicolon
r_while
c_loop
(paren
id|len
op_logical_and
id|path
(braket
id|len
op_minus
l_int|1
)braket
op_eq
l_char|&squot;/&squot;
)paren
id|len
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
r_return
l_int|1
suffix:semicolon
id|submodule
op_assign
id|xstrndup
c_func
(paren
id|path
comma
id|len
)paren
suffix:semicolon
id|refs
op_assign
id|get_ref_cache
c_func
(paren
id|submodule
)paren
suffix:semicolon
id|free
c_func
(paren
id|submodule
)paren
suffix:semicolon
id|retval
op_assign
id|resolve_gitlink_ref_recursive
c_func
(paren
id|refs
comma
id|refname
comma
id|sha1
comma
l_int|0
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Return the ref_entry for the given refname from the packed&n; * references.  If it does not exist, return NULL.&n; */
DECL|function|get_packed_ref
r_static
r_struct
id|ref_entry
op_star
id|get_packed_ref
c_func
(paren
r_const
r_char
op_star
id|refname
)paren
(brace
r_return
id|find_ref
c_func
(paren
id|get_packed_refs
c_func
(paren
op_amp
id|ref_cache
)paren
comma
id|refname
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * A loose ref file doesn&squot;t exist; check for a packed ref.  The&n; * options are forwarded from resolve_safe_unsafe().&n; */
DECL|function|resolve_missing_loose_ref
r_static
r_int
id|resolve_missing_loose_ref
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_int
id|resolve_flags
comma
r_int
r_char
op_star
id|sha1
comma
r_int
op_star
id|flags
)paren
(brace
r_struct
id|ref_entry
op_star
id|entry
suffix:semicolon
multiline_comment|/*&n;&t; * The loose reference file does not exist; check for a packed&n;&t; * reference.&n;&t; */
id|entry
op_assign
id|get_packed_ref
c_func
(paren
id|refname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
)paren
(brace
id|hashcpy
c_func
(paren
id|sha1
comma
id|entry-&gt;u.value.oid.hash
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
)paren
op_star
id|flags
op_or_assign
id|REF_ISPACKED
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* The reference is not a packed reference, either. */
r_if
c_cond
(paren
id|resolve_flags
op_amp
id|RESOLVE_REF_READING
)paren
(brace
id|errno
op_assign
id|ENOENT
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|hashclr
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* This function needs to return a meaningful errno on failure */
DECL|function|resolve_ref_1
r_static
r_const
r_char
op_star
id|resolve_ref_1
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_int
id|resolve_flags
comma
r_int
r_char
op_star
id|sha1
comma
r_int
op_star
id|flags
comma
r_struct
id|strbuf
op_star
id|sb_refname
comma
r_struct
id|strbuf
op_star
id|sb_path
comma
r_struct
id|strbuf
op_star
id|sb_contents
)paren
(brace
r_int
id|depth
op_assign
id|MAXDEPTH
suffix:semicolon
r_int
id|bad_name
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|flags
)paren
op_star
id|flags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|check_refname_format
c_func
(paren
id|refname
comma
id|REFNAME_ALLOW_ONELEVEL
)paren
)paren
(brace
r_if
c_cond
(paren
id|flags
)paren
op_star
id|flags
op_or_assign
id|REF_BAD_NAME
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|resolve_flags
op_amp
id|RESOLVE_REF_ALLOW_BAD_NAME
)paren
op_logical_or
op_logical_neg
id|refname_is_safe
c_func
(paren
id|refname
)paren
)paren
(brace
id|errno
op_assign
id|EINVAL
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * dwim_ref() uses REF_ISBROKEN to distinguish between&n;&t;&t; * missing refs and refs that were present but invalid,&n;&t;&t; * to complain about the latter to stderr.&n;&t;&t; *&n;&t;&t; * We don&squot;t know whether the ref exists, so don&squot;t set&n;&t;&t; * REF_ISBROKEN yet.&n;&t;&t; */
id|bad_name
op_assign
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_const
r_char
op_star
id|path
suffix:semicolon
r_struct
id|stat
id|st
suffix:semicolon
r_char
op_star
id|buf
suffix:semicolon
r_int
id|fd
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|depth
OL
l_int|0
)paren
(brace
id|errno
op_assign
id|ELOOP
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|strbuf_reset
c_func
(paren
id|sb_path
)paren
suffix:semicolon
id|strbuf_git_path
c_func
(paren
id|sb_path
comma
l_string|&quot;%s&quot;
comma
id|refname
)paren
suffix:semicolon
id|path
op_assign
id|sb_path-&gt;buf
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We might have to loop back here to avoid a race&n;&t;&t; * condition: first we lstat() the file, then we try&n;&t;&t; * to read it as a link or as a file.  But if somebody&n;&t;&t; * changes the type of the file (file &lt;-&gt; directory&n;&t;&t; * &lt;-&gt; symlink) between the lstat() and reading, then&n;&t;&t; * we don&squot;t want to report that as an error but rather&n;&t;&t; * try again starting with the lstat().&n;&t;&t; */
id|stat_ref
suffix:colon
r_if
c_cond
(paren
id|lstat
c_func
(paren
id|path
comma
op_amp
id|st
)paren
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|errno
op_ne
id|ENOENT
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|resolve_missing_loose_ref
c_func
(paren
id|refname
comma
id|resolve_flags
comma
id|sha1
comma
id|flags
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|bad_name
)paren
(brace
id|hashclr
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
)paren
op_star
id|flags
op_or_assign
id|REF_ISBROKEN
suffix:semicolon
)brace
r_return
id|refname
suffix:semicolon
)brace
multiline_comment|/* Follow &quot;normalized&quot; - ie &quot;refs/..&quot; symlinks by hand */
r_if
c_cond
(paren
id|S_ISLNK
c_func
(paren
id|st.st_mode
)paren
)paren
(brace
id|strbuf_reset
c_func
(paren
id|sb_contents
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strbuf_readlink
c_func
(paren
id|sb_contents
comma
id|path
comma
l_int|0
)paren
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|errno
op_eq
id|ENOENT
op_logical_or
id|errno
op_eq
id|EINVAL
)paren
multiline_comment|/* inconsistent with lstat; retry */
r_goto
id|stat_ref
suffix:semicolon
r_else
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|sb_contents-&gt;buf
comma
l_string|&quot;refs/&quot;
)paren
op_logical_and
op_logical_neg
id|check_refname_format
c_func
(paren
id|sb_contents-&gt;buf
comma
l_int|0
)paren
)paren
(brace
id|strbuf_swap
c_func
(paren
id|sb_refname
comma
id|sb_contents
)paren
suffix:semicolon
id|refname
op_assign
id|sb_refname-&gt;buf
suffix:semicolon
r_if
c_cond
(paren
id|flags
)paren
op_star
id|flags
op_or_assign
id|REF_ISSYMREF
suffix:semicolon
r_if
c_cond
(paren
id|resolve_flags
op_amp
id|RESOLVE_REF_NO_RECURSE
)paren
(brace
id|hashclr
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_return
id|refname
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
)brace
multiline_comment|/* Is it a directory? */
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|st.st_mode
)paren
)paren
(brace
id|errno
op_assign
id|EISDIR
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Anything else, just open it and try to use it as&n;&t;&t; * a ref&n;&t;&t; */
id|fd
op_assign
id|open
c_func
(paren
id|path
comma
id|O_RDONLY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|errno
op_eq
id|ENOENT
)paren
multiline_comment|/* inconsistent with lstat; retry */
r_goto
id|stat_ref
suffix:semicolon
r_else
r_return
l_int|NULL
suffix:semicolon
)brace
id|strbuf_reset
c_func
(paren
id|sb_contents
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strbuf_read
c_func
(paren
id|sb_contents
comma
id|fd
comma
l_int|256
)paren
OL
l_int|0
)paren
(brace
r_int
id|save_errno
op_assign
id|errno
suffix:semicolon
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
id|errno
op_assign
id|save_errno
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
id|strbuf_rtrim
c_func
(paren
id|sb_contents
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Is it a symbolic ref?&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|starts_with
c_func
(paren
id|sb_contents-&gt;buf
comma
l_string|&quot;ref:&quot;
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Please note that FETCH_HEAD has a second&n;&t;&t;&t; * line containing other data.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|sb_contents-&gt;buf
comma
id|sha1
)paren
op_logical_or
(paren
id|sb_contents-&gt;buf
(braket
l_int|40
)braket
op_ne
l_char|&squot;&bslash;0&squot;
op_logical_and
op_logical_neg
id|isspace
c_func
(paren
id|sb_contents-&gt;buf
(braket
l_int|40
)braket
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|flags
)paren
op_star
id|flags
op_or_assign
id|REF_ISBROKEN
suffix:semicolon
id|errno
op_assign
id|EINVAL
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bad_name
)paren
(brace
id|hashclr
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
)paren
op_star
id|flags
op_or_assign
id|REF_ISBROKEN
suffix:semicolon
)brace
r_return
id|refname
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
)paren
op_star
id|flags
op_or_assign
id|REF_ISSYMREF
suffix:semicolon
id|buf
op_assign
id|sb_contents-&gt;buf
op_plus
l_int|4
suffix:semicolon
r_while
c_loop
(paren
id|isspace
c_func
(paren
op_star
id|buf
)paren
)paren
id|buf
op_increment
suffix:semicolon
id|strbuf_reset
c_func
(paren
id|sb_refname
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
id|sb_refname
comma
id|buf
)paren
suffix:semicolon
id|refname
op_assign
id|sb_refname-&gt;buf
suffix:semicolon
r_if
c_cond
(paren
id|resolve_flags
op_amp
id|RESOLVE_REF_NO_RECURSE
)paren
(brace
id|hashclr
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_return
id|refname
suffix:semicolon
)brace
r_if
c_cond
(paren
id|check_refname_format
c_func
(paren
id|buf
comma
id|REFNAME_ALLOW_ONELEVEL
)paren
)paren
(brace
r_if
c_cond
(paren
id|flags
)paren
op_star
id|flags
op_or_assign
id|REF_ISBROKEN
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|resolve_flags
op_amp
id|RESOLVE_REF_ALLOW_BAD_NAME
)paren
op_logical_or
op_logical_neg
id|refname_is_safe
c_func
(paren
id|buf
)paren
)paren
(brace
id|errno
op_assign
id|EINVAL
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|bad_name
op_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
DECL|function|resolve_ref_unsafe
r_const
r_char
op_star
id|resolve_ref_unsafe
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_int
id|resolve_flags
comma
r_int
r_char
op_star
id|sha1
comma
r_int
op_star
id|flags
)paren
(brace
r_static
r_struct
id|strbuf
id|sb_refname
op_assign
id|STRBUF_INIT
suffix:semicolon
r_struct
id|strbuf
id|sb_contents
op_assign
id|STRBUF_INIT
suffix:semicolon
r_struct
id|strbuf
id|sb_path
op_assign
id|STRBUF_INIT
suffix:semicolon
r_const
r_char
op_star
id|ret
suffix:semicolon
id|ret
op_assign
id|resolve_ref_1
c_func
(paren
id|refname
comma
id|resolve_flags
comma
id|sha1
comma
id|flags
comma
op_amp
id|sb_refname
comma
op_amp
id|sb_path
comma
op_amp
id|sb_contents
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb_path
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb_contents
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Peel the entry (if possible) and return its new peel_status.  If&n; * repeel is true, re-peel the entry even if there is an old peeled&n; * value that is already stored in it.&n; *&n; * It is OK to call this function with a packed reference entry that&n; * might be stale and might even refer to an object that has since&n; * been garbage-collected.  In such a case, if the entry has&n; * REF_KNOWS_PEELED then leave the status unchanged and return&n; * PEEL_PEELED or PEEL_NON_TAG; otherwise, return PEEL_INVALID.&n; */
DECL|function|peel_entry
r_static
r_enum
id|peel_status
id|peel_entry
c_func
(paren
r_struct
id|ref_entry
op_star
id|entry
comma
r_int
id|repeel
)paren
(brace
r_enum
id|peel_status
id|status
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;flag
op_amp
id|REF_KNOWS_PEELED
)paren
(brace
r_if
c_cond
(paren
id|repeel
)paren
(brace
id|entry-&gt;flag
op_and_assign
op_complement
id|REF_KNOWS_PEELED
suffix:semicolon
id|oidclr
c_func
(paren
op_amp
id|entry-&gt;u.value.peeled
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
id|is_null_oid
c_func
(paren
op_amp
id|entry-&gt;u.value.peeled
)paren
ques
c_cond
id|PEEL_NON_TAG
suffix:colon
id|PEEL_PEELED
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|entry-&gt;flag
op_amp
id|REF_ISBROKEN
)paren
r_return
id|PEEL_BROKEN
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;flag
op_amp
id|REF_ISSYMREF
)paren
r_return
id|PEEL_IS_SYMREF
suffix:semicolon
id|status
op_assign
id|peel_object
c_func
(paren
id|entry-&gt;u.value.oid.hash
comma
id|entry-&gt;u.value.peeled.hash
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
id|PEEL_PEELED
op_logical_or
id|status
op_eq
id|PEEL_NON_TAG
)paren
id|entry-&gt;flag
op_or_assign
id|REF_KNOWS_PEELED
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
DECL|function|peel_ref
r_int
id|peel_ref
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_int
r_char
op_star
id|sha1
)paren
(brace
r_int
id|flag
suffix:semicolon
r_int
r_char
id|base
(braket
l_int|20
)braket
suffix:semicolon
r_if
c_cond
(paren
id|current_ref
op_logical_and
(paren
id|current_ref-&gt;name
op_eq
id|refname
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|current_ref-&gt;name
comma
id|refname
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|peel_entry
c_func
(paren
id|current_ref
comma
l_int|0
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|hashcpy
c_func
(paren
id|sha1
comma
id|current_ref-&gt;u.value.peeled.hash
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|read_ref_full
c_func
(paren
id|refname
comma
id|RESOLVE_REF_READING
comma
id|base
comma
op_amp
id|flag
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * If the reference is packed, read its ref_entry from the&n;&t; * cache in the hope that we already know its peeled value.&n;&t; * We only try this optimization on packed references because&n;&t; * (a) forcing the filling of the loose reference cache could&n;&t; * be expensive and (b) loose references anyway usually do not&n;&t; * have REF_KNOWS_PEELED.&n;&t; */
r_if
c_cond
(paren
id|flag
op_amp
id|REF_ISPACKED
)paren
(brace
r_struct
id|ref_entry
op_star
id|r
op_assign
id|get_packed_ref
c_func
(paren
id|refname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
(brace
r_if
c_cond
(paren
id|peel_entry
c_func
(paren
id|r
comma
l_int|0
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|hashcpy
c_func
(paren
id|sha1
comma
id|r-&gt;u.value.peeled.hash
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
id|peel_object
c_func
(paren
id|base
comma
id|sha1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Call fn for each reference in the specified ref_cache, omitting&n; * references not in the containing_dir of base.  fn is called for all&n; * references, including broken ones.  If fn ever returns a non-zero&n; * value, stop the iteration and return that value; otherwise, return&n; * 0.&n; */
DECL|function|do_for_each_entry
r_static
r_int
id|do_for_each_entry
c_func
(paren
r_struct
id|ref_cache
op_star
id|refs
comma
r_const
r_char
op_star
id|base
comma
id|each_ref_entry_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_struct
id|packed_ref_cache
op_star
id|packed_ref_cache
suffix:semicolon
r_struct
id|ref_dir
op_star
id|loose_dir
suffix:semicolon
r_struct
id|ref_dir
op_star
id|packed_dir
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * We must make sure that all loose refs are read before accessing the&n;&t; * packed-refs file; this avoids a race condition in which loose refs&n;&t; * are migrated to the packed-refs file by a simultaneous process, but&n;&t; * our in-memory view is from before the migration. get_packed_ref_cache()&n;&t; * takes care of making sure our view is up to date with what is on&n;&t; * disk.&n;&t; */
id|loose_dir
op_assign
id|get_loose_refs
c_func
(paren
id|refs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base
op_logical_and
op_star
id|base
)paren
(brace
id|loose_dir
op_assign
id|find_containing_dir
c_func
(paren
id|loose_dir
comma
id|base
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|loose_dir
)paren
id|prime_ref_dir
c_func
(paren
id|loose_dir
)paren
suffix:semicolon
id|packed_ref_cache
op_assign
id|get_packed_ref_cache
c_func
(paren
id|refs
)paren
suffix:semicolon
id|acquire_packed_ref_cache
c_func
(paren
id|packed_ref_cache
)paren
suffix:semicolon
id|packed_dir
op_assign
id|get_packed_ref_dir
c_func
(paren
id|packed_ref_cache
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base
op_logical_and
op_star
id|base
)paren
(brace
id|packed_dir
op_assign
id|find_containing_dir
c_func
(paren
id|packed_dir
comma
id|base
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|packed_dir
op_logical_and
id|loose_dir
)paren
(brace
id|sort_ref_dir
c_func
(paren
id|packed_dir
)paren
suffix:semicolon
id|sort_ref_dir
c_func
(paren
id|loose_dir
)paren
suffix:semicolon
id|retval
op_assign
id|do_for_each_entry_in_dirs
c_func
(paren
id|packed_dir
comma
id|loose_dir
comma
id|fn
comma
id|cb_data
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|packed_dir
)paren
(brace
id|sort_ref_dir
c_func
(paren
id|packed_dir
)paren
suffix:semicolon
id|retval
op_assign
id|do_for_each_entry_in_dir
c_func
(paren
id|packed_dir
comma
l_int|0
comma
id|fn
comma
id|cb_data
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|loose_dir
)paren
(brace
id|sort_ref_dir
c_func
(paren
id|loose_dir
)paren
suffix:semicolon
id|retval
op_assign
id|do_for_each_entry_in_dir
c_func
(paren
id|loose_dir
comma
l_int|0
comma
id|fn
comma
id|cb_data
)paren
suffix:semicolon
)brace
id|release_packed_ref_cache
c_func
(paren
id|packed_ref_cache
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Call fn for each reference in the specified ref_cache for which the&n; * refname begins with base.  If trim is non-zero, then trim that many&n; * characters off the beginning of each refname before passing the&n; * refname to fn.  flags can be DO_FOR_EACH_INCLUDE_BROKEN to include&n; * broken references in the iteration.  If fn ever returns a non-zero&n; * value, stop the iteration and return that value; otherwise, return&n; * 0.&n; */
DECL|function|do_for_each_ref
r_static
r_int
id|do_for_each_ref
c_func
(paren
r_struct
id|ref_cache
op_star
id|refs
comma
r_const
r_char
op_star
id|base
comma
id|each_ref_fn
id|fn
comma
r_int
id|trim
comma
r_int
id|flags
comma
r_void
op_star
id|cb_data
)paren
(brace
r_struct
id|ref_entry_cb
id|data
suffix:semicolon
id|data.base
op_assign
id|base
suffix:semicolon
id|data.trim
op_assign
id|trim
suffix:semicolon
id|data.flags
op_assign
id|flags
suffix:semicolon
id|data.fn
op_assign
id|fn
suffix:semicolon
id|data.cb_data
op_assign
id|cb_data
suffix:semicolon
r_if
c_cond
(paren
id|ref_paranoia
OL
l_int|0
)paren
id|ref_paranoia
op_assign
id|git_env_bool
c_func
(paren
l_string|&quot;GIT_REF_PARANOIA&quot;
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ref_paranoia
)paren
id|data.flags
op_or_assign
id|DO_FOR_EACH_INCLUDE_BROKEN
suffix:semicolon
r_return
id|do_for_each_entry
c_func
(paren
id|refs
comma
id|base
comma
id|do_one_ref
comma
op_amp
id|data
)paren
suffix:semicolon
)brace
DECL|function|do_head_ref
r_static
r_int
id|do_head_ref
c_func
(paren
r_const
r_char
op_star
id|submodule
comma
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_struct
id|object_id
id|oid
suffix:semicolon
r_int
id|flag
suffix:semicolon
r_if
c_cond
(paren
id|submodule
)paren
(brace
r_if
c_cond
(paren
id|resolve_gitlink_ref
c_func
(paren
id|submodule
comma
l_string|&quot;HEAD&quot;
comma
id|oid.hash
)paren
op_eq
l_int|0
)paren
r_return
id|fn
c_func
(paren
l_string|&quot;HEAD&quot;
comma
op_amp
id|oid
comma
l_int|0
comma
id|cb_data
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|read_ref_full
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|RESOLVE_REF_READING
comma
id|oid.hash
comma
op_amp
id|flag
)paren
)paren
r_return
id|fn
c_func
(paren
l_string|&quot;HEAD&quot;
comma
op_amp
id|oid
comma
id|flag
comma
id|cb_data
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|head_ref
r_int
id|head_ref
c_func
(paren
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|do_head_ref
c_func
(paren
l_int|NULL
comma
id|fn
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|head_ref_submodule
r_int
id|head_ref_submodule
c_func
(paren
r_const
r_char
op_star
id|submodule
comma
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|do_head_ref
c_func
(paren
id|submodule
comma
id|fn
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|for_each_ref
r_int
id|for_each_ref
c_func
(paren
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|do_for_each_ref
c_func
(paren
op_amp
id|ref_cache
comma
l_string|&quot;&quot;
comma
id|fn
comma
l_int|0
comma
l_int|0
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|for_each_ref_submodule
r_int
id|for_each_ref_submodule
c_func
(paren
r_const
r_char
op_star
id|submodule
comma
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|do_for_each_ref
c_func
(paren
id|get_ref_cache
c_func
(paren
id|submodule
)paren
comma
l_string|&quot;&quot;
comma
id|fn
comma
l_int|0
comma
l_int|0
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|for_each_ref_in
r_int
id|for_each_ref_in
c_func
(paren
r_const
r_char
op_star
id|prefix
comma
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|do_for_each_ref
c_func
(paren
op_amp
id|ref_cache
comma
id|prefix
comma
id|fn
comma
id|strlen
c_func
(paren
id|prefix
)paren
comma
l_int|0
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|for_each_fullref_in
r_int
id|for_each_fullref_in
c_func
(paren
r_const
r_char
op_star
id|prefix
comma
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
comma
r_int
r_int
id|broken
)paren
(brace
r_int
r_int
id|flag
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|broken
)paren
id|flag
op_assign
id|DO_FOR_EACH_INCLUDE_BROKEN
suffix:semicolon
r_return
id|do_for_each_ref
c_func
(paren
op_amp
id|ref_cache
comma
id|prefix
comma
id|fn
comma
l_int|0
comma
id|flag
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|for_each_ref_in_submodule
r_int
id|for_each_ref_in_submodule
c_func
(paren
r_const
r_char
op_star
id|submodule
comma
r_const
r_char
op_star
id|prefix
comma
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|do_for_each_ref
c_func
(paren
id|get_ref_cache
c_func
(paren
id|submodule
)paren
comma
id|prefix
comma
id|fn
comma
id|strlen
c_func
(paren
id|prefix
)paren
comma
l_int|0
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|for_each_replace_ref
r_int
id|for_each_replace_ref
c_func
(paren
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|do_for_each_ref
c_func
(paren
op_amp
id|ref_cache
comma
id|git_replace_ref_base
comma
id|fn
comma
id|strlen
c_func
(paren
id|git_replace_ref_base
)paren
comma
l_int|0
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|for_each_namespaced_ref
r_int
id|for_each_namespaced_ref
c_func
(paren
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_struct
id|strbuf
id|buf
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
id|buf
comma
l_string|&quot;%srefs/&quot;
comma
id|get_git_namespace
c_func
(paren
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|do_for_each_ref
c_func
(paren
op_amp
id|ref_cache
comma
id|buf.buf
comma
id|fn
comma
l_int|0
comma
l_int|0
comma
id|cb_data
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|buf
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|for_each_rawref
r_int
id|for_each_rawref
c_func
(paren
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|do_for_each_ref
c_func
(paren
op_amp
id|ref_cache
comma
l_string|&quot;&quot;
comma
id|fn
comma
l_int|0
comma
id|DO_FOR_EACH_INCLUDE_BROKEN
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|unlock_ref
r_static
r_void
id|unlock_ref
c_func
(paren
r_struct
id|ref_lock
op_star
id|lock
)paren
(brace
multiline_comment|/* Do not free lock-&gt;lk -- atexit() still looks at them */
r_if
c_cond
(paren
id|lock-&gt;lk
)paren
id|rollback_lock_file
c_func
(paren
id|lock-&gt;lk
)paren
suffix:semicolon
id|free
c_func
(paren
id|lock-&gt;ref_name
)paren
suffix:semicolon
id|free
c_func
(paren
id|lock-&gt;orig_ref_name
)paren
suffix:semicolon
id|free
c_func
(paren
id|lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Verify that the reference locked by lock has the value old_sha1.&n; * Fail if the reference doesn&squot;t exist and mustexist is set. Return 0&n; * on success. On error, write an error message to err, set errno, and&n; * return a negative value.&n; */
DECL|function|verify_lock
r_static
r_int
id|verify_lock
c_func
(paren
r_struct
id|ref_lock
op_star
id|lock
comma
r_const
r_int
r_char
op_star
id|old_sha1
comma
r_int
id|mustexist
comma
r_struct
id|strbuf
op_star
id|err
)paren
(brace
m_assert
(paren
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_ref_full
c_func
(paren
id|lock-&gt;ref_name
comma
id|mustexist
ques
c_cond
id|RESOLVE_REF_READING
suffix:colon
l_int|0
comma
id|lock-&gt;old_oid.hash
comma
l_int|NULL
)paren
)paren
(brace
r_int
id|save_errno
op_assign
id|errno
suffix:semicolon
id|strbuf_addf
c_func
(paren
id|err
comma
l_string|&quot;can&squot;t verify ref %s&quot;
comma
id|lock-&gt;ref_name
)paren
suffix:semicolon
id|errno
op_assign
id|save_errno
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hashcmp
c_func
(paren
id|lock-&gt;old_oid.hash
comma
id|old_sha1
)paren
)paren
(brace
id|strbuf_addf
c_func
(paren
id|err
comma
l_string|&quot;ref %s is at %s but expected %s&quot;
comma
id|lock-&gt;ref_name
comma
id|sha1_to_hex
c_func
(paren
id|lock-&gt;old_oid.hash
)paren
comma
id|sha1_to_hex
c_func
(paren
id|old_sha1
)paren
)paren
suffix:semicolon
id|errno
op_assign
id|EBUSY
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|remove_empty_directories
r_static
r_int
id|remove_empty_directories
c_func
(paren
r_struct
id|strbuf
op_star
id|path
)paren
(brace
multiline_comment|/*&n;&t; * we want to create a file but there is a directory there;&n;&t; * if that is an empty directory (or a directory that contains&n;&t; * only empty directories), remove them.&n;&t; */
r_return
id|remove_dir_recursively
c_func
(paren
id|path
comma
id|REMOVE_DIR_EMPTY_ONLY
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Locks a ref returning the lock on success and NULL on failure.&n; * On failure errno is set to something meaningful.&n; */
DECL|function|lock_ref_sha1_basic
r_static
r_struct
id|ref_lock
op_star
id|lock_ref_sha1_basic
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_const
r_int
r_char
op_star
id|old_sha1
comma
r_const
r_struct
id|string_list
op_star
id|extras
comma
r_const
r_struct
id|string_list
op_star
id|skip
comma
r_int
r_int
id|flags
comma
r_int
op_star
id|type_p
comma
r_struct
id|strbuf
op_star
id|err
)paren
(brace
r_struct
id|strbuf
id|ref_file
op_assign
id|STRBUF_INIT
suffix:semicolon
r_struct
id|strbuf
id|orig_ref_file
op_assign
id|STRBUF_INIT
suffix:semicolon
r_const
r_char
op_star
id|orig_refname
op_assign
id|refname
suffix:semicolon
r_struct
id|ref_lock
op_star
id|lock
suffix:semicolon
r_int
id|last_errno
op_assign
l_int|0
suffix:semicolon
r_int
id|type
comma
id|lflags
suffix:semicolon
r_int
id|mustexist
op_assign
(paren
id|old_sha1
op_logical_and
op_logical_neg
id|is_null_sha1
c_func
(paren
id|old_sha1
)paren
)paren
suffix:semicolon
r_int
id|resolve_flags
op_assign
l_int|0
suffix:semicolon
r_int
id|attempts_remaining
op_assign
l_int|3
suffix:semicolon
m_assert
(paren
id|err
)paren
suffix:semicolon
id|lock
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|ref_lock
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mustexist
)paren
id|resolve_flags
op_or_assign
id|RESOLVE_REF_READING
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|REF_DELETING
)paren
(brace
id|resolve_flags
op_or_assign
id|RESOLVE_REF_ALLOW_BAD_NAME
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|REF_NODEREF
)paren
id|resolve_flags
op_or_assign
id|RESOLVE_REF_NO_RECURSE
suffix:semicolon
)brace
id|refname
op_assign
id|resolve_ref_unsafe
c_func
(paren
id|refname
comma
id|resolve_flags
comma
id|lock-&gt;old_oid.hash
comma
op_amp
id|type
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|refname
op_logical_and
id|errno
op_eq
id|EISDIR
)paren
(brace
multiline_comment|/*&n;&t;&t; * we are trying to lock foo but we used to&n;&t;&t; * have foo/bar which now does not exist;&n;&t;&t; * it is normal for the empty directory &squot;foo&squot;&n;&t;&t; * to remain.&n;&t;&t; */
id|strbuf_git_path
c_func
(paren
op_amp
id|orig_ref_file
comma
l_string|&quot;%s&quot;
comma
id|orig_refname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|remove_empty_directories
c_func
(paren
op_amp
id|orig_ref_file
)paren
)paren
(brace
id|last_errno
op_assign
id|errno
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|verify_refname_available_dir
c_func
(paren
id|orig_refname
comma
id|extras
comma
id|skip
comma
id|get_loose_refs
c_func
(paren
op_amp
id|ref_cache
)paren
comma
id|err
)paren
)paren
id|strbuf_addf
c_func
(paren
id|err
comma
l_string|&quot;there are still refs under &squot;%s&squot;&quot;
comma
id|orig_refname
)paren
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
id|refname
op_assign
id|resolve_ref_unsafe
c_func
(paren
id|orig_refname
comma
id|resolve_flags
comma
id|lock-&gt;old_oid.hash
comma
op_amp
id|type
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|type_p
)paren
op_star
id|type_p
op_assign
id|type
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|refname
)paren
(brace
id|last_errno
op_assign
id|errno
suffix:semicolon
r_if
c_cond
(paren
id|last_errno
op_ne
id|ENOTDIR
op_logical_or
op_logical_neg
id|verify_refname_available_dir
c_func
(paren
id|orig_refname
comma
id|extras
comma
id|skip
comma
id|get_loose_refs
c_func
(paren
op_amp
id|ref_cache
)paren
comma
id|err
)paren
)paren
id|strbuf_addf
c_func
(paren
id|err
comma
l_string|&quot;unable to resolve reference %s: %s&quot;
comma
id|orig_refname
comma
id|strerror
c_func
(paren
id|last_errno
)paren
)paren
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the ref did not exist and we are creating it, make sure&n;&t; * there is no existing packed ref whose name begins with our&n;&t; * refname, nor a packed ref whose name is a proper prefix of&n;&t; * our refname.&n;&t; */
r_if
c_cond
(paren
id|is_null_oid
c_func
(paren
op_amp
id|lock-&gt;old_oid
)paren
op_logical_and
id|verify_refname_available_dir
c_func
(paren
id|refname
comma
id|extras
comma
id|skip
comma
id|get_packed_refs
c_func
(paren
op_amp
id|ref_cache
)paren
comma
id|err
)paren
)paren
(brace
id|last_errno
op_assign
id|ENOTDIR
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
id|lock-&gt;lk
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|lock_file
)paren
)paren
suffix:semicolon
id|lflags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|REF_NODEREF
)paren
(brace
id|refname
op_assign
id|orig_refname
suffix:semicolon
id|lflags
op_or_assign
id|LOCK_NO_DEREF
suffix:semicolon
)brace
id|lock-&gt;ref_name
op_assign
id|xstrdup
c_func
(paren
id|refname
)paren
suffix:semicolon
id|lock-&gt;orig_ref_name
op_assign
id|xstrdup
c_func
(paren
id|orig_refname
)paren
suffix:semicolon
id|strbuf_git_path
c_func
(paren
op_amp
id|ref_file
comma
l_string|&quot;%s&quot;
comma
id|refname
)paren
suffix:semicolon
id|retry
suffix:colon
r_switch
c_cond
(paren
id|safe_create_leading_directories_const
c_func
(paren
id|ref_file.buf
)paren
)paren
(brace
r_case
id|SCLD_OK
suffix:colon
r_break
suffix:semicolon
multiline_comment|/* success */
r_case
id|SCLD_VANISHED
suffix:colon
r_if
c_cond
(paren
op_decrement
id|attempts_remaining
OG
l_int|0
)paren
r_goto
id|retry
suffix:semicolon
multiline_comment|/* fall through */
r_default
suffix:colon
id|last_errno
op_assign
id|errno
suffix:semicolon
id|strbuf_addf
c_func
(paren
id|err
comma
l_string|&quot;unable to create directory for %s&quot;
comma
id|ref_file.buf
)paren
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hold_lock_file_for_update
c_func
(paren
id|lock-&gt;lk
comma
id|ref_file.buf
comma
id|lflags
)paren
OL
l_int|0
)paren
(brace
id|last_errno
op_assign
id|errno
suffix:semicolon
r_if
c_cond
(paren
id|errno
op_eq
id|ENOENT
op_logical_and
op_decrement
id|attempts_remaining
OG
l_int|0
)paren
multiline_comment|/*&n;&t;&t;&t; * Maybe somebody just deleted one of the&n;&t;&t;&t; * directories leading to ref_file.  Try&n;&t;&t;&t; * again:&n;&t;&t;&t; */
r_goto
id|retry
suffix:semicolon
r_else
(brace
id|unable_to_lock_message
c_func
(paren
id|ref_file.buf
comma
id|errno
comma
id|err
)paren
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|old_sha1
op_logical_and
id|verify_lock
c_func
(paren
id|lock
comma
id|old_sha1
comma
id|mustexist
comma
id|err
)paren
)paren
(brace
id|last_errno
op_assign
id|errno
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
id|error_return
suffix:colon
id|unlock_ref
c_func
(paren
id|lock
)paren
suffix:semicolon
id|lock
op_assign
l_int|NULL
suffix:semicolon
id|out
suffix:colon
id|strbuf_release
c_func
(paren
op_amp
id|ref_file
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|orig_ref_file
)paren
suffix:semicolon
id|errno
op_assign
id|last_errno
suffix:semicolon
r_return
id|lock
suffix:semicolon
)brace
multiline_comment|/*&n; * Write an entry to the packed-refs file for the specified refname.&n; * If peeled is non-NULL, write it as the entry&squot;s peeled value.&n; */
DECL|function|write_packed_entry
r_static
r_void
id|write_packed_entry
c_func
(paren
id|FILE
op_star
id|fh
comma
r_char
op_star
id|refname
comma
r_int
r_char
op_star
id|sha1
comma
r_int
r_char
op_star
id|peeled
)paren
(brace
id|fprintf_or_die
c_func
(paren
id|fh
comma
l_string|&quot;%s %s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
comma
id|refname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|peeled
)paren
id|fprintf_or_die
c_func
(paren
id|fh
comma
l_string|&quot;^%s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|peeled
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * An each_ref_entry_fn that writes the entry to a packed-refs file.&n; */
DECL|function|write_packed_entry_fn
r_static
r_int
id|write_packed_entry_fn
c_func
(paren
r_struct
id|ref_entry
op_star
id|entry
comma
r_void
op_star
id|cb_data
)paren
(brace
r_enum
id|peel_status
id|peel_status
op_assign
id|peel_entry
c_func
(paren
id|entry
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|peel_status
op_ne
id|PEEL_PEELED
op_logical_and
id|peel_status
op_ne
id|PEEL_NON_TAG
)paren
id|error
c_func
(paren
l_string|&quot;internal error: %s is not a valid packed reference!&quot;
comma
id|entry-&gt;name
)paren
suffix:semicolon
id|write_packed_entry
c_func
(paren
id|cb_data
comma
id|entry-&gt;name
comma
id|entry-&gt;u.value.oid.hash
comma
id|peel_status
op_eq
id|PEEL_PEELED
ques
c_cond
id|entry-&gt;u.value.peeled.hash
suffix:colon
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Lock the packed-refs file for writing. Flags is passed to&n; * hold_lock_file_for_update(). Return 0 on success. On errors, set&n; * errno appropriately and return a nonzero value.&n; */
DECL|function|lock_packed_refs
r_static
r_int
id|lock_packed_refs
c_func
(paren
r_int
id|flags
)paren
(brace
r_static
r_int
id|timeout_configured
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|timeout_value
op_assign
l_int|1000
suffix:semicolon
r_struct
id|packed_ref_cache
op_star
id|packed_ref_cache
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|timeout_configured
)paren
(brace
id|git_config_get_int
c_func
(paren
l_string|&quot;core.packedrefstimeout&quot;
comma
op_amp
id|timeout_value
)paren
suffix:semicolon
id|timeout_configured
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hold_lock_file_for_update_timeout
c_func
(paren
op_amp
id|packlock
comma
id|git_path
c_func
(paren
l_string|&quot;packed-refs&quot;
)paren
comma
id|flags
comma
id|timeout_value
)paren
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Get the current packed-refs while holding the lock.  If the&n;&t; * packed-refs file has been modified since we last read it,&n;&t; * this will automatically invalidate the cache and re-read&n;&t; * the packed-refs file.&n;&t; */
id|packed_ref_cache
op_assign
id|get_packed_ref_cache
c_func
(paren
op_amp
id|ref_cache
)paren
suffix:semicolon
id|packed_ref_cache-&gt;lock
op_assign
op_amp
id|packlock
suffix:semicolon
multiline_comment|/* Increment the reference count to prevent it from being freed: */
id|acquire_packed_ref_cache
c_func
(paren
id|packed_ref_cache
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Write the current version of the packed refs cache from memory to&n; * disk. The packed-refs file must already be locked for writing (see&n; * lock_packed_refs()). Return zero on success. On errors, set errno&n; * and return a nonzero value&n; */
DECL|function|commit_packed_refs
r_static
r_int
id|commit_packed_refs
c_func
(paren
r_void
)paren
(brace
r_struct
id|packed_ref_cache
op_star
id|packed_ref_cache
op_assign
id|get_packed_ref_cache
c_func
(paren
op_amp
id|ref_cache
)paren
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_int
id|save_errno
op_assign
l_int|0
suffix:semicolon
id|FILE
op_star
id|out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|packed_ref_cache-&gt;lock
)paren
id|die
c_func
(paren
l_string|&quot;internal error: packed-refs not locked&quot;
)paren
suffix:semicolon
id|out
op_assign
id|fdopen_lock_file
c_func
(paren
id|packed_ref_cache-&gt;lock
comma
l_string|&quot;w&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|out
)paren
id|die_errno
c_func
(paren
l_string|&quot;unable to fdopen packed-refs descriptor&quot;
)paren
suffix:semicolon
id|fprintf_or_die
c_func
(paren
id|out
comma
l_string|&quot;%s&quot;
comma
id|PACKED_REFS_HEADER
)paren
suffix:semicolon
id|do_for_each_entry_in_dir
c_func
(paren
id|get_packed_ref_dir
c_func
(paren
id|packed_ref_cache
)paren
comma
l_int|0
comma
id|write_packed_entry_fn
comma
id|out
)paren
suffix:semicolon
r_if
c_cond
(paren
id|commit_lock_file
c_func
(paren
id|packed_ref_cache-&gt;lock
)paren
)paren
(brace
id|save_errno
op_assign
id|errno
suffix:semicolon
id|error
op_assign
l_int|1
suffix:semicolon
)brace
id|packed_ref_cache-&gt;lock
op_assign
l_int|NULL
suffix:semicolon
id|release_packed_ref_cache
c_func
(paren
id|packed_ref_cache
)paren
suffix:semicolon
id|errno
op_assign
id|save_errno
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Rollback the lockfile for the packed-refs file, and discard the&n; * in-memory packed reference cache.  (The packed-refs file will be&n; * read anew if it is needed again after this function is called.)&n; */
DECL|function|rollback_packed_refs
r_static
r_void
id|rollback_packed_refs
c_func
(paren
r_void
)paren
(brace
r_struct
id|packed_ref_cache
op_star
id|packed_ref_cache
op_assign
id|get_packed_ref_cache
c_func
(paren
op_amp
id|ref_cache
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|packed_ref_cache-&gt;lock
)paren
id|die
c_func
(paren
l_string|&quot;internal error: packed-refs not locked&quot;
)paren
suffix:semicolon
id|rollback_lock_file
c_func
(paren
id|packed_ref_cache-&gt;lock
)paren
suffix:semicolon
id|packed_ref_cache-&gt;lock
op_assign
l_int|NULL
suffix:semicolon
id|release_packed_ref_cache
c_func
(paren
id|packed_ref_cache
)paren
suffix:semicolon
id|clear_packed_ref_cache
c_func
(paren
op_amp
id|ref_cache
)paren
suffix:semicolon
)brace
DECL|struct|ref_to_prune
r_struct
id|ref_to_prune
(brace
DECL|member|next
r_struct
id|ref_to_prune
op_star
id|next
suffix:semicolon
DECL|member|sha1
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
DECL|member|name
r_char
id|name
(braket
id|FLEX_ARRAY
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|pack_refs_cb_data
r_struct
id|pack_refs_cb_data
(brace
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
DECL|member|packed_refs
r_struct
id|ref_dir
op_star
id|packed_refs
suffix:semicolon
DECL|member|ref_to_prune
r_struct
id|ref_to_prune
op_star
id|ref_to_prune
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * An each_ref_entry_fn that is run over loose references only.  If&n; * the loose reference can be packed, add an entry in the packed ref&n; * cache.  If the reference should be pruned, also add it to&n; * ref_to_prune in the pack_refs_cb_data.&n; */
DECL|function|pack_if_possible_fn
r_static
r_int
id|pack_if_possible_fn
c_func
(paren
r_struct
id|ref_entry
op_star
id|entry
comma
r_void
op_star
id|cb_data
)paren
(brace
r_struct
id|pack_refs_cb_data
op_star
id|cb
op_assign
id|cb_data
suffix:semicolon
r_enum
id|peel_status
id|peel_status
suffix:semicolon
r_struct
id|ref_entry
op_star
id|packed_entry
suffix:semicolon
r_int
id|is_tag_ref
op_assign
id|starts_with
c_func
(paren
id|entry-&gt;name
comma
l_string|&quot;refs/tags/&quot;
)paren
suffix:semicolon
multiline_comment|/* Do not pack per-worktree refs: */
r_if
c_cond
(paren
id|ref_type
c_func
(paren
id|entry-&gt;name
)paren
op_ne
id|REF_TYPE_NORMAL
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* ALWAYS pack tags */
r_if
c_cond
(paren
op_logical_neg
(paren
id|cb-&gt;flags
op_amp
id|PACK_REFS_ALL
)paren
op_logical_and
op_logical_neg
id|is_tag_ref
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Do not pack symbolic or broken refs: */
r_if
c_cond
(paren
(paren
id|entry-&gt;flag
op_amp
id|REF_ISSYMREF
)paren
op_logical_or
op_logical_neg
id|ref_resolves_to_object
c_func
(paren
id|entry
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Add a packed ref cache entry equivalent to the loose entry. */
id|peel_status
op_assign
id|peel_entry
c_func
(paren
id|entry
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|peel_status
op_ne
id|PEEL_PEELED
op_logical_and
id|peel_status
op_ne
id|PEEL_NON_TAG
)paren
id|die
c_func
(paren
l_string|&quot;internal error peeling reference %s (%s)&quot;
comma
id|entry-&gt;name
comma
id|oid_to_hex
c_func
(paren
op_amp
id|entry-&gt;u.value.oid
)paren
)paren
suffix:semicolon
id|packed_entry
op_assign
id|find_ref
c_func
(paren
id|cb-&gt;packed_refs
comma
id|entry-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|packed_entry
)paren
(brace
multiline_comment|/* Overwrite existing packed entry with info from loose entry */
id|packed_entry-&gt;flag
op_assign
id|REF_ISPACKED
op_or
id|REF_KNOWS_PEELED
suffix:semicolon
id|oidcpy
c_func
(paren
op_amp
id|packed_entry-&gt;u.value.oid
comma
op_amp
id|entry-&gt;u.value.oid
)paren
suffix:semicolon
)brace
r_else
(brace
id|packed_entry
op_assign
id|create_ref_entry
c_func
(paren
id|entry-&gt;name
comma
id|entry-&gt;u.value.oid.hash
comma
id|REF_ISPACKED
op_or
id|REF_KNOWS_PEELED
comma
l_int|0
)paren
suffix:semicolon
id|add_ref
c_func
(paren
id|cb-&gt;packed_refs
comma
id|packed_entry
)paren
suffix:semicolon
)brace
id|oidcpy
c_func
(paren
op_amp
id|packed_entry-&gt;u.value.peeled
comma
op_amp
id|entry-&gt;u.value.peeled
)paren
suffix:semicolon
multiline_comment|/* Schedule the loose reference for pruning if requested. */
r_if
c_cond
(paren
(paren
id|cb-&gt;flags
op_amp
id|PACK_REFS_PRUNE
)paren
)paren
(brace
r_int
id|namelen
op_assign
id|strlen
c_func
(paren
id|entry-&gt;name
)paren
op_plus
l_int|1
suffix:semicolon
r_struct
id|ref_to_prune
op_star
id|n
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|n
)paren
op_plus
id|namelen
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|n-&gt;sha1
comma
id|entry-&gt;u.value.oid.hash
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|n-&gt;name
comma
id|entry-&gt;name
comma
id|namelen
)paren
suffix:semicolon
multiline_comment|/* includes NUL */
id|n-&gt;next
op_assign
id|cb-&gt;ref_to_prune
suffix:semicolon
id|cb-&gt;ref_to_prune
op_assign
id|n
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove empty parents, but spare refs/ and immediate subdirs.&n; * Note: munges *name.&n; */
DECL|function|try_remove_empty_parents
r_static
r_void
id|try_remove_empty_parents
c_func
(paren
r_char
op_star
id|name
)paren
(brace
r_char
op_star
id|p
comma
op_star
id|q
suffix:semicolon
r_int
id|i
suffix:semicolon
id|p
op_assign
id|name
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* refs/{heads,tags,...}/ */
r_while
c_loop
(paren
op_star
id|p
op_logical_and
op_star
id|p
op_ne
l_char|&squot;/&squot;
)paren
id|p
op_increment
suffix:semicolon
multiline_comment|/* tolerate duplicate slashes; see check_refname_format() */
r_while
c_loop
(paren
op_star
id|p
op_eq
l_char|&squot;/&squot;
)paren
id|p
op_increment
suffix:semicolon
)brace
r_for
c_loop
(paren
id|q
op_assign
id|p
suffix:semicolon
op_star
id|q
suffix:semicolon
id|q
op_increment
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_while
c_loop
(paren
id|q
OG
id|p
op_logical_and
op_star
id|q
op_ne
l_char|&squot;/&squot;
)paren
id|q
op_decrement
suffix:semicolon
r_while
c_loop
(paren
id|q
OG
id|p
op_logical_and
op_star
(paren
id|q
op_minus
l_int|1
)paren
op_eq
l_char|&squot;/&squot;
)paren
id|q
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|q
op_eq
id|p
)paren
r_break
suffix:semicolon
op_star
id|q
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|rmdir
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;%s&quot;
comma
id|name
)paren
)paren
)paren
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* make sure nobody touched the ref, and unlink */
DECL|function|prune_ref
r_static
r_void
id|prune_ref
c_func
(paren
r_struct
id|ref_to_prune
op_star
id|r
)paren
(brace
r_struct
id|ref_transaction
op_star
id|transaction
suffix:semicolon
r_struct
id|strbuf
id|err
op_assign
id|STRBUF_INIT
suffix:semicolon
r_if
c_cond
(paren
id|check_refname_format
c_func
(paren
id|r-&gt;name
comma
l_int|0
)paren
)paren
r_return
suffix:semicolon
id|transaction
op_assign
id|ref_transaction_begin
c_func
(paren
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|transaction
op_logical_or
id|ref_transaction_delete
c_func
(paren
id|transaction
comma
id|r-&gt;name
comma
id|r-&gt;sha1
comma
id|REF_ISPRUNING
comma
l_int|NULL
comma
op_amp
id|err
)paren
op_logical_or
id|ref_transaction_commit
c_func
(paren
id|transaction
comma
op_amp
id|err
)paren
)paren
(brace
id|ref_transaction_free
c_func
(paren
id|transaction
)paren
suffix:semicolon
id|error
c_func
(paren
l_string|&quot;%s&quot;
comma
id|err.buf
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|err
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ref_transaction_free
c_func
(paren
id|transaction
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|err
)paren
suffix:semicolon
id|try_remove_empty_parents
c_func
(paren
id|r-&gt;name
)paren
suffix:semicolon
)brace
DECL|function|prune_refs
r_static
r_void
id|prune_refs
c_func
(paren
r_struct
id|ref_to_prune
op_star
id|r
)paren
(brace
r_while
c_loop
(paren
id|r
)paren
(brace
id|prune_ref
c_func
(paren
id|r
)paren
suffix:semicolon
id|r
op_assign
id|r-&gt;next
suffix:semicolon
)brace
)brace
DECL|function|pack_refs
r_int
id|pack_refs
c_func
(paren
r_int
r_int
id|flags
)paren
(brace
r_struct
id|pack_refs_cb_data
id|cbdata
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|cbdata
comma
l_int|0
comma
r_sizeof
(paren
id|cbdata
)paren
)paren
suffix:semicolon
id|cbdata.flags
op_assign
id|flags
suffix:semicolon
id|lock_packed_refs
c_func
(paren
id|LOCK_DIE_ON_ERROR
)paren
suffix:semicolon
id|cbdata.packed_refs
op_assign
id|get_packed_refs
c_func
(paren
op_amp
id|ref_cache
)paren
suffix:semicolon
id|do_for_each_entry_in_dir
c_func
(paren
id|get_loose_refs
c_func
(paren
op_amp
id|ref_cache
)paren
comma
l_int|0
comma
id|pack_if_possible_fn
comma
op_amp
id|cbdata
)paren
suffix:semicolon
r_if
c_cond
(paren
id|commit_packed_refs
c_func
(paren
)paren
)paren
id|die_errno
c_func
(paren
l_string|&quot;unable to overwrite old ref-pack file&quot;
)paren
suffix:semicolon
id|prune_refs
c_func
(paren
id|cbdata.ref_to_prune
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Rewrite the packed-refs file, omitting any refs listed in&n; * &squot;refnames&squot;. On error, leave packed-refs unchanged, write an error&n; * message to &squot;err&squot;, and return a nonzero value.&n; *&n; * The refs in &squot;refnames&squot; needn&squot;t be sorted. `err` must not be NULL.&n; */
DECL|function|repack_without_refs
r_static
r_int
id|repack_without_refs
c_func
(paren
r_struct
id|string_list
op_star
id|refnames
comma
r_struct
id|strbuf
op_star
id|err
)paren
(brace
r_struct
id|ref_dir
op_star
id|packed
suffix:semicolon
r_struct
id|string_list_item
op_star
id|refname
suffix:semicolon
r_int
id|ret
comma
id|needs_repacking
op_assign
l_int|0
comma
id|removed
op_assign
l_int|0
suffix:semicolon
m_assert
(paren
id|err
)paren
suffix:semicolon
multiline_comment|/* Look for a packed ref */
id|for_each_string_list_item
c_func
(paren
id|refname
comma
id|refnames
)paren
(brace
r_if
c_cond
(paren
id|get_packed_ref
c_func
(paren
id|refname-&gt;string
)paren
)paren
(brace
id|needs_repacking
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Avoid locking if we have nothing to do */
r_if
c_cond
(paren
op_logical_neg
id|needs_repacking
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* no refname exists in packed refs */
r_if
c_cond
(paren
id|lock_packed_refs
c_func
(paren
l_int|0
)paren
)paren
(brace
id|unable_to_lock_message
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;packed-refs&quot;
)paren
comma
id|errno
comma
id|err
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|packed
op_assign
id|get_packed_refs
c_func
(paren
op_amp
id|ref_cache
)paren
suffix:semicolon
multiline_comment|/* Remove refnames from the cache */
id|for_each_string_list_item
c_func
(paren
id|refname
comma
id|refnames
)paren
r_if
c_cond
(paren
id|remove_entry
c_func
(paren
id|packed
comma
id|refname-&gt;string
)paren
op_ne
l_int|1
)paren
id|removed
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|removed
)paren
(brace
multiline_comment|/*&n;&t;&t; * All packed entries disappeared while we were&n;&t;&t; * acquiring the lock.&n;&t;&t; */
id|rollback_packed_refs
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Write what remains */
id|ret
op_assign
id|commit_packed_refs
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
id|strbuf_addf
c_func
(paren
id|err
comma
l_string|&quot;unable to overwrite old ref-pack file: %s&quot;
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|delete_ref_loose
r_static
r_int
id|delete_ref_loose
c_func
(paren
r_struct
id|ref_lock
op_star
id|lock
comma
r_int
id|flag
comma
r_struct
id|strbuf
op_star
id|err
)paren
(brace
m_assert
(paren
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flag
op_amp
id|REF_ISPACKED
)paren
op_logical_or
id|flag
op_amp
id|REF_ISSYMREF
)paren
(brace
multiline_comment|/*&n;&t;&t; * loose.  The loose file name is the same as the&n;&t;&t; * lockfile name, minus &quot;.lock&quot;:&n;&t;&t; */
r_char
op_star
id|loose_filename
op_assign
id|get_locked_file_path
c_func
(paren
id|lock-&gt;lk
)paren
suffix:semicolon
r_int
id|res
op_assign
id|unlink_or_msg
c_func
(paren
id|loose_filename
comma
id|err
)paren
suffix:semicolon
id|free
c_func
(paren
id|loose_filename
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|delete_refs
r_int
id|delete_refs
c_func
(paren
r_struct
id|string_list
op_star
id|refnames
)paren
(brace
r_struct
id|strbuf
id|err
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|i
comma
id|result
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|refnames-&gt;nr
)paren
r_return
l_int|0
suffix:semicolon
id|result
op_assign
id|repack_without_refs
c_func
(paren
id|refnames
comma
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
(brace
multiline_comment|/*&n;&t;&t; * If we failed to rewrite the packed-refs file, then&n;&t;&t; * it is unsafe to try to remove loose refs, because&n;&t;&t; * doing so might expose an obsolete packed value for&n;&t;&t; * a reference that might even point at an object that&n;&t;&t; * has been garbage collected.&n;&t;&t; */
r_if
c_cond
(paren
id|refnames-&gt;nr
op_eq
l_int|1
)paren
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;could not delete reference %s: %s&quot;
)paren
comma
id|refnames-&gt;items
(braket
l_int|0
)braket
dot
id|string
comma
id|err.buf
)paren
suffix:semicolon
r_else
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;could not delete references: %s&quot;
)paren
comma
id|err.buf
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|refnames-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_char
op_star
id|refname
op_assign
id|refnames-&gt;items
(braket
id|i
)braket
dot
id|string
suffix:semicolon
r_if
c_cond
(paren
id|delete_ref
c_func
(paren
id|refname
comma
l_int|NULL
comma
l_int|0
)paren
)paren
id|result
op_or_assign
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;could not remove reference %s&quot;
)paren
comma
id|refname
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|strbuf_release
c_func
(paren
op_amp
id|err
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * People using contrib&squot;s git-new-workdir have .git/logs/refs -&gt;&n; * /some/other/path/.git/logs/refs, and that may live on another device.&n; *&n; * IOW, to avoid cross device rename errors, the temporary renamed log must&n; * live into logs/refs.&n; */
DECL|macro|TMP_RENAMED_LOG
mdefine_line|#define TMP_RENAMED_LOG  &quot;logs/refs/.tmp-renamed-log&quot;
DECL|function|rename_tmp_log
r_static
r_int
id|rename_tmp_log
c_func
(paren
r_const
r_char
op_star
id|newrefname
)paren
(brace
r_int
id|attempts_remaining
op_assign
l_int|4
suffix:semicolon
r_struct
id|strbuf
id|path
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|ret
op_assign
l_int|1
suffix:semicolon
id|retry
suffix:colon
id|strbuf_reset
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
id|strbuf_git_path
c_func
(paren
op_amp
id|path
comma
l_string|&quot;logs/%s&quot;
comma
id|newrefname
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|safe_create_leading_directories_const
c_func
(paren
id|path.buf
)paren
)paren
(brace
r_case
id|SCLD_OK
suffix:colon
r_break
suffix:semicolon
multiline_comment|/* success */
r_case
id|SCLD_VANISHED
suffix:colon
r_if
c_cond
(paren
op_decrement
id|attempts_remaining
OG
l_int|0
)paren
r_goto
id|retry
suffix:semicolon
multiline_comment|/* fall through */
r_default
suffix:colon
id|error
c_func
(paren
l_string|&quot;unable to create directory for %s&quot;
comma
id|newrefname
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rename
c_func
(paren
id|git_path
c_func
(paren
id|TMP_RENAMED_LOG
)paren
comma
id|path.buf
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|errno
op_eq
id|EISDIR
op_logical_or
id|errno
op_eq
id|ENOTDIR
)paren
op_logical_and
op_decrement
id|attempts_remaining
OG
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * rename(a, b) when b is an existing&n;&t;&t;&t; * directory ought to result in ISDIR, but&n;&t;&t;&t; * Solaris 5.8 gives ENOTDIR.  Sheesh.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|remove_empty_directories
c_func
(paren
op_amp
id|path
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Directory not empty: logs/%s&quot;
comma
id|newrefname
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_goto
id|retry
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|errno
op_eq
id|ENOENT
op_logical_and
op_decrement
id|attempts_remaining
OG
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Maybe another process just deleted one of&n;&t;&t;&t; * the directories in the path to newrefname.&n;&t;&t;&t; * Try again from the beginning.&n;&t;&t;&t; */
r_goto
id|retry
suffix:semicolon
)brace
r_else
(brace
id|error
c_func
(paren
l_string|&quot;unable to move logfile &quot;
id|TMP_RENAMED_LOG
l_string|&quot; to logs/%s: %s&quot;
comma
id|newrefname
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
id|ret
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
id|strbuf_release
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|verify_refname_available
r_int
id|verify_refname_available
c_func
(paren
r_const
r_char
op_star
id|newname
comma
r_struct
id|string_list
op_star
id|extras
comma
r_struct
id|string_list
op_star
id|skip
comma
r_struct
id|strbuf
op_star
id|err
)paren
(brace
r_struct
id|ref_dir
op_star
id|packed_refs
op_assign
id|get_packed_refs
c_func
(paren
op_amp
id|ref_cache
)paren
suffix:semicolon
r_struct
id|ref_dir
op_star
id|loose_refs
op_assign
id|get_loose_refs
c_func
(paren
op_amp
id|ref_cache
)paren
suffix:semicolon
r_if
c_cond
(paren
id|verify_refname_available_dir
c_func
(paren
id|newname
comma
id|extras
comma
id|skip
comma
id|packed_refs
comma
id|err
)paren
op_logical_or
id|verify_refname_available_dir
c_func
(paren
id|newname
comma
id|extras
comma
id|skip
comma
id|loose_refs
comma
id|err
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|rename_ref_available
r_static
r_int
id|rename_ref_available
c_func
(paren
r_const
r_char
op_star
id|oldname
comma
r_const
r_char
op_star
id|newname
)paren
(brace
r_struct
id|string_list
id|skip
op_assign
id|STRING_LIST_INIT_NODUP
suffix:semicolon
r_struct
id|strbuf
id|err
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|string_list_insert
c_func
(paren
op_amp
id|skip
comma
id|oldname
)paren
suffix:semicolon
id|ret
op_assign
op_logical_neg
id|verify_refname_available
c_func
(paren
id|newname
comma
l_int|NULL
comma
op_amp
id|skip
comma
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|error
c_func
(paren
l_string|&quot;%s&quot;
comma
id|err.buf
)paren
suffix:semicolon
id|string_list_clear
c_func
(paren
op_amp
id|skip
comma
l_int|0
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|err
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_int
id|write_ref_to_lockfile
c_func
(paren
r_struct
id|ref_lock
op_star
id|lock
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_struct
id|strbuf
op_star
id|err
)paren
suffix:semicolon
r_static
r_int
id|commit_ref_update
c_func
(paren
r_struct
id|ref_lock
op_star
id|lock
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_const
r_char
op_star
id|logmsg
comma
r_int
id|flags
comma
r_struct
id|strbuf
op_star
id|err
)paren
suffix:semicolon
DECL|function|rename_ref
r_int
id|rename_ref
c_func
(paren
r_const
r_char
op_star
id|oldrefname
comma
r_const
r_char
op_star
id|newrefname
comma
r_const
r_char
op_star
id|logmsg
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
comma
id|orig_sha1
(braket
l_int|20
)braket
suffix:semicolon
r_int
id|flag
op_assign
l_int|0
comma
id|logmoved
op_assign
l_int|0
suffix:semicolon
r_struct
id|ref_lock
op_star
id|lock
suffix:semicolon
r_struct
id|stat
id|loginfo
suffix:semicolon
r_int
id|log
op_assign
op_logical_neg
id|lstat
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|oldrefname
)paren
comma
op_amp
id|loginfo
)paren
suffix:semicolon
r_const
r_char
op_star
id|symref
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|strbuf
id|err
op_assign
id|STRBUF_INIT
suffix:semicolon
r_if
c_cond
(paren
id|log
op_logical_and
id|S_ISLNK
c_func
(paren
id|loginfo.st_mode
)paren
)paren
r_return
id|error
c_func
(paren
l_string|&quot;reflog for %s is a symlink&quot;
comma
id|oldrefname
)paren
suffix:semicolon
id|symref
op_assign
id|resolve_ref_unsafe
c_func
(paren
id|oldrefname
comma
id|RESOLVE_REF_READING
comma
id|orig_sha1
comma
op_amp
id|flag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flag
op_amp
id|REF_ISSYMREF
)paren
r_return
id|error
c_func
(paren
l_string|&quot;refname %s is a symbolic ref, renaming it is not supported&quot;
comma
id|oldrefname
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|symref
)paren
r_return
id|error
c_func
(paren
l_string|&quot;refname %s not found&quot;
comma
id|oldrefname
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rename_ref_available
c_func
(paren
id|oldrefname
comma
id|newrefname
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|log
op_logical_and
id|rename
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|oldrefname
)paren
comma
id|git_path
c_func
(paren
id|TMP_RENAMED_LOG
)paren
)paren
)paren
r_return
id|error
c_func
(paren
l_string|&quot;unable to move logfile logs/%s to &quot;
id|TMP_RENAMED_LOG
l_string|&quot;: %s&quot;
comma
id|oldrefname
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|delete_ref
c_func
(paren
id|oldrefname
comma
id|orig_sha1
comma
id|REF_NODEREF
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;unable to delete old %s&quot;
comma
id|oldrefname
)paren
suffix:semicolon
r_goto
id|rollback
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|read_ref_full
c_func
(paren
id|newrefname
comma
id|RESOLVE_REF_READING
comma
id|sha1
comma
l_int|NULL
)paren
op_logical_and
id|delete_ref
c_func
(paren
id|newrefname
comma
id|sha1
comma
id|REF_NODEREF
)paren
)paren
(brace
r_if
c_cond
(paren
id|errno
op_eq
id|EISDIR
)paren
(brace
r_struct
id|strbuf
id|path
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|result
suffix:semicolon
id|strbuf_git_path
c_func
(paren
op_amp
id|path
comma
l_string|&quot;%s&quot;
comma
id|newrefname
)paren
suffix:semicolon
id|result
op_assign
id|remove_empty_directories
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Directory not empty: %s&quot;
comma
id|newrefname
)paren
suffix:semicolon
r_goto
id|rollback
suffix:semicolon
)brace
)brace
r_else
(brace
id|error
c_func
(paren
l_string|&quot;unable to delete existing %s&quot;
comma
id|newrefname
)paren
suffix:semicolon
r_goto
id|rollback
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|log
op_logical_and
id|rename_tmp_log
c_func
(paren
id|newrefname
)paren
)paren
r_goto
id|rollback
suffix:semicolon
id|logmoved
op_assign
id|log
suffix:semicolon
id|lock
op_assign
id|lock_ref_sha1_basic
c_func
(paren
id|newrefname
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|NULL
comma
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lock
)paren
(brace
id|error
c_func
(paren
l_string|&quot;unable to rename &squot;%s&squot; to &squot;%s&squot;: %s&quot;
comma
id|oldrefname
comma
id|newrefname
comma
id|err.buf
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|err
)paren
suffix:semicolon
r_goto
id|rollback
suffix:semicolon
)brace
id|hashcpy
c_func
(paren
id|lock-&gt;old_oid.hash
comma
id|orig_sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write_ref_to_lockfile
c_func
(paren
id|lock
comma
id|orig_sha1
comma
op_amp
id|err
)paren
op_logical_or
id|commit_ref_update
c_func
(paren
id|lock
comma
id|orig_sha1
comma
id|logmsg
comma
l_int|0
comma
op_amp
id|err
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;unable to write current sha1 into %s: %s&quot;
comma
id|newrefname
comma
id|err.buf
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|err
)paren
suffix:semicolon
r_goto
id|rollback
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|rollback
suffix:colon
id|lock
op_assign
id|lock_ref_sha1_basic
c_func
(paren
id|oldrefname
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|NULL
comma
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lock
)paren
(brace
id|error
c_func
(paren
l_string|&quot;unable to lock %s for rollback: %s&quot;
comma
id|oldrefname
comma
id|err.buf
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|err
)paren
suffix:semicolon
r_goto
id|rollbacklog
suffix:semicolon
)brace
id|flag
op_assign
id|log_all_ref_updates
suffix:semicolon
id|log_all_ref_updates
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|write_ref_to_lockfile
c_func
(paren
id|lock
comma
id|orig_sha1
comma
op_amp
id|err
)paren
op_logical_or
id|commit_ref_update
c_func
(paren
id|lock
comma
id|orig_sha1
comma
l_int|NULL
comma
l_int|0
comma
op_amp
id|err
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;unable to write current sha1 into %s: %s&quot;
comma
id|oldrefname
comma
id|err.buf
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|err
)paren
suffix:semicolon
)brace
id|log_all_ref_updates
op_assign
id|flag
suffix:semicolon
id|rollbacklog
suffix:colon
r_if
c_cond
(paren
id|logmoved
op_logical_and
id|rename
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|newrefname
)paren
comma
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|oldrefname
)paren
)paren
)paren
id|error
c_func
(paren
l_string|&quot;unable to restore logfile %s from %s: %s&quot;
comma
id|oldrefname
comma
id|newrefname
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|logmoved
op_logical_and
id|log
op_logical_and
id|rename
c_func
(paren
id|git_path
c_func
(paren
id|TMP_RENAMED_LOG
)paren
comma
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|oldrefname
)paren
)paren
)paren
id|error
c_func
(paren
l_string|&quot;unable to restore logfile %s from &quot;
id|TMP_RENAMED_LOG
l_string|&quot;: %s&quot;
comma
id|oldrefname
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|close_ref
r_static
r_int
id|close_ref
c_func
(paren
r_struct
id|ref_lock
op_star
id|lock
)paren
(brace
r_if
c_cond
(paren
id|close_lock_file
c_func
(paren
id|lock-&gt;lk
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|commit_ref
r_static
r_int
id|commit_ref
c_func
(paren
r_struct
id|ref_lock
op_star
id|lock
)paren
(brace
r_if
c_cond
(paren
id|commit_lock_file
c_func
(paren
id|lock-&gt;lk
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Create a reflog for a ref.  If force_create = 0, the reflog will&n; * only be created for certain refs (those for which&n; * should_autocreate_reflog returns non-zero.  Otherwise, create it&n; * regardless of the ref name.  Fill in *err and return -1 on failure.&n; */
DECL|function|log_ref_setup
r_static
r_int
id|log_ref_setup
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_struct
id|strbuf
op_star
id|logfile
comma
r_struct
id|strbuf
op_star
id|err
comma
r_int
id|force_create
)paren
(brace
r_int
id|logfd
comma
id|oflags
op_assign
id|O_APPEND
op_or
id|O_WRONLY
suffix:semicolon
id|strbuf_git_path
c_func
(paren
id|logfile
comma
l_string|&quot;logs/%s&quot;
comma
id|refname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|force_create
op_logical_or
id|should_autocreate_reflog
c_func
(paren
id|refname
)paren
)paren
(brace
r_if
c_cond
(paren
id|safe_create_leading_directories
c_func
(paren
id|logfile-&gt;buf
)paren
OL
l_int|0
)paren
(brace
id|strbuf_addf
c_func
(paren
id|err
comma
l_string|&quot;unable to create directory for %s: &quot;
l_string|&quot;%s&quot;
comma
id|logfile-&gt;buf
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|oflags
op_or_assign
id|O_CREAT
suffix:semicolon
)brace
id|logfd
op_assign
id|open
c_func
(paren
id|logfile-&gt;buf
comma
id|oflags
comma
l_int|0666
)paren
suffix:semicolon
r_if
c_cond
(paren
id|logfd
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|oflags
op_amp
id|O_CREAT
)paren
op_logical_and
(paren
id|errno
op_eq
id|ENOENT
op_logical_or
id|errno
op_eq
id|EISDIR
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|errno
op_eq
id|EISDIR
)paren
(brace
r_if
c_cond
(paren
id|remove_empty_directories
c_func
(paren
id|logfile
)paren
)paren
(brace
id|strbuf_addf
c_func
(paren
id|err
comma
l_string|&quot;There are still logs under &quot;
l_string|&quot;&squot;%s&squot;&quot;
comma
id|logfile-&gt;buf
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|logfd
op_assign
id|open
c_func
(paren
id|logfile-&gt;buf
comma
id|oflags
comma
l_int|0666
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|logfd
OL
l_int|0
)paren
(brace
id|strbuf_addf
c_func
(paren
id|err
comma
l_string|&quot;unable to append to %s: %s&quot;
comma
id|logfile-&gt;buf
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
id|adjust_shared_perm
c_func
(paren
id|logfile-&gt;buf
)paren
suffix:semicolon
id|close
c_func
(paren
id|logfd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|safe_create_reflog
r_int
id|safe_create_reflog
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_int
id|force_create
comma
r_struct
id|strbuf
op_star
id|err
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
id|ret
op_assign
id|log_ref_setup
c_func
(paren
id|refname
comma
op_amp
id|sb
comma
id|err
comma
id|force_create
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|log_ref_write_fd
r_static
r_int
id|log_ref_write_fd
c_func
(paren
r_int
id|fd
comma
r_const
r_int
r_char
op_star
id|old_sha1
comma
r_const
r_int
r_char
op_star
id|new_sha1
comma
r_const
r_char
op_star
id|committer
comma
r_const
r_char
op_star
id|msg
)paren
(brace
r_int
id|msglen
comma
id|written
suffix:semicolon
r_int
id|maxlen
comma
id|len
suffix:semicolon
r_char
op_star
id|logrec
suffix:semicolon
id|msglen
op_assign
id|msg
ques
c_cond
id|strlen
c_func
(paren
id|msg
)paren
suffix:colon
l_int|0
suffix:semicolon
id|maxlen
op_assign
id|strlen
c_func
(paren
id|committer
)paren
op_plus
id|msglen
op_plus
l_int|100
suffix:semicolon
id|logrec
op_assign
id|xmalloc
c_func
(paren
id|maxlen
)paren
suffix:semicolon
id|len
op_assign
id|xsnprintf
c_func
(paren
id|logrec
comma
id|maxlen
comma
l_string|&quot;%s %s %s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|old_sha1
)paren
comma
id|sha1_to_hex
c_func
(paren
id|new_sha1
)paren
comma
id|committer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msglen
)paren
id|len
op_add_assign
id|copy_reflog_msg
c_func
(paren
id|logrec
op_plus
id|len
l_int|1
comma
id|msg
)paren
l_int|1
suffix:semicolon
id|written
op_assign
id|len
op_le
id|maxlen
ques
c_cond
id|write_in_full
c_func
(paren
id|fd
comma
id|logrec
comma
id|len
)paren
suffix:colon
l_int|1
suffix:semicolon
id|free
c_func
(paren
id|logrec
)paren
suffix:semicolon
r_if
c_cond
(paren
id|written
op_ne
id|len
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|log_ref_write_1
r_static
r_int
id|log_ref_write_1
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_const
r_int
r_char
op_star
id|old_sha1
comma
r_const
r_int
r_char
op_star
id|new_sha1
comma
r_const
r_char
op_star
id|msg
comma
r_struct
id|strbuf
op_star
id|logfile
comma
r_int
id|flags
comma
r_struct
id|strbuf
op_star
id|err
)paren
(brace
r_int
id|logfd
comma
id|result
comma
id|oflags
op_assign
id|O_APPEND
op_or
id|O_WRONLY
suffix:semicolon
r_if
c_cond
(paren
id|log_all_ref_updates
OL
l_int|0
)paren
id|log_all_ref_updates
op_assign
op_logical_neg
id|is_bare_repository
c_func
(paren
)paren
suffix:semicolon
id|result
op_assign
id|log_ref_setup
c_func
(paren
id|refname
comma
id|logfile
comma
id|err
comma
id|flags
op_amp
id|REF_FORCE_CREATE_REFLOG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
r_return
id|result
suffix:semicolon
id|logfd
op_assign
id|open
c_func
(paren
id|logfile-&gt;buf
comma
id|oflags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|logfd
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|result
op_assign
id|log_ref_write_fd
c_func
(paren
id|logfd
comma
id|old_sha1
comma
id|new_sha1
comma
id|git_committer_info
c_func
(paren
l_int|0
)paren
comma
id|msg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
(brace
id|strbuf_addf
c_func
(paren
id|err
comma
l_string|&quot;unable to append to %s: %s&quot;
comma
id|logfile-&gt;buf
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
id|close
c_func
(paren
id|logfd
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|close
c_func
(paren
id|logfd
)paren
)paren
(brace
id|strbuf_addf
c_func
(paren
id|err
comma
l_string|&quot;unable to append to %s: %s&quot;
comma
id|logfile-&gt;buf
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|log_ref_write
r_static
r_int
id|log_ref_write
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_const
r_int
r_char
op_star
id|old_sha1
comma
r_const
r_int
r_char
op_star
id|new_sha1
comma
r_const
r_char
op_star
id|msg
comma
r_int
id|flags
comma
r_struct
id|strbuf
op_star
id|err
)paren
(brace
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|ret
op_assign
id|log_ref_write_1
c_func
(paren
id|refname
comma
id|old_sha1
comma
id|new_sha1
comma
id|msg
comma
op_amp
id|sb
comma
id|flags
comma
id|err
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Write sha1 into the open lockfile, then close the lockfile. On&n; * errors, rollback the lockfile, fill in *err and&n; * return -1.&n; */
DECL|function|write_ref_to_lockfile
r_static
r_int
id|write_ref_to_lockfile
c_func
(paren
r_struct
id|ref_lock
op_star
id|lock
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_struct
id|strbuf
op_star
id|err
)paren
(brace
r_static
r_char
id|term
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
r_struct
id|object
op_star
id|o
suffix:semicolon
r_int
id|fd
suffix:semicolon
id|o
op_assign
id|parse_object
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|o
)paren
(brace
id|strbuf_addf
c_func
(paren
id|err
comma
l_string|&quot;Trying to write ref %s with nonexistent object %s&quot;
comma
id|lock-&gt;ref_name
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
id|unlock_ref
c_func
(paren
id|lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|o-&gt;type
op_ne
id|OBJ_COMMIT
op_logical_and
id|is_branch
c_func
(paren
id|lock-&gt;ref_name
)paren
)paren
(brace
id|strbuf_addf
c_func
(paren
id|err
comma
l_string|&quot;Trying to write non-commit object %s to branch %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
comma
id|lock-&gt;ref_name
)paren
suffix:semicolon
id|unlock_ref
c_func
(paren
id|lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|fd
op_assign
id|get_lock_file_fd
c_func
(paren
id|lock-&gt;lk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write_in_full
c_func
(paren
id|fd
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
comma
l_int|40
)paren
op_ne
l_int|40
op_logical_or
id|write_in_full
c_func
(paren
id|fd
comma
op_amp
id|term
comma
l_int|1
)paren
op_ne
l_int|1
op_logical_or
id|close_ref
c_func
(paren
id|lock
)paren
OL
l_int|0
)paren
(brace
id|strbuf_addf
c_func
(paren
id|err
comma
l_string|&quot;Couldn&squot;t write %s&quot;
comma
id|get_lock_file_path
c_func
(paren
id|lock-&gt;lk
)paren
)paren
suffix:semicolon
id|unlock_ref
c_func
(paren
id|lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Commit a change to a loose reference that has already been written&n; * to the loose reference lockfile. Also update the reflogs if&n; * necessary, using the specified lockmsg (which can be NULL).&n; */
DECL|function|commit_ref_update
r_static
r_int
id|commit_ref_update
c_func
(paren
r_struct
id|ref_lock
op_star
id|lock
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_const
r_char
op_star
id|logmsg
comma
r_int
id|flags
comma
r_struct
id|strbuf
op_star
id|err
)paren
(brace
id|clear_loose_ref_cache
c_func
(paren
op_amp
id|ref_cache
)paren
suffix:semicolon
r_if
c_cond
(paren
id|log_ref_write
c_func
(paren
id|lock-&gt;ref_name
comma
id|lock-&gt;old_oid.hash
comma
id|sha1
comma
id|logmsg
comma
id|flags
comma
id|err
)paren
OL
l_int|0
op_logical_or
(paren
id|strcmp
c_func
(paren
id|lock-&gt;ref_name
comma
id|lock-&gt;orig_ref_name
)paren
op_logical_and
id|log_ref_write
c_func
(paren
id|lock-&gt;orig_ref_name
comma
id|lock-&gt;old_oid.hash
comma
id|sha1
comma
id|logmsg
comma
id|flags
comma
id|err
)paren
OL
l_int|0
)paren
)paren
(brace
r_char
op_star
id|old_msg
op_assign
id|strbuf_detach
c_func
(paren
id|err
comma
l_int|NULL
)paren
suffix:semicolon
id|strbuf_addf
c_func
(paren
id|err
comma
l_string|&quot;Cannot update the ref &squot;%s&squot;: %s&quot;
comma
id|lock-&gt;ref_name
comma
id|old_msg
)paren
suffix:semicolon
id|free
c_func
(paren
id|old_msg
)paren
suffix:semicolon
id|unlock_ref
c_func
(paren
id|lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|lock-&gt;orig_ref_name
comma
l_string|&quot;HEAD&quot;
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Special hack: If a branch is updated directly and HEAD&n;&t;&t; * points to it (may happen on the remote side of a push&n;&t;&t; * for example) then logically the HEAD reflog should be&n;&t;&t; * updated too.&n;&t;&t; * A generic solution implies reverse symref information,&n;&t;&t; * but finding all symrefs pointing to the given branch&n;&t;&t; * would be rather costly for this rare event (the direct&n;&t;&t; * update of a branch) to be worth it.  So let&squot;s cheat and&n;&t;&t; * check with HEAD only which should cover 99% of all usage&n;&t;&t; * scenarios (even 100% of the default ones).&n;&t;&t; */
r_int
r_char
id|head_sha1
(braket
l_int|20
)braket
suffix:semicolon
r_int
id|head_flag
suffix:semicolon
r_const
r_char
op_star
id|head_ref
suffix:semicolon
id|head_ref
op_assign
id|resolve_ref_unsafe
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|RESOLVE_REF_READING
comma
id|head_sha1
comma
op_amp
id|head_flag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|head_ref
op_logical_and
(paren
id|head_flag
op_amp
id|REF_ISSYMREF
)paren
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|head_ref
comma
id|lock-&gt;ref_name
)paren
)paren
(brace
r_struct
id|strbuf
id|log_err
op_assign
id|STRBUF_INIT
suffix:semicolon
r_if
c_cond
(paren
id|log_ref_write
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|lock-&gt;old_oid.hash
comma
id|sha1
comma
id|logmsg
comma
l_int|0
comma
op_amp
id|log_err
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;%s&quot;
comma
id|log_err.buf
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|log_err
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|commit_ref
c_func
(paren
id|lock
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Couldn&squot;t set %s&quot;
comma
id|lock-&gt;ref_name
)paren
suffix:semicolon
id|unlock_ref
c_func
(paren
id|lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|unlock_ref
c_func
(paren
id|lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|create_symref
r_int
id|create_symref
c_func
(paren
r_const
r_char
op_star
id|ref_target
comma
r_const
r_char
op_star
id|refs_heads_master
comma
r_const
r_char
op_star
id|logmsg
)paren
(brace
r_char
op_star
id|lockpath
op_assign
l_int|NULL
suffix:semicolon
r_char
id|ref
(braket
l_int|1000
)braket
suffix:semicolon
r_int
id|fd
comma
id|len
comma
id|written
suffix:semicolon
r_char
op_star
id|git_HEAD
op_assign
id|git_pathdup
c_func
(paren
l_string|&quot;%s&quot;
comma
id|ref_target
)paren
suffix:semicolon
r_int
r_char
id|old_sha1
(braket
l_int|20
)braket
comma
id|new_sha1
(braket
l_int|20
)braket
suffix:semicolon
r_struct
id|strbuf
id|err
op_assign
id|STRBUF_INIT
suffix:semicolon
r_if
c_cond
(paren
id|logmsg
op_logical_and
id|read_ref
c_func
(paren
id|ref_target
comma
id|old_sha1
)paren
)paren
id|hashclr
c_func
(paren
id|old_sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|safe_create_leading_directories
c_func
(paren
id|git_HEAD
)paren
OL
l_int|0
)paren
r_return
id|error
c_func
(paren
l_string|&quot;unable to create directory for %s&quot;
comma
id|git_HEAD
)paren
suffix:semicolon
macro_line|#ifndef NO_SYMLINK_HEAD
r_if
c_cond
(paren
id|prefer_symlink_refs
)paren
(brace
id|unlink
c_func
(paren
id|git_HEAD
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|symlink
c_func
(paren
id|refs_heads_master
comma
id|git_HEAD
)paren
)paren
r_goto
id|done
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;no symlink - falling back to symbolic ref&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|len
op_assign
id|snprintf
c_func
(paren
id|ref
comma
r_sizeof
(paren
id|ref
)paren
comma
l_string|&quot;ref: %s&bslash;n&quot;
comma
id|refs_heads_master
)paren
suffix:semicolon
r_if
c_cond
(paren
r_sizeof
(paren
id|ref
)paren
op_le
id|len
)paren
(brace
id|error
c_func
(paren
l_string|&quot;refname too long: %s&quot;
comma
id|refs_heads_master
)paren
suffix:semicolon
r_goto
id|error_free_return
suffix:semicolon
)brace
id|lockpath
op_assign
id|mkpathdup
c_func
(paren
l_string|&quot;%s.lock&quot;
comma
id|git_HEAD
)paren
suffix:semicolon
id|fd
op_assign
id|open
c_func
(paren
id|lockpath
comma
id|O_CREAT
op_or
id|O_EXCL
op_or
id|O_WRONLY
comma
l_int|0666
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Unable to open %s for writing&quot;
comma
id|lockpath
)paren
suffix:semicolon
r_goto
id|error_free_return
suffix:semicolon
)brace
id|written
op_assign
id|write_in_full
c_func
(paren
id|fd
comma
id|ref
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|close
c_func
(paren
id|fd
)paren
op_ne
l_int|0
op_logical_or
id|written
op_ne
id|len
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Unable to write to %s&quot;
comma
id|lockpath
)paren
suffix:semicolon
r_goto
id|error_unlink_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rename
c_func
(paren
id|lockpath
comma
id|git_HEAD
)paren
OL
l_int|0
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Unable to create %s&quot;
comma
id|git_HEAD
)paren
suffix:semicolon
r_goto
id|error_unlink_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|adjust_shared_perm
c_func
(paren
id|git_HEAD
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Unable to fix permissions on %s&quot;
comma
id|lockpath
)paren
suffix:semicolon
id|error_unlink_return
suffix:colon
id|unlink_or_warn
c_func
(paren
id|lockpath
)paren
suffix:semicolon
id|error_free_return
suffix:colon
id|free
c_func
(paren
id|lockpath
)paren
suffix:semicolon
id|free
c_func
(paren
id|git_HEAD
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|free
c_func
(paren
id|lockpath
)paren
suffix:semicolon
macro_line|#ifndef NO_SYMLINK_HEAD
id|done
suffix:colon
macro_line|#endif
r_if
c_cond
(paren
id|logmsg
op_logical_and
op_logical_neg
id|read_ref
c_func
(paren
id|refs_heads_master
comma
id|new_sha1
)paren
op_logical_and
id|log_ref_write
c_func
(paren
id|ref_target
comma
id|old_sha1
comma
id|new_sha1
comma
id|logmsg
comma
l_int|0
comma
op_amp
id|err
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;%s&quot;
comma
id|err.buf
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|err
)paren
suffix:semicolon
)brace
id|free
c_func
(paren
id|git_HEAD
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|reflog_exists
r_int
id|reflog_exists
c_func
(paren
r_const
r_char
op_star
id|refname
)paren
(brace
r_struct
id|stat
id|st
suffix:semicolon
r_return
op_logical_neg
id|lstat
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|refname
)paren
comma
op_amp
id|st
)paren
op_logical_and
id|S_ISREG
c_func
(paren
id|st.st_mode
)paren
suffix:semicolon
)brace
DECL|function|delete_reflog
r_int
id|delete_reflog
c_func
(paren
r_const
r_char
op_star
id|refname
)paren
(brace
r_return
id|remove_path
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|refname
)paren
)paren
suffix:semicolon
)brace
DECL|function|show_one_reflog_ent
r_static
r_int
id|show_one_reflog_ent
c_func
(paren
r_struct
id|strbuf
op_star
id|sb
comma
id|each_reflog_ent_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_int
r_char
id|osha1
(braket
l_int|20
)braket
comma
id|nsha1
(braket
l_int|20
)braket
suffix:semicolon
r_char
op_star
id|email_end
comma
op_star
id|message
suffix:semicolon
r_int
r_int
id|timestamp
suffix:semicolon
r_int
id|tz
suffix:semicolon
multiline_comment|/* old SP new SP name &lt;email&gt; SP time TAB msg LF */
r_if
c_cond
(paren
id|sb-&gt;len
OL
l_int|83
op_logical_or
id|sb-&gt;buf
(braket
id|sb-&gt;len
l_int|1
)braket
op_ne
l_char|&squot;&bslash;n&squot;
op_logical_or
id|get_sha1_hex
c_func
(paren
id|sb-&gt;buf
comma
id|osha1
)paren
op_logical_or
id|sb-&gt;buf
(braket
l_int|40
)braket
op_ne
l_char|&squot; &squot;
op_logical_or
id|get_sha1_hex
c_func
(paren
id|sb-&gt;buf
op_plus
l_int|41
comma
id|nsha1
)paren
op_logical_or
id|sb-&gt;buf
(braket
l_int|81
)braket
op_ne
l_char|&squot; &squot;
op_logical_or
op_logical_neg
(paren
id|email_end
op_assign
id|strchr
c_func
(paren
id|sb-&gt;buf
op_plus
l_int|82
comma
l_char|&squot;&gt;&squot;
)paren
)paren
op_logical_or
id|email_end
(braket
l_int|1
)braket
op_ne
l_char|&squot; &squot;
op_logical_or
op_logical_neg
(paren
id|timestamp
op_assign
id|strtoul
c_func
(paren
id|email_end
op_plus
l_int|2
comma
op_amp
id|message
comma
l_int|10
)paren
)paren
op_logical_or
op_logical_neg
id|message
op_logical_or
id|message
(braket
l_int|0
)braket
op_ne
l_char|&squot; &squot;
op_logical_or
(paren
id|message
(braket
l_int|1
)braket
op_ne
l_char|&squot;+&squot;
op_logical_and
id|message
(braket
l_int|1
)braket
op_ne
l_char|&squot;-&squot;
)paren
op_logical_or
op_logical_neg
id|isdigit
c_func
(paren
id|message
(braket
l_int|2
)braket
)paren
op_logical_or
op_logical_neg
id|isdigit
c_func
(paren
id|message
(braket
l_int|3
)braket
)paren
op_logical_or
op_logical_neg
id|isdigit
c_func
(paren
id|message
(braket
l_int|4
)braket
)paren
op_logical_or
op_logical_neg
id|isdigit
c_func
(paren
id|message
(braket
l_int|5
)braket
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* corrupt? */
id|email_end
(braket
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|tz
op_assign
id|strtol
c_func
(paren
id|message
op_plus
l_int|1
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|message
(braket
l_int|6
)braket
op_ne
l_char|&squot;&bslash;t&squot;
)paren
id|message
op_add_assign
l_int|6
suffix:semicolon
r_else
id|message
op_add_assign
l_int|7
suffix:semicolon
r_return
id|fn
c_func
(paren
id|osha1
comma
id|nsha1
comma
id|sb-&gt;buf
op_plus
l_int|82
comma
id|timestamp
comma
id|tz
comma
id|message
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|find_beginning_of_line
r_static
r_char
op_star
id|find_beginning_of_line
c_func
(paren
r_char
op_star
id|bob
comma
r_char
op_star
id|scan
)paren
(brace
r_while
c_loop
(paren
id|bob
OL
id|scan
op_logical_and
op_star
(paren
op_decrement
id|scan
)paren
op_ne
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
multiline_comment|/* keep scanning backwards */
multiline_comment|/*&n;&t; * Return either beginning of the buffer, or LF at the end of&n;&t; * the previous line.&n;&t; */
r_return
id|scan
suffix:semicolon
)brace
DECL|function|for_each_reflog_ent_reverse
r_int
id|for_each_reflog_ent_reverse
c_func
(paren
r_const
r_char
op_star
id|refname
comma
id|each_reflog_ent_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
id|FILE
op_star
id|logfp
suffix:semicolon
r_int
id|pos
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
comma
id|at_tail
op_assign
l_int|1
suffix:semicolon
id|logfp
op_assign
id|fopen
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|refname
)paren
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|logfp
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Jump to the end */
r_if
c_cond
(paren
id|fseek
c_func
(paren
id|logfp
comma
l_int|0
comma
id|SEEK_END
)paren
OL
l_int|0
)paren
r_return
id|error
c_func
(paren
l_string|&quot;cannot seek back reflog for %s: %s&quot;
comma
id|refname
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
id|pos
op_assign
id|ftell
c_func
(paren
id|logfp
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|ret
op_logical_and
l_int|0
OL
id|pos
)paren
(brace
r_int
id|cnt
suffix:semicolon
r_int
id|nread
suffix:semicolon
r_char
id|buf
(braket
id|BUFSIZ
)braket
suffix:semicolon
r_char
op_star
id|endp
comma
op_star
id|scanp
suffix:semicolon
multiline_comment|/* Fill next block from the end */
id|cnt
op_assign
(paren
r_sizeof
(paren
id|buf
)paren
OL
id|pos
)paren
ques
c_cond
r_sizeof
(paren
id|buf
)paren
suffix:colon
id|pos
suffix:semicolon
r_if
c_cond
(paren
id|fseek
c_func
(paren
id|logfp
comma
id|pos
id|cnt
comma
id|SEEK_SET
)paren
)paren
r_return
id|error
c_func
(paren
l_string|&quot;cannot seek back reflog for %s: %s&quot;
comma
id|refname
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
id|nread
op_assign
id|fread
c_func
(paren
id|buf
comma
id|cnt
comma
l_int|1
comma
id|logfp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nread
op_ne
l_int|1
)paren
r_return
id|error
c_func
(paren
l_string|&quot;cannot read %d bytes from reflog for %s: %s&quot;
comma
id|cnt
comma
id|refname
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
id|pos
op_sub_assign
id|cnt
suffix:semicolon
id|scanp
op_assign
id|endp
op_assign
id|buf
op_plus
id|cnt
suffix:semicolon
r_if
c_cond
(paren
id|at_tail
op_logical_and
id|scanp
(braket
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
multiline_comment|/* Looking at the final LF at the end of the file */
id|scanp
op_decrement
suffix:semicolon
id|at_tail
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|buf
OL
id|scanp
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * terminating LF of the previous line, or the beginning&n;&t;&t;&t; * of the buffer.&n;&t;&t;&t; */
r_char
op_star
id|bp
suffix:semicolon
id|bp
op_assign
id|find_beginning_of_line
c_func
(paren
id|buf
comma
id|scanp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|bp
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * The newline is the end of the previous line,&n;&t;&t;&t;&t; * so we know we have complete line starting&n;&t;&t;&t;&t; * at (bp + 1). Prefix it onto any prior data&n;&t;&t;&t;&t; * we collected for the line and process it.&n;&t;&t;&t;&t; */
id|strbuf_splice
c_func
(paren
op_amp
id|sb
comma
l_int|0
comma
l_int|0
comma
id|bp
op_plus
l_int|1
comma
id|endp
(paren
id|bp
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|scanp
op_assign
id|bp
suffix:semicolon
id|endp
op_assign
id|bp
op_plus
l_int|1
suffix:semicolon
id|ret
op_assign
id|show_one_reflog_ent
c_func
(paren
op_amp
id|sb
comma
id|fn
comma
id|cb_data
)paren
suffix:semicolon
id|strbuf_reset
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|pos
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * We are at the start of the buffer, and the&n;&t;&t;&t;&t; * start of the file; there is no previous&n;&t;&t;&t;&t; * line, and we have everything for this one.&n;&t;&t;&t;&t; * Process it, and we can end the loop.&n;&t;&t;&t;&t; */
id|strbuf_splice
c_func
(paren
op_amp
id|sb
comma
l_int|0
comma
l_int|0
comma
id|buf
comma
id|endp
id|buf
)paren
suffix:semicolon
id|ret
op_assign
id|show_one_reflog_ent
c_func
(paren
op_amp
id|sb
comma
id|fn
comma
id|cb_data
)paren
suffix:semicolon
id|strbuf_reset
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bp
op_eq
id|buf
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * We are at the start of the buffer, and there&n;&t;&t;&t;&t; * is more file to read backwards. Which means&n;&t;&t;&t;&t; * we are in the middle of a line. Note that we&n;&t;&t;&t;&t; * may get here even if *bp was a newline; that&n;&t;&t;&t;&t; * just means we are at the exact end of the&n;&t;&t;&t;&t; * previous line, rather than some spot in the&n;&t;&t;&t;&t; * middle.&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * Save away what we have to be combined with&n;&t;&t;&t;&t; * the data from the next read.&n;&t;&t;&t;&t; */
id|strbuf_splice
c_func
(paren
op_amp
id|sb
comma
l_int|0
comma
l_int|0
comma
id|buf
comma
id|endp
id|buf
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|ret
op_logical_and
id|sb.len
)paren
id|die
c_func
(paren
l_string|&quot;BUG: reverse reflog parser had leftover data&quot;
)paren
suffix:semicolon
id|fclose
c_func
(paren
id|logfp
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|for_each_reflog_ent
r_int
id|for_each_reflog_ent
c_func
(paren
r_const
r_char
op_star
id|refname
comma
id|each_reflog_ent_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
id|FILE
op_star
id|logfp
suffix:semicolon
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|logfp
op_assign
id|fopen
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|refname
)paren
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|logfp
)paren
r_return
l_int|1
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|ret
op_logical_and
op_logical_neg
id|strbuf_getwholeline
c_func
(paren
op_amp
id|sb
comma
id|logfp
comma
l_char|&squot;&bslash;n&squot;
)paren
)paren
id|ret
op_assign
id|show_one_reflog_ent
c_func
(paren
op_amp
id|sb
comma
id|fn
comma
id|cb_data
)paren
suffix:semicolon
id|fclose
c_func
(paren
id|logfp
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Call fn for each reflog in the namespace indicated by name.  name&n; * must be empty or end with &squot;/&squot;.  Name will be used as a scratch&n; * space, but its contents will be restored before return.&n; */
DECL|function|do_for_each_reflog
r_static
r_int
id|do_for_each_reflog
c_func
(paren
r_struct
id|strbuf
op_star
id|name
comma
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
id|DIR
op_star
id|d
op_assign
id|opendir
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|name-&gt;buf
)paren
)paren
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_struct
id|dirent
op_star
id|de
suffix:semicolon
r_int
id|oldlen
op_assign
id|name-&gt;len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|d
)paren
r_return
id|name-&gt;len
ques
c_cond
id|errno
suffix:colon
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|de
op_assign
id|readdir
c_func
(paren
id|d
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_struct
id|stat
id|st
suffix:semicolon
r_if
c_cond
(paren
id|de-&gt;d_name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|ends_with
c_func
(paren
id|de-&gt;d_name
comma
l_string|&quot;.lock&quot;
)paren
)paren
r_continue
suffix:semicolon
id|strbuf_addstr
c_func
(paren
id|name
comma
id|de-&gt;d_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|name-&gt;buf
)paren
comma
op_amp
id|st
)paren
OL
l_int|0
)paren
(brace
suffix:semicolon
multiline_comment|/* silently ignore */
)brace
r_else
(brace
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|st.st_mode
)paren
)paren
(brace
id|strbuf_addch
c_func
(paren
id|name
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
id|retval
op_assign
id|do_for_each_reflog
c_func
(paren
id|name
comma
id|fn
comma
id|cb_data
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|object_id
id|oid
suffix:semicolon
r_if
c_cond
(paren
id|read_ref_full
c_func
(paren
id|name-&gt;buf
comma
l_int|0
comma
id|oid.hash
comma
l_int|NULL
)paren
)paren
id|retval
op_assign
id|error
c_func
(paren
l_string|&quot;bad ref for %s&quot;
comma
id|name-&gt;buf
)paren
suffix:semicolon
r_else
id|retval
op_assign
id|fn
c_func
(paren
id|name-&gt;buf
comma
op_amp
id|oid
comma
l_int|0
comma
id|cb_data
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retval
)paren
r_break
suffix:semicolon
)brace
id|strbuf_setlen
c_func
(paren
id|name
comma
id|oldlen
)paren
suffix:semicolon
)brace
id|closedir
c_func
(paren
id|d
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|for_each_reflog
r_int
id|for_each_reflog
c_func
(paren
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_int
id|retval
suffix:semicolon
r_struct
id|strbuf
id|name
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|name
comma
id|PATH_MAX
)paren
suffix:semicolon
id|retval
op_assign
id|do_for_each_reflog
c_func
(paren
op_amp
id|name
comma
id|fn
comma
id|cb_data
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|name
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|ref_update_reject_duplicates
r_static
r_int
id|ref_update_reject_duplicates
c_func
(paren
r_struct
id|string_list
op_star
id|refnames
comma
r_struct
id|strbuf
op_star
id|err
)paren
(brace
r_int
id|i
comma
id|n
op_assign
id|refnames-&gt;nr
suffix:semicolon
m_assert
(paren
id|err
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|refnames-&gt;items
(braket
id|i
l_int|1
)braket
dot
id|string
comma
id|refnames-&gt;items
(braket
id|i
)braket
dot
id|string
)paren
)paren
(brace
id|strbuf_addf
c_func
(paren
id|err
comma
l_string|&quot;Multiple updates for ref &squot;%s&squot; not allowed.&quot;
comma
id|refnames-&gt;items
(braket
id|i
)braket
dot
id|string
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ref_transaction_commit
r_int
id|ref_transaction_commit
c_func
(paren
r_struct
id|ref_transaction
op_star
id|transaction
comma
r_struct
id|strbuf
op_star
id|err
)paren
(brace
r_int
id|ret
op_assign
l_int|0
comma
id|i
suffix:semicolon
r_int
id|n
op_assign
id|transaction-&gt;nr
suffix:semicolon
r_struct
id|ref_update
op_star
op_star
id|updates
op_assign
id|transaction-&gt;updates
suffix:semicolon
r_struct
id|string_list
id|refs_to_delete
op_assign
id|STRING_LIST_INIT_NODUP
suffix:semicolon
r_struct
id|string_list_item
op_star
id|ref_to_delete
suffix:semicolon
r_struct
id|string_list
id|affected_refnames
op_assign
id|STRING_LIST_INIT_NODUP
suffix:semicolon
m_assert
(paren
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|transaction-&gt;state
op_ne
id|REF_TRANSACTION_OPEN
)paren
id|die
c_func
(paren
l_string|&quot;BUG: commit called for transaction that is not open&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n
)paren
(brace
id|transaction-&gt;state
op_assign
id|REF_TRANSACTION_CLOSED
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Fail if a refname appears more than once in the transaction: */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
id|string_list_append
c_func
(paren
op_amp
id|affected_refnames
comma
id|updates
(braket
id|i
)braket
op_member_access_from_pointer
id|refname
)paren
suffix:semicolon
id|string_list_sort
c_func
(paren
op_amp
id|affected_refnames
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ref_update_reject_duplicates
c_func
(paren
op_amp
id|affected_refnames
comma
id|err
)paren
)paren
(brace
id|ret
op_assign
id|TRANSACTION_GENERIC_ERROR
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Acquire all locks, verify old values if provided, check&n;&t; * that new values are valid, and write new values to the&n;&t; * lockfiles, ready to be activated. Only keep one lockfile&n;&t; * open at a time to avoid running out of file descriptors.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|ref_update
op_star
id|update
op_assign
id|updates
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|update-&gt;flags
op_amp
id|REF_HAVE_NEW
)paren
op_logical_and
id|is_null_sha1
c_func
(paren
id|update-&gt;new_sha1
)paren
)paren
id|update-&gt;flags
op_or_assign
id|REF_DELETING
suffix:semicolon
id|update-&gt;lock
op_assign
id|lock_ref_sha1_basic
c_func
(paren
id|update-&gt;refname
comma
(paren
(paren
id|update-&gt;flags
op_amp
id|REF_HAVE_OLD
)paren
ques
c_cond
id|update-&gt;old_sha1
suffix:colon
l_int|NULL
)paren
comma
op_amp
id|affected_refnames
comma
l_int|NULL
comma
id|update-&gt;flags
comma
op_amp
id|update-&gt;type
comma
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|update-&gt;lock
)paren
(brace
r_char
op_star
id|reason
suffix:semicolon
id|ret
op_assign
(paren
id|errno
op_eq
id|ENOTDIR
)paren
ques
c_cond
id|TRANSACTION_NAME_CONFLICT
suffix:colon
id|TRANSACTION_GENERIC_ERROR
suffix:semicolon
id|reason
op_assign
id|strbuf_detach
c_func
(paren
id|err
comma
l_int|NULL
)paren
suffix:semicolon
id|strbuf_addf
c_func
(paren
id|err
comma
l_string|&quot;cannot lock ref &squot;%s&squot;: %s&quot;
comma
id|update-&gt;refname
comma
id|reason
)paren
suffix:semicolon
id|free
c_func
(paren
id|reason
)paren
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|update-&gt;flags
op_amp
id|REF_HAVE_NEW
)paren
op_logical_and
op_logical_neg
(paren
id|update-&gt;flags
op_amp
id|REF_DELETING
)paren
)paren
(brace
r_int
id|overwriting_symref
op_assign
(paren
(paren
id|update-&gt;type
op_amp
id|REF_ISSYMREF
)paren
op_logical_and
(paren
id|update-&gt;flags
op_amp
id|REF_NODEREF
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|overwriting_symref
op_logical_and
op_logical_neg
id|hashcmp
c_func
(paren
id|update-&gt;lock-&gt;old_oid.hash
comma
id|update-&gt;new_sha1
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * The reference already has the desired&n;&t;&t;&t;&t; * value, so we don&squot;t need to write it.&n;&t;&t;&t;&t; */
)brace
r_else
r_if
c_cond
(paren
id|write_ref_to_lockfile
c_func
(paren
id|update-&gt;lock
comma
id|update-&gt;new_sha1
comma
id|err
)paren
)paren
(brace
r_char
op_star
id|write_err
op_assign
id|strbuf_detach
c_func
(paren
id|err
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * The lock was freed upon failure of&n;&t;&t;&t;&t; * write_ref_to_lockfile():&n;&t;&t;&t;&t; */
id|update-&gt;lock
op_assign
l_int|NULL
suffix:semicolon
id|strbuf_addf
c_func
(paren
id|err
comma
l_string|&quot;cannot update the ref &squot;%s&squot;: %s&quot;
comma
id|update-&gt;refname
comma
id|write_err
)paren
suffix:semicolon
id|free
c_func
(paren
id|write_err
)paren
suffix:semicolon
id|ret
op_assign
id|TRANSACTION_GENERIC_ERROR
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
r_else
(brace
id|update-&gt;flags
op_or_assign
id|REF_NEEDS_COMMIT
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|update-&gt;flags
op_amp
id|REF_NEEDS_COMMIT
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * We didn&squot;t have to write anything to the lockfile.&n;&t;&t;&t; * Close it to free up the file descriptor:&n;&t;&t;&t; */
r_if
c_cond
(paren
id|close_ref
c_func
(paren
id|update-&gt;lock
)paren
)paren
(brace
id|strbuf_addf
c_func
(paren
id|err
comma
l_string|&quot;Couldn&squot;t close %s.lock&quot;
comma
id|update-&gt;refname
)paren
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Perform updates first so live commits remain referenced */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|ref_update
op_star
id|update
op_assign
id|updates
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|update-&gt;flags
op_amp
id|REF_NEEDS_COMMIT
)paren
(brace
r_if
c_cond
(paren
id|commit_ref_update
c_func
(paren
id|update-&gt;lock
comma
id|update-&gt;new_sha1
comma
id|update-&gt;msg
comma
id|update-&gt;flags
comma
id|err
)paren
)paren
(brace
multiline_comment|/* freed by commit_ref_update(): */
id|update-&gt;lock
op_assign
l_int|NULL
suffix:semicolon
id|ret
op_assign
id|TRANSACTION_GENERIC_ERROR
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* freed by commit_ref_update(): */
id|update-&gt;lock
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Perform deletes now that updates are safely completed */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|ref_update
op_star
id|update
op_assign
id|updates
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|update-&gt;flags
op_amp
id|REF_DELETING
)paren
(brace
r_if
c_cond
(paren
id|delete_ref_loose
c_func
(paren
id|update-&gt;lock
comma
id|update-&gt;type
comma
id|err
)paren
)paren
(brace
id|ret
op_assign
id|TRANSACTION_GENERIC_ERROR
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|update-&gt;flags
op_amp
id|REF_ISPRUNING
)paren
)paren
id|string_list_append
c_func
(paren
op_amp
id|refs_to_delete
comma
id|update-&gt;lock-&gt;ref_name
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|repack_without_refs
c_func
(paren
op_amp
id|refs_to_delete
comma
id|err
)paren
)paren
(brace
id|ret
op_assign
id|TRANSACTION_GENERIC_ERROR
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
id|for_each_string_list_item
c_func
(paren
id|ref_to_delete
comma
op_amp
id|refs_to_delete
)paren
id|unlink_or_warn
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|ref_to_delete-&gt;string
)paren
)paren
suffix:semicolon
id|clear_loose_ref_cache
c_func
(paren
op_amp
id|ref_cache
)paren
suffix:semicolon
id|cleanup
suffix:colon
id|transaction-&gt;state
op_assign
id|REF_TRANSACTION_CLOSED
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|updates
(braket
id|i
)braket
op_member_access_from_pointer
id|lock
)paren
id|unlock_ref
c_func
(paren
id|updates
(braket
id|i
)braket
op_member_access_from_pointer
id|lock
)paren
suffix:semicolon
id|string_list_clear
c_func
(paren
op_amp
id|refs_to_delete
comma
l_int|0
)paren
suffix:semicolon
id|string_list_clear
c_func
(paren
op_amp
id|affected_refnames
comma
l_int|0
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|ref_present
r_static
r_int
id|ref_present
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_const
r_struct
id|object_id
op_star
id|oid
comma
r_int
id|flags
comma
r_void
op_star
id|cb_data
)paren
(brace
r_struct
id|string_list
op_star
id|affected_refnames
op_assign
id|cb_data
suffix:semicolon
r_return
id|string_list_has_string
c_func
(paren
id|affected_refnames
comma
id|refname
)paren
suffix:semicolon
)brace
DECL|function|initial_ref_transaction_commit
r_int
id|initial_ref_transaction_commit
c_func
(paren
r_struct
id|ref_transaction
op_star
id|transaction
comma
r_struct
id|strbuf
op_star
id|err
)paren
(brace
r_int
id|ret
op_assign
l_int|0
comma
id|i
suffix:semicolon
r_int
id|n
op_assign
id|transaction-&gt;nr
suffix:semicolon
r_struct
id|ref_update
op_star
op_star
id|updates
op_assign
id|transaction-&gt;updates
suffix:semicolon
r_struct
id|string_list
id|affected_refnames
op_assign
id|STRING_LIST_INIT_NODUP
suffix:semicolon
m_assert
(paren
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|transaction-&gt;state
op_ne
id|REF_TRANSACTION_OPEN
)paren
id|die
c_func
(paren
l_string|&quot;BUG: commit called for transaction that is not open&quot;
)paren
suffix:semicolon
multiline_comment|/* Fail if a refname appears more than once in the transaction: */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
id|string_list_append
c_func
(paren
op_amp
id|affected_refnames
comma
id|updates
(braket
id|i
)braket
op_member_access_from_pointer
id|refname
)paren
suffix:semicolon
id|string_list_sort
c_func
(paren
op_amp
id|affected_refnames
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ref_update_reject_duplicates
c_func
(paren
op_amp
id|affected_refnames
comma
id|err
)paren
)paren
(brace
id|ret
op_assign
id|TRANSACTION_GENERIC_ERROR
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * It&squot;s really undefined to call this function in an active&n;&t; * repository or when there are existing references: we are&n;&t; * only locking and changing packed-refs, so (1) any&n;&t; * simultaneous processes might try to change a reference at&n;&t; * the same time we do, and (2) any existing loose versions of&n;&t; * the references that we are setting would have precedence&n;&t; * over our values. But some remote helpers create the remote&n;&t; * &quot;HEAD&quot; and &quot;master&quot; branches before calling this function,&n;&t; * so here we really only check that none of the references&n;&t; * that we are creating already exists.&n;&t; */
r_if
c_cond
(paren
id|for_each_rawref
c_func
(paren
id|ref_present
comma
op_amp
id|affected_refnames
)paren
)paren
id|die
c_func
(paren
l_string|&quot;BUG: initial ref transaction called with existing refs&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|ref_update
op_star
id|update
op_assign
id|updates
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|update-&gt;flags
op_amp
id|REF_HAVE_OLD
)paren
op_logical_and
op_logical_neg
id|is_null_sha1
c_func
(paren
id|update-&gt;old_sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;BUG: initial ref transaction with old_sha1 set&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|verify_refname_available
c_func
(paren
id|update-&gt;refname
comma
op_amp
id|affected_refnames
comma
l_int|NULL
comma
id|err
)paren
)paren
(brace
id|ret
op_assign
id|TRANSACTION_NAME_CONFLICT
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|lock_packed_refs
c_func
(paren
l_int|0
)paren
)paren
(brace
id|strbuf_addf
c_func
(paren
id|err
comma
l_string|&quot;unable to lock packed-refs file: %s&quot;
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|TRANSACTION_GENERIC_ERROR
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|ref_update
op_star
id|update
op_assign
id|updates
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|update-&gt;flags
op_amp
id|REF_HAVE_NEW
)paren
op_logical_and
op_logical_neg
id|is_null_sha1
c_func
(paren
id|update-&gt;new_sha1
)paren
)paren
id|add_packed_ref
c_func
(paren
id|update-&gt;refname
comma
id|update-&gt;new_sha1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|commit_packed_refs
c_func
(paren
)paren
)paren
(brace
id|strbuf_addf
c_func
(paren
id|err
comma
l_string|&quot;unable to commit packed-refs file: %s&quot;
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|TRANSACTION_GENERIC_ERROR
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
id|cleanup
suffix:colon
id|transaction-&gt;state
op_assign
id|REF_TRANSACTION_CLOSED
suffix:semicolon
id|string_list_clear
c_func
(paren
op_amp
id|affected_refnames
comma
l_int|0
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|struct|expire_reflog_cb
r_struct
id|expire_reflog_cb
(brace
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
DECL|member|should_prune_fn
id|reflog_expiry_should_prune_fn
op_star
id|should_prune_fn
suffix:semicolon
DECL|member|policy_cb
r_void
op_star
id|policy_cb
suffix:semicolon
DECL|member|newlog
id|FILE
op_star
id|newlog
suffix:semicolon
DECL|member|last_kept_sha1
r_int
r_char
id|last_kept_sha1
(braket
l_int|20
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|function|expire_reflog_ent
r_static
r_int
id|expire_reflog_ent
c_func
(paren
r_int
r_char
op_star
id|osha1
comma
r_int
r_char
op_star
id|nsha1
comma
r_const
r_char
op_star
id|email
comma
r_int
r_int
id|timestamp
comma
r_int
id|tz
comma
r_const
r_char
op_star
id|message
comma
r_void
op_star
id|cb_data
)paren
(brace
r_struct
id|expire_reflog_cb
op_star
id|cb
op_assign
id|cb_data
suffix:semicolon
r_struct
id|expire_reflog_policy_cb
op_star
id|policy_cb
op_assign
id|cb-&gt;policy_cb
suffix:semicolon
r_if
c_cond
(paren
id|cb-&gt;flags
op_amp
id|EXPIRE_REFLOGS_REWRITE
)paren
id|osha1
op_assign
id|cb-&gt;last_kept_sha1
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|cb-&gt;should_prune_fn
)paren
(paren
id|osha1
comma
id|nsha1
comma
id|email
comma
id|timestamp
comma
id|tz
comma
id|message
comma
id|policy_cb
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cb-&gt;newlog
)paren
id|printf
c_func
(paren
l_string|&quot;would prune %s&quot;
comma
id|message
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cb-&gt;flags
op_amp
id|EXPIRE_REFLOGS_VERBOSE
)paren
id|printf
c_func
(paren
l_string|&quot;prune %s&quot;
comma
id|message
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|cb-&gt;newlog
)paren
(brace
id|fprintf
c_func
(paren
id|cb-&gt;newlog
comma
l_string|&quot;%s %s %s %lu %+05d&bslash;t%s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|osha1
)paren
comma
id|sha1_to_hex
c_func
(paren
id|nsha1
)paren
comma
id|email
comma
id|timestamp
comma
id|tz
comma
id|message
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|cb-&gt;last_kept_sha1
comma
id|nsha1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cb-&gt;flags
op_amp
id|EXPIRE_REFLOGS_VERBOSE
)paren
id|printf
c_func
(paren
l_string|&quot;keep %s&quot;
comma
id|message
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|reflog_expire
r_int
id|reflog_expire
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
r_int
id|flags
comma
id|reflog_expiry_prepare_fn
id|prepare_fn
comma
id|reflog_expiry_should_prune_fn
id|should_prune_fn
comma
id|reflog_expiry_cleanup_fn
id|cleanup_fn
comma
r_void
op_star
id|policy_cb_data
)paren
(brace
r_static
r_struct
id|lock_file
id|reflog_lock
suffix:semicolon
r_struct
id|expire_reflog_cb
id|cb
suffix:semicolon
r_struct
id|ref_lock
op_star
id|lock
suffix:semicolon
r_char
op_star
id|log_file
suffix:semicolon
r_int
id|status
op_assign
l_int|0
suffix:semicolon
r_int
id|type
suffix:semicolon
r_struct
id|strbuf
id|err
op_assign
id|STRBUF_INIT
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|cb
comma
l_int|0
comma
r_sizeof
(paren
id|cb
)paren
)paren
suffix:semicolon
id|cb.flags
op_assign
id|flags
suffix:semicolon
id|cb.policy_cb
op_assign
id|policy_cb_data
suffix:semicolon
id|cb.should_prune_fn
op_assign
id|should_prune_fn
suffix:semicolon
multiline_comment|/*&n;&t; * The reflog file is locked by holding the lock on the&n;&t; * reference itself, plus we might need to update the&n;&t; * reference if --updateref was specified:&n;&t; */
id|lock
op_assign
id|lock_ref_sha1_basic
c_func
(paren
id|refname
comma
id|sha1
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
op_amp
id|type
comma
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lock
)paren
(brace
id|error
c_func
(paren
l_string|&quot;cannot lock ref &squot;%s&squot;: %s&quot;
comma
id|refname
comma
id|err.buf
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|err
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|reflog_exists
c_func
(paren
id|refname
)paren
)paren
(brace
id|unlock_ref
c_func
(paren
id|lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|log_file
op_assign
id|git_pathdup
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|refname
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|EXPIRE_REFLOGS_DRY_RUN
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Even though holding $GIT_DIR/logs/$reflog.lock has&n;&t;&t; * no locking implications, we use the lock_file&n;&t;&t; * machinery here anyway because it does a lot of the&n;&t;&t; * work we need, including cleaning up if the program&n;&t;&t; * exits unexpectedly.&n;&t;&t; */
r_if
c_cond
(paren
id|hold_lock_file_for_update
c_func
(paren
op_amp
id|reflog_lock
comma
id|log_file
comma
l_int|0
)paren
OL
l_int|0
)paren
(brace
r_struct
id|strbuf
id|err
op_assign
id|STRBUF_INIT
suffix:semicolon
id|unable_to_lock_message
c_func
(paren
id|log_file
comma
id|errno
comma
op_amp
id|err
)paren
suffix:semicolon
id|error
c_func
(paren
l_string|&quot;%s&quot;
comma
id|err.buf
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|err
)paren
suffix:semicolon
r_goto
id|failure
suffix:semicolon
)brace
id|cb.newlog
op_assign
id|fdopen_lock_file
c_func
(paren
op_amp
id|reflog_lock
comma
l_string|&quot;w&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cb.newlog
)paren
(brace
id|error
c_func
(paren
l_string|&quot;cannot fdopen %s (%s)&quot;
comma
id|get_lock_file_path
c_func
(paren
op_amp
id|reflog_lock
)paren
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_goto
id|failure
suffix:semicolon
)brace
)brace
(paren
op_star
id|prepare_fn
)paren
(paren
id|refname
comma
id|sha1
comma
id|cb.policy_cb
)paren
suffix:semicolon
id|for_each_reflog_ent
c_func
(paren
id|refname
comma
id|expire_reflog_ent
comma
op_amp
id|cb
)paren
suffix:semicolon
(paren
op_star
id|cleanup_fn
)paren
(paren
id|cb.policy_cb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|EXPIRE_REFLOGS_DRY_RUN
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * It doesn&squot;t make sense to adjust a reference pointed&n;&t;&t; * to by a symbolic ref based on expiring entries in&n;&t;&t; * the symbolic reference&squot;s reflog. Nor can we update&n;&t;&t; * a reference if there are no remaining reflog&n;&t;&t; * entries.&n;&t;&t; */
r_int
id|update
op_assign
(paren
id|flags
op_amp
id|EXPIRE_REFLOGS_UPDATE_REF
)paren
op_logical_and
op_logical_neg
(paren
id|type
op_amp
id|REF_ISSYMREF
)paren
op_logical_and
op_logical_neg
id|is_null_sha1
c_func
(paren
id|cb.last_kept_sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|close_lock_file
c_func
(paren
op_amp
id|reflog_lock
)paren
)paren
(brace
id|status
op_or_assign
id|error
c_func
(paren
l_string|&quot;couldn&squot;t write %s: %s&quot;
comma
id|log_file
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|update
op_logical_and
(paren
id|write_in_full
c_func
(paren
id|get_lock_file_fd
c_func
(paren
id|lock-&gt;lk
)paren
comma
id|sha1_to_hex
c_func
(paren
id|cb.last_kept_sha1
)paren
comma
l_int|40
)paren
op_ne
l_int|40
op_logical_or
id|write_str_in_full
c_func
(paren
id|get_lock_file_fd
c_func
(paren
id|lock-&gt;lk
)paren
comma
l_string|&quot;&bslash;n&quot;
)paren
op_ne
l_int|1
op_logical_or
id|close_ref
c_func
(paren
id|lock
)paren
OL
l_int|0
)paren
)paren
(brace
id|status
op_or_assign
id|error
c_func
(paren
l_string|&quot;couldn&squot;t write %s&quot;
comma
id|get_lock_file_path
c_func
(paren
id|lock-&gt;lk
)paren
)paren
suffix:semicolon
id|rollback_lock_file
c_func
(paren
op_amp
id|reflog_lock
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|commit_lock_file
c_func
(paren
op_amp
id|reflog_lock
)paren
)paren
(brace
id|status
op_or_assign
id|error
c_func
(paren
l_string|&quot;unable to commit reflog &squot;%s&squot; (%s)&quot;
comma
id|log_file
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|update
op_logical_and
id|commit_ref
c_func
(paren
id|lock
)paren
)paren
(brace
id|status
op_or_assign
id|error
c_func
(paren
l_string|&quot;couldn&squot;t set %s&quot;
comma
id|lock-&gt;ref_name
)paren
suffix:semicolon
)brace
)brace
id|free
c_func
(paren
id|log_file
)paren
suffix:semicolon
id|unlock_ref
c_func
(paren
id|lock
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
id|failure
suffix:colon
id|rollback_lock_file
c_func
(paren
op_amp
id|reflog_lock
)paren
suffix:semicolon
id|free
c_func
(paren
id|log_file
)paren
suffix:semicolon
id|unlock_ref
c_func
(paren
id|lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
eof
