multiline_comment|/*&n; * Pickaxe&n; *&n; * Copyright (c) 2006, Junio C Hamano&n; */
macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;builtin.h&quot;
macro_line|#include &quot;blob.h&quot;
macro_line|#include &quot;commit.h&quot;
macro_line|#include &quot;tag.h&quot;
macro_line|#include &quot;tree-walk.h&quot;
macro_line|#include &quot;diff.h&quot;
macro_line|#include &quot;diffcore.h&quot;
macro_line|#include &quot;revision.h&quot;
macro_line|#include &quot;quote.h&quot;
macro_line|#include &quot;xdiff-interface.h&quot;
macro_line|#include &quot;cache-tree.h&quot;
macro_line|#include &quot;string-list.h&quot;
macro_line|#include &quot;mailmap.h&quot;
macro_line|#include &quot;parse-options.h&quot;
DECL|variable|blame_usage
r_static
r_char
id|blame_usage
(braket
)braket
op_assign
l_string|&quot;git blame [options] [rev-opts] [rev] [--] file&quot;
suffix:semicolon
DECL|variable|blame_opt_usage
r_static
r_const
r_char
op_star
id|blame_opt_usage
(braket
)braket
op_assign
(brace
id|blame_usage
comma
l_string|&quot;&quot;
comma
l_string|&quot;[rev-opts] are documented in git-rev-list(1)&quot;
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|longest_file
r_static
r_int
id|longest_file
suffix:semicolon
DECL|variable|longest_author
r_static
r_int
id|longest_author
suffix:semicolon
DECL|variable|max_orig_digits
r_static
r_int
id|max_orig_digits
suffix:semicolon
DECL|variable|max_digits
r_static
r_int
id|max_digits
suffix:semicolon
DECL|variable|max_score_digits
r_static
r_int
id|max_score_digits
suffix:semicolon
DECL|variable|show_root
r_static
r_int
id|show_root
suffix:semicolon
DECL|variable|reverse
r_static
r_int
id|reverse
suffix:semicolon
DECL|variable|blank_boundary
r_static
r_int
id|blank_boundary
suffix:semicolon
DECL|variable|incremental
r_static
r_int
id|incremental
suffix:semicolon
DECL|variable|cmd_is_annotate
r_static
r_int
id|cmd_is_annotate
suffix:semicolon
DECL|variable|xdl_opts
r_static
r_int
id|xdl_opts
op_assign
id|XDF_NEED_MINIMAL
suffix:semicolon
DECL|variable|mailmap
r_static
r_struct
id|string_list
id|mailmap
suffix:semicolon
macro_line|#ifndef DEBUG
DECL|macro|DEBUG
mdefine_line|#define DEBUG 0
macro_line|#endif
multiline_comment|/* stats */
DECL|variable|num_read_blob
r_static
r_int
id|num_read_blob
suffix:semicolon
DECL|variable|num_get_patch
r_static
r_int
id|num_get_patch
suffix:semicolon
DECL|variable|num_commits
r_static
r_int
id|num_commits
suffix:semicolon
DECL|macro|PICKAXE_BLAME_MOVE
mdefine_line|#define PICKAXE_BLAME_MOVE&t;&t;01
DECL|macro|PICKAXE_BLAME_COPY
mdefine_line|#define PICKAXE_BLAME_COPY&t;&t;02
DECL|macro|PICKAXE_BLAME_COPY_HARDER
mdefine_line|#define PICKAXE_BLAME_COPY_HARDER&t;04
DECL|macro|PICKAXE_BLAME_COPY_HARDEST
mdefine_line|#define PICKAXE_BLAME_COPY_HARDEST&t;010
multiline_comment|/*&n; * blame for a blame_entry with score lower than these thresholds&n; * is not passed to the parent using move/copy logic.&n; */
DECL|variable|blame_move_score
r_static
r_int
id|blame_move_score
suffix:semicolon
DECL|variable|blame_copy_score
r_static
r_int
id|blame_copy_score
suffix:semicolon
DECL|macro|BLAME_DEFAULT_MOVE_SCORE
mdefine_line|#define BLAME_DEFAULT_MOVE_SCORE&t;20
DECL|macro|BLAME_DEFAULT_COPY_SCORE
mdefine_line|#define BLAME_DEFAULT_COPY_SCORE&t;40
multiline_comment|/* bits #0..7 in revision.h, #8..11 used for merge_bases() in commit.c */
DECL|macro|METAINFO_SHOWN
mdefine_line|#define METAINFO_SHOWN&t;&t;(1u&lt;&lt;12)
DECL|macro|MORE_THAN_ONE_PATH
mdefine_line|#define MORE_THAN_ONE_PATH&t;(1u&lt;&lt;13)
multiline_comment|/*&n; * One blob in a commit that is being suspected&n; */
DECL|struct|origin
r_struct
id|origin
(brace
DECL|member|refcnt
r_int
id|refcnt
suffix:semicolon
DECL|member|commit
r_struct
id|commit
op_star
id|commit
suffix:semicolon
DECL|member|file
id|mmfile_t
id|file
suffix:semicolon
DECL|member|blob_sha1
r_int
r_char
id|blob_sha1
(braket
l_int|20
)braket
suffix:semicolon
DECL|member|path
r_char
id|path
(braket
id|FLEX_ARRAY
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Given an origin, prepare mmfile_t structure to be used by the&n; * diff machinery&n; */
DECL|function|fill_origin_blob
r_static
r_void
id|fill_origin_blob
c_func
(paren
r_struct
id|origin
op_star
id|o
comma
id|mmfile_t
op_star
id|file
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|o-&gt;file.ptr
)paren
(brace
r_enum
id|object_type
id|type
suffix:semicolon
id|num_read_blob
op_increment
suffix:semicolon
id|file-&gt;ptr
op_assign
id|read_sha1_file
c_func
(paren
id|o-&gt;blob_sha1
comma
op_amp
id|type
comma
(paren
r_int
r_int
op_star
)paren
(paren
op_amp
(paren
id|file-&gt;size
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file-&gt;ptr
)paren
id|die
c_func
(paren
l_string|&quot;Cannot read blob %s for path %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|o-&gt;blob_sha1
)paren
comma
id|o-&gt;path
)paren
suffix:semicolon
id|o-&gt;file
op_assign
op_star
id|file
suffix:semicolon
)brace
r_else
op_star
id|file
op_assign
id|o-&gt;file
suffix:semicolon
)brace
multiline_comment|/*&n; * Origin is refcounted and usually we keep the blob contents to be&n; * reused.&n; */
DECL|function|origin_incref
r_static
r_inline
r_struct
id|origin
op_star
id|origin_incref
c_func
(paren
r_struct
id|origin
op_star
id|o
)paren
(brace
r_if
c_cond
(paren
id|o
)paren
id|o-&gt;refcnt
op_increment
suffix:semicolon
r_return
id|o
suffix:semicolon
)brace
DECL|function|origin_decref
r_static
r_void
id|origin_decref
c_func
(paren
r_struct
id|origin
op_star
id|o
)paren
(brace
r_if
c_cond
(paren
id|o
op_logical_and
op_decrement
id|o-&gt;refcnt
op_le
l_int|0
)paren
(brace
id|free
c_func
(paren
id|o-&gt;file.ptr
)paren
suffix:semicolon
id|free
c_func
(paren
id|o
)paren
suffix:semicolon
)brace
)brace
DECL|function|drop_origin_blob
r_static
r_void
id|drop_origin_blob
c_func
(paren
r_struct
id|origin
op_star
id|o
)paren
(brace
r_if
c_cond
(paren
id|o-&gt;file.ptr
)paren
(brace
id|free
c_func
(paren
id|o-&gt;file.ptr
)paren
suffix:semicolon
id|o-&gt;file.ptr
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Each group of lines is described by a blame_entry; it can be split&n; * as we pass blame to the parents.  They form a linked list in the&n; * scoreboard structure, sorted by the target line number.&n; */
DECL|struct|blame_entry
r_struct
id|blame_entry
(brace
DECL|member|prev
r_struct
id|blame_entry
op_star
id|prev
suffix:semicolon
DECL|member|next
r_struct
id|blame_entry
op_star
id|next
suffix:semicolon
multiline_comment|/* the first line of this group in the final image;&n;&t; * internally all line numbers are 0 based.&n;&t; */
DECL|member|lno
r_int
id|lno
suffix:semicolon
multiline_comment|/* how many lines this group has */
DECL|member|num_lines
r_int
id|num_lines
suffix:semicolon
multiline_comment|/* the commit that introduced this group into the final image */
DECL|member|suspect
r_struct
id|origin
op_star
id|suspect
suffix:semicolon
multiline_comment|/* true if the suspect is truly guilty; false while we have not&n;&t; * checked if the group came from one of its parents.&n;&t; */
DECL|member|guilty
r_char
id|guilty
suffix:semicolon
multiline_comment|/* true if the entry has been scanned for copies in the current parent&n;&t; */
DECL|member|scanned
r_char
id|scanned
suffix:semicolon
multiline_comment|/* the line number of the first line of this group in the&n;&t; * suspect&squot;s file; internally all line numbers are 0 based.&n;&t; */
DECL|member|s_lno
r_int
id|s_lno
suffix:semicolon
multiline_comment|/* how significant this entry is -- cached to avoid&n;&t; * scanning the lines over and over.&n;&t; */
DECL|member|score
r_int
id|score
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * The current state of the blame assignment.&n; */
DECL|struct|scoreboard
r_struct
id|scoreboard
(brace
multiline_comment|/* the final commit (i.e. where we started digging from) */
DECL|member|final
r_struct
id|commit
op_star
id|final
suffix:semicolon
DECL|member|revs
r_struct
id|rev_info
op_star
id|revs
suffix:semicolon
DECL|member|path
r_const
r_char
op_star
id|path
suffix:semicolon
multiline_comment|/*&n;&t; * The contents in the final image.&n;&t; * Used by many functions to obtain contents of the nth line,&n;&t; * indexed with scoreboard.lineno[blame_entry.lno].&n;&t; */
DECL|member|final_buf
r_const
r_char
op_star
id|final_buf
suffix:semicolon
DECL|member|final_buf_size
r_int
r_int
id|final_buf_size
suffix:semicolon
multiline_comment|/* linked list of blames */
DECL|member|ent
r_struct
id|blame_entry
op_star
id|ent
suffix:semicolon
multiline_comment|/* look-up a line in the final buffer */
DECL|member|num_lines
r_int
id|num_lines
suffix:semicolon
DECL|member|lineno
r_int
op_star
id|lineno
suffix:semicolon
)brace
suffix:semicolon
DECL|function|same_suspect
r_static
r_inline
r_int
id|same_suspect
c_func
(paren
r_struct
id|origin
op_star
id|a
comma
r_struct
id|origin
op_star
id|b
)paren
(brace
r_if
c_cond
(paren
id|a
op_eq
id|b
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;commit
op_ne
id|b-&gt;commit
)paren
r_return
l_int|0
suffix:semicolon
r_return
op_logical_neg
id|strcmp
c_func
(paren
id|a-&gt;path
comma
id|b-&gt;path
)paren
suffix:semicolon
)brace
r_static
r_void
id|sanity_check_refcnt
c_func
(paren
r_struct
id|scoreboard
op_star
)paren
suffix:semicolon
multiline_comment|/*&n; * If two blame entries that are next to each other came from&n; * contiguous lines in the same origin (i.e. &lt;commit, path&gt; pair),&n; * merge them together.&n; */
DECL|function|coalesce
r_static
r_void
id|coalesce
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
)paren
(brace
r_struct
id|blame_entry
op_star
id|ent
comma
op_star
id|next
suffix:semicolon
r_for
c_loop
(paren
id|ent
op_assign
id|sb-&gt;ent
suffix:semicolon
id|ent
op_logical_and
(paren
id|next
op_assign
id|ent-&gt;next
)paren
suffix:semicolon
id|ent
op_assign
id|next
)paren
(brace
r_if
c_cond
(paren
id|same_suspect
c_func
(paren
id|ent-&gt;suspect
comma
id|next-&gt;suspect
)paren
op_logical_and
id|ent-&gt;guilty
op_eq
id|next-&gt;guilty
op_logical_and
id|ent-&gt;s_lno
op_plus
id|ent-&gt;num_lines
op_eq
id|next-&gt;s_lno
)paren
(brace
id|ent-&gt;num_lines
op_add_assign
id|next-&gt;num_lines
suffix:semicolon
id|ent-&gt;next
op_assign
id|next-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|ent-&gt;next
)paren
id|ent-&gt;next-&gt;prev
op_assign
id|ent
suffix:semicolon
id|origin_decref
c_func
(paren
id|next-&gt;suspect
)paren
suffix:semicolon
id|free
c_func
(paren
id|next
)paren
suffix:semicolon
id|ent-&gt;score
op_assign
l_int|0
suffix:semicolon
id|next
op_assign
id|ent
suffix:semicolon
multiline_comment|/* again */
)brace
)brace
r_if
c_cond
(paren
id|DEBUG
)paren
multiline_comment|/* sanity */
id|sanity_check_refcnt
c_func
(paren
id|sb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Given a commit and a path in it, create a new origin structure.&n; * The callers that add blame to the scoreboard should use&n; * get_origin() to obtain shared, refcounted copy instead of calling&n; * this function directly.&n; */
DECL|function|make_origin
r_static
r_struct
id|origin
op_star
id|make_origin
c_func
(paren
r_struct
id|commit
op_star
id|commit
comma
r_const
r_char
op_star
id|path
)paren
(brace
r_struct
id|origin
op_star
id|o
suffix:semicolon
id|o
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|o
)paren
op_plus
id|strlen
c_func
(paren
id|path
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|o-&gt;commit
op_assign
id|commit
suffix:semicolon
id|o-&gt;refcnt
op_assign
l_int|1
suffix:semicolon
id|strcpy
c_func
(paren
id|o-&gt;path
comma
id|path
)paren
suffix:semicolon
r_return
id|o
suffix:semicolon
)brace
multiline_comment|/*&n; * Locate an existing origin or create a new one.&n; */
DECL|function|get_origin
r_static
r_struct
id|origin
op_star
id|get_origin
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_struct
id|commit
op_star
id|commit
comma
r_const
r_char
op_star
id|path
)paren
(brace
r_struct
id|blame_entry
op_star
id|e
suffix:semicolon
r_for
c_loop
(paren
id|e
op_assign
id|sb-&gt;ent
suffix:semicolon
id|e
suffix:semicolon
id|e
op_assign
id|e-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|e-&gt;suspect-&gt;commit
op_eq
id|commit
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|e-&gt;suspect-&gt;path
comma
id|path
)paren
)paren
r_return
id|origin_incref
c_func
(paren
id|e-&gt;suspect
)paren
suffix:semicolon
)brace
r_return
id|make_origin
c_func
(paren
id|commit
comma
id|path
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Fill the blob_sha1 field of an origin if it hasn&squot;t, so that later&n; * call to fill_origin_blob() can use it to locate the data.  blob_sha1&n; * for an origin is also used to pass the blame for the entire file to&n; * the parent to detect the case where a child&squot;s blob is identical to&n; * that of its parent&squot;s.&n; */
DECL|function|fill_blob_sha1
r_static
r_int
id|fill_blob_sha1
c_func
(paren
r_struct
id|origin
op_star
id|origin
)paren
(brace
r_int
id|mode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_null_sha1
c_func
(paren
id|origin-&gt;blob_sha1
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|get_tree_entry
c_func
(paren
id|origin-&gt;commit-&gt;object.sha1
comma
id|origin-&gt;path
comma
id|origin-&gt;blob_sha1
comma
op_amp
id|mode
)paren
)paren
r_goto
id|error_out
suffix:semicolon
r_if
c_cond
(paren
id|sha1_object_info
c_func
(paren
id|origin-&gt;blob_sha1
comma
l_int|NULL
)paren
op_ne
id|OBJ_BLOB
)paren
r_goto
id|error_out
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|error_out
suffix:colon
id|hashclr
c_func
(paren
id|origin-&gt;blob_sha1
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * We have an origin -- check if the same path exists in the&n; * parent and return an origin structure to represent it.&n; */
DECL|function|find_origin
r_static
r_struct
id|origin
op_star
id|find_origin
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_struct
id|commit
op_star
id|parent
comma
r_struct
id|origin
op_star
id|origin
)paren
(brace
r_struct
id|origin
op_star
id|porigin
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|diff_options
id|diff_opts
suffix:semicolon
r_const
r_char
op_star
id|paths
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
id|parent-&gt;util
)paren
(brace
multiline_comment|/*&n;&t;&t; * Each commit object can cache one origin in that&n;&t;&t; * commit.  This is a freestanding copy of origin and&n;&t;&t; * not refcounted.&n;&t;&t; */
r_struct
id|origin
op_star
id|cached
op_assign
id|parent-&gt;util
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|cached-&gt;path
comma
id|origin-&gt;path
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * The same path between origin and its parent&n;&t;&t;&t; * without renaming -- the most common case.&n;&t;&t;&t; */
id|porigin
op_assign
id|get_origin
c_func
(paren
id|sb
comma
id|parent
comma
id|cached-&gt;path
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If the origin was newly created (i.e. get_origin&n;&t;&t;&t; * would call make_origin if none is found in the&n;&t;&t;&t; * scoreboard), it does not know the blob_sha1,&n;&t;&t;&t; * so copy it.  Otherwise porigin was in the&n;&t;&t;&t; * scoreboard and already knows blob_sha1.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|porigin-&gt;refcnt
op_eq
l_int|1
)paren
id|hashcpy
c_func
(paren
id|porigin-&gt;blob_sha1
comma
id|cached-&gt;blob_sha1
)paren
suffix:semicolon
r_return
id|porigin
suffix:semicolon
)brace
multiline_comment|/* otherwise it was not very useful; free it */
id|free
c_func
(paren
id|parent-&gt;util
)paren
suffix:semicolon
id|parent-&gt;util
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* See if the origin-&gt;path is different between parent&n;&t; * and origin first.  Most of the time they are the&n;&t; * same and diff-tree is fairly efficient about this.&n;&t; */
id|diff_setup
c_func
(paren
op_amp
id|diff_opts
)paren
suffix:semicolon
id|DIFF_OPT_SET
c_func
(paren
op_amp
id|diff_opts
comma
id|RECURSIVE
)paren
suffix:semicolon
id|diff_opts.detect_rename
op_assign
l_int|0
suffix:semicolon
id|diff_opts.output_format
op_assign
id|DIFF_FORMAT_NO_OUTPUT
suffix:semicolon
id|paths
(braket
l_int|0
)braket
op_assign
id|origin-&gt;path
suffix:semicolon
id|paths
(braket
l_int|1
)braket
op_assign
l_int|NULL
suffix:semicolon
id|diff_tree_setup_paths
c_func
(paren
id|paths
comma
op_amp
id|diff_opts
)paren
suffix:semicolon
r_if
c_cond
(paren
id|diff_setup_done
c_func
(paren
op_amp
id|diff_opts
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;diff-setup&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_null_sha1
c_func
(paren
id|origin-&gt;commit-&gt;object.sha1
)paren
)paren
id|do_diff_cache
c_func
(paren
id|parent-&gt;tree-&gt;object.sha1
comma
op_amp
id|diff_opts
)paren
suffix:semicolon
r_else
id|diff_tree_sha1
c_func
(paren
id|parent-&gt;tree-&gt;object.sha1
comma
id|origin-&gt;commit-&gt;tree-&gt;object.sha1
comma
l_string|&quot;&quot;
comma
op_amp
id|diff_opts
)paren
suffix:semicolon
id|diffcore_std
c_func
(paren
op_amp
id|diff_opts
)paren
suffix:semicolon
multiline_comment|/* It is either one entry that says &quot;modified&quot;, or &quot;created&quot;,&n;&t; * or nothing.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|diff_queued_diff.nr
)paren
(brace
multiline_comment|/* The path is the same as parent */
id|porigin
op_assign
id|get_origin
c_func
(paren
id|sb
comma
id|parent
comma
id|origin-&gt;path
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|porigin-&gt;blob_sha1
comma
id|origin-&gt;blob_sha1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|diff_queued_diff.nr
op_ne
l_int|1
)paren
id|die
c_func
(paren
l_string|&quot;internal error in blame::find_origin&quot;
)paren
suffix:semicolon
r_else
(brace
r_struct
id|diff_filepair
op_star
id|p
op_assign
id|diff_queued_diff.queue
(braket
l_int|0
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|p-&gt;status
)paren
(brace
r_default
suffix:colon
id|die
c_func
(paren
l_string|&quot;internal error in blame::find_origin (%c)&quot;
comma
id|p-&gt;status
)paren
suffix:semicolon
r_case
l_char|&squot;M&squot;
suffix:colon
id|porigin
op_assign
id|get_origin
c_func
(paren
id|sb
comma
id|parent
comma
id|origin-&gt;path
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|porigin-&gt;blob_sha1
comma
id|p-&gt;one-&gt;sha1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;A&squot;
suffix:colon
r_case
l_char|&squot;T&squot;
suffix:colon
multiline_comment|/* Did not exist in parent, or type changed */
r_break
suffix:semicolon
)brace
)brace
id|diff_flush
c_func
(paren
op_amp
id|diff_opts
)paren
suffix:semicolon
id|diff_tree_release_paths
c_func
(paren
op_amp
id|diff_opts
)paren
suffix:semicolon
r_if
c_cond
(paren
id|porigin
)paren
(brace
multiline_comment|/*&n;&t;&t; * Create a freestanding copy that is not part of&n;&t;&t; * the refcounted origin found in the scoreboard, and&n;&t;&t; * cache it in the commit.&n;&t;&t; */
r_struct
id|origin
op_star
id|cached
suffix:semicolon
id|cached
op_assign
id|make_origin
c_func
(paren
id|porigin-&gt;commit
comma
id|porigin-&gt;path
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|cached-&gt;blob_sha1
comma
id|porigin-&gt;blob_sha1
)paren
suffix:semicolon
id|parent-&gt;util
op_assign
id|cached
suffix:semicolon
)brace
r_return
id|porigin
suffix:semicolon
)brace
multiline_comment|/*&n; * We have an origin -- find the path that corresponds to it in its&n; * parent and return an origin structure to represent it.&n; */
DECL|function|find_rename
r_static
r_struct
id|origin
op_star
id|find_rename
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_struct
id|commit
op_star
id|parent
comma
r_struct
id|origin
op_star
id|origin
)paren
(brace
r_struct
id|origin
op_star
id|porigin
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|diff_options
id|diff_opts
suffix:semicolon
r_int
id|i
suffix:semicolon
r_const
r_char
op_star
id|paths
(braket
l_int|2
)braket
suffix:semicolon
id|diff_setup
c_func
(paren
op_amp
id|diff_opts
)paren
suffix:semicolon
id|DIFF_OPT_SET
c_func
(paren
op_amp
id|diff_opts
comma
id|RECURSIVE
)paren
suffix:semicolon
id|diff_opts.detect_rename
op_assign
id|DIFF_DETECT_RENAME
suffix:semicolon
id|diff_opts.output_format
op_assign
id|DIFF_FORMAT_NO_OUTPUT
suffix:semicolon
id|diff_opts.single_follow
op_assign
id|origin-&gt;path
suffix:semicolon
id|paths
(braket
l_int|0
)braket
op_assign
l_int|NULL
suffix:semicolon
id|diff_tree_setup_paths
c_func
(paren
id|paths
comma
op_amp
id|diff_opts
)paren
suffix:semicolon
r_if
c_cond
(paren
id|diff_setup_done
c_func
(paren
op_amp
id|diff_opts
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;diff-setup&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_null_sha1
c_func
(paren
id|origin-&gt;commit-&gt;object.sha1
)paren
)paren
id|do_diff_cache
c_func
(paren
id|parent-&gt;tree-&gt;object.sha1
comma
op_amp
id|diff_opts
)paren
suffix:semicolon
r_else
id|diff_tree_sha1
c_func
(paren
id|parent-&gt;tree-&gt;object.sha1
comma
id|origin-&gt;commit-&gt;tree-&gt;object.sha1
comma
l_string|&quot;&quot;
comma
op_amp
id|diff_opts
)paren
suffix:semicolon
id|diffcore_std
c_func
(paren
op_amp
id|diff_opts
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|diff_queued_diff.nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|diff_filepair
op_star
id|p
op_assign
id|diff_queued_diff.queue
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;status
op_eq
l_char|&squot;R&squot;
op_logical_or
id|p-&gt;status
op_eq
l_char|&squot;C&squot;
)paren
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|p-&gt;two-&gt;path
comma
id|origin-&gt;path
)paren
)paren
(brace
id|porigin
op_assign
id|get_origin
c_func
(paren
id|sb
comma
id|parent
comma
id|p-&gt;one-&gt;path
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|porigin-&gt;blob_sha1
comma
id|p-&gt;one-&gt;sha1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|diff_flush
c_func
(paren
op_amp
id|diff_opts
)paren
suffix:semicolon
id|diff_tree_release_paths
c_func
(paren
op_amp
id|diff_opts
)paren
suffix:semicolon
r_return
id|porigin
suffix:semicolon
)brace
multiline_comment|/*&n; * Parsing of patch chunks...&n; */
DECL|struct|chunk
r_struct
id|chunk
(brace
multiline_comment|/* line number in postimage; up to but not including this&n;&t; * line is the same as preimage&n;&t; */
DECL|member|same
r_int
id|same
suffix:semicolon
multiline_comment|/* preimage line number after this chunk */
DECL|member|p_next
r_int
id|p_next
suffix:semicolon
multiline_comment|/* postimage line number after this chunk */
DECL|member|t_next
r_int
id|t_next
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|patch
r_struct
id|patch
(brace
DECL|member|chunks
r_struct
id|chunk
op_star
id|chunks
suffix:semicolon
DECL|member|num
r_int
id|num
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|blame_diff_state
r_struct
id|blame_diff_state
(brace
DECL|member|xm
r_struct
id|xdiff_emit_state
id|xm
suffix:semicolon
DECL|member|ret
r_struct
id|patch
op_star
id|ret
suffix:semicolon
DECL|member|hunk_post_context
r_int
id|hunk_post_context
suffix:semicolon
DECL|member|hunk_in_pre_context
r_int
id|hunk_in_pre_context
suffix:colon
l_int|1
suffix:semicolon
)brace
suffix:semicolon
DECL|function|process_u_diff
r_static
r_void
id|process_u_diff
c_func
(paren
r_void
op_star
id|state_
comma
r_char
op_star
id|line
comma
r_int
r_int
id|len
)paren
(brace
r_struct
id|blame_diff_state
op_star
id|state
op_assign
id|state_
suffix:semicolon
r_struct
id|chunk
op_star
id|chunk
suffix:semicolon
r_int
id|off1
comma
id|off2
comma
id|len1
comma
id|len2
comma
id|num
suffix:semicolon
id|num
op_assign
id|state-&gt;ret-&gt;num
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|4
op_logical_or
id|line
(braket
l_int|0
)braket
op_ne
l_char|&squot;@&squot;
op_logical_or
id|line
(braket
l_int|1
)braket
op_ne
l_char|&squot;@&squot;
)paren
(brace
r_if
c_cond
(paren
id|state-&gt;hunk_in_pre_context
op_logical_and
id|line
(braket
l_int|0
)braket
op_eq
l_char|&squot; &squot;
)paren
id|state-&gt;ret-&gt;chunks
(braket
id|num
l_int|1
)braket
dot
id|same
op_increment
suffix:semicolon
r_else
(brace
id|state-&gt;hunk_in_pre_context
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|line
(braket
l_int|0
)braket
op_eq
l_char|&squot; &squot;
)paren
id|state-&gt;hunk_post_context
op_increment
suffix:semicolon
r_else
id|state-&gt;hunk_post_context
op_assign
l_int|0
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|num
op_logical_and
id|state-&gt;hunk_post_context
)paren
(brace
id|chunk
op_assign
op_amp
id|state-&gt;ret-&gt;chunks
(braket
id|num
l_int|1
)braket
suffix:semicolon
id|chunk-&gt;p_next
op_sub_assign
id|state-&gt;hunk_post_context
suffix:semicolon
id|chunk-&gt;t_next
op_sub_assign
id|state-&gt;hunk_post_context
suffix:semicolon
)brace
id|state-&gt;ret-&gt;num
op_assign
op_increment
id|num
suffix:semicolon
id|state-&gt;ret-&gt;chunks
op_assign
id|xrealloc
c_func
(paren
id|state-&gt;ret-&gt;chunks
comma
r_sizeof
(paren
r_struct
id|chunk
)paren
op_star
id|num
)paren
suffix:semicolon
id|chunk
op_assign
op_amp
id|state-&gt;ret-&gt;chunks
(braket
id|num
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|parse_hunk_header
c_func
(paren
id|line
comma
id|len
comma
op_amp
id|off1
comma
op_amp
id|len1
comma
op_amp
id|off2
comma
op_amp
id|len2
)paren
)paren
(brace
id|state-&gt;ret-&gt;num
op_decrement
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Line numbers in patch output are one based. */
id|off1
op_decrement
suffix:semicolon
id|off2
op_decrement
suffix:semicolon
id|chunk-&gt;same
op_assign
id|len2
ques
c_cond
id|off2
suffix:colon
(paren
id|off2
op_plus
l_int|1
)paren
suffix:semicolon
id|chunk-&gt;p_next
op_assign
id|off1
op_plus
(paren
id|len1
ques
c_cond
id|len1
suffix:colon
l_int|1
)paren
suffix:semicolon
id|chunk-&gt;t_next
op_assign
id|chunk-&gt;same
op_plus
id|len2
suffix:semicolon
id|state-&gt;hunk_in_pre_context
op_assign
l_int|1
suffix:semicolon
id|state-&gt;hunk_post_context
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|compare_buffer
r_static
r_struct
id|patch
op_star
id|compare_buffer
c_func
(paren
id|mmfile_t
op_star
id|file_p
comma
id|mmfile_t
op_star
id|file_o
comma
r_int
id|context
)paren
(brace
r_struct
id|blame_diff_state
id|state
suffix:semicolon
id|xpparam_t
id|xpp
suffix:semicolon
id|xdemitconf_t
id|xecfg
suffix:semicolon
id|xdemitcb_t
id|ecb
suffix:semicolon
id|xpp.flags
op_assign
id|xdl_opts
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|xecfg
comma
l_int|0
comma
r_sizeof
(paren
id|xecfg
)paren
)paren
suffix:semicolon
id|xecfg.ctxlen
op_assign
id|context
suffix:semicolon
id|ecb.outf
op_assign
id|xdiff_outf
suffix:semicolon
id|ecb.priv
op_assign
op_amp
id|state
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|state
comma
l_int|0
comma
r_sizeof
(paren
id|state
)paren
)paren
suffix:semicolon
id|state.xm.consume
op_assign
id|process_u_diff
suffix:semicolon
id|state.ret
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|patch
)paren
)paren
suffix:semicolon
id|state.ret-&gt;chunks
op_assign
l_int|NULL
suffix:semicolon
id|state.ret-&gt;num
op_assign
l_int|0
suffix:semicolon
id|xdi_diff
c_func
(paren
id|file_p
comma
id|file_o
comma
op_amp
id|xpp
comma
op_amp
id|xecfg
comma
op_amp
id|ecb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state.ret-&gt;num
)paren
(brace
r_struct
id|chunk
op_star
id|chunk
suffix:semicolon
id|chunk
op_assign
op_amp
id|state.ret-&gt;chunks
(braket
id|state.ret-&gt;num
l_int|1
)braket
suffix:semicolon
id|chunk-&gt;p_next
op_sub_assign
id|state.hunk_post_context
suffix:semicolon
id|chunk-&gt;t_next
op_sub_assign
id|state.hunk_post_context
suffix:semicolon
)brace
r_return
id|state.ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Run diff between two origins and grab the patch output, so that&n; * we can pass blame for lines origin is currently suspected for&n; * to its parent.&n; */
DECL|function|get_patch
r_static
r_struct
id|patch
op_star
id|get_patch
c_func
(paren
r_struct
id|origin
op_star
id|parent
comma
r_struct
id|origin
op_star
id|origin
)paren
(brace
id|mmfile_t
id|file_p
comma
id|file_o
suffix:semicolon
r_struct
id|patch
op_star
id|patch
suffix:semicolon
id|fill_origin_blob
c_func
(paren
id|parent
comma
op_amp
id|file_p
)paren
suffix:semicolon
id|fill_origin_blob
c_func
(paren
id|origin
comma
op_amp
id|file_o
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file_p.ptr
op_logical_or
op_logical_neg
id|file_o.ptr
)paren
r_return
l_int|NULL
suffix:semicolon
id|patch
op_assign
id|compare_buffer
c_func
(paren
op_amp
id|file_p
comma
op_amp
id|file_o
comma
l_int|0
)paren
suffix:semicolon
id|num_get_patch
op_increment
suffix:semicolon
r_return
id|patch
suffix:semicolon
)brace
DECL|function|free_patch
r_static
r_void
id|free_patch
c_func
(paren
r_struct
id|patch
op_star
id|p
)paren
(brace
id|free
c_func
(paren
id|p-&gt;chunks
)paren
suffix:semicolon
id|free
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Link in a new blame entry to the scoreboard.  Entries that cover the&n; * same line range have been removed from the scoreboard previously.&n; */
DECL|function|add_blame_entry
r_static
r_void
id|add_blame_entry
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_struct
id|blame_entry
op_star
id|e
)paren
(brace
r_struct
id|blame_entry
op_star
id|ent
comma
op_star
id|prev
op_assign
l_int|NULL
suffix:semicolon
id|origin_incref
c_func
(paren
id|e-&gt;suspect
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ent
op_assign
id|sb-&gt;ent
suffix:semicolon
id|ent
op_logical_and
id|ent-&gt;lno
OL
id|e-&gt;lno
suffix:semicolon
id|ent
op_assign
id|ent-&gt;next
)paren
id|prev
op_assign
id|ent
suffix:semicolon
multiline_comment|/* prev, if not NULL, is the last one that is below e */
id|e-&gt;prev
op_assign
id|prev
suffix:semicolon
r_if
c_cond
(paren
id|prev
)paren
(brace
id|e-&gt;next
op_assign
id|prev-&gt;next
suffix:semicolon
id|prev-&gt;next
op_assign
id|e
suffix:semicolon
)brace
r_else
(brace
id|e-&gt;next
op_assign
id|sb-&gt;ent
suffix:semicolon
id|sb-&gt;ent
op_assign
id|e
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e-&gt;next
)paren
id|e-&gt;next-&gt;prev
op_assign
id|e
suffix:semicolon
)brace
multiline_comment|/*&n; * src typically is on-stack; we want to copy the information in it to&n; * a malloced blame_entry that is already on the linked list of the&n; * scoreboard.  The origin of dst loses a refcnt while the origin of src&n; * gains one.&n; */
DECL|function|dup_entry
r_static
r_void
id|dup_entry
c_func
(paren
r_struct
id|blame_entry
op_star
id|dst
comma
r_struct
id|blame_entry
op_star
id|src
)paren
(brace
r_struct
id|blame_entry
op_star
id|p
comma
op_star
id|n
suffix:semicolon
id|p
op_assign
id|dst-&gt;prev
suffix:semicolon
id|n
op_assign
id|dst-&gt;next
suffix:semicolon
id|origin_incref
c_func
(paren
id|src-&gt;suspect
)paren
suffix:semicolon
id|origin_decref
c_func
(paren
id|dst-&gt;suspect
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|dst
comma
id|src
comma
r_sizeof
(paren
op_star
id|src
)paren
)paren
suffix:semicolon
id|dst-&gt;prev
op_assign
id|p
suffix:semicolon
id|dst-&gt;next
op_assign
id|n
suffix:semicolon
id|dst-&gt;score
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|nth_line
r_static
r_const
r_char
op_star
id|nth_line
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_int
id|lno
)paren
(brace
r_return
id|sb-&gt;final_buf
op_plus
id|sb-&gt;lineno
(braket
id|lno
)braket
suffix:semicolon
)brace
multiline_comment|/*&n; * It is known that lines between tlno to same came from parent, and e&n; * has an overlap with that range.  it also is known that parent&squot;s&n; * line plno corresponds to e&squot;s line tlno.&n; *&n; *                &lt;---- e -----&gt;&n; *                   &lt;------&gt;&n; *                   &lt;------------&gt;&n; *             &lt;------------&gt;&n; *             &lt;------------------&gt;&n; *&n; * Split e into potentially three parts; before this chunk, the chunk&n; * to be blamed for the parent, and after that portion.&n; */
DECL|function|split_overlap
r_static
r_void
id|split_overlap
c_func
(paren
r_struct
id|blame_entry
op_star
id|split
comma
r_struct
id|blame_entry
op_star
id|e
comma
r_int
id|tlno
comma
r_int
id|plno
comma
r_int
id|same
comma
r_struct
id|origin
op_star
id|parent
)paren
(brace
r_int
id|chunk_end_lno
suffix:semicolon
id|memset
c_func
(paren
id|split
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|blame_entry
(braket
l_int|3
)braket
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e-&gt;s_lno
OL
id|tlno
)paren
(brace
multiline_comment|/* there is a pre-chunk part not blamed on parent */
id|split
(braket
l_int|0
)braket
dot
id|suspect
op_assign
id|origin_incref
c_func
(paren
id|e-&gt;suspect
)paren
suffix:semicolon
id|split
(braket
l_int|0
)braket
dot
id|lno
op_assign
id|e-&gt;lno
suffix:semicolon
id|split
(braket
l_int|0
)braket
dot
id|s_lno
op_assign
id|e-&gt;s_lno
suffix:semicolon
id|split
(braket
l_int|0
)braket
dot
id|num_lines
op_assign
id|tlno
id|e-&gt;s_lno
suffix:semicolon
id|split
(braket
l_int|1
)braket
dot
id|lno
op_assign
id|e-&gt;lno
op_plus
id|tlno
id|e-&gt;s_lno
suffix:semicolon
id|split
(braket
l_int|1
)braket
dot
id|s_lno
op_assign
id|plno
suffix:semicolon
)brace
r_else
(brace
id|split
(braket
l_int|1
)braket
dot
id|lno
op_assign
id|e-&gt;lno
suffix:semicolon
id|split
(braket
l_int|1
)braket
dot
id|s_lno
op_assign
id|plno
op_plus
(paren
id|e-&gt;s_lno
id|tlno
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|same
OL
id|e-&gt;s_lno
op_plus
id|e-&gt;num_lines
)paren
(brace
multiline_comment|/* there is a post-chunk part not blamed on parent */
id|split
(braket
l_int|2
)braket
dot
id|suspect
op_assign
id|origin_incref
c_func
(paren
id|e-&gt;suspect
)paren
suffix:semicolon
id|split
(braket
l_int|2
)braket
dot
id|lno
op_assign
id|e-&gt;lno
op_plus
(paren
id|same
id|e-&gt;s_lno
)paren
suffix:semicolon
id|split
(braket
l_int|2
)braket
dot
id|s_lno
op_assign
id|e-&gt;s_lno
op_plus
(paren
id|same
id|e-&gt;s_lno
)paren
suffix:semicolon
id|split
(braket
l_int|2
)braket
dot
id|num_lines
op_assign
id|e-&gt;s_lno
op_plus
id|e-&gt;num_lines
id|same
suffix:semicolon
id|chunk_end_lno
op_assign
id|split
(braket
l_int|2
)braket
dot
id|lno
suffix:semicolon
)brace
r_else
id|chunk_end_lno
op_assign
id|e-&gt;lno
op_plus
id|e-&gt;num_lines
suffix:semicolon
id|split
(braket
l_int|1
)braket
dot
id|num_lines
op_assign
id|chunk_end_lno
id|split
(braket
l_int|1
)braket
dot
id|lno
suffix:semicolon
multiline_comment|/*&n;&t; * if it turns out there is nothing to blame the parent for,&n;&t; * forget about the splitting.  !split[1].suspect signals this.&n;&t; */
r_if
c_cond
(paren
id|split
(braket
l_int|1
)braket
dot
id|num_lines
OL
l_int|1
)paren
r_return
suffix:semicolon
id|split
(braket
l_int|1
)braket
dot
id|suspect
op_assign
id|origin_incref
c_func
(paren
id|parent
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * split_overlap() divided an existing blame e into up to three parts&n; * in split.  Adjust the linked list of blames in the scoreboard to&n; * reflect the split.&n; */
DECL|function|split_blame
r_static
r_void
id|split_blame
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_struct
id|blame_entry
op_star
id|split
comma
r_struct
id|blame_entry
op_star
id|e
)paren
(brace
r_struct
id|blame_entry
op_star
id|new_entry
suffix:semicolon
r_if
c_cond
(paren
id|split
(braket
l_int|0
)braket
dot
id|suspect
op_logical_and
id|split
(braket
l_int|2
)braket
dot
id|suspect
)paren
(brace
multiline_comment|/* The first part (reuse storage for the existing entry e) */
id|dup_entry
c_func
(paren
id|e
comma
op_amp
id|split
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/* The last part -- me */
id|new_entry
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|new_entry
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|new_entry
comma
op_amp
(paren
id|split
(braket
l_int|2
)braket
)paren
comma
r_sizeof
(paren
r_struct
id|blame_entry
)paren
)paren
suffix:semicolon
id|add_blame_entry
c_func
(paren
id|sb
comma
id|new_entry
)paren
suffix:semicolon
multiline_comment|/* ... and the middle part -- parent */
id|new_entry
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|new_entry
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|new_entry
comma
op_amp
(paren
id|split
(braket
l_int|1
)braket
)paren
comma
r_sizeof
(paren
r_struct
id|blame_entry
)paren
)paren
suffix:semicolon
id|add_blame_entry
c_func
(paren
id|sb
comma
id|new_entry
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|split
(braket
l_int|0
)braket
dot
id|suspect
op_logical_and
op_logical_neg
id|split
(braket
l_int|2
)braket
dot
id|suspect
)paren
multiline_comment|/*&n;&t;&t; * The parent covers the entire area; reuse storage for&n;&t;&t; * e and replace it with the parent.&n;&t;&t; */
id|dup_entry
c_func
(paren
id|e
comma
op_amp
id|split
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|split
(braket
l_int|0
)braket
dot
id|suspect
)paren
(brace
multiline_comment|/* me and then parent */
id|dup_entry
c_func
(paren
id|e
comma
op_amp
id|split
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|new_entry
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|new_entry
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|new_entry
comma
op_amp
(paren
id|split
(braket
l_int|1
)braket
)paren
comma
r_sizeof
(paren
r_struct
id|blame_entry
)paren
)paren
suffix:semicolon
id|add_blame_entry
c_func
(paren
id|sb
comma
id|new_entry
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* parent and then me */
id|dup_entry
c_func
(paren
id|e
comma
op_amp
id|split
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|new_entry
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|new_entry
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|new_entry
comma
op_amp
(paren
id|split
(braket
l_int|2
)braket
)paren
comma
r_sizeof
(paren
r_struct
id|blame_entry
)paren
)paren
suffix:semicolon
id|add_blame_entry
c_func
(paren
id|sb
comma
id|new_entry
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DEBUG
)paren
(brace
multiline_comment|/* sanity */
r_struct
id|blame_entry
op_star
id|ent
suffix:semicolon
r_int
id|lno
op_assign
id|sb-&gt;ent-&gt;lno
comma
id|corrupt
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|ent
op_assign
id|sb-&gt;ent
suffix:semicolon
id|ent
suffix:semicolon
id|ent
op_assign
id|ent-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|lno
op_ne
id|ent-&gt;lno
)paren
id|corrupt
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ent-&gt;s_lno
OL
l_int|0
)paren
id|corrupt
op_assign
l_int|1
suffix:semicolon
id|lno
op_add_assign
id|ent-&gt;num_lines
suffix:semicolon
)brace
r_if
c_cond
(paren
id|corrupt
)paren
(brace
id|lno
op_assign
id|sb-&gt;ent-&gt;lno
suffix:semicolon
r_for
c_loop
(paren
id|ent
op_assign
id|sb-&gt;ent
suffix:semicolon
id|ent
suffix:semicolon
id|ent
op_assign
id|ent-&gt;next
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;L %8d l %8d n %8d&bslash;n&quot;
comma
id|lno
comma
id|ent-&gt;lno
comma
id|ent-&gt;num_lines
)paren
suffix:semicolon
id|lno
op_assign
id|ent-&gt;lno
op_plus
id|ent-&gt;num_lines
suffix:semicolon
)brace
id|die
c_func
(paren
l_string|&quot;oops&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * After splitting the blame, the origins used by the&n; * on-stack blame_entry should lose one refcnt each.&n; */
DECL|function|decref_split
r_static
r_void
id|decref_split
c_func
(paren
r_struct
id|blame_entry
op_star
id|split
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
id|origin_decref
c_func
(paren
id|split
(braket
id|i
)braket
dot
id|suspect
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Helper for blame_chunk().  blame_entry e is known to overlap with&n; * the patch hunk; split it and pass blame to the parent.&n; */
DECL|function|blame_overlap
r_static
r_void
id|blame_overlap
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_struct
id|blame_entry
op_star
id|e
comma
r_int
id|tlno
comma
r_int
id|plno
comma
r_int
id|same
comma
r_struct
id|origin
op_star
id|parent
)paren
(brace
r_struct
id|blame_entry
id|split
(braket
l_int|3
)braket
suffix:semicolon
id|split_overlap
c_func
(paren
id|split
comma
id|e
comma
id|tlno
comma
id|plno
comma
id|same
comma
id|parent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|split
(braket
l_int|1
)braket
dot
id|suspect
)paren
id|split_blame
c_func
(paren
id|sb
comma
id|split
comma
id|e
)paren
suffix:semicolon
id|decref_split
c_func
(paren
id|split
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Find the line number of the last line the target is suspected for.&n; */
DECL|function|find_last_in_target
r_static
r_int
id|find_last_in_target
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_struct
id|origin
op_star
id|target
)paren
(brace
r_struct
id|blame_entry
op_star
id|e
suffix:semicolon
r_int
id|last_in_target
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|e
op_assign
id|sb-&gt;ent
suffix:semicolon
id|e
suffix:semicolon
id|e
op_assign
id|e-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|e-&gt;guilty
op_logical_or
op_logical_neg
id|same_suspect
c_func
(paren
id|e-&gt;suspect
comma
id|target
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|last_in_target
OL
id|e-&gt;s_lno
op_plus
id|e-&gt;num_lines
)paren
id|last_in_target
op_assign
id|e-&gt;s_lno
op_plus
id|e-&gt;num_lines
suffix:semicolon
)brace
r_return
id|last_in_target
suffix:semicolon
)brace
multiline_comment|/*&n; * Process one hunk from the patch between the current suspect for&n; * blame_entry e and its parent.  Find and split the overlap, and&n; * pass blame to the overlapping part to the parent.&n; */
DECL|function|blame_chunk
r_static
r_void
id|blame_chunk
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_int
id|tlno
comma
r_int
id|plno
comma
r_int
id|same
comma
r_struct
id|origin
op_star
id|target
comma
r_struct
id|origin
op_star
id|parent
)paren
(brace
r_struct
id|blame_entry
op_star
id|e
suffix:semicolon
r_for
c_loop
(paren
id|e
op_assign
id|sb-&gt;ent
suffix:semicolon
id|e
suffix:semicolon
id|e
op_assign
id|e-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|e-&gt;guilty
op_logical_or
op_logical_neg
id|same_suspect
c_func
(paren
id|e-&gt;suspect
comma
id|target
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|same
op_le
id|e-&gt;s_lno
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|tlno
OL
id|e-&gt;s_lno
op_plus
id|e-&gt;num_lines
)paren
id|blame_overlap
c_func
(paren
id|sb
comma
id|e
comma
id|tlno
comma
id|plno
comma
id|same
comma
id|parent
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * We are looking at the origin &squot;target&squot; and aiming to pass blame&n; * for the lines it is suspected to its parent.  Run diff to find&n; * which lines came from parent and pass blame for them.&n; */
DECL|function|pass_blame_to_parent
r_static
r_int
id|pass_blame_to_parent
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_struct
id|origin
op_star
id|target
comma
r_struct
id|origin
op_star
id|parent
)paren
(brace
r_int
id|i
comma
id|last_in_target
comma
id|plno
comma
id|tlno
suffix:semicolon
r_struct
id|patch
op_star
id|patch
suffix:semicolon
id|last_in_target
op_assign
id|find_last_in_target
c_func
(paren
id|sb
comma
id|target
)paren
suffix:semicolon
r_if
c_cond
(paren
id|last_in_target
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* nothing remains for this target */
id|patch
op_assign
id|get_patch
c_func
(paren
id|parent
comma
id|target
)paren
suffix:semicolon
id|plno
op_assign
id|tlno
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|patch-&gt;num
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|chunk
op_star
id|chunk
op_assign
op_amp
id|patch-&gt;chunks
(braket
id|i
)braket
suffix:semicolon
id|blame_chunk
c_func
(paren
id|sb
comma
id|tlno
comma
id|plno
comma
id|chunk-&gt;same
comma
id|target
comma
id|parent
)paren
suffix:semicolon
id|plno
op_assign
id|chunk-&gt;p_next
suffix:semicolon
id|tlno
op_assign
id|chunk-&gt;t_next
suffix:semicolon
)brace
multiline_comment|/* The rest (i.e. anything after tlno) are the same as the parent */
id|blame_chunk
c_func
(paren
id|sb
comma
id|tlno
comma
id|plno
comma
id|last_in_target
comma
id|target
comma
id|parent
)paren
suffix:semicolon
id|free_patch
c_func
(paren
id|patch
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * The lines in blame_entry after splitting blames many times can become&n; * very small and trivial, and at some point it becomes pointless to&n; * blame the parents.  E.g. &quot;&bslash;t&bslash;t}&bslash;n&bslash;t}&bslash;n&bslash;n&quot; appears everywhere in any&n; * ordinary C program, and it is not worth to say it was copied from&n; * totally unrelated file in the parent.&n; *&n; * Compute how trivial the lines in the blame_entry are.&n; */
DECL|function|ent_score
r_static
r_int
id|ent_score
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_struct
id|blame_entry
op_star
id|e
)paren
(brace
r_int
id|score
suffix:semicolon
r_const
r_char
op_star
id|cp
comma
op_star
id|ep
suffix:semicolon
r_if
c_cond
(paren
id|e-&gt;score
)paren
r_return
id|e-&gt;score
suffix:semicolon
id|score
op_assign
l_int|1
suffix:semicolon
id|cp
op_assign
id|nth_line
c_func
(paren
id|sb
comma
id|e-&gt;lno
)paren
suffix:semicolon
id|ep
op_assign
id|nth_line
c_func
(paren
id|sb
comma
id|e-&gt;lno
op_plus
id|e-&gt;num_lines
)paren
suffix:semicolon
r_while
c_loop
(paren
id|cp
OL
id|ep
)paren
(brace
r_int
id|ch
op_assign
op_star
(paren
(paren
r_int
r_char
op_star
)paren
id|cp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|isalnum
c_func
(paren
id|ch
)paren
)paren
id|score
op_increment
suffix:semicolon
id|cp
op_increment
suffix:semicolon
)brace
id|e-&gt;score
op_assign
id|score
suffix:semicolon
r_return
id|score
suffix:semicolon
)brace
multiline_comment|/*&n; * best_so_far[] and this[] are both a split of an existing blame_entry&n; * that passes blame to the parent.  Maintain best_so_far the best split&n; * so far, by comparing this and best_so_far and copying this into&n; * bst_so_far as needed.&n; */
DECL|function|copy_split_if_better
r_static
r_void
id|copy_split_if_better
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_struct
id|blame_entry
op_star
id|best_so_far
comma
r_struct
id|blame_entry
op_star
id|this
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|this
(braket
l_int|1
)braket
dot
id|suspect
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|best_so_far
(braket
l_int|1
)braket
dot
id|suspect
)paren
(brace
r_if
c_cond
(paren
id|ent_score
c_func
(paren
id|sb
comma
op_amp
id|this
(braket
l_int|1
)braket
)paren
OL
id|ent_score
c_func
(paren
id|sb
comma
op_amp
id|best_so_far
(braket
l_int|1
)braket
)paren
)paren
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
id|origin_incref
c_func
(paren
id|this
(braket
id|i
)braket
dot
id|suspect
)paren
suffix:semicolon
id|decref_split
c_func
(paren
id|best_so_far
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|best_so_far
comma
id|this
comma
r_sizeof
(paren
r_struct
id|blame_entry
(braket
l_int|3
)braket
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * We are looking at a part of the final image represented by&n; * ent (tlno and same are offset by ent-&gt;s_lno).&n; * tlno is where we are looking at in the final image.&n; * up to (but not including) same match preimage.&n; * plno is where we are looking at in the preimage.&n; *&n; * &lt;-------------- final image ----------------------&gt;&n; *       &lt;------ent------&gt;&n; *         ^tlno ^same&n; *    &lt;---------preimage-----&gt;&n; *         ^plno&n; *&n; * All line numbers are 0-based.&n; */
DECL|function|handle_split
r_static
r_void
id|handle_split
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_struct
id|blame_entry
op_star
id|ent
comma
r_int
id|tlno
comma
r_int
id|plno
comma
r_int
id|same
comma
r_struct
id|origin
op_star
id|parent
comma
r_struct
id|blame_entry
op_star
id|split
)paren
(brace
r_if
c_cond
(paren
id|ent-&gt;num_lines
op_le
id|tlno
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|tlno
OL
id|same
)paren
(brace
r_struct
id|blame_entry
id|this
(braket
l_int|3
)braket
suffix:semicolon
id|tlno
op_add_assign
id|ent-&gt;s_lno
suffix:semicolon
id|same
op_add_assign
id|ent-&gt;s_lno
suffix:semicolon
id|split_overlap
c_func
(paren
id|this
comma
id|ent
comma
id|tlno
comma
id|plno
comma
id|same
comma
id|parent
)paren
suffix:semicolon
id|copy_split_if_better
c_func
(paren
id|sb
comma
id|split
comma
id|this
)paren
suffix:semicolon
id|decref_split
c_func
(paren
id|this
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Find the lines from parent that are the same as ent so that&n; * we can pass blames to it.  file_p has the blob contents for&n; * the parent.&n; */
DECL|function|find_copy_in_blob
r_static
r_void
id|find_copy_in_blob
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_struct
id|blame_entry
op_star
id|ent
comma
r_struct
id|origin
op_star
id|parent
comma
r_struct
id|blame_entry
op_star
id|split
comma
id|mmfile_t
op_star
id|file_p
)paren
(brace
r_const
r_char
op_star
id|cp
suffix:semicolon
r_int
id|cnt
suffix:semicolon
id|mmfile_t
id|file_o
suffix:semicolon
r_struct
id|patch
op_star
id|patch
suffix:semicolon
r_int
id|i
comma
id|plno
comma
id|tlno
suffix:semicolon
multiline_comment|/*&n;&t; * Prepare mmfile that contains only the lines in ent.&n;&t; */
id|cp
op_assign
id|nth_line
c_func
(paren
id|sb
comma
id|ent-&gt;lno
)paren
suffix:semicolon
id|file_o.ptr
op_assign
(paren
r_char
op_star
)paren
id|cp
suffix:semicolon
id|cnt
op_assign
id|ent-&gt;num_lines
suffix:semicolon
r_while
c_loop
(paren
id|cnt
op_logical_and
id|cp
OL
id|sb-&gt;final_buf
op_plus
id|sb-&gt;final_buf_size
)paren
(brace
r_if
c_cond
(paren
op_star
id|cp
op_increment
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|cnt
op_decrement
suffix:semicolon
)brace
id|file_o.size
op_assign
id|cp
id|file_o.ptr
suffix:semicolon
id|patch
op_assign
id|compare_buffer
c_func
(paren
id|file_p
comma
op_amp
id|file_o
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * file_o is a part of final image we are annotating.&n;&t; * file_p partially may match that image.&n;&t; */
id|memset
c_func
(paren
id|split
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|blame_entry
(braket
l_int|3
)braket
)paren
)paren
suffix:semicolon
id|plno
op_assign
id|tlno
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|patch-&gt;num
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|chunk
op_star
id|chunk
op_assign
op_amp
id|patch-&gt;chunks
(braket
id|i
)braket
suffix:semicolon
id|handle_split
c_func
(paren
id|sb
comma
id|ent
comma
id|tlno
comma
id|plno
comma
id|chunk-&gt;same
comma
id|parent
comma
id|split
)paren
suffix:semicolon
id|plno
op_assign
id|chunk-&gt;p_next
suffix:semicolon
id|tlno
op_assign
id|chunk-&gt;t_next
suffix:semicolon
)brace
multiline_comment|/* remainder, if any, all match the preimage */
id|handle_split
c_func
(paren
id|sb
comma
id|ent
comma
id|tlno
comma
id|plno
comma
id|ent-&gt;num_lines
comma
id|parent
comma
id|split
)paren
suffix:semicolon
id|free_patch
c_func
(paren
id|patch
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * See if lines currently target is suspected for can be attributed to&n; * parent.&n; */
DECL|function|find_move_in_parent
r_static
r_int
id|find_move_in_parent
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_struct
id|origin
op_star
id|target
comma
r_struct
id|origin
op_star
id|parent
)paren
(brace
r_int
id|last_in_target
comma
id|made_progress
suffix:semicolon
r_struct
id|blame_entry
op_star
id|e
comma
id|split
(braket
l_int|3
)braket
suffix:semicolon
id|mmfile_t
id|file_p
suffix:semicolon
id|last_in_target
op_assign
id|find_last_in_target
c_func
(paren
id|sb
comma
id|target
)paren
suffix:semicolon
r_if
c_cond
(paren
id|last_in_target
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* nothing remains for this target */
id|fill_origin_blob
c_func
(paren
id|parent
comma
op_amp
id|file_p
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file_p.ptr
)paren
r_return
l_int|0
suffix:semicolon
id|made_progress
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|made_progress
)paren
(brace
id|made_progress
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|e
op_assign
id|sb-&gt;ent
suffix:semicolon
id|e
suffix:semicolon
id|e
op_assign
id|e-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|e-&gt;guilty
op_logical_or
op_logical_neg
id|same_suspect
c_func
(paren
id|e-&gt;suspect
comma
id|target
)paren
op_logical_or
id|ent_score
c_func
(paren
id|sb
comma
id|e
)paren
OL
id|blame_move_score
)paren
r_continue
suffix:semicolon
id|find_copy_in_blob
c_func
(paren
id|sb
comma
id|e
comma
id|parent
comma
id|split
comma
op_amp
id|file_p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|split
(braket
l_int|1
)braket
dot
id|suspect
op_logical_and
id|blame_move_score
OL
id|ent_score
c_func
(paren
id|sb
comma
op_amp
id|split
(braket
l_int|1
)braket
)paren
)paren
(brace
id|split_blame
c_func
(paren
id|sb
comma
id|split
comma
id|e
)paren
suffix:semicolon
id|made_progress
op_assign
l_int|1
suffix:semicolon
)brace
id|decref_split
c_func
(paren
id|split
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|struct|blame_list
r_struct
id|blame_list
(brace
DECL|member|ent
r_struct
id|blame_entry
op_star
id|ent
suffix:semicolon
DECL|member|split
r_struct
id|blame_entry
id|split
(braket
l_int|3
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Count the number of entries the target is suspected for,&n; * and prepare a list of entry and the best split.&n; */
DECL|function|setup_blame_list
r_static
r_struct
id|blame_list
op_star
id|setup_blame_list
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_struct
id|origin
op_star
id|target
comma
r_int
id|min_score
comma
r_int
op_star
id|num_ents_p
)paren
(brace
r_struct
id|blame_entry
op_star
id|e
suffix:semicolon
r_int
id|num_ents
comma
id|i
suffix:semicolon
r_struct
id|blame_list
op_star
id|blame_list
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|e
op_assign
id|sb-&gt;ent
comma
id|num_ents
op_assign
l_int|0
suffix:semicolon
id|e
suffix:semicolon
id|e
op_assign
id|e-&gt;next
)paren
r_if
c_cond
(paren
op_logical_neg
id|e-&gt;scanned
op_logical_and
op_logical_neg
id|e-&gt;guilty
op_logical_and
id|same_suspect
c_func
(paren
id|e-&gt;suspect
comma
id|target
)paren
op_logical_and
id|min_score
OL
id|ent_score
c_func
(paren
id|sb
comma
id|e
)paren
)paren
id|num_ents
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|num_ents
)paren
(brace
id|blame_list
op_assign
id|xcalloc
c_func
(paren
id|num_ents
comma
r_sizeof
(paren
r_struct
id|blame_list
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|e
op_assign
id|sb-&gt;ent
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|e
suffix:semicolon
id|e
op_assign
id|e-&gt;next
)paren
r_if
c_cond
(paren
op_logical_neg
id|e-&gt;scanned
op_logical_and
op_logical_neg
id|e-&gt;guilty
op_logical_and
id|same_suspect
c_func
(paren
id|e-&gt;suspect
comma
id|target
)paren
op_logical_and
id|min_score
OL
id|ent_score
c_func
(paren
id|sb
comma
id|e
)paren
)paren
id|blame_list
(braket
id|i
op_increment
)braket
dot
id|ent
op_assign
id|e
suffix:semicolon
)brace
op_star
id|num_ents_p
op_assign
id|num_ents
suffix:semicolon
r_return
id|blame_list
suffix:semicolon
)brace
multiline_comment|/*&n; * Reset the scanned status on all entries.&n; */
DECL|function|reset_scanned_flag
r_static
r_void
id|reset_scanned_flag
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
)paren
(brace
r_struct
id|blame_entry
op_star
id|e
suffix:semicolon
r_for
c_loop
(paren
id|e
op_assign
id|sb-&gt;ent
suffix:semicolon
id|e
suffix:semicolon
id|e
op_assign
id|e-&gt;next
)paren
id|e-&gt;scanned
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * For lines target is suspected for, see if we can find code movement&n; * across file boundary from the parent commit.  porigin is the path&n; * in the parent we already tried.&n; */
DECL|function|find_copy_in_parent
r_static
r_int
id|find_copy_in_parent
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_struct
id|origin
op_star
id|target
comma
r_struct
id|commit
op_star
id|parent
comma
r_struct
id|origin
op_star
id|porigin
comma
r_int
id|opt
)paren
(brace
r_struct
id|diff_options
id|diff_opts
suffix:semicolon
r_const
r_char
op_star
id|paths
(braket
l_int|1
)braket
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_struct
id|blame_list
op_star
id|blame_list
suffix:semicolon
r_int
id|num_ents
suffix:semicolon
id|blame_list
op_assign
id|setup_blame_list
c_func
(paren
id|sb
comma
id|target
comma
id|blame_copy_score
comma
op_amp
id|num_ents
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|blame_list
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* nothing remains for this target */
id|diff_setup
c_func
(paren
op_amp
id|diff_opts
)paren
suffix:semicolon
id|DIFF_OPT_SET
c_func
(paren
op_amp
id|diff_opts
comma
id|RECURSIVE
)paren
suffix:semicolon
id|diff_opts.output_format
op_assign
id|DIFF_FORMAT_NO_OUTPUT
suffix:semicolon
id|paths
(braket
l_int|0
)braket
op_assign
l_int|NULL
suffix:semicolon
id|diff_tree_setup_paths
c_func
(paren
id|paths
comma
op_amp
id|diff_opts
)paren
suffix:semicolon
r_if
c_cond
(paren
id|diff_setup_done
c_func
(paren
op_amp
id|diff_opts
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;diff-setup&quot;
)paren
suffix:semicolon
multiline_comment|/* Try &quot;find copies harder&quot; on new path if requested;&n;&t; * we do not want to use diffcore_rename() actually to&n;&t; * match things up; find_copies_harder is set only to&n;&t; * force diff_tree_sha1() to feed all filepairs to diff_queue,&n;&t; * and this code needs to be after diff_setup_done(), which&n;&t; * usually makes find-copies-harder imply copy detection.&n;&t; */
r_if
c_cond
(paren
(paren
id|opt
op_amp
id|PICKAXE_BLAME_COPY_HARDEST
)paren
op_logical_or
(paren
(paren
id|opt
op_amp
id|PICKAXE_BLAME_COPY_HARDER
)paren
op_logical_and
(paren
op_logical_neg
id|porigin
op_logical_or
id|strcmp
c_func
(paren
id|target-&gt;path
comma
id|porigin-&gt;path
)paren
)paren
)paren
)paren
id|DIFF_OPT_SET
c_func
(paren
op_amp
id|diff_opts
comma
id|FIND_COPIES_HARDER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_null_sha1
c_func
(paren
id|target-&gt;commit-&gt;object.sha1
)paren
)paren
id|do_diff_cache
c_func
(paren
id|parent-&gt;tree-&gt;object.sha1
comma
op_amp
id|diff_opts
)paren
suffix:semicolon
r_else
id|diff_tree_sha1
c_func
(paren
id|parent-&gt;tree-&gt;object.sha1
comma
id|target-&gt;commit-&gt;tree-&gt;object.sha1
comma
l_string|&quot;&quot;
comma
op_amp
id|diff_opts
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|DIFF_OPT_TST
c_func
(paren
op_amp
id|diff_opts
comma
id|FIND_COPIES_HARDER
)paren
)paren
id|diffcore_std
c_func
(paren
op_amp
id|diff_opts
)paren
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_int
id|made_progress
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|diff_queued_diff.nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|diff_filepair
op_star
id|p
op_assign
id|diff_queued_diff.queue
(braket
id|i
)braket
suffix:semicolon
r_struct
id|origin
op_star
id|norigin
suffix:semicolon
id|mmfile_t
id|file_p
suffix:semicolon
r_struct
id|blame_entry
id|this
(braket
l_int|3
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|DIFF_FILE_VALID
c_func
(paren
id|p-&gt;one
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* does not exist in parent */
r_if
c_cond
(paren
id|porigin
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|p-&gt;one-&gt;path
comma
id|porigin-&gt;path
)paren
)paren
multiline_comment|/* find_move already dealt with this path */
r_continue
suffix:semicolon
id|norigin
op_assign
id|get_origin
c_func
(paren
id|sb
comma
id|parent
comma
id|p-&gt;one-&gt;path
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|norigin-&gt;blob_sha1
comma
id|p-&gt;one-&gt;sha1
)paren
suffix:semicolon
id|fill_origin_blob
c_func
(paren
id|norigin
comma
op_amp
id|file_p
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file_p.ptr
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|num_ents
suffix:semicolon
id|j
op_increment
)paren
(brace
id|find_copy_in_blob
c_func
(paren
id|sb
comma
id|blame_list
(braket
id|j
)braket
dot
id|ent
comma
id|norigin
comma
id|this
comma
op_amp
id|file_p
)paren
suffix:semicolon
id|copy_split_if_better
c_func
(paren
id|sb
comma
id|blame_list
(braket
id|j
)braket
dot
id|split
comma
id|this
)paren
suffix:semicolon
id|decref_split
c_func
(paren
id|this
)paren
suffix:semicolon
)brace
id|origin_decref
c_func
(paren
id|norigin
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|num_ents
suffix:semicolon
id|j
op_increment
)paren
(brace
r_struct
id|blame_entry
op_star
id|split
op_assign
id|blame_list
(braket
id|j
)braket
dot
id|split
suffix:semicolon
r_if
c_cond
(paren
id|split
(braket
l_int|1
)braket
dot
id|suspect
op_logical_and
id|blame_copy_score
OL
id|ent_score
c_func
(paren
id|sb
comma
op_amp
id|split
(braket
l_int|1
)braket
)paren
)paren
(brace
id|split_blame
c_func
(paren
id|sb
comma
id|split
comma
id|blame_list
(braket
id|j
)braket
dot
id|ent
)paren
suffix:semicolon
id|made_progress
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|blame_list
(braket
id|j
)braket
dot
id|ent-&gt;scanned
op_assign
l_int|1
suffix:semicolon
id|decref_split
c_func
(paren
id|split
)paren
suffix:semicolon
)brace
id|free
c_func
(paren
id|blame_list
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|made_progress
)paren
r_break
suffix:semicolon
id|blame_list
op_assign
id|setup_blame_list
c_func
(paren
id|sb
comma
id|target
comma
id|blame_copy_score
comma
op_amp
id|num_ents
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|blame_list
)paren
(brace
id|retval
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|reset_scanned_flag
c_func
(paren
id|sb
)paren
suffix:semicolon
id|diff_flush
c_func
(paren
op_amp
id|diff_opts
)paren
suffix:semicolon
id|diff_tree_release_paths
c_func
(paren
op_amp
id|diff_opts
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * The blobs of origin and porigin exactly match, so everything&n; * origin is suspected for can be blamed on the parent.&n; */
DECL|function|pass_whole_blame
r_static
r_void
id|pass_whole_blame
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_struct
id|origin
op_star
id|origin
comma
r_struct
id|origin
op_star
id|porigin
)paren
(brace
r_struct
id|blame_entry
op_star
id|e
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|porigin-&gt;file.ptr
op_logical_and
id|origin-&gt;file.ptr
)paren
(brace
multiline_comment|/* Steal its file */
id|porigin-&gt;file
op_assign
id|origin-&gt;file
suffix:semicolon
id|origin-&gt;file.ptr
op_assign
l_int|NULL
suffix:semicolon
)brace
r_for
c_loop
(paren
id|e
op_assign
id|sb-&gt;ent
suffix:semicolon
id|e
suffix:semicolon
id|e
op_assign
id|e-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|same_suspect
c_func
(paren
id|e-&gt;suspect
comma
id|origin
)paren
)paren
r_continue
suffix:semicolon
id|origin_incref
c_func
(paren
id|porigin
)paren
suffix:semicolon
id|origin_decref
c_func
(paren
id|e-&gt;suspect
)paren
suffix:semicolon
id|e-&gt;suspect
op_assign
id|porigin
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * We pass blame from the current commit to its parents.  We keep saying&n; * &quot;parent&quot; (and &quot;porigin&quot;), but what we mean is to find scapegoat to&n; * exonerate ourselves.&n; */
DECL|function|first_scapegoat
r_static
r_struct
id|commit_list
op_star
id|first_scapegoat
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|reverse
)paren
r_return
id|commit-&gt;parents
suffix:semicolon
r_return
id|lookup_decoration
c_func
(paren
op_amp
id|revs-&gt;children
comma
op_amp
id|commit-&gt;object
)paren
suffix:semicolon
)brace
DECL|function|num_scapegoats
r_static
r_int
id|num_scapegoats
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_int
id|cnt
suffix:semicolon
r_struct
id|commit_list
op_star
id|l
op_assign
id|first_scapegoat
c_func
(paren
id|revs
comma
id|commit
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|l
suffix:semicolon
id|l
op_assign
id|l-&gt;next
)paren
id|cnt
op_increment
suffix:semicolon
r_return
id|cnt
suffix:semicolon
)brace
DECL|macro|MAXSG
mdefine_line|#define MAXSG 16
DECL|function|pass_blame
r_static
r_void
id|pass_blame
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_struct
id|origin
op_star
id|origin
comma
r_int
id|opt
)paren
(brace
r_struct
id|rev_info
op_star
id|revs
op_assign
id|sb-&gt;revs
suffix:semicolon
r_int
id|i
comma
id|pass
comma
id|num_sg
suffix:semicolon
r_struct
id|commit
op_star
id|commit
op_assign
id|origin-&gt;commit
suffix:semicolon
r_struct
id|commit_list
op_star
id|sg
suffix:semicolon
r_struct
id|origin
op_star
id|sg_buf
(braket
id|MAXSG
)braket
suffix:semicolon
r_struct
id|origin
op_star
id|porigin
comma
op_star
op_star
id|sg_origin
op_assign
id|sg_buf
suffix:semicolon
id|num_sg
op_assign
id|num_scapegoats
c_func
(paren
id|revs
comma
id|commit
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|num_sg
)paren
r_goto
id|finish
suffix:semicolon
r_else
r_if
c_cond
(paren
id|num_sg
OL
id|ARRAY_SIZE
c_func
(paren
id|sg_buf
)paren
)paren
id|memset
c_func
(paren
id|sg_buf
comma
l_int|0
comma
r_sizeof
(paren
id|sg_buf
)paren
)paren
suffix:semicolon
r_else
id|sg_origin
op_assign
id|xcalloc
c_func
(paren
id|num_sg
comma
r_sizeof
(paren
op_star
id|sg_origin
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The first pass looks for unrenamed path to optimize for&n;&t; * common cases, then we look for renames in the second pass.&n;&t; */
r_for
c_loop
(paren
id|pass
op_assign
l_int|0
suffix:semicolon
id|pass
OL
l_int|2
suffix:semicolon
id|pass
op_increment
)paren
(brace
r_struct
id|origin
op_star
(paren
op_star
id|find
)paren
(paren
r_struct
id|scoreboard
op_star
comma
r_struct
id|commit
op_star
comma
r_struct
id|origin
op_star
)paren
suffix:semicolon
id|find
op_assign
id|pass
ques
c_cond
id|find_rename
suffix:colon
id|find_origin
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|sg
op_assign
id|first_scapegoat
c_func
(paren
id|revs
comma
id|commit
)paren
suffix:semicolon
id|i
OL
id|num_sg
op_logical_and
id|sg
suffix:semicolon
id|sg
op_assign
id|sg-&gt;next
comma
id|i
op_increment
)paren
(brace
r_struct
id|commit
op_star
id|p
op_assign
id|sg-&gt;item
suffix:semicolon
r_int
id|j
comma
id|same
suffix:semicolon
r_if
c_cond
(paren
id|sg_origin
(braket
id|i
)braket
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|parse_commit
c_func
(paren
id|p
)paren
)paren
r_continue
suffix:semicolon
id|porigin
op_assign
id|find
c_func
(paren
id|sb
comma
id|p
comma
id|origin
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|porigin
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hashcmp
c_func
(paren
id|porigin-&gt;blob_sha1
comma
id|origin-&gt;blob_sha1
)paren
)paren
(brace
id|pass_whole_blame
c_func
(paren
id|sb
comma
id|origin
comma
id|porigin
)paren
suffix:semicolon
id|origin_decref
c_func
(paren
id|porigin
)paren
suffix:semicolon
r_goto
id|finish
suffix:semicolon
)brace
r_for
c_loop
(paren
id|j
op_assign
id|same
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|i
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
id|sg_origin
(braket
id|j
)braket
op_logical_and
op_logical_neg
id|hashcmp
c_func
(paren
id|sg_origin
(braket
id|j
)braket
op_member_access_from_pointer
id|blob_sha1
comma
id|porigin-&gt;blob_sha1
)paren
)paren
(brace
id|same
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|same
)paren
id|sg_origin
(braket
id|i
)braket
op_assign
id|porigin
suffix:semicolon
r_else
id|origin_decref
c_func
(paren
id|porigin
)paren
suffix:semicolon
)brace
)brace
id|num_commits
op_increment
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|sg
op_assign
id|first_scapegoat
c_func
(paren
id|revs
comma
id|commit
)paren
suffix:semicolon
id|i
OL
id|num_sg
op_logical_and
id|sg
suffix:semicolon
id|sg
op_assign
id|sg-&gt;next
comma
id|i
op_increment
)paren
(brace
r_struct
id|origin
op_star
id|porigin
op_assign
id|sg_origin
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|porigin
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|pass_blame_to_parent
c_func
(paren
id|sb
comma
id|origin
comma
id|porigin
)paren
)paren
r_goto
id|finish
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Optionally find moves in parents&squot; files.&n;&t; */
r_if
c_cond
(paren
id|opt
op_amp
id|PICKAXE_BLAME_MOVE
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|sg
op_assign
id|first_scapegoat
c_func
(paren
id|revs
comma
id|commit
)paren
suffix:semicolon
id|i
OL
id|num_sg
op_logical_and
id|sg
suffix:semicolon
id|sg
op_assign
id|sg-&gt;next
comma
id|i
op_increment
)paren
(brace
r_struct
id|origin
op_star
id|porigin
op_assign
id|sg_origin
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|porigin
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|find_move_in_parent
c_func
(paren
id|sb
comma
id|origin
comma
id|porigin
)paren
)paren
r_goto
id|finish
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Optionally find copies from parents&squot; files.&n;&t; */
r_if
c_cond
(paren
id|opt
op_amp
id|PICKAXE_BLAME_COPY
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|sg
op_assign
id|first_scapegoat
c_func
(paren
id|revs
comma
id|commit
)paren
suffix:semicolon
id|i
OL
id|num_sg
op_logical_and
id|sg
suffix:semicolon
id|sg
op_assign
id|sg-&gt;next
comma
id|i
op_increment
)paren
(brace
r_struct
id|origin
op_star
id|porigin
op_assign
id|sg_origin
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|find_copy_in_parent
c_func
(paren
id|sb
comma
id|origin
comma
id|sg-&gt;item
comma
id|porigin
comma
id|opt
)paren
)paren
r_goto
id|finish
suffix:semicolon
)brace
id|finish
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_sg
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|sg_origin
(braket
id|i
)braket
)paren
(brace
id|drop_origin_blob
c_func
(paren
id|sg_origin
(braket
id|i
)braket
)paren
suffix:semicolon
id|origin_decref
c_func
(paren
id|sg_origin
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
id|drop_origin_blob
c_func
(paren
id|origin
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sg_buf
op_ne
id|sg_origin
)paren
id|free
c_func
(paren
id|sg_origin
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Information on commits, used for output.&n; */
DECL|struct|commit_info
r_struct
id|commit_info
(brace
DECL|member|author
r_const
r_char
op_star
id|author
suffix:semicolon
DECL|member|author_mail
r_const
r_char
op_star
id|author_mail
suffix:semicolon
DECL|member|author_time
r_int
r_int
id|author_time
suffix:semicolon
DECL|member|author_tz
r_const
r_char
op_star
id|author_tz
suffix:semicolon
multiline_comment|/* filled only when asked for details */
DECL|member|committer
r_const
r_char
op_star
id|committer
suffix:semicolon
DECL|member|committer_mail
r_const
r_char
op_star
id|committer_mail
suffix:semicolon
DECL|member|committer_time
r_int
r_int
id|committer_time
suffix:semicolon
DECL|member|committer_tz
r_const
r_char
op_star
id|committer_tz
suffix:semicolon
DECL|member|summary
r_const
r_char
op_star
id|summary
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Parse author/committer line in the commit object buffer&n; */
DECL|function|get_ac_line
r_static
r_void
id|get_ac_line
c_func
(paren
r_const
r_char
op_star
id|inbuf
comma
r_const
r_char
op_star
id|what
comma
r_int
id|bufsz
comma
r_char
op_star
id|person
comma
r_const
r_char
op_star
op_star
id|mail
comma
r_int
r_int
op_star
id|time
comma
r_const
r_char
op_star
op_star
id|tz
)paren
(brace
r_int
id|len
comma
id|tzlen
comma
id|maillen
suffix:semicolon
r_char
op_star
id|tmp
comma
op_star
id|endp
comma
op_star
id|timepos
suffix:semicolon
id|tmp
op_assign
id|strstr
c_func
(paren
id|inbuf
comma
id|what
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp
)paren
r_goto
id|error_out
suffix:semicolon
id|tmp
op_add_assign
id|strlen
c_func
(paren
id|what
)paren
suffix:semicolon
id|endp
op_assign
id|strchr
c_func
(paren
id|tmp
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|endp
)paren
id|len
op_assign
id|strlen
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_else
id|len
op_assign
id|endp
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|bufsz
op_le
id|len
)paren
(brace
id|error_out
suffix:colon
multiline_comment|/* Ugh */
op_star
id|mail
op_assign
op_star
id|tz
op_assign
l_string|&quot;(unknown)&quot;
suffix:semicolon
op_star
id|time
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|person
comma
id|tmp
comma
id|len
)paren
suffix:semicolon
id|tmp
op_assign
id|person
suffix:semicolon
id|tmp
op_add_assign
id|len
suffix:semicolon
op_star
id|tmp
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_star
id|tmp
op_ne
l_char|&squot; &squot;
)paren
id|tmp
op_decrement
suffix:semicolon
op_star
id|tz
op_assign
id|tmp
op_plus
l_int|1
suffix:semicolon
id|tzlen
op_assign
(paren
id|person
op_plus
id|len
)paren
op_minus
(paren
id|tmp
op_plus
l_int|1
)paren
suffix:semicolon
op_star
id|tmp
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_star
id|tmp
op_ne
l_char|&squot; &squot;
)paren
id|tmp
op_decrement
suffix:semicolon
op_star
id|time
op_assign
id|strtoul
c_func
(paren
id|tmp
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
id|timepos
op_assign
id|tmp
suffix:semicolon
op_star
id|tmp
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_star
id|tmp
op_ne
l_char|&squot; &squot;
)paren
id|tmp
op_decrement
suffix:semicolon
op_star
id|mail
op_assign
id|tmp
op_plus
l_int|1
suffix:semicolon
op_star
id|tmp
op_assign
l_int|0
suffix:semicolon
id|maillen
op_assign
id|timepos
id|tmp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mailmap.nr
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * mailmap expansion may make the name longer.&n;&t; * make room by pushing stuff down.&n;&t; */
id|tmp
op_assign
id|person
op_plus
id|bufsz
(paren
id|tzlen
op_plus
l_int|1
)paren
suffix:semicolon
id|memmove
c_func
(paren
id|tmp
comma
op_star
id|tz
comma
id|tzlen
)paren
suffix:semicolon
id|tmp
(braket
id|tzlen
)braket
op_assign
l_int|0
suffix:semicolon
op_star
id|tz
op_assign
id|tmp
suffix:semicolon
id|tmp
op_assign
id|tmp
(paren
id|maillen
op_plus
l_int|1
)paren
suffix:semicolon
id|memmove
c_func
(paren
id|tmp
comma
op_star
id|mail
comma
id|maillen
)paren
suffix:semicolon
id|tmp
(braket
id|maillen
)braket
op_assign
l_int|0
suffix:semicolon
op_star
id|mail
op_assign
id|tmp
suffix:semicolon
multiline_comment|/*&n;&t; * Now, convert e-mail using mailmap&n;&t; */
id|map_email
c_func
(paren
op_amp
id|mailmap
comma
id|tmp
op_plus
l_int|1
comma
id|person
comma
id|tmp
op_minus
id|person
op_minus
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|get_commit_info
r_static
r_void
id|get_commit_info
c_func
(paren
r_struct
id|commit
op_star
id|commit
comma
r_struct
id|commit_info
op_star
id|ret
comma
r_int
id|detailed
)paren
(brace
r_int
id|len
suffix:semicolon
r_char
op_star
id|tmp
comma
op_star
id|endp
suffix:semicolon
r_static
r_char
id|author_buf
(braket
l_int|1024
)braket
suffix:semicolon
r_static
r_char
id|committer_buf
(braket
l_int|1024
)braket
suffix:semicolon
r_static
r_char
id|summary_buf
(braket
l_int|1024
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * We&squot;ve operated without save_commit_buffer, so&n;&t; * we now need to populate them for output.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|commit-&gt;buffer
)paren
(brace
r_enum
id|object_type
id|type
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
id|commit-&gt;buffer
op_assign
id|read_sha1_file
c_func
(paren
id|commit-&gt;object.sha1
comma
op_amp
id|type
comma
op_amp
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|commit-&gt;buffer
)paren
id|die
c_func
(paren
l_string|&quot;Cannot read commit %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|commit-&gt;object.sha1
)paren
)paren
suffix:semicolon
)brace
id|ret-&gt;author
op_assign
id|author_buf
suffix:semicolon
id|get_ac_line
c_func
(paren
id|commit-&gt;buffer
comma
l_string|&quot;&bslash;nauthor &quot;
comma
r_sizeof
(paren
id|author_buf
)paren
comma
id|author_buf
comma
op_amp
id|ret-&gt;author_mail
comma
op_amp
id|ret-&gt;author_time
comma
op_amp
id|ret-&gt;author_tz
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|detailed
)paren
r_return
suffix:semicolon
id|ret-&gt;committer
op_assign
id|committer_buf
suffix:semicolon
id|get_ac_line
c_func
(paren
id|commit-&gt;buffer
comma
l_string|&quot;&bslash;ncommitter &quot;
comma
r_sizeof
(paren
id|committer_buf
)paren
comma
id|committer_buf
comma
op_amp
id|ret-&gt;committer_mail
comma
op_amp
id|ret-&gt;committer_time
comma
op_amp
id|ret-&gt;committer_tz
)paren
suffix:semicolon
id|ret-&gt;summary
op_assign
id|summary_buf
suffix:semicolon
id|tmp
op_assign
id|strstr
c_func
(paren
id|commit-&gt;buffer
comma
l_string|&quot;&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp
)paren
(brace
id|error_out
suffix:colon
id|sprintf
c_func
(paren
id|summary_buf
comma
l_string|&quot;(%s)&quot;
comma
id|sha1_to_hex
c_func
(paren
id|commit-&gt;object.sha1
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|tmp
op_add_assign
l_int|2
suffix:semicolon
id|endp
op_assign
id|strchr
c_func
(paren
id|tmp
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|endp
)paren
id|endp
op_assign
id|tmp
op_plus
id|strlen
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|len
op_assign
id|endp
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ge
r_sizeof
(paren
id|summary_buf
)paren
op_logical_or
id|len
op_eq
l_int|0
)paren
r_goto
id|error_out
suffix:semicolon
id|memcpy
c_func
(paren
id|summary_buf
comma
id|tmp
comma
id|len
)paren
suffix:semicolon
id|summary_buf
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * To allow LF and other nonportable characters in pathnames,&n; * they are c-style quoted as needed.&n; */
DECL|function|write_filename_info
r_static
r_void
id|write_filename_info
c_func
(paren
r_const
r_char
op_star
id|path
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;filename &quot;
)paren
suffix:semicolon
id|write_name_quoted
c_func
(paren
id|path
comma
id|stdout
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The blame_entry is found to be guilty for the range.  Mark it&n; * as such, and show it in incremental output.&n; */
DECL|function|found_guilty_entry
r_static
r_void
id|found_guilty_entry
c_func
(paren
r_struct
id|blame_entry
op_star
id|ent
)paren
(brace
r_if
c_cond
(paren
id|ent-&gt;guilty
)paren
r_return
suffix:semicolon
id|ent-&gt;guilty
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|incremental
)paren
(brace
r_struct
id|origin
op_star
id|suspect
op_assign
id|ent-&gt;suspect
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s %d %d %d&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|suspect-&gt;commit-&gt;object.sha1
)paren
comma
id|ent-&gt;s_lno
op_plus
l_int|1
comma
id|ent-&gt;lno
op_plus
l_int|1
comma
id|ent-&gt;num_lines
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|suspect-&gt;commit-&gt;object.flags
op_amp
id|METAINFO_SHOWN
)paren
)paren
(brace
r_struct
id|commit_info
id|ci
suffix:semicolon
id|suspect-&gt;commit-&gt;object.flags
op_or_assign
id|METAINFO_SHOWN
suffix:semicolon
id|get_commit_info
c_func
(paren
id|suspect-&gt;commit
comma
op_amp
id|ci
comma
l_int|1
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;author %s&bslash;n&quot;
comma
id|ci.author
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;author-mail %s&bslash;n&quot;
comma
id|ci.author_mail
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;author-time %lu&bslash;n&quot;
comma
id|ci.author_time
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;author-tz %s&bslash;n&quot;
comma
id|ci.author_tz
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;committer %s&bslash;n&quot;
comma
id|ci.committer
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;committer-mail %s&bslash;n&quot;
comma
id|ci.committer_mail
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;committer-time %lu&bslash;n&quot;
comma
id|ci.committer_time
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;committer-tz %s&bslash;n&quot;
comma
id|ci.committer_tz
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;summary %s&bslash;n&quot;
comma
id|ci.summary
)paren
suffix:semicolon
r_if
c_cond
(paren
id|suspect-&gt;commit-&gt;object.flags
op_amp
id|UNINTERESTING
)paren
id|printf
c_func
(paren
l_string|&quot;boundary&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|write_filename_info
c_func
(paren
id|suspect-&gt;path
)paren
suffix:semicolon
id|maybe_flush_or_die
c_func
(paren
id|stdout
comma
l_string|&quot;stdout&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * The main loop -- while the scoreboard has lines whose true origin&n; * is still unknown, pick one blame_entry, and allow its current&n; * suspect to pass blames to its parents.&n; */
DECL|function|assign_blame
r_static
r_void
id|assign_blame
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_int
id|opt
)paren
(brace
r_struct
id|rev_info
op_star
id|revs
op_assign
id|sb-&gt;revs
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_struct
id|blame_entry
op_star
id|ent
suffix:semicolon
r_struct
id|commit
op_star
id|commit
suffix:semicolon
r_struct
id|origin
op_star
id|suspect
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* find one suspect to break down */
r_for
c_loop
(paren
id|ent
op_assign
id|sb-&gt;ent
suffix:semicolon
op_logical_neg
id|suspect
op_logical_and
id|ent
suffix:semicolon
id|ent
op_assign
id|ent-&gt;next
)paren
r_if
c_cond
(paren
op_logical_neg
id|ent-&gt;guilty
)paren
id|suspect
op_assign
id|ent-&gt;suspect
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|suspect
)paren
r_return
suffix:semicolon
multiline_comment|/* all done */
multiline_comment|/*&n;&t;&t; * We will use this suspect later in the loop,&n;&t;&t; * so hold onto it in the meantime.&n;&t;&t; */
id|origin_incref
c_func
(paren
id|suspect
)paren
suffix:semicolon
id|commit
op_assign
id|suspect-&gt;commit
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|commit-&gt;object.parsed
)paren
id|parse_commit
c_func
(paren
id|commit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reverse
op_logical_or
(paren
op_logical_neg
(paren
id|commit-&gt;object.flags
op_amp
id|UNINTERESTING
)paren
op_logical_and
op_logical_neg
(paren
id|revs-&gt;max_age
op_ne
l_int|1
op_logical_and
id|commit-&gt;date
OL
id|revs-&gt;max_age
)paren
)paren
)paren
id|pass_blame
c_func
(paren
id|sb
comma
id|suspect
comma
id|opt
)paren
suffix:semicolon
r_else
(brace
id|commit-&gt;object.flags
op_or_assign
id|UNINTERESTING
suffix:semicolon
r_if
c_cond
(paren
id|commit-&gt;object.parsed
)paren
id|mark_parents_uninteresting
c_func
(paren
id|commit
)paren
suffix:semicolon
)brace
multiline_comment|/* treat root commit as boundary */
r_if
c_cond
(paren
op_logical_neg
id|commit-&gt;parents
op_logical_and
op_logical_neg
id|show_root
)paren
id|commit-&gt;object.flags
op_or_assign
id|UNINTERESTING
suffix:semicolon
multiline_comment|/* Take responsibility for the remaining entries */
r_for
c_loop
(paren
id|ent
op_assign
id|sb-&gt;ent
suffix:semicolon
id|ent
suffix:semicolon
id|ent
op_assign
id|ent-&gt;next
)paren
r_if
c_cond
(paren
id|same_suspect
c_func
(paren
id|ent-&gt;suspect
comma
id|suspect
)paren
)paren
id|found_guilty_entry
c_func
(paren
id|ent
)paren
suffix:semicolon
id|origin_decref
c_func
(paren
id|suspect
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG
)paren
multiline_comment|/* sanity */
id|sanity_check_refcnt
c_func
(paren
id|sb
)paren
suffix:semicolon
)brace
)brace
DECL|function|format_time
r_static
r_const
r_char
op_star
id|format_time
c_func
(paren
r_int
r_int
id|time
comma
r_const
r_char
op_star
id|tz_str
comma
r_int
id|show_raw_time
)paren
(brace
r_static
r_char
id|time_buf
(braket
l_int|128
)braket
suffix:semicolon
id|time_t
id|t
op_assign
id|time
suffix:semicolon
r_int
id|minutes
comma
id|tz
suffix:semicolon
r_struct
id|tm
op_star
id|tm
suffix:semicolon
r_if
c_cond
(paren
id|show_raw_time
)paren
(brace
id|sprintf
c_func
(paren
id|time_buf
comma
l_string|&quot;%lu %s&quot;
comma
id|time
comma
id|tz_str
)paren
suffix:semicolon
r_return
id|time_buf
suffix:semicolon
)brace
id|tz
op_assign
id|atoi
c_func
(paren
id|tz_str
)paren
suffix:semicolon
id|minutes
op_assign
id|tz
OL
l_int|0
ques
c_cond
id|tz
suffix:colon
id|tz
suffix:semicolon
id|minutes
op_assign
(paren
id|minutes
op_div
l_int|100
)paren
op_star
l_int|60
op_plus
(paren
id|minutes
op_mod
l_int|100
)paren
suffix:semicolon
id|minutes
op_assign
id|tz
OL
l_int|0
ques
c_cond
id|minutes
suffix:colon
id|minutes
suffix:semicolon
id|t
op_assign
id|time
op_plus
id|minutes
op_star
l_int|60
suffix:semicolon
id|tm
op_assign
id|gmtime
c_func
(paren
op_amp
id|t
)paren
suffix:semicolon
id|strftime
c_func
(paren
id|time_buf
comma
r_sizeof
(paren
id|time_buf
)paren
comma
l_string|&quot;%Y-%m-%d %H:%M:%S &quot;
comma
id|tm
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|time_buf
comma
id|tz_str
)paren
suffix:semicolon
r_return
id|time_buf
suffix:semicolon
)brace
DECL|macro|OUTPUT_ANNOTATE_COMPAT
mdefine_line|#define OUTPUT_ANNOTATE_COMPAT&t;001
DECL|macro|OUTPUT_LONG_OBJECT_NAME
mdefine_line|#define OUTPUT_LONG_OBJECT_NAME&t;002
DECL|macro|OUTPUT_RAW_TIMESTAMP
mdefine_line|#define OUTPUT_RAW_TIMESTAMP&t;004
DECL|macro|OUTPUT_PORCELAIN
mdefine_line|#define OUTPUT_PORCELAIN&t;010
DECL|macro|OUTPUT_SHOW_NAME
mdefine_line|#define OUTPUT_SHOW_NAME&t;020
DECL|macro|OUTPUT_SHOW_NUMBER
mdefine_line|#define OUTPUT_SHOW_NUMBER&t;040
DECL|macro|OUTPUT_SHOW_SCORE
mdefine_line|#define OUTPUT_SHOW_SCORE      0100
DECL|macro|OUTPUT_NO_AUTHOR
mdefine_line|#define OUTPUT_NO_AUTHOR       0200
DECL|function|emit_porcelain
r_static
r_void
id|emit_porcelain
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_struct
id|blame_entry
op_star
id|ent
)paren
(brace
r_int
id|cnt
suffix:semicolon
r_const
r_char
op_star
id|cp
suffix:semicolon
r_struct
id|origin
op_star
id|suspect
op_assign
id|ent-&gt;suspect
suffix:semicolon
r_char
id|hex
(braket
l_int|41
)braket
suffix:semicolon
id|strcpy
c_func
(paren
id|hex
comma
id|sha1_to_hex
c_func
(paren
id|suspect-&gt;commit-&gt;object.sha1
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s%c%d %d %d&bslash;n&quot;
comma
id|hex
comma
id|ent-&gt;guilty
ques
c_cond
l_char|&squot; &squot;
suffix:colon
l_char|&squot;*&squot;
comma
singleline_comment|// purely for debugging
id|ent-&gt;s_lno
op_plus
l_int|1
comma
id|ent-&gt;lno
op_plus
l_int|1
comma
id|ent-&gt;num_lines
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|suspect-&gt;commit-&gt;object.flags
op_amp
id|METAINFO_SHOWN
)paren
)paren
(brace
r_struct
id|commit_info
id|ci
suffix:semicolon
id|suspect-&gt;commit-&gt;object.flags
op_or_assign
id|METAINFO_SHOWN
suffix:semicolon
id|get_commit_info
c_func
(paren
id|suspect-&gt;commit
comma
op_amp
id|ci
comma
l_int|1
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;author %s&bslash;n&quot;
comma
id|ci.author
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;author-mail %s&bslash;n&quot;
comma
id|ci.author_mail
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;author-time %lu&bslash;n&quot;
comma
id|ci.author_time
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;author-tz %s&bslash;n&quot;
comma
id|ci.author_tz
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;committer %s&bslash;n&quot;
comma
id|ci.committer
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;committer-mail %s&bslash;n&quot;
comma
id|ci.committer_mail
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;committer-time %lu&bslash;n&quot;
comma
id|ci.committer_time
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;committer-tz %s&bslash;n&quot;
comma
id|ci.committer_tz
)paren
suffix:semicolon
id|write_filename_info
c_func
(paren
id|suspect-&gt;path
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;summary %s&bslash;n&quot;
comma
id|ci.summary
)paren
suffix:semicolon
r_if
c_cond
(paren
id|suspect-&gt;commit-&gt;object.flags
op_amp
id|UNINTERESTING
)paren
id|printf
c_func
(paren
l_string|&quot;boundary&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|suspect-&gt;commit-&gt;object.flags
op_amp
id|MORE_THAN_ONE_PATH
)paren
id|write_filename_info
c_func
(paren
id|suspect-&gt;path
)paren
suffix:semicolon
id|cp
op_assign
id|nth_line
c_func
(paren
id|sb
comma
id|ent-&gt;lno
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|ent-&gt;num_lines
suffix:semicolon
id|cnt
op_increment
)paren
(brace
r_char
id|ch
suffix:semicolon
r_if
c_cond
(paren
id|cnt
)paren
id|printf
c_func
(paren
l_string|&quot;%s %d %d&bslash;n&quot;
comma
id|hex
comma
id|ent-&gt;s_lno
op_plus
l_int|1
op_plus
id|cnt
comma
id|ent-&gt;lno
op_plus
l_int|1
op_plus
id|cnt
)paren
suffix:semicolon
id|putchar
c_func
(paren
l_char|&squot;&bslash;t&squot;
)paren
suffix:semicolon
r_do
(brace
id|ch
op_assign
op_star
id|cp
op_increment
suffix:semicolon
id|putchar
c_func
(paren
id|ch
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|ch
op_ne
l_char|&squot;&bslash;n&squot;
op_logical_and
id|cp
OL
id|sb-&gt;final_buf
op_plus
id|sb-&gt;final_buf_size
)paren
suffix:semicolon
)brace
)brace
DECL|function|emit_other
r_static
r_void
id|emit_other
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_struct
id|blame_entry
op_star
id|ent
comma
r_int
id|opt
)paren
(brace
r_int
id|cnt
suffix:semicolon
r_const
r_char
op_star
id|cp
suffix:semicolon
r_struct
id|origin
op_star
id|suspect
op_assign
id|ent-&gt;suspect
suffix:semicolon
r_struct
id|commit_info
id|ci
suffix:semicolon
r_char
id|hex
(braket
l_int|41
)braket
suffix:semicolon
r_int
id|show_raw_time
op_assign
op_logical_neg
op_logical_neg
(paren
id|opt
op_amp
id|OUTPUT_RAW_TIMESTAMP
)paren
suffix:semicolon
id|get_commit_info
c_func
(paren
id|suspect-&gt;commit
comma
op_amp
id|ci
comma
l_int|1
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|hex
comma
id|sha1_to_hex
c_func
(paren
id|suspect-&gt;commit-&gt;object.sha1
)paren
)paren
suffix:semicolon
id|cp
op_assign
id|nth_line
c_func
(paren
id|sb
comma
id|ent-&gt;lno
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|ent-&gt;num_lines
suffix:semicolon
id|cnt
op_increment
)paren
(brace
r_char
id|ch
suffix:semicolon
r_int
id|length
op_assign
(paren
id|opt
op_amp
id|OUTPUT_LONG_OBJECT_NAME
)paren
ques
c_cond
l_int|40
suffix:colon
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|suspect-&gt;commit-&gt;object.flags
op_amp
id|UNINTERESTING
)paren
(brace
r_if
c_cond
(paren
id|blank_boundary
)paren
id|memset
c_func
(paren
id|hex
comma
l_char|&squot; &squot;
comma
id|length
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|cmd_is_annotate
)paren
(brace
id|length
op_decrement
suffix:semicolon
id|putchar
c_func
(paren
l_char|&squot;^&squot;
)paren
suffix:semicolon
)brace
)brace
id|printf
c_func
(paren
l_string|&quot;%.*s&quot;
comma
id|length
comma
id|hex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opt
op_amp
id|OUTPUT_ANNOTATE_COMPAT
)paren
id|printf
c_func
(paren
l_string|&quot;&bslash;t(%10s&bslash;t%10s&bslash;t%d)&quot;
comma
id|ci.author
comma
id|format_time
c_func
(paren
id|ci.author_time
comma
id|ci.author_tz
comma
id|show_raw_time
)paren
comma
id|ent-&gt;lno
op_plus
l_int|1
op_plus
id|cnt
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|opt
op_amp
id|OUTPUT_SHOW_SCORE
)paren
id|printf
c_func
(paren
l_string|&quot; %*d %02d&quot;
comma
id|max_score_digits
comma
id|ent-&gt;score
comma
id|ent-&gt;suspect-&gt;refcnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opt
op_amp
id|OUTPUT_SHOW_NAME
)paren
id|printf
c_func
(paren
l_string|&quot; %-*.*s&quot;
comma
id|longest_file
comma
id|longest_file
comma
id|suspect-&gt;path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opt
op_amp
id|OUTPUT_SHOW_NUMBER
)paren
id|printf
c_func
(paren
l_string|&quot; %*d&quot;
comma
id|max_orig_digits
comma
id|ent-&gt;s_lno
op_plus
l_int|1
op_plus
id|cnt
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|opt
op_amp
id|OUTPUT_NO_AUTHOR
)paren
)paren
id|printf
c_func
(paren
l_string|&quot; (%-*.*s %10s&quot;
comma
id|longest_author
comma
id|longest_author
comma
id|ci.author
comma
id|format_time
c_func
(paren
id|ci.author_time
comma
id|ci.author_tz
comma
id|show_raw_time
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot; %*d) &quot;
comma
id|max_digits
comma
id|ent-&gt;lno
op_plus
l_int|1
op_plus
id|cnt
)paren
suffix:semicolon
)brace
r_do
(brace
id|ch
op_assign
op_star
id|cp
op_increment
suffix:semicolon
id|putchar
c_func
(paren
id|ch
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|ch
op_ne
l_char|&squot;&bslash;n&squot;
op_logical_and
id|cp
OL
id|sb-&gt;final_buf
op_plus
id|sb-&gt;final_buf_size
)paren
suffix:semicolon
)brace
)brace
DECL|function|output
r_static
r_void
id|output
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_int
id|option
)paren
(brace
r_struct
id|blame_entry
op_star
id|ent
suffix:semicolon
r_if
c_cond
(paren
id|option
op_amp
id|OUTPUT_PORCELAIN
)paren
(brace
r_for
c_loop
(paren
id|ent
op_assign
id|sb-&gt;ent
suffix:semicolon
id|ent
suffix:semicolon
id|ent
op_assign
id|ent-&gt;next
)paren
(brace
r_struct
id|blame_entry
op_star
id|oth
suffix:semicolon
r_struct
id|origin
op_star
id|suspect
op_assign
id|ent-&gt;suspect
suffix:semicolon
r_struct
id|commit
op_star
id|commit
op_assign
id|suspect-&gt;commit
suffix:semicolon
r_if
c_cond
(paren
id|commit-&gt;object.flags
op_amp
id|MORE_THAN_ONE_PATH
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|oth
op_assign
id|ent-&gt;next
suffix:semicolon
id|oth
suffix:semicolon
id|oth
op_assign
id|oth-&gt;next
)paren
(brace
r_if
c_cond
(paren
(paren
id|oth-&gt;suspect-&gt;commit
op_ne
id|commit
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|oth-&gt;suspect-&gt;path
comma
id|suspect-&gt;path
)paren
)paren
r_continue
suffix:semicolon
id|commit-&gt;object.flags
op_or_assign
id|MORE_THAN_ONE_PATH
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_for
c_loop
(paren
id|ent
op_assign
id|sb-&gt;ent
suffix:semicolon
id|ent
suffix:semicolon
id|ent
op_assign
id|ent-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|option
op_amp
id|OUTPUT_PORCELAIN
)paren
id|emit_porcelain
c_func
(paren
id|sb
comma
id|ent
)paren
suffix:semicolon
r_else
(brace
id|emit_other
c_func
(paren
id|sb
comma
id|ent
comma
id|option
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * To allow quick access to the contents of nth line in the&n; * final image, prepare an index in the scoreboard.&n; */
DECL|function|prepare_lines
r_static
r_int
id|prepare_lines
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
)paren
(brace
r_const
r_char
op_star
id|buf
op_assign
id|sb-&gt;final_buf
suffix:semicolon
r_int
r_int
id|len
op_assign
id|sb-&gt;final_buf_size
suffix:semicolon
r_int
id|num
op_assign
l_int|0
comma
id|incomplete
op_assign
l_int|0
comma
id|bol
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|len
op_logical_and
id|buf
(braket
id|len
op_minus
l_int|1
)braket
op_ne
l_char|&squot;&bslash;n&squot;
)paren
id|incomplete
op_increment
suffix:semicolon
multiline_comment|/* incomplete line at the end */
r_while
c_loop
(paren
id|len
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|bol
)paren
(brace
id|sb-&gt;lineno
op_assign
id|xrealloc
c_func
(paren
id|sb-&gt;lineno
comma
r_sizeof
(paren
r_int
op_star
)paren
op_star
(paren
id|num
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|sb-&gt;lineno
(braket
id|num
)braket
op_assign
id|buf
id|sb-&gt;final_buf
suffix:semicolon
id|bol
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|buf
op_increment
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|num
op_increment
suffix:semicolon
id|bol
op_assign
l_int|1
suffix:semicolon
)brace
)brace
id|sb-&gt;lineno
op_assign
id|xrealloc
c_func
(paren
id|sb-&gt;lineno
comma
r_sizeof
(paren
r_int
op_star
)paren
op_star
(paren
id|num
op_plus
id|incomplete
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|sb-&gt;lineno
(braket
id|num
op_plus
id|incomplete
)braket
op_assign
id|buf
id|sb-&gt;final_buf
suffix:semicolon
id|sb-&gt;num_lines
op_assign
id|num
op_plus
id|incomplete
suffix:semicolon
r_return
id|sb-&gt;num_lines
suffix:semicolon
)brace
multiline_comment|/*&n; * Add phony grafts for use with -S; this is primarily to&n; * support git-cvsserver that wants to give a linear history&n; * to its clients.&n; */
DECL|function|read_ancestry
r_static
r_int
id|read_ancestry
c_func
(paren
r_const
r_char
op_star
id|graft_file
)paren
(brace
id|FILE
op_star
id|fp
op_assign
id|fopen
c_func
(paren
id|graft_file
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_char
id|buf
(braket
l_int|1024
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fp
)paren
r_return
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|fgets
c_func
(paren
id|buf
comma
r_sizeof
(paren
id|buf
)paren
comma
id|fp
)paren
)paren
(brace
multiline_comment|/* The format is just &quot;Commit Parent1 Parent2 ...&bslash;n&quot; */
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|buf
)paren
suffix:semicolon
r_struct
id|commit_graft
op_star
id|graft
op_assign
id|read_graft_line
c_func
(paren
id|buf
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|graft
)paren
id|register_commit_graft
c_func
(paren
id|graft
comma
l_int|0
)paren
suffix:semicolon
)brace
id|fclose
c_func
(paren
id|fp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * How many columns do we need to show line numbers in decimal?&n; */
DECL|function|lineno_width
r_static
r_int
id|lineno_width
c_func
(paren
r_int
id|lines
)paren
(brace
r_int
id|i
comma
id|width
suffix:semicolon
r_for
c_loop
(paren
id|width
op_assign
l_int|1
comma
id|i
op_assign
l_int|10
suffix:semicolon
id|i
op_le
id|lines
op_plus
l_int|1
suffix:semicolon
id|width
op_increment
)paren
id|i
op_mul_assign
l_int|10
suffix:semicolon
r_return
id|width
suffix:semicolon
)brace
multiline_comment|/*&n; * How many columns do we need to show line numbers, authors,&n; * and filenames?&n; */
DECL|function|find_alignment
r_static
r_void
id|find_alignment
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_int
op_star
id|option
)paren
(brace
r_int
id|longest_src_lines
op_assign
l_int|0
suffix:semicolon
r_int
id|longest_dst_lines
op_assign
l_int|0
suffix:semicolon
r_int
id|largest_score
op_assign
l_int|0
suffix:semicolon
r_struct
id|blame_entry
op_star
id|e
suffix:semicolon
r_for
c_loop
(paren
id|e
op_assign
id|sb-&gt;ent
suffix:semicolon
id|e
suffix:semicolon
id|e
op_assign
id|e-&gt;next
)paren
(brace
r_struct
id|origin
op_star
id|suspect
op_assign
id|e-&gt;suspect
suffix:semicolon
r_struct
id|commit_info
id|ci
suffix:semicolon
r_int
id|num
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|suspect-&gt;path
comma
id|sb-&gt;path
)paren
)paren
op_star
id|option
op_or_assign
id|OUTPUT_SHOW_NAME
suffix:semicolon
id|num
op_assign
id|strlen
c_func
(paren
id|suspect-&gt;path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|longest_file
OL
id|num
)paren
id|longest_file
op_assign
id|num
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|suspect-&gt;commit-&gt;object.flags
op_amp
id|METAINFO_SHOWN
)paren
)paren
(brace
id|suspect-&gt;commit-&gt;object.flags
op_or_assign
id|METAINFO_SHOWN
suffix:semicolon
id|get_commit_info
c_func
(paren
id|suspect-&gt;commit
comma
op_amp
id|ci
comma
l_int|1
)paren
suffix:semicolon
id|num
op_assign
id|strlen
c_func
(paren
id|ci.author
)paren
suffix:semicolon
r_if
c_cond
(paren
id|longest_author
OL
id|num
)paren
id|longest_author
op_assign
id|num
suffix:semicolon
)brace
id|num
op_assign
id|e-&gt;s_lno
op_plus
id|e-&gt;num_lines
suffix:semicolon
r_if
c_cond
(paren
id|longest_src_lines
OL
id|num
)paren
id|longest_src_lines
op_assign
id|num
suffix:semicolon
id|num
op_assign
id|e-&gt;lno
op_plus
id|e-&gt;num_lines
suffix:semicolon
r_if
c_cond
(paren
id|longest_dst_lines
OL
id|num
)paren
id|longest_dst_lines
op_assign
id|num
suffix:semicolon
r_if
c_cond
(paren
id|largest_score
OL
id|ent_score
c_func
(paren
id|sb
comma
id|e
)paren
)paren
id|largest_score
op_assign
id|ent_score
c_func
(paren
id|sb
comma
id|e
)paren
suffix:semicolon
)brace
id|max_orig_digits
op_assign
id|lineno_width
c_func
(paren
id|longest_src_lines
)paren
suffix:semicolon
id|max_digits
op_assign
id|lineno_width
c_func
(paren
id|longest_dst_lines
)paren
suffix:semicolon
id|max_score_digits
op_assign
id|lineno_width
c_func
(paren
id|largest_score
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * For debugging -- origin is refcounted, and this asserts that&n; * we do not underflow.&n; */
DECL|function|sanity_check_refcnt
r_static
r_void
id|sanity_check_refcnt
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
)paren
(brace
r_int
id|baa
op_assign
l_int|0
suffix:semicolon
r_struct
id|blame_entry
op_star
id|ent
suffix:semicolon
r_for
c_loop
(paren
id|ent
op_assign
id|sb-&gt;ent
suffix:semicolon
id|ent
suffix:semicolon
id|ent
op_assign
id|ent-&gt;next
)paren
(brace
multiline_comment|/* Nobody should have zero or negative refcnt */
r_if
c_cond
(paren
id|ent-&gt;suspect-&gt;refcnt
op_le
l_int|0
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s in %s has negative refcnt %d&bslash;n&quot;
comma
id|ent-&gt;suspect-&gt;path
comma
id|sha1_to_hex
c_func
(paren
id|ent-&gt;suspect-&gt;commit-&gt;object.sha1
)paren
comma
id|ent-&gt;suspect-&gt;refcnt
)paren
suffix:semicolon
id|baa
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|ent
op_assign
id|sb-&gt;ent
suffix:semicolon
id|ent
suffix:semicolon
id|ent
op_assign
id|ent-&gt;next
)paren
(brace
multiline_comment|/* Mark the ones that haven&squot;t been checked */
r_if
c_cond
(paren
l_int|0
OL
id|ent-&gt;suspect-&gt;refcnt
)paren
id|ent-&gt;suspect-&gt;refcnt
op_assign
id|ent-&gt;suspect-&gt;refcnt
suffix:semicolon
)brace
r_for
c_loop
(paren
id|ent
op_assign
id|sb-&gt;ent
suffix:semicolon
id|ent
suffix:semicolon
id|ent
op_assign
id|ent-&gt;next
)paren
(brace
multiline_comment|/*&n;&t;&t; * ... then pick each and see if they have the the&n;&t;&t; * correct refcnt.&n;&t;&t; */
r_int
id|found
suffix:semicolon
r_struct
id|blame_entry
op_star
id|e
suffix:semicolon
r_struct
id|origin
op_star
id|suspect
op_assign
id|ent-&gt;suspect
suffix:semicolon
r_if
c_cond
(paren
l_int|0
OL
id|suspect-&gt;refcnt
)paren
r_continue
suffix:semicolon
id|suspect-&gt;refcnt
op_assign
id|suspect-&gt;refcnt
suffix:semicolon
multiline_comment|/* Unmark */
r_for
c_loop
(paren
id|found
op_assign
l_int|0
comma
id|e
op_assign
id|sb-&gt;ent
suffix:semicolon
id|e
suffix:semicolon
id|e
op_assign
id|e-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|e-&gt;suspect
op_ne
id|suspect
)paren
r_continue
suffix:semicolon
id|found
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|suspect-&gt;refcnt
op_ne
id|found
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s in %s has refcnt %d, not %d&bslash;n&quot;
comma
id|ent-&gt;suspect-&gt;path
comma
id|sha1_to_hex
c_func
(paren
id|ent-&gt;suspect-&gt;commit-&gt;object.sha1
)paren
comma
id|ent-&gt;suspect-&gt;refcnt
comma
id|found
)paren
suffix:semicolon
id|baa
op_assign
l_int|2
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|baa
)paren
(brace
r_int
id|opt
op_assign
l_int|0160
suffix:semicolon
id|find_alignment
c_func
(paren
id|sb
comma
op_amp
id|opt
)paren
suffix:semicolon
id|output
c_func
(paren
id|sb
comma
id|opt
)paren
suffix:semicolon
id|die
c_func
(paren
l_string|&quot;Baa %d!&quot;
comma
id|baa
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Used for the command line parsing; check if the path exists&n; * in the working tree.&n; */
DECL|function|has_string_in_work_tree
r_static
r_int
id|has_string_in_work_tree
c_func
(paren
r_const
r_char
op_star
id|path
)paren
(brace
r_struct
id|stat
id|st
suffix:semicolon
r_return
op_logical_neg
id|lstat
c_func
(paren
id|path
comma
op_amp
id|st
)paren
suffix:semicolon
)brace
DECL|function|parse_score
r_static
r_int
id|parse_score
c_func
(paren
r_const
r_char
op_star
id|arg
)paren
(brace
r_char
op_star
id|end
suffix:semicolon
r_int
r_int
id|score
op_assign
id|strtoul
c_func
(paren
id|arg
comma
op_amp
id|end
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|end
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|score
suffix:semicolon
)brace
DECL|function|add_prefix
r_static
r_const
r_char
op_star
id|add_prefix
c_func
(paren
r_const
r_char
op_star
id|prefix
comma
r_const
r_char
op_star
id|path
)paren
(brace
r_return
id|prefix_path
c_func
(paren
id|prefix
comma
id|prefix
ques
c_cond
id|strlen
c_func
(paren
id|prefix
)paren
suffix:colon
l_int|0
comma
id|path
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Parsing of (comma separated) one item in the -L option&n; */
DECL|function|parse_loc
r_static
r_const
r_char
op_star
id|parse_loc
c_func
(paren
r_const
r_char
op_star
id|spec
comma
r_struct
id|scoreboard
op_star
id|sb
comma
r_int
id|lno
comma
r_int
id|begin
comma
r_int
op_star
id|ret
)paren
(brace
r_char
op_star
id|term
suffix:semicolon
r_const
r_char
op_star
id|line
suffix:semicolon
r_int
id|num
suffix:semicolon
r_int
id|reg_error
suffix:semicolon
id|regex_t
id|regexp
suffix:semicolon
id|regmatch_t
id|match
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* Allow &quot;-L &lt;something&gt;,+20&quot; to mean starting at &lt;something&gt;&n;&t; * for 20 lines, or &quot;-L &lt;something&gt;,-5&quot; for 5 lines ending at&n;&t; * &lt;something&gt;.&n;&t; */
r_if
c_cond
(paren
l_int|1
OL
id|begin
op_logical_and
(paren
id|spec
(braket
l_int|0
)braket
op_eq
l_char|&squot;+&squot;
op_logical_or
id|spec
(braket
l_int|0
)braket
op_eq
l_char|&squot;-&squot;
)paren
)paren
(brace
id|num
op_assign
id|strtol
c_func
(paren
id|spec
op_plus
l_int|1
comma
op_amp
id|term
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|term
op_ne
id|spec
op_plus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|spec
(braket
l_int|0
)braket
op_eq
l_char|&squot;-&squot;
)paren
id|num
op_assign
l_int|0
id|num
suffix:semicolon
r_if
c_cond
(paren
l_int|0
OL
id|num
)paren
op_star
id|ret
op_assign
id|begin
op_plus
id|num
l_int|2
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|num
)paren
op_star
id|ret
op_assign
id|begin
suffix:semicolon
r_else
op_star
id|ret
op_assign
id|begin
op_plus
id|num
suffix:semicolon
r_return
id|term
suffix:semicolon
)brace
r_return
id|spec
suffix:semicolon
)brace
id|num
op_assign
id|strtol
c_func
(paren
id|spec
comma
op_amp
id|term
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|term
op_ne
id|spec
)paren
(brace
op_star
id|ret
op_assign
id|num
suffix:semicolon
r_return
id|term
suffix:semicolon
)brace
r_if
c_cond
(paren
id|spec
(braket
l_int|0
)braket
op_ne
l_char|&squot;/&squot;
)paren
r_return
id|spec
suffix:semicolon
multiline_comment|/* it could be a regexp of form /.../ */
r_for
c_loop
(paren
id|term
op_assign
(paren
r_char
op_star
)paren
id|spec
op_plus
l_int|1
suffix:semicolon
op_star
id|term
op_logical_and
op_star
id|term
op_ne
l_char|&squot;/&squot;
suffix:semicolon
id|term
op_increment
)paren
(brace
r_if
c_cond
(paren
op_star
id|term
op_eq
l_char|&squot;&bslash;&bslash;&squot;
)paren
id|term
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|term
op_ne
l_char|&squot;/&squot;
)paren
r_return
id|spec
suffix:semicolon
multiline_comment|/* try [spec+1 .. term-1] as regexp */
op_star
id|term
op_assign
l_int|0
suffix:semicolon
id|begin
op_decrement
suffix:semicolon
multiline_comment|/* input is in human terms */
id|line
op_assign
id|nth_line
c_func
(paren
id|sb
comma
id|begin
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|reg_error
op_assign
id|regcomp
c_func
(paren
op_amp
id|regexp
comma
id|spec
op_plus
l_int|1
comma
id|REG_NEWLINE
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|reg_error
op_assign
id|regexec
c_func
(paren
op_amp
id|regexp
comma
id|line
comma
l_int|1
comma
id|match
comma
l_int|0
)paren
)paren
)paren
(brace
r_const
r_char
op_star
id|cp
op_assign
id|line
op_plus
id|match
(braket
l_int|0
)braket
dot
id|rm_so
suffix:semicolon
r_const
r_char
op_star
id|nline
suffix:semicolon
r_while
c_loop
(paren
id|begin
op_increment
OL
id|lno
)paren
(brace
id|nline
op_assign
id|nth_line
c_func
(paren
id|sb
comma
id|begin
)paren
suffix:semicolon
r_if
c_cond
(paren
id|line
op_le
id|cp
op_logical_and
id|cp
OL
id|nline
)paren
r_break
suffix:semicolon
id|line
op_assign
id|nline
suffix:semicolon
)brace
op_star
id|ret
op_assign
id|begin
suffix:semicolon
id|regfree
c_func
(paren
op_amp
id|regexp
)paren
suffix:semicolon
op_star
id|term
op_increment
op_assign
l_char|&squot;/&squot;
suffix:semicolon
r_return
id|term
suffix:semicolon
)brace
r_else
(brace
r_char
id|errbuf
(braket
l_int|1024
)braket
suffix:semicolon
id|regerror
c_func
(paren
id|reg_error
comma
op_amp
id|regexp
comma
id|errbuf
comma
l_int|1024
)paren
suffix:semicolon
id|die
c_func
(paren
l_string|&quot;-L parameter &squot;%s&squot;: %s&quot;
comma
id|spec
op_plus
l_int|1
comma
id|errbuf
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Parsing of -L option&n; */
DECL|function|prepare_blame_range
r_static
r_void
id|prepare_blame_range
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_const
r_char
op_star
id|bottomtop
comma
r_int
id|lno
comma
r_int
op_star
id|bottom
comma
r_int
op_star
id|top
)paren
(brace
r_const
r_char
op_star
id|term
suffix:semicolon
id|term
op_assign
id|parse_loc
c_func
(paren
id|bottomtop
comma
id|sb
comma
id|lno
comma
l_int|1
comma
id|bottom
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|term
op_eq
l_char|&squot;,&squot;
)paren
(brace
id|term
op_assign
id|parse_loc
c_func
(paren
id|term
op_plus
l_int|1
comma
id|sb
comma
id|lno
comma
op_star
id|bottom
op_plus
l_int|1
comma
id|top
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|term
)paren
id|usage
c_func
(paren
id|blame_usage
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|term
)paren
id|usage
c_func
(paren
id|blame_usage
)paren
suffix:semicolon
)brace
DECL|function|git_blame_config
r_static
r_int
id|git_blame_config
c_func
(paren
r_const
r_char
op_star
id|var
comma
r_const
r_char
op_star
id|value
comma
r_void
op_star
id|cb
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;blame.showroot&quot;
)paren
)paren
(brace
id|show_root
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;blame.blankboundary&quot;
)paren
)paren
(brace
id|blank_boundary
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|git_default_config
c_func
(paren
id|var
comma
id|value
comma
id|cb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Prepare a dummy commit that represents the work tree (or staged) item.&n; * Note that annotating work tree item never works in the reverse.&n; */
DECL|function|fake_working_tree_commit
r_static
r_struct
id|commit
op_star
id|fake_working_tree_commit
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_const
r_char
op_star
id|contents_from
)paren
(brace
r_struct
id|commit
op_star
id|commit
suffix:semicolon
r_struct
id|origin
op_star
id|origin
suffix:semicolon
r_int
r_char
id|head_sha1
(braket
l_int|20
)braket
suffix:semicolon
r_struct
id|strbuf
id|buf
suffix:semicolon
r_const
r_char
op_star
id|ident
suffix:semicolon
id|time_t
id|now
suffix:semicolon
r_int
id|size
comma
id|len
suffix:semicolon
r_struct
id|cache_entry
op_star
id|ce
suffix:semicolon
r_int
id|mode
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|head_sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;No such ref: HEAD&quot;
)paren
suffix:semicolon
id|time
c_func
(paren
op_amp
id|now
)paren
suffix:semicolon
id|commit
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|commit
)paren
)paren
suffix:semicolon
id|commit-&gt;parents
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|commit-&gt;parents
)paren
)paren
suffix:semicolon
id|commit-&gt;parents-&gt;item
op_assign
id|lookup_commit_reference
c_func
(paren
id|head_sha1
)paren
suffix:semicolon
id|commit-&gt;object.parsed
op_assign
l_int|1
suffix:semicolon
id|commit-&gt;date
op_assign
id|now
suffix:semicolon
id|commit-&gt;object.type
op_assign
id|OBJ_COMMIT
suffix:semicolon
id|origin
op_assign
id|make_origin
c_func
(paren
id|commit
comma
id|path
)paren
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|buf
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|contents_from
op_logical_or
id|strcmp
c_func
(paren
l_string|&quot;-&quot;
comma
id|contents_from
)paren
)paren
(brace
r_struct
id|stat
id|st
suffix:semicolon
r_const
r_char
op_star
id|read_from
suffix:semicolon
r_int
r_int
id|fin_size
suffix:semicolon
r_if
c_cond
(paren
id|contents_from
)paren
(brace
r_if
c_cond
(paren
id|stat
c_func
(paren
id|contents_from
comma
op_amp
id|st
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;Cannot stat %s&quot;
comma
id|contents_from
)paren
suffix:semicolon
id|read_from
op_assign
id|contents_from
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|lstat
c_func
(paren
id|path
comma
op_amp
id|st
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;Cannot lstat %s&quot;
comma
id|path
)paren
suffix:semicolon
id|read_from
op_assign
id|path
suffix:semicolon
)brace
id|fin_size
op_assign
id|xsize_t
c_func
(paren
id|st.st_size
)paren
suffix:semicolon
id|mode
op_assign
id|canon_mode
c_func
(paren
id|st.st_mode
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|st.st_mode
op_amp
id|S_IFMT
)paren
(brace
r_case
id|S_IFREG
suffix:colon
r_if
c_cond
(paren
id|strbuf_read_file
c_func
(paren
op_amp
id|buf
comma
id|read_from
comma
id|st.st_size
)paren
op_ne
id|st.st_size
)paren
id|die
c_func
(paren
l_string|&quot;cannot open or read %s&quot;
comma
id|read_from
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_IFLNK
suffix:colon
r_if
c_cond
(paren
id|readlink
c_func
(paren
id|read_from
comma
id|buf.buf
comma
id|buf.alloc
)paren
op_ne
id|fin_size
)paren
id|die
c_func
(paren
l_string|&quot;cannot readlink %s&quot;
comma
id|read_from
)paren
suffix:semicolon
id|buf.len
op_assign
id|fin_size
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|die
c_func
(paren
l_string|&quot;unsupported file type %s&quot;
comma
id|read_from
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Reading from stdin */
id|contents_from
op_assign
l_string|&quot;standard input&quot;
suffix:semicolon
id|mode
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|strbuf_read
c_func
(paren
op_amp
id|buf
comma
l_int|0
comma
l_int|0
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;read error %s from stdin&quot;
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
)brace
id|convert_to_git
c_func
(paren
id|path
comma
id|buf.buf
comma
id|buf.len
comma
op_amp
id|buf
comma
l_int|0
)paren
suffix:semicolon
id|origin-&gt;file.ptr
op_assign
id|buf.buf
suffix:semicolon
id|origin-&gt;file.size
op_assign
id|buf.len
suffix:semicolon
id|pretend_sha1_file
c_func
(paren
id|buf.buf
comma
id|buf.len
comma
id|OBJ_BLOB
comma
id|origin-&gt;blob_sha1
)paren
suffix:semicolon
id|commit-&gt;util
op_assign
id|origin
suffix:semicolon
multiline_comment|/*&n;&t; * Read the current index, replace the path entry with&n;&t; * origin-&gt;blob_sha1 without mucking with its mode or type&n;&t; * bits; we are not going to write this index out -- we just&n;&t; * want to run &quot;diff-index --cached&quot;.&n;&t; */
id|discard_cache
c_func
(paren
)paren
suffix:semicolon
id|read_cache
c_func
(paren
)paren
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mode
)paren
(brace
r_int
id|pos
op_assign
id|cache_name_pos
c_func
(paren
id|path
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_le
id|pos
)paren
id|mode
op_assign
id|active_cache
(braket
id|pos
)braket
op_member_access_from_pointer
id|ce_mode
suffix:semicolon
r_else
multiline_comment|/* Let&squot;s not bother reading from HEAD tree */
id|mode
op_assign
id|S_IFREG
op_or
l_int|0644
suffix:semicolon
)brace
id|size
op_assign
id|cache_entry_size
c_func
(paren
id|len
)paren
suffix:semicolon
id|ce
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
id|size
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|ce-&gt;sha1
comma
id|origin-&gt;blob_sha1
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ce-&gt;name
comma
id|path
comma
id|len
)paren
suffix:semicolon
id|ce-&gt;ce_flags
op_assign
id|create_ce_flags
c_func
(paren
id|len
comma
l_int|0
)paren
suffix:semicolon
id|ce-&gt;ce_mode
op_assign
id|create_ce_mode
c_func
(paren
id|mode
)paren
suffix:semicolon
id|add_cache_entry
c_func
(paren
id|ce
comma
id|ADD_CACHE_OK_TO_ADD
op_or
id|ADD_CACHE_OK_TO_REPLACE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We are not going to write this out, so this does not matter&n;&t; * right now, but someday we might optimize diff-index --cached&n;&t; * with cache-tree information.&n;&t; */
id|cache_tree_invalidate_path
c_func
(paren
id|active_cache_tree
comma
id|path
)paren
suffix:semicolon
id|commit-&gt;buffer
op_assign
id|xmalloc
c_func
(paren
l_int|400
)paren
suffix:semicolon
id|ident
op_assign
id|fmt_ident
c_func
(paren
l_string|&quot;Not Committed Yet&quot;
comma
l_string|&quot;not.committed.yet&quot;
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|snprintf
c_func
(paren
id|commit-&gt;buffer
comma
l_int|400
comma
l_string|&quot;tree 0000000000000000000000000000000000000000&bslash;n&quot;
l_string|&quot;parent %s&bslash;n&quot;
l_string|&quot;author %s&bslash;n&quot;
l_string|&quot;committer %s&bslash;n&bslash;n&quot;
l_string|&quot;Version of %s from %s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|head_sha1
)paren
comma
id|ident
comma
id|ident
comma
id|path
comma
id|contents_from
ques
c_cond
id|contents_from
suffix:colon
id|path
)paren
suffix:semicolon
r_return
id|commit
suffix:semicolon
)brace
DECL|function|prepare_final
r_static
r_const
r_char
op_star
id|prepare_final
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
)paren
(brace
r_int
id|i
suffix:semicolon
r_const
r_char
op_star
id|final_commit_name
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|rev_info
op_star
id|revs
op_assign
id|sb-&gt;revs
suffix:semicolon
multiline_comment|/*&n;&t; * There must be one and only one positive commit in the&n;&t; * revs-&gt;pending array.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|revs-&gt;pending.nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|object
op_star
id|obj
op_assign
id|revs-&gt;pending.objects
(braket
id|i
)braket
dot
id|item
suffix:semicolon
r_if
c_cond
(paren
id|obj-&gt;flags
op_amp
id|UNINTERESTING
)paren
r_continue
suffix:semicolon
r_while
c_loop
(paren
id|obj-&gt;type
op_eq
id|OBJ_TAG
)paren
id|obj
op_assign
id|deref_tag
c_func
(paren
id|obj
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|obj-&gt;type
op_ne
id|OBJ_COMMIT
)paren
id|die
c_func
(paren
l_string|&quot;Non commit %s?&quot;
comma
id|revs-&gt;pending.objects
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;final
)paren
id|die
c_func
(paren
l_string|&quot;More than one commit to dig from %s and %s?&quot;
comma
id|revs-&gt;pending.objects
(braket
id|i
)braket
dot
id|name
comma
id|final_commit_name
)paren
suffix:semicolon
id|sb-&gt;final
op_assign
(paren
r_struct
id|commit
op_star
)paren
id|obj
suffix:semicolon
id|final_commit_name
op_assign
id|revs-&gt;pending.objects
(braket
id|i
)braket
dot
id|name
suffix:semicolon
)brace
r_return
id|final_commit_name
suffix:semicolon
)brace
DECL|function|prepare_initial
r_static
r_const
r_char
op_star
id|prepare_initial
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
)paren
(brace
r_int
id|i
suffix:semicolon
r_const
r_char
op_star
id|final_commit_name
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|rev_info
op_star
id|revs
op_assign
id|sb-&gt;revs
suffix:semicolon
multiline_comment|/*&n;&t; * There must be one and only one negative commit, and it must be&n;&t; * the boundary.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|revs-&gt;pending.nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|object
op_star
id|obj
op_assign
id|revs-&gt;pending.objects
(braket
id|i
)braket
dot
id|item
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|obj-&gt;flags
op_amp
id|UNINTERESTING
)paren
)paren
r_continue
suffix:semicolon
r_while
c_loop
(paren
id|obj-&gt;type
op_eq
id|OBJ_TAG
)paren
id|obj
op_assign
id|deref_tag
c_func
(paren
id|obj
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|obj-&gt;type
op_ne
id|OBJ_COMMIT
)paren
id|die
c_func
(paren
l_string|&quot;Non commit %s?&quot;
comma
id|revs-&gt;pending.objects
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;final
)paren
id|die
c_func
(paren
l_string|&quot;More than one commit to dig down to %s and %s?&quot;
comma
id|revs-&gt;pending.objects
(braket
id|i
)braket
dot
id|name
comma
id|final_commit_name
)paren
suffix:semicolon
id|sb-&gt;final
op_assign
(paren
r_struct
id|commit
op_star
)paren
id|obj
suffix:semicolon
id|final_commit_name
op_assign
id|revs-&gt;pending.objects
(braket
id|i
)braket
dot
id|name
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|final_commit_name
)paren
id|die
c_func
(paren
l_string|&quot;No commit to dig down to?&quot;
)paren
suffix:semicolon
r_return
id|final_commit_name
suffix:semicolon
)brace
DECL|function|blame_copy_callback
r_static
r_int
id|blame_copy_callback
c_func
(paren
r_const
r_struct
id|option
op_star
id|option
comma
r_const
r_char
op_star
id|arg
comma
r_int
id|unset
)paren
(brace
r_int
op_star
id|opt
op_assign
id|option-&gt;value
suffix:semicolon
multiline_comment|/*&n;&t; * -C enables copy from removed files;&n;&t; * -C -C enables copy from existing files, but only&n;&t; *       when blaming a new file;&n;&t; * -C -C -C enables copy from existing files for&n;&t; *          everybody&n;&t; */
r_if
c_cond
(paren
op_star
id|opt
op_amp
id|PICKAXE_BLAME_COPY_HARDER
)paren
op_star
id|opt
op_or_assign
id|PICKAXE_BLAME_COPY_HARDEST
suffix:semicolon
r_if
c_cond
(paren
op_star
id|opt
op_amp
id|PICKAXE_BLAME_COPY
)paren
op_star
id|opt
op_or_assign
id|PICKAXE_BLAME_COPY_HARDER
suffix:semicolon
op_star
id|opt
op_or_assign
id|PICKAXE_BLAME_COPY
op_or
id|PICKAXE_BLAME_MOVE
suffix:semicolon
r_if
c_cond
(paren
id|arg
)paren
id|blame_copy_score
op_assign
id|parse_score
c_func
(paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|blame_move_callback
r_static
r_int
id|blame_move_callback
c_func
(paren
r_const
r_struct
id|option
op_star
id|option
comma
r_const
r_char
op_star
id|arg
comma
r_int
id|unset
)paren
(brace
r_int
op_star
id|opt
op_assign
id|option-&gt;value
suffix:semicolon
op_star
id|opt
op_or_assign
id|PICKAXE_BLAME_MOVE
suffix:semicolon
r_if
c_cond
(paren
id|arg
)paren
id|blame_move_score
op_assign
id|parse_score
c_func
(paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|blame_bottomtop_callback
r_static
r_int
id|blame_bottomtop_callback
c_func
(paren
r_const
r_struct
id|option
op_star
id|option
comma
r_const
r_char
op_star
id|arg
comma
r_int
id|unset
)paren
(brace
r_const
r_char
op_star
op_star
id|bottomtop
op_assign
id|option-&gt;value
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_star
id|bottomtop
)paren
id|die
c_func
(paren
l_string|&quot;More than one &squot;-L n,m&squot; option given&quot;
)paren
suffix:semicolon
op_star
id|bottomtop
op_assign
id|arg
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cmd_blame
r_int
id|cmd_blame
c_func
(paren
r_int
id|argc
comma
r_const
r_char
op_star
op_star
id|argv
comma
r_const
r_char
op_star
id|prefix
)paren
(brace
r_struct
id|rev_info
id|revs
suffix:semicolon
r_const
r_char
op_star
id|path
suffix:semicolon
r_struct
id|scoreboard
id|sb
suffix:semicolon
r_struct
id|origin
op_star
id|o
suffix:semicolon
r_struct
id|blame_entry
op_star
id|ent
suffix:semicolon
r_int
id|dashdash_pos
comma
id|bottom
comma
id|top
comma
id|lno
suffix:semicolon
r_const
r_char
op_star
id|final_commit_name
op_assign
l_int|NULL
suffix:semicolon
r_enum
id|object_type
id|type
suffix:semicolon
r_static
r_const
r_char
op_star
id|bottomtop
op_assign
l_int|NULL
suffix:semicolon
r_static
r_int
id|output_option
op_assign
l_int|0
comma
id|opt
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|show_stats
op_assign
l_int|0
suffix:semicolon
r_static
r_const
r_char
op_star
id|revs_file
op_assign
l_int|NULL
suffix:semicolon
r_static
r_const
r_char
op_star
id|contents_from
op_assign
l_int|NULL
suffix:semicolon
r_static
r_const
r_struct
id|option
id|options
(braket
)braket
op_assign
(brace
id|OPT_BOOLEAN
c_func
(paren
l_int|0
comma
l_string|&quot;incremental&quot;
comma
op_amp
id|incremental
comma
l_string|&quot;Show blame entries as we find them, incrementally&quot;
)paren
comma
id|OPT_BOOLEAN
c_func
(paren
l_char|&squot;b&squot;
comma
l_int|NULL
comma
op_amp
id|blank_boundary
comma
l_string|&quot;Show blank SHA-1 for boundary commits (Default: off)&quot;
)paren
comma
id|OPT_BOOLEAN
c_func
(paren
l_int|0
comma
l_string|&quot;root&quot;
comma
op_amp
id|show_root
comma
l_string|&quot;Do not treat root commits as boundaries (Default: off)&quot;
)paren
comma
id|OPT_BOOLEAN
c_func
(paren
l_int|0
comma
l_string|&quot;show-stats&quot;
comma
op_amp
id|show_stats
comma
l_string|&quot;Show work cost statistics&quot;
)paren
comma
id|OPT_BIT
c_func
(paren
l_int|0
comma
l_string|&quot;score-debug&quot;
comma
op_amp
id|output_option
comma
l_string|&quot;Show output score for blame entries&quot;
comma
id|OUTPUT_SHOW_SCORE
)paren
comma
id|OPT_BIT
c_func
(paren
l_char|&squot;f&squot;
comma
l_string|&quot;show-name&quot;
comma
op_amp
id|output_option
comma
l_string|&quot;Show original filename (Default: auto)&quot;
comma
id|OUTPUT_SHOW_NAME
)paren
comma
id|OPT_BIT
c_func
(paren
l_char|&squot;n&squot;
comma
l_string|&quot;show-number&quot;
comma
op_amp
id|output_option
comma
l_string|&quot;Show original linenumber (Default: off)&quot;
comma
id|OUTPUT_SHOW_NUMBER
)paren
comma
id|OPT_BIT
c_func
(paren
l_char|&squot;p&squot;
comma
l_string|&quot;porcelain&quot;
comma
op_amp
id|output_option
comma
l_string|&quot;Show in a format designed for machine consumption&quot;
comma
id|OUTPUT_PORCELAIN
)paren
comma
id|OPT_BIT
c_func
(paren
l_char|&squot;c&squot;
comma
l_int|NULL
comma
op_amp
id|output_option
comma
l_string|&quot;Use the same output mode as git-annotate (Default: off)&quot;
comma
id|OUTPUT_ANNOTATE_COMPAT
)paren
comma
id|OPT_BIT
c_func
(paren
l_char|&squot;t&squot;
comma
l_int|NULL
comma
op_amp
id|output_option
comma
l_string|&quot;Show raw timestamp (Default: off)&quot;
comma
id|OUTPUT_RAW_TIMESTAMP
)paren
comma
id|OPT_BIT
c_func
(paren
l_char|&squot;l&squot;
comma
l_int|NULL
comma
op_amp
id|output_option
comma
l_string|&quot;Show long commit SHA1 (Default: off)&quot;
comma
id|OUTPUT_LONG_OBJECT_NAME
)paren
comma
id|OPT_BIT
c_func
(paren
l_char|&squot;s&squot;
comma
l_int|NULL
comma
op_amp
id|output_option
comma
l_string|&quot;Suppress author name and timestamp (Default: off)&quot;
comma
id|OUTPUT_NO_AUTHOR
)paren
comma
id|OPT_BIT
c_func
(paren
l_char|&squot;w&squot;
comma
l_int|NULL
comma
op_amp
id|xdl_opts
comma
l_string|&quot;Ignore whitespace differences&quot;
comma
id|XDF_IGNORE_WHITESPACE
)paren
comma
id|OPT_STRING
c_func
(paren
l_char|&squot;S&squot;
comma
l_int|NULL
comma
op_amp
id|revs_file
comma
l_string|&quot;file&quot;
comma
l_string|&quot;Use revisions from &lt;file&gt; instead of calling git-rev-list&quot;
)paren
comma
id|OPT_STRING
c_func
(paren
l_int|0
comma
l_string|&quot;contents&quot;
comma
op_amp
id|contents_from
comma
l_string|&quot;file&quot;
comma
l_string|&quot;Use &lt;file&gt;&squot;s contents as the final image&quot;
)paren
comma
(brace
id|OPTION_CALLBACK
comma
l_char|&squot;C&squot;
comma
l_int|NULL
comma
op_amp
id|opt
comma
l_string|&quot;score&quot;
comma
l_string|&quot;Find line copies within and across files&quot;
comma
id|PARSE_OPT_OPTARG
comma
id|blame_copy_callback
)brace
comma
(brace
id|OPTION_CALLBACK
comma
l_char|&squot;M&squot;
comma
l_int|NULL
comma
op_amp
id|opt
comma
l_string|&quot;score&quot;
comma
l_string|&quot;Find line movements within and across files&quot;
comma
id|PARSE_OPT_OPTARG
comma
id|blame_move_callback
)brace
comma
id|OPT_CALLBACK
c_func
(paren
l_char|&squot;L&squot;
comma
l_int|NULL
comma
op_amp
id|bottomtop
comma
l_string|&quot;n,m&quot;
comma
l_string|&quot;Process only line range n,m, counting from 1&quot;
comma
id|blame_bottomtop_callback
)paren
comma
id|OPT_END
c_func
(paren
)paren
)brace
suffix:semicolon
r_struct
id|parse_opt_ctx_t
id|ctx
suffix:semicolon
id|cmd_is_annotate
op_assign
op_logical_neg
id|strcmp
c_func
(paren
id|argv
(braket
l_int|0
)braket
comma
l_string|&quot;annotate&quot;
)paren
suffix:semicolon
id|git_config
c_func
(paren
id|git_blame_config
comma
l_int|NULL
)paren
suffix:semicolon
id|init_revisions
c_func
(paren
op_amp
id|revs
comma
l_int|NULL
)paren
suffix:semicolon
id|save_commit_buffer
op_assign
l_int|0
suffix:semicolon
id|dashdash_pos
op_assign
l_int|0
suffix:semicolon
id|parse_options_start
c_func
(paren
op_amp
id|ctx
comma
id|argc
comma
id|argv
comma
id|PARSE_OPT_KEEP_DASHDASH
op_or
id|PARSE_OPT_KEEP_ARGV0
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_switch
c_cond
(paren
id|parse_options_step
c_func
(paren
op_amp
id|ctx
comma
id|options
comma
id|blame_opt_usage
)paren
)paren
(brace
r_case
id|PARSE_OPT_HELP
suffix:colon
m_exit
(paren
l_int|129
)paren
suffix:semicolon
r_case
id|PARSE_OPT_DONE
suffix:colon
r_if
c_cond
(paren
id|ctx.argv
(braket
l_int|0
)braket
)paren
id|dashdash_pos
op_assign
id|ctx.cpidx
suffix:semicolon
r_goto
id|parse_done
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|ctx.argv
(braket
l_int|0
)braket
comma
l_string|&quot;--reverse&quot;
)paren
)paren
(brace
id|ctx.argv
(braket
l_int|0
)braket
op_assign
l_string|&quot;--children&quot;
suffix:semicolon
id|reverse
op_assign
l_int|1
suffix:semicolon
)brace
id|parse_revision_opt
c_func
(paren
op_amp
id|revs
comma
op_amp
id|ctx
comma
id|options
comma
id|blame_opt_usage
)paren
suffix:semicolon
)brace
id|parse_done
suffix:colon
id|argc
op_assign
id|parse_options_end
c_func
(paren
op_amp
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DIFF_OPT_TST
c_func
(paren
op_amp
id|revs.diffopt
comma
id|FIND_COPIES_HARDER
)paren
)paren
id|opt
op_or_assign
(paren
id|PICKAXE_BLAME_COPY
op_or
id|PICKAXE_BLAME_MOVE
op_or
id|PICKAXE_BLAME_COPY_HARDER
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|blame_move_score
)paren
id|blame_move_score
op_assign
id|BLAME_DEFAULT_MOVE_SCORE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|blame_copy_score
)paren
id|blame_copy_score
op_assign
id|BLAME_DEFAULT_COPY_SCORE
suffix:semicolon
multiline_comment|/*&n;&t; * We have collected options unknown to us in argv[1..unk]&n;&t; * which are to be passed to revision machinery if we are&n;&t; * going to do the &quot;bottom&quot; processing.&n;&t; *&n;&t; * The remaining are:&n;&t; *&n;&t; * (1) if dashdash_pos != 0, its either&n;&t; *     &quot;blame [revisions] -- &lt;path&gt;&quot; or&n;&t; *     &quot;blame -- &lt;path&gt; &lt;rev&gt;&quot;&n;&t; *&n;&t; * (2) otherwise, its one of the two:&n;&t; *     &quot;blame [revisions] &lt;path&gt;&quot;&n;&t; *     &quot;blame &lt;path&gt; &lt;rev&gt;&quot;&n;&t; *&n;&t; * Note that we must strip out &lt;path&gt; from the arguments: we do not&n;&t; * want the path pruning but we may want &quot;bottom&quot; processing.&n;&t; */
r_if
c_cond
(paren
id|dashdash_pos
)paren
(brace
r_switch
c_cond
(paren
id|argc
id|dashdash_pos
l_int|1
)paren
(brace
r_case
l_int|2
suffix:colon
multiline_comment|/* (1b) */
r_if
c_cond
(paren
id|argc
op_ne
l_int|4
)paren
id|usage_with_options
c_func
(paren
id|blame_opt_usage
comma
id|options
)paren
suffix:semicolon
multiline_comment|/* reorder for the new way: &lt;rev&gt; -- &lt;path&gt; */
id|argv
(braket
l_int|1
)braket
op_assign
id|argv
(braket
l_int|3
)braket
suffix:semicolon
id|argv
(braket
l_int|3
)braket
op_assign
id|argv
(braket
l_int|2
)braket
suffix:semicolon
id|argv
(braket
l_int|2
)braket
op_assign
l_string|&quot;--&quot;
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
r_case
l_int|1
suffix:colon
multiline_comment|/* (1a) */
id|path
op_assign
id|add_prefix
c_func
(paren
id|prefix
comma
id|argv
(braket
op_decrement
id|argc
)braket
)paren
suffix:semicolon
id|argv
(braket
id|argc
)braket
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|usage_with_options
c_func
(paren
id|blame_opt_usage
comma
id|options
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|argc
OL
l_int|2
)paren
id|usage_with_options
c_func
(paren
id|blame_opt_usage
comma
id|options
)paren
suffix:semicolon
id|path
op_assign
id|add_prefix
c_func
(paren
id|prefix
comma
id|argv
(braket
id|argc
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|argc
op_eq
l_int|3
op_logical_and
op_logical_neg
id|has_string_in_work_tree
c_func
(paren
id|path
)paren
)paren
(brace
multiline_comment|/* (2b) */
id|path
op_assign
id|add_prefix
c_func
(paren
id|prefix
comma
id|argv
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|argv
(braket
l_int|1
)braket
op_assign
id|argv
(braket
l_int|2
)braket
suffix:semicolon
)brace
id|argv
(braket
id|argc
l_int|1
)braket
op_assign
l_string|&quot;--&quot;
suffix:semicolon
id|setup_work_tree
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|has_string_in_work_tree
c_func
(paren
id|path
)paren
)paren
id|die
c_func
(paren
l_string|&quot;cannot stat path %s: %s&quot;
comma
id|path
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
)brace
id|setup_revisions
c_func
(paren
id|argc
comma
id|argv
comma
op_amp
id|revs
comma
l_int|NULL
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|sb
comma
l_int|0
comma
r_sizeof
(paren
id|sb
)paren
)paren
suffix:semicolon
id|sb.revs
op_assign
op_amp
id|revs
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|reverse
)paren
id|final_commit_name
op_assign
id|prepare_final
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|contents_from
)paren
id|die
c_func
(paren
l_string|&quot;--contents and --children do not blend well.&quot;
)paren
suffix:semicolon
r_else
id|final_commit_name
op_assign
id|prepare_initial
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sb.final
)paren
(brace
multiline_comment|/*&n;&t;&t; * &quot;--not A B -- path&quot; without anything positive;&n;&t;&t; * do not default to HEAD, but use the working tree&n;&t;&t; * or &quot;--contents&quot;.&n;&t;&t; */
id|setup_work_tree
c_func
(paren
)paren
suffix:semicolon
id|sb.final
op_assign
id|fake_working_tree_commit
c_func
(paren
id|path
comma
id|contents_from
)paren
suffix:semicolon
id|add_pending_object
c_func
(paren
op_amp
id|revs
comma
op_amp
(paren
id|sb.final-&gt;object
)paren
comma
l_string|&quot;:&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|contents_from
)paren
id|die
c_func
(paren
l_string|&quot;Cannot use --contents with final commit object name&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we have bottom, this will mark the ancestors of the&n;&t; * bottom commits we would reach while traversing as&n;&t; * uninteresting.&n;&t; */
r_if
c_cond
(paren
id|prepare_revision_walk
c_func
(paren
op_amp
id|revs
)paren
)paren
id|die
c_func
(paren
l_string|&quot;revision walk setup failed&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_null_sha1
c_func
(paren
id|sb.final-&gt;object.sha1
)paren
)paren
(brace
r_char
op_star
id|buf
suffix:semicolon
id|o
op_assign
id|sb.final-&gt;util
suffix:semicolon
id|buf
op_assign
id|xmalloc
c_func
(paren
id|o-&gt;file.size
op_plus
l_int|1
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|buf
comma
id|o-&gt;file.ptr
comma
id|o-&gt;file.size
op_plus
l_int|1
)paren
suffix:semicolon
id|sb.final_buf
op_assign
id|buf
suffix:semicolon
id|sb.final_buf_size
op_assign
id|o-&gt;file.size
suffix:semicolon
)brace
r_else
(brace
id|o
op_assign
id|get_origin
c_func
(paren
op_amp
id|sb
comma
id|sb.final
comma
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fill_blob_sha1
c_func
(paren
id|o
)paren
)paren
id|die
c_func
(paren
l_string|&quot;no such path %s in %s&quot;
comma
id|path
comma
id|final_commit_name
)paren
suffix:semicolon
id|sb.final_buf
op_assign
id|read_sha1_file
c_func
(paren
id|o-&gt;blob_sha1
comma
op_amp
id|type
comma
op_amp
id|sb.final_buf_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sb.final_buf
)paren
id|die
c_func
(paren
l_string|&quot;Cannot read blob %s for path %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|o-&gt;blob_sha1
)paren
comma
id|path
)paren
suffix:semicolon
)brace
id|num_read_blob
op_increment
suffix:semicolon
id|lno
op_assign
id|prepare_lines
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
id|bottom
op_assign
id|top
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|bottomtop
)paren
id|prepare_blame_range
c_func
(paren
op_amp
id|sb
comma
id|bottomtop
comma
id|lno
comma
op_amp
id|bottom
comma
op_amp
id|top
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bottom
op_logical_and
id|top
op_logical_and
id|top
OL
id|bottom
)paren
(brace
r_int
id|tmp
suffix:semicolon
id|tmp
op_assign
id|top
suffix:semicolon
id|top
op_assign
id|bottom
suffix:semicolon
id|bottom
op_assign
id|tmp
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bottom
OL
l_int|1
)paren
id|bottom
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|top
OL
l_int|1
)paren
id|top
op_assign
id|lno
suffix:semicolon
id|bottom
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|lno
OL
id|top
)paren
id|die
c_func
(paren
l_string|&quot;file %s has only %lu lines&quot;
comma
id|path
comma
id|lno
)paren
suffix:semicolon
id|ent
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|ent
)paren
)paren
suffix:semicolon
id|ent-&gt;lno
op_assign
id|bottom
suffix:semicolon
id|ent-&gt;num_lines
op_assign
id|top
id|bottom
suffix:semicolon
id|ent-&gt;suspect
op_assign
id|o
suffix:semicolon
id|ent-&gt;s_lno
op_assign
id|bottom
suffix:semicolon
id|sb.ent
op_assign
id|ent
suffix:semicolon
id|sb.path
op_assign
id|path
suffix:semicolon
r_if
c_cond
(paren
id|revs_file
op_logical_and
id|read_ancestry
c_func
(paren
id|revs_file
)paren
)paren
id|die
c_func
(paren
l_string|&quot;reading graft file %s failed: %s&quot;
comma
id|revs_file
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
id|read_mailmap
c_func
(paren
op_amp
id|mailmap
comma
l_string|&quot;.mailmap&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|incremental
)paren
id|setup_pager
c_func
(paren
)paren
suffix:semicolon
id|assign_blame
c_func
(paren
op_amp
id|sb
comma
id|opt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|incremental
)paren
r_return
l_int|0
suffix:semicolon
id|coalesce
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|output_option
op_amp
id|OUTPUT_PORCELAIN
)paren
)paren
id|find_alignment
c_func
(paren
op_amp
id|sb
comma
op_amp
id|output_option
)paren
suffix:semicolon
id|output
c_func
(paren
op_amp
id|sb
comma
id|output_option
)paren
suffix:semicolon
id|free
c_func
(paren
(paren
r_void
op_star
)paren
id|sb.final_buf
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ent
op_assign
id|sb.ent
suffix:semicolon
id|ent
suffix:semicolon
)paren
(brace
r_struct
id|blame_entry
op_star
id|e
op_assign
id|ent-&gt;next
suffix:semicolon
id|free
c_func
(paren
id|ent
)paren
suffix:semicolon
id|ent
op_assign
id|e
suffix:semicolon
)brace
r_if
c_cond
(paren
id|show_stats
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;num read blob: %d&bslash;n&quot;
comma
id|num_read_blob
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;num get patch: %d&bslash;n&quot;
comma
id|num_get_patch
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;num commits: %d&bslash;n&quot;
comma
id|num_commits
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
