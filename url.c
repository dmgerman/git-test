macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;url.h&quot;
DECL|function|is_urlschemechar
r_int
id|is_urlschemechar
c_func
(paren
r_int
id|first_flag
comma
r_int
id|ch
)paren
(brace
multiline_comment|/*&n;&t; * The set of valid URL schemes, as per STD66 (RFC3986) is&n;&t; * &squot;[A-Za-z][A-Za-z0-9+.-]*&squot;. But use sightly looser check&n;&t; * of &squot;[A-Za-z0-9][A-Za-z0-9+.-]*&squot; because earlier version&n;&t; * of check used &squot;[A-Za-z0-9]+&squot; so not to break any remote&n;&t; * helpers.&n;&t; */
r_int
id|alphanumeric
comma
id|special
suffix:semicolon
id|alphanumeric
op_assign
id|ch
OG
l_int|0
op_logical_and
id|isalnum
c_func
(paren
id|ch
)paren
suffix:semicolon
id|special
op_assign
id|ch
op_eq
l_char|&squot;+&squot;
op_logical_or
id|ch
op_eq
l_char|&squot;-&squot;
op_logical_or
id|ch
op_eq
l_char|&squot;.&squot;
suffix:semicolon
r_return
id|alphanumeric
op_logical_or
(paren
op_logical_neg
id|first_flag
op_logical_and
id|special
)paren
suffix:semicolon
)brace
DECL|function|is_url
r_int
id|is_url
c_func
(paren
r_const
r_char
op_star
id|url
)paren
(brace
r_const
r_char
op_star
id|url2
comma
op_star
id|first_slash
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|url
)paren
r_return
l_int|0
suffix:semicolon
id|url2
op_assign
id|url
suffix:semicolon
id|first_slash
op_assign
id|strchr
c_func
(paren
id|url
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
multiline_comment|/* Input with no slash at all or slash first can&squot;t be URL. */
r_if
c_cond
(paren
op_logical_neg
id|first_slash
op_logical_or
id|first_slash
op_eq
id|url
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Character before must be : and next must be /. */
r_if
c_cond
(paren
id|first_slash
(braket
l_int|1
)braket
op_ne
l_char|&squot;:&squot;
op_logical_or
id|first_slash
(braket
l_int|1
)braket
op_ne
l_char|&squot;/&squot;
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* There must be something before the :// */
r_if
c_cond
(paren
id|first_slash
op_eq
id|url
op_plus
l_int|1
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Check all characters up to first slash - 1. Only alphanum&n;&t; * is allowed.&n;&t; */
id|url2
op_assign
id|url
suffix:semicolon
r_while
c_loop
(paren
id|url2
OL
id|first_slash
l_int|1
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|is_urlschemechar
c_func
(paren
id|url2
op_eq
id|url
comma
(paren
r_int
r_char
)paren
op_star
id|url2
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|url2
op_increment
suffix:semicolon
)brace
multiline_comment|/* Valid enough. */
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|url_decode_char
r_static
r_int
id|url_decode_char
c_func
(paren
r_const
r_char
op_star
id|q
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_char
id|val
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_char
id|c
op_assign
op_star
id|q
op_increment
suffix:semicolon
id|val
op_lshift_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|c
op_ge
l_char|&squot;0&squot;
op_logical_and
id|c
op_le
l_char|&squot;9&squot;
)paren
id|val
op_add_assign
id|c
l_char|&squot;0&squot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c
op_ge
l_char|&squot;a&squot;
op_logical_and
id|c
op_le
l_char|&squot;f&squot;
)paren
id|val
op_add_assign
id|c
l_char|&squot;a&squot;
op_plus
l_int|10
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c
op_ge
l_char|&squot;A&squot;
op_logical_and
id|c
op_le
l_char|&squot;F&squot;
)paren
id|val
op_add_assign
id|c
l_char|&squot;A&squot;
op_plus
l_int|10
suffix:semicolon
r_else
r_return
l_int|1
suffix:semicolon
)brace
r_return
id|val
suffix:semicolon
)brace
DECL|function|url_decode_internal
r_static
r_char
op_star
id|url_decode_internal
c_func
(paren
r_const
r_char
op_star
op_star
id|query
comma
r_const
r_char
op_star
id|stop_at
comma
r_struct
id|strbuf
op_star
id|out
comma
r_int
id|decode_plus
)paren
(brace
r_const
r_char
op_star
id|q
op_assign
op_star
id|query
suffix:semicolon
r_do
(brace
r_int
r_char
id|c
op_assign
op_star
id|q
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|stop_at
op_logical_and
id|strchr
c_func
(paren
id|stop_at
comma
id|c
)paren
)paren
(brace
id|q
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;%&squot;
)paren
(brace
r_int
id|val
op_assign
id|url_decode_char
c_func
(paren
id|q
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_le
id|val
)paren
(brace
id|strbuf_addch
c_func
(paren
id|out
comma
id|val
)paren
suffix:semicolon
id|q
op_add_assign
l_int|3
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|decode_plus
op_logical_and
id|c
op_eq
l_char|&squot;+&squot;
)paren
id|strbuf_addch
c_func
(paren
id|out
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
r_else
id|strbuf_addch
c_func
(paren
id|out
comma
id|c
)paren
suffix:semicolon
id|q
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
op_star
id|query
op_assign
id|q
suffix:semicolon
r_return
id|strbuf_detach
c_func
(paren
id|out
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|url_decode
r_char
op_star
id|url_decode
c_func
(paren
r_const
r_char
op_star
id|url
)paren
(brace
r_struct
id|strbuf
id|out
op_assign
id|STRBUF_INIT
suffix:semicolon
r_const
r_char
op_star
id|colon
op_assign
id|strchr
c_func
(paren
id|url
comma
l_char|&squot;:&squot;
)paren
suffix:semicolon
multiline_comment|/* Skip protocol part if present */
r_if
c_cond
(paren
id|colon
op_logical_and
id|url
OL
id|colon
)paren
(brace
id|strbuf_add
c_func
(paren
op_amp
id|out
comma
id|url
comma
id|colon
id|url
)paren
suffix:semicolon
id|url
op_assign
id|colon
suffix:semicolon
)brace
r_return
id|url_decode_internal
c_func
(paren
op_amp
id|url
comma
l_int|NULL
comma
op_amp
id|out
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|url_decode_parameter_name
r_char
op_star
id|url_decode_parameter_name
c_func
(paren
r_const
r_char
op_star
op_star
id|query
)paren
(brace
r_struct
id|strbuf
id|out
op_assign
id|STRBUF_INIT
suffix:semicolon
r_return
id|url_decode_internal
c_func
(paren
id|query
comma
l_string|&quot;&amp;=&quot;
comma
op_amp
id|out
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|url_decode_parameter_value
r_char
op_star
id|url_decode_parameter_value
c_func
(paren
r_const
r_char
op_star
op_star
id|query
)paren
(brace
r_struct
id|strbuf
id|out
op_assign
id|STRBUF_INIT
suffix:semicolon
r_return
id|url_decode_internal
c_func
(paren
id|query
comma
l_string|&quot;&amp;&quot;
comma
op_amp
id|out
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|end_url_with_slash
r_void
id|end_url_with_slash
c_func
(paren
r_struct
id|strbuf
op_star
id|buf
comma
r_const
r_char
op_star
id|url
)paren
(brace
id|strbuf_addstr
c_func
(paren
id|buf
comma
id|url
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf-&gt;len
op_logical_and
id|buf-&gt;buf
(braket
id|buf-&gt;len
l_int|1
)braket
op_ne
l_char|&squot;/&squot;
)paren
id|strbuf_addstr
c_func
(paren
id|buf
comma
l_string|&quot;/&quot;
)paren
suffix:semicolon
)brace
DECL|function|str_end_url_with_slash
r_void
id|str_end_url_with_slash
c_func
(paren
r_const
r_char
op_star
id|url
comma
r_char
op_star
op_star
id|dest
)paren
(brace
r_struct
id|strbuf
id|buf
op_assign
id|STRBUF_INIT
suffix:semicolon
id|end_url_with_slash
c_func
(paren
op_amp
id|buf
comma
id|url
)paren
suffix:semicolon
id|free
c_func
(paren
op_star
id|dest
)paren
suffix:semicolon
op_star
id|dest
op_assign
id|strbuf_detach
c_func
(paren
op_amp
id|buf
comma
l_int|NULL
)paren
suffix:semicolon
)brace
eof
