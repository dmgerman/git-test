multiline_comment|/*&n; * Recursive Merge algorithm stolen from git-merge-recursive.py by&n; * Fredrik Kuivinen.&n; * The thieves were Alex Riesen and Johannes Schindelin, in June/July 2006&n; */
macro_line|#include &lt;stdarg.h&gt;
macro_line|#include &lt;string.h&gt;
macro_line|#include &lt;assert.h&gt;
macro_line|#include &lt;sys/wait.h&gt;
macro_line|#include &lt;sys/types.h&gt;
macro_line|#include &lt;sys/stat.h&gt;
macro_line|#include &lt;time.h&gt;
macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;cache-tree.h&quot;
macro_line|#include &quot;commit.h&quot;
macro_line|#include &quot;blob.h&quot;
macro_line|#include &quot;tree-walk.h&quot;
macro_line|#include &quot;diff.h&quot;
macro_line|#include &quot;diffcore.h&quot;
macro_line|#include &quot;run-command.h&quot;
macro_line|#include &quot;tag.h&quot;
macro_line|#include &quot;path-list.h&quot;
multiline_comment|/*#define DEBUG*/
macro_line|#ifdef DEBUG
DECL|macro|debug
mdefine_line|#define debug(args, ...) fprintf(stderr, args, ## __VA_ARGS__)
macro_line|#else
DECL|macro|debug
mdefine_line|#define debug(args, ...)
macro_line|#endif
macro_line|#ifdef DEBUG
macro_line|#include &quot;quote.h&quot;
DECL|function|show_ce_entry
r_static
r_void
id|show_ce_entry
c_func
(paren
r_const
r_char
op_star
id|tag
comma
r_struct
id|cache_entry
op_star
id|ce
)paren
(brace
r_if
c_cond
(paren
id|tag
op_logical_and
op_star
id|tag
op_logical_and
(paren
id|ce-&gt;ce_flags
op_amp
id|htons
c_func
(paren
id|CE_VALID
)paren
)paren
)paren
(brace
r_static
r_char
id|alttag
(braket
l_int|4
)braket
suffix:semicolon
id|memcpy
c_func
(paren
id|alttag
comma
id|tag
comma
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|isalpha
c_func
(paren
id|tag
(braket
l_int|0
)braket
)paren
)paren
id|alttag
(braket
l_int|0
)braket
op_assign
id|tolower
c_func
(paren
id|tag
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tag
(braket
l_int|0
)braket
op_eq
l_char|&squot;?&squot;
)paren
id|alttag
(braket
l_int|0
)braket
op_assign
l_char|&squot;!&squot;
suffix:semicolon
r_else
(brace
id|alttag
(braket
l_int|0
)braket
op_assign
l_char|&squot;v&squot;
suffix:semicolon
id|alttag
(braket
l_int|1
)braket
op_assign
id|tag
(braket
l_int|0
)braket
suffix:semicolon
id|alttag
(braket
l_int|2
)braket
op_assign
l_char|&squot; &squot;
suffix:semicolon
id|alttag
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|tag
op_assign
id|alttag
suffix:semicolon
)brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s%06o %s %d&bslash;t&quot;
comma
id|tag
comma
id|ntohl
c_func
(paren
id|ce-&gt;ce_mode
)paren
comma
id|sha1_to_hex
c_func
(paren
id|ce-&gt;sha1
)paren
comma
id|ce_stage
c_func
(paren
id|ce
)paren
)paren
suffix:semicolon
id|write_name_quoted
c_func
(paren
l_string|&quot;&quot;
comma
l_int|0
comma
id|ce-&gt;name
comma
l_char|&squot;&bslash;n&squot;
comma
id|stderr
)paren
suffix:semicolon
id|fputc
c_func
(paren
l_char|&squot;&bslash;n&squot;
comma
id|stderr
)paren
suffix:semicolon
)brace
DECL|function|ls_files
r_static
r_void
id|ls_files
c_func
(paren
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|active_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|cache_entry
op_star
id|ce
op_assign
id|active_cache
(braket
id|i
)braket
suffix:semicolon
id|show_ce_entry
c_func
(paren
l_string|&quot;&quot;
comma
id|ce
)paren
suffix:semicolon
)brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;---&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * A virtual commit has&n; * - (const char *)commit-&gt;util set to the name, and&n; * - *(int *)commit-&gt;object.sha1 set to the virtual id.&n; */
DECL|function|commit_title
r_static
r_const
r_char
op_star
id|commit_title
c_func
(paren
r_struct
id|commit
op_star
id|commit
comma
r_int
op_star
id|len
)paren
(brace
r_const
r_char
op_star
id|s
op_assign
l_string|&quot;(null commit)&quot;
suffix:semicolon
op_star
id|len
op_assign
id|strlen
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|commit-&gt;util
)paren
(brace
id|s
op_assign
id|commit-&gt;util
suffix:semicolon
op_star
id|len
op_assign
id|strlen
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|parse_commit
c_func
(paren
id|commit
)paren
op_ne
l_int|0
)paren
(brace
id|s
op_assign
l_string|&quot;(bad commit)&quot;
suffix:semicolon
op_star
id|len
op_assign
id|strlen
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
r_else
(brace
id|s
op_assign
id|commit-&gt;buffer
suffix:semicolon
r_char
id|prev
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_while
c_loop
(paren
op_star
id|s
)paren
(brace
r_if
c_cond
(paren
l_char|&squot;&bslash;n&squot;
op_eq
id|prev
op_logical_and
l_char|&squot;&bslash;n&squot;
op_eq
op_star
id|s
)paren
(brace
op_increment
id|s
suffix:semicolon
r_break
suffix:semicolon
)brace
id|prev
op_assign
op_star
id|s
op_increment
suffix:semicolon
)brace
op_star
id|len
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|s
(braket
op_star
id|len
)braket
op_logical_and
l_char|&squot;&bslash;n&squot;
op_ne
id|s
(braket
op_star
id|len
)braket
)paren
op_increment
(paren
op_star
id|len
)paren
suffix:semicolon
)brace
)brace
r_return
id|s
suffix:semicolon
)brace
DECL|function|commit_hex_sha1
r_static
r_const
r_char
op_star
id|commit_hex_sha1
c_func
(paren
r_const
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_return
id|commit-&gt;util
ques
c_cond
l_string|&quot;virtual&quot;
suffix:colon
id|commit
ques
c_cond
id|sha1_to_hex
c_func
(paren
id|commit-&gt;object.sha1
)paren
suffix:colon
l_string|&quot;undefined&quot;
suffix:semicolon
)brace
DECL|function|commit_list_count
r_static
r_int
id|commit_list_count
c_func
(paren
r_const
r_struct
id|commit_list
op_star
id|l
)paren
(brace
r_int
id|c
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|l
suffix:semicolon
id|l
op_assign
id|l-&gt;next
)paren
id|c
op_increment
suffix:semicolon
r_return
id|c
suffix:semicolon
)brace
DECL|function|make_virtual_commit
r_static
r_struct
id|commit
op_star
id|make_virtual_commit
c_func
(paren
r_struct
id|tree
op_star
id|tree
comma
r_const
r_char
op_star
id|comment
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|commit
)paren
)paren
suffix:semicolon
r_static
r_int
id|virtual_id
op_assign
l_int|1
suffix:semicolon
id|commit-&gt;tree
op_assign
id|tree
suffix:semicolon
id|commit-&gt;util
op_assign
(paren
r_void
op_star
)paren
id|comment
suffix:semicolon
op_star
(paren
r_int
op_star
)paren
id|commit-&gt;object.sha1
op_assign
id|virtual_id
op_increment
suffix:semicolon
r_return
id|commit
suffix:semicolon
)brace
multiline_comment|/*&n; * TODO: we should not have to copy the SHA1s around, but rather reference&n; * them. That way, sha_eq() is just sha1 == sha2.&n; */
DECL|function|sha_eq
r_static
r_int
id|sha_eq
c_func
(paren
r_const
r_int
r_char
op_star
id|a
comma
r_const
r_int
r_char
op_star
id|b
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|a
op_logical_and
op_logical_neg
id|b
)paren
r_return
l_int|2
suffix:semicolon
r_return
id|a
op_logical_and
id|b
op_logical_and
id|memcmp
c_func
(paren
id|a
comma
id|b
comma
l_int|20
)paren
op_eq
l_int|0
suffix:semicolon
)brace
DECL|function|memswp
r_static
r_void
id|memswp
c_func
(paren
r_void
op_star
id|p1
comma
r_void
op_star
id|p2
comma
r_int
id|n
)paren
(brace
r_int
r_char
op_star
id|a
op_assign
id|p1
comma
op_star
id|b
op_assign
id|p2
suffix:semicolon
r_while
c_loop
(paren
id|n
op_decrement
)paren
(brace
op_star
id|a
op_xor_assign
op_star
id|b
suffix:semicolon
op_star
id|b
op_xor_assign
op_star
id|a
suffix:semicolon
op_star
id|a
op_xor_assign
op_star
id|b
suffix:semicolon
op_increment
id|a
suffix:semicolon
op_increment
id|b
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * TODO: we should convert the merge_result users to&n; * &t;int blabla(..., struct commit **result)&n; * like everywhere else in git.&n; * Same goes for merge_tree_result and merge_file_info.&n; */
DECL|struct|merge_result
r_struct
id|merge_result
(brace
DECL|member|commit
r_struct
id|commit
op_star
id|commit
suffix:semicolon
DECL|member|clean
r_int
id|clean
suffix:colon
l_int|1
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|merge_tree_result
r_struct
id|merge_tree_result
(brace
DECL|member|tree
r_struct
id|tree
op_star
id|tree
suffix:semicolon
DECL|member|clean
r_int
id|clean
suffix:colon
l_int|1
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * TODO: check if we can just reuse the active_cache structure: it is already&n; * sorted (by name, stage).&n; * Only problem: do not write it when flushing the cache.&n; */
DECL|struct|stage_data
r_struct
id|stage_data
(brace
r_struct
(brace
DECL|member|mode
r_int
id|mode
suffix:semicolon
DECL|member|sha
r_int
r_char
id|sha
(braket
l_int|20
)braket
suffix:semicolon
DECL|member|stages
)brace
id|stages
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|processed
r_int
id|processed
suffix:colon
l_int|1
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|currentFileSet
r_static
r_struct
id|path_list
id|currentFileSet
op_assign
(brace
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|1
)brace
suffix:semicolon
DECL|variable|currentDirectorySet
r_static
r_struct
id|path_list
id|currentDirectorySet
op_assign
(brace
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|1
)brace
suffix:semicolon
DECL|variable|output_indent
r_static
r_int
id|output_indent
op_assign
l_int|0
suffix:semicolon
DECL|function|output
r_static
r_void
id|output
c_func
(paren
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
id|va_list
id|args
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|output_indent
suffix:semicolon
id|i
op_decrement
suffix:semicolon
)paren
id|fputs
c_func
(paren
l_string|&quot;  &quot;
comma
id|stdout
)paren
suffix:semicolon
id|va_start
c_func
(paren
id|args
comma
id|fmt
)paren
suffix:semicolon
id|vfprintf
c_func
(paren
id|stdout
comma
id|fmt
comma
id|args
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|args
)paren
suffix:semicolon
id|fputc
c_func
(paren
l_char|&squot;&bslash;n&squot;
comma
id|stdout
)paren
suffix:semicolon
)brace
DECL|variable|original_index_file
r_static
r_const
r_char
op_star
id|original_index_file
suffix:semicolon
DECL|variable|temporary_index_file
r_static
r_const
r_char
op_star
id|temporary_index_file
suffix:semicolon
DECL|variable|cache_dirty
r_static
r_int
id|cache_dirty
op_assign
l_int|0
suffix:semicolon
DECL|function|flush_cache
r_static
r_int
id|flush_cache
c_func
(paren
)paren
(brace
multiline_comment|/* flush temporary index */
r_struct
id|lock_file
op_star
id|lock
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|lock_file
)paren
)paren
suffix:semicolon
r_int
id|fd
op_assign
id|hold_lock_file_for_update
c_func
(paren
id|lock
comma
id|getenv
c_func
(paren
l_string|&quot;GIT_INDEX_FILE&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;could not lock %s&quot;
comma
id|temporary_index_file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write_cache
c_func
(paren
id|fd
comma
id|active_cache
comma
id|active_nr
)paren
op_logical_or
id|close
c_func
(paren
id|fd
)paren
op_logical_or
id|commit_lock_file
c_func
(paren
id|lock
)paren
)paren
id|die
(paren
l_string|&quot;unable to write %s&quot;
comma
id|getenv
c_func
(paren
l_string|&quot;GIT_INDEX_FILE&quot;
)paren
)paren
suffix:semicolon
id|discard_cache
c_func
(paren
)paren
suffix:semicolon
id|cache_dirty
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|setup_index
r_static
r_void
id|setup_index
c_func
(paren
r_int
id|temp
)paren
(brace
r_const
r_char
op_star
id|idx
op_assign
id|temp
ques
c_cond
id|temporary_index_file
suffix:colon
id|original_index_file
suffix:semicolon
r_if
c_cond
(paren
id|cache_dirty
)paren
id|die
c_func
(paren
l_string|&quot;fatal: cache changed flush_cache();&quot;
)paren
suffix:semicolon
id|unlink
c_func
(paren
id|temporary_index_file
)paren
suffix:semicolon
id|setenv
c_func
(paren
l_string|&quot;GIT_INDEX_FILE&quot;
comma
id|idx
comma
l_int|1
)paren
suffix:semicolon
id|discard_cache
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|make_cache_entry
r_static
r_struct
id|cache_entry
op_star
id|make_cache_entry
c_func
(paren
r_int
r_int
id|mode
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_const
r_char
op_star
id|path
comma
r_int
id|stage
comma
r_int
id|refresh
)paren
(brace
r_int
id|size
comma
id|len
suffix:semicolon
r_struct
id|cache_entry
op_star
id|ce
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|verify_path
c_func
(paren
id|path
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|path
)paren
suffix:semicolon
id|size
op_assign
id|cache_entry_size
c_func
(paren
id|len
)paren
suffix:semicolon
id|ce
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
id|size
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ce-&gt;sha1
comma
id|sha1
comma
l_int|20
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ce-&gt;name
comma
id|path
comma
id|len
)paren
suffix:semicolon
id|ce-&gt;ce_flags
op_assign
id|create_ce_flags
c_func
(paren
id|len
comma
id|stage
)paren
suffix:semicolon
id|ce-&gt;ce_mode
op_assign
id|create_ce_mode
c_func
(paren
id|mode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|refresh
)paren
r_return
id|refresh_cache_entry
c_func
(paren
id|ce
comma
l_int|0
)paren
suffix:semicolon
r_return
id|ce
suffix:semicolon
)brace
DECL|function|add_cacheinfo
r_static
r_int
id|add_cacheinfo
c_func
(paren
r_int
r_int
id|mode
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_const
r_char
op_star
id|path
comma
r_int
id|stage
comma
r_int
id|refresh
comma
r_int
id|options
)paren
(brace
r_struct
id|cache_entry
op_star
id|ce
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cache_dirty
)paren
id|read_cache_from
c_func
(paren
id|getenv
c_func
(paren
l_string|&quot;GIT_INDEX_FILE&quot;
)paren
)paren
suffix:semicolon
id|cache_dirty
op_increment
suffix:semicolon
id|ce
op_assign
id|make_cache_entry
c_func
(paren
id|mode
comma
id|sha1
ques
c_cond
id|sha1
suffix:colon
id|null_sha1
comma
id|path
comma
id|stage
comma
id|refresh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ce
)paren
r_return
id|error
c_func
(paren
l_string|&quot;cache_addinfo failed: %s&quot;
comma
id|strerror
c_func
(paren
id|cache_errno
)paren
)paren
suffix:semicolon
r_return
id|add_cache_entry
c_func
(paren
id|ce
comma
id|options
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is a global variable which is used in a number of places but&n; * only written to in the &squot;merge&squot; function.&n; *&n; * index_only == 1    =&gt; Don&squot;t leave any non-stage 0 entries in the cache and&n; *                       don&squot;t update the working directory.&n; *               0    =&gt; Leave unmerged entries in the cache and update&n; *                       the working directory.&n; */
DECL|variable|index_only
r_static
r_int
id|index_only
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * TODO: this can be streamlined by refactoring builtin-read-tree.c&n; */
DECL|function|git_read_tree
r_static
r_int
id|git_read_tree
c_func
(paren
r_const
r_struct
id|tree
op_star
id|tree
)paren
(brace
macro_line|#if 0
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;GIT_INDEX_FILE=&squot;%s&squot; git-read-tree %s&bslash;n&quot;
comma
id|getenv
c_func
(paren
l_string|&quot;GIT_INDEX_FILE&quot;
)paren
comma
id|sha1_to_hex
c_func
(paren
id|tree-&gt;object.sha1
)paren
)paren
suffix:semicolon
macro_line|#endif
r_const
r_char
op_star
id|argv
(braket
)braket
op_assign
(brace
l_string|&quot;git-read-tree&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
)brace
suffix:semicolon
r_if
c_cond
(paren
id|cache_dirty
)paren
id|die
c_func
(paren
l_string|&quot;read-tree with dirty cache&quot;
)paren
suffix:semicolon
id|argv
(braket
l_int|1
)braket
op_assign
id|sha1_to_hex
c_func
(paren
id|tree-&gt;object.sha1
)paren
suffix:semicolon
r_int
id|rc
op_assign
id|run_command_v
c_func
(paren
l_int|2
comma
id|argv
)paren
suffix:semicolon
r_return
id|rc
OL
l_int|0
ques
c_cond
l_int|1
suffix:colon
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * TODO: this can be streamlined by refactoring builtin-read-tree.c&n; */
DECL|function|git_merge_trees
r_static
r_int
id|git_merge_trees
c_func
(paren
r_const
r_char
op_star
id|update_arg
comma
r_struct
id|tree
op_star
id|common
comma
r_struct
id|tree
op_star
id|head
comma
r_struct
id|tree
op_star
id|merge
)paren
(brace
macro_line|#if 0
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;GIT_INDEX_FILE=&squot;%s&squot; git-read-tree %s -m %s %s %s&bslash;n&quot;
comma
id|getenv
c_func
(paren
l_string|&quot;GIT_INDEX_FILE&quot;
)paren
comma
id|update_arg
comma
id|sha1_to_hex
c_func
(paren
id|common-&gt;object.sha1
)paren
comma
id|sha1_to_hex
c_func
(paren
id|head-&gt;object.sha1
)paren
comma
id|sha1_to_hex
c_func
(paren
id|merge-&gt;object.sha1
)paren
)paren
suffix:semicolon
macro_line|#endif
r_const
r_char
op_star
id|argv
(braket
)braket
op_assign
(brace
l_string|&quot;git-read-tree&quot;
comma
l_int|NULL
comma
l_string|&quot;-m&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
)brace
suffix:semicolon
r_if
c_cond
(paren
id|cache_dirty
)paren
id|flush_cache
c_func
(paren
)paren
suffix:semicolon
id|argv
(braket
l_int|1
)braket
op_assign
id|update_arg
suffix:semicolon
id|argv
(braket
l_int|3
)braket
op_assign
id|sha1_to_hex
c_func
(paren
id|common-&gt;object.sha1
)paren
suffix:semicolon
id|argv
(braket
l_int|4
)braket
op_assign
id|sha1_to_hex
c_func
(paren
id|head-&gt;object.sha1
)paren
suffix:semicolon
id|argv
(braket
l_int|5
)braket
op_assign
id|sha1_to_hex
c_func
(paren
id|merge-&gt;object.sha1
)paren
suffix:semicolon
r_int
id|rc
op_assign
id|run_command_v
c_func
(paren
l_int|6
comma
id|argv
)paren
suffix:semicolon
r_return
id|rc
OL
l_int|0
ques
c_cond
l_int|1
suffix:colon
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * TODO: this can be streamlined by refactoring builtin-write-tree.c&n; */
DECL|function|git_write_tree
r_static
r_struct
id|tree
op_star
id|git_write_tree
c_func
(paren
)paren
(brace
macro_line|#if 0
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;GIT_INDEX_FILE=&squot;%s&squot; git-write-tree&bslash;n&quot;
comma
id|getenv
c_func
(paren
l_string|&quot;GIT_INDEX_FILE&quot;
)paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cache_dirty
)paren
id|flush_cache
c_func
(paren
)paren
suffix:semicolon
id|FILE
op_star
id|fp
op_assign
id|popen
c_func
(paren
l_string|&quot;git-write-tree 2&gt;/dev/null&quot;
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_char
id|buf
(braket
l_int|41
)braket
suffix:semicolon
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_int
id|ch
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ch
op_assign
id|fgetc
c_func
(paren
id|fp
)paren
)paren
op_ne
id|EOF
)paren
r_if
c_cond
(paren
id|i
OL
r_sizeof
(paren
id|buf
)paren
op_minus
l_int|1
op_logical_and
id|ch
op_ge
l_char|&squot;0&squot;
op_logical_and
id|ch
op_le
l_char|&squot;f&squot;
)paren
id|buf
(braket
id|i
op_increment
)braket
op_assign
id|ch
suffix:semicolon
r_else
r_break
suffix:semicolon
r_int
id|rc
op_assign
id|pclose
c_func
(paren
id|fp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|1
op_logical_or
id|WEXITSTATUS
c_func
(paren
id|rc
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|buf
(braket
id|i
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1
c_func
(paren
id|buf
comma
id|sha1
)paren
op_ne
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|lookup_tree
c_func
(paren
id|sha1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * TODO: get rid of files_and_dirs; we do not use it except for&n; * current_file_set and current_dir_set, which are global already.&n; */
r_static
r_struct
(brace
DECL|member|files
r_struct
id|path_list
op_star
id|files
suffix:semicolon
DECL|member|dirs
r_struct
id|path_list
op_star
id|dirs
suffix:semicolon
DECL|variable|files_and_dirs
)brace
id|files_and_dirs
suffix:semicolon
DECL|function|save_files_dirs
r_static
r_int
id|save_files_dirs
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
comma
r_const
r_char
op_star
id|base
comma
r_int
id|baselen
comma
r_const
r_char
op_star
id|path
comma
r_int
r_int
id|mode
comma
r_int
id|stage
)paren
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|path
)paren
suffix:semicolon
r_char
op_star
id|newpath
op_assign
id|malloc
c_func
(paren
id|baselen
op_plus
id|len
op_plus
l_int|1
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|newpath
comma
id|base
comma
id|baselen
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|newpath
op_plus
id|baselen
comma
id|path
comma
id|len
)paren
suffix:semicolon
id|newpath
(braket
id|baselen
op_plus
id|len
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|mode
)paren
)paren
id|path_list_insert
c_func
(paren
id|newpath
comma
id|files_and_dirs.dirs
)paren
suffix:semicolon
r_else
id|path_list_insert
c_func
(paren
id|newpath
comma
id|files_and_dirs.files
)paren
suffix:semicolon
id|free
c_func
(paren
id|newpath
)paren
suffix:semicolon
r_return
id|READ_TREE_RECURSIVE
suffix:semicolon
)brace
DECL|function|get_files_dirs
r_static
r_int
id|get_files_dirs
c_func
(paren
r_struct
id|tree
op_star
id|tree
comma
r_struct
id|path_list
op_star
id|files
comma
r_struct
id|path_list
op_star
id|dirs
)paren
(brace
r_int
id|n
suffix:semicolon
id|files_and_dirs.files
op_assign
id|files
suffix:semicolon
id|files_and_dirs.dirs
op_assign
id|dirs
suffix:semicolon
id|debug
c_func
(paren
l_string|&quot;get_files_dirs ...&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_tree_recursive
c_func
(paren
id|tree
comma
l_string|&quot;&quot;
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
id|save_files_dirs
)paren
op_ne
l_int|0
)paren
(brace
id|debug
c_func
(paren
l_string|&quot;  get_files_dirs done (0)&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|n
op_assign
id|files-&gt;nr
op_plus
id|dirs-&gt;nr
suffix:semicolon
id|debug
c_func
(paren
l_string|&quot;  get_files_dirs done (%d)&bslash;n&quot;
comma
id|n
)paren
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
multiline_comment|/*&n; * TODO: this wrapper is so small, we can use path_list_lookup directly.&n; * Same goes for index_entry_get(), free_index_entries(), find_rename_bysrc(),&n; * free_rename_entries().&n; */
DECL|function|index_entry_find
r_static
r_struct
id|stage_data
op_star
id|index_entry_find
c_func
(paren
r_struct
id|path_list
op_star
id|ents
comma
r_const
r_char
op_star
id|path
)paren
(brace
r_struct
id|path_list_item
op_star
id|item
op_assign
id|path_list_lookup
c_func
(paren
id|path
comma
id|ents
)paren
suffix:semicolon
r_if
c_cond
(paren
id|item
)paren
r_return
id|item-&gt;util
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|index_entry_get
r_static
r_struct
id|stage_data
op_star
id|index_entry_get
c_func
(paren
r_struct
id|path_list
op_star
id|ents
comma
r_const
r_char
op_star
id|path
)paren
(brace
r_struct
id|path_list_item
op_star
id|item
op_assign
id|path_list_lookup
c_func
(paren
id|path
comma
id|ents
)paren
suffix:semicolon
r_if
c_cond
(paren
id|item
op_eq
l_int|NULL
)paren
(brace
id|item
op_assign
id|path_list_insert
c_func
(paren
id|path
comma
id|ents
)paren
suffix:semicolon
id|item-&gt;util
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|stage_data
)paren
)paren
suffix:semicolon
)brace
r_return
id|item-&gt;util
suffix:semicolon
)brace
multiline_comment|/*&n; * TODO: since the result of index_entry_from_db() is tucked into a&n; * path_list anyway, this helper can do that already.&n; */
multiline_comment|/*&n; * Returns a index_entry instance which doesn&squot;t have to correspond to&n; * a real cache entry in Git&squot;s index.&n; */
DECL|function|index_entry_from_db
r_static
r_struct
id|stage_data
op_star
id|index_entry_from_db
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_struct
id|tree
op_star
id|o
comma
r_struct
id|tree
op_star
id|a
comma
r_struct
id|tree
op_star
id|b
)paren
(brace
r_struct
id|stage_data
op_star
id|e
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|stage_data
)paren
)paren
suffix:semicolon
id|get_tree_entry
c_func
(paren
id|o-&gt;object.sha1
comma
id|path
comma
id|e-&gt;stages
(braket
l_int|1
)braket
dot
id|sha
comma
op_amp
id|e-&gt;stages
(braket
l_int|1
)braket
dot
id|mode
)paren
suffix:semicolon
id|get_tree_entry
c_func
(paren
id|a-&gt;object.sha1
comma
id|path
comma
id|e-&gt;stages
(braket
l_int|2
)braket
dot
id|sha
comma
op_amp
id|e-&gt;stages
(braket
l_int|2
)braket
dot
id|mode
)paren
suffix:semicolon
id|get_tree_entry
c_func
(paren
id|b-&gt;object.sha1
comma
id|path
comma
id|e-&gt;stages
(braket
l_int|3
)braket
dot
id|sha
comma
op_amp
id|e-&gt;stages
(braket
l_int|3
)braket
dot
id|mode
)paren
suffix:semicolon
r_return
id|e
suffix:semicolon
)brace
DECL|function|free_index_entries
r_static
r_void
id|free_index_entries
c_func
(paren
r_struct
id|path_list
op_star
op_star
id|ents
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|ents
)paren
r_return
suffix:semicolon
id|path_list_clear
c_func
(paren
op_star
id|ents
comma
l_int|1
)paren
suffix:semicolon
id|free
c_func
(paren
op_star
id|ents
)paren
suffix:semicolon
op_star
id|ents
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Create a dictionary mapping file names to CacheEntry objects. The&n; * dictionary contains one entry for every path with a non-zero stage entry.&n; */
DECL|function|get_unmerged
r_static
r_struct
id|path_list
op_star
id|get_unmerged
c_func
(paren
)paren
(brace
r_struct
id|path_list
op_star
id|unmerged
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|path_list
)paren
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
id|unmerged-&gt;strdup_paths
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cache_dirty
)paren
(brace
id|read_cache_from
c_func
(paren
id|getenv
c_func
(paren
l_string|&quot;GIT_INDEX_FILE&quot;
)paren
)paren
suffix:semicolon
id|cache_dirty
op_increment
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|active_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|cache_entry
op_star
id|ce
op_assign
id|active_cache
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ce_stage
c_func
(paren
id|ce
)paren
)paren
r_continue
suffix:semicolon
r_struct
id|stage_data
op_star
id|e
op_assign
id|index_entry_get
c_func
(paren
id|unmerged
comma
id|ce-&gt;name
)paren
suffix:semicolon
id|e-&gt;stages
(braket
id|ce_stage
c_func
(paren
id|ce
)paren
)braket
dot
id|mode
op_assign
id|ntohl
c_func
(paren
id|ce-&gt;ce_mode
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|e-&gt;stages
(braket
id|ce_stage
c_func
(paren
id|ce
)paren
)braket
dot
id|sha
comma
id|ce-&gt;sha1
comma
l_int|20
)paren
suffix:semicolon
)brace
id|debug
c_func
(paren
l_string|&quot;  get_unmerged done&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|unmerged
suffix:semicolon
)brace
DECL|struct|rename
r_struct
id|rename
(brace
DECL|member|pair
r_struct
id|diff_filepair
op_star
id|pair
suffix:semicolon
DECL|member|src_entry
r_struct
id|stage_data
op_star
id|src_entry
suffix:semicolon
DECL|member|dst_entry
r_struct
id|stage_data
op_star
id|dst_entry
suffix:semicolon
DECL|member|processed
r_int
id|processed
suffix:colon
l_int|1
suffix:semicolon
)brace
suffix:semicolon
DECL|function|find_rename_bysrc
r_static
r_struct
id|rename
op_star
id|find_rename_bysrc
c_func
(paren
r_struct
id|path_list
op_star
id|e
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|path_list_item
op_star
id|item
op_assign
id|path_list_lookup
c_func
(paren
id|name
comma
id|e
)paren
suffix:semicolon
r_if
c_cond
(paren
id|item
)paren
r_return
id|item-&gt;util
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|free_rename_entries
r_static
r_void
id|free_rename_entries
c_func
(paren
r_struct
id|path_list
op_star
op_star
id|list
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|list
)paren
r_return
suffix:semicolon
id|path_list_clear
c_func
(paren
op_star
id|list
comma
l_int|0
)paren
suffix:semicolon
id|free
c_func
(paren
op_star
id|list
)paren
suffix:semicolon
op_star
id|list
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Get information of all renames which occured between &squot;oTree&squot; and&n; * &squot;tree&squot;. We need the three trees in the merge (&squot;oTree&squot;, &squot;aTree&squot; and&n; * &squot;bTree&squot;) to be able to associate the correct cache entries with&n; * the rename information. &squot;tree&squot; is always equal to either aTree or bTree.&n; */
DECL|function|get_renames
r_static
r_struct
id|path_list
op_star
id|get_renames
c_func
(paren
r_struct
id|tree
op_star
id|tree
comma
r_struct
id|tree
op_star
id|oTree
comma
r_struct
id|tree
op_star
id|aTree
comma
r_struct
id|tree
op_star
id|bTree
comma
r_struct
id|path_list
op_star
id|entries
)paren
(brace
macro_line|#ifdef DEBUG
id|time_t
id|t
op_assign
id|time
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|debug
c_func
(paren
l_string|&quot;getRenames ...&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_int
id|i
suffix:semicolon
r_struct
id|path_list
op_star
id|renames
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|path_list
)paren
)paren
suffix:semicolon
r_struct
id|diff_options
id|opts
suffix:semicolon
id|diff_setup
c_func
(paren
op_amp
id|opts
)paren
suffix:semicolon
id|opts.recursive
op_assign
l_int|1
suffix:semicolon
id|opts.detect_rename
op_assign
id|DIFF_DETECT_RENAME
suffix:semicolon
id|opts.output_format
op_assign
id|DIFF_FORMAT_NO_OUTPUT
suffix:semicolon
r_if
c_cond
(paren
id|diff_setup_done
c_func
(paren
op_amp
id|opts
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;diff setup failed&quot;
)paren
suffix:semicolon
id|diff_tree_sha1
c_func
(paren
id|oTree-&gt;object.sha1
comma
id|tree-&gt;object.sha1
comma
l_string|&quot;&quot;
comma
op_amp
id|opts
)paren
suffix:semicolon
id|diffcore_std
c_func
(paren
op_amp
id|opts
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|diff_queued_diff.nr
suffix:semicolon
op_increment
id|i
)paren
(brace
r_struct
id|rename
op_star
id|re
suffix:semicolon
r_struct
id|diff_filepair
op_star
id|pair
op_assign
id|diff_queued_diff.queue
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|pair-&gt;status
op_ne
l_char|&squot;R&squot;
)paren
(brace
id|diff_free_filepair
c_func
(paren
id|pair
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|re
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|re
)paren
)paren
suffix:semicolon
id|re-&gt;processed
op_assign
l_int|0
suffix:semicolon
id|re-&gt;pair
op_assign
id|pair
suffix:semicolon
id|re-&gt;src_entry
op_assign
id|index_entry_find
c_func
(paren
id|entries
comma
id|re-&gt;pair-&gt;one-&gt;path
)paren
suffix:semicolon
multiline_comment|/* TODO: should it not be an error, if src_entry was found? */
r_if
c_cond
(paren
op_logical_neg
id|re-&gt;src_entry
)paren
(brace
id|re-&gt;src_entry
op_assign
id|index_entry_from_db
c_func
(paren
id|re-&gt;pair-&gt;one-&gt;path
comma
id|oTree
comma
id|aTree
comma
id|bTree
)paren
suffix:semicolon
r_struct
id|path_list_item
op_star
id|item
op_assign
id|path_list_insert
c_func
(paren
id|re-&gt;pair-&gt;one-&gt;path
comma
id|entries
)paren
suffix:semicolon
id|item-&gt;util
op_assign
id|re-&gt;src_entry
suffix:semicolon
)brace
id|re-&gt;dst_entry
op_assign
id|index_entry_find
c_func
(paren
id|entries
comma
id|re-&gt;pair-&gt;two-&gt;path
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|re-&gt;dst_entry
)paren
(brace
id|re-&gt;dst_entry
op_assign
id|index_entry_from_db
c_func
(paren
id|re-&gt;pair-&gt;two-&gt;path
comma
id|oTree
comma
id|aTree
comma
id|bTree
)paren
suffix:semicolon
r_struct
id|path_list_item
op_star
id|item
op_assign
id|path_list_insert
c_func
(paren
id|re-&gt;pair-&gt;two-&gt;path
comma
id|entries
)paren
suffix:semicolon
id|item-&gt;util
op_assign
id|re-&gt;dst_entry
suffix:semicolon
)brace
r_struct
id|path_list_item
op_star
id|item
op_assign
id|path_list_insert
c_func
(paren
id|pair-&gt;one-&gt;path
comma
id|renames
)paren
suffix:semicolon
id|item-&gt;util
op_assign
id|re
suffix:semicolon
)brace
id|opts.output_format
op_assign
id|DIFF_FORMAT_NO_OUTPUT
suffix:semicolon
id|diff_queued_diff.nr
op_assign
l_int|0
suffix:semicolon
id|diff_flush
c_func
(paren
op_amp
id|opts
)paren
suffix:semicolon
id|debug
c_func
(paren
l_string|&quot;  getRenames done in %ld&bslash;n&quot;
comma
id|time
c_func
(paren
l_int|0
)paren
op_minus
id|t
)paren
suffix:semicolon
r_return
id|renames
suffix:semicolon
)brace
multiline_comment|/*&n; * TODO: the code would be way nicer, if we had a struct containing just sha1 and mode.&n; * In this particular case, we might get away reusing stage_data, no?&n; */
DECL|function|update_stages
r_int
id|update_stages
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_int
r_char
op_star
id|osha
comma
r_int
id|omode
comma
r_int
r_char
op_star
id|asha
comma
r_int
id|amode
comma
r_int
r_char
op_star
id|bsha
comma
r_int
id|bmode
comma
r_int
id|clear
multiline_comment|/* =True */
)paren
(brace
r_int
id|options
op_assign
id|ADD_CACHE_OK_TO_ADD
op_or
id|ADD_CACHE_OK_TO_REPLACE
suffix:semicolon
r_if
c_cond
(paren
id|clear
)paren
r_if
c_cond
(paren
id|add_cacheinfo
c_func
(paren
l_int|0
comma
id|null_sha1
comma
id|path
comma
l_int|0
comma
l_int|0
comma
id|options
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|omode
)paren
r_if
c_cond
(paren
id|add_cacheinfo
c_func
(paren
id|omode
comma
id|osha
comma
id|path
comma
l_int|1
comma
l_int|0
comma
id|options
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|amode
)paren
r_if
c_cond
(paren
id|add_cacheinfo
c_func
(paren
id|omode
comma
id|osha
comma
id|path
comma
l_int|2
comma
l_int|0
comma
id|options
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|bmode
)paren
r_if
c_cond
(paren
id|add_cacheinfo
c_func
(paren
id|omode
comma
id|osha
comma
id|path
comma
l_int|3
comma
l_int|0
comma
id|options
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * TODO: there has to be a function in libgit doing this exact thing.&n; */
DECL|function|remove_path
r_static
r_int
id|remove_path
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_int
id|ret
suffix:semicolon
r_char
op_star
id|slash
suffix:semicolon
id|ret
op_assign
id|unlink
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
r_char
op_star
id|dirs
op_assign
id|malloc
c_func
(paren
id|len
op_plus
l_int|1
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|dirs
comma
id|name
comma
id|len
)paren
suffix:semicolon
id|dirs
(braket
id|len
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_while
c_loop
(paren
(paren
id|slash
op_assign
id|strrchr
c_func
(paren
id|name
comma
l_char|&squot;/&squot;
)paren
)paren
)paren
(brace
op_star
id|slash
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|len
op_assign
id|slash
id|name
suffix:semicolon
r_if
c_cond
(paren
id|rmdir
c_func
(paren
id|name
)paren
op_ne
l_int|0
)paren
r_break
suffix:semicolon
)brace
id|free
c_func
(paren
id|dirs
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* General TODO: unC99ify the code: no declaration after code */
multiline_comment|/* General TODO: no javaIfiCation: rename updateCache to update_cache */
multiline_comment|/*&n; * TODO: once we no longer call external programs, we&squot;d probably be better of&n; * not setting / getting the environment variable GIT_INDEX_FILE all the time.&n; */
DECL|function|remove_file
r_int
id|remove_file
c_func
(paren
r_int
id|clean
comma
r_const
r_char
op_star
id|path
)paren
(brace
r_int
id|updateCache
op_assign
id|index_only
op_logical_or
id|clean
suffix:semicolon
r_int
id|updateWd
op_assign
op_logical_neg
id|index_only
suffix:semicolon
r_if
c_cond
(paren
id|updateCache
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cache_dirty
)paren
id|read_cache_from
c_func
(paren
id|getenv
c_func
(paren
l_string|&quot;GIT_INDEX_FILE&quot;
)paren
)paren
suffix:semicolon
id|cache_dirty
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|remove_file_from_cache
c_func
(paren
id|path
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|updateWd
)paren
(brace
id|unlink
c_func
(paren
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|errno
op_ne
id|ENOENT
op_logical_or
id|errno
op_ne
id|EISDIR
)paren
r_return
l_int|1
suffix:semicolon
id|remove_path
c_func
(paren
id|path
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|unique_path
r_static
r_char
op_star
id|unique_path
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_const
r_char
op_star
id|branch
)paren
(brace
r_char
op_star
id|newpath
op_assign
id|xmalloc
c_func
(paren
id|strlen
c_func
(paren
id|path
)paren
op_plus
l_int|1
op_plus
id|strlen
c_func
(paren
id|branch
)paren
op_plus
l_int|8
op_plus
l_int|1
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|newpath
comma
id|path
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|newpath
comma
l_string|&quot;~&quot;
)paren
suffix:semicolon
r_char
op_star
id|p
op_assign
id|newpath
op_plus
id|strlen
c_func
(paren
id|newpath
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|p
comma
id|branch
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
op_star
id|p
suffix:semicolon
op_increment
id|p
)paren
r_if
c_cond
(paren
l_char|&squot;/&squot;
op_eq
op_star
id|p
)paren
op_star
id|p
op_assign
l_char|&squot;_&squot;
suffix:semicolon
r_int
id|suffix
op_assign
l_int|0
suffix:semicolon
r_struct
id|stat
id|st
suffix:semicolon
r_while
c_loop
(paren
id|path_list_has_path
c_func
(paren
op_amp
id|currentFileSet
comma
id|newpath
)paren
op_logical_or
id|path_list_has_path
c_func
(paren
op_amp
id|currentDirectorySet
comma
id|newpath
)paren
op_logical_or
id|lstat
c_func
(paren
id|newpath
comma
op_amp
id|st
)paren
op_eq
l_int|0
)paren
(brace
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;_%d&quot;
comma
id|suffix
op_increment
)paren
suffix:semicolon
)brace
id|path_list_insert
c_func
(paren
id|newpath
comma
op_amp
id|currentFileSet
)paren
suffix:semicolon
r_return
id|newpath
suffix:semicolon
)brace
multiline_comment|/*&n; * TODO: except for create_last, this so looks like&n; * safe_create_leading_directories().&n; */
DECL|function|mkdir_p
r_static
r_int
id|mkdir_p
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_int
r_int
id|mode
comma
r_int
id|create_last
)paren
(brace
r_char
op_star
id|buf
op_assign
id|strdup
c_func
(paren
id|path
)paren
suffix:semicolon
r_char
op_star
id|p
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|buf
suffix:semicolon
op_star
id|p
suffix:semicolon
op_increment
id|p
)paren
(brace
r_if
c_cond
(paren
op_star
id|p
op_ne
l_char|&squot;/&squot;
)paren
r_continue
suffix:semicolon
op_star
id|p
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|mkdir
c_func
(paren
id|buf
comma
id|mode
)paren
)paren
(brace
r_int
id|e
op_assign
id|errno
suffix:semicolon
r_if
c_cond
(paren
id|e
op_eq
id|EEXIST
)paren
(brace
r_struct
id|stat
id|st
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stat
c_func
(paren
id|buf
comma
op_amp
id|st
)paren
op_logical_and
id|S_ISDIR
c_func
(paren
id|st.st_mode
)paren
)paren
r_goto
id|next
suffix:semicolon
multiline_comment|/* ok */
id|errno
op_assign
id|e
suffix:semicolon
)brace
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|next
suffix:colon
op_star
id|p
op_assign
l_char|&squot;/&squot;
suffix:semicolon
)brace
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|create_last
op_logical_and
id|mkdir
c_func
(paren
id|path
comma
id|mode
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|flush_buffer
r_static
r_void
id|flush_buffer
c_func
(paren
r_int
id|fd
comma
r_const
r_char
op_star
id|buf
comma
r_int
r_int
id|size
)paren
(brace
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
r_int
id|ret
op_assign
id|xwrite
c_func
(paren
id|fd
comma
id|buf
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
multiline_comment|/* Ignore epipe */
r_if
c_cond
(paren
id|errno
op_eq
id|EPIPE
)paren
r_break
suffix:semicolon
id|die
c_func
(paren
l_string|&quot;merge-recursive: %s&quot;
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
id|die
c_func
(paren
l_string|&quot;merge-recursive: disk full?&quot;
)paren
suffix:semicolon
)brace
id|size
op_sub_assign
id|ret
suffix:semicolon
id|buf
op_add_assign
id|ret
suffix:semicolon
)brace
)brace
multiline_comment|/* General TODO: reindent according to guide lines (no if ( blabla )) */
DECL|function|update_file_flags
r_void
id|update_file_flags
c_func
(paren
r_const
r_int
r_char
op_star
id|sha
comma
r_int
id|mode
comma
r_const
r_char
op_star
id|path
comma
r_int
id|updateCache
comma
r_int
id|updateWd
)paren
(brace
r_if
c_cond
(paren
id|index_only
)paren
id|updateWd
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|updateWd
)paren
(brace
r_char
id|type
(braket
l_int|20
)braket
suffix:semicolon
r_void
op_star
id|buf
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
id|buf
op_assign
id|read_sha1_file
c_func
(paren
id|sha
comma
id|type
comma
op_amp
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
id|die
c_func
(paren
l_string|&quot;cannot read object %s &squot;%s&squot;&quot;
comma
id|sha1_to_hex
c_func
(paren
id|sha
)paren
comma
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|type
comma
id|blob_type
)paren
op_ne
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;blob expected for %s &squot;%s&squot;&quot;
comma
id|sha1_to_hex
c_func
(paren
id|sha
)paren
comma
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|mode
)paren
)paren
(brace
r_if
c_cond
(paren
id|mkdir_p
c_func
(paren
id|path
comma
l_int|0777
comma
l_int|0
multiline_comment|/* don&squot;t create last element */
)paren
)paren
id|die
c_func
(paren
l_string|&quot;failed to create path %s: %s&quot;
comma
id|path
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
id|unlink
c_func
(paren
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mode
op_amp
l_int|0100
)paren
id|mode
op_assign
l_int|0777
suffix:semicolon
r_else
id|mode
op_assign
l_int|0666
suffix:semicolon
r_int
id|fd
op_assign
id|open
c_func
(paren
id|path
comma
id|O_WRONLY
op_or
id|O_TRUNC
op_or
id|O_CREAT
comma
id|mode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;failed to open %s: %s&quot;
comma
id|path
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
id|flush_buffer
c_func
(paren
id|fd
comma
id|buf
comma
id|size
)paren
suffix:semicolon
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISLNK
c_func
(paren
id|mode
)paren
)paren
(brace
r_char
op_star
id|linkTarget
op_assign
id|malloc
c_func
(paren
id|size
op_plus
l_int|1
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|linkTarget
comma
id|buf
comma
id|size
)paren
suffix:semicolon
id|linkTarget
(braket
id|size
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|mkdir_p
c_func
(paren
id|path
comma
l_int|0777
comma
l_int|0
)paren
suffix:semicolon
id|symlink
c_func
(paren
id|linkTarget
comma
id|path
)paren
suffix:semicolon
)brace
r_else
id|die
c_func
(paren
l_string|&quot;do not know what to do with %06o %s &squot;%s&squot;&quot;
comma
id|mode
comma
id|sha1_to_hex
c_func
(paren
id|sha
)paren
comma
id|path
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|updateCache
)paren
id|add_cacheinfo
c_func
(paren
id|mode
comma
id|sha
comma
id|path
comma
l_int|0
comma
id|updateWd
comma
id|ADD_CACHE_OK_TO_ADD
)paren
suffix:semicolon
)brace
multiline_comment|/* TODO: is this often used? if not, do direct call */
DECL|function|update_file
r_void
id|update_file
c_func
(paren
r_int
id|clean
comma
r_const
r_int
r_char
op_star
id|sha
comma
r_int
id|mode
comma
r_const
r_char
op_star
id|path
)paren
(brace
id|update_file_flags
c_func
(paren
id|sha
comma
id|mode
comma
id|path
comma
id|index_only
op_logical_or
id|clean
comma
op_logical_neg
id|index_only
)paren
suffix:semicolon
)brace
multiline_comment|/* Low level file merging, update and removal */
DECL|struct|merge_file_info
r_struct
id|merge_file_info
(brace
DECL|member|sha
r_int
r_char
id|sha
(braket
l_int|20
)braket
suffix:semicolon
DECL|member|mode
r_int
id|mode
suffix:semicolon
DECL|member|clean
r_int
id|clean
suffix:colon
l_int|1
comma
DECL|member|merge
id|merge
suffix:colon
l_int|1
suffix:semicolon
)brace
suffix:semicolon
DECL|function|git_unpack_file
r_static
r_char
op_star
id|git_unpack_file
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
comma
r_char
op_star
id|path
)paren
(brace
r_void
op_star
id|buf
suffix:semicolon
r_char
id|type
(braket
l_int|20
)braket
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_int
id|fd
suffix:semicolon
id|buf
op_assign
id|read_sha1_file
c_func
(paren
id|sha1
comma
id|type
comma
op_amp
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
op_logical_or
id|strcmp
c_func
(paren
id|type
comma
id|blob_type
)paren
)paren
id|die
c_func
(paren
l_string|&quot;unable to read blob object %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|path
comma
l_string|&quot;.merge_file_XXXXXX&quot;
)paren
suffix:semicolon
id|fd
op_assign
id|mkstemp
c_func
(paren
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;unable to create temp-file&quot;
)paren
suffix:semicolon
id|flush_buffer
c_func
(paren
id|fd
comma
id|buf
comma
id|size
)paren
suffix:semicolon
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
r_return
id|path
suffix:semicolon
)brace
multiline_comment|/*&n; * TODO: the signature would be much more efficient using stage_data&n; */
DECL|function|merge_file
r_static
r_struct
id|merge_file_info
id|merge_file
c_func
(paren
r_const
r_char
op_star
id|oPath
comma
r_const
r_int
r_char
op_star
id|oSha
comma
r_int
id|oMode
comma
r_const
r_char
op_star
id|aPath
comma
r_const
r_int
r_char
op_star
id|aSha
comma
r_int
id|aMode
comma
r_const
r_char
op_star
id|bPath
comma
r_const
r_int
r_char
op_star
id|bSha
comma
r_int
id|bMode
comma
r_const
r_char
op_star
id|branch1Name
comma
r_const
r_char
op_star
id|branch2Name
)paren
(brace
r_struct
id|merge_file_info
id|result
suffix:semicolon
id|result.merge
op_assign
l_int|0
suffix:semicolon
id|result.clean
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|S_IFMT
op_amp
id|aMode
)paren
op_ne
(paren
id|S_IFMT
op_amp
id|bMode
)paren
)paren
(brace
id|result.clean
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|aMode
)paren
)paren
(brace
id|result.mode
op_assign
id|aMode
suffix:semicolon
id|memcpy
c_func
(paren
id|result.sha
comma
id|aSha
comma
l_int|20
)paren
suffix:semicolon
)brace
r_else
(brace
id|result.mode
op_assign
id|bMode
suffix:semicolon
id|memcpy
c_func
(paren
id|result.sha
comma
id|bSha
comma
l_int|20
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|aSha
comma
id|oSha
comma
l_int|20
)paren
op_ne
l_int|0
op_logical_and
id|memcmp
c_func
(paren
id|bSha
comma
id|oSha
comma
l_int|20
)paren
op_ne
l_int|0
)paren
id|result.merge
op_assign
l_int|1
suffix:semicolon
id|result.mode
op_assign
id|aMode
op_eq
id|oMode
ques
c_cond
id|bMode
suffix:colon
id|aMode
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|aSha
comma
id|oSha
comma
l_int|20
)paren
op_eq
l_int|0
)paren
id|memcpy
c_func
(paren
id|result.sha
comma
id|bSha
comma
l_int|20
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|bSha
comma
id|oSha
comma
l_int|20
)paren
op_eq
l_int|0
)paren
id|memcpy
c_func
(paren
id|result.sha
comma
id|aSha
comma
l_int|20
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|aMode
)paren
)paren
(brace
r_int
id|code
op_assign
l_int|1
suffix:semicolon
r_char
id|orig
(braket
id|PATH_MAX
)braket
suffix:semicolon
r_char
id|src1
(braket
id|PATH_MAX
)braket
suffix:semicolon
r_char
id|src2
(braket
id|PATH_MAX
)braket
suffix:semicolon
id|git_unpack_file
c_func
(paren
id|oSha
comma
id|orig
)paren
suffix:semicolon
id|git_unpack_file
c_func
(paren
id|aSha
comma
id|src1
)paren
suffix:semicolon
id|git_unpack_file
c_func
(paren
id|bSha
comma
id|src2
)paren
suffix:semicolon
r_const
r_char
op_star
id|argv
(braket
)braket
op_assign
(brace
l_string|&quot;merge&quot;
comma
l_string|&quot;-L&quot;
comma
l_int|NULL
comma
l_string|&quot;-L&quot;
comma
l_int|NULL
comma
l_string|&quot;-L&quot;
comma
l_int|NULL
comma
id|src1
comma
id|orig
comma
id|src2
comma
l_int|NULL
)brace
suffix:semicolon
r_char
op_star
id|la
comma
op_star
id|lb
comma
op_star
id|lo
suffix:semicolon
id|argv
(braket
l_int|2
)braket
op_assign
id|la
op_assign
id|strdup
c_func
(paren
id|mkpath
c_func
(paren
l_string|&quot;%s/%s&quot;
comma
id|branch1Name
comma
id|aPath
)paren
)paren
suffix:semicolon
id|argv
(braket
l_int|6
)braket
op_assign
id|lb
op_assign
id|strdup
c_func
(paren
id|mkpath
c_func
(paren
l_string|&quot;%s/%s&quot;
comma
id|branch2Name
comma
id|bPath
)paren
)paren
suffix:semicolon
id|argv
(braket
l_int|4
)braket
op_assign
id|lo
op_assign
id|strdup
c_func
(paren
id|mkpath
c_func
(paren
l_string|&quot;orig/%s&quot;
comma
id|oPath
)paren
)paren
suffix:semicolon
macro_line|#if 0
id|printf
c_func
(paren
l_string|&quot;%s %s %s %s %s %s %s %s %s %s&bslash;n&quot;
comma
id|argv
(braket
l_int|0
)braket
comma
id|argv
(braket
l_int|1
)braket
comma
id|argv
(braket
l_int|2
)braket
comma
id|argv
(braket
l_int|3
)braket
comma
id|argv
(braket
l_int|4
)braket
comma
id|argv
(braket
l_int|5
)braket
comma
id|argv
(braket
l_int|6
)braket
comma
id|argv
(braket
l_int|7
)braket
comma
id|argv
(braket
l_int|8
)braket
comma
id|argv
(braket
l_int|9
)braket
)paren
suffix:semicolon
macro_line|#endif
id|code
op_assign
id|run_command_v
c_func
(paren
l_int|10
comma
id|argv
)paren
suffix:semicolon
id|free
c_func
(paren
id|la
)paren
suffix:semicolon
id|free
c_func
(paren
id|lb
)paren
suffix:semicolon
id|free
c_func
(paren
id|lo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|code
op_logical_and
id|code
OL
l_int|256
)paren
(brace
id|die
c_func
(paren
l_string|&quot;Failed to execute &squot;merge&squot;. merge(1) is used as the &quot;
l_string|&quot;file-level merge tool. Is &squot;merge&squot; in your path?&quot;
)paren
suffix:semicolon
)brace
r_struct
id|stat
id|st
suffix:semicolon
r_int
id|fd
op_assign
id|open
c_func
(paren
id|src1
comma
id|O_RDONLY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
op_logical_or
id|fstat
c_func
(paren
id|fd
comma
op_amp
id|st
)paren
OL
l_int|0
op_logical_or
id|index_fd
c_func
(paren
id|result.sha
comma
id|fd
comma
op_amp
id|st
comma
l_int|1
comma
l_string|&quot;blob&quot;
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Unable to add %s to database&quot;
comma
id|src1
)paren
suffix:semicolon
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
id|unlink
c_func
(paren
id|orig
)paren
suffix:semicolon
id|unlink
c_func
(paren
id|src1
)paren
suffix:semicolon
id|unlink
c_func
(paren
id|src2
)paren
suffix:semicolon
id|result.clean
op_assign
id|WEXITSTATUS
c_func
(paren
id|code
)paren
op_eq
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|S_ISLNK
c_func
(paren
id|aMode
)paren
op_logical_or
id|S_ISLNK
c_func
(paren
id|bMode
)paren
)paren
)paren
id|die
c_func
(paren
l_string|&quot;cannot merge modes?&quot;
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|result.sha
comma
id|aSha
comma
l_int|20
)paren
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|aSha
comma
id|bSha
comma
l_int|20
)paren
op_ne
l_int|0
)paren
id|result.clean
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_return
id|result
suffix:semicolon
)brace
DECL|function|conflict_rename_rename
r_static
r_void
id|conflict_rename_rename
c_func
(paren
r_struct
id|rename
op_star
id|ren1
comma
r_const
r_char
op_star
id|branch1
comma
r_struct
id|rename
op_star
id|ren2
comma
r_const
r_char
op_star
id|branch2
)paren
(brace
r_char
op_star
id|del
(braket
l_int|2
)braket
suffix:semicolon
r_int
id|delp
op_assign
l_int|0
suffix:semicolon
r_const
r_char
op_star
id|ren1_dst
op_assign
id|ren1-&gt;pair-&gt;two-&gt;path
suffix:semicolon
r_const
r_char
op_star
id|ren2_dst
op_assign
id|ren2-&gt;pair-&gt;two-&gt;path
suffix:semicolon
r_const
r_char
op_star
id|dstName1
op_assign
id|ren1_dst
suffix:semicolon
r_const
r_char
op_star
id|dstName2
op_assign
id|ren2_dst
suffix:semicolon
r_if
c_cond
(paren
id|path_list_has_path
c_func
(paren
op_amp
id|currentDirectorySet
comma
id|ren1_dst
)paren
)paren
(brace
id|dstName1
op_assign
id|del
(braket
id|delp
op_increment
)braket
op_assign
id|unique_path
c_func
(paren
id|ren1_dst
comma
id|branch1
)paren
suffix:semicolon
id|output
c_func
(paren
l_string|&quot;%s is a directory in %s adding as %s instead&quot;
comma
id|ren1_dst
comma
id|branch2
comma
id|dstName1
)paren
suffix:semicolon
id|remove_file
c_func
(paren
l_int|0
comma
id|ren1_dst
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|path_list_has_path
c_func
(paren
op_amp
id|currentDirectorySet
comma
id|ren2_dst
)paren
)paren
(brace
id|dstName2
op_assign
id|del
(braket
id|delp
op_increment
)braket
op_assign
id|unique_path
c_func
(paren
id|ren2_dst
comma
id|branch2
)paren
suffix:semicolon
id|output
c_func
(paren
l_string|&quot;%s is a directory in %s adding as %s instead&quot;
comma
id|ren2_dst
comma
id|branch1
comma
id|dstName2
)paren
suffix:semicolon
id|remove_file
c_func
(paren
l_int|0
comma
id|ren2_dst
)paren
suffix:semicolon
)brace
id|update_stages
c_func
(paren
id|dstName1
comma
l_int|NULL
comma
l_int|0
comma
id|ren1-&gt;pair-&gt;two-&gt;sha1
comma
id|ren1-&gt;pair-&gt;two-&gt;mode
comma
l_int|NULL
comma
l_int|0
comma
l_int|1
multiline_comment|/* clear */
)paren
suffix:semicolon
id|update_stages
c_func
(paren
id|dstName2
comma
l_int|NULL
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ren2-&gt;pair-&gt;two-&gt;sha1
comma
id|ren2-&gt;pair-&gt;two-&gt;mode
comma
l_int|1
multiline_comment|/* clear */
)paren
suffix:semicolon
r_while
c_loop
(paren
id|delp
op_decrement
)paren
id|free
c_func
(paren
id|del
(braket
id|delp
)braket
)paren
suffix:semicolon
)brace
DECL|function|conflict_rename_dir
r_static
r_void
id|conflict_rename_dir
c_func
(paren
r_struct
id|rename
op_star
id|ren1
comma
r_const
r_char
op_star
id|branch1
)paren
(brace
r_char
op_star
id|newPath
op_assign
id|unique_path
c_func
(paren
id|ren1-&gt;pair-&gt;two-&gt;path
comma
id|branch1
)paren
suffix:semicolon
id|output
c_func
(paren
l_string|&quot;Renaming %s to %s instead&quot;
comma
id|ren1-&gt;pair-&gt;one-&gt;path
comma
id|newPath
)paren
suffix:semicolon
id|remove_file
c_func
(paren
l_int|0
comma
id|ren1-&gt;pair-&gt;two-&gt;path
)paren
suffix:semicolon
id|update_file
c_func
(paren
l_int|0
comma
id|ren1-&gt;pair-&gt;two-&gt;sha1
comma
id|ren1-&gt;pair-&gt;two-&gt;mode
comma
id|newPath
)paren
suffix:semicolon
id|free
c_func
(paren
id|newPath
)paren
suffix:semicolon
)brace
DECL|function|conflict_rename_rename_2
r_static
r_void
id|conflict_rename_rename_2
c_func
(paren
r_struct
id|rename
op_star
id|ren1
comma
r_const
r_char
op_star
id|branch1
comma
r_struct
id|rename
op_star
id|ren2
comma
r_const
r_char
op_star
id|branch2
)paren
(brace
r_char
op_star
id|newPath1
op_assign
id|unique_path
c_func
(paren
id|ren1-&gt;pair-&gt;two-&gt;path
comma
id|branch1
)paren
suffix:semicolon
r_char
op_star
id|newPath2
op_assign
id|unique_path
c_func
(paren
id|ren2-&gt;pair-&gt;two-&gt;path
comma
id|branch2
)paren
suffix:semicolon
id|output
c_func
(paren
l_string|&quot;Renaming %s to %s and %s to %s instead&quot;
comma
id|ren1-&gt;pair-&gt;one-&gt;path
comma
id|newPath1
comma
id|ren2-&gt;pair-&gt;one-&gt;path
comma
id|newPath2
)paren
suffix:semicolon
id|remove_file
c_func
(paren
l_int|0
comma
id|ren1-&gt;pair-&gt;two-&gt;path
)paren
suffix:semicolon
id|update_file
c_func
(paren
l_int|0
comma
id|ren1-&gt;pair-&gt;two-&gt;sha1
comma
id|ren1-&gt;pair-&gt;two-&gt;mode
comma
id|newPath1
)paren
suffix:semicolon
id|update_file
c_func
(paren
l_int|0
comma
id|ren2-&gt;pair-&gt;two-&gt;sha1
comma
id|ren2-&gt;pair-&gt;two-&gt;mode
comma
id|newPath2
)paren
suffix:semicolon
id|free
c_func
(paren
id|newPath2
)paren
suffix:semicolon
id|free
c_func
(paren
id|newPath1
)paren
suffix:semicolon
)brace
multiline_comment|/* General TODO: get rid of all the debug messages */
DECL|function|process_renames
r_static
r_int
id|process_renames
c_func
(paren
r_struct
id|path_list
op_star
id|renamesA
comma
r_struct
id|path_list
op_star
id|renamesB
comma
r_const
r_char
op_star
id|branchNameA
comma
r_const
r_char
op_star
id|branchNameB
)paren
(brace
r_int
id|cleanMerge
op_assign
l_int|1
comma
id|i
suffix:semicolon
r_struct
id|path_list
id|srcNames
op_assign
(brace
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
id|byDstA
op_assign
(brace
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
id|byDstB
op_assign
(brace
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_const
r_struct
id|rename
op_star
id|sre
suffix:semicolon
multiline_comment|/*&n;&t; * TODO: think about a saner way to do this.&n;&t; * Since both renamesA and renamesB are sorted, it should&n;&t; * be much more efficient to traverse both simultaneously,&n;&t; * only byDstA and byDstB should be needed.&n;&t; */
id|debug
c_func
(paren
l_string|&quot;processRenames...&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|renamesA-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sre
op_assign
id|renamesA-&gt;items
(braket
id|i
)braket
dot
id|util
suffix:semicolon
id|path_list_insert
c_func
(paren
id|sre-&gt;pair-&gt;one-&gt;path
comma
op_amp
id|srcNames
)paren
suffix:semicolon
id|path_list_insert
c_func
(paren
id|sre-&gt;pair-&gt;two-&gt;path
comma
op_amp
id|byDstA
)paren
op_member_access_from_pointer
id|util
op_assign
id|sre-&gt;dst_entry
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|renamesB-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sre
op_assign
id|renamesB-&gt;items
(braket
id|i
)braket
dot
id|util
suffix:semicolon
id|path_list_insert
c_func
(paren
id|sre-&gt;pair-&gt;one-&gt;path
comma
op_amp
id|srcNames
)paren
suffix:semicolon
id|path_list_insert
c_func
(paren
id|sre-&gt;pair-&gt;two-&gt;path
comma
op_amp
id|byDstB
)paren
op_member_access_from_pointer
id|util
op_assign
id|sre-&gt;dst_entry
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|srcNames.nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_char
op_star
id|src
op_assign
id|srcNames.items
(braket
id|i
)braket
dot
id|path
suffix:semicolon
r_struct
id|path_list
op_star
id|renames1
comma
op_star
id|renames2
comma
op_star
id|renames2Dst
suffix:semicolon
r_struct
id|rename
op_star
id|ren1
comma
op_star
id|ren2
suffix:semicolon
r_const
r_char
op_star
id|branchName1
comma
op_star
id|branchName2
suffix:semicolon
id|ren1
op_assign
id|find_rename_bysrc
c_func
(paren
id|renamesA
comma
id|src
)paren
suffix:semicolon
id|ren2
op_assign
id|find_rename_bysrc
c_func
(paren
id|renamesB
comma
id|src
)paren
suffix:semicolon
multiline_comment|/* TODO: refactor, so that 1/2 are not needed */
r_if
c_cond
(paren
id|ren1
)paren
(brace
id|renames1
op_assign
id|renamesA
suffix:semicolon
id|renames2
op_assign
id|renamesB
suffix:semicolon
id|renames2Dst
op_assign
op_amp
id|byDstB
suffix:semicolon
id|branchName1
op_assign
id|branchNameA
suffix:semicolon
id|branchName2
op_assign
id|branchNameB
suffix:semicolon
)brace
r_else
(brace
id|renames1
op_assign
id|renamesB
suffix:semicolon
id|renames2
op_assign
id|renamesA
suffix:semicolon
id|renames2Dst
op_assign
op_amp
id|byDstA
suffix:semicolon
id|branchName1
op_assign
id|branchNameB
suffix:semicolon
id|branchName2
op_assign
id|branchNameA
suffix:semicolon
r_struct
id|rename
op_star
id|tmp
op_assign
id|ren2
suffix:semicolon
id|ren2
op_assign
id|ren1
suffix:semicolon
id|ren1
op_assign
id|tmp
suffix:semicolon
)brace
id|ren1-&gt;dst_entry-&gt;processed
op_assign
l_int|1
suffix:semicolon
id|ren1-&gt;src_entry-&gt;processed
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ren1-&gt;processed
)paren
r_continue
suffix:semicolon
id|ren1-&gt;processed
op_assign
l_int|1
suffix:semicolon
r_const
r_char
op_star
id|ren1_src
op_assign
id|ren1-&gt;pair-&gt;one-&gt;path
suffix:semicolon
r_const
r_char
op_star
id|ren1_dst
op_assign
id|ren1-&gt;pair-&gt;two-&gt;path
suffix:semicolon
r_if
c_cond
(paren
id|ren2
)paren
(brace
r_const
r_char
op_star
id|ren2_src
op_assign
id|ren2-&gt;pair-&gt;one-&gt;path
suffix:semicolon
r_const
r_char
op_star
id|ren2_dst
op_assign
id|ren2-&gt;pair-&gt;two-&gt;path
suffix:semicolon
multiline_comment|/* Renamed in 1 and renamed in 2 */
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|ren1_src
comma
id|ren2_src
)paren
op_ne
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;ren1.src != ren2.src&quot;
)paren
suffix:semicolon
id|ren2-&gt;dst_entry-&gt;processed
op_assign
l_int|1
suffix:semicolon
id|ren2-&gt;processed
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|ren1_dst
comma
id|ren2_dst
)paren
op_ne
l_int|0
)paren
(brace
id|cleanMerge
op_assign
l_int|0
suffix:semicolon
id|output
c_func
(paren
l_string|&quot;CONFLICT (rename/rename): &quot;
l_string|&quot;Rename %s-&gt;%s in branch %s &quot;
l_string|&quot;rename %s-&gt;%s in %s&quot;
comma
id|src
comma
id|ren1_dst
comma
id|branchName1
comma
id|src
comma
id|ren2_dst
comma
id|branchName2
)paren
suffix:semicolon
id|conflict_rename_rename
c_func
(paren
id|ren1
comma
id|branchName1
comma
id|ren2
comma
id|branchName2
)paren
suffix:semicolon
)brace
r_else
(brace
id|remove_file
c_func
(paren
l_int|1
comma
id|ren1_src
)paren
suffix:semicolon
r_struct
id|merge_file_info
id|mfi
suffix:semicolon
id|mfi
op_assign
id|merge_file
c_func
(paren
id|ren1_src
comma
id|ren1-&gt;pair-&gt;one-&gt;sha1
comma
id|ren1-&gt;pair-&gt;one-&gt;mode
comma
id|ren1_dst
comma
id|ren1-&gt;pair-&gt;two-&gt;sha1
comma
id|ren1-&gt;pair-&gt;two-&gt;mode
comma
id|ren2_dst
comma
id|ren2-&gt;pair-&gt;two-&gt;sha1
comma
id|ren2-&gt;pair-&gt;two-&gt;mode
comma
id|branchName1
comma
id|branchName2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mfi.merge
op_logical_or
op_logical_neg
id|mfi.clean
)paren
id|output
c_func
(paren
l_string|&quot;Renaming %s-&gt;%s&quot;
comma
id|src
comma
id|ren1_dst
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mfi.merge
)paren
id|output
c_func
(paren
l_string|&quot;Auto-merging %s&quot;
comma
id|ren1_dst
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mfi.clean
)paren
(brace
id|output
c_func
(paren
l_string|&quot;CONFLICT (content): merge conflict in %s&quot;
comma
id|ren1_dst
)paren
suffix:semicolon
id|cleanMerge
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|index_only
)paren
id|update_stages
c_func
(paren
id|ren1_dst
comma
id|ren1-&gt;pair-&gt;one-&gt;sha1
comma
id|ren1-&gt;pair-&gt;one-&gt;mode
comma
id|ren1-&gt;pair-&gt;two-&gt;sha1
comma
id|ren1-&gt;pair-&gt;two-&gt;mode
comma
id|ren2-&gt;pair-&gt;two-&gt;sha1
comma
id|ren2-&gt;pair-&gt;two-&gt;mode
comma
l_int|1
multiline_comment|/* clear */
)paren
suffix:semicolon
)brace
id|update_file
c_func
(paren
id|mfi.clean
comma
id|mfi.sha
comma
id|mfi.mode
comma
id|ren1_dst
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Renamed in 1, maybe changed in 2 */
id|remove_file
c_func
(paren
l_int|1
comma
id|ren1_src
)paren
suffix:semicolon
r_int
r_char
id|srcShaOtherBranch
(braket
l_int|20
)braket
comma
id|dstShaOtherBranch
(braket
l_int|20
)braket
suffix:semicolon
r_int
id|srcModeOtherBranch
comma
id|dstModeOtherBranch
suffix:semicolon
r_int
id|stage
op_assign
id|renamesA
op_eq
id|renames1
ques
c_cond
l_int|3
suffix:colon
l_int|2
suffix:semicolon
id|memcpy
c_func
(paren
id|srcShaOtherBranch
comma
id|ren1-&gt;src_entry-&gt;stages
(braket
id|stage
)braket
dot
id|sha
comma
l_int|20
)paren
suffix:semicolon
id|srcModeOtherBranch
op_assign
id|ren1-&gt;src_entry-&gt;stages
(braket
id|stage
)braket
dot
id|mode
suffix:semicolon
id|memcpy
c_func
(paren
id|dstShaOtherBranch
comma
id|ren1-&gt;dst_entry-&gt;stages
(braket
id|stage
)braket
dot
id|sha
comma
l_int|20
)paren
suffix:semicolon
id|dstModeOtherBranch
op_assign
id|ren1-&gt;dst_entry-&gt;stages
(braket
id|stage
)braket
dot
id|mode
suffix:semicolon
r_int
id|tryMerge
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|newPath
suffix:semicolon
r_if
c_cond
(paren
id|path_list_has_path
c_func
(paren
op_amp
id|currentDirectorySet
comma
id|ren1_dst
)paren
)paren
(brace
id|cleanMerge
op_assign
l_int|0
suffix:semicolon
id|output
c_func
(paren
l_string|&quot;CONFLICT (rename/directory): Rename %s-&gt;%s in %s &quot;
l_string|&quot; directory %s added in %s&quot;
comma
id|ren1_src
comma
id|ren1_dst
comma
id|branchName1
comma
id|ren1_dst
comma
id|branchName2
)paren
suffix:semicolon
id|conflict_rename_dir
c_func
(paren
id|ren1
comma
id|branchName1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|srcShaOtherBranch
comma
id|null_sha1
comma
l_int|20
)paren
op_eq
l_int|0
)paren
(brace
id|cleanMerge
op_assign
l_int|0
suffix:semicolon
id|output
c_func
(paren
l_string|&quot;CONFLICT (rename/delete): Rename %s-&gt;%s in %s &quot;
l_string|&quot;and deleted in %s&quot;
comma
id|ren1_src
comma
id|ren1_dst
comma
id|branchName1
comma
id|branchName2
)paren
suffix:semicolon
id|update_file
c_func
(paren
l_int|0
comma
id|ren1-&gt;pair-&gt;two-&gt;sha1
comma
id|ren1-&gt;pair-&gt;two-&gt;mode
comma
id|ren1_dst
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|dstShaOtherBranch
comma
id|null_sha1
comma
l_int|20
)paren
op_ne
l_int|0
)paren
(brace
id|cleanMerge
op_assign
l_int|0
suffix:semicolon
id|tryMerge
op_assign
l_int|1
suffix:semicolon
id|output
c_func
(paren
l_string|&quot;CONFLICT (rename/add): Rename %s-&gt;%s in %s. &quot;
l_string|&quot;%s added in %s&quot;
comma
id|ren1_src
comma
id|ren1_dst
comma
id|branchName1
comma
id|ren1_dst
comma
id|branchName2
)paren
suffix:semicolon
id|newPath
op_assign
id|unique_path
c_func
(paren
id|ren1_dst
comma
id|branchName2
)paren
suffix:semicolon
id|output
c_func
(paren
l_string|&quot;Adding as %s instead&quot;
comma
id|newPath
)paren
suffix:semicolon
id|update_file
c_func
(paren
l_int|0
comma
id|dstShaOtherBranch
comma
id|dstModeOtherBranch
comma
id|newPath
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|ren2
op_assign
id|find_rename_bysrc
c_func
(paren
id|renames2Dst
comma
id|ren1_dst
)paren
)paren
)paren
(brace
id|cleanMerge
op_assign
l_int|0
suffix:semicolon
id|ren2-&gt;processed
op_assign
l_int|1
suffix:semicolon
id|output
c_func
(paren
l_string|&quot;CONFLICT (rename/rename): Rename %s-&gt;%s in %s. &quot;
l_string|&quot;Rename %s-&gt;%s in %s&quot;
comma
id|ren1_src
comma
id|ren1_dst
comma
id|branchName1
comma
id|ren2-&gt;pair-&gt;one-&gt;path
comma
id|ren2-&gt;pair-&gt;two-&gt;path
comma
id|branchName2
)paren
suffix:semicolon
id|conflict_rename_rename_2
c_func
(paren
id|ren1
comma
id|branchName1
comma
id|ren2
comma
id|branchName2
)paren
suffix:semicolon
)brace
r_else
id|tryMerge
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|tryMerge
)paren
(brace
r_const
r_char
op_star
id|oname
op_assign
id|ren1_src
suffix:semicolon
r_const
r_char
op_star
id|aname
op_assign
id|ren1_dst
suffix:semicolon
r_const
r_char
op_star
id|bname
op_assign
id|ren1_src
suffix:semicolon
r_int
r_char
id|osha
(braket
l_int|20
)braket
comma
id|asha
(braket
l_int|20
)braket
comma
id|bsha
(braket
l_int|20
)braket
suffix:semicolon
r_int
id|omode
op_assign
id|ren1-&gt;pair-&gt;one-&gt;mode
suffix:semicolon
r_int
id|amode
op_assign
id|ren1-&gt;pair-&gt;two-&gt;mode
suffix:semicolon
r_int
id|bmode
op_assign
id|srcModeOtherBranch
suffix:semicolon
id|memcpy
c_func
(paren
id|osha
comma
id|ren1-&gt;pair-&gt;one-&gt;sha1
comma
l_int|20
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|asha
comma
id|ren1-&gt;pair-&gt;two-&gt;sha1
comma
l_int|20
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|bsha
comma
id|srcShaOtherBranch
comma
l_int|20
)paren
suffix:semicolon
r_const
r_char
op_star
id|aBranch
op_assign
id|branchName1
suffix:semicolon
r_const
r_char
op_star
id|bBranch
op_assign
id|branchName2
suffix:semicolon
r_if
c_cond
(paren
id|renamesA
op_ne
id|renames1
)paren
(brace
id|memswp
c_func
(paren
op_amp
id|aname
comma
op_amp
id|bname
comma
r_sizeof
(paren
id|aname
)paren
)paren
suffix:semicolon
id|memswp
c_func
(paren
id|asha
comma
id|bsha
comma
l_int|20
)paren
suffix:semicolon
id|memswp
c_func
(paren
op_amp
id|aBranch
comma
op_amp
id|bBranch
comma
r_sizeof
(paren
id|aBranch
)paren
)paren
suffix:semicolon
)brace
r_struct
id|merge_file_info
id|mfi
suffix:semicolon
id|mfi
op_assign
id|merge_file
c_func
(paren
id|oname
comma
id|osha
comma
id|omode
comma
id|aname
comma
id|asha
comma
id|amode
comma
id|bname
comma
id|bsha
comma
id|bmode
comma
id|aBranch
comma
id|bBranch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mfi.merge
op_logical_or
op_logical_neg
id|mfi.clean
)paren
id|output
c_func
(paren
l_string|&quot;Renaming %s =&gt; %s&quot;
comma
id|ren1_src
comma
id|ren1_dst
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mfi.merge
)paren
id|output
c_func
(paren
l_string|&quot;Auto-merging %s&quot;
comma
id|ren1_dst
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mfi.clean
)paren
(brace
id|output
c_func
(paren
l_string|&quot;CONFLICT (rename/modify): Merge conflict in %s&quot;
comma
id|ren1_dst
)paren
suffix:semicolon
id|cleanMerge
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|index_only
)paren
id|update_stages
c_func
(paren
id|ren1_dst
comma
id|osha
comma
id|omode
comma
id|asha
comma
id|amode
comma
id|bsha
comma
id|bmode
comma
l_int|1
multiline_comment|/* clear */
)paren
suffix:semicolon
)brace
id|update_file
c_func
(paren
id|mfi.clean
comma
id|mfi.sha
comma
id|mfi.mode
comma
id|ren1_dst
)paren
suffix:semicolon
)brace
)brace
)brace
id|path_list_clear
c_func
(paren
op_amp
id|srcNames
comma
l_int|0
)paren
suffix:semicolon
id|debug
c_func
(paren
l_string|&quot;  processRenames done&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cache_dirty
)paren
id|flush_cache
c_func
(paren
)paren
suffix:semicolon
r_return
id|cleanMerge
suffix:semicolon
)brace
DECL|function|has_sha
r_static
r_int
r_char
op_star
id|has_sha
c_func
(paren
r_const
r_int
r_char
op_star
id|sha
)paren
(brace
r_return
id|memcmp
c_func
(paren
id|sha
comma
id|null_sha1
comma
l_int|20
)paren
op_eq
l_int|0
ques
c_cond
l_int|NULL
suffix:colon
(paren
r_int
r_char
op_star
)paren
id|sha
suffix:semicolon
)brace
multiline_comment|/* Per entry merge function */
DECL|function|process_entry
r_static
r_int
id|process_entry
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_struct
id|stage_data
op_star
id|entry
comma
r_const
r_char
op_star
id|branch1Name
comma
r_const
r_char
op_star
id|branch2Name
)paren
(brace
multiline_comment|/*&n;&t;printf(&quot;processing entry, clean cache: %s&bslash;n&quot;, index_only ? &quot;yes&quot;: &quot;no&quot;);&n;&t;print_index_entry(&quot;&bslash;tpath: &quot;, entry);&n;&t;*/
r_int
id|cleanMerge
op_assign
l_int|1
suffix:semicolon
r_int
r_char
op_star
id|oSha
op_assign
id|has_sha
c_func
(paren
id|entry-&gt;stages
(braket
l_int|1
)braket
dot
id|sha
)paren
suffix:semicolon
r_int
r_char
op_star
id|aSha
op_assign
id|has_sha
c_func
(paren
id|entry-&gt;stages
(braket
l_int|2
)braket
dot
id|sha
)paren
suffix:semicolon
r_int
r_char
op_star
id|bSha
op_assign
id|has_sha
c_func
(paren
id|entry-&gt;stages
(braket
l_int|3
)braket
dot
id|sha
)paren
suffix:semicolon
r_int
id|oMode
op_assign
id|entry-&gt;stages
(braket
l_int|1
)braket
dot
id|mode
suffix:semicolon
r_int
id|aMode
op_assign
id|entry-&gt;stages
(braket
l_int|2
)braket
dot
id|mode
suffix:semicolon
r_int
id|bMode
op_assign
id|entry-&gt;stages
(braket
l_int|3
)braket
dot
id|mode
suffix:semicolon
r_if
c_cond
(paren
id|oSha
op_logical_and
(paren
op_logical_neg
id|aSha
op_logical_or
op_logical_neg
id|bSha
)paren
)paren
(brace
multiline_comment|/* Case A: Deleted in one */
r_if
c_cond
(paren
(paren
op_logical_neg
id|aSha
op_logical_and
op_logical_neg
id|bSha
)paren
op_logical_or
(paren
id|sha_eq
c_func
(paren
id|aSha
comma
id|oSha
)paren
op_logical_and
op_logical_neg
id|bSha
)paren
op_logical_or
(paren
op_logical_neg
id|aSha
op_logical_and
id|sha_eq
c_func
(paren
id|bSha
comma
id|oSha
)paren
)paren
)paren
(brace
multiline_comment|/* Deleted in both or deleted in one and&n;&t;&t;&t; * unchanged in the other */
r_if
c_cond
(paren
id|aSha
)paren
id|output
c_func
(paren
l_string|&quot;Removing %s&quot;
comma
id|path
)paren
suffix:semicolon
id|remove_file
c_func
(paren
l_int|1
comma
id|path
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Deleted in one and changed in the other */
id|cleanMerge
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|aSha
)paren
(brace
id|output
c_func
(paren
l_string|&quot;CONFLICT (delete/modify): %s deleted in %s &quot;
l_string|&quot;and modified in %s. Version %s of %s left in tree.&quot;
comma
id|path
comma
id|branch1Name
comma
id|branch2Name
comma
id|branch2Name
comma
id|path
)paren
suffix:semicolon
id|update_file
c_func
(paren
l_int|0
comma
id|bSha
comma
id|bMode
comma
id|path
)paren
suffix:semicolon
)brace
r_else
(brace
id|output
c_func
(paren
l_string|&quot;CONFLICT (delete/modify): %s deleted in %s &quot;
l_string|&quot;and modified in %s. Version %s of %s left in tree.&quot;
comma
id|path
comma
id|branch2Name
comma
id|branch1Name
comma
id|branch1Name
comma
id|path
)paren
suffix:semicolon
id|update_file
c_func
(paren
l_int|0
comma
id|aSha
comma
id|aMode
comma
id|path
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
op_logical_neg
id|oSha
op_logical_and
id|aSha
op_logical_and
op_logical_neg
id|bSha
)paren
op_logical_or
(paren
op_logical_neg
id|oSha
op_logical_and
op_logical_neg
id|aSha
op_logical_and
id|bSha
)paren
)paren
(brace
multiline_comment|/* Case B: Added in one. */
r_const
r_char
op_star
id|addBranch
suffix:semicolon
r_const
r_char
op_star
id|otherBranch
suffix:semicolon
r_int
id|mode
suffix:semicolon
r_const
r_int
r_char
op_star
id|sha
suffix:semicolon
r_const
r_char
op_star
id|conf
suffix:semicolon
r_if
c_cond
(paren
id|aSha
)paren
(brace
id|addBranch
op_assign
id|branch1Name
suffix:semicolon
id|otherBranch
op_assign
id|branch2Name
suffix:semicolon
id|mode
op_assign
id|aMode
suffix:semicolon
id|sha
op_assign
id|aSha
suffix:semicolon
id|conf
op_assign
l_string|&quot;file/directory&quot;
suffix:semicolon
)brace
r_else
(brace
id|addBranch
op_assign
id|branch2Name
suffix:semicolon
id|otherBranch
op_assign
id|branch1Name
suffix:semicolon
id|mode
op_assign
id|bMode
suffix:semicolon
id|sha
op_assign
id|bSha
suffix:semicolon
id|conf
op_assign
l_string|&quot;directory/file&quot;
suffix:semicolon
)brace
r_if
c_cond
(paren
id|path_list_has_path
c_func
(paren
op_amp
id|currentDirectorySet
comma
id|path
)paren
)paren
(brace
id|cleanMerge
op_assign
l_int|0
suffix:semicolon
r_const
r_char
op_star
id|newPath
op_assign
id|unique_path
c_func
(paren
id|path
comma
id|addBranch
)paren
suffix:semicolon
id|output
c_func
(paren
l_string|&quot;CONFLICT (%s): There is a directory with name %s in %s. &quot;
l_string|&quot;Adding %s as %s&quot;
comma
id|conf
comma
id|path
comma
id|otherBranch
comma
id|path
comma
id|newPath
)paren
suffix:semicolon
id|remove_file
c_func
(paren
l_int|0
comma
id|path
)paren
suffix:semicolon
id|update_file
c_func
(paren
l_int|0
comma
id|sha
comma
id|mode
comma
id|newPath
)paren
suffix:semicolon
)brace
r_else
(brace
id|output
c_func
(paren
l_string|&quot;Adding %s&quot;
comma
id|path
)paren
suffix:semicolon
id|update_file
c_func
(paren
l_int|1
comma
id|sha
comma
id|mode
comma
id|path
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|oSha
op_logical_and
id|aSha
op_logical_and
id|bSha
)paren
(brace
multiline_comment|/* Case C: Added in both (check for same permissions). */
r_if
c_cond
(paren
id|sha_eq
c_func
(paren
id|aSha
comma
id|bSha
)paren
)paren
(brace
r_if
c_cond
(paren
id|aMode
op_ne
id|bMode
)paren
(brace
id|cleanMerge
op_assign
l_int|0
suffix:semicolon
id|output
c_func
(paren
l_string|&quot;CONFLICT: File %s added identically in both branches, &quot;
l_string|&quot;but permissions conflict %06o-&gt;%06o&quot;
comma
id|path
comma
id|aMode
comma
id|bMode
)paren
suffix:semicolon
id|output
c_func
(paren
l_string|&quot;CONFLICT: adding with permission: %06o&quot;
comma
id|aMode
)paren
suffix:semicolon
id|update_file
c_func
(paren
l_int|0
comma
id|aSha
comma
id|aMode
comma
id|path
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* This case is handled by git-read-tree */
m_assert
(paren
l_int|0
op_logical_and
l_string|&quot;This case must be handled by git-read-tree&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|cleanMerge
op_assign
l_int|0
suffix:semicolon
r_const
r_char
op_star
id|newPath1
op_assign
id|unique_path
c_func
(paren
id|path
comma
id|branch1Name
)paren
suffix:semicolon
r_const
r_char
op_star
id|newPath2
op_assign
id|unique_path
c_func
(paren
id|path
comma
id|branch2Name
)paren
suffix:semicolon
id|output
c_func
(paren
l_string|&quot;CONFLICT (add/add): File %s added non-identically &quot;
l_string|&quot;in both branches. Adding as %s and %s instead.&quot;
comma
id|path
comma
id|newPath1
comma
id|newPath2
)paren
suffix:semicolon
id|remove_file
c_func
(paren
l_int|0
comma
id|path
)paren
suffix:semicolon
id|update_file
c_func
(paren
l_int|0
comma
id|aSha
comma
id|aMode
comma
id|newPath1
)paren
suffix:semicolon
id|update_file
c_func
(paren
l_int|0
comma
id|bSha
comma
id|bMode
comma
id|newPath2
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|oSha
op_logical_and
id|aSha
op_logical_and
id|bSha
)paren
(brace
multiline_comment|/* case D: Modified in both, but differently. */
id|output
c_func
(paren
l_string|&quot;Auto-merging %s&quot;
comma
id|path
)paren
suffix:semicolon
r_struct
id|merge_file_info
id|mfi
suffix:semicolon
id|mfi
op_assign
id|merge_file
c_func
(paren
id|path
comma
id|oSha
comma
id|oMode
comma
id|path
comma
id|aSha
comma
id|aMode
comma
id|path
comma
id|bSha
comma
id|bMode
comma
id|branch1Name
comma
id|branch2Name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mfi.clean
)paren
id|update_file
c_func
(paren
l_int|1
comma
id|mfi.sha
comma
id|mfi.mode
comma
id|path
)paren
suffix:semicolon
r_else
(brace
id|cleanMerge
op_assign
l_int|0
suffix:semicolon
id|output
c_func
(paren
l_string|&quot;CONFLICT (content): Merge conflict in %s&quot;
comma
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index_only
)paren
id|update_file
c_func
(paren
l_int|0
comma
id|mfi.sha
comma
id|mfi.mode
comma
id|path
)paren
suffix:semicolon
r_else
id|update_file_flags
c_func
(paren
id|mfi.sha
comma
id|mfi.mode
comma
id|path
comma
l_int|0
multiline_comment|/* updateCache */
comma
l_int|1
multiline_comment|/* updateWd */
)paren
suffix:semicolon
)brace
)brace
r_else
id|die
c_func
(paren
l_string|&quot;Fatal merge failure, shouldn&squot;t happen.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cache_dirty
)paren
id|flush_cache
c_func
(paren
)paren
suffix:semicolon
r_return
id|cleanMerge
suffix:semicolon
)brace
DECL|function|merge_trees
r_static
r_struct
id|merge_tree_result
id|merge_trees
c_func
(paren
r_struct
id|tree
op_star
id|head
comma
r_struct
id|tree
op_star
id|merge
comma
r_struct
id|tree
op_star
id|common
comma
r_const
r_char
op_star
id|branch1Name
comma
r_const
r_char
op_star
id|branch2Name
)paren
(brace
r_int
id|code
suffix:semicolon
r_struct
id|merge_tree_result
id|result
op_assign
(brace
l_int|NULL
comma
l_int|0
)brace
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|common-&gt;object.sha1
comma
id|merge-&gt;object.sha1
comma
l_int|20
)paren
)paren
(brace
id|output
c_func
(paren
l_string|&quot;Already uptodate!&quot;
)paren
suffix:semicolon
id|result.tree
op_assign
id|head
suffix:semicolon
id|result.clean
op_assign
l_int|1
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
id|debug
c_func
(paren
l_string|&quot;merge_trees ...&bslash;n&quot;
)paren
suffix:semicolon
id|code
op_assign
id|git_merge_trees
c_func
(paren
id|index_only
ques
c_cond
l_string|&quot;-i&quot;
suffix:colon
l_string|&quot;-u&quot;
comma
id|common
comma
id|head
comma
id|merge
)paren
suffix:semicolon
r_if
c_cond
(paren
id|code
op_ne
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;merging of trees %s and %s failed&quot;
comma
id|sha1_to_hex
c_func
(paren
id|head-&gt;object.sha1
)paren
comma
id|sha1_to_hex
c_func
(paren
id|merge-&gt;object.sha1
)paren
)paren
suffix:semicolon
id|result.tree
op_assign
id|git_write_tree
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result.tree
)paren
(brace
id|path_list_clear
c_func
(paren
op_amp
id|currentFileSet
comma
l_int|1
)paren
suffix:semicolon
id|path_list_clear
c_func
(paren
op_amp
id|currentDirectorySet
comma
l_int|1
)paren
suffix:semicolon
id|get_files_dirs
c_func
(paren
id|head
comma
op_amp
id|currentFileSet
comma
op_amp
id|currentDirectorySet
)paren
suffix:semicolon
id|get_files_dirs
c_func
(paren
id|merge
comma
op_amp
id|currentFileSet
comma
op_amp
id|currentDirectorySet
)paren
suffix:semicolon
r_struct
id|path_list
op_star
id|entries
op_assign
id|get_unmerged
c_func
(paren
)paren
suffix:semicolon
r_struct
id|path_list
op_star
id|re_head
comma
op_star
id|re_merge
suffix:semicolon
id|re_head
op_assign
id|get_renames
c_func
(paren
id|head
comma
id|common
comma
id|head
comma
id|merge
comma
id|entries
)paren
suffix:semicolon
id|re_merge
op_assign
id|get_renames
c_func
(paren
id|merge
comma
id|common
comma
id|head
comma
id|merge
comma
id|entries
)paren
suffix:semicolon
id|result.clean
op_assign
id|process_renames
c_func
(paren
id|re_head
comma
id|re_merge
comma
id|branch1Name
comma
id|branch2Name
)paren
suffix:semicolon
id|debug
c_func
(paren
l_string|&quot;&bslash;tprocessing entries...&bslash;n&quot;
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|entries-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_char
op_star
id|path
op_assign
id|entries-&gt;items
(braket
id|i
)braket
dot
id|path
suffix:semicolon
r_struct
id|stage_data
op_star
id|e
op_assign
id|entries-&gt;items
(braket
id|i
)braket
dot
id|util
suffix:semicolon
r_if
c_cond
(paren
id|e-&gt;processed
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|process_entry
c_func
(paren
id|path
comma
id|e
comma
id|branch1Name
comma
id|branch2Name
)paren
)paren
id|result.clean
op_assign
l_int|0
suffix:semicolon
)brace
id|free_rename_entries
c_func
(paren
op_amp
id|re_merge
)paren
suffix:semicolon
id|free_rename_entries
c_func
(paren
op_amp
id|re_head
)paren
suffix:semicolon
id|free_index_entries
c_func
(paren
op_amp
id|entries
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result.clean
op_logical_or
id|index_only
)paren
id|result.tree
op_assign
id|git_write_tree
c_func
(paren
)paren
suffix:semicolon
r_else
id|result.tree
op_assign
l_int|NULL
suffix:semicolon
id|debug
c_func
(paren
l_string|&quot;&bslash;t  processing entries done&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|result.clean
op_assign
l_int|1
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;merging of trees %s and %s resulted in %s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|head-&gt;object.sha1
)paren
comma
id|sha1_to_hex
c_func
(paren
id|merge-&gt;object.sha1
)paren
comma
id|sha1_to_hex
c_func
(paren
id|result.tree-&gt;object.sha1
)paren
)paren
suffix:semicolon
)brace
id|debug
c_func
(paren
l_string|&quot;  merge_trees done&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * Merge the commits h1 and h2, return the resulting virtual&n; * commit object and a flag indicating the cleaness of the merge.&n; */
r_static
DECL|function|merge
r_struct
id|merge_result
id|merge
c_func
(paren
r_struct
id|commit
op_star
id|h1
comma
r_struct
id|commit
op_star
id|h2
comma
r_const
r_char
op_star
id|branch1Name
comma
r_const
r_char
op_star
id|branch2Name
comma
r_int
id|callDepth
multiline_comment|/* =0 */
comma
r_struct
id|commit
op_star
id|ancestor
multiline_comment|/* =None */
)paren
(brace
r_struct
id|merge_result
id|result
op_assign
(brace
l_int|NULL
comma
l_int|0
)brace
suffix:semicolon
r_const
r_char
op_star
id|msg
suffix:semicolon
r_int
id|msglen
suffix:semicolon
r_struct
id|commit_list
op_star
id|ca
op_assign
l_int|NULL
comma
op_star
id|iter
suffix:semicolon
r_struct
id|commit
op_star
id|mergedCA
suffix:semicolon
r_struct
id|merge_tree_result
id|mtr
suffix:semicolon
id|output
c_func
(paren
l_string|&quot;Merging:&quot;
)paren
suffix:semicolon
id|msg
op_assign
id|commit_title
c_func
(paren
id|h1
comma
op_amp
id|msglen
)paren
suffix:semicolon
multiline_comment|/* TODO: refactor. we always show the sha1 with the title */
id|output
c_func
(paren
l_string|&quot;%s %.*s&quot;
comma
id|commit_hex_sha1
c_func
(paren
id|h1
)paren
comma
id|msglen
comma
id|msg
)paren
suffix:semicolon
id|msg
op_assign
id|commit_title
c_func
(paren
id|h2
comma
op_amp
id|msglen
)paren
suffix:semicolon
id|output
c_func
(paren
l_string|&quot;%s %.*s&quot;
comma
id|commit_hex_sha1
c_func
(paren
id|h2
)paren
comma
id|msglen
comma
id|msg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ancestor
)paren
id|commit_list_insert
c_func
(paren
id|ancestor
comma
op_amp
id|ca
)paren
suffix:semicolon
r_else
id|ca
op_assign
id|get_merge_bases
c_func
(paren
id|h1
comma
id|h2
comma
l_int|1
)paren
suffix:semicolon
id|output
c_func
(paren
l_string|&quot;found %u common ancestor(s):&quot;
comma
id|commit_list_count
c_func
(paren
id|ca
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|iter
op_assign
id|ca
suffix:semicolon
id|iter
suffix:semicolon
id|iter
op_assign
id|iter-&gt;next
)paren
(brace
id|msg
op_assign
id|commit_title
c_func
(paren
id|iter-&gt;item
comma
op_amp
id|msglen
)paren
suffix:semicolon
id|output
c_func
(paren
l_string|&quot;%s %.*s&quot;
comma
id|commit_hex_sha1
c_func
(paren
id|iter-&gt;item
)paren
comma
id|msglen
comma
id|msg
)paren
suffix:semicolon
)brace
id|mergedCA
op_assign
id|pop_commit
c_func
(paren
op_amp
id|ca
)paren
suffix:semicolon
multiline_comment|/* TODO: what happens when merge with virtual commits fails? */
r_for
c_loop
(paren
id|iter
op_assign
id|ca
suffix:semicolon
id|iter
suffix:semicolon
id|iter
op_assign
id|iter-&gt;next
)paren
(brace
id|output_indent
op_assign
id|callDepth
op_plus
l_int|1
suffix:semicolon
id|result
op_assign
id|merge
c_func
(paren
id|mergedCA
comma
id|iter-&gt;item
comma
l_string|&quot;Temporary merge branch 1&quot;
comma
l_string|&quot;Temporary merge branch 2&quot;
comma
id|callDepth
op_plus
l_int|1
comma
l_int|NULL
)paren
suffix:semicolon
id|mergedCA
op_assign
id|result.commit
suffix:semicolon
id|output_indent
op_assign
id|callDepth
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mergedCA
)paren
id|die
c_func
(paren
l_string|&quot;merge returned no commit&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|callDepth
op_eq
l_int|0
)paren
(brace
id|setup_index
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|index_only
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|setup_index
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|git_read_tree
c_func
(paren
id|h1-&gt;tree
)paren
suffix:semicolon
id|index_only
op_assign
l_int|1
suffix:semicolon
)brace
id|mtr
op_assign
id|merge_trees
c_func
(paren
id|h1-&gt;tree
comma
id|h2-&gt;tree
comma
id|mergedCA-&gt;tree
comma
id|branch1Name
comma
id|branch2Name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ancestor
op_logical_and
(paren
id|mtr.clean
op_logical_or
id|index_only
)paren
)paren
(brace
id|result.commit
op_assign
id|make_virtual_commit
c_func
(paren
id|mtr.tree
comma
l_string|&quot;merged tree&quot;
)paren
suffix:semicolon
id|commit_list_insert
c_func
(paren
id|h1
comma
op_amp
id|result.commit-&gt;parents
)paren
suffix:semicolon
id|commit_list_insert
c_func
(paren
id|h2
comma
op_amp
id|result.commit-&gt;parents-&gt;next
)paren
suffix:semicolon
)brace
r_else
id|result.commit
op_assign
l_int|NULL
suffix:semicolon
id|result.clean
op_assign
id|mtr.clean
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|get_ref
r_static
r_struct
id|commit
op_star
id|get_ref
c_func
(paren
r_const
r_char
op_star
id|ref
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_struct
id|object
op_star
id|object
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1
c_func
(paren
id|ref
comma
id|sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Could not resolve ref &squot;%s&squot;&quot;
comma
id|ref
)paren
suffix:semicolon
id|object
op_assign
id|deref_tag
c_func
(paren
id|parse_object
c_func
(paren
id|sha1
)paren
comma
id|ref
comma
id|strlen
c_func
(paren
id|ref
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|object-&gt;type
op_ne
id|TYPE_COMMIT
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|parse_commit
c_func
(paren
(paren
r_struct
id|commit
op_star
)paren
id|object
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Could not parse commit &squot;%s&squot;&quot;
comma
id|sha1_to_hex
c_func
(paren
id|object-&gt;sha1
)paren
)paren
suffix:semicolon
r_return
(paren
r_struct
id|commit
op_star
)paren
id|object
suffix:semicolon
)brace
DECL|function|main
r_int
id|main
c_func
(paren
r_int
id|argc
comma
r_char
op_star
id|argv
(braket
)braket
)paren
(brace
r_static
r_const
r_char
op_star
id|bases
(braket
l_int|2
)braket
suffix:semicolon
r_static
r_int
id|bases_count
op_assign
l_int|0
suffix:semicolon
id|original_index_file
op_assign
id|getenv
c_func
(paren
l_string|&quot;GIT_INDEX_FILE&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|original_index_file
)paren
id|original_index_file
op_assign
id|strdup
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;index&quot;
)paren
)paren
suffix:semicolon
id|temporary_index_file
op_assign
id|strdup
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;mrg-rcrsv-tmp-idx&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|argc
OL
l_int|4
)paren
id|die
c_func
(paren
l_string|&quot;Usage: %s &lt;base&gt;... -- &lt;head&gt; &lt;remote&gt; ...&bslash;n&quot;
comma
id|argv
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|argc
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|argv
(braket
id|i
)braket
comma
l_string|&quot;--&quot;
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|bases_count
OL
r_sizeof
(paren
id|bases
)paren
op_div
r_sizeof
(paren
op_star
id|bases
)paren
)paren
id|bases
(braket
id|bases_count
op_increment
)braket
op_assign
id|argv
(braket
id|i
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|argc
id|i
op_ne
l_int|3
)paren
multiline_comment|/* &quot;--&quot; &quot;&lt;head&gt;&quot; &quot;&lt;remote&gt;&quot; */
id|die
c_func
(paren
l_string|&quot;Not handling anything other than two heads merge.&quot;
)paren
suffix:semicolon
r_const
r_char
op_star
id|branch1
comma
op_star
id|branch2
suffix:semicolon
id|branch1
op_assign
id|argv
(braket
op_increment
id|i
)braket
suffix:semicolon
id|branch2
op_assign
id|argv
(braket
op_increment
id|i
)braket
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Merging %s with %s&bslash;n&quot;
comma
id|branch1
comma
id|branch2
)paren
suffix:semicolon
r_struct
id|merge_result
id|result
suffix:semicolon
r_struct
id|commit
op_star
id|h1
op_assign
id|get_ref
c_func
(paren
id|branch1
)paren
suffix:semicolon
r_struct
id|commit
op_star
id|h2
op_assign
id|get_ref
c_func
(paren
id|branch2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bases_count
op_eq
l_int|1
)paren
(brace
r_struct
id|commit
op_star
id|ancestor
op_assign
id|get_ref
c_func
(paren
id|bases
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|result
op_assign
id|merge
c_func
(paren
id|h1
comma
id|h2
comma
id|branch1
comma
id|branch2
comma
l_int|0
comma
id|ancestor
)paren
suffix:semicolon
)brace
r_else
id|result
op_assign
id|merge
c_func
(paren
id|h1
comma
id|h2
comma
id|branch1
comma
id|branch2
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cache_dirty
)paren
id|flush_cache
c_func
(paren
)paren
suffix:semicolon
r_return
id|result.clean
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;vim: sw=8 noet&n;*/
eof
