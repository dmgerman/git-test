multiline_comment|/*&n; * Recursive Merge algorithm stolen from git-merge-recursive.py by&n; * Fredrik Kuivinen.&n; * The thieves were Alex Riesen and Johannes Schindelin, in June/July 2006&n; */
macro_line|#include &quot;advice.h&quot;
macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;cache-tree.h&quot;
macro_line|#include &quot;commit.h&quot;
macro_line|#include &quot;blob.h&quot;
macro_line|#include &quot;builtin.h&quot;
macro_line|#include &quot;tree-walk.h&quot;
macro_line|#include &quot;diff.h&quot;
macro_line|#include &quot;diffcore.h&quot;
macro_line|#include &quot;tag.h&quot;
macro_line|#include &quot;unpack-trees.h&quot;
macro_line|#include &quot;string-list.h&quot;
macro_line|#include &quot;xdiff-interface.h&quot;
macro_line|#include &quot;ll-merge.h&quot;
macro_line|#include &quot;attr.h&quot;
macro_line|#include &quot;merge-recursive.h&quot;
macro_line|#include &quot;dir.h&quot;
macro_line|#include &quot;submodule.h&quot;
DECL|function|shift_tree_object
r_static
r_struct
id|tree
op_star
id|shift_tree_object
c_func
(paren
r_struct
id|tree
op_star
id|one
comma
r_struct
id|tree
op_star
id|two
comma
r_const
r_char
op_star
id|subtree_shift
)paren
(brace
r_int
r_char
id|shifted
(braket
l_int|20
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|subtree_shift
)paren
(brace
id|shift_tree
c_func
(paren
id|one-&gt;object.sha1
comma
id|two-&gt;object.sha1
comma
id|shifted
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|shift_tree_by
c_func
(paren
id|one-&gt;object.sha1
comma
id|two-&gt;object.sha1
comma
id|shifted
comma
id|subtree_shift
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|hashcmp
c_func
(paren
id|two-&gt;object.sha1
comma
id|shifted
)paren
)paren
r_return
id|two
suffix:semicolon
r_return
id|lookup_tree
c_func
(paren
id|shifted
)paren
suffix:semicolon
)brace
DECL|function|make_virtual_commit
r_static
r_struct
id|commit
op_star
id|make_virtual_commit
c_func
(paren
r_struct
id|tree
op_star
id|tree
comma
r_const
r_char
op_star
id|comment
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
id|alloc_commit_node
c_func
(paren
)paren
suffix:semicolon
r_struct
id|merge_remote_desc
op_star
id|desc
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|desc
)paren
)paren
suffix:semicolon
id|desc-&gt;name
op_assign
id|comment
suffix:semicolon
id|desc-&gt;obj
op_assign
(paren
r_struct
id|object
op_star
)paren
id|commit
suffix:semicolon
id|commit-&gt;tree
op_assign
id|tree
suffix:semicolon
id|commit-&gt;util
op_assign
id|desc
suffix:semicolon
id|commit-&gt;object.parsed
op_assign
l_int|1
suffix:semicolon
r_return
id|commit
suffix:semicolon
)brace
multiline_comment|/*&n; * Since we use get_tree_entry(), which does not put the read object into&n; * the object pool, we cannot rely on a == b.&n; */
DECL|function|sha_eq
r_static
r_int
id|sha_eq
c_func
(paren
r_const
r_int
r_char
op_star
id|a
comma
r_const
r_int
r_char
op_star
id|b
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|a
op_logical_and
op_logical_neg
id|b
)paren
r_return
l_int|2
suffix:semicolon
r_return
id|a
op_logical_and
id|b
op_logical_and
id|hashcmp
c_func
(paren
id|a
comma
id|b
)paren
op_eq
l_int|0
suffix:semicolon
)brace
DECL|enum|rename_type
r_enum
id|rename_type
(brace
DECL|enumerator|RENAME_NORMAL
id|RENAME_NORMAL
op_assign
l_int|0
comma
DECL|enumerator|RENAME_DELETE
id|RENAME_DELETE
comma
DECL|enumerator|RENAME_ONE_FILE_TO_ONE
id|RENAME_ONE_FILE_TO_ONE
comma
DECL|enumerator|RENAME_ONE_FILE_TO_TWO
id|RENAME_ONE_FILE_TO_TWO
comma
DECL|enumerator|RENAME_TWO_FILES_TO_ONE
id|RENAME_TWO_FILES_TO_ONE
)brace
suffix:semicolon
DECL|struct|rename_conflict_info
r_struct
id|rename_conflict_info
(brace
DECL|member|rename_type
r_enum
id|rename_type
id|rename_type
suffix:semicolon
DECL|member|pair1
r_struct
id|diff_filepair
op_star
id|pair1
suffix:semicolon
DECL|member|pair2
r_struct
id|diff_filepair
op_star
id|pair2
suffix:semicolon
DECL|member|branch1
r_const
r_char
op_star
id|branch1
suffix:semicolon
DECL|member|branch2
r_const
r_char
op_star
id|branch2
suffix:semicolon
DECL|member|dst_entry1
r_struct
id|stage_data
op_star
id|dst_entry1
suffix:semicolon
DECL|member|dst_entry2
r_struct
id|stage_data
op_star
id|dst_entry2
suffix:semicolon
DECL|member|ren1_other
r_struct
id|diff_filespec
id|ren1_other
suffix:semicolon
DECL|member|ren2_other
r_struct
id|diff_filespec
id|ren2_other
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Since we want to write the index eventually, we cannot reuse the index&n; * for these (temporary) data.&n; */
DECL|struct|stage_data
r_struct
id|stage_data
(brace
r_struct
(brace
DECL|member|mode
r_int
id|mode
suffix:semicolon
DECL|member|sha
r_int
r_char
id|sha
(braket
l_int|20
)braket
suffix:semicolon
DECL|member|stages
)brace
id|stages
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|rename_conflict_info
r_struct
id|rename_conflict_info
op_star
id|rename_conflict_info
suffix:semicolon
DECL|member|processed
r_int
id|processed
suffix:colon
l_int|1
suffix:semicolon
)brace
suffix:semicolon
DECL|function|setup_rename_conflict_info
r_static
r_inline
r_void
id|setup_rename_conflict_info
c_func
(paren
r_enum
id|rename_type
id|rename_type
comma
r_struct
id|diff_filepair
op_star
id|pair1
comma
r_struct
id|diff_filepair
op_star
id|pair2
comma
r_const
r_char
op_star
id|branch1
comma
r_const
r_char
op_star
id|branch2
comma
r_struct
id|stage_data
op_star
id|dst_entry1
comma
r_struct
id|stage_data
op_star
id|dst_entry2
comma
r_struct
id|merge_options
op_star
id|o
comma
r_struct
id|stage_data
op_star
id|src_entry1
comma
r_struct
id|stage_data
op_star
id|src_entry2
)paren
(brace
r_struct
id|rename_conflict_info
op_star
id|ci
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|rename_conflict_info
)paren
)paren
suffix:semicolon
id|ci-&gt;rename_type
op_assign
id|rename_type
suffix:semicolon
id|ci-&gt;pair1
op_assign
id|pair1
suffix:semicolon
id|ci-&gt;branch1
op_assign
id|branch1
suffix:semicolon
id|ci-&gt;branch2
op_assign
id|branch2
suffix:semicolon
id|ci-&gt;dst_entry1
op_assign
id|dst_entry1
suffix:semicolon
id|dst_entry1-&gt;rename_conflict_info
op_assign
id|ci
suffix:semicolon
id|dst_entry1-&gt;processed
op_assign
l_int|0
suffix:semicolon
m_assert
(paren
op_logical_neg
id|pair2
op_eq
op_logical_neg
id|dst_entry2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dst_entry2
)paren
(brace
id|ci-&gt;dst_entry2
op_assign
id|dst_entry2
suffix:semicolon
id|ci-&gt;pair2
op_assign
id|pair2
suffix:semicolon
id|dst_entry2-&gt;rename_conflict_info
op_assign
id|ci
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rename_type
op_eq
id|RENAME_TWO_FILES_TO_ONE
)paren
(brace
multiline_comment|/*&n;&t;&t; * For each rename, there could have been&n;&t;&t; * modifications on the side of history where that&n;&t;&t; * file was not renamed.&n;&t;&t; */
r_int
id|ostage1
op_assign
id|o-&gt;branch1
op_eq
id|branch1
ques
c_cond
l_int|3
suffix:colon
l_int|2
suffix:semicolon
r_int
id|ostage2
op_assign
id|ostage1
op_xor
l_int|1
suffix:semicolon
id|ci-&gt;ren1_other.path
op_assign
id|pair1-&gt;one-&gt;path
suffix:semicolon
id|hashcpy
c_func
(paren
id|ci-&gt;ren1_other.sha1
comma
id|src_entry1-&gt;stages
(braket
id|ostage1
)braket
dot
id|sha
)paren
suffix:semicolon
id|ci-&gt;ren1_other.mode
op_assign
id|src_entry1-&gt;stages
(braket
id|ostage1
)braket
dot
id|mode
suffix:semicolon
id|ci-&gt;ren2_other.path
op_assign
id|pair2-&gt;one-&gt;path
suffix:semicolon
id|hashcpy
c_func
(paren
id|ci-&gt;ren2_other.sha1
comma
id|src_entry2-&gt;stages
(braket
id|ostage2
)braket
dot
id|sha
)paren
suffix:semicolon
id|ci-&gt;ren2_other.mode
op_assign
id|src_entry2-&gt;stages
(braket
id|ostage2
)braket
dot
id|mode
suffix:semicolon
)brace
)brace
DECL|function|show
r_static
r_int
id|show
c_func
(paren
r_struct
id|merge_options
op_star
id|o
comma
r_int
id|v
)paren
(brace
r_return
(paren
op_logical_neg
id|o-&gt;call_depth
op_logical_and
id|o-&gt;verbosity
op_ge
id|v
)paren
op_logical_or
id|o-&gt;verbosity
op_ge
l_int|5
suffix:semicolon
)brace
DECL|function|flush_output
r_static
r_void
id|flush_output
c_func
(paren
r_struct
id|merge_options
op_star
id|o
)paren
(brace
r_if
c_cond
(paren
id|o-&gt;obuf.len
)paren
(brace
id|fputs
c_func
(paren
id|o-&gt;obuf.buf
comma
id|stdout
)paren
suffix:semicolon
id|strbuf_reset
c_func
(paren
op_amp
id|o-&gt;obuf
)paren
suffix:semicolon
)brace
)brace
id|__attribute__
c_func
(paren
(paren
id|format
(paren
id|printf
comma
l_int|3
comma
l_int|4
)paren
)paren
)paren
DECL|function|output
r_static
r_void
id|output
c_func
(paren
r_struct
id|merge_options
op_star
id|o
comma
r_int
id|v
comma
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
id|va_list
id|ap
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|show
c_func
(paren
id|o
comma
id|v
)paren
)paren
r_return
suffix:semicolon
id|strbuf_grow
c_func
(paren
op_amp
id|o-&gt;obuf
comma
id|o-&gt;call_depth
op_star
l_int|2
op_plus
l_int|2
)paren
suffix:semicolon
id|memset
c_func
(paren
id|o-&gt;obuf.buf
op_plus
id|o-&gt;obuf.len
comma
l_char|&squot; &squot;
comma
id|o-&gt;call_depth
op_star
l_int|2
)paren
suffix:semicolon
id|strbuf_setlen
c_func
(paren
op_amp
id|o-&gt;obuf
comma
id|o-&gt;obuf.len
op_plus
id|o-&gt;call_depth
op_star
l_int|2
)paren
suffix:semicolon
id|va_start
c_func
(paren
id|ap
comma
id|fmt
)paren
suffix:semicolon
id|strbuf_vaddf
c_func
(paren
op_amp
id|o-&gt;obuf
comma
id|fmt
comma
id|ap
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|ap
)paren
suffix:semicolon
id|strbuf_addch
c_func
(paren
op_amp
id|o-&gt;obuf
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|o-&gt;buffer_output
)paren
id|flush_output
c_func
(paren
id|o
)paren
suffix:semicolon
)brace
DECL|function|output_commit_title
r_static
r_void
id|output_commit_title
c_func
(paren
r_struct
id|merge_options
op_star
id|o
comma
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_int
id|i
suffix:semicolon
id|flush_output
c_func
(paren
id|o
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|o-&gt;call_depth
suffix:semicolon
id|i
op_decrement
suffix:semicolon
)paren
id|fputs
c_func
(paren
l_string|&quot;  &quot;
comma
id|stdout
)paren
suffix:semicolon
r_if
c_cond
(paren
id|commit-&gt;util
)paren
id|printf
c_func
(paren
l_string|&quot;virtual %s&bslash;n&quot;
comma
id|merge_remote_util
c_func
(paren
id|commit
)paren
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
r_else
(brace
id|printf
c_func
(paren
l_string|&quot;%s &quot;
comma
id|find_unique_abbrev
c_func
(paren
id|commit-&gt;object.sha1
comma
id|DEFAULT_ABBREV
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parse_commit
c_func
(paren
id|commit
)paren
op_ne
l_int|0
)paren
id|printf
c_func
(paren
id|_
c_func
(paren
l_string|&quot;(bad commit)&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_else
(brace
r_const
r_char
op_star
id|title
suffix:semicolon
r_const
r_char
op_star
id|msg
op_assign
id|get_commit_buffer
c_func
(paren
id|commit
comma
l_int|NULL
)paren
suffix:semicolon
r_int
id|len
op_assign
id|find_commit_subject
c_func
(paren
id|msg
comma
op_amp
id|title
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
)paren
id|printf
c_func
(paren
l_string|&quot;%.*s&bslash;n&quot;
comma
id|len
comma
id|title
)paren
suffix:semicolon
id|unuse_commit_buffer
c_func
(paren
id|commit
comma
id|msg
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|add_cacheinfo
r_static
r_int
id|add_cacheinfo
c_func
(paren
r_int
r_int
id|mode
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_const
r_char
op_star
id|path
comma
r_int
id|stage
comma
r_int
id|refresh
comma
r_int
id|options
)paren
(brace
r_struct
id|cache_entry
op_star
id|ce
suffix:semicolon
id|ce
op_assign
id|make_cache_entry
c_func
(paren
id|mode
comma
id|sha1
ques
c_cond
id|sha1
suffix:colon
id|null_sha1
comma
id|path
comma
id|stage
comma
(paren
id|refresh
ques
c_cond
(paren
id|CE_MATCH_REFRESH
op_or
id|CE_MATCH_IGNORE_MISSING
)paren
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ce
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;addinfo_cache failed for path &squot;%s&squot;&quot;
)paren
comma
id|path
)paren
suffix:semicolon
r_return
id|add_cache_entry
c_func
(paren
id|ce
comma
id|options
)paren
suffix:semicolon
)brace
DECL|function|init_tree_desc_from_tree
r_static
r_void
id|init_tree_desc_from_tree
c_func
(paren
r_struct
id|tree_desc
op_star
id|desc
comma
r_struct
id|tree
op_star
id|tree
)paren
(brace
id|parse_tree
c_func
(paren
id|tree
)paren
suffix:semicolon
id|init_tree_desc
c_func
(paren
id|desc
comma
id|tree-&gt;buffer
comma
id|tree-&gt;size
)paren
suffix:semicolon
)brace
DECL|function|git_merge_trees
r_static
r_int
id|git_merge_trees
c_func
(paren
r_int
id|index_only
comma
r_struct
id|tree
op_star
id|common
comma
r_struct
id|tree
op_star
id|head
comma
r_struct
id|tree
op_star
id|merge
)paren
(brace
r_int
id|rc
suffix:semicolon
r_struct
id|tree_desc
id|t
(braket
l_int|3
)braket
suffix:semicolon
r_struct
id|unpack_trees_options
id|opts
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|opts
comma
l_int|0
comma
r_sizeof
(paren
id|opts
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index_only
)paren
id|opts.index_only
op_assign
l_int|1
suffix:semicolon
r_else
id|opts.update
op_assign
l_int|1
suffix:semicolon
id|opts.merge
op_assign
l_int|1
suffix:semicolon
id|opts.head_idx
op_assign
l_int|2
suffix:semicolon
id|opts.fn
op_assign
id|threeway_merge
suffix:semicolon
id|opts.src_index
op_assign
op_amp
id|the_index
suffix:semicolon
id|opts.dst_index
op_assign
op_amp
id|the_index
suffix:semicolon
id|setup_unpack_trees_porcelain
c_func
(paren
op_amp
id|opts
comma
l_string|&quot;merge&quot;
)paren
suffix:semicolon
id|init_tree_desc_from_tree
c_func
(paren
id|t
op_plus
l_int|0
comma
id|common
)paren
suffix:semicolon
id|init_tree_desc_from_tree
c_func
(paren
id|t
op_plus
l_int|1
comma
id|head
)paren
suffix:semicolon
id|init_tree_desc_from_tree
c_func
(paren
id|t
op_plus
l_int|2
comma
id|merge
)paren
suffix:semicolon
id|rc
op_assign
id|unpack_trees
c_func
(paren
l_int|3
comma
id|t
comma
op_amp
id|opts
)paren
suffix:semicolon
id|cache_tree_free
c_func
(paren
op_amp
id|active_cache_tree
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|write_tree_from_memory
r_struct
id|tree
op_star
id|write_tree_from_memory
c_func
(paren
r_struct
id|merge_options
op_star
id|o
)paren
(brace
r_struct
id|tree
op_star
id|result
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|unmerged_cache
c_func
(paren
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;BUG: There are unmerged index entries:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|active_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_struct
id|cache_entry
op_star
id|ce
op_assign
id|active_cache
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ce_stage
c_func
(paren
id|ce
)paren
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;BUG: %d %.*s&bslash;n&quot;
comma
id|ce_stage
c_func
(paren
id|ce
)paren
comma
(paren
r_int
)paren
id|ce_namelen
c_func
(paren
id|ce
)paren
comma
id|ce-&gt;name
)paren
suffix:semicolon
)brace
id|die
c_func
(paren
l_string|&quot;Bug in merge-recursive.c&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|active_cache_tree
)paren
id|active_cache_tree
op_assign
id|cache_tree
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cache_tree_fully_valid
c_func
(paren
id|active_cache_tree
)paren
op_logical_and
id|cache_tree_update
c_func
(paren
op_amp
id|the_index
comma
l_int|0
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;error building trees&quot;
)paren
)paren
suffix:semicolon
id|result
op_assign
id|lookup_tree
c_func
(paren
id|active_cache_tree-&gt;sha1
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|save_files_dirs
r_static
r_int
id|save_files_dirs
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
comma
r_const
r_char
op_star
id|base
comma
r_int
id|baselen
comma
r_const
r_char
op_star
id|path
comma
r_int
r_int
id|mode
comma
r_int
id|stage
comma
r_void
op_star
id|context
)paren
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|path
)paren
suffix:semicolon
r_char
op_star
id|newpath
op_assign
id|xmalloc
c_func
(paren
id|baselen
op_plus
id|len
op_plus
l_int|1
)paren
suffix:semicolon
r_struct
id|merge_options
op_star
id|o
op_assign
id|context
suffix:semicolon
id|memcpy
c_func
(paren
id|newpath
comma
id|base
comma
id|baselen
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|newpath
op_plus
id|baselen
comma
id|path
comma
id|len
)paren
suffix:semicolon
id|newpath
(braket
id|baselen
op_plus
id|len
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|mode
)paren
)paren
id|string_list_insert
c_func
(paren
op_amp
id|o-&gt;current_directory_set
comma
id|newpath
)paren
suffix:semicolon
r_else
id|string_list_insert
c_func
(paren
op_amp
id|o-&gt;current_file_set
comma
id|newpath
)paren
suffix:semicolon
id|free
c_func
(paren
id|newpath
)paren
suffix:semicolon
r_return
(paren
id|S_ISDIR
c_func
(paren
id|mode
)paren
ques
c_cond
id|READ_TREE_RECURSIVE
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|get_files_dirs
r_static
r_int
id|get_files_dirs
c_func
(paren
r_struct
id|merge_options
op_star
id|o
comma
r_struct
id|tree
op_star
id|tree
)paren
(brace
r_int
id|n
suffix:semicolon
r_struct
id|pathspec
id|match_all
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|match_all
comma
l_int|0
comma
r_sizeof
(paren
id|match_all
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_tree_recursive
c_func
(paren
id|tree
comma
l_string|&quot;&quot;
comma
l_int|0
comma
l_int|0
comma
op_amp
id|match_all
comma
id|save_files_dirs
comma
id|o
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|n
op_assign
id|o-&gt;current_file_set.nr
op_plus
id|o-&gt;current_directory_set.nr
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
multiline_comment|/*&n; * Returns an index_entry instance which doesn&squot;t have to correspond to&n; * a real cache entry in Git&squot;s index.&n; */
DECL|function|insert_stage_data
r_static
r_struct
id|stage_data
op_star
id|insert_stage_data
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_struct
id|tree
op_star
id|o
comma
r_struct
id|tree
op_star
id|a
comma
r_struct
id|tree
op_star
id|b
comma
r_struct
id|string_list
op_star
id|entries
)paren
(brace
r_struct
id|string_list_item
op_star
id|item
suffix:semicolon
r_struct
id|stage_data
op_star
id|e
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|stage_data
)paren
)paren
suffix:semicolon
id|get_tree_entry
c_func
(paren
id|o-&gt;object.sha1
comma
id|path
comma
id|e-&gt;stages
(braket
l_int|1
)braket
dot
id|sha
comma
op_amp
id|e-&gt;stages
(braket
l_int|1
)braket
dot
id|mode
)paren
suffix:semicolon
id|get_tree_entry
c_func
(paren
id|a-&gt;object.sha1
comma
id|path
comma
id|e-&gt;stages
(braket
l_int|2
)braket
dot
id|sha
comma
op_amp
id|e-&gt;stages
(braket
l_int|2
)braket
dot
id|mode
)paren
suffix:semicolon
id|get_tree_entry
c_func
(paren
id|b-&gt;object.sha1
comma
id|path
comma
id|e-&gt;stages
(braket
l_int|3
)braket
dot
id|sha
comma
op_amp
id|e-&gt;stages
(braket
l_int|3
)braket
dot
id|mode
)paren
suffix:semicolon
id|item
op_assign
id|string_list_insert
c_func
(paren
id|entries
comma
id|path
)paren
suffix:semicolon
id|item-&gt;util
op_assign
id|e
suffix:semicolon
r_return
id|e
suffix:semicolon
)brace
multiline_comment|/*&n; * Create a dictionary mapping file names to stage_data objects. The&n; * dictionary contains one entry for every path with a non-zero stage entry.&n; */
DECL|function|get_unmerged
r_static
r_struct
id|string_list
op_star
id|get_unmerged
c_func
(paren
r_void
)paren
(brace
r_struct
id|string_list
op_star
id|unmerged
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|string_list
)paren
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
id|unmerged-&gt;strdup_strings
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|active_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|string_list_item
op_star
id|item
suffix:semicolon
r_struct
id|stage_data
op_star
id|e
suffix:semicolon
r_const
r_struct
id|cache_entry
op_star
id|ce
op_assign
id|active_cache
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ce_stage
c_func
(paren
id|ce
)paren
)paren
r_continue
suffix:semicolon
id|item
op_assign
id|string_list_lookup
c_func
(paren
id|unmerged
comma
id|ce-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|item
)paren
(brace
id|item
op_assign
id|string_list_insert
c_func
(paren
id|unmerged
comma
id|ce-&gt;name
)paren
suffix:semicolon
id|item-&gt;util
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|stage_data
)paren
)paren
suffix:semicolon
)brace
id|e
op_assign
id|item-&gt;util
suffix:semicolon
id|e-&gt;stages
(braket
id|ce_stage
c_func
(paren
id|ce
)paren
)braket
dot
id|mode
op_assign
id|ce-&gt;ce_mode
suffix:semicolon
id|hashcpy
c_func
(paren
id|e-&gt;stages
(braket
id|ce_stage
c_func
(paren
id|ce
)paren
)braket
dot
id|sha
comma
id|ce-&gt;sha1
)paren
suffix:semicolon
)brace
r_return
id|unmerged
suffix:semicolon
)brace
DECL|function|string_list_df_name_compare
r_static
r_int
id|string_list_df_name_compare
c_func
(paren
r_const
r_void
op_star
id|a
comma
r_const
r_void
op_star
id|b
)paren
(brace
r_const
r_struct
id|string_list_item
op_star
id|one
op_assign
id|a
suffix:semicolon
r_const
r_struct
id|string_list_item
op_star
id|two
op_assign
id|b
suffix:semicolon
r_int
id|onelen
op_assign
id|strlen
c_func
(paren
id|one-&gt;string
)paren
suffix:semicolon
r_int
id|twolen
op_assign
id|strlen
c_func
(paren
id|two-&gt;string
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Here we only care that entries for D/F conflicts are&n;&t; * adjacent, in particular with the file of the D/F conflict&n;&t; * appearing before files below the corresponding directory.&n;&t; * The order of the rest of the list is irrelevant for us.&n;&t; *&n;&t; * To achieve this, we sort with df_name_compare and provide&n;&t; * the mode S_IFDIR so that D/F conflicts will sort correctly.&n;&t; * We use the mode S_IFDIR for everything else for simplicity,&n;&t; * since in other cases any changes in their order due to&n;&t; * sorting cause no problems for us.&n;&t; */
r_int
id|cmp
op_assign
id|df_name_compare
c_func
(paren
id|one-&gt;string
comma
id|onelen
comma
id|S_IFDIR
comma
id|two-&gt;string
comma
id|twolen
comma
id|S_IFDIR
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Now that &squot;foo&squot; and &squot;foo/bar&squot; compare equal, we have to make sure&n;&t; * that &squot;foo&squot; comes before &squot;foo/bar&squot;.&n;&t; */
r_if
c_cond
(paren
id|cmp
)paren
r_return
id|cmp
suffix:semicolon
r_return
id|onelen
id|twolen
suffix:semicolon
)brace
DECL|function|record_df_conflict_files
r_static
r_void
id|record_df_conflict_files
c_func
(paren
r_struct
id|merge_options
op_star
id|o
comma
r_struct
id|string_list
op_star
id|entries
)paren
(brace
multiline_comment|/* If there is a D/F conflict and the file for such a conflict&n;&t; * currently exist in the working tree, we want to allow it to be&n;&t; * removed to make room for the corresponding directory if needed.&n;&t; * The files underneath the directories of such D/F conflicts will&n;&t; * be processed before the corresponding file involved in the D/F&n;&t; * conflict.  If the D/F directory ends up being removed by the&n;&t; * merge, then we won&squot;t have to touch the D/F file.  If the D/F&n;&t; * directory needs to be written to the working copy, then the D/F&n;&t; * file will simply be removed (in make_room_for_path()) to make&n;&t; * room for the necessary paths.  Note that if both the directory&n;&t; * and the file need to be present, then the D/F file will be&n;&t; * reinstated with a new unique name at the time it is processed.&n;&t; */
r_struct
id|string_list
id|df_sorted_entries
suffix:semicolon
r_const
r_char
op_star
id|last_file
op_assign
l_int|NULL
suffix:semicolon
r_int
id|last_len
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * If we&squot;re merging merge-bases, we don&squot;t want to bother with&n;&t; * any working directory changes.&n;&t; */
r_if
c_cond
(paren
id|o-&gt;call_depth
)paren
r_return
suffix:semicolon
multiline_comment|/* Ensure D/F conflicts are adjacent in the entries list. */
id|memset
c_func
(paren
op_amp
id|df_sorted_entries
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|string_list
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|entries-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|string_list_item
op_star
id|next
op_assign
op_amp
id|entries-&gt;items
(braket
id|i
)braket
suffix:semicolon
id|string_list_append
c_func
(paren
op_amp
id|df_sorted_entries
comma
id|next-&gt;string
)paren
op_member_access_from_pointer
id|util
op_assign
id|next-&gt;util
suffix:semicolon
)brace
id|qsort
c_func
(paren
id|df_sorted_entries.items
comma
id|entries-&gt;nr
comma
r_sizeof
(paren
op_star
id|entries-&gt;items
)paren
comma
id|string_list_df_name_compare
)paren
suffix:semicolon
id|string_list_clear
c_func
(paren
op_amp
id|o-&gt;df_conflict_file_set
comma
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|df_sorted_entries.nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_char
op_star
id|path
op_assign
id|df_sorted_entries.items
(braket
id|i
)braket
dot
id|string
suffix:semicolon
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|path
)paren
suffix:semicolon
r_struct
id|stage_data
op_star
id|e
op_assign
id|df_sorted_entries.items
(braket
id|i
)braket
dot
id|util
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Check if last_file &amp; path correspond to a D/F conflict;&n;&t;&t; * i.e. whether path is last_file+&squot;/&squot;+&lt;something&gt;.&n;&t;&t; * If so, record that it&squot;s okay to remove last_file to make&n;&t;&t; * room for path and friends if needed.&n;&t;&t; */
r_if
c_cond
(paren
id|last_file
op_logical_and
id|len
OG
id|last_len
op_logical_and
id|memcmp
c_func
(paren
id|path
comma
id|last_file
comma
id|last_len
)paren
op_eq
l_int|0
op_logical_and
id|path
(braket
id|last_len
)braket
op_eq
l_char|&squot;/&squot;
)paren
(brace
id|string_list_insert
c_func
(paren
op_amp
id|o-&gt;df_conflict_file_set
comma
id|last_file
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Determine whether path could exist as a file in the&n;&t;&t; * working directory as a possible D/F conflict.  This&n;&t;&t; * will only occur when it exists in stage 2 as a&n;&t;&t; * file.&n;&t;&t; */
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|e-&gt;stages
(braket
l_int|2
)braket
dot
id|mode
)paren
op_logical_or
id|S_ISLNK
c_func
(paren
id|e-&gt;stages
(braket
l_int|2
)braket
dot
id|mode
)paren
)paren
(brace
id|last_file
op_assign
id|path
suffix:semicolon
id|last_len
op_assign
id|len
suffix:semicolon
)brace
r_else
(brace
id|last_file
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
id|string_list_clear
c_func
(paren
op_amp
id|df_sorted_entries
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|struct|rename
r_struct
id|rename
(brace
DECL|member|pair
r_struct
id|diff_filepair
op_star
id|pair
suffix:semicolon
DECL|member|src_entry
r_struct
id|stage_data
op_star
id|src_entry
suffix:semicolon
DECL|member|dst_entry
r_struct
id|stage_data
op_star
id|dst_entry
suffix:semicolon
DECL|member|processed
r_int
id|processed
suffix:colon
l_int|1
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Get information of all renames which occurred between &squot;o_tree&squot; and&n; * &squot;tree&squot;. We need the three trees in the merge (&squot;o_tree&squot;, &squot;a_tree&squot; and&n; * &squot;b_tree&squot;) to be able to associate the correct cache entries with&n; * the rename information. &squot;tree&squot; is always equal to either a_tree or b_tree.&n; */
DECL|function|get_renames
r_static
r_struct
id|string_list
op_star
id|get_renames
c_func
(paren
r_struct
id|merge_options
op_star
id|o
comma
r_struct
id|tree
op_star
id|tree
comma
r_struct
id|tree
op_star
id|o_tree
comma
r_struct
id|tree
op_star
id|a_tree
comma
r_struct
id|tree
op_star
id|b_tree
comma
r_struct
id|string_list
op_star
id|entries
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|string_list
op_star
id|renames
suffix:semicolon
r_struct
id|diff_options
id|opts
suffix:semicolon
id|renames
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|string_list
)paren
)paren
suffix:semicolon
id|diff_setup
c_func
(paren
op_amp
id|opts
)paren
suffix:semicolon
id|DIFF_OPT_SET
c_func
(paren
op_amp
id|opts
comma
id|RECURSIVE
)paren
suffix:semicolon
id|DIFF_OPT_CLR
c_func
(paren
op_amp
id|opts
comma
id|RENAME_EMPTY
)paren
suffix:semicolon
id|opts.detect_rename
op_assign
id|DIFF_DETECT_RENAME
suffix:semicolon
id|opts.rename_limit
op_assign
id|o-&gt;merge_rename_limit
op_ge
l_int|0
ques
c_cond
id|o-&gt;merge_rename_limit
suffix:colon
id|o-&gt;diff_rename_limit
op_ge
l_int|0
ques
c_cond
id|o-&gt;diff_rename_limit
suffix:colon
l_int|1000
suffix:semicolon
id|opts.rename_score
op_assign
id|o-&gt;rename_score
suffix:semicolon
id|opts.show_rename_progress
op_assign
id|o-&gt;show_rename_progress
suffix:semicolon
id|opts.output_format
op_assign
id|DIFF_FORMAT_NO_OUTPUT
suffix:semicolon
id|diff_setup_done
c_func
(paren
op_amp
id|opts
)paren
suffix:semicolon
id|diff_tree_sha1
c_func
(paren
id|o_tree-&gt;object.sha1
comma
id|tree-&gt;object.sha1
comma
l_string|&quot;&quot;
comma
op_amp
id|opts
)paren
suffix:semicolon
id|diffcore_std
c_func
(paren
op_amp
id|opts
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opts.needed_rename_limit
OG
id|o-&gt;needed_rename_limit
)paren
id|o-&gt;needed_rename_limit
op_assign
id|opts.needed_rename_limit
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|diff_queued_diff.nr
suffix:semicolon
op_increment
id|i
)paren
(brace
r_struct
id|string_list_item
op_star
id|item
suffix:semicolon
r_struct
id|rename
op_star
id|re
suffix:semicolon
r_struct
id|diff_filepair
op_star
id|pair
op_assign
id|diff_queued_diff.queue
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|pair-&gt;status
op_ne
l_char|&squot;R&squot;
)paren
(brace
id|diff_free_filepair
c_func
(paren
id|pair
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|re
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|re
)paren
)paren
suffix:semicolon
id|re-&gt;processed
op_assign
l_int|0
suffix:semicolon
id|re-&gt;pair
op_assign
id|pair
suffix:semicolon
id|item
op_assign
id|string_list_lookup
c_func
(paren
id|entries
comma
id|re-&gt;pair-&gt;one-&gt;path
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|item
)paren
id|re-&gt;src_entry
op_assign
id|insert_stage_data
c_func
(paren
id|re-&gt;pair-&gt;one-&gt;path
comma
id|o_tree
comma
id|a_tree
comma
id|b_tree
comma
id|entries
)paren
suffix:semicolon
r_else
id|re-&gt;src_entry
op_assign
id|item-&gt;util
suffix:semicolon
id|item
op_assign
id|string_list_lookup
c_func
(paren
id|entries
comma
id|re-&gt;pair-&gt;two-&gt;path
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|item
)paren
id|re-&gt;dst_entry
op_assign
id|insert_stage_data
c_func
(paren
id|re-&gt;pair-&gt;two-&gt;path
comma
id|o_tree
comma
id|a_tree
comma
id|b_tree
comma
id|entries
)paren
suffix:semicolon
r_else
id|re-&gt;dst_entry
op_assign
id|item-&gt;util
suffix:semicolon
id|item
op_assign
id|string_list_insert
c_func
(paren
id|renames
comma
id|pair-&gt;one-&gt;path
)paren
suffix:semicolon
id|item-&gt;util
op_assign
id|re
suffix:semicolon
)brace
id|opts.output_format
op_assign
id|DIFF_FORMAT_NO_OUTPUT
suffix:semicolon
id|diff_queued_diff.nr
op_assign
l_int|0
suffix:semicolon
id|diff_flush
c_func
(paren
op_amp
id|opts
)paren
suffix:semicolon
r_return
id|renames
suffix:semicolon
)brace
DECL|function|update_stages
r_static
r_int
id|update_stages
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_const
r_struct
id|diff_filespec
op_star
id|o
comma
r_const
r_struct
id|diff_filespec
op_star
id|a
comma
r_const
r_struct
id|diff_filespec
op_star
id|b
)paren
(brace
multiline_comment|/*&n;&t; * NOTE: It is usually a bad idea to call update_stages on a path&n;&t; * before calling update_file on that same path, since it can&n;&t; * sometimes lead to spurious &quot;refusing to lose untracked file...&quot;&n;&t; * messages from update_file (via make_room_for path via&n;&t; * would_lose_untracked).  Instead, reverse the order of the calls&n;&t; * (executing update_file first and then update_stages).&n;&t; */
r_int
id|clear
op_assign
l_int|1
suffix:semicolon
r_int
id|options
op_assign
id|ADD_CACHE_OK_TO_ADD
op_or
id|ADD_CACHE_SKIP_DFCHECK
suffix:semicolon
r_if
c_cond
(paren
id|clear
)paren
r_if
c_cond
(paren
id|remove_file_from_cache
c_func
(paren
id|path
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|o
)paren
r_if
c_cond
(paren
id|add_cacheinfo
c_func
(paren
id|o-&gt;mode
comma
id|o-&gt;sha1
comma
id|path
comma
l_int|1
comma
l_int|0
comma
id|options
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|a
)paren
r_if
c_cond
(paren
id|add_cacheinfo
c_func
(paren
id|a-&gt;mode
comma
id|a-&gt;sha1
comma
id|path
comma
l_int|2
comma
l_int|0
comma
id|options
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|b
)paren
r_if
c_cond
(paren
id|add_cacheinfo
c_func
(paren
id|b-&gt;mode
comma
id|b-&gt;sha1
comma
id|path
comma
l_int|3
comma
l_int|0
comma
id|options
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|update_entry
r_static
r_void
id|update_entry
c_func
(paren
r_struct
id|stage_data
op_star
id|entry
comma
r_struct
id|diff_filespec
op_star
id|o
comma
r_struct
id|diff_filespec
op_star
id|a
comma
r_struct
id|diff_filespec
op_star
id|b
)paren
(brace
id|entry-&gt;processed
op_assign
l_int|0
suffix:semicolon
id|entry-&gt;stages
(braket
l_int|1
)braket
dot
id|mode
op_assign
id|o-&gt;mode
suffix:semicolon
id|entry-&gt;stages
(braket
l_int|2
)braket
dot
id|mode
op_assign
id|a-&gt;mode
suffix:semicolon
id|entry-&gt;stages
(braket
l_int|3
)braket
dot
id|mode
op_assign
id|b-&gt;mode
suffix:semicolon
id|hashcpy
c_func
(paren
id|entry-&gt;stages
(braket
l_int|1
)braket
dot
id|sha
comma
id|o-&gt;sha1
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|entry-&gt;stages
(braket
l_int|2
)braket
dot
id|sha
comma
id|a-&gt;sha1
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|entry-&gt;stages
(braket
l_int|3
)braket
dot
id|sha
comma
id|b-&gt;sha1
)paren
suffix:semicolon
)brace
DECL|function|remove_file
r_static
r_int
id|remove_file
c_func
(paren
r_struct
id|merge_options
op_star
id|o
comma
r_int
id|clean
comma
r_const
r_char
op_star
id|path
comma
r_int
id|no_wd
)paren
(brace
r_int
id|update_cache
op_assign
id|o-&gt;call_depth
op_logical_or
id|clean
suffix:semicolon
r_int
id|update_working_directory
op_assign
op_logical_neg
id|o-&gt;call_depth
op_logical_and
op_logical_neg
id|no_wd
suffix:semicolon
r_if
c_cond
(paren
id|update_cache
)paren
(brace
r_if
c_cond
(paren
id|remove_file_from_cache
c_func
(paren
id|path
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|update_working_directory
)paren
(brace
r_if
c_cond
(paren
id|ignore_case
)paren
(brace
r_struct
id|cache_entry
op_star
id|ce
suffix:semicolon
id|ce
op_assign
id|cache_file_exists
c_func
(paren
id|path
comma
id|strlen
c_func
(paren
id|path
)paren
comma
id|ignore_case
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ce
op_logical_and
id|ce_stage
c_func
(paren
id|ce
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|remove_path
c_func
(paren
id|path
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* add a string to a strbuf, but converting &quot;/&quot; to &quot;_&quot; */
DECL|function|add_flattened_path
r_static
r_void
id|add_flattened_path
c_func
(paren
r_struct
id|strbuf
op_star
id|out
comma
r_const
r_char
op_star
id|s
)paren
(brace
r_int
id|i
op_assign
id|out-&gt;len
suffix:semicolon
id|strbuf_addstr
c_func
(paren
id|out
comma
id|s
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
id|out-&gt;len
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|out-&gt;buf
(braket
id|i
)braket
op_eq
l_char|&squot;/&squot;
)paren
id|out-&gt;buf
(braket
id|i
)braket
op_assign
l_char|&squot;_&squot;
suffix:semicolon
)brace
DECL|function|unique_path
r_static
r_char
op_star
id|unique_path
c_func
(paren
r_struct
id|merge_options
op_star
id|o
comma
r_const
r_char
op_star
id|path
comma
r_const
r_char
op_star
id|branch
)paren
(brace
r_struct
id|strbuf
id|newpath
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|suffix
op_assign
l_int|0
suffix:semicolon
r_struct
id|stat
id|st
suffix:semicolon
r_int
id|base_len
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
id|newpath
comma
l_string|&quot;%s~&quot;
comma
id|path
)paren
suffix:semicolon
id|add_flattened_path
c_func
(paren
op_amp
id|newpath
comma
id|branch
)paren
suffix:semicolon
id|base_len
op_assign
id|newpath.len
suffix:semicolon
r_while
c_loop
(paren
id|string_list_has_string
c_func
(paren
op_amp
id|o-&gt;current_file_set
comma
id|newpath.buf
)paren
op_logical_or
id|string_list_has_string
c_func
(paren
op_amp
id|o-&gt;current_directory_set
comma
id|newpath.buf
)paren
op_logical_or
id|lstat
c_func
(paren
id|newpath.buf
comma
op_amp
id|st
)paren
op_eq
l_int|0
)paren
(brace
id|strbuf_setlen
c_func
(paren
op_amp
id|newpath
comma
id|base_len
)paren
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
id|newpath
comma
l_string|&quot;_%d&quot;
comma
id|suffix
op_increment
)paren
suffix:semicolon
)brace
id|string_list_insert
c_func
(paren
op_amp
id|o-&gt;current_file_set
comma
id|newpath.buf
)paren
suffix:semicolon
r_return
id|strbuf_detach
c_func
(paren
op_amp
id|newpath
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|dir_in_way
r_static
r_int
id|dir_in_way
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_int
id|check_working_copy
)paren
(brace
r_int
id|pos
comma
id|pathlen
op_assign
id|strlen
c_func
(paren
id|path
)paren
suffix:semicolon
r_char
op_star
id|dirpath
op_assign
id|xmalloc
c_func
(paren
id|pathlen
op_plus
l_int|2
)paren
suffix:semicolon
r_struct
id|stat
id|st
suffix:semicolon
id|strcpy
c_func
(paren
id|dirpath
comma
id|path
)paren
suffix:semicolon
id|dirpath
(braket
id|pathlen
)braket
op_assign
l_char|&squot;/&squot;
suffix:semicolon
id|dirpath
(braket
id|pathlen
op_plus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|pos
op_assign
id|cache_name_pos
c_func
(paren
id|dirpath
comma
id|pathlen
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
l_int|0
)paren
id|pos
op_assign
l_int|1
id|pos
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
id|active_nr
op_logical_and
op_logical_neg
id|strncmp
c_func
(paren
id|dirpath
comma
id|active_cache
(braket
id|pos
)braket
op_member_access_from_pointer
id|name
comma
id|pathlen
op_plus
l_int|1
)paren
)paren
(brace
id|free
c_func
(paren
id|dirpath
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|free
c_func
(paren
id|dirpath
)paren
suffix:semicolon
r_return
id|check_working_copy
op_logical_and
op_logical_neg
id|lstat
c_func
(paren
id|path
comma
op_amp
id|st
)paren
op_logical_and
id|S_ISDIR
c_func
(paren
id|st.st_mode
)paren
suffix:semicolon
)brace
DECL|function|was_tracked
r_static
r_int
id|was_tracked
c_func
(paren
r_const
r_char
op_star
id|path
)paren
(brace
r_int
id|pos
op_assign
id|cache_name_pos
c_func
(paren
id|path
comma
id|strlen
c_func
(paren
id|path
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
l_int|0
)paren
id|pos
op_assign
l_int|1
id|pos
suffix:semicolon
r_while
c_loop
(paren
id|pos
OL
id|active_nr
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|path
comma
id|active_cache
(braket
id|pos
)braket
op_member_access_from_pointer
id|name
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * If stage #0, it is definitely tracked.&n;&t;&t; * If it has stage #2 then it was tracked&n;&t;&t; * before this merge started.  All other&n;&t;&t; * cases the path was not tracked.&n;&t;&t; */
r_switch
c_cond
(paren
id|ce_stage
c_func
(paren
id|active_cache
(braket
id|pos
)braket
)paren
)paren
(brace
r_case
l_int|0
suffix:colon
r_case
l_int|2
suffix:colon
r_return
l_int|1
suffix:semicolon
)brace
id|pos
op_increment
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|would_lose_untracked
r_static
r_int
id|would_lose_untracked
c_func
(paren
r_const
r_char
op_star
id|path
)paren
(brace
r_return
op_logical_neg
id|was_tracked
c_func
(paren
id|path
)paren
op_logical_and
id|file_exists
c_func
(paren
id|path
)paren
suffix:semicolon
)brace
DECL|function|make_room_for_path
r_static
r_int
id|make_room_for_path
c_func
(paren
r_struct
id|merge_options
op_star
id|o
comma
r_const
r_char
op_star
id|path
)paren
(brace
r_int
id|status
comma
id|i
suffix:semicolon
r_const
r_char
op_star
id|msg
op_assign
id|_
c_func
(paren
l_string|&quot;failed to create path &squot;%s&squot;%s&quot;
)paren
suffix:semicolon
multiline_comment|/* Unlink any D/F conflict files that are in the way */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|o-&gt;df_conflict_file_set.nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_char
op_star
id|df_path
op_assign
id|o-&gt;df_conflict_file_set.items
(braket
id|i
)braket
dot
id|string
suffix:semicolon
r_int
id|pathlen
op_assign
id|strlen
c_func
(paren
id|path
)paren
suffix:semicolon
r_int
id|df_pathlen
op_assign
id|strlen
c_func
(paren
id|df_path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|df_pathlen
OL
id|pathlen
op_logical_and
id|path
(braket
id|df_pathlen
)braket
op_eq
l_char|&squot;/&squot;
op_logical_and
id|strncmp
c_func
(paren
id|path
comma
id|df_path
comma
id|df_pathlen
)paren
op_eq
l_int|0
)paren
(brace
id|output
c_func
(paren
id|o
comma
l_int|3
comma
id|_
c_func
(paren
l_string|&quot;Removing %s to make room for subdirectory&bslash;n&quot;
)paren
comma
id|df_path
)paren
suffix:semicolon
id|unlink
c_func
(paren
id|df_path
)paren
suffix:semicolon
id|unsorted_string_list_delete_item
c_func
(paren
op_amp
id|o-&gt;df_conflict_file_set
comma
id|i
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Make sure leading directories are created */
id|status
op_assign
id|safe_create_leading_directories_const
c_func
(paren
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
(brace
r_if
c_cond
(paren
id|status
op_eq
id|SCLD_EXISTS
)paren
(brace
multiline_comment|/* something else exists */
id|error
c_func
(paren
id|msg
comma
id|path
comma
id|_
c_func
(paren
l_string|&quot;: perhaps a D/F conflict?&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|die
c_func
(paren
id|msg
comma
id|path
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Do not unlink a file in the work tree if we are not&n;&t; * tracking it.&n;&t; */
r_if
c_cond
(paren
id|would_lose_untracked
c_func
(paren
id|path
)paren
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;refusing to lose untracked file at &squot;%s&squot;&quot;
)paren
comma
id|path
)paren
suffix:semicolon
multiline_comment|/* Successful unlink is good.. */
r_if
c_cond
(paren
op_logical_neg
id|unlink
c_func
(paren
id|path
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* .. and so is no existing file */
r_if
c_cond
(paren
id|errno
op_eq
id|ENOENT
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* .. but not some other error (who really cares what?) */
r_return
id|error
c_func
(paren
id|msg
comma
id|path
comma
id|_
c_func
(paren
l_string|&quot;: perhaps a D/F conflict?&quot;
)paren
)paren
suffix:semicolon
)brace
DECL|function|update_file_flags
r_static
r_void
id|update_file_flags
c_func
(paren
r_struct
id|merge_options
op_star
id|o
comma
r_const
r_int
r_char
op_star
id|sha
comma
r_int
id|mode
comma
r_const
r_char
op_star
id|path
comma
r_int
id|update_cache
comma
r_int
id|update_wd
)paren
(brace
r_if
c_cond
(paren
id|o-&gt;call_depth
)paren
id|update_wd
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|update_wd
)paren
(brace
r_enum
id|object_type
id|type
suffix:semicolon
r_void
op_star
id|buf
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_if
c_cond
(paren
id|S_ISGITLINK
c_func
(paren
id|mode
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * We may later decide to recursively descend into&n;&t;&t;&t; * the submodule directory and update its index&n;&t;&t;&t; * and/or work tree, but we do not do that now.&n;&t;&t;&t; */
id|update_wd
op_assign
l_int|0
suffix:semicolon
r_goto
id|update_index
suffix:semicolon
)brace
id|buf
op_assign
id|read_sha1_file
c_func
(paren
id|sha
comma
op_amp
id|type
comma
op_amp
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;cannot read object %s &squot;%s&squot;&quot;
)paren
comma
id|sha1_to_hex
c_func
(paren
id|sha
)paren
comma
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
id|OBJ_BLOB
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;blob expected for %s &squot;%s&squot;&quot;
)paren
comma
id|sha1_to_hex
c_func
(paren
id|sha
)paren
comma
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|mode
)paren
)paren
(brace
r_struct
id|strbuf
id|strbuf
op_assign
id|STRBUF_INIT
suffix:semicolon
r_if
c_cond
(paren
id|convert_to_working_tree
c_func
(paren
id|path
comma
id|buf
comma
id|size
comma
op_amp
id|strbuf
)paren
)paren
(brace
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
id|size
op_assign
id|strbuf.len
suffix:semicolon
id|buf
op_assign
id|strbuf_detach
c_func
(paren
op_amp
id|strbuf
comma
l_int|NULL
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|make_room_for_path
c_func
(paren
id|o
comma
id|path
)paren
OL
l_int|0
)paren
(brace
id|update_wd
op_assign
l_int|0
suffix:semicolon
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
r_goto
id|update_index
suffix:semicolon
)brace
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|mode
)paren
op_logical_or
(paren
op_logical_neg
id|has_symlinks
op_logical_and
id|S_ISLNK
c_func
(paren
id|mode
)paren
)paren
)paren
(brace
r_int
id|fd
suffix:semicolon
r_if
c_cond
(paren
id|mode
op_amp
l_int|0100
)paren
id|mode
op_assign
l_int|0777
suffix:semicolon
r_else
id|mode
op_assign
l_int|0666
suffix:semicolon
id|fd
op_assign
id|open
c_func
(paren
id|path
comma
id|O_WRONLY
op_or
id|O_TRUNC
op_or
id|O_CREAT
comma
id|mode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;failed to open &squot;%s&squot;&quot;
)paren
comma
id|path
)paren
suffix:semicolon
id|write_in_full
c_func
(paren
id|fd
comma
id|buf
comma
id|size
)paren
suffix:semicolon
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISLNK
c_func
(paren
id|mode
)paren
)paren
(brace
r_char
op_star
id|lnk
op_assign
id|xmemdupz
c_func
(paren
id|buf
comma
id|size
)paren
suffix:semicolon
id|safe_create_leading_directories_const
c_func
(paren
id|path
)paren
suffix:semicolon
id|unlink
c_func
(paren
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|symlink
c_func
(paren
id|lnk
comma
id|path
)paren
)paren
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;failed to symlink &squot;%s&squot;&quot;
)paren
comma
id|path
)paren
suffix:semicolon
id|free
c_func
(paren
id|lnk
)paren
suffix:semicolon
)brace
r_else
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;do not know what to do with %06o %s &squot;%s&squot;&quot;
)paren
comma
id|mode
comma
id|sha1_to_hex
c_func
(paren
id|sha
)paren
comma
id|path
)paren
suffix:semicolon
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
id|update_index
suffix:colon
r_if
c_cond
(paren
id|update_cache
)paren
id|add_cacheinfo
c_func
(paren
id|mode
comma
id|sha
comma
id|path
comma
l_int|0
comma
id|update_wd
comma
id|ADD_CACHE_OK_TO_ADD
)paren
suffix:semicolon
)brace
DECL|function|update_file
r_static
r_void
id|update_file
c_func
(paren
r_struct
id|merge_options
op_star
id|o
comma
r_int
id|clean
comma
r_const
r_int
r_char
op_star
id|sha
comma
r_int
id|mode
comma
r_const
r_char
op_star
id|path
)paren
(brace
id|update_file_flags
c_func
(paren
id|o
comma
id|sha
comma
id|mode
comma
id|path
comma
id|o-&gt;call_depth
op_logical_or
id|clean
comma
op_logical_neg
id|o-&gt;call_depth
)paren
suffix:semicolon
)brace
multiline_comment|/* Low level file merging, update and removal */
DECL|struct|merge_file_info
r_struct
id|merge_file_info
(brace
DECL|member|sha
r_int
r_char
id|sha
(braket
l_int|20
)braket
suffix:semicolon
DECL|member|mode
r_int
id|mode
suffix:semicolon
DECL|member|clean
r_int
id|clean
suffix:colon
l_int|1
comma
DECL|member|merge
id|merge
suffix:colon
l_int|1
suffix:semicolon
)brace
suffix:semicolon
DECL|function|merge_3way
r_static
r_int
id|merge_3way
c_func
(paren
r_struct
id|merge_options
op_star
id|o
comma
id|mmbuffer_t
op_star
id|result_buf
comma
r_const
r_struct
id|diff_filespec
op_star
id|one
comma
r_const
r_struct
id|diff_filespec
op_star
id|a
comma
r_const
r_struct
id|diff_filespec
op_star
id|b
comma
r_const
r_char
op_star
id|branch1
comma
r_const
r_char
op_star
id|branch2
)paren
(brace
id|mmfile_t
id|orig
comma
id|src1
comma
id|src2
suffix:semicolon
r_struct
id|ll_merge_options
id|ll_opts
op_assign
(brace
l_int|0
)brace
suffix:semicolon
r_char
op_star
id|base_name
comma
op_star
id|name1
comma
op_star
id|name2
suffix:semicolon
r_int
id|merge_status
suffix:semicolon
id|ll_opts.renormalize
op_assign
id|o-&gt;renormalize
suffix:semicolon
id|ll_opts.xdl_opts
op_assign
id|o-&gt;xdl_opts
suffix:semicolon
r_if
c_cond
(paren
id|o-&gt;call_depth
)paren
(brace
id|ll_opts.virtual_ancestor
op_assign
l_int|1
suffix:semicolon
id|ll_opts.variant
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_switch
c_cond
(paren
id|o-&gt;recursive_variant
)paren
(brace
r_case
id|MERGE_RECURSIVE_OURS
suffix:colon
id|ll_opts.variant
op_assign
id|XDL_MERGE_FAVOR_OURS
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MERGE_RECURSIVE_THEIRS
suffix:colon
id|ll_opts.variant
op_assign
id|XDL_MERGE_FAVOR_THEIRS
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ll_opts.variant
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|a-&gt;path
comma
id|b-&gt;path
)paren
op_logical_or
(paren
id|o-&gt;ancestor
op_ne
l_int|NULL
op_logical_and
id|strcmp
c_func
(paren
id|a-&gt;path
comma
id|one-&gt;path
)paren
op_ne
l_int|0
)paren
)paren
(brace
id|base_name
op_assign
id|o-&gt;ancestor
op_eq
l_int|NULL
ques
c_cond
l_int|NULL
suffix:colon
id|mkpathdup
c_func
(paren
l_string|&quot;%s:%s&quot;
comma
id|o-&gt;ancestor
comma
id|one-&gt;path
)paren
suffix:semicolon
id|name1
op_assign
id|mkpathdup
c_func
(paren
l_string|&quot;%s:%s&quot;
comma
id|branch1
comma
id|a-&gt;path
)paren
suffix:semicolon
id|name2
op_assign
id|mkpathdup
c_func
(paren
l_string|&quot;%s:%s&quot;
comma
id|branch2
comma
id|b-&gt;path
)paren
suffix:semicolon
)brace
r_else
(brace
id|base_name
op_assign
id|o-&gt;ancestor
op_eq
l_int|NULL
ques
c_cond
l_int|NULL
suffix:colon
id|mkpathdup
c_func
(paren
l_string|&quot;%s&quot;
comma
id|o-&gt;ancestor
)paren
suffix:semicolon
id|name1
op_assign
id|mkpathdup
c_func
(paren
l_string|&quot;%s&quot;
comma
id|branch1
)paren
suffix:semicolon
id|name2
op_assign
id|mkpathdup
c_func
(paren
l_string|&quot;%s&quot;
comma
id|branch2
)paren
suffix:semicolon
)brace
id|read_mmblob
c_func
(paren
op_amp
id|orig
comma
id|one-&gt;sha1
)paren
suffix:semicolon
id|read_mmblob
c_func
(paren
op_amp
id|src1
comma
id|a-&gt;sha1
)paren
suffix:semicolon
id|read_mmblob
c_func
(paren
op_amp
id|src2
comma
id|b-&gt;sha1
)paren
suffix:semicolon
id|merge_status
op_assign
id|ll_merge
c_func
(paren
id|result_buf
comma
id|a-&gt;path
comma
op_amp
id|orig
comma
id|base_name
comma
op_amp
id|src1
comma
id|name1
comma
op_amp
id|src2
comma
id|name2
comma
op_amp
id|ll_opts
)paren
suffix:semicolon
id|free
c_func
(paren
id|base_name
)paren
suffix:semicolon
id|free
c_func
(paren
id|name1
)paren
suffix:semicolon
id|free
c_func
(paren
id|name2
)paren
suffix:semicolon
id|free
c_func
(paren
id|orig.ptr
)paren
suffix:semicolon
id|free
c_func
(paren
id|src1.ptr
)paren
suffix:semicolon
id|free
c_func
(paren
id|src2.ptr
)paren
suffix:semicolon
r_return
id|merge_status
suffix:semicolon
)brace
DECL|function|merge_file_1
r_static
r_struct
id|merge_file_info
id|merge_file_1
c_func
(paren
r_struct
id|merge_options
op_star
id|o
comma
r_const
r_struct
id|diff_filespec
op_star
id|one
comma
r_const
r_struct
id|diff_filespec
op_star
id|a
comma
r_const
r_struct
id|diff_filespec
op_star
id|b
comma
r_const
r_char
op_star
id|branch1
comma
r_const
r_char
op_star
id|branch2
)paren
(brace
r_struct
id|merge_file_info
id|result
suffix:semicolon
id|result.merge
op_assign
l_int|0
suffix:semicolon
id|result.clean
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|S_IFMT
op_amp
id|a-&gt;mode
)paren
op_ne
(paren
id|S_IFMT
op_amp
id|b-&gt;mode
)paren
)paren
(brace
id|result.clean
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|a-&gt;mode
)paren
)paren
(brace
id|result.mode
op_assign
id|a-&gt;mode
suffix:semicolon
id|hashcpy
c_func
(paren
id|result.sha
comma
id|a-&gt;sha1
)paren
suffix:semicolon
)brace
r_else
(brace
id|result.mode
op_assign
id|b-&gt;mode
suffix:semicolon
id|hashcpy
c_func
(paren
id|result.sha
comma
id|b-&gt;sha1
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|sha_eq
c_func
(paren
id|a-&gt;sha1
comma
id|one-&gt;sha1
)paren
op_logical_and
op_logical_neg
id|sha_eq
c_func
(paren
id|b-&gt;sha1
comma
id|one-&gt;sha1
)paren
)paren
id|result.merge
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Merge modes&n;&t;&t; */
r_if
c_cond
(paren
id|a-&gt;mode
op_eq
id|b-&gt;mode
op_logical_or
id|a-&gt;mode
op_eq
id|one-&gt;mode
)paren
id|result.mode
op_assign
id|b-&gt;mode
suffix:semicolon
r_else
(brace
id|result.mode
op_assign
id|a-&gt;mode
suffix:semicolon
r_if
c_cond
(paren
id|b-&gt;mode
op_ne
id|one-&gt;mode
)paren
(brace
id|result.clean
op_assign
l_int|0
suffix:semicolon
id|result.merge
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|sha_eq
c_func
(paren
id|a-&gt;sha1
comma
id|b-&gt;sha1
)paren
op_logical_or
id|sha_eq
c_func
(paren
id|a-&gt;sha1
comma
id|one-&gt;sha1
)paren
)paren
id|hashcpy
c_func
(paren
id|result.sha
comma
id|b-&gt;sha1
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sha_eq
c_func
(paren
id|b-&gt;sha1
comma
id|one-&gt;sha1
)paren
)paren
id|hashcpy
c_func
(paren
id|result.sha
comma
id|a-&gt;sha1
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|a-&gt;mode
)paren
)paren
(brace
id|mmbuffer_t
id|result_buf
suffix:semicolon
r_int
id|merge_status
suffix:semicolon
id|merge_status
op_assign
id|merge_3way
c_func
(paren
id|o
comma
op_amp
id|result_buf
comma
id|one
comma
id|a
comma
id|b
comma
id|branch1
comma
id|branch2
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|merge_status
OL
l_int|0
)paren
op_logical_or
op_logical_neg
id|result_buf.ptr
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Failed to execute internal merge&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write_sha1_file
c_func
(paren
id|result_buf.ptr
comma
id|result_buf.size
comma
id|blob_type
comma
id|result.sha
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Unable to add %s to database&quot;
)paren
comma
id|a-&gt;path
)paren
suffix:semicolon
id|free
c_func
(paren
id|result_buf.ptr
)paren
suffix:semicolon
id|result.clean
op_assign
(paren
id|merge_status
op_eq
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISGITLINK
c_func
(paren
id|a-&gt;mode
)paren
)paren
(brace
id|result.clean
op_assign
id|merge_submodule
c_func
(paren
id|result.sha
comma
id|one-&gt;path
comma
id|one-&gt;sha1
comma
id|a-&gt;sha1
comma
id|b-&gt;sha1
comma
op_logical_neg
id|o-&gt;call_depth
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISLNK
c_func
(paren
id|a-&gt;mode
)paren
)paren
(brace
id|hashcpy
c_func
(paren
id|result.sha
comma
id|a-&gt;sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sha_eq
c_func
(paren
id|a-&gt;sha1
comma
id|b-&gt;sha1
)paren
)paren
id|result.clean
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;unsupported object type in the tree&quot;
)paren
)paren
suffix:semicolon
)brace
)brace
r_return
id|result
suffix:semicolon
)brace
r_static
r_struct
id|merge_file_info
DECL|function|merge_file_special_markers
id|merge_file_special_markers
c_func
(paren
r_struct
id|merge_options
op_star
id|o
comma
r_const
r_struct
id|diff_filespec
op_star
id|one
comma
r_const
r_struct
id|diff_filespec
op_star
id|a
comma
r_const
r_struct
id|diff_filespec
op_star
id|b
comma
r_const
r_char
op_star
id|branch1
comma
r_const
r_char
op_star
id|filename1
comma
r_const
r_char
op_star
id|branch2
comma
r_const
r_char
op_star
id|filename2
)paren
(brace
r_char
op_star
id|side1
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
id|side2
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|merge_file_info
id|mfi
suffix:semicolon
r_if
c_cond
(paren
id|filename1
)paren
id|side1
op_assign
id|xstrfmt
c_func
(paren
l_string|&quot;%s:%s&quot;
comma
id|branch1
comma
id|filename1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|filename2
)paren
id|side2
op_assign
id|xstrfmt
c_func
(paren
l_string|&quot;%s:%s&quot;
comma
id|branch2
comma
id|filename2
)paren
suffix:semicolon
id|mfi
op_assign
id|merge_file_1
c_func
(paren
id|o
comma
id|one
comma
id|a
comma
id|b
comma
id|side1
ques
c_cond
id|side1
suffix:colon
id|branch1
comma
id|side2
ques
c_cond
id|side2
suffix:colon
id|branch2
)paren
suffix:semicolon
id|free
c_func
(paren
id|side1
)paren
suffix:semicolon
id|free
c_func
(paren
id|side2
)paren
suffix:semicolon
r_return
id|mfi
suffix:semicolon
)brace
DECL|function|merge_file_one
r_static
r_struct
id|merge_file_info
id|merge_file_one
c_func
(paren
r_struct
id|merge_options
op_star
id|o
comma
r_const
r_char
op_star
id|path
comma
r_const
r_int
r_char
op_star
id|o_sha
comma
r_int
id|o_mode
comma
r_const
r_int
r_char
op_star
id|a_sha
comma
r_int
id|a_mode
comma
r_const
r_int
r_char
op_star
id|b_sha
comma
r_int
id|b_mode
comma
r_const
r_char
op_star
id|branch1
comma
r_const
r_char
op_star
id|branch2
)paren
(brace
r_struct
id|diff_filespec
id|one
comma
id|a
comma
id|b
suffix:semicolon
id|one.path
op_assign
id|a.path
op_assign
id|b.path
op_assign
(paren
r_char
op_star
)paren
id|path
suffix:semicolon
id|hashcpy
c_func
(paren
id|one.sha1
comma
id|o_sha
)paren
suffix:semicolon
id|one.mode
op_assign
id|o_mode
suffix:semicolon
id|hashcpy
c_func
(paren
id|a.sha1
comma
id|a_sha
)paren
suffix:semicolon
id|a.mode
op_assign
id|a_mode
suffix:semicolon
id|hashcpy
c_func
(paren
id|b.sha1
comma
id|b_sha
)paren
suffix:semicolon
id|b.mode
op_assign
id|b_mode
suffix:semicolon
r_return
id|merge_file_1
c_func
(paren
id|o
comma
op_amp
id|one
comma
op_amp
id|a
comma
op_amp
id|b
comma
id|branch1
comma
id|branch2
)paren
suffix:semicolon
)brace
DECL|function|handle_change_delete
r_static
r_void
id|handle_change_delete
c_func
(paren
r_struct
id|merge_options
op_star
id|o
comma
r_const
r_char
op_star
id|path
comma
r_const
r_int
r_char
op_star
id|o_sha
comma
r_int
id|o_mode
comma
r_const
r_int
r_char
op_star
id|a_sha
comma
r_int
id|a_mode
comma
r_const
r_int
r_char
op_star
id|b_sha
comma
r_int
id|b_mode
comma
r_const
r_char
op_star
id|change
comma
r_const
r_char
op_star
id|change_past
)paren
(brace
r_char
op_star
id|renamed
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|dir_in_way
c_func
(paren
id|path
comma
op_logical_neg
id|o-&gt;call_depth
)paren
)paren
(brace
id|renamed
op_assign
id|unique_path
c_func
(paren
id|o
comma
id|path
comma
id|a_sha
ques
c_cond
id|o-&gt;branch1
suffix:colon
id|o-&gt;branch2
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|o-&gt;call_depth
)paren
(brace
multiline_comment|/*&n;&t;&t; * We cannot arbitrarily accept either a_sha or b_sha as&n;&t;&t; * correct; since there is no true &quot;middle point&quot; between&n;&t;&t; * them, simply reuse the base version for virtual merge base.&n;&t;&t; */
id|remove_file_from_cache
c_func
(paren
id|path
)paren
suffix:semicolon
id|update_file
c_func
(paren
id|o
comma
l_int|0
comma
id|o_sha
comma
id|o_mode
comma
id|renamed
ques
c_cond
id|renamed
suffix:colon
id|path
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|a_sha
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|renamed
)paren
(brace
id|output
c_func
(paren
id|o
comma
l_int|1
comma
id|_
c_func
(paren
l_string|&quot;CONFLICT (%s/delete): %s deleted in %s &quot;
l_string|&quot;and %s in %s. Version %s of %s left in tree.&quot;
)paren
comma
id|change
comma
id|path
comma
id|o-&gt;branch1
comma
id|change_past
comma
id|o-&gt;branch2
comma
id|o-&gt;branch2
comma
id|path
)paren
suffix:semicolon
id|update_file
c_func
(paren
id|o
comma
l_int|0
comma
id|b_sha
comma
id|b_mode
comma
id|path
)paren
suffix:semicolon
)brace
r_else
(brace
id|output
c_func
(paren
id|o
comma
l_int|1
comma
id|_
c_func
(paren
l_string|&quot;CONFLICT (%s/delete): %s deleted in %s &quot;
l_string|&quot;and %s in %s. Version %s of %s left in tree at %s.&quot;
)paren
comma
id|change
comma
id|path
comma
id|o-&gt;branch1
comma
id|change_past
comma
id|o-&gt;branch2
comma
id|o-&gt;branch2
comma
id|path
comma
id|renamed
)paren
suffix:semicolon
id|update_file
c_func
(paren
id|o
comma
l_int|0
comma
id|b_sha
comma
id|b_mode
comma
id|renamed
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|renamed
)paren
(brace
id|output
c_func
(paren
id|o
comma
l_int|1
comma
id|_
c_func
(paren
l_string|&quot;CONFLICT (%s/delete): %s deleted in %s &quot;
l_string|&quot;and %s in %s. Version %s of %s left in tree.&quot;
)paren
comma
id|change
comma
id|path
comma
id|o-&gt;branch2
comma
id|change_past
comma
id|o-&gt;branch1
comma
id|o-&gt;branch1
comma
id|path
)paren
suffix:semicolon
)brace
r_else
(brace
id|output
c_func
(paren
id|o
comma
l_int|1
comma
id|_
c_func
(paren
l_string|&quot;CONFLICT (%s/delete): %s deleted in %s &quot;
l_string|&quot;and %s in %s. Version %s of %s left in tree at %s.&quot;
)paren
comma
id|change
comma
id|path
comma
id|o-&gt;branch2
comma
id|change_past
comma
id|o-&gt;branch1
comma
id|o-&gt;branch1
comma
id|path
comma
id|renamed
)paren
suffix:semicolon
id|update_file
c_func
(paren
id|o
comma
l_int|0
comma
id|a_sha
comma
id|a_mode
comma
id|renamed
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * No need to call update_file() on path when !renamed, since&n;&t;&t; * that would needlessly touch path.  We could call&n;&t;&t; * update_file_flags() with update_cache=0 and update_wd=0,&n;&t;&t; * but that&squot;s a no-op.&n;&t;&t; */
)brace
id|free
c_func
(paren
id|renamed
)paren
suffix:semicolon
)brace
DECL|function|conflict_rename_delete
r_static
r_void
id|conflict_rename_delete
c_func
(paren
r_struct
id|merge_options
op_star
id|o
comma
r_struct
id|diff_filepair
op_star
id|pair
comma
r_const
r_char
op_star
id|rename_branch
comma
r_const
r_char
op_star
id|other_branch
)paren
(brace
r_const
r_struct
id|diff_filespec
op_star
id|orig
op_assign
id|pair-&gt;one
suffix:semicolon
r_const
r_struct
id|diff_filespec
op_star
id|dest
op_assign
id|pair-&gt;two
suffix:semicolon
r_const
r_int
r_char
op_star
id|a_sha
op_assign
l_int|NULL
suffix:semicolon
r_const
r_int
r_char
op_star
id|b_sha
op_assign
l_int|NULL
suffix:semicolon
r_int
id|a_mode
op_assign
l_int|0
suffix:semicolon
r_int
id|b_mode
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|rename_branch
op_eq
id|o-&gt;branch1
)paren
(brace
id|a_sha
op_assign
id|dest-&gt;sha1
suffix:semicolon
id|a_mode
op_assign
id|dest-&gt;mode
suffix:semicolon
)brace
r_else
(brace
id|b_sha
op_assign
id|dest-&gt;sha1
suffix:semicolon
id|b_mode
op_assign
id|dest-&gt;mode
suffix:semicolon
)brace
id|handle_change_delete
c_func
(paren
id|o
comma
id|o-&gt;call_depth
ques
c_cond
id|orig-&gt;path
suffix:colon
id|dest-&gt;path
comma
id|orig-&gt;sha1
comma
id|orig-&gt;mode
comma
id|a_sha
comma
id|a_mode
comma
id|b_sha
comma
id|b_mode
comma
id|_
c_func
(paren
l_string|&quot;rename&quot;
)paren
comma
id|_
c_func
(paren
l_string|&quot;renamed&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|o-&gt;call_depth
)paren
(brace
id|remove_file_from_cache
c_func
(paren
id|dest-&gt;path
)paren
suffix:semicolon
)brace
r_else
(brace
id|update_stages
c_func
(paren
id|dest-&gt;path
comma
l_int|NULL
comma
id|rename_branch
op_eq
id|o-&gt;branch1
ques
c_cond
id|dest
suffix:colon
l_int|NULL
comma
id|rename_branch
op_eq
id|o-&gt;branch1
ques
c_cond
l_int|NULL
suffix:colon
id|dest
)paren
suffix:semicolon
)brace
)brace
DECL|function|filespec_from_entry
r_static
r_struct
id|diff_filespec
op_star
id|filespec_from_entry
c_func
(paren
r_struct
id|diff_filespec
op_star
id|target
comma
r_struct
id|stage_data
op_star
id|entry
comma
r_int
id|stage
)paren
(brace
r_int
r_char
op_star
id|sha
op_assign
id|entry-&gt;stages
(braket
id|stage
)braket
dot
id|sha
suffix:semicolon
r_int
id|mode
op_assign
id|entry-&gt;stages
(braket
id|stage
)braket
dot
id|mode
suffix:semicolon
r_if
c_cond
(paren
id|mode
op_eq
l_int|0
op_logical_or
id|is_null_sha1
c_func
(paren
id|sha
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|hashcpy
c_func
(paren
id|target-&gt;sha1
comma
id|sha
)paren
suffix:semicolon
id|target-&gt;mode
op_assign
id|mode
suffix:semicolon
r_return
id|target
suffix:semicolon
)brace
DECL|function|handle_file
r_static
r_void
id|handle_file
c_func
(paren
r_struct
id|merge_options
op_star
id|o
comma
r_struct
id|diff_filespec
op_star
id|rename
comma
r_int
id|stage
comma
r_struct
id|rename_conflict_info
op_star
id|ci
)paren
(brace
r_char
op_star
id|dst_name
op_assign
id|rename-&gt;path
suffix:semicolon
r_struct
id|stage_data
op_star
id|dst_entry
suffix:semicolon
r_const
r_char
op_star
id|cur_branch
comma
op_star
id|other_branch
suffix:semicolon
r_struct
id|diff_filespec
id|other
suffix:semicolon
r_struct
id|diff_filespec
op_star
id|add
suffix:semicolon
r_if
c_cond
(paren
id|stage
op_eq
l_int|2
)paren
(brace
id|dst_entry
op_assign
id|ci-&gt;dst_entry1
suffix:semicolon
id|cur_branch
op_assign
id|ci-&gt;branch1
suffix:semicolon
id|other_branch
op_assign
id|ci-&gt;branch2
suffix:semicolon
)brace
r_else
(brace
id|dst_entry
op_assign
id|ci-&gt;dst_entry2
suffix:semicolon
id|cur_branch
op_assign
id|ci-&gt;branch2
suffix:semicolon
id|other_branch
op_assign
id|ci-&gt;branch1
suffix:semicolon
)brace
id|add
op_assign
id|filespec_from_entry
c_func
(paren
op_amp
id|other
comma
id|dst_entry
comma
id|stage
op_xor
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|add
)paren
(brace
r_char
op_star
id|add_name
op_assign
id|unique_path
c_func
(paren
id|o
comma
id|rename-&gt;path
comma
id|other_branch
)paren
suffix:semicolon
id|update_file
c_func
(paren
id|o
comma
l_int|0
comma
id|add-&gt;sha1
comma
id|add-&gt;mode
comma
id|add_name
)paren
suffix:semicolon
id|remove_file
c_func
(paren
id|o
comma
l_int|0
comma
id|rename-&gt;path
comma
l_int|0
)paren
suffix:semicolon
id|dst_name
op_assign
id|unique_path
c_func
(paren
id|o
comma
id|rename-&gt;path
comma
id|cur_branch
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|dir_in_way
c_func
(paren
id|rename-&gt;path
comma
op_logical_neg
id|o-&gt;call_depth
)paren
)paren
(brace
id|dst_name
op_assign
id|unique_path
c_func
(paren
id|o
comma
id|rename-&gt;path
comma
id|cur_branch
)paren
suffix:semicolon
id|output
c_func
(paren
id|o
comma
l_int|1
comma
id|_
c_func
(paren
l_string|&quot;%s is a directory in %s adding as %s instead&quot;
)paren
comma
id|rename-&gt;path
comma
id|other_branch
comma
id|dst_name
)paren
suffix:semicolon
)brace
)brace
id|update_file
c_func
(paren
id|o
comma
l_int|0
comma
id|rename-&gt;sha1
comma
id|rename-&gt;mode
comma
id|dst_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stage
op_eq
l_int|2
)paren
id|update_stages
c_func
(paren
id|rename-&gt;path
comma
l_int|NULL
comma
id|rename
comma
id|add
)paren
suffix:semicolon
r_else
id|update_stages
c_func
(paren
id|rename-&gt;path
comma
l_int|NULL
comma
id|add
comma
id|rename
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dst_name
op_ne
id|rename-&gt;path
)paren
id|free
c_func
(paren
id|dst_name
)paren
suffix:semicolon
)brace
DECL|function|conflict_rename_rename_1to2
r_static
r_void
id|conflict_rename_rename_1to2
c_func
(paren
r_struct
id|merge_options
op_star
id|o
comma
r_struct
id|rename_conflict_info
op_star
id|ci
)paren
(brace
multiline_comment|/* One file was renamed in both branches, but to different names. */
r_struct
id|diff_filespec
op_star
id|one
op_assign
id|ci-&gt;pair1-&gt;one
suffix:semicolon
r_struct
id|diff_filespec
op_star
id|a
op_assign
id|ci-&gt;pair1-&gt;two
suffix:semicolon
r_struct
id|diff_filespec
op_star
id|b
op_assign
id|ci-&gt;pair2-&gt;two
suffix:semicolon
id|output
c_func
(paren
id|o
comma
l_int|1
comma
id|_
c_func
(paren
l_string|&quot;CONFLICT (rename/rename): &quot;
l_string|&quot;Rename &bslash;&quot;%s&bslash;&quot;-&gt;&bslash;&quot;%s&bslash;&quot; in branch &bslash;&quot;%s&bslash;&quot; &quot;
l_string|&quot;rename &bslash;&quot;%s&bslash;&quot;-&gt;&bslash;&quot;%s&bslash;&quot; in &bslash;&quot;%s&bslash;&quot;%s&quot;
)paren
comma
id|one-&gt;path
comma
id|a-&gt;path
comma
id|ci-&gt;branch1
comma
id|one-&gt;path
comma
id|b-&gt;path
comma
id|ci-&gt;branch2
comma
id|o-&gt;call_depth
ques
c_cond
id|_
c_func
(paren
l_string|&quot; (left unresolved)&quot;
)paren
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|o-&gt;call_depth
)paren
(brace
r_struct
id|merge_file_info
id|mfi
suffix:semicolon
r_struct
id|diff_filespec
id|other
suffix:semicolon
r_struct
id|diff_filespec
op_star
id|add
suffix:semicolon
id|mfi
op_assign
id|merge_file_one
c_func
(paren
id|o
comma
id|one-&gt;path
comma
id|one-&gt;sha1
comma
id|one-&gt;mode
comma
id|a-&gt;sha1
comma
id|a-&gt;mode
comma
id|b-&gt;sha1
comma
id|b-&gt;mode
comma
id|ci-&gt;branch1
comma
id|ci-&gt;branch2
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * FIXME: For rename/add-source conflicts (if we could detect&n;&t;&t; * such), this is wrong.  We should instead find a unique&n;&t;&t; * pathname and then either rename the add-source file to that&n;&t;&t; * unique path, or use that unique path instead of src here.&n;&t;&t; */
id|update_file
c_func
(paren
id|o
comma
l_int|0
comma
id|mfi.sha
comma
id|mfi.mode
comma
id|one-&gt;path
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Above, we put the merged content at the merge-base&squot;s&n;&t;&t; * path.  Now we usually need to delete both a-&gt;path and&n;&t;&t; * b-&gt;path.  However, the rename on each side of the merge&n;&t;&t; * could also be involved in a rename/add conflict.  In&n;&t;&t; * such cases, we should keep the added file around,&n;&t;&t; * resolving the conflict at that path in its favor.&n;&t;&t; */
id|add
op_assign
id|filespec_from_entry
c_func
(paren
op_amp
id|other
comma
id|ci-&gt;dst_entry1
comma
l_int|2
op_xor
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|add
)paren
id|update_file
c_func
(paren
id|o
comma
l_int|0
comma
id|add-&gt;sha1
comma
id|add-&gt;mode
comma
id|a-&gt;path
)paren
suffix:semicolon
r_else
id|remove_file_from_cache
c_func
(paren
id|a-&gt;path
)paren
suffix:semicolon
id|add
op_assign
id|filespec_from_entry
c_func
(paren
op_amp
id|other
comma
id|ci-&gt;dst_entry2
comma
l_int|3
op_xor
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|add
)paren
id|update_file
c_func
(paren
id|o
comma
l_int|0
comma
id|add-&gt;sha1
comma
id|add-&gt;mode
comma
id|b-&gt;path
)paren
suffix:semicolon
r_else
id|remove_file_from_cache
c_func
(paren
id|b-&gt;path
)paren
suffix:semicolon
)brace
r_else
(brace
id|handle_file
c_func
(paren
id|o
comma
id|a
comma
l_int|2
comma
id|ci
)paren
suffix:semicolon
id|handle_file
c_func
(paren
id|o
comma
id|b
comma
l_int|3
comma
id|ci
)paren
suffix:semicolon
)brace
)brace
DECL|function|conflict_rename_rename_2to1
r_static
r_void
id|conflict_rename_rename_2to1
c_func
(paren
r_struct
id|merge_options
op_star
id|o
comma
r_struct
id|rename_conflict_info
op_star
id|ci
)paren
(brace
multiline_comment|/* Two files, a &amp; b, were renamed to the same thing, c. */
r_struct
id|diff_filespec
op_star
id|a
op_assign
id|ci-&gt;pair1-&gt;one
suffix:semicolon
r_struct
id|diff_filespec
op_star
id|b
op_assign
id|ci-&gt;pair2-&gt;one
suffix:semicolon
r_struct
id|diff_filespec
op_star
id|c1
op_assign
id|ci-&gt;pair1-&gt;two
suffix:semicolon
r_struct
id|diff_filespec
op_star
id|c2
op_assign
id|ci-&gt;pair2-&gt;two
suffix:semicolon
r_char
op_star
id|path
op_assign
id|c1-&gt;path
suffix:semicolon
multiline_comment|/* == c2-&gt;path */
r_struct
id|merge_file_info
id|mfi_c1
suffix:semicolon
r_struct
id|merge_file_info
id|mfi_c2
suffix:semicolon
id|output
c_func
(paren
id|o
comma
l_int|1
comma
id|_
c_func
(paren
l_string|&quot;CONFLICT (rename/rename): &quot;
l_string|&quot;Rename %s-&gt;%s in %s. &quot;
l_string|&quot;Rename %s-&gt;%s in %s&quot;
)paren
comma
id|a-&gt;path
comma
id|c1-&gt;path
comma
id|ci-&gt;branch1
comma
id|b-&gt;path
comma
id|c2-&gt;path
comma
id|ci-&gt;branch2
)paren
suffix:semicolon
id|remove_file
c_func
(paren
id|o
comma
l_int|1
comma
id|a-&gt;path
comma
id|would_lose_untracked
c_func
(paren
id|a-&gt;path
)paren
)paren
suffix:semicolon
id|remove_file
c_func
(paren
id|o
comma
l_int|1
comma
id|b-&gt;path
comma
id|would_lose_untracked
c_func
(paren
id|b-&gt;path
)paren
)paren
suffix:semicolon
id|mfi_c1
op_assign
id|merge_file_special_markers
c_func
(paren
id|o
comma
id|a
comma
id|c1
comma
op_amp
id|ci-&gt;ren1_other
comma
id|o-&gt;branch1
comma
id|c1-&gt;path
comma
id|o-&gt;branch2
comma
id|ci-&gt;ren1_other.path
)paren
suffix:semicolon
id|mfi_c2
op_assign
id|merge_file_special_markers
c_func
(paren
id|o
comma
id|b
comma
op_amp
id|ci-&gt;ren2_other
comma
id|c2
comma
id|o-&gt;branch1
comma
id|ci-&gt;ren2_other.path
comma
id|o-&gt;branch2
comma
id|c2-&gt;path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|o-&gt;call_depth
)paren
(brace
multiline_comment|/*&n;&t;&t; * If mfi_c1.clean &amp;&amp; mfi_c2.clean, then it might make&n;&t;&t; * sense to do a two-way merge of those results.  But, I&n;&t;&t; * think in all cases, it makes sense to have the virtual&n;&t;&t; * merge base just undo the renames; they can be detected&n;&t;&t; * again later for the non-recursive merge.&n;&t;&t; */
id|remove_file
c_func
(paren
id|o
comma
l_int|0
comma
id|path
comma
l_int|0
)paren
suffix:semicolon
id|update_file
c_func
(paren
id|o
comma
l_int|0
comma
id|mfi_c1.sha
comma
id|mfi_c1.mode
comma
id|a-&gt;path
)paren
suffix:semicolon
id|update_file
c_func
(paren
id|o
comma
l_int|0
comma
id|mfi_c2.sha
comma
id|mfi_c2.mode
comma
id|b-&gt;path
)paren
suffix:semicolon
)brace
r_else
(brace
r_char
op_star
id|new_path1
op_assign
id|unique_path
c_func
(paren
id|o
comma
id|path
comma
id|ci-&gt;branch1
)paren
suffix:semicolon
r_char
op_star
id|new_path2
op_assign
id|unique_path
c_func
(paren
id|o
comma
id|path
comma
id|ci-&gt;branch2
)paren
suffix:semicolon
id|output
c_func
(paren
id|o
comma
l_int|1
comma
id|_
c_func
(paren
l_string|&quot;Renaming %s to %s and %s to %s instead&quot;
)paren
comma
id|a-&gt;path
comma
id|new_path1
comma
id|b-&gt;path
comma
id|new_path2
)paren
suffix:semicolon
id|remove_file
c_func
(paren
id|o
comma
l_int|0
comma
id|path
comma
l_int|0
)paren
suffix:semicolon
id|update_file
c_func
(paren
id|o
comma
l_int|0
comma
id|mfi_c1.sha
comma
id|mfi_c1.mode
comma
id|new_path1
)paren
suffix:semicolon
id|update_file
c_func
(paren
id|o
comma
l_int|0
comma
id|mfi_c2.sha
comma
id|mfi_c2.mode
comma
id|new_path2
)paren
suffix:semicolon
id|free
c_func
(paren
id|new_path2
)paren
suffix:semicolon
id|free
c_func
(paren
id|new_path1
)paren
suffix:semicolon
)brace
)brace
DECL|function|process_renames
r_static
r_int
id|process_renames
c_func
(paren
r_struct
id|merge_options
op_star
id|o
comma
r_struct
id|string_list
op_star
id|a_renames
comma
r_struct
id|string_list
op_star
id|b_renames
)paren
(brace
r_int
id|clean_merge
op_assign
l_int|1
comma
id|i
comma
id|j
suffix:semicolon
r_struct
id|string_list
id|a_by_dst
op_assign
id|STRING_LIST_INIT_NODUP
suffix:semicolon
r_struct
id|string_list
id|b_by_dst
op_assign
id|STRING_LIST_INIT_NODUP
suffix:semicolon
r_const
r_struct
id|rename
op_star
id|sre
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|a_renames-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sre
op_assign
id|a_renames-&gt;items
(braket
id|i
)braket
dot
id|util
suffix:semicolon
id|string_list_insert
c_func
(paren
op_amp
id|a_by_dst
comma
id|sre-&gt;pair-&gt;two-&gt;path
)paren
op_member_access_from_pointer
id|util
op_assign
(paren
r_void
op_star
)paren
id|sre
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|b_renames-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sre
op_assign
id|b_renames-&gt;items
(braket
id|i
)braket
dot
id|util
suffix:semicolon
id|string_list_insert
c_func
(paren
op_amp
id|b_by_dst
comma
id|sre-&gt;pair-&gt;two-&gt;path
)paren
op_member_access_from_pointer
id|util
op_assign
(paren
r_void
op_star
)paren
id|sre
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|a_renames-&gt;nr
op_logical_or
id|j
OL
id|b_renames-&gt;nr
suffix:semicolon
)paren
(brace
r_struct
id|string_list
op_star
id|renames1
comma
op_star
id|renames2Dst
suffix:semicolon
r_struct
id|rename
op_star
id|ren1
op_assign
l_int|NULL
comma
op_star
id|ren2
op_assign
l_int|NULL
suffix:semicolon
r_const
r_char
op_star
id|branch1
comma
op_star
id|branch2
suffix:semicolon
r_const
r_char
op_star
id|ren1_src
comma
op_star
id|ren1_dst
suffix:semicolon
r_struct
id|string_list_item
op_star
id|lookup
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
id|a_renames-&gt;nr
)paren
(brace
id|ren2
op_assign
id|b_renames-&gt;items
(braket
id|j
op_increment
)braket
dot
id|util
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|j
op_ge
id|b_renames-&gt;nr
)paren
(brace
id|ren1
op_assign
id|a_renames-&gt;items
(braket
id|i
op_increment
)braket
dot
id|util
suffix:semicolon
)brace
r_else
(brace
r_int
id|compare
op_assign
id|strcmp
c_func
(paren
id|a_renames-&gt;items
(braket
id|i
)braket
dot
id|string
comma
id|b_renames-&gt;items
(braket
id|j
)braket
dot
id|string
)paren
suffix:semicolon
r_if
c_cond
(paren
id|compare
op_le
l_int|0
)paren
id|ren1
op_assign
id|a_renames-&gt;items
(braket
id|i
op_increment
)braket
dot
id|util
suffix:semicolon
r_if
c_cond
(paren
id|compare
op_ge
l_int|0
)paren
id|ren2
op_assign
id|b_renames-&gt;items
(braket
id|j
op_increment
)braket
dot
id|util
suffix:semicolon
)brace
multiline_comment|/* TODO: refactor, so that 1/2 are not needed */
r_if
c_cond
(paren
id|ren1
)paren
(brace
id|renames1
op_assign
id|a_renames
suffix:semicolon
id|renames2Dst
op_assign
op_amp
id|b_by_dst
suffix:semicolon
id|branch1
op_assign
id|o-&gt;branch1
suffix:semicolon
id|branch2
op_assign
id|o-&gt;branch2
suffix:semicolon
)brace
r_else
(brace
r_struct
id|rename
op_star
id|tmp
suffix:semicolon
id|renames1
op_assign
id|b_renames
suffix:semicolon
id|renames2Dst
op_assign
op_amp
id|a_by_dst
suffix:semicolon
id|branch1
op_assign
id|o-&gt;branch2
suffix:semicolon
id|branch2
op_assign
id|o-&gt;branch1
suffix:semicolon
id|tmp
op_assign
id|ren2
suffix:semicolon
id|ren2
op_assign
id|ren1
suffix:semicolon
id|ren1
op_assign
id|tmp
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ren1-&gt;processed
)paren
r_continue
suffix:semicolon
id|ren1-&gt;processed
op_assign
l_int|1
suffix:semicolon
id|ren1-&gt;dst_entry-&gt;processed
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* BUG: We should only mark src_entry as processed if we&n;&t;&t; * are not dealing with a rename + add-source case.&n;&t;&t; */
id|ren1-&gt;src_entry-&gt;processed
op_assign
l_int|1
suffix:semicolon
id|ren1_src
op_assign
id|ren1-&gt;pair-&gt;one-&gt;path
suffix:semicolon
id|ren1_dst
op_assign
id|ren1-&gt;pair-&gt;two-&gt;path
suffix:semicolon
r_if
c_cond
(paren
id|ren2
)paren
(brace
multiline_comment|/* One file renamed on both sides */
r_const
r_char
op_star
id|ren2_src
op_assign
id|ren2-&gt;pair-&gt;one-&gt;path
suffix:semicolon
r_const
r_char
op_star
id|ren2_dst
op_assign
id|ren2-&gt;pair-&gt;two-&gt;path
suffix:semicolon
r_enum
id|rename_type
id|rename_type
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|ren1_src
comma
id|ren2_src
)paren
op_ne
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;ren1_src != ren2_src&quot;
)paren
suffix:semicolon
id|ren2-&gt;dst_entry-&gt;processed
op_assign
l_int|1
suffix:semicolon
id|ren2-&gt;processed
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|ren1_dst
comma
id|ren2_dst
)paren
op_ne
l_int|0
)paren
(brace
id|rename_type
op_assign
id|RENAME_ONE_FILE_TO_TWO
suffix:semicolon
id|clean_merge
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|rename_type
op_assign
id|RENAME_ONE_FILE_TO_ONE
suffix:semicolon
multiline_comment|/* BUG: We should only remove ren1_src in&n;&t;&t;&t;&t; * the base stage (think of rename +&n;&t;&t;&t;&t; * add-source cases).&n;&t;&t;&t;&t; */
id|remove_file
c_func
(paren
id|o
comma
l_int|1
comma
id|ren1_src
comma
l_int|1
)paren
suffix:semicolon
id|update_entry
c_func
(paren
id|ren1-&gt;dst_entry
comma
id|ren1-&gt;pair-&gt;one
comma
id|ren1-&gt;pair-&gt;two
comma
id|ren2-&gt;pair-&gt;two
)paren
suffix:semicolon
)brace
id|setup_rename_conflict_info
c_func
(paren
id|rename_type
comma
id|ren1-&gt;pair
comma
id|ren2-&gt;pair
comma
id|branch1
comma
id|branch2
comma
id|ren1-&gt;dst_entry
comma
id|ren2-&gt;dst_entry
comma
id|o
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|lookup
op_assign
id|string_list_lookup
c_func
(paren
id|renames2Dst
comma
id|ren1_dst
)paren
)paren
)paren
(brace
multiline_comment|/* Two different files renamed to the same thing */
r_char
op_star
id|ren2_dst
suffix:semicolon
id|ren2
op_assign
id|lookup-&gt;util
suffix:semicolon
id|ren2_dst
op_assign
id|ren2-&gt;pair-&gt;two-&gt;path
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|ren1_dst
comma
id|ren2_dst
)paren
op_ne
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;ren1_dst != ren2_dst&quot;
)paren
suffix:semicolon
id|clean_merge
op_assign
l_int|0
suffix:semicolon
id|ren2-&gt;processed
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * BUG: We should only mark src_entry as processed&n;&t;&t;&t; * if we are not dealing with a rename + add-source&n;&t;&t;&t; * case.&n;&t;&t;&t; */
id|ren2-&gt;src_entry-&gt;processed
op_assign
l_int|1
suffix:semicolon
id|setup_rename_conflict_info
c_func
(paren
id|RENAME_TWO_FILES_TO_ONE
comma
id|ren1-&gt;pair
comma
id|ren2-&gt;pair
comma
id|branch1
comma
id|branch2
comma
id|ren1-&gt;dst_entry
comma
id|ren2-&gt;dst_entry
comma
id|o
comma
id|ren1-&gt;src_entry
comma
id|ren2-&gt;src_entry
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Renamed in 1, maybe changed in 2 */
multiline_comment|/* we only use sha1 and mode of these */
r_struct
id|diff_filespec
id|src_other
comma
id|dst_other
suffix:semicolon
r_int
id|try_merge
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * unpack_trees loads entries from common-commit&n;&t;&t;&t; * into stage 1, from head-commit into stage 2, and&n;&t;&t;&t; * from merge-commit into stage 3.  We keep track&n;&t;&t;&t; * of which side corresponds to the rename.&n;&t;&t;&t; */
r_int
id|renamed_stage
op_assign
id|a_renames
op_eq
id|renames1
ques
c_cond
l_int|2
suffix:colon
l_int|3
suffix:semicolon
r_int
id|other_stage
op_assign
id|a_renames
op_eq
id|renames1
ques
c_cond
l_int|3
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* BUG: We should only remove ren1_src in the base&n;&t;&t;&t; * stage and in other_stage (think of rename +&n;&t;&t;&t; * add-source case).&n;&t;&t;&t; */
id|remove_file
c_func
(paren
id|o
comma
l_int|1
comma
id|ren1_src
comma
id|renamed_stage
op_eq
l_int|2
op_logical_or
op_logical_neg
id|was_tracked
c_func
(paren
id|ren1_src
)paren
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|src_other.sha1
comma
id|ren1-&gt;src_entry-&gt;stages
(braket
id|other_stage
)braket
dot
id|sha
)paren
suffix:semicolon
id|src_other.mode
op_assign
id|ren1-&gt;src_entry-&gt;stages
(braket
id|other_stage
)braket
dot
id|mode
suffix:semicolon
id|hashcpy
c_func
(paren
id|dst_other.sha1
comma
id|ren1-&gt;dst_entry-&gt;stages
(braket
id|other_stage
)braket
dot
id|sha
)paren
suffix:semicolon
id|dst_other.mode
op_assign
id|ren1-&gt;dst_entry-&gt;stages
(braket
id|other_stage
)braket
dot
id|mode
suffix:semicolon
id|try_merge
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sha_eq
c_func
(paren
id|src_other.sha1
comma
id|null_sha1
)paren
)paren
(brace
id|setup_rename_conflict_info
c_func
(paren
id|RENAME_DELETE
comma
id|ren1-&gt;pair
comma
l_int|NULL
comma
id|branch1
comma
id|branch2
comma
id|ren1-&gt;dst_entry
comma
l_int|NULL
comma
id|o
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|dst_other.mode
op_eq
id|ren1-&gt;pair-&gt;two-&gt;mode
)paren
op_logical_and
id|sha_eq
c_func
(paren
id|dst_other.sha1
comma
id|ren1-&gt;pair-&gt;two-&gt;sha1
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Added file on the other side identical to&n;&t;&t;&t;&t; * the file being renamed: clean merge.&n;&t;&t;&t;&t; * Also, there is no need to overwrite the&n;&t;&t;&t;&t; * file already in the working copy, so call&n;&t;&t;&t;&t; * update_file_flags() instead of&n;&t;&t;&t;&t; * update_file().&n;&t;&t;&t;&t; */
id|update_file_flags
c_func
(paren
id|o
comma
id|ren1-&gt;pair-&gt;two-&gt;sha1
comma
id|ren1-&gt;pair-&gt;two-&gt;mode
comma
id|ren1_dst
comma
l_int|1
comma
multiline_comment|/* update_cache */
l_int|0
multiline_comment|/* update_wd    */
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|sha_eq
c_func
(paren
id|dst_other.sha1
comma
id|null_sha1
)paren
)paren
(brace
id|clean_merge
op_assign
l_int|0
suffix:semicolon
id|try_merge
op_assign
l_int|1
suffix:semicolon
id|output
c_func
(paren
id|o
comma
l_int|1
comma
id|_
c_func
(paren
l_string|&quot;CONFLICT (rename/add): Rename %s-&gt;%s in %s. &quot;
l_string|&quot;%s added in %s&quot;
)paren
comma
id|ren1_src
comma
id|ren1_dst
comma
id|branch1
comma
id|ren1_dst
comma
id|branch2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|o-&gt;call_depth
)paren
(brace
r_struct
id|merge_file_info
id|mfi
suffix:semicolon
id|mfi
op_assign
id|merge_file_one
c_func
(paren
id|o
comma
id|ren1_dst
comma
id|null_sha1
comma
l_int|0
comma
id|ren1-&gt;pair-&gt;two-&gt;sha1
comma
id|ren1-&gt;pair-&gt;two-&gt;mode
comma
id|dst_other.sha1
comma
id|dst_other.mode
comma
id|branch1
comma
id|branch2
)paren
suffix:semicolon
id|output
c_func
(paren
id|o
comma
l_int|1
comma
id|_
c_func
(paren
l_string|&quot;Adding merged %s&quot;
)paren
comma
id|ren1_dst
)paren
suffix:semicolon
id|update_file
c_func
(paren
id|o
comma
l_int|0
comma
id|mfi.sha
comma
id|mfi.mode
comma
id|ren1_dst
)paren
suffix:semicolon
id|try_merge
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_char
op_star
id|new_path
op_assign
id|unique_path
c_func
(paren
id|o
comma
id|ren1_dst
comma
id|branch2
)paren
suffix:semicolon
id|output
c_func
(paren
id|o
comma
l_int|1
comma
id|_
c_func
(paren
l_string|&quot;Adding as %s instead&quot;
)paren
comma
id|new_path
)paren
suffix:semicolon
id|update_file
c_func
(paren
id|o
comma
l_int|0
comma
id|dst_other.sha1
comma
id|dst_other.mode
comma
id|new_path
)paren
suffix:semicolon
id|free
c_func
(paren
id|new_path
)paren
suffix:semicolon
)brace
)brace
r_else
id|try_merge
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|try_merge
)paren
(brace
r_struct
id|diff_filespec
op_star
id|one
comma
op_star
id|a
comma
op_star
id|b
suffix:semicolon
id|src_other.path
op_assign
(paren
r_char
op_star
)paren
id|ren1_src
suffix:semicolon
id|one
op_assign
id|ren1-&gt;pair-&gt;one
suffix:semicolon
r_if
c_cond
(paren
id|a_renames
op_eq
id|renames1
)paren
(brace
id|a
op_assign
id|ren1-&gt;pair-&gt;two
suffix:semicolon
id|b
op_assign
op_amp
id|src_other
suffix:semicolon
)brace
r_else
(brace
id|b
op_assign
id|ren1-&gt;pair-&gt;two
suffix:semicolon
id|a
op_assign
op_amp
id|src_other
suffix:semicolon
)brace
id|update_entry
c_func
(paren
id|ren1-&gt;dst_entry
comma
id|one
comma
id|a
comma
id|b
)paren
suffix:semicolon
id|setup_rename_conflict_info
c_func
(paren
id|RENAME_NORMAL
comma
id|ren1-&gt;pair
comma
l_int|NULL
comma
id|branch1
comma
l_int|NULL
comma
id|ren1-&gt;dst_entry
comma
l_int|NULL
comma
id|o
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
)brace
)brace
id|string_list_clear
c_func
(paren
op_amp
id|a_by_dst
comma
l_int|0
)paren
suffix:semicolon
id|string_list_clear
c_func
(paren
op_amp
id|b_by_dst
comma
l_int|0
)paren
suffix:semicolon
r_return
id|clean_merge
suffix:semicolon
)brace
DECL|function|stage_sha
r_static
r_int
r_char
op_star
id|stage_sha
c_func
(paren
r_const
r_int
r_char
op_star
id|sha
comma
r_int
id|mode
)paren
(brace
r_return
(paren
id|is_null_sha1
c_func
(paren
id|sha
)paren
op_logical_or
id|mode
op_eq
l_int|0
)paren
ques
c_cond
l_int|NULL
suffix:colon
(paren
r_int
r_char
op_star
)paren
id|sha
suffix:semicolon
)brace
DECL|function|read_sha1_strbuf
r_static
r_int
id|read_sha1_strbuf
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
comma
r_struct
id|strbuf
op_star
id|dst
)paren
(brace
r_void
op_star
id|buf
suffix:semicolon
r_enum
id|object_type
id|type
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
id|buf
op_assign
id|read_sha1_file
c_func
(paren
id|sha1
comma
op_amp
id|type
comma
op_amp
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;cannot read object %s&quot;
)paren
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
id|OBJ_BLOB
)paren
(brace
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;object %s is not a blob&quot;
)paren
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
)brace
id|strbuf_attach
c_func
(paren
id|dst
comma
id|buf
comma
id|size
comma
id|size
op_plus
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|blob_unchanged
r_static
r_int
id|blob_unchanged
c_func
(paren
r_const
r_int
r_char
op_star
id|o_sha
comma
r_const
r_int
r_char
op_star
id|a_sha
comma
r_int
id|renormalize
comma
r_const
r_char
op_star
id|path
)paren
(brace
r_struct
id|strbuf
id|o
op_assign
id|STRBUF_INIT
suffix:semicolon
r_struct
id|strbuf
id|a
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* assume changed for safety */
r_if
c_cond
(paren
id|sha_eq
c_func
(paren
id|o_sha
comma
id|a_sha
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|renormalize
)paren
r_return
l_int|0
suffix:semicolon
m_assert
(paren
id|o_sha
op_logical_and
id|a_sha
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_sha1_strbuf
c_func
(paren
id|o_sha
comma
op_amp
id|o
)paren
op_logical_or
id|read_sha1_strbuf
c_func
(paren
id|a_sha
comma
op_amp
id|a
)paren
)paren
r_goto
id|error_return
suffix:semicolon
multiline_comment|/*&n;&t; * Note: binary | is used so that both renormalizations are&n;&t; * performed.  Comparison can be skipped if both files are&n;&t; * unchanged since their sha1s have already been compared.&n;&t; */
r_if
c_cond
(paren
id|renormalize_buffer
c_func
(paren
id|path
comma
id|o.buf
comma
id|o.len
comma
op_amp
id|o
)paren
op_or
id|renormalize_buffer
c_func
(paren
id|path
comma
id|a.buf
comma
id|o.len
comma
op_amp
id|a
)paren
)paren
id|ret
op_assign
(paren
id|o.len
op_eq
id|a.len
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|o.buf
comma
id|a.buf
comma
id|o.len
)paren
)paren
suffix:semicolon
id|error_return
suffix:colon
id|strbuf_release
c_func
(paren
op_amp
id|o
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|a
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|handle_modify_delete
r_static
r_void
id|handle_modify_delete
c_func
(paren
r_struct
id|merge_options
op_star
id|o
comma
r_const
r_char
op_star
id|path
comma
r_int
r_char
op_star
id|o_sha
comma
r_int
id|o_mode
comma
r_int
r_char
op_star
id|a_sha
comma
r_int
id|a_mode
comma
r_int
r_char
op_star
id|b_sha
comma
r_int
id|b_mode
)paren
(brace
id|handle_change_delete
c_func
(paren
id|o
comma
id|path
comma
id|o_sha
comma
id|o_mode
comma
id|a_sha
comma
id|a_mode
comma
id|b_sha
comma
id|b_mode
comma
id|_
c_func
(paren
l_string|&quot;modify&quot;
)paren
comma
id|_
c_func
(paren
l_string|&quot;modified&quot;
)paren
)paren
suffix:semicolon
)brace
DECL|function|merge_content
r_static
r_int
id|merge_content
c_func
(paren
r_struct
id|merge_options
op_star
id|o
comma
r_const
r_char
op_star
id|path
comma
r_int
r_char
op_star
id|o_sha
comma
r_int
id|o_mode
comma
r_int
r_char
op_star
id|a_sha
comma
r_int
id|a_mode
comma
r_int
r_char
op_star
id|b_sha
comma
r_int
id|b_mode
comma
r_struct
id|rename_conflict_info
op_star
id|rename_conflict_info
)paren
(brace
r_const
r_char
op_star
id|reason
op_assign
id|_
c_func
(paren
l_string|&quot;content&quot;
)paren
suffix:semicolon
r_const
r_char
op_star
id|path1
op_assign
l_int|NULL
comma
op_star
id|path2
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|merge_file_info
id|mfi
suffix:semicolon
r_struct
id|diff_filespec
id|one
comma
id|a
comma
id|b
suffix:semicolon
r_int
id|df_conflict_remains
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|o_sha
)paren
(brace
id|reason
op_assign
id|_
c_func
(paren
l_string|&quot;add/add&quot;
)paren
suffix:semicolon
id|o_sha
op_assign
(paren
r_int
r_char
op_star
)paren
id|null_sha1
suffix:semicolon
)brace
id|one.path
op_assign
id|a.path
op_assign
id|b.path
op_assign
(paren
r_char
op_star
)paren
id|path
suffix:semicolon
id|hashcpy
c_func
(paren
id|one.sha1
comma
id|o_sha
)paren
suffix:semicolon
id|one.mode
op_assign
id|o_mode
suffix:semicolon
id|hashcpy
c_func
(paren
id|a.sha1
comma
id|a_sha
)paren
suffix:semicolon
id|a.mode
op_assign
id|a_mode
suffix:semicolon
id|hashcpy
c_func
(paren
id|b.sha1
comma
id|b_sha
)paren
suffix:semicolon
id|b.mode
op_assign
id|b_mode
suffix:semicolon
r_if
c_cond
(paren
id|rename_conflict_info
)paren
(brace
r_struct
id|diff_filepair
op_star
id|pair1
op_assign
id|rename_conflict_info-&gt;pair1
suffix:semicolon
id|path1
op_assign
(paren
id|o-&gt;branch1
op_eq
id|rename_conflict_info-&gt;branch1
)paren
ques
c_cond
id|pair1-&gt;two-&gt;path
suffix:colon
id|pair1-&gt;one-&gt;path
suffix:semicolon
multiline_comment|/* If rename_conflict_info-&gt;pair2 != NULL, we are in&n;&t;&t; * RENAME_ONE_FILE_TO_ONE case.  Otherwise, we have a&n;&t;&t; * normal rename.&n;&t;&t; */
id|path2
op_assign
(paren
id|rename_conflict_info-&gt;pair2
op_logical_or
id|o-&gt;branch2
op_eq
id|rename_conflict_info-&gt;branch1
)paren
ques
c_cond
id|pair1-&gt;two-&gt;path
suffix:colon
id|pair1-&gt;one-&gt;path
suffix:semicolon
r_if
c_cond
(paren
id|dir_in_way
c_func
(paren
id|path
comma
op_logical_neg
id|o-&gt;call_depth
)paren
)paren
id|df_conflict_remains
op_assign
l_int|1
suffix:semicolon
)brace
id|mfi
op_assign
id|merge_file_special_markers
c_func
(paren
id|o
comma
op_amp
id|one
comma
op_amp
id|a
comma
op_amp
id|b
comma
id|o-&gt;branch1
comma
id|path1
comma
id|o-&gt;branch2
comma
id|path2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mfi.clean
op_logical_and
op_logical_neg
id|df_conflict_remains
op_logical_and
id|sha_eq
c_func
(paren
id|mfi.sha
comma
id|a_sha
)paren
op_logical_and
id|mfi.mode
op_eq
id|a_mode
)paren
(brace
r_int
id|path_renamed_outside_HEAD
suffix:semicolon
id|output
c_func
(paren
id|o
comma
l_int|3
comma
id|_
c_func
(paren
l_string|&quot;Skipped %s (merged same as existing)&quot;
)paren
comma
id|path
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The content merge resulted in the same file contents we&n;&t;&t; * already had.  We can return early if those file contents&n;&t;&t; * are recorded at the correct path (which may not be true&n;&t;&t; * if the merge involves a rename).&n;&t;&t; */
id|path_renamed_outside_HEAD
op_assign
op_logical_neg
id|path2
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|path
comma
id|path2
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|path_renamed_outside_HEAD
)paren
(brace
id|add_cacheinfo
c_func
(paren
id|mfi.mode
comma
id|mfi.sha
comma
id|path
comma
l_int|0
comma
(paren
op_logical_neg
id|o-&gt;call_depth
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
id|mfi.clean
suffix:semicolon
)brace
)brace
r_else
id|output
c_func
(paren
id|o
comma
l_int|2
comma
id|_
c_func
(paren
l_string|&quot;Auto-merging %s&quot;
)paren
comma
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mfi.clean
)paren
(brace
r_if
c_cond
(paren
id|S_ISGITLINK
c_func
(paren
id|mfi.mode
)paren
)paren
id|reason
op_assign
id|_
c_func
(paren
l_string|&quot;submodule&quot;
)paren
suffix:semicolon
id|output
c_func
(paren
id|o
comma
l_int|1
comma
id|_
c_func
(paren
l_string|&quot;CONFLICT (%s): Merge conflict in %s&quot;
)paren
comma
id|reason
comma
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rename_conflict_info
op_logical_and
op_logical_neg
id|df_conflict_remains
)paren
id|update_stages
c_func
(paren
id|path
comma
op_amp
id|one
comma
op_amp
id|a
comma
op_amp
id|b
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|df_conflict_remains
)paren
(brace
r_char
op_star
id|new_path
suffix:semicolon
r_if
c_cond
(paren
id|o-&gt;call_depth
)paren
(brace
id|remove_file_from_cache
c_func
(paren
id|path
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|mfi.clean
)paren
id|update_stages
c_func
(paren
id|path
comma
op_amp
id|one
comma
op_amp
id|a
comma
op_amp
id|b
)paren
suffix:semicolon
r_else
(brace
r_int
id|file_from_stage2
op_assign
id|was_tracked
c_func
(paren
id|path
)paren
suffix:semicolon
r_struct
id|diff_filespec
id|merged
suffix:semicolon
id|hashcpy
c_func
(paren
id|merged.sha1
comma
id|mfi.sha
)paren
suffix:semicolon
id|merged.mode
op_assign
id|mfi.mode
suffix:semicolon
id|update_stages
c_func
(paren
id|path
comma
l_int|NULL
comma
id|file_from_stage2
ques
c_cond
op_amp
id|merged
suffix:colon
l_int|NULL
comma
id|file_from_stage2
ques
c_cond
l_int|NULL
suffix:colon
op_amp
id|merged
)paren
suffix:semicolon
)brace
)brace
id|new_path
op_assign
id|unique_path
c_func
(paren
id|o
comma
id|path
comma
id|rename_conflict_info-&gt;branch1
)paren
suffix:semicolon
id|output
c_func
(paren
id|o
comma
l_int|1
comma
id|_
c_func
(paren
l_string|&quot;Adding as %s instead&quot;
)paren
comma
id|new_path
)paren
suffix:semicolon
id|update_file
c_func
(paren
id|o
comma
l_int|0
comma
id|mfi.sha
comma
id|mfi.mode
comma
id|new_path
)paren
suffix:semicolon
id|free
c_func
(paren
id|new_path
)paren
suffix:semicolon
id|mfi.clean
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|update_file
c_func
(paren
id|o
comma
id|mfi.clean
comma
id|mfi.sha
comma
id|mfi.mode
comma
id|path
)paren
suffix:semicolon
)brace
r_return
id|mfi.clean
suffix:semicolon
)brace
multiline_comment|/* Per entry merge function */
DECL|function|process_entry
r_static
r_int
id|process_entry
c_func
(paren
r_struct
id|merge_options
op_star
id|o
comma
r_const
r_char
op_star
id|path
comma
r_struct
id|stage_data
op_star
id|entry
)paren
(brace
multiline_comment|/*&n;&t;printf(&quot;processing entry, clean cache: %s&bslash;n&quot;, index_only ? &quot;yes&quot;: &quot;no&quot;);&n;&t;print_index_entry(&quot;&bslash;tpath: &quot;, entry);&n;&t;*/
r_int
id|clean_merge
op_assign
l_int|1
suffix:semicolon
r_int
id|normalize
op_assign
id|o-&gt;renormalize
suffix:semicolon
r_int
id|o_mode
op_assign
id|entry-&gt;stages
(braket
l_int|1
)braket
dot
id|mode
suffix:semicolon
r_int
id|a_mode
op_assign
id|entry-&gt;stages
(braket
l_int|2
)braket
dot
id|mode
suffix:semicolon
r_int
id|b_mode
op_assign
id|entry-&gt;stages
(braket
l_int|3
)braket
dot
id|mode
suffix:semicolon
r_int
r_char
op_star
id|o_sha
op_assign
id|stage_sha
c_func
(paren
id|entry-&gt;stages
(braket
l_int|1
)braket
dot
id|sha
comma
id|o_mode
)paren
suffix:semicolon
r_int
r_char
op_star
id|a_sha
op_assign
id|stage_sha
c_func
(paren
id|entry-&gt;stages
(braket
l_int|2
)braket
dot
id|sha
comma
id|a_mode
)paren
suffix:semicolon
r_int
r_char
op_star
id|b_sha
op_assign
id|stage_sha
c_func
(paren
id|entry-&gt;stages
(braket
l_int|3
)braket
dot
id|sha
comma
id|b_mode
)paren
suffix:semicolon
id|entry-&gt;processed
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;rename_conflict_info
)paren
(brace
r_struct
id|rename_conflict_info
op_star
id|conflict_info
op_assign
id|entry-&gt;rename_conflict_info
suffix:semicolon
r_switch
c_cond
(paren
id|conflict_info-&gt;rename_type
)paren
(brace
r_case
id|RENAME_NORMAL
suffix:colon
r_case
id|RENAME_ONE_FILE_TO_ONE
suffix:colon
id|clean_merge
op_assign
id|merge_content
c_func
(paren
id|o
comma
id|path
comma
id|o_sha
comma
id|o_mode
comma
id|a_sha
comma
id|a_mode
comma
id|b_sha
comma
id|b_mode
comma
id|conflict_info
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RENAME_DELETE
suffix:colon
id|clean_merge
op_assign
l_int|0
suffix:semicolon
id|conflict_rename_delete
c_func
(paren
id|o
comma
id|conflict_info-&gt;pair1
comma
id|conflict_info-&gt;branch1
comma
id|conflict_info-&gt;branch2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RENAME_ONE_FILE_TO_TWO
suffix:colon
id|clean_merge
op_assign
l_int|0
suffix:semicolon
id|conflict_rename_rename_1to2
c_func
(paren
id|o
comma
id|conflict_info
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RENAME_TWO_FILES_TO_ONE
suffix:colon
id|clean_merge
op_assign
l_int|0
suffix:semicolon
id|conflict_rename_rename_2to1
c_func
(paren
id|o
comma
id|conflict_info
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|entry-&gt;processed
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|o_sha
op_logical_and
(paren
op_logical_neg
id|a_sha
op_logical_or
op_logical_neg
id|b_sha
)paren
)paren
(brace
multiline_comment|/* Case A: Deleted in one */
r_if
c_cond
(paren
(paren
op_logical_neg
id|a_sha
op_logical_and
op_logical_neg
id|b_sha
)paren
op_logical_or
(paren
op_logical_neg
id|b_sha
op_logical_and
id|blob_unchanged
c_func
(paren
id|o_sha
comma
id|a_sha
comma
id|normalize
comma
id|path
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|a_sha
op_logical_and
id|blob_unchanged
c_func
(paren
id|o_sha
comma
id|b_sha
comma
id|normalize
comma
id|path
)paren
)paren
)paren
(brace
multiline_comment|/* Deleted in both or deleted in one and&n;&t;&t;&t; * unchanged in the other */
r_if
c_cond
(paren
id|a_sha
)paren
id|output
c_func
(paren
id|o
comma
l_int|2
comma
id|_
c_func
(paren
l_string|&quot;Removing %s&quot;
)paren
comma
id|path
)paren
suffix:semicolon
multiline_comment|/* do not touch working file if it did not exist */
id|remove_file
c_func
(paren
id|o
comma
l_int|1
comma
id|path
comma
op_logical_neg
id|a_sha
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Modify/delete; deleted side may have put a directory in the way */
id|clean_merge
op_assign
l_int|0
suffix:semicolon
id|handle_modify_delete
c_func
(paren
id|o
comma
id|path
comma
id|o_sha
comma
id|o_mode
comma
id|a_sha
comma
id|a_mode
comma
id|b_sha
comma
id|b_mode
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
op_logical_neg
id|o_sha
op_logical_and
id|a_sha
op_logical_and
op_logical_neg
id|b_sha
)paren
op_logical_or
(paren
op_logical_neg
id|o_sha
op_logical_and
op_logical_neg
id|a_sha
op_logical_and
id|b_sha
)paren
)paren
(brace
multiline_comment|/* Case B: Added in one. */
multiline_comment|/* [nothing|directory] -&gt; ([nothing|directory], file) */
r_const
r_char
op_star
id|add_branch
suffix:semicolon
r_const
r_char
op_star
id|other_branch
suffix:semicolon
r_int
id|mode
suffix:semicolon
r_const
r_int
r_char
op_star
id|sha
suffix:semicolon
r_const
r_char
op_star
id|conf
suffix:semicolon
r_if
c_cond
(paren
id|a_sha
)paren
(brace
id|add_branch
op_assign
id|o-&gt;branch1
suffix:semicolon
id|other_branch
op_assign
id|o-&gt;branch2
suffix:semicolon
id|mode
op_assign
id|a_mode
suffix:semicolon
id|sha
op_assign
id|a_sha
suffix:semicolon
id|conf
op_assign
id|_
c_func
(paren
l_string|&quot;file/directory&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|add_branch
op_assign
id|o-&gt;branch2
suffix:semicolon
id|other_branch
op_assign
id|o-&gt;branch1
suffix:semicolon
id|mode
op_assign
id|b_mode
suffix:semicolon
id|sha
op_assign
id|b_sha
suffix:semicolon
id|conf
op_assign
id|_
c_func
(paren
l_string|&quot;directory/file&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dir_in_way
c_func
(paren
id|path
comma
op_logical_neg
id|o-&gt;call_depth
)paren
)paren
(brace
r_char
op_star
id|new_path
op_assign
id|unique_path
c_func
(paren
id|o
comma
id|path
comma
id|add_branch
)paren
suffix:semicolon
id|clean_merge
op_assign
l_int|0
suffix:semicolon
id|output
c_func
(paren
id|o
comma
l_int|1
comma
id|_
c_func
(paren
l_string|&quot;CONFLICT (%s): There is a directory with name %s in %s. &quot;
l_string|&quot;Adding %s as %s&quot;
)paren
comma
id|conf
comma
id|path
comma
id|other_branch
comma
id|path
comma
id|new_path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|o-&gt;call_depth
)paren
id|remove_file_from_cache
c_func
(paren
id|path
)paren
suffix:semicolon
id|update_file
c_func
(paren
id|o
comma
l_int|0
comma
id|sha
comma
id|mode
comma
id|new_path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|o-&gt;call_depth
)paren
id|remove_file_from_cache
c_func
(paren
id|path
)paren
suffix:semicolon
id|free
c_func
(paren
id|new_path
)paren
suffix:semicolon
)brace
r_else
(brace
id|output
c_func
(paren
id|o
comma
l_int|2
comma
id|_
c_func
(paren
l_string|&quot;Adding %s&quot;
)paren
comma
id|path
)paren
suffix:semicolon
multiline_comment|/* do not overwrite file if already present */
id|update_file_flags
c_func
(paren
id|o
comma
id|sha
comma
id|mode
comma
id|path
comma
l_int|1
comma
op_logical_neg
id|a_sha
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|a_sha
op_logical_and
id|b_sha
)paren
(brace
multiline_comment|/* Case C: Added in both (check for same permissions) and */
multiline_comment|/* case D: Modified in both, but differently. */
id|clean_merge
op_assign
id|merge_content
c_func
(paren
id|o
comma
id|path
comma
id|o_sha
comma
id|o_mode
comma
id|a_sha
comma
id|a_mode
comma
id|b_sha
comma
id|b_mode
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|o_sha
op_logical_and
op_logical_neg
id|a_sha
op_logical_and
op_logical_neg
id|b_sha
)paren
(brace
multiline_comment|/*&n;&t;&t; * this entry was deleted altogether. a_mode == 0 means&n;&t;&t; * we had that path and want to actively remove it.&n;&t;&t; */
id|remove_file
c_func
(paren
id|o
comma
l_int|1
comma
id|path
comma
op_logical_neg
id|a_mode
)paren
suffix:semicolon
)brace
r_else
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Fatal merge failure, shouldn&squot;t happen.&quot;
)paren
)paren
suffix:semicolon
r_return
id|clean_merge
suffix:semicolon
)brace
DECL|function|merge_trees
r_int
id|merge_trees
c_func
(paren
r_struct
id|merge_options
op_star
id|o
comma
r_struct
id|tree
op_star
id|head
comma
r_struct
id|tree
op_star
id|merge
comma
r_struct
id|tree
op_star
id|common
comma
r_struct
id|tree
op_star
op_star
id|result
)paren
(brace
r_int
id|code
comma
id|clean
suffix:semicolon
r_if
c_cond
(paren
id|o-&gt;subtree_shift
)paren
(brace
id|merge
op_assign
id|shift_tree_object
c_func
(paren
id|head
comma
id|merge
comma
id|o-&gt;subtree_shift
)paren
suffix:semicolon
id|common
op_assign
id|shift_tree_object
c_func
(paren
id|head
comma
id|common
comma
id|o-&gt;subtree_shift
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sha_eq
c_func
(paren
id|common-&gt;object.sha1
comma
id|merge-&gt;object.sha1
)paren
)paren
(brace
id|output
c_func
(paren
id|o
comma
l_int|0
comma
id|_
c_func
(paren
l_string|&quot;Already up-to-date!&quot;
)paren
)paren
suffix:semicolon
op_star
id|result
op_assign
id|head
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|code
op_assign
id|git_merge_trees
c_func
(paren
id|o-&gt;call_depth
comma
id|common
comma
id|head
comma
id|merge
)paren
suffix:semicolon
r_if
c_cond
(paren
id|code
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|show
c_func
(paren
id|o
comma
l_int|4
)paren
op_logical_or
id|o-&gt;call_depth
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;merging of trees %s and %s failed&quot;
)paren
comma
id|sha1_to_hex
c_func
(paren
id|head-&gt;object.sha1
)paren
comma
id|sha1_to_hex
c_func
(paren
id|merge-&gt;object.sha1
)paren
)paren
suffix:semicolon
r_else
m_exit
(paren
l_int|128
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unmerged_cache
c_func
(paren
)paren
)paren
(brace
r_struct
id|string_list
op_star
id|entries
comma
op_star
id|re_head
comma
op_star
id|re_merge
suffix:semicolon
r_int
id|i
suffix:semicolon
id|string_list_clear
c_func
(paren
op_amp
id|o-&gt;current_file_set
comma
l_int|1
)paren
suffix:semicolon
id|string_list_clear
c_func
(paren
op_amp
id|o-&gt;current_directory_set
comma
l_int|1
)paren
suffix:semicolon
id|get_files_dirs
c_func
(paren
id|o
comma
id|head
)paren
suffix:semicolon
id|get_files_dirs
c_func
(paren
id|o
comma
id|merge
)paren
suffix:semicolon
id|entries
op_assign
id|get_unmerged
c_func
(paren
)paren
suffix:semicolon
id|record_df_conflict_files
c_func
(paren
id|o
comma
id|entries
)paren
suffix:semicolon
id|re_head
op_assign
id|get_renames
c_func
(paren
id|o
comma
id|head
comma
id|common
comma
id|head
comma
id|merge
comma
id|entries
)paren
suffix:semicolon
id|re_merge
op_assign
id|get_renames
c_func
(paren
id|o
comma
id|merge
comma
id|common
comma
id|head
comma
id|merge
comma
id|entries
)paren
suffix:semicolon
id|clean
op_assign
id|process_renames
c_func
(paren
id|o
comma
id|re_head
comma
id|re_merge
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|entries-&gt;nr
op_minus
l_int|1
suffix:semicolon
l_int|0
op_le
id|i
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_const
r_char
op_star
id|path
op_assign
id|entries-&gt;items
(braket
id|i
)braket
dot
id|string
suffix:semicolon
r_struct
id|stage_data
op_star
id|e
op_assign
id|entries-&gt;items
(braket
id|i
)braket
dot
id|util
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|e-&gt;processed
op_logical_and
op_logical_neg
id|process_entry
c_func
(paren
id|o
comma
id|path
comma
id|e
)paren
)paren
id|clean
op_assign
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|entries-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|stage_data
op_star
id|e
op_assign
id|entries-&gt;items
(braket
id|i
)braket
dot
id|util
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|e-&gt;processed
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Unprocessed path??? %s&quot;
)paren
comma
id|entries-&gt;items
(braket
id|i
)braket
dot
id|string
)paren
suffix:semicolon
)brace
id|string_list_clear
c_func
(paren
id|re_merge
comma
l_int|0
)paren
suffix:semicolon
id|string_list_clear
c_func
(paren
id|re_head
comma
l_int|0
)paren
suffix:semicolon
id|string_list_clear
c_func
(paren
id|entries
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
id|clean
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|o-&gt;call_depth
)paren
op_star
id|result
op_assign
id|write_tree_from_memory
c_func
(paren
id|o
)paren
suffix:semicolon
r_return
id|clean
suffix:semicolon
)brace
DECL|function|reverse_commit_list
r_static
r_struct
id|commit_list
op_star
id|reverse_commit_list
c_func
(paren
r_struct
id|commit_list
op_star
id|list
)paren
(brace
r_struct
id|commit_list
op_star
id|next
op_assign
l_int|NULL
comma
op_star
id|current
comma
op_star
id|backup
suffix:semicolon
r_for
c_loop
(paren
id|current
op_assign
id|list
suffix:semicolon
id|current
suffix:semicolon
id|current
op_assign
id|backup
)paren
(brace
id|backup
op_assign
id|current-&gt;next
suffix:semicolon
id|current-&gt;next
op_assign
id|next
suffix:semicolon
id|next
op_assign
id|current
suffix:semicolon
)brace
r_return
id|next
suffix:semicolon
)brace
multiline_comment|/*&n; * Merge the commits h1 and h2, return the resulting virtual&n; * commit object and a flag indicating the cleanness of the merge.&n; */
DECL|function|merge_recursive
r_int
id|merge_recursive
c_func
(paren
r_struct
id|merge_options
op_star
id|o
comma
r_struct
id|commit
op_star
id|h1
comma
r_struct
id|commit
op_star
id|h2
comma
r_struct
id|commit_list
op_star
id|ca
comma
r_struct
id|commit
op_star
op_star
id|result
)paren
(brace
r_struct
id|commit_list
op_star
id|iter
suffix:semicolon
r_struct
id|commit
op_star
id|merged_common_ancestors
suffix:semicolon
r_struct
id|tree
op_star
id|mrtree
op_assign
id|mrtree
suffix:semicolon
r_int
id|clean
suffix:semicolon
r_if
c_cond
(paren
id|show
c_func
(paren
id|o
comma
l_int|4
)paren
)paren
(brace
id|output
c_func
(paren
id|o
comma
l_int|4
comma
id|_
c_func
(paren
l_string|&quot;Merging:&quot;
)paren
)paren
suffix:semicolon
id|output_commit_title
c_func
(paren
id|o
comma
id|h1
)paren
suffix:semicolon
id|output_commit_title
c_func
(paren
id|o
comma
id|h2
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ca
)paren
(brace
id|ca
op_assign
id|get_merge_bases
c_func
(paren
id|h1
comma
id|h2
comma
l_int|1
)paren
suffix:semicolon
id|ca
op_assign
id|reverse_commit_list
c_func
(paren
id|ca
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|show
c_func
(paren
id|o
comma
l_int|5
)paren
)paren
(brace
r_int
id|cnt
op_assign
id|commit_list_count
c_func
(paren
id|ca
)paren
suffix:semicolon
id|output
c_func
(paren
id|o
comma
l_int|5
comma
id|Q_
c_func
(paren
l_string|&quot;found %u common ancestor:&quot;
comma
l_string|&quot;found %u common ancestors:&quot;
comma
id|cnt
)paren
comma
id|cnt
)paren
suffix:semicolon
r_for
c_loop
(paren
id|iter
op_assign
id|ca
suffix:semicolon
id|iter
suffix:semicolon
id|iter
op_assign
id|iter-&gt;next
)paren
id|output_commit_title
c_func
(paren
id|o
comma
id|iter-&gt;item
)paren
suffix:semicolon
)brace
id|merged_common_ancestors
op_assign
id|pop_commit
c_func
(paren
op_amp
id|ca
)paren
suffix:semicolon
r_if
c_cond
(paren
id|merged_common_ancestors
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* if there is no common ancestor, use an empty tree */
r_struct
id|tree
op_star
id|tree
suffix:semicolon
id|tree
op_assign
id|lookup_tree
c_func
(paren
id|EMPTY_TREE_SHA1_BIN
)paren
suffix:semicolon
id|merged_common_ancestors
op_assign
id|make_virtual_commit
c_func
(paren
id|tree
comma
l_string|&quot;ancestor&quot;
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|iter
op_assign
id|ca
suffix:semicolon
id|iter
suffix:semicolon
id|iter
op_assign
id|iter-&gt;next
)paren
(brace
r_const
r_char
op_star
id|saved_b1
comma
op_star
id|saved_b2
suffix:semicolon
id|o-&gt;call_depth
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t; * When the merge fails, the result contains files&n;&t;&t; * with conflict markers. The cleanness flag is&n;&t;&t; * ignored, it was never actually used, as result of&n;&t;&t; * merge_trees has always overwritten it: the committed&n;&t;&t; * &quot;conflicts&quot; were already resolved.&n;&t;&t; */
id|discard_cache
c_func
(paren
)paren
suffix:semicolon
id|saved_b1
op_assign
id|o-&gt;branch1
suffix:semicolon
id|saved_b2
op_assign
id|o-&gt;branch2
suffix:semicolon
id|o-&gt;branch1
op_assign
l_string|&quot;Temporary merge branch 1&quot;
suffix:semicolon
id|o-&gt;branch2
op_assign
l_string|&quot;Temporary merge branch 2&quot;
suffix:semicolon
id|merge_recursive
c_func
(paren
id|o
comma
id|merged_common_ancestors
comma
id|iter-&gt;item
comma
l_int|NULL
comma
op_amp
id|merged_common_ancestors
)paren
suffix:semicolon
id|o-&gt;branch1
op_assign
id|saved_b1
suffix:semicolon
id|o-&gt;branch2
op_assign
id|saved_b2
suffix:semicolon
id|o-&gt;call_depth
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|merged_common_ancestors
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;merge returned no commit&quot;
)paren
)paren
suffix:semicolon
)brace
id|discard_cache
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|o-&gt;call_depth
)paren
id|read_cache
c_func
(paren
)paren
suffix:semicolon
id|o-&gt;ancestor
op_assign
l_string|&quot;merged common ancestors&quot;
suffix:semicolon
id|clean
op_assign
id|merge_trees
c_func
(paren
id|o
comma
id|h1-&gt;tree
comma
id|h2-&gt;tree
comma
id|merged_common_ancestors-&gt;tree
comma
op_amp
id|mrtree
)paren
suffix:semicolon
r_if
c_cond
(paren
id|o-&gt;call_depth
)paren
(brace
op_star
id|result
op_assign
id|make_virtual_commit
c_func
(paren
id|mrtree
comma
l_string|&quot;merged tree&quot;
)paren
suffix:semicolon
id|commit_list_insert
c_func
(paren
id|h1
comma
op_amp
(paren
op_star
id|result
)paren
op_member_access_from_pointer
id|parents
)paren
suffix:semicolon
id|commit_list_insert
c_func
(paren
id|h2
comma
op_amp
(paren
op_star
id|result
)paren
op_member_access_from_pointer
id|parents-&gt;next
)paren
suffix:semicolon
)brace
id|flush_output
c_func
(paren
id|o
)paren
suffix:semicolon
r_if
c_cond
(paren
id|show
c_func
(paren
id|o
comma
l_int|2
)paren
)paren
id|diff_warn_rename_limit
c_func
(paren
l_string|&quot;merge.renamelimit&quot;
comma
id|o-&gt;needed_rename_limit
comma
l_int|0
)paren
suffix:semicolon
r_return
id|clean
suffix:semicolon
)brace
DECL|function|get_ref
r_static
r_struct
id|commit
op_star
id|get_ref
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|object
op_star
id|object
suffix:semicolon
id|object
op_assign
id|deref_tag
c_func
(paren
id|parse_object
c_func
(paren
id|sha1
)paren
comma
id|name
comma
id|strlen
c_func
(paren
id|name
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|object
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|object-&gt;type
op_eq
id|OBJ_TREE
)paren
r_return
id|make_virtual_commit
c_func
(paren
(paren
r_struct
id|tree
op_star
)paren
id|object
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|object-&gt;type
op_ne
id|OBJ_COMMIT
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|parse_commit
c_func
(paren
(paren
r_struct
id|commit
op_star
)paren
id|object
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
(paren
r_struct
id|commit
op_star
)paren
id|object
suffix:semicolon
)brace
DECL|function|merge_recursive_generic
r_int
id|merge_recursive_generic
c_func
(paren
r_struct
id|merge_options
op_star
id|o
comma
r_const
r_int
r_char
op_star
id|head
comma
r_const
r_int
r_char
op_star
id|merge
comma
r_int
id|num_base_list
comma
r_const
r_int
r_char
op_star
op_star
id|base_list
comma
r_struct
id|commit
op_star
op_star
id|result
)paren
(brace
r_int
id|clean
suffix:semicolon
r_struct
id|lock_file
op_star
id|lock
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|lock_file
)paren
)paren
suffix:semicolon
r_struct
id|commit
op_star
id|head_commit
op_assign
id|get_ref
c_func
(paren
id|head
comma
id|o-&gt;branch1
)paren
suffix:semicolon
r_struct
id|commit
op_star
id|next_commit
op_assign
id|get_ref
c_func
(paren
id|merge
comma
id|o-&gt;branch2
)paren
suffix:semicolon
r_struct
id|commit_list
op_star
id|ca
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|base_list
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_base_list
suffix:semicolon
op_increment
id|i
)paren
(brace
r_struct
id|commit
op_star
id|base
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|base
op_assign
id|get_ref
c_func
(paren
id|base_list
(braket
id|i
)braket
comma
id|sha1_to_hex
c_func
(paren
id|base_list
(braket
id|i
)braket
)paren
)paren
)paren
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Could not parse object &squot;%s&squot;&quot;
)paren
comma
id|sha1_to_hex
c_func
(paren
id|base_list
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
id|commit_list_insert
c_func
(paren
id|base
comma
op_amp
id|ca
)paren
suffix:semicolon
)brace
)brace
id|hold_locked_index
c_func
(paren
id|lock
comma
l_int|1
)paren
suffix:semicolon
id|clean
op_assign
id|merge_recursive
c_func
(paren
id|o
comma
id|head_commit
comma
id|next_commit
comma
id|ca
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|active_cache_changed
op_logical_and
id|write_locked_index
c_func
(paren
op_amp
id|the_index
comma
id|lock
comma
id|COMMIT_LOCK
)paren
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Unable to write index.&quot;
)paren
)paren
suffix:semicolon
r_return
id|clean
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
)brace
DECL|function|merge_recursive_config
r_static
r_void
id|merge_recursive_config
c_func
(paren
r_struct
id|merge_options
op_star
id|o
)paren
(brace
id|git_config_get_int
c_func
(paren
l_string|&quot;merge.verbosity&quot;
comma
op_amp
id|o-&gt;verbosity
)paren
suffix:semicolon
id|git_config_get_int
c_func
(paren
l_string|&quot;diff.renamelimit&quot;
comma
op_amp
id|o-&gt;diff_rename_limit
)paren
suffix:semicolon
id|git_config_get_int
c_func
(paren
l_string|&quot;merge.renamelimit&quot;
comma
op_amp
id|o-&gt;merge_rename_limit
)paren
suffix:semicolon
id|git_config
c_func
(paren
id|git_xmerge_config
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|init_merge_options
r_void
id|init_merge_options
c_func
(paren
r_struct
id|merge_options
op_star
id|o
)paren
(brace
id|memset
c_func
(paren
id|o
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|merge_options
)paren
)paren
suffix:semicolon
id|o-&gt;verbosity
op_assign
l_int|2
suffix:semicolon
id|o-&gt;buffer_output
op_assign
l_int|1
suffix:semicolon
id|o-&gt;diff_rename_limit
op_assign
l_int|1
suffix:semicolon
id|o-&gt;merge_rename_limit
op_assign
l_int|1
suffix:semicolon
id|o-&gt;renormalize
op_assign
l_int|0
suffix:semicolon
id|merge_recursive_config
c_func
(paren
id|o
)paren
suffix:semicolon
r_if
c_cond
(paren
id|getenv
c_func
(paren
l_string|&quot;GIT_MERGE_VERBOSITY&quot;
)paren
)paren
id|o-&gt;verbosity
op_assign
id|strtol
c_func
(paren
id|getenv
c_func
(paren
l_string|&quot;GIT_MERGE_VERBOSITY&quot;
)paren
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|o-&gt;verbosity
op_ge
l_int|5
)paren
id|o-&gt;buffer_output
op_assign
l_int|0
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|o-&gt;obuf
comma
l_int|0
)paren
suffix:semicolon
id|string_list_init
c_func
(paren
op_amp
id|o-&gt;current_file_set
comma
l_int|1
)paren
suffix:semicolon
id|string_list_init
c_func
(paren
op_amp
id|o-&gt;current_directory_set
comma
l_int|1
)paren
suffix:semicolon
id|string_list_init
c_func
(paren
op_amp
id|o-&gt;df_conflict_file_set
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|parse_merge_opt
r_int
id|parse_merge_opt
c_func
(paren
r_struct
id|merge_options
op_star
id|o
comma
r_const
r_char
op_star
id|s
)paren
(brace
r_const
r_char
op_star
id|arg
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s
op_logical_or
op_logical_neg
op_star
id|s
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|s
comma
l_string|&quot;ours&quot;
)paren
)paren
id|o-&gt;recursive_variant
op_assign
id|MERGE_RECURSIVE_OURS
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|s
comma
l_string|&quot;theirs&quot;
)paren
)paren
id|o-&gt;recursive_variant
op_assign
id|MERGE_RECURSIVE_THEIRS
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|s
comma
l_string|&quot;subtree&quot;
)paren
)paren
id|o-&gt;subtree_shift
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|skip_prefix
c_func
(paren
id|s
comma
l_string|&quot;subtree=&quot;
comma
op_amp
id|arg
)paren
)paren
id|o-&gt;subtree_shift
op_assign
id|arg
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|s
comma
l_string|&quot;patience&quot;
)paren
)paren
id|o-&gt;xdl_opts
op_assign
id|DIFF_WITH_ALG
c_func
(paren
id|o
comma
id|PATIENCE_DIFF
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|s
comma
l_string|&quot;histogram&quot;
)paren
)paren
id|o-&gt;xdl_opts
op_assign
id|DIFF_WITH_ALG
c_func
(paren
id|o
comma
id|HISTOGRAM_DIFF
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|skip_prefix
c_func
(paren
id|s
comma
l_string|&quot;diff-algorithm=&quot;
comma
op_amp
id|arg
)paren
)paren
(brace
r_int
id|value
op_assign
id|parse_algorithm_value
c_func
(paren
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* clear out previous settings */
id|DIFF_XDL_CLR
c_func
(paren
id|o
comma
id|NEED_MINIMAL
)paren
suffix:semicolon
id|o-&gt;xdl_opts
op_and_assign
op_complement
id|XDF_DIFF_ALGORITHM_MASK
suffix:semicolon
id|o-&gt;xdl_opts
op_or_assign
id|value
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|s
comma
l_string|&quot;ignore-space-change&quot;
)paren
)paren
id|o-&gt;xdl_opts
op_or_assign
id|XDF_IGNORE_WHITESPACE_CHANGE
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|s
comma
l_string|&quot;ignore-all-space&quot;
)paren
)paren
id|o-&gt;xdl_opts
op_or_assign
id|XDF_IGNORE_WHITESPACE
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|s
comma
l_string|&quot;ignore-space-at-eol&quot;
)paren
)paren
id|o-&gt;xdl_opts
op_or_assign
id|XDF_IGNORE_WHITESPACE_AT_EOL
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|s
comma
l_string|&quot;renormalize&quot;
)paren
)paren
id|o-&gt;renormalize
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|s
comma
l_string|&quot;no-renormalize&quot;
)paren
)paren
id|o-&gt;renormalize
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|skip_prefix
c_func
(paren
id|s
comma
l_string|&quot;rename-threshold=&quot;
comma
op_amp
id|arg
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|o-&gt;rename_score
op_assign
id|parse_rename_score
c_func
(paren
op_amp
id|arg
)paren
)paren
op_eq
l_int|1
op_logical_or
op_star
id|arg
op_ne
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
