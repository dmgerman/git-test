macro_line|#include &quot;builtin.h&quot;
macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;refs.h&quot;
macro_line|#include &quot;object.h&quot;
macro_line|#include &quot;tag.h&quot;
macro_line|#include &quot;commit.h&quot;
macro_line|#include &quot;tree.h&quot;
macro_line|#include &quot;blob.h&quot;
macro_line|#include &quot;quote.h&quot;
macro_line|#include &quot;parse-options.h&quot;
multiline_comment|/* Quoting styles */
DECL|macro|QUOTE_NONE
mdefine_line|#define QUOTE_NONE 0
DECL|macro|QUOTE_SHELL
mdefine_line|#define QUOTE_SHELL 1
DECL|macro|QUOTE_PERL
mdefine_line|#define QUOTE_PERL 2
DECL|macro|QUOTE_PYTHON
mdefine_line|#define QUOTE_PYTHON 4
DECL|macro|QUOTE_TCL
mdefine_line|#define QUOTE_TCL 8
DECL|enumerator|FIELD_STR
DECL|enumerator|FIELD_ULONG
DECL|enumerator|FIELD_TIME
DECL|typedef|cmp_type
r_typedef
r_enum
(brace
id|FIELD_STR
comma
id|FIELD_ULONG
comma
id|FIELD_TIME
)brace
id|cmp_type
suffix:semicolon
DECL|struct|atom_value
r_struct
id|atom_value
(brace
DECL|member|s
r_const
r_char
op_star
id|s
suffix:semicolon
DECL|member|ul
r_int
r_int
id|ul
suffix:semicolon
multiline_comment|/* used for sorting when not FIELD_STR */
)brace
suffix:semicolon
DECL|struct|ref_sort
r_struct
id|ref_sort
(brace
DECL|member|next
r_struct
id|ref_sort
op_star
id|next
suffix:semicolon
DECL|member|atom
r_int
id|atom
suffix:semicolon
multiline_comment|/* index into used_atom array */
DECL|member|reverse
r_int
id|reverse
suffix:colon
l_int|1
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|refinfo
r_struct
id|refinfo
(brace
DECL|member|refname
r_char
op_star
id|refname
suffix:semicolon
DECL|member|objectname
r_int
r_char
id|objectname
(braket
l_int|20
)braket
suffix:semicolon
DECL|member|value
r_struct
id|atom_value
op_star
id|value
suffix:semicolon
)brace
suffix:semicolon
r_static
r_struct
(brace
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
DECL|member|cmp_type
id|cmp_type
id|cmp_type
suffix:semicolon
DECL|variable|valid_atom
)brace
id|valid_atom
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;refname&quot;
)brace
comma
(brace
l_string|&quot;objecttype&quot;
)brace
comma
(brace
l_string|&quot;objectsize&quot;
comma
id|FIELD_ULONG
)brace
comma
(brace
l_string|&quot;objectname&quot;
)brace
comma
(brace
l_string|&quot;tree&quot;
)brace
comma
(brace
l_string|&quot;parent&quot;
)brace
comma
(brace
l_string|&quot;numparent&quot;
comma
id|FIELD_ULONG
)brace
comma
(brace
l_string|&quot;object&quot;
)brace
comma
(brace
l_string|&quot;type&quot;
)brace
comma
(brace
l_string|&quot;tag&quot;
)brace
comma
(brace
l_string|&quot;author&quot;
)brace
comma
(brace
l_string|&quot;authorname&quot;
)brace
comma
(brace
l_string|&quot;authoremail&quot;
)brace
comma
(brace
l_string|&quot;authordate&quot;
comma
id|FIELD_TIME
)brace
comma
(brace
l_string|&quot;committer&quot;
)brace
comma
(brace
l_string|&quot;committername&quot;
)brace
comma
(brace
l_string|&quot;committeremail&quot;
)brace
comma
(brace
l_string|&quot;committerdate&quot;
comma
id|FIELD_TIME
)brace
comma
(brace
l_string|&quot;tagger&quot;
)brace
comma
(brace
l_string|&quot;taggername&quot;
)brace
comma
(brace
l_string|&quot;taggeremail&quot;
)brace
comma
(brace
l_string|&quot;taggerdate&quot;
comma
id|FIELD_TIME
)brace
comma
(brace
l_string|&quot;creator&quot;
)brace
comma
(brace
l_string|&quot;creatordate&quot;
comma
id|FIELD_TIME
)brace
comma
(brace
l_string|&quot;subject&quot;
)brace
comma
(brace
l_string|&quot;body&quot;
)brace
comma
(brace
l_string|&quot;contents&quot;
)brace
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * An atom is a valid field atom listed above, possibly prefixed with&n; * a &quot;*&quot; to denote deref_tag().&n; *&n; * We parse given format string and sort specifiers, and make a list&n; * of properties that we need to extract out of objects.  refinfo&n; * structure will hold an array of values extracted that can be&n; * indexed with the &quot;atom number&quot;, which is an index into this&n; * array.&n; */
DECL|variable|used_atom
r_static
r_const
r_char
op_star
op_star
id|used_atom
suffix:semicolon
DECL|variable|used_atom_type
r_static
id|cmp_type
op_star
id|used_atom_type
suffix:semicolon
DECL|variable|used_atom_cnt
DECL|variable|sort_atom_limit
DECL|variable|need_tagged
r_static
r_int
id|used_atom_cnt
comma
id|sort_atom_limit
comma
id|need_tagged
suffix:semicolon
multiline_comment|/*&n; * Used to parse format string and sort specifiers&n; */
DECL|function|parse_atom
r_static
r_int
id|parse_atom
c_func
(paren
r_const
r_char
op_star
id|atom
comma
r_const
r_char
op_star
id|ep
)paren
(brace
r_const
r_char
op_star
id|sp
suffix:semicolon
r_int
id|i
comma
id|at
suffix:semicolon
id|sp
op_assign
id|atom
suffix:semicolon
r_if
c_cond
(paren
op_star
id|sp
op_eq
l_char|&squot;*&squot;
op_logical_and
id|sp
OL
id|ep
)paren
id|sp
op_increment
suffix:semicolon
multiline_comment|/* deref */
r_if
c_cond
(paren
id|ep
op_le
id|sp
)paren
id|die
c_func
(paren
l_string|&quot;malformed field name: %.*s&quot;
comma
(paren
r_int
)paren
(paren
id|ep
op_minus
id|atom
)paren
comma
id|atom
)paren
suffix:semicolon
multiline_comment|/* Do we have the atom already used elsewhere? */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|used_atom_cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|used_atom
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
id|ep
id|atom
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|used_atom
(braket
id|i
)braket
comma
id|atom
comma
id|len
)paren
)paren
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/* Is the atom a valid one? */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|valid_atom
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|valid_atom
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the atom name has a colon, strip it and everything after&n;&t;&t; * it off - it specifies the format for this entry, and&n;&t;&t; * shouldn&squot;t be used for checking against the valid_atom&n;&t;&t; * table.&n;&t;&t; */
r_const
r_char
op_star
id|formatp
op_assign
id|strchr
c_func
(paren
id|sp
comma
l_char|&squot;:&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|formatp
op_logical_or
id|ep
OL
id|formatp
)paren
id|formatp
op_assign
id|ep
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
id|formatp
id|sp
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|valid_atom
(braket
id|i
)braket
dot
id|name
comma
id|sp
comma
id|len
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ARRAY_SIZE
c_func
(paren
id|valid_atom
)paren
op_le
id|i
)paren
id|die
c_func
(paren
l_string|&quot;unknown field name: %.*s&quot;
comma
(paren
r_int
)paren
(paren
id|ep
op_minus
id|atom
)paren
comma
id|atom
)paren
suffix:semicolon
multiline_comment|/* Add it in, including the deref prefix */
id|at
op_assign
id|used_atom_cnt
suffix:semicolon
id|used_atom_cnt
op_increment
suffix:semicolon
id|used_atom
op_assign
id|xrealloc
c_func
(paren
id|used_atom
comma
(paren
r_sizeof
op_star
id|used_atom
)paren
op_star
id|used_atom_cnt
)paren
suffix:semicolon
id|used_atom_type
op_assign
id|xrealloc
c_func
(paren
id|used_atom_type
comma
(paren
r_sizeof
(paren
op_star
id|used_atom_type
)paren
op_star
id|used_atom_cnt
)paren
)paren
suffix:semicolon
id|used_atom
(braket
id|at
)braket
op_assign
id|xmemdupz
c_func
(paren
id|atom
comma
id|ep
id|atom
)paren
suffix:semicolon
id|used_atom_type
(braket
id|at
)braket
op_assign
id|valid_atom
(braket
id|i
)braket
dot
id|cmp_type
suffix:semicolon
r_return
id|at
suffix:semicolon
)brace
multiline_comment|/*&n; * In a format string, find the next occurrence of %(atom).&n; */
DECL|function|find_next
r_static
r_const
r_char
op_star
id|find_next
c_func
(paren
r_const
r_char
op_star
id|cp
)paren
(brace
r_while
c_loop
(paren
op_star
id|cp
)paren
(brace
r_if
c_cond
(paren
op_star
id|cp
op_eq
l_char|&squot;%&squot;
)paren
(brace
multiline_comment|/* %( is the start of an atom;&n;&t;&t;&t; * %% is a quoted per-cent.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|cp
(braket
l_int|1
)braket
op_eq
l_char|&squot;(&squot;
)paren
r_return
id|cp
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cp
(braket
l_int|1
)braket
op_eq
l_char|&squot;%&squot;
)paren
id|cp
op_increment
suffix:semicolon
multiline_comment|/* skip over two % */
multiline_comment|/* otherwise this is a singleton, literal % */
)brace
id|cp
op_increment
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Make sure the format string is well formed, and parse out&n; * the used atoms.&n; */
DECL|function|verify_format
r_static
r_int
id|verify_format
c_func
(paren
r_const
r_char
op_star
id|format
)paren
(brace
r_const
r_char
op_star
id|cp
comma
op_star
id|sp
suffix:semicolon
r_for
c_loop
(paren
id|cp
op_assign
id|format
suffix:semicolon
op_star
id|cp
op_logical_and
(paren
id|sp
op_assign
id|find_next
c_func
(paren
id|cp
)paren
)paren
suffix:semicolon
)paren
(brace
r_const
r_char
op_star
id|ep
op_assign
id|strchr
c_func
(paren
id|sp
comma
l_char|&squot;)&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ep
)paren
r_return
id|error
c_func
(paren
l_string|&quot;malformed format string %s&quot;
comma
id|sp
)paren
suffix:semicolon
multiline_comment|/* sp points at &quot;%(&quot; and ep points at the closing &quot;)&quot; */
id|parse_atom
c_func
(paren
id|sp
op_plus
l_int|2
comma
id|ep
)paren
suffix:semicolon
id|cp
op_assign
id|ep
op_plus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Given an object name, read the object data and size, and return a&n; * &quot;struct object&quot;.  If the object data we are returning is also borrowed&n; * by the &quot;struct object&quot; representation, set *eaten as well---it is a&n; * signal from parse_object_buffer to us not to free the buffer.&n; */
DECL|function|get_obj
r_static
r_void
op_star
id|get_obj
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
comma
r_struct
id|object
op_star
op_star
id|obj
comma
r_int
r_int
op_star
id|sz
comma
r_int
op_star
id|eaten
)paren
(brace
r_enum
id|object_type
id|type
suffix:semicolon
r_void
op_star
id|buf
op_assign
id|read_sha1_file
c_func
(paren
id|sha1
comma
op_amp
id|type
comma
id|sz
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf
)paren
op_star
id|obj
op_assign
id|parse_object_buffer
c_func
(paren
id|sha1
comma
id|type
comma
op_star
id|sz
comma
id|buf
comma
id|eaten
)paren
suffix:semicolon
r_else
op_star
id|obj
op_assign
l_int|NULL
suffix:semicolon
r_return
id|buf
suffix:semicolon
)brace
multiline_comment|/* See grab_values */
DECL|function|grab_common_values
r_static
r_void
id|grab_common_values
c_func
(paren
r_struct
id|atom_value
op_star
id|val
comma
r_int
id|deref
comma
r_struct
id|object
op_star
id|obj
comma
r_void
op_star
id|buf
comma
r_int
r_int
id|sz
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|used_atom_cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_char
op_star
id|name
op_assign
id|used_atom
(braket
id|i
)braket
suffix:semicolon
r_struct
id|atom_value
op_star
id|v
op_assign
op_amp
id|val
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_logical_neg
id|deref
op_ne
(paren
op_star
id|name
op_eq
l_char|&squot;*&squot;
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|deref
)paren
id|name
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;objecttype&quot;
)paren
)paren
id|v-&gt;s
op_assign
r_typename
(paren
id|obj-&gt;type
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;objectsize&quot;
)paren
)paren
(brace
r_char
op_star
id|s
op_assign
id|xmalloc
c_func
(paren
l_int|40
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|s
comma
l_string|&quot;%lu&quot;
comma
id|sz
)paren
suffix:semicolon
id|v-&gt;ul
op_assign
id|sz
suffix:semicolon
id|v-&gt;s
op_assign
id|s
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;objectname&quot;
)paren
)paren
(brace
r_char
op_star
id|s
op_assign
id|xmalloc
c_func
(paren
l_int|41
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|s
comma
id|sha1_to_hex
c_func
(paren
id|obj-&gt;sha1
)paren
)paren
suffix:semicolon
id|v-&gt;s
op_assign
id|s
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* See grab_values */
DECL|function|grab_tag_values
r_static
r_void
id|grab_tag_values
c_func
(paren
r_struct
id|atom_value
op_star
id|val
comma
r_int
id|deref
comma
r_struct
id|object
op_star
id|obj
comma
r_void
op_star
id|buf
comma
r_int
r_int
id|sz
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|tag
op_star
id|tag
op_assign
(paren
r_struct
id|tag
op_star
)paren
id|obj
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|used_atom_cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_char
op_star
id|name
op_assign
id|used_atom
(braket
id|i
)braket
suffix:semicolon
r_struct
id|atom_value
op_star
id|v
op_assign
op_amp
id|val
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_logical_neg
id|deref
op_ne
(paren
op_star
id|name
op_eq
l_char|&squot;*&squot;
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|deref
)paren
id|name
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;tag&quot;
)paren
)paren
id|v-&gt;s
op_assign
id|tag-&gt;tag
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;type&quot;
)paren
op_logical_and
id|tag-&gt;tagged
)paren
id|v-&gt;s
op_assign
r_typename
(paren
id|tag-&gt;tagged-&gt;type
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;object&quot;
)paren
op_logical_and
id|tag-&gt;tagged
)paren
(brace
r_char
op_star
id|s
op_assign
id|xmalloc
c_func
(paren
l_int|41
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|s
comma
id|sha1_to_hex
c_func
(paren
id|tag-&gt;tagged-&gt;sha1
)paren
)paren
suffix:semicolon
id|v-&gt;s
op_assign
id|s
suffix:semicolon
)brace
)brace
)brace
DECL|function|num_parents
r_static
r_int
id|num_parents
c_func
(paren
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_struct
id|commit_list
op_star
id|parents
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|parents
op_assign
id|commit-&gt;parents
suffix:semicolon
id|parents
suffix:semicolon
id|parents
op_assign
id|parents-&gt;next
)paren
id|i
op_increment
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/* See grab_values */
DECL|function|grab_commit_values
r_static
r_void
id|grab_commit_values
c_func
(paren
r_struct
id|atom_value
op_star
id|val
comma
r_int
id|deref
comma
r_struct
id|object
op_star
id|obj
comma
r_void
op_star
id|buf
comma
r_int
r_int
id|sz
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|commit
op_star
id|commit
op_assign
(paren
r_struct
id|commit
op_star
)paren
id|obj
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|used_atom_cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_char
op_star
id|name
op_assign
id|used_atom
(braket
id|i
)braket
suffix:semicolon
r_struct
id|atom_value
op_star
id|v
op_assign
op_amp
id|val
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_logical_neg
id|deref
op_ne
(paren
op_star
id|name
op_eq
l_char|&squot;*&squot;
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|deref
)paren
id|name
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;tree&quot;
)paren
)paren
(brace
r_char
op_star
id|s
op_assign
id|xmalloc
c_func
(paren
l_int|41
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|s
comma
id|sha1_to_hex
c_func
(paren
id|commit-&gt;tree-&gt;object.sha1
)paren
)paren
suffix:semicolon
id|v-&gt;s
op_assign
id|s
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;numparent&quot;
)paren
)paren
(brace
r_char
op_star
id|s
op_assign
id|xmalloc
c_func
(paren
l_int|40
)paren
suffix:semicolon
id|v-&gt;ul
op_assign
id|num_parents
c_func
(paren
id|commit
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|s
comma
l_string|&quot;%lu&quot;
comma
id|v-&gt;ul
)paren
suffix:semicolon
id|v-&gt;s
op_assign
id|s
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;parent&quot;
)paren
)paren
(brace
r_int
id|num
op_assign
id|num_parents
c_func
(paren
id|commit
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|commit_list
op_star
id|parents
suffix:semicolon
r_char
op_star
id|s
op_assign
id|xmalloc
c_func
(paren
l_int|41
op_star
id|num
op_plus
l_int|1
)paren
suffix:semicolon
id|v-&gt;s
op_assign
id|s
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|parents
op_assign
id|commit-&gt;parents
suffix:semicolon
id|parents
suffix:semicolon
id|parents
op_assign
id|parents-&gt;next
comma
id|i
op_assign
id|i
op_plus
l_int|41
)paren
(brace
r_struct
id|commit
op_star
id|parent
op_assign
id|parents-&gt;item
suffix:semicolon
id|strcpy
c_func
(paren
id|s
op_plus
id|i
comma
id|sha1_to_hex
c_func
(paren
id|parent-&gt;object.sha1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parents-&gt;next
)paren
id|s
(braket
id|i
op_plus
l_int|40
)braket
op_assign
l_char|&squot; &squot;
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
op_star
id|s
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
)brace
)brace
DECL|function|find_wholine
r_static
r_const
r_char
op_star
id|find_wholine
c_func
(paren
r_const
r_char
op_star
id|who
comma
r_int
id|wholen
comma
r_const
r_char
op_star
id|buf
comma
r_int
r_int
id|sz
)paren
(brace
r_const
r_char
op_star
id|eol
suffix:semicolon
r_while
c_loop
(paren
op_star
id|buf
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|buf
comma
id|who
comma
id|wholen
)paren
op_logical_and
id|buf
(braket
id|wholen
)braket
op_eq
l_char|&squot; &squot;
)paren
r_return
id|buf
op_plus
id|wholen
op_plus
l_int|1
suffix:semicolon
id|eol
op_assign
id|strchr
c_func
(paren
id|buf
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|eol
)paren
r_return
l_string|&quot;&quot;
suffix:semicolon
id|eol
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|eol
op_eq
l_char|&squot;&bslash;n&squot;
)paren
r_return
l_string|&quot;&quot;
suffix:semicolon
multiline_comment|/* end of header */
id|buf
op_assign
id|eol
suffix:semicolon
)brace
r_return
l_string|&quot;&quot;
suffix:semicolon
)brace
DECL|function|copy_line
r_static
r_const
r_char
op_star
id|copy_line
c_func
(paren
r_const
r_char
op_star
id|buf
)paren
(brace
r_const
r_char
op_star
id|eol
op_assign
id|strchrnul
c_func
(paren
id|buf
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_return
id|xmemdupz
c_func
(paren
id|buf
comma
id|eol
id|buf
)paren
suffix:semicolon
)brace
DECL|function|copy_name
r_static
r_const
r_char
op_star
id|copy_name
c_func
(paren
r_const
r_char
op_star
id|buf
)paren
(brace
r_const
r_char
op_star
id|cp
suffix:semicolon
r_for
c_loop
(paren
id|cp
op_assign
id|buf
suffix:semicolon
op_star
id|cp
op_logical_and
op_star
id|cp
op_ne
l_char|&squot;&bslash;n&squot;
suffix:semicolon
id|cp
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|cp
comma
l_string|&quot; &lt;&quot;
comma
l_int|2
)paren
)paren
r_return
id|xmemdupz
c_func
(paren
id|buf
comma
id|cp
id|buf
)paren
suffix:semicolon
)brace
r_return
l_string|&quot;&quot;
suffix:semicolon
)brace
DECL|function|copy_email
r_static
r_const
r_char
op_star
id|copy_email
c_func
(paren
r_const
r_char
op_star
id|buf
)paren
(brace
r_const
r_char
op_star
id|email
op_assign
id|strchr
c_func
(paren
id|buf
comma
l_char|&squot;&lt;&squot;
)paren
suffix:semicolon
r_const
r_char
op_star
id|eoemail
op_assign
id|strchr
c_func
(paren
id|email
comma
l_char|&squot;&gt;&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|email
op_logical_or
op_logical_neg
id|eoemail
)paren
r_return
l_string|&quot;&quot;
suffix:semicolon
r_return
id|xmemdupz
c_func
(paren
id|email
comma
id|eoemail
op_plus
l_int|1
id|email
)paren
suffix:semicolon
)brace
DECL|function|grab_date
r_static
r_void
id|grab_date
c_func
(paren
r_const
r_char
op_star
id|buf
comma
r_struct
id|atom_value
op_star
id|v
comma
r_const
r_char
op_star
id|atomname
)paren
(brace
r_const
r_char
op_star
id|eoemail
op_assign
id|strstr
c_func
(paren
id|buf
comma
l_string|&quot;&gt; &quot;
)paren
suffix:semicolon
r_char
op_star
id|zone
suffix:semicolon
r_int
r_int
id|timestamp
suffix:semicolon
r_int
id|tz
suffix:semicolon
r_enum
id|date_mode
id|date_mode
op_assign
id|DATE_NORMAL
suffix:semicolon
r_const
r_char
op_star
id|formatp
suffix:semicolon
multiline_comment|/*&n;&t; * We got here because atomname ends in &quot;date&quot; or &quot;date&lt;something&gt;&quot;;&n;&t; * it&squot;s not possible that &lt;something&gt; is not &quot;:&lt;format&gt;&quot; because&n;&t; * parse_atom() wouldn&squot;t have allowed it, so we can assume that no&n;&t; * &quot;:&quot; means no format is specified, and use the default.&n;&t; */
id|formatp
op_assign
id|strchr
c_func
(paren
id|atomname
comma
l_char|&squot;:&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|formatp
op_ne
l_int|NULL
)paren
(brace
id|formatp
op_increment
suffix:semicolon
id|date_mode
op_assign
id|parse_date_format
c_func
(paren
id|formatp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|eoemail
)paren
r_goto
id|bad
suffix:semicolon
id|timestamp
op_assign
id|strtoul
c_func
(paren
id|eoemail
op_plus
l_int|2
comma
op_amp
id|zone
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timestamp
op_eq
id|ULONG_MAX
)paren
r_goto
id|bad
suffix:semicolon
id|tz
op_assign
id|strtol
c_func
(paren
id|zone
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tz
op_eq
id|LONG_MIN
op_logical_or
id|tz
op_eq
id|LONG_MAX
)paren
op_logical_and
id|errno
op_eq
id|ERANGE
)paren
r_goto
id|bad
suffix:semicolon
id|v-&gt;s
op_assign
id|xstrdup
c_func
(paren
id|show_date
c_func
(paren
id|timestamp
comma
id|tz
comma
id|date_mode
)paren
)paren
suffix:semicolon
id|v-&gt;ul
op_assign
id|timestamp
suffix:semicolon
r_return
suffix:semicolon
id|bad
suffix:colon
id|v-&gt;s
op_assign
l_string|&quot;&quot;
suffix:semicolon
id|v-&gt;ul
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* See grab_values */
DECL|function|grab_person
r_static
r_void
id|grab_person
c_func
(paren
r_const
r_char
op_star
id|who
comma
r_struct
id|atom_value
op_star
id|val
comma
r_int
id|deref
comma
r_struct
id|object
op_star
id|obj
comma
r_void
op_star
id|buf
comma
r_int
r_int
id|sz
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|wholen
op_assign
id|strlen
c_func
(paren
id|who
)paren
suffix:semicolon
r_const
r_char
op_star
id|wholine
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|used_atom_cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_char
op_star
id|name
op_assign
id|used_atom
(braket
id|i
)braket
suffix:semicolon
r_struct
id|atom_value
op_star
id|v
op_assign
op_amp
id|val
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_logical_neg
id|deref
op_ne
(paren
op_star
id|name
op_eq
l_char|&squot;*&squot;
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|deref
)paren
id|name
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|who
comma
id|name
comma
id|wholen
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|name
(braket
id|wholen
)braket
op_ne
l_int|0
op_logical_and
id|strcmp
c_func
(paren
id|name
op_plus
id|wholen
comma
l_string|&quot;name&quot;
)paren
op_logical_and
id|strcmp
c_func
(paren
id|name
op_plus
id|wholen
comma
l_string|&quot;email&quot;
)paren
op_logical_and
id|prefixcmp
c_func
(paren
id|name
op_plus
id|wholen
comma
l_string|&quot;date&quot;
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wholine
)paren
id|wholine
op_assign
id|find_wholine
c_func
(paren
id|who
comma
id|wholen
comma
id|buf
comma
id|sz
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wholine
)paren
r_return
suffix:semicolon
multiline_comment|/* no point looking for it */
r_if
c_cond
(paren
id|name
(braket
id|wholen
)braket
op_eq
l_int|0
)paren
id|v-&gt;s
op_assign
id|copy_line
c_func
(paren
id|wholine
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
op_plus
id|wholen
comma
l_string|&quot;name&quot;
)paren
)paren
id|v-&gt;s
op_assign
id|copy_name
c_func
(paren
id|wholine
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
op_plus
id|wholen
comma
l_string|&quot;email&quot;
)paren
)paren
id|v-&gt;s
op_assign
id|copy_email
c_func
(paren
id|wholine
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|name
op_plus
id|wholen
comma
l_string|&quot;date&quot;
)paren
)paren
id|grab_date
c_func
(paren
id|wholine
comma
id|v
comma
id|name
)paren
suffix:semicolon
)brace
multiline_comment|/* For a tag or a commit object, if &quot;creator&quot; or &quot;creatordate&quot; is&n;&t; * requested, do something special.&n;&t; */
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|who
comma
l_string|&quot;tagger&quot;
)paren
op_logical_and
id|strcmp
c_func
(paren
id|who
comma
l_string|&quot;committer&quot;
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* &quot;author&quot; for commit object is not wanted */
r_if
c_cond
(paren
op_logical_neg
id|wholine
)paren
id|wholine
op_assign
id|find_wholine
c_func
(paren
id|who
comma
id|wholen
comma
id|buf
comma
id|sz
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wholine
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|used_atom_cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_char
op_star
id|name
op_assign
id|used_atom
(braket
id|i
)braket
suffix:semicolon
r_struct
id|atom_value
op_star
id|v
op_assign
op_amp
id|val
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_logical_neg
id|deref
op_ne
(paren
op_star
id|name
op_eq
l_char|&squot;*&squot;
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|deref
)paren
id|name
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|name
comma
l_string|&quot;creatordate&quot;
)paren
)paren
id|grab_date
c_func
(paren
id|wholine
comma
id|v
comma
id|name
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;creator&quot;
)paren
)paren
id|v-&gt;s
op_assign
id|copy_line
c_func
(paren
id|wholine
)paren
suffix:semicolon
)brace
)brace
DECL|function|find_subpos
r_static
r_void
id|find_subpos
c_func
(paren
r_const
r_char
op_star
id|buf
comma
r_int
r_int
id|sz
comma
r_const
r_char
op_star
op_star
id|sub
comma
r_const
r_char
op_star
op_star
id|body
)paren
(brace
r_while
c_loop
(paren
op_star
id|buf
)paren
(brace
r_const
r_char
op_star
id|eol
op_assign
id|strchr
c_func
(paren
id|buf
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|eol
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|eol
(braket
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|buf
op_assign
id|eol
op_plus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* found end of header */
)brace
id|buf
op_assign
id|eol
op_plus
l_int|1
suffix:semicolon
)brace
r_while
c_loop
(paren
op_star
id|buf
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|buf
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|buf
)paren
r_return
suffix:semicolon
op_star
id|sub
op_assign
id|buf
suffix:semicolon
multiline_comment|/* first non-empty line */
id|buf
op_assign
id|strchr
c_func
(paren
id|buf
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
(brace
op_star
id|body
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* no body */
)brace
r_while
c_loop
(paren
op_star
id|buf
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|buf
op_increment
suffix:semicolon
multiline_comment|/* skip blank between subject and body */
op_star
id|body
op_assign
id|buf
suffix:semicolon
)brace
multiline_comment|/* See grab_values */
DECL|function|grab_sub_body_contents
r_static
r_void
id|grab_sub_body_contents
c_func
(paren
r_struct
id|atom_value
op_star
id|val
comma
r_int
id|deref
comma
r_struct
id|object
op_star
id|obj
comma
r_void
op_star
id|buf
comma
r_int
r_int
id|sz
)paren
(brace
r_int
id|i
suffix:semicolon
r_const
r_char
op_star
id|subpos
op_assign
l_int|NULL
comma
op_star
id|bodypos
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|used_atom_cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_char
op_star
id|name
op_assign
id|used_atom
(braket
id|i
)braket
suffix:semicolon
r_struct
id|atom_value
op_star
id|v
op_assign
op_amp
id|val
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_logical_neg
id|deref
op_ne
(paren
op_star
id|name
op_eq
l_char|&squot;*&squot;
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|deref
)paren
id|name
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;subject&quot;
)paren
op_logical_and
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;body&quot;
)paren
op_logical_and
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;contents&quot;
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|subpos
)paren
id|find_subpos
c_func
(paren
id|buf
comma
id|sz
comma
op_amp
id|subpos
comma
op_amp
id|bodypos
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|subpos
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;subject&quot;
)paren
)paren
id|v-&gt;s
op_assign
id|copy_line
c_func
(paren
id|subpos
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;body&quot;
)paren
)paren
id|v-&gt;s
op_assign
id|xstrdup
c_func
(paren
id|bodypos
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;contents&quot;
)paren
)paren
id|v-&gt;s
op_assign
id|xstrdup
c_func
(paren
id|subpos
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* We want to have empty print-string for field requests&n; * that do not apply (e.g. &quot;authordate&quot; for a tag object)&n; */
DECL|function|fill_missing_values
r_static
r_void
id|fill_missing_values
c_func
(paren
r_struct
id|atom_value
op_star
id|val
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|used_atom_cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|atom_value
op_star
id|v
op_assign
op_amp
id|val
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|v-&gt;s
op_eq
l_int|NULL
)paren
id|v-&gt;s
op_assign
l_string|&quot;&quot;
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * val is a list of atom_value to hold returned values.  Extract&n; * the values for atoms in used_atom array out of (obj, buf, sz).&n; * when deref is false, (obj, buf, sz) is the object that is&n; * pointed at by the ref itself; otherwise it is the object the&n; * ref (which is a tag) refers to.&n; */
DECL|function|grab_values
r_static
r_void
id|grab_values
c_func
(paren
r_struct
id|atom_value
op_star
id|val
comma
r_int
id|deref
comma
r_struct
id|object
op_star
id|obj
comma
r_void
op_star
id|buf
comma
r_int
r_int
id|sz
)paren
(brace
id|grab_common_values
c_func
(paren
id|val
comma
id|deref
comma
id|obj
comma
id|buf
comma
id|sz
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|obj-&gt;type
)paren
(brace
r_case
id|OBJ_TAG
suffix:colon
id|grab_tag_values
c_func
(paren
id|val
comma
id|deref
comma
id|obj
comma
id|buf
comma
id|sz
)paren
suffix:semicolon
id|grab_sub_body_contents
c_func
(paren
id|val
comma
id|deref
comma
id|obj
comma
id|buf
comma
id|sz
)paren
suffix:semicolon
id|grab_person
c_func
(paren
l_string|&quot;tagger&quot;
comma
id|val
comma
id|deref
comma
id|obj
comma
id|buf
comma
id|sz
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OBJ_COMMIT
suffix:colon
id|grab_commit_values
c_func
(paren
id|val
comma
id|deref
comma
id|obj
comma
id|buf
comma
id|sz
)paren
suffix:semicolon
id|grab_sub_body_contents
c_func
(paren
id|val
comma
id|deref
comma
id|obj
comma
id|buf
comma
id|sz
)paren
suffix:semicolon
id|grab_person
c_func
(paren
l_string|&quot;author&quot;
comma
id|val
comma
id|deref
comma
id|obj
comma
id|buf
comma
id|sz
)paren
suffix:semicolon
id|grab_person
c_func
(paren
l_string|&quot;committer&quot;
comma
id|val
comma
id|deref
comma
id|obj
comma
id|buf
comma
id|sz
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OBJ_TREE
suffix:colon
singleline_comment|// grab_tree_values(val, deref, obj, buf, sz);
r_break
suffix:semicolon
r_case
id|OBJ_BLOB
suffix:colon
singleline_comment|// grab_blob_values(val, deref, obj, buf, sz);
r_break
suffix:semicolon
r_default
suffix:colon
id|die
c_func
(paren
l_string|&quot;Eh?  Object of type %d?&quot;
comma
id|obj-&gt;type
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * generate a format suitable for scanf from a ref_rev_parse_rules&n; * rule, that is replace the &quot;%.*s&quot; spec with a &quot;%s&quot; spec&n; */
DECL|function|gen_scanf_fmt
r_static
r_void
id|gen_scanf_fmt
c_func
(paren
r_char
op_star
id|scanf_fmt
comma
r_const
r_char
op_star
id|rule
)paren
(brace
r_char
op_star
id|spec
suffix:semicolon
id|spec
op_assign
id|strstr
c_func
(paren
id|rule
comma
l_string|&quot;%.*s&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|spec
op_logical_or
id|strstr
c_func
(paren
id|spec
op_plus
l_int|4
comma
l_string|&quot;%.*s&quot;
)paren
)paren
id|die
c_func
(paren
l_string|&quot;invalid rule in ref_rev_parse_rules: %s&quot;
comma
id|rule
)paren
suffix:semicolon
multiline_comment|/* copy all until spec */
id|strncpy
c_func
(paren
id|scanf_fmt
comma
id|rule
comma
id|spec
id|rule
)paren
suffix:semicolon
id|scanf_fmt
(braket
id|spec
id|rule
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
multiline_comment|/* copy new spec */
id|strcat
c_func
(paren
id|scanf_fmt
comma
l_string|&quot;%s&quot;
)paren
suffix:semicolon
multiline_comment|/* copy remaining rule */
id|strcat
c_func
(paren
id|scanf_fmt
comma
id|spec
op_plus
l_int|4
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Shorten the refname to an non-ambiguous form&n; */
DECL|function|get_short_ref
r_static
r_char
op_star
id|get_short_ref
c_func
(paren
r_struct
id|refinfo
op_star
id|ref
)paren
(brace
r_int
id|i
suffix:semicolon
r_static
r_char
op_star
op_star
id|scanf_fmts
suffix:semicolon
r_static
r_int
id|nr_rules
suffix:semicolon
r_char
op_star
id|short_name
suffix:semicolon
multiline_comment|/* pre generate scanf formats from ref_rev_parse_rules[] */
r_if
c_cond
(paren
op_logical_neg
id|nr_rules
)paren
(brace
r_int
id|total_len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* the rule list is NULL terminated, count them first */
r_for
c_loop
(paren
suffix:semicolon
id|ref_rev_parse_rules
(braket
id|nr_rules
)braket
suffix:semicolon
id|nr_rules
op_increment
)paren
multiline_comment|/* no +1 because strlen(&quot;%s&quot;) &lt; strlen(&quot;%.*s&quot;) */
id|total_len
op_add_assign
id|strlen
c_func
(paren
id|ref_rev_parse_rules
(braket
id|nr_rules
)braket
)paren
suffix:semicolon
id|scanf_fmts
op_assign
id|xmalloc
c_func
(paren
id|nr_rules
op_star
r_sizeof
(paren
r_char
op_star
)paren
op_plus
id|total_len
)paren
suffix:semicolon
id|total_len
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_rules
suffix:semicolon
id|i
op_increment
)paren
(brace
id|scanf_fmts
(braket
id|i
)braket
op_assign
(paren
r_char
op_star
)paren
op_amp
id|scanf_fmts
(braket
id|nr_rules
)braket
op_plus
id|total_len
suffix:semicolon
id|gen_scanf_fmt
c_func
(paren
id|scanf_fmts
(braket
id|i
)braket
comma
id|ref_rev_parse_rules
(braket
id|i
)braket
)paren
suffix:semicolon
id|total_len
op_add_assign
id|strlen
c_func
(paren
id|ref_rev_parse_rules
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* bail out if there are no rules */
r_if
c_cond
(paren
op_logical_neg
id|nr_rules
)paren
r_return
id|ref-&gt;refname
suffix:semicolon
multiline_comment|/* buffer for scanf result, at most ref-&gt;refname must fit */
id|short_name
op_assign
id|xstrdup
c_func
(paren
id|ref-&gt;refname
)paren
suffix:semicolon
multiline_comment|/* skip first rule, it will always match */
r_for
c_loop
(paren
id|i
op_assign
id|nr_rules
l_int|1
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
op_decrement
id|i
)paren
(brace
r_int
id|j
suffix:semicolon
r_int
id|short_name_len
suffix:semicolon
r_if
c_cond
(paren
l_int|1
op_ne
id|sscanf
c_func
(paren
id|ref-&gt;refname
comma
id|scanf_fmts
(braket
id|i
)braket
comma
id|short_name
)paren
)paren
r_continue
suffix:semicolon
id|short_name_len
op_assign
id|strlen
c_func
(paren
id|short_name
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * check if the short name resolves to a valid ref,&n;&t;&t; * but use only rules prior to the matched one&n;&t;&t; */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|i
suffix:semicolon
id|j
op_increment
)paren
(brace
r_const
r_char
op_star
id|rule
op_assign
id|ref_rev_parse_rules
(braket
id|j
)braket
suffix:semicolon
r_int
r_char
id|short_objectname
(braket
l_int|20
)braket
suffix:semicolon
r_char
id|refname
(braket
id|PATH_MAX
)braket
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * the short name is ambiguous, if it resolves&n;&t;&t;&t; * (with this previous rule) to a valid ref&n;&t;&t;&t; * read_ref() returns 0 on success&n;&t;&t;&t; */
id|mksnpath
c_func
(paren
id|refname
comma
r_sizeof
(paren
id|refname
)paren
comma
id|rule
comma
id|short_name_len
comma
id|short_name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|read_ref
c_func
(paren
id|refname
comma
id|short_objectname
)paren
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * short name is non-ambiguous if all previous rules&n;&t;&t; * haven&squot;t resolved to a valid ref&n;&t;&t; */
r_if
c_cond
(paren
id|j
op_eq
id|i
)paren
r_return
id|short_name
suffix:semicolon
)brace
id|free
c_func
(paren
id|short_name
)paren
suffix:semicolon
r_return
id|ref-&gt;refname
suffix:semicolon
)brace
multiline_comment|/*&n; * Parse the object referred by ref, and grab needed value.&n; */
DECL|function|populate_value
r_static
r_void
id|populate_value
c_func
(paren
r_struct
id|refinfo
op_star
id|ref
)paren
(brace
r_void
op_star
id|buf
suffix:semicolon
r_struct
id|object
op_star
id|obj
suffix:semicolon
r_int
id|eaten
comma
id|i
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_const
r_int
r_char
op_star
id|tagged
suffix:semicolon
id|ref-&gt;value
op_assign
id|xcalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|atom_value
)paren
comma
id|used_atom_cnt
)paren
suffix:semicolon
id|buf
op_assign
id|get_obj
c_func
(paren
id|ref-&gt;objectname
comma
op_amp
id|obj
comma
op_amp
id|size
comma
op_amp
id|eaten
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
id|die
c_func
(paren
l_string|&quot;missing object %s for %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|ref-&gt;objectname
)paren
comma
id|ref-&gt;refname
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|obj
)paren
id|die
c_func
(paren
l_string|&quot;parse_object_buffer failed on %s for %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|ref-&gt;objectname
)paren
comma
id|ref-&gt;refname
)paren
suffix:semicolon
multiline_comment|/* Fill in specials first */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|used_atom_cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_char
op_star
id|name
op_assign
id|used_atom
(braket
id|i
)braket
suffix:semicolon
r_struct
id|atom_value
op_star
id|v
op_assign
op_amp
id|ref-&gt;value
(braket
id|i
)braket
suffix:semicolon
r_int
id|deref
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_star
id|name
op_eq
l_char|&squot;*&squot;
)paren
(brace
id|deref
op_assign
l_int|1
suffix:semicolon
id|name
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|name
comma
l_string|&quot;refname&quot;
)paren
)paren
(brace
r_const
r_char
op_star
id|formatp
op_assign
id|strchr
c_func
(paren
id|name
comma
l_char|&squot;:&squot;
)paren
suffix:semicolon
r_const
r_char
op_star
id|refname
op_assign
id|ref-&gt;refname
suffix:semicolon
multiline_comment|/* look for &quot;short&quot; refname format */
r_if
c_cond
(paren
id|formatp
)paren
(brace
id|formatp
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|formatp
comma
l_string|&quot;short&quot;
)paren
)paren
id|refname
op_assign
id|get_short_ref
c_func
(paren
id|ref
)paren
suffix:semicolon
r_else
id|die
c_func
(paren
l_string|&quot;unknown refname format %s&quot;
comma
id|formatp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|deref
)paren
id|v-&gt;s
op_assign
id|refname
suffix:semicolon
r_else
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|refname
)paren
suffix:semicolon
r_char
op_star
id|s
op_assign
id|xmalloc
c_func
(paren
id|len
op_plus
l_int|4
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|s
comma
l_string|&quot;%s^{}&quot;
comma
id|refname
)paren
suffix:semicolon
id|v-&gt;s
op_assign
id|s
suffix:semicolon
)brace
)brace
)brace
id|grab_values
c_func
(paren
id|ref-&gt;value
comma
l_int|0
comma
id|obj
comma
id|buf
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|eaten
)paren
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
multiline_comment|/* If there is no atom that wants to know about tagged&n;&t; * object, we are done.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|need_tagged
op_logical_or
(paren
id|obj-&gt;type
op_ne
id|OBJ_TAG
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* If it is a tag object, see if we use a value that derefs&n;&t; * the object, and if we do grab the object it refers to.&n;&t; */
id|tagged
op_assign
(paren
(paren
r_struct
id|tag
op_star
)paren
id|obj
)paren
op_member_access_from_pointer
id|tagged-&gt;sha1
suffix:semicolon
multiline_comment|/* NEEDSWORK: This derefs tag only once, which&n;&t; * is good to deal with chains of trust, but&n;&t; * is not consistent with what deref_tag() does&n;&t; * which peels the onion to the core.&n;&t; */
id|buf
op_assign
id|get_obj
c_func
(paren
id|tagged
comma
op_amp
id|obj
comma
op_amp
id|size
comma
op_amp
id|eaten
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
id|die
c_func
(paren
l_string|&quot;missing object %s for %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|tagged
)paren
comma
id|ref-&gt;refname
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|obj
)paren
id|die
c_func
(paren
l_string|&quot;parse_object_buffer failed on %s for %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|tagged
)paren
comma
id|ref-&gt;refname
)paren
suffix:semicolon
id|grab_values
c_func
(paren
id|ref-&gt;value
comma
l_int|1
comma
id|obj
comma
id|buf
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|eaten
)paren
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Given a ref, return the value for the atom.  This lazily gets value&n; * out of the object by calling populate value.&n; */
DECL|function|get_value
r_static
r_void
id|get_value
c_func
(paren
r_struct
id|refinfo
op_star
id|ref
comma
r_int
id|atom
comma
r_struct
id|atom_value
op_star
op_star
id|v
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ref-&gt;value
)paren
(brace
id|populate_value
c_func
(paren
id|ref
)paren
suffix:semicolon
id|fill_missing_values
c_func
(paren
id|ref-&gt;value
)paren
suffix:semicolon
)brace
op_star
id|v
op_assign
op_amp
id|ref-&gt;value
(braket
id|atom
)braket
suffix:semicolon
)brace
DECL|struct|grab_ref_cbdata
r_struct
id|grab_ref_cbdata
(brace
DECL|member|grab_array
r_struct
id|refinfo
op_star
op_star
id|grab_array
suffix:semicolon
DECL|member|grab_pattern
r_const
r_char
op_star
op_star
id|grab_pattern
suffix:semicolon
DECL|member|grab_cnt
r_int
id|grab_cnt
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * A call-back given to for_each_ref().  It is unfortunate that we&n; * need to use global variables to pass extra information to this&n; * function.&n; */
DECL|function|grab_single_ref
r_static
r_int
id|grab_single_ref
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
id|flag
comma
r_void
op_star
id|cb_data
)paren
(brace
r_struct
id|grab_ref_cbdata
op_star
id|cb
op_assign
id|cb_data
suffix:semicolon
r_struct
id|refinfo
op_star
id|ref
suffix:semicolon
r_int
id|cnt
suffix:semicolon
r_if
c_cond
(paren
op_star
id|cb-&gt;grab_pattern
)paren
(brace
r_const
r_char
op_star
op_star
id|pattern
suffix:semicolon
r_int
id|namelen
op_assign
id|strlen
c_func
(paren
id|refname
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pattern
op_assign
id|cb-&gt;grab_pattern
suffix:semicolon
op_star
id|pattern
suffix:semicolon
id|pattern
op_increment
)paren
(brace
r_const
r_char
op_star
id|p
op_assign
op_star
id|pattern
suffix:semicolon
r_int
id|plen
op_assign
id|strlen
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|plen
op_le
id|namelen
)paren
op_logical_and
op_logical_neg
id|strncmp
c_func
(paren
id|refname
comma
id|p
comma
id|plen
)paren
op_logical_and
(paren
id|refname
(braket
id|plen
)braket
op_eq
l_char|&squot;&bslash;0&squot;
op_logical_or
id|refname
(braket
id|plen
)braket
op_eq
l_char|&squot;/&squot;
op_logical_or
id|p
(braket
id|plen
op_minus
l_int|1
)braket
op_eq
l_char|&squot;/&squot;
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fnmatch
c_func
(paren
id|p
comma
id|refname
comma
id|FNM_PATHNAME
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|pattern
)paren
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* We do not open the object yet; sort may only need refname&n;&t; * to do its job and the resulting list may yet to be pruned&n;&t; * by maxcount logic.&n;&t; */
id|ref
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|ref
)paren
)paren
suffix:semicolon
id|ref-&gt;refname
op_assign
id|xstrdup
c_func
(paren
id|refname
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|ref-&gt;objectname
comma
id|sha1
)paren
suffix:semicolon
id|cnt
op_assign
id|cb-&gt;grab_cnt
suffix:semicolon
id|cb-&gt;grab_array
op_assign
id|xrealloc
c_func
(paren
id|cb-&gt;grab_array
comma
r_sizeof
(paren
op_star
id|cb-&gt;grab_array
)paren
op_star
(paren
id|cnt
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|cb-&gt;grab_array
(braket
id|cnt
op_increment
)braket
op_assign
id|ref
suffix:semicolon
id|cb-&gt;grab_cnt
op_assign
id|cnt
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cmp_ref_sort
r_static
r_int
id|cmp_ref_sort
c_func
(paren
r_struct
id|ref_sort
op_star
id|s
comma
r_struct
id|refinfo
op_star
id|a
comma
r_struct
id|refinfo
op_star
id|b
)paren
(brace
r_struct
id|atom_value
op_star
id|va
comma
op_star
id|vb
suffix:semicolon
r_int
id|cmp
suffix:semicolon
id|cmp_type
id|cmp_type
op_assign
id|used_atom_type
(braket
id|s-&gt;atom
)braket
suffix:semicolon
id|get_value
c_func
(paren
id|a
comma
id|s-&gt;atom
comma
op_amp
id|va
)paren
suffix:semicolon
id|get_value
c_func
(paren
id|b
comma
id|s-&gt;atom
comma
op_amp
id|vb
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmp_type
)paren
(brace
r_case
id|FIELD_STR
suffix:colon
id|cmp
op_assign
id|strcmp
c_func
(paren
id|va-&gt;s
comma
id|vb-&gt;s
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|va-&gt;ul
OL
id|vb-&gt;ul
)paren
id|cmp
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|va-&gt;ul
op_eq
id|vb-&gt;ul
)paren
id|cmp
op_assign
l_int|0
suffix:semicolon
r_else
id|cmp
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
(paren
id|s-&gt;reverse
)paren
ques
c_cond
id|cmp
suffix:colon
id|cmp
suffix:semicolon
)brace
DECL|variable|ref_sort
r_static
r_struct
id|ref_sort
op_star
id|ref_sort
suffix:semicolon
DECL|function|compare_refs
r_static
r_int
id|compare_refs
c_func
(paren
r_const
r_void
op_star
id|a_
comma
r_const
r_void
op_star
id|b_
)paren
(brace
r_struct
id|refinfo
op_star
id|a
op_assign
op_star
(paren
(paren
r_struct
id|refinfo
op_star
op_star
)paren
id|a_
)paren
suffix:semicolon
r_struct
id|refinfo
op_star
id|b
op_assign
op_star
(paren
(paren
r_struct
id|refinfo
op_star
op_star
)paren
id|b_
)paren
suffix:semicolon
r_struct
id|ref_sort
op_star
id|s
suffix:semicolon
r_for
c_loop
(paren
id|s
op_assign
id|ref_sort
suffix:semicolon
id|s
suffix:semicolon
id|s
op_assign
id|s-&gt;next
)paren
(brace
r_int
id|cmp
op_assign
id|cmp_ref_sort
c_func
(paren
id|s
comma
id|a
comma
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmp
)paren
r_return
id|cmp
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sort_refs
r_static
r_void
id|sort_refs
c_func
(paren
r_struct
id|ref_sort
op_star
id|sort
comma
r_struct
id|refinfo
op_star
op_star
id|refs
comma
r_int
id|num_refs
)paren
(brace
id|ref_sort
op_assign
id|sort
suffix:semicolon
id|qsort
c_func
(paren
id|refs
comma
id|num_refs
comma
r_sizeof
(paren
r_struct
id|refinfo
op_star
)paren
comma
id|compare_refs
)paren
suffix:semicolon
)brace
DECL|function|print_value
r_static
r_void
id|print_value
c_func
(paren
r_struct
id|refinfo
op_star
id|ref
comma
r_int
id|atom
comma
r_int
id|quote_style
)paren
(brace
r_struct
id|atom_value
op_star
id|v
suffix:semicolon
id|get_value
c_func
(paren
id|ref
comma
id|atom
comma
op_amp
id|v
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|quote_style
)paren
(brace
r_case
id|QUOTE_NONE
suffix:colon
id|fputs
c_func
(paren
id|v-&gt;s
comma
id|stdout
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QUOTE_SHELL
suffix:colon
id|sq_quote_print
c_func
(paren
id|stdout
comma
id|v-&gt;s
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QUOTE_PERL
suffix:colon
id|perl_quote_print
c_func
(paren
id|stdout
comma
id|v-&gt;s
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QUOTE_PYTHON
suffix:colon
id|python_quote_print
c_func
(paren
id|stdout
comma
id|v-&gt;s
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QUOTE_TCL
suffix:colon
id|tcl_quote_print
c_func
(paren
id|stdout
comma
id|v-&gt;s
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|function|hex1
r_static
r_int
id|hex1
c_func
(paren
r_char
id|ch
)paren
(brace
r_if
c_cond
(paren
l_char|&squot;0&squot;
op_le
id|ch
op_logical_and
id|ch
op_le
l_char|&squot;9&squot;
)paren
r_return
id|ch
l_char|&squot;0&squot;
suffix:semicolon
r_else
r_if
c_cond
(paren
l_char|&squot;a&squot;
op_le
id|ch
op_logical_and
id|ch
op_le
l_char|&squot;f&squot;
)paren
r_return
id|ch
l_char|&squot;a&squot;
op_plus
l_int|10
suffix:semicolon
r_else
r_if
c_cond
(paren
l_char|&squot;A&squot;
op_le
id|ch
op_logical_and
id|ch
op_le
l_char|&squot;F&squot;
)paren
r_return
id|ch
l_char|&squot;A&squot;
op_plus
l_int|10
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|hex2
r_static
r_int
id|hex2
c_func
(paren
r_const
r_char
op_star
id|cp
)paren
(brace
r_if
c_cond
(paren
id|cp
(braket
l_int|0
)braket
op_logical_and
id|cp
(braket
l_int|1
)braket
)paren
r_return
(paren
id|hex1
c_func
(paren
id|cp
(braket
l_int|0
)braket
)paren
op_lshift
l_int|4
)paren
op_or
id|hex1
c_func
(paren
id|cp
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_else
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|emit
r_static
r_void
id|emit
c_func
(paren
r_const
r_char
op_star
id|cp
comma
r_const
r_char
op_star
id|ep
)paren
(brace
r_while
c_loop
(paren
op_star
id|cp
op_logical_and
(paren
op_logical_neg
id|ep
op_logical_or
id|cp
OL
id|ep
)paren
)paren
(brace
r_if
c_cond
(paren
op_star
id|cp
op_eq
l_char|&squot;%&squot;
)paren
(brace
r_if
c_cond
(paren
id|cp
(braket
l_int|1
)braket
op_eq
l_char|&squot;%&squot;
)paren
id|cp
op_increment
suffix:semicolon
r_else
(brace
r_int
id|ch
op_assign
id|hex2
c_func
(paren
id|cp
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_le
id|ch
)paren
(brace
id|putchar
c_func
(paren
id|ch
)paren
suffix:semicolon
id|cp
op_add_assign
l_int|3
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
)brace
id|putchar
c_func
(paren
op_star
id|cp
)paren
suffix:semicolon
id|cp
op_increment
suffix:semicolon
)brace
)brace
DECL|function|show_ref
r_static
r_void
id|show_ref
c_func
(paren
r_struct
id|refinfo
op_star
id|info
comma
r_const
r_char
op_star
id|format
comma
r_int
id|quote_style
)paren
(brace
r_const
r_char
op_star
id|cp
comma
op_star
id|sp
comma
op_star
id|ep
suffix:semicolon
r_for
c_loop
(paren
id|cp
op_assign
id|format
suffix:semicolon
op_star
id|cp
op_logical_and
(paren
id|sp
op_assign
id|find_next
c_func
(paren
id|cp
)paren
)paren
suffix:semicolon
id|cp
op_assign
id|ep
op_plus
l_int|1
)paren
(brace
id|ep
op_assign
id|strchr
c_func
(paren
id|sp
comma
l_char|&squot;)&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp
OL
id|sp
)paren
id|emit
c_func
(paren
id|cp
comma
id|sp
)paren
suffix:semicolon
id|print_value
c_func
(paren
id|info
comma
id|parse_atom
c_func
(paren
id|sp
op_plus
l_int|2
comma
id|ep
)paren
comma
id|quote_style
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|cp
)paren
(brace
id|sp
op_assign
id|cp
op_plus
id|strlen
c_func
(paren
id|cp
)paren
suffix:semicolon
id|emit
c_func
(paren
id|cp
comma
id|sp
)paren
suffix:semicolon
)brace
id|putchar
c_func
(paren
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
DECL|function|default_sort
r_static
r_struct
id|ref_sort
op_star
id|default_sort
c_func
(paren
r_void
)paren
(brace
r_static
r_const
r_char
id|cstr_name
(braket
)braket
op_assign
l_string|&quot;refname&quot;
suffix:semicolon
r_struct
id|ref_sort
op_star
id|sort
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|sort
)paren
)paren
suffix:semicolon
id|sort-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|sort-&gt;atom
op_assign
id|parse_atom
c_func
(paren
id|cstr_name
comma
id|cstr_name
op_plus
id|strlen
c_func
(paren
id|cstr_name
)paren
)paren
suffix:semicolon
r_return
id|sort
suffix:semicolon
)brace
DECL|function|opt_parse_sort
r_static
r_int
id|opt_parse_sort
c_func
(paren
r_const
r_struct
id|option
op_star
id|opt
comma
r_const
r_char
op_star
id|arg
comma
r_int
id|unset
)paren
(brace
r_struct
id|ref_sort
op_star
op_star
id|sort_tail
op_assign
id|opt-&gt;value
suffix:semicolon
r_struct
id|ref_sort
op_star
id|s
suffix:semicolon
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
multiline_comment|/* should --no-sort void the list ? */
r_return
l_int|1
suffix:semicolon
op_star
id|sort_tail
op_assign
id|s
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|s
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|arg
op_eq
l_char|&squot;-&squot;
)paren
(brace
id|s-&gt;reverse
op_assign
l_int|1
suffix:semicolon
id|arg
op_increment
suffix:semicolon
)brace
id|len
op_assign
id|strlen
c_func
(paren
id|arg
)paren
suffix:semicolon
id|s-&gt;atom
op_assign
id|parse_atom
c_func
(paren
id|arg
comma
id|arg
op_plus
id|len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|for_each_ref_usage
r_static
r_char
r_const
op_star
r_const
id|for_each_ref_usage
(braket
)braket
op_assign
(brace
l_string|&quot;git for-each-ref [options] [&lt;pattern&gt;]&quot;
comma
l_int|NULL
)brace
suffix:semicolon
DECL|function|cmd_for_each_ref
r_int
id|cmd_for_each_ref
c_func
(paren
r_int
id|argc
comma
r_const
r_char
op_star
op_star
id|argv
comma
r_const
r_char
op_star
id|prefix
)paren
(brace
r_int
id|i
comma
id|num_refs
suffix:semicolon
r_const
r_char
op_star
id|format
op_assign
l_string|&quot;%(objectname) %(objecttype)&bslash;t%(refname)&quot;
suffix:semicolon
r_struct
id|ref_sort
op_star
id|sort
op_assign
l_int|NULL
comma
op_star
op_star
id|sort_tail
op_assign
op_amp
id|sort
suffix:semicolon
r_int
id|maxcount
op_assign
l_int|0
comma
id|quote_style
op_assign
l_int|0
suffix:semicolon
r_struct
id|refinfo
op_star
op_star
id|refs
suffix:semicolon
r_struct
id|grab_ref_cbdata
id|cbdata
suffix:semicolon
r_struct
id|option
id|opts
(braket
)braket
op_assign
(brace
id|OPT_BIT
c_func
(paren
l_char|&squot;s&squot;
comma
l_string|&quot;shell&quot;
comma
op_amp
id|quote_style
comma
l_string|&quot;quote placeholders suitably for shells&quot;
comma
id|QUOTE_SHELL
)paren
comma
id|OPT_BIT
c_func
(paren
l_char|&squot;p&squot;
comma
l_string|&quot;perl&quot;
comma
op_amp
id|quote_style
comma
l_string|&quot;quote placeholders suitably for perl&quot;
comma
id|QUOTE_PERL
)paren
comma
id|OPT_BIT
c_func
(paren
l_int|0
comma
l_string|&quot;python&quot;
comma
op_amp
id|quote_style
comma
l_string|&quot;quote placeholders suitably for python&quot;
comma
id|QUOTE_PYTHON
)paren
comma
id|OPT_BIT
c_func
(paren
l_int|0
comma
l_string|&quot;tcl&quot;
comma
op_amp
id|quote_style
comma
l_string|&quot;quote placeholders suitably for tcl&quot;
comma
id|QUOTE_TCL
)paren
comma
id|OPT_GROUP
c_func
(paren
l_string|&quot;&quot;
)paren
comma
id|OPT_INTEGER
c_func
(paren
l_int|0
comma
l_string|&quot;count&quot;
comma
op_amp
id|maxcount
comma
l_string|&quot;show only &lt;n&gt; matched refs&quot;
)paren
comma
id|OPT_STRING
c_func
(paren
l_int|0
comma
l_string|&quot;format&quot;
comma
op_amp
id|format
comma
l_string|&quot;format&quot;
comma
l_string|&quot;format to use for the output&quot;
)paren
comma
id|OPT_CALLBACK
c_func
(paren
l_int|0
comma
l_string|&quot;sort&quot;
comma
id|sort_tail
comma
l_string|&quot;key&quot;
comma
l_string|&quot;field name to sort on&quot;
comma
op_amp
id|opt_parse_sort
)paren
comma
id|OPT_END
c_func
(paren
)paren
comma
)brace
suffix:semicolon
id|parse_options
c_func
(paren
id|argc
comma
id|argv
comma
id|opts
comma
id|for_each_ref_usage
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|maxcount
OL
l_int|0
)paren
(brace
id|error
c_func
(paren
l_string|&quot;invalid --count argument: `%d&squot;&quot;
comma
id|maxcount
)paren
suffix:semicolon
id|usage_with_options
c_func
(paren
id|for_each_ref_usage
comma
id|opts
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|HAS_MULTI_BITS
c_func
(paren
id|quote_style
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;more than one quoting style?&quot;
)paren
suffix:semicolon
id|usage_with_options
c_func
(paren
id|for_each_ref_usage
comma
id|opts
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|verify_format
c_func
(paren
id|format
)paren
)paren
id|usage_with_options
c_func
(paren
id|for_each_ref_usage
comma
id|opts
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sort
)paren
id|sort
op_assign
id|default_sort
c_func
(paren
)paren
suffix:semicolon
id|sort_atom_limit
op_assign
id|used_atom_cnt
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|cbdata
comma
l_int|0
comma
r_sizeof
(paren
id|cbdata
)paren
)paren
suffix:semicolon
id|cbdata.grab_pattern
op_assign
id|argv
suffix:semicolon
id|for_each_ref
c_func
(paren
id|grab_single_ref
comma
op_amp
id|cbdata
)paren
suffix:semicolon
id|refs
op_assign
id|cbdata.grab_array
suffix:semicolon
id|num_refs
op_assign
id|cbdata.grab_cnt
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|used_atom_cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|used_atom
(braket
id|i
)braket
(braket
l_int|0
)braket
op_eq
l_char|&squot;*&squot;
)paren
(brace
id|need_tagged
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|sort_refs
c_func
(paren
id|sort
comma
id|refs
comma
id|num_refs
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|maxcount
op_logical_or
id|num_refs
OL
id|maxcount
)paren
id|maxcount
op_assign
id|num_refs
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|maxcount
suffix:semicolon
id|i
op_increment
)paren
id|show_ref
c_func
(paren
id|refs
(braket
id|i
)braket
comma
id|format
comma
id|quote_style
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
