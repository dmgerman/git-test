macro_line|#include &quot;cache.h&quot;
DECL|macro|DEBUG_85
macro_line|#undef DEBUG_85
macro_line|#ifdef DEBUG_85
DECL|macro|say
mdefine_line|#define say(a) fprintf(stderr, a)
DECL|macro|say1
mdefine_line|#define say1(a,b) fprintf(stderr, a, b)
DECL|macro|say2
mdefine_line|#define say2(a,b,c) fprintf(stderr, a, b, c)
macro_line|#else
DECL|macro|say
mdefine_line|#define say(a) do {} while(0)
DECL|macro|say1
mdefine_line|#define say1(a,b) do {} while(0)
DECL|macro|say2
mdefine_line|#define say2(a,b,c) do {} while(0)
macro_line|#endif
DECL|variable|en85
r_static
r_const
r_char
id|en85
(braket
)braket
op_assign
(brace
l_char|&squot;0&squot;
comma
l_char|&squot;1&squot;
comma
l_char|&squot;2&squot;
comma
l_char|&squot;3&squot;
comma
l_char|&squot;4&squot;
comma
l_char|&squot;5&squot;
comma
l_char|&squot;6&squot;
comma
l_char|&squot;7&squot;
comma
l_char|&squot;8&squot;
comma
l_char|&squot;9&squot;
comma
l_char|&squot;A&squot;
comma
l_char|&squot;B&squot;
comma
l_char|&squot;C&squot;
comma
l_char|&squot;D&squot;
comma
l_char|&squot;E&squot;
comma
l_char|&squot;F&squot;
comma
l_char|&squot;G&squot;
comma
l_char|&squot;H&squot;
comma
l_char|&squot;I&squot;
comma
l_char|&squot;J&squot;
comma
l_char|&squot;K&squot;
comma
l_char|&squot;L&squot;
comma
l_char|&squot;M&squot;
comma
l_char|&squot;N&squot;
comma
l_char|&squot;O&squot;
comma
l_char|&squot;P&squot;
comma
l_char|&squot;Q&squot;
comma
l_char|&squot;R&squot;
comma
l_char|&squot;S&squot;
comma
l_char|&squot;T&squot;
comma
l_char|&squot;U&squot;
comma
l_char|&squot;V&squot;
comma
l_char|&squot;W&squot;
comma
l_char|&squot;X&squot;
comma
l_char|&squot;Y&squot;
comma
l_char|&squot;Z&squot;
comma
l_char|&squot;a&squot;
comma
l_char|&squot;b&squot;
comma
l_char|&squot;c&squot;
comma
l_char|&squot;d&squot;
comma
l_char|&squot;e&squot;
comma
l_char|&squot;f&squot;
comma
l_char|&squot;g&squot;
comma
l_char|&squot;h&squot;
comma
l_char|&squot;i&squot;
comma
l_char|&squot;j&squot;
comma
l_char|&squot;k&squot;
comma
l_char|&squot;l&squot;
comma
l_char|&squot;m&squot;
comma
l_char|&squot;n&squot;
comma
l_char|&squot;o&squot;
comma
l_char|&squot;p&squot;
comma
l_char|&squot;q&squot;
comma
l_char|&squot;r&squot;
comma
l_char|&squot;s&squot;
comma
l_char|&squot;t&squot;
comma
l_char|&squot;u&squot;
comma
l_char|&squot;v&squot;
comma
l_char|&squot;w&squot;
comma
l_char|&squot;x&squot;
comma
l_char|&squot;y&squot;
comma
l_char|&squot;z&squot;
comma
l_char|&squot;!&squot;
comma
l_char|&squot;#&squot;
comma
l_char|&squot;$&squot;
comma
l_char|&squot;%&squot;
comma
l_char|&squot;&amp;&squot;
comma
l_char|&squot;(&squot;
comma
l_char|&squot;)&squot;
comma
l_char|&squot;*&squot;
comma
l_char|&squot;+&squot;
comma
l_char|&squot;-&squot;
comma
l_char|&squot;;&squot;
comma
l_char|&squot;&lt;&squot;
comma
l_char|&squot;=&squot;
comma
l_char|&squot;&gt;&squot;
comma
l_char|&squot;?&squot;
comma
l_char|&squot;@&squot;
comma
l_char|&squot;^&squot;
comma
l_char|&squot;_&squot;
comma
l_char|&squot;`&squot;
comma
l_char|&squot;{&squot;
comma
l_char|&squot;|&squot;
comma
l_char|&squot;}&squot;
comma
l_char|&squot;~&squot;
)brace
suffix:semicolon
DECL|variable|de85
r_static
r_char
id|de85
(braket
l_int|256
)braket
suffix:semicolon
DECL|function|prep_base85
r_static
r_void
id|prep_base85
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|de85
(braket
l_char|&squot;Z&squot;
)braket
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|en85
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|ch
op_assign
id|en85
(braket
id|i
)braket
suffix:semicolon
id|de85
(braket
id|ch
)braket
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
)brace
)brace
DECL|function|decode_85
r_int
id|decode_85
c_func
(paren
r_char
op_star
id|dst
comma
r_const
r_char
op_star
id|buffer
comma
r_int
id|len
)paren
(brace
id|prep_base85
c_func
(paren
)paren
suffix:semicolon
id|say2
c_func
(paren
l_string|&quot;decode 85 &lt;%.*s&gt;&quot;
comma
id|len
op_div
l_int|4
op_star
l_int|5
comma
id|buffer
)paren
suffix:semicolon
r_while
c_loop
(paren
id|len
)paren
(brace
r_int
id|acc
op_assign
l_int|0
suffix:semicolon
r_int
id|de
comma
id|cnt
op_assign
l_int|4
suffix:semicolon
r_int
r_char
id|ch
suffix:semicolon
r_do
(brace
id|ch
op_assign
op_star
id|buffer
op_increment
suffix:semicolon
id|de
op_assign
id|de85
(braket
id|ch
)braket
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|de
OL
l_int|0
)paren
r_return
id|error
c_func
(paren
l_string|&quot;invalid base85 alphabet %c&quot;
comma
id|ch
)paren
suffix:semicolon
id|acc
op_assign
id|acc
op_star
l_int|85
op_plus
id|de
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|cnt
)paren
suffix:semicolon
id|ch
op_assign
op_star
id|buffer
op_increment
suffix:semicolon
id|de
op_assign
id|de85
(braket
id|ch
)braket
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|de
OL
l_int|0
)paren
r_return
id|error
c_func
(paren
l_string|&quot;invalid base85 alphabet %c&quot;
comma
id|ch
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Detect overflow.  The largest&n;&t;&t; * 5-letter possible is &quot;|NsC0&quot; to&n;&t;&t; * encode 0xffffffff, and &quot;|NsC&quot; gives&n;&t;&t; * 0x03030303 at this point (i.e.&n;&t;&t; * 0xffffffff = 0x03030303 * 85).&n;&t;&t; */
r_if
c_cond
(paren
l_int|0x03030303
OL
id|acc
op_logical_or
l_int|0xffffffff
id|de
OL
(paren
id|acc
op_mul_assign
l_int|85
)paren
)paren
r_return
id|error
c_func
(paren
l_string|&quot;invalid base85 sequence %.5s&quot;
comma
id|buffer
op_minus
l_int|5
)paren
suffix:semicolon
id|acc
op_add_assign
id|de
suffix:semicolon
id|say1
c_func
(paren
l_string|&quot; %08x&quot;
comma
id|acc
)paren
suffix:semicolon
id|cnt
op_assign
(paren
id|len
OL
l_int|4
)paren
ques
c_cond
id|len
suffix:colon
l_int|4
suffix:semicolon
id|len
op_sub_assign
id|cnt
suffix:semicolon
r_do
(brace
id|acc
op_assign
(paren
id|acc
op_lshift
l_int|8
)paren
op_or
(paren
id|acc
op_rshift
l_int|24
)paren
suffix:semicolon
op_star
id|dst
op_increment
op_assign
id|acc
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|cnt
)paren
suffix:semicolon
)brace
id|say
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|encode_85
r_void
id|encode_85
c_func
(paren
r_char
op_star
id|buf
comma
r_const
r_int
r_char
op_star
id|data
comma
r_int
id|bytes
)paren
(brace
id|prep_base85
c_func
(paren
)paren
suffix:semicolon
id|say
c_func
(paren
l_string|&quot;encode 85&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|bytes
)paren
(brace
r_int
id|acc
op_assign
l_int|0
suffix:semicolon
r_int
id|cnt
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|24
suffix:semicolon
id|cnt
op_ge
l_int|0
suffix:semicolon
id|cnt
op_sub_assign
l_int|8
)paren
(brace
r_int
id|ch
op_assign
op_star
id|data
op_increment
suffix:semicolon
id|acc
op_or_assign
id|ch
op_lshift
id|cnt
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|bytes
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
id|say1
c_func
(paren
l_string|&quot; %08x&quot;
comma
id|acc
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|4
suffix:semicolon
id|cnt
op_ge
l_int|0
suffix:semicolon
id|cnt
op_decrement
)paren
(brace
r_int
id|val
op_assign
id|acc
op_mod
l_int|85
suffix:semicolon
id|acc
op_div_assign
l_int|85
suffix:semicolon
id|buf
(braket
id|cnt
)braket
op_assign
id|en85
(braket
id|val
)braket
suffix:semicolon
)brace
id|buf
op_add_assign
l_int|5
suffix:semicolon
)brace
id|say
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
op_star
id|buf
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_85
DECL|function|main
r_int
id|main
c_func
(paren
r_int
id|ac
comma
r_char
op_star
op_star
id|av
)paren
(brace
r_char
id|buf
(braket
l_int|1024
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|av
(braket
l_int|1
)braket
comma
l_string|&quot;-e&quot;
)paren
)paren
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|av
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|encode_85
c_func
(paren
id|buf
comma
id|av
(braket
l_int|2
)braket
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
l_int|26
)paren
id|len
op_assign
id|len
op_plus
l_char|&squot;A&squot;
l_int|1
suffix:semicolon
r_else
id|len
op_assign
id|len
op_plus
l_char|&squot;a&squot;
l_int|26
l_int|1
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;encoded: %c%s&bslash;n&quot;
comma
id|len
comma
id|buf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|av
(braket
l_int|1
)braket
comma
l_string|&quot;-d&quot;
)paren
)paren
(brace
r_int
id|len
op_assign
op_star
id|av
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
l_char|&squot;A&squot;
op_le
id|len
op_logical_and
id|len
op_le
l_char|&squot;Z&squot;
)paren
id|len
op_assign
id|len
l_char|&squot;A&squot;
op_plus
l_int|1
suffix:semicolon
r_else
id|len
op_assign
id|len
l_char|&squot;a&squot;
op_plus
l_int|26
op_plus
l_int|1
suffix:semicolon
id|decode_85
c_func
(paren
id|buf
comma
id|av
(braket
l_int|2
)braket
op_plus
l_int|1
comma
id|len
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;decoded: %.*s&bslash;n&quot;
comma
id|len
comma
id|buf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|av
(braket
l_int|1
)braket
comma
l_string|&quot;-t&quot;
)paren
)paren
(brace
r_char
id|t
(braket
l_int|4
)braket
op_assign
(brace
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
)brace
suffix:semicolon
id|encode_85
c_func
(paren
id|buf
comma
id|t
comma
l_int|4
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;encoded: D%s&bslash;n&quot;
comma
id|buf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#endif
eof
