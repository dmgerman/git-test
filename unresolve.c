macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;tree-walk.h&quot;
DECL|variable|unresolve_usage
r_static
r_const
r_char
id|unresolve_usage
(braket
)braket
op_assign
l_string|&quot;git-unresolve &lt;paths&gt;...&quot;
suffix:semicolon
DECL|variable|cache_file
r_static
r_struct
id|cache_file
id|cache_file
suffix:semicolon
DECL|variable|head_sha1
r_static
r_int
r_char
id|head_sha1
(braket
l_int|20
)braket
suffix:semicolon
DECL|variable|merge_head_sha1
r_static
r_int
r_char
id|merge_head_sha1
(braket
l_int|20
)braket
suffix:semicolon
DECL|function|read_one_ent
r_static
r_struct
id|cache_entry
op_star
id|read_one_ent
c_func
(paren
r_const
r_char
op_star
id|which
comma
r_int
r_char
op_star
id|ent
comma
r_const
r_char
op_star
id|path
comma
r_int
id|namelen
comma
r_int
id|stage
)paren
(brace
r_int
id|mode
suffix:semicolon
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_int
id|size
suffix:semicolon
r_struct
id|cache_entry
op_star
id|ce
suffix:semicolon
r_if
c_cond
(paren
id|get_tree_entry
c_func
(paren
id|ent
comma
id|path
comma
id|sha1
comma
op_amp
id|mode
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;%s: not in %s branch.&quot;
comma
id|path
comma
id|which
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mode
op_eq
id|S_IFDIR
)paren
(brace
id|error
c_func
(paren
l_string|&quot;%s: not a blob in %s branch.&quot;
comma
id|path
comma
id|which
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|size
op_assign
id|cache_entry_size
c_func
(paren
id|namelen
)paren
suffix:semicolon
id|ce
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
id|size
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ce-&gt;sha1
comma
id|sha1
comma
l_int|20
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ce-&gt;name
comma
id|path
comma
id|namelen
)paren
suffix:semicolon
id|ce-&gt;ce_flags
op_assign
id|create_ce_flags
c_func
(paren
id|namelen
comma
id|stage
)paren
suffix:semicolon
id|ce-&gt;ce_mode
op_assign
id|create_ce_mode
c_func
(paren
id|mode
)paren
suffix:semicolon
r_return
id|ce
suffix:semicolon
)brace
DECL|function|unresolve_one
r_static
r_int
id|unresolve_one
c_func
(paren
r_const
r_char
op_star
id|path
)paren
(brace
r_int
id|namelen
op_assign
id|strlen
c_func
(paren
id|path
)paren
suffix:semicolon
r_int
id|pos
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_struct
id|cache_entry
op_star
id|ce_2
op_assign
l_int|NULL
comma
op_star
id|ce_3
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* See if there is such entry in the index. */
id|pos
op_assign
id|cache_name_pos
c_func
(paren
id|path
comma
id|namelen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
l_int|0
)paren
(brace
multiline_comment|/* If there isn&squot;t, either it is unmerged, or&n;&t;&t; * resolved as &quot;removed&quot; by mistake.  We do not&n;&t;&t; * want to do anything in the former case.&n;&t;&t; */
id|pos
op_assign
id|pos
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
id|active_nr
)paren
(brace
r_struct
id|cache_entry
op_star
id|ce
op_assign
id|active_cache
(braket
id|pos
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ce_namelen
c_func
(paren
id|ce
)paren
op_eq
id|namelen
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|ce-&gt;name
comma
id|path
comma
id|namelen
)paren
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: skipping still unmerged path.&bslash;n&quot;
comma
id|path
)paren
suffix:semicolon
r_goto
id|free_return
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Grab blobs from given path from HEAD and MERGE_HEAD,&n;&t; * stuff HEAD version in stage #2,&n;&t; * stuff MERGE_HEAD version in stage #3.&n;&t; */
id|ce_2
op_assign
id|read_one_ent
c_func
(paren
l_string|&quot;our&quot;
comma
id|head_sha1
comma
id|path
comma
id|namelen
comma
l_int|2
)paren
suffix:semicolon
id|ce_3
op_assign
id|read_one_ent
c_func
(paren
l_string|&quot;their&quot;
comma
id|merge_head_sha1
comma
id|path
comma
id|namelen
comma
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ce_2
op_logical_or
op_logical_neg
id|ce_3
)paren
(brace
id|ret
op_assign
l_int|1
suffix:semicolon
r_goto
id|free_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|ce_2-&gt;sha1
comma
id|ce_3-&gt;sha1
comma
l_int|20
)paren
op_logical_and
id|ce_2-&gt;ce_mode
op_eq
id|ce_3-&gt;ce_mode
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: identical in both, skipping.&bslash;n&quot;
comma
id|path
)paren
suffix:semicolon
r_goto
id|free_return
suffix:semicolon
)brace
id|remove_file_from_cache
c_func
(paren
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|add_cache_entry
c_func
(paren
id|ce_2
comma
id|ADD_CACHE_OK_TO_ADD
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;%s: cannot add our version to the index.&quot;
comma
id|path
)paren
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
r_goto
id|free_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|add_cache_entry
c_func
(paren
id|ce_3
comma
id|ADD_CACHE_OK_TO_ADD
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|error
c_func
(paren
l_string|&quot;%s: cannot add their version to the index.&quot;
comma
id|path
)paren
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
id|free_return
suffix:colon
id|free
c_func
(paren
id|ce_2
)paren
suffix:semicolon
id|free
c_func
(paren
id|ce_3
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|read_head_pointers
r_static
r_void
id|read_head_pointers
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|read_ref
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;HEAD&quot;
)paren
comma
id|head_sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Cannot read HEAD -- no initial commit yet?&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_ref
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;MERGE_HEAD&quot;
)paren
comma
id|merge_head_sha1
)paren
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Not in the middle of a merge.&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|0
)paren
suffix:semicolon
)brace
)brace
DECL|function|main
r_int
id|main
c_func
(paren
r_int
id|ac
comma
r_char
op_star
op_star
id|av
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_int
id|newfd
suffix:semicolon
r_if
c_cond
(paren
id|ac
OL
l_int|2
)paren
id|usage
c_func
(paren
id|unresolve_usage
)paren
suffix:semicolon
id|git_config
c_func
(paren
id|git_default_config
)paren
suffix:semicolon
multiline_comment|/* Read HEAD and MERGE_HEAD; if MERGE_HEAD does not exist, we&n;&t; * are not doing a merge, so exit with success status.&n;&t; */
id|read_head_pointers
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Otherwise we would need to update the cache. */
id|newfd
op_assign
id|hold_index_file_for_update
c_func
(paren
op_amp
id|cache_file
comma
id|get_index_file
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newfd
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;unable to create new cachefile&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_cache
c_func
(paren
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;cache corrupted&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|ac
suffix:semicolon
id|i
op_increment
)paren
(brace
r_char
op_star
id|arg
op_assign
id|av
(braket
id|i
)braket
suffix:semicolon
id|err
op_or_assign
id|unresolve_one
c_func
(paren
id|arg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
)paren
id|die
c_func
(paren
l_string|&quot;Error encountered; index not updated.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|active_cache_changed
)paren
(brace
r_if
c_cond
(paren
id|write_cache
c_func
(paren
id|newfd
comma
id|active_cache
comma
id|active_nr
)paren
op_logical_or
id|commit_index_file
c_func
(paren
op_amp
id|cache_file
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Unable to write new cachefile&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
