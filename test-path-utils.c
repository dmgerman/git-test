macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;string-list.h&quot;
multiline_comment|/*&n; * A &quot;string_list_each_func_t&quot; function that normalizes an entry from&n; * GIT_CEILING_DIRECTORIES.  If the path is unusable for some reason,&n; * die with an explanation.&n; */
DECL|function|normalize_ceiling_entry
r_static
r_int
id|normalize_ceiling_entry
c_func
(paren
r_struct
id|string_list_item
op_star
id|item
comma
r_void
op_star
id|unused
)paren
(brace
r_const
r_char
op_star
id|ceil
op_assign
id|item-&gt;string
suffix:semicolon
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|ceil
)paren
suffix:semicolon
r_char
id|buf
(braket
id|PATH_MAX
op_plus
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;Empty path is not supported&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|PATH_MAX
)paren
id|die
c_func
(paren
l_string|&quot;Path &bslash;&quot;%s&bslash;&quot; is too long&quot;
comma
id|ceil
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_absolute_path
c_func
(paren
id|ceil
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Path &bslash;&quot;%s&bslash;&quot; is not absolute&quot;
comma
id|ceil
)paren
suffix:semicolon
r_if
c_cond
(paren
id|normalize_path_copy
c_func
(paren
id|buf
comma
id|ceil
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;Path &bslash;&quot;%s&bslash;&quot; could not be normalized&quot;
comma
id|ceil
)paren
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|1
op_logical_and
id|buf
(braket
id|len
op_minus
l_int|1
)braket
op_eq
l_char|&squot;/&squot;
)paren
id|die
c_func
(paren
l_string|&quot;Normalized path &bslash;&quot;%s&bslash;&quot; ended with slash&quot;
comma
id|buf
)paren
suffix:semicolon
id|free
c_func
(paren
id|item-&gt;string
)paren
suffix:semicolon
id|item-&gt;string
op_assign
id|xstrdup
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|main
r_int
id|main
c_func
(paren
r_int
id|argc
comma
r_char
op_star
op_star
id|argv
)paren
(brace
r_if
c_cond
(paren
id|argc
op_eq
l_int|3
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
l_string|&quot;normalize_path_copy&quot;
)paren
)paren
(brace
r_char
op_star
id|buf
op_assign
id|xmalloc
c_func
(paren
id|PATH_MAX
op_plus
l_int|1
)paren
suffix:semicolon
r_int
id|rv
op_assign
id|normalize_path_copy
c_func
(paren
id|buf
comma
id|argv
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
)paren
id|buf
op_assign
l_string|&quot;++failed++&quot;
suffix:semicolon
id|puts
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|argc
op_ge
l_int|2
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
l_string|&quot;real_path&quot;
)paren
)paren
(brace
r_while
c_loop
(paren
id|argc
OG
l_int|2
)paren
(brace
id|puts
c_func
(paren
id|real_path
c_func
(paren
id|argv
(braket
l_int|2
)braket
)paren
)paren
suffix:semicolon
id|argc
op_decrement
suffix:semicolon
id|argv
op_increment
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|argc
op_ge
l_int|2
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
l_string|&quot;absolute_path&quot;
)paren
)paren
(brace
r_while
c_loop
(paren
id|argc
OG
l_int|2
)paren
(brace
id|puts
c_func
(paren
id|absolute_path
c_func
(paren
id|argv
(braket
l_int|2
)braket
)paren
)paren
suffix:semicolon
id|argc
op_decrement
suffix:semicolon
id|argv
op_increment
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|argc
op_eq
l_int|4
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
l_string|&quot;longest_ancestor_length&quot;
)paren
)paren
(brace
r_int
id|len
suffix:semicolon
r_struct
id|string_list
id|ceiling_dirs
op_assign
id|STRING_LIST_INIT_DUP
suffix:semicolon
r_char
op_star
id|path
op_assign
id|xstrdup
c_func
(paren
id|argv
(braket
l_int|2
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We have to normalize the arguments because under&n;&t;&t; * Windows, bash mangles arguments that look like&n;&t;&t; * absolute POSIX paths or colon-separate lists of&n;&t;&t; * absolute POSIX paths into DOS paths (e.g.,&n;&t;&t; * &quot;/foo:/foo/bar&quot; might be converted to&n;&t;&t; * &quot;D:&bslash;Src&bslash;msysgit&bslash;foo;D:&bslash;Src&bslash;msysgit&bslash;foo&bslash;bar&quot;),&n;&t;&t; * whereas longest_ancestor_length() requires paths&n;&t;&t; * that use forward slashes.&n;&t;&t; */
r_if
c_cond
(paren
id|normalize_path_copy
c_func
(paren
id|path
comma
id|path
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Path &bslash;&quot;%s&bslash;&quot; could not be normalized&quot;
comma
id|argv
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|string_list_split
c_func
(paren
op_amp
id|ceiling_dirs
comma
id|argv
(braket
l_int|3
)braket
comma
id|PATH_SEP
comma
l_int|1
)paren
suffix:semicolon
id|filter_string_list
c_func
(paren
op_amp
id|ceiling_dirs
comma
l_int|0
comma
id|normalize_ceiling_entry
comma
l_int|NULL
)paren
suffix:semicolon
id|len
op_assign
id|longest_ancestor_length
c_func
(paren
id|path
comma
op_amp
id|ceiling_dirs
)paren
suffix:semicolon
id|string_list_clear
c_func
(paren
op_amp
id|ceiling_dirs
comma
l_int|0
)paren
suffix:semicolon
id|free
c_func
(paren
id|path
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%d&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|argc
op_ge
l_int|4
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
l_string|&quot;prefix_path&quot;
)paren
)paren
(brace
r_char
op_star
id|prefix
op_assign
id|argv
(braket
l_int|2
)braket
suffix:semicolon
r_int
id|prefix_len
op_assign
id|strlen
c_func
(paren
id|prefix
)paren
suffix:semicolon
r_int
id|nongit_ok
suffix:semicolon
id|setup_git_directory_gently
c_func
(paren
op_amp
id|nongit_ok
)paren
suffix:semicolon
r_while
c_loop
(paren
id|argc
OG
l_int|3
)paren
(brace
id|puts
c_func
(paren
id|prefix_path
c_func
(paren
id|prefix
comma
id|prefix_len
comma
id|argv
(braket
l_int|3
)braket
)paren
)paren
suffix:semicolon
id|argc
op_decrement
suffix:semicolon
id|argv
op_increment
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|argc
op_eq
l_int|4
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
l_string|&quot;strip_path_suffix&quot;
)paren
)paren
(brace
r_char
op_star
id|prefix
op_assign
id|strip_path_suffix
c_func
(paren
id|argv
(braket
l_int|2
)braket
comma
id|argv
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|prefix
ques
c_cond
id|prefix
suffix:colon
l_string|&quot;(null)&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: unknown function name: %s&bslash;n&quot;
comma
id|argv
(braket
l_int|0
)braket
comma
id|argv
(braket
l_int|1
)braket
ques
c_cond
id|argv
(braket
l_int|1
)braket
suffix:colon
l_string|&quot;(there was none)&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
eof
