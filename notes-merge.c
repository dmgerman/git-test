macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;commit.h&quot;
macro_line|#include &quot;refs.h&quot;
macro_line|#include &quot;diff.h&quot;
macro_line|#include &quot;diffcore.h&quot;
macro_line|#include &quot;notes.h&quot;
macro_line|#include &quot;notes-merge.h&quot;
DECL|struct|notes_merge_pair
r_struct
id|notes_merge_pair
(brace
DECL|member|obj
DECL|member|base
DECL|member|local
DECL|member|remote
r_int
r_char
id|obj
(braket
l_int|20
)braket
comma
id|base
(braket
l_int|20
)braket
comma
id|local
(braket
l_int|20
)braket
comma
id|remote
(braket
l_int|20
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|function|init_notes_merge_options
r_void
id|init_notes_merge_options
c_func
(paren
r_struct
id|notes_merge_options
op_star
id|o
)paren
(brace
id|memset
c_func
(paren
id|o
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|notes_merge_options
)paren
)paren
suffix:semicolon
id|o-&gt;verbosity
op_assign
id|NOTES_MERGE_VERBOSITY_DEFAULT
suffix:semicolon
)brace
DECL|macro|OUTPUT
mdefine_line|#define OUTPUT(o, v, ...) &bslash;&n;&t;do { &bslash;&n;&t;&t;if ((o)-&gt;verbosity &gt;= (v)) { &bslash;&n;&t;&t;&t;printf(__VA_ARGS__); &bslash;&n;&t;&t;&t;puts(&quot;&quot;); &bslash;&n;&t;&t;} &bslash;&n;&t;} while (0)
DECL|function|path_to_sha1
r_static
r_int
id|path_to_sha1
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_int
r_char
op_star
id|sha1
)paren
(brace
r_char
id|hex_sha1
(braket
l_int|40
)braket
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_star
id|path
op_logical_and
id|i
OL
l_int|40
)paren
(brace
r_if
c_cond
(paren
op_star
id|path
op_ne
l_char|&squot;/&squot;
)paren
id|hex_sha1
(braket
id|i
op_increment
)braket
op_assign
op_star
id|path
suffix:semicolon
id|path
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|path
op_logical_or
id|i
op_ne
l_int|40
)paren
r_return
l_int|1
suffix:semicolon
r_return
id|get_sha1_hex
c_func
(paren
id|hex_sha1
comma
id|sha1
)paren
suffix:semicolon
)brace
DECL|function|verify_notes_filepair
r_static
r_int
id|verify_notes_filepair
c_func
(paren
r_struct
id|diff_filepair
op_star
id|p
comma
r_int
r_char
op_star
id|sha1
)paren
(brace
r_switch
c_cond
(paren
id|p-&gt;status
)paren
(brace
r_case
id|DIFF_STATUS_MODIFIED
suffix:colon
m_assert
(paren
id|p-&gt;one-&gt;mode
op_eq
id|p-&gt;two-&gt;mode
)paren
suffix:semicolon
m_assert
(paren
op_logical_neg
id|is_null_sha1
c_func
(paren
id|p-&gt;one-&gt;sha1
)paren
)paren
suffix:semicolon
m_assert
(paren
op_logical_neg
id|is_null_sha1
c_func
(paren
id|p-&gt;two-&gt;sha1
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DIFF_STATUS_ADDED
suffix:colon
m_assert
(paren
id|is_null_sha1
c_func
(paren
id|p-&gt;one-&gt;sha1
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DIFF_STATUS_DELETED
suffix:colon
m_assert
(paren
id|is_null_sha1
c_func
(paren
id|p-&gt;two-&gt;sha1
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
l_int|1
suffix:semicolon
)brace
m_assert
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|p-&gt;one-&gt;path
comma
id|p-&gt;two-&gt;path
)paren
)paren
suffix:semicolon
r_return
id|path_to_sha1
c_func
(paren
id|p-&gt;one-&gt;path
comma
id|sha1
)paren
suffix:semicolon
)brace
DECL|function|find_notes_merge_pair_pos
r_static
r_struct
id|notes_merge_pair
op_star
id|find_notes_merge_pair_pos
c_func
(paren
r_struct
id|notes_merge_pair
op_star
id|list
comma
r_int
id|len
comma
r_int
r_char
op_star
id|obj
comma
r_int
id|insert_new
comma
r_int
op_star
id|occupied
)paren
(brace
multiline_comment|/*&n;&t; * Both diff_tree_remote() and diff_tree_local() tend to process&n;&t; * merge_pairs in ascending order. Therefore, cache last returned&n;&t; * index, and search sequentially from there until the appropriate&n;&t; * position is found.&n;&t; *&n;&t; * Since inserts only happen from diff_tree_remote() (which mainly&n;&t; * _appends_), we don&squot;t care that inserting into the middle of the&n;&t; * list is expensive (using memmove()).&n;&t; */
r_static
r_int
id|last_index
suffix:semicolon
r_int
id|i
op_assign
id|last_index
OL
id|len
ques
c_cond
id|last_index
suffix:colon
id|len
l_int|1
suffix:semicolon
r_int
id|prev_cmp
op_assign
l_int|0
comma
id|cmp
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|i
op_ge
l_int|0
op_logical_and
id|i
OL
id|len
)paren
(brace
id|cmp
op_assign
id|hashcmp
c_func
(paren
id|obj
comma
id|list
(braket
id|i
)braket
dot
id|obj
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmp
)paren
multiline_comment|/* obj belongs @ i */
r_break
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cmp
OL
l_int|0
op_logical_and
id|prev_cmp
op_le
l_int|0
)paren
multiline_comment|/* obj belongs &lt; i */
id|i
op_decrement
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cmp
OL
l_int|0
)paren
multiline_comment|/* obj belongs between i-1 and i */
r_break
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cmp
OG
l_int|0
op_logical_and
id|prev_cmp
op_ge
l_int|0
)paren
multiline_comment|/* obj belongs &gt; i */
id|i
op_increment
suffix:semicolon
r_else
multiline_comment|/* if (cmp &gt; 0) */
(brace
multiline_comment|/* obj belongs between i and i+1 */
id|i
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
id|prev_cmp
op_assign
id|cmp
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
id|i
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* obj belongs at, or immediately preceding, index i (0 &lt;= i &lt;= len) */
r_if
c_cond
(paren
op_logical_neg
id|cmp
)paren
op_star
id|occupied
op_assign
l_int|1
suffix:semicolon
r_else
(brace
op_star
id|occupied
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|insert_new
op_logical_and
id|i
OL
id|len
)paren
(brace
id|memmove
c_func
(paren
id|list
op_plus
id|i
op_plus
l_int|1
comma
id|list
op_plus
id|i
comma
(paren
id|len
id|i
)paren
op_star
r_sizeof
(paren
r_struct
id|notes_merge_pair
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|list
op_plus
id|i
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|notes_merge_pair
)paren
)paren
suffix:semicolon
)brace
)brace
id|last_index
op_assign
id|i
suffix:semicolon
r_return
id|list
op_plus
id|i
suffix:semicolon
)brace
DECL|variable|uninitialized
r_static
r_int
r_char
id|uninitialized
(braket
l_int|20
)braket
op_assign
l_string|&quot;&bslash;xff&bslash;xff&bslash;xff&bslash;xff&bslash;xff&bslash;xff&bslash;xff&bslash;xff&bslash;xff&bslash;xff&quot;
"&bslash;"
l_string|&quot;&bslash;xff&bslash;xff&bslash;xff&bslash;xff&bslash;xff&bslash;xff&bslash;xff&bslash;xff&bslash;xff&bslash;xff&quot;
suffix:semicolon
DECL|function|diff_tree_remote
r_static
r_struct
id|notes_merge_pair
op_star
id|diff_tree_remote
c_func
(paren
r_struct
id|notes_merge_options
op_star
id|o
comma
r_const
r_int
r_char
op_star
id|base
comma
r_const
r_int
r_char
op_star
id|remote
comma
r_int
op_star
id|num_changes
)paren
(brace
r_struct
id|diff_options
id|opt
suffix:semicolon
r_struct
id|notes_merge_pair
op_star
id|changes
suffix:semicolon
r_int
id|i
comma
id|len
op_assign
l_int|0
suffix:semicolon
id|trace_printf
c_func
(paren
l_string|&quot;&bslash;tdiff_tree_remote(base = %.7s, remote = %.7s)&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|base
)paren
comma
id|sha1_to_hex
c_func
(paren
id|remote
)paren
)paren
suffix:semicolon
id|diff_setup
c_func
(paren
op_amp
id|opt
)paren
suffix:semicolon
id|DIFF_OPT_SET
c_func
(paren
op_amp
id|opt
comma
id|RECURSIVE
)paren
suffix:semicolon
id|opt.output_format
op_assign
id|DIFF_FORMAT_NO_OUTPUT
suffix:semicolon
r_if
c_cond
(paren
id|diff_setup_done
c_func
(paren
op_amp
id|opt
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;diff_setup_done failed&quot;
)paren
suffix:semicolon
id|diff_tree_sha1
c_func
(paren
id|base
comma
id|remote
comma
l_string|&quot;&quot;
comma
op_amp
id|opt
)paren
suffix:semicolon
id|diffcore_std
c_func
(paren
op_amp
id|opt
)paren
suffix:semicolon
id|changes
op_assign
id|xcalloc
c_func
(paren
id|diff_queued_diff.nr
comma
r_sizeof
(paren
r_struct
id|notes_merge_pair
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|diff_queued_diff.nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|diff_filepair
op_star
id|p
op_assign
id|diff_queued_diff.queue
(braket
id|i
)braket
suffix:semicolon
r_struct
id|notes_merge_pair
op_star
id|mp
suffix:semicolon
r_int
id|occupied
suffix:semicolon
r_int
r_char
id|obj
(braket
l_int|20
)braket
suffix:semicolon
r_if
c_cond
(paren
id|verify_notes_filepair
c_func
(paren
id|p
comma
id|obj
)paren
)paren
(brace
id|trace_printf
c_func
(paren
l_string|&quot;&bslash;t&bslash;tCannot merge entry &squot;%s&squot; (%c): &quot;
l_string|&quot;%.7s -&gt; %.7s. Skipping!&bslash;n&quot;
comma
id|p-&gt;one-&gt;path
comma
id|p-&gt;status
comma
id|sha1_to_hex
c_func
(paren
id|p-&gt;one-&gt;sha1
)paren
comma
id|sha1_to_hex
c_func
(paren
id|p-&gt;two-&gt;sha1
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|mp
op_assign
id|find_notes_merge_pair_pos
c_func
(paren
id|changes
comma
id|len
comma
id|obj
comma
l_int|1
comma
op_amp
id|occupied
)paren
suffix:semicolon
r_if
c_cond
(paren
id|occupied
)paren
(brace
multiline_comment|/* We&squot;ve found an addition/deletion pair */
m_assert
(paren
op_logical_neg
id|hashcmp
c_func
(paren
id|mp-&gt;obj
comma
id|obj
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_null_sha1
c_func
(paren
id|p-&gt;one-&gt;sha1
)paren
)paren
(brace
multiline_comment|/* addition */
m_assert
(paren
id|is_null_sha1
c_func
(paren
id|mp-&gt;remote
)paren
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|mp-&gt;remote
comma
id|p-&gt;two-&gt;sha1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|is_null_sha1
c_func
(paren
id|p-&gt;two-&gt;sha1
)paren
)paren
(brace
multiline_comment|/* deletion */
m_assert
(paren
id|is_null_sha1
c_func
(paren
id|mp-&gt;base
)paren
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|mp-&gt;base
comma
id|p-&gt;one-&gt;sha1
)paren
suffix:semicolon
)brace
r_else
m_assert
(paren
op_logical_neg
l_string|&quot;Invalid existing change recorded&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|hashcpy
c_func
(paren
id|mp-&gt;obj
comma
id|obj
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|mp-&gt;base
comma
id|p-&gt;one-&gt;sha1
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|mp-&gt;local
comma
id|uninitialized
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|mp-&gt;remote
comma
id|p-&gt;two-&gt;sha1
)paren
suffix:semicolon
id|len
op_increment
suffix:semicolon
)brace
id|trace_printf
c_func
(paren
l_string|&quot;&bslash;t&bslash;tStored remote change for %s: %.7s -&gt; %.7s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|mp-&gt;obj
)paren
comma
id|sha1_to_hex
c_func
(paren
id|mp-&gt;base
)paren
comma
id|sha1_to_hex
c_func
(paren
id|mp-&gt;remote
)paren
)paren
suffix:semicolon
)brace
id|diff_flush
c_func
(paren
op_amp
id|opt
)paren
suffix:semicolon
id|diff_tree_release_paths
c_func
(paren
op_amp
id|opt
)paren
suffix:semicolon
op_star
id|num_changes
op_assign
id|len
suffix:semicolon
r_return
id|changes
suffix:semicolon
)brace
DECL|function|diff_tree_local
r_static
r_void
id|diff_tree_local
c_func
(paren
r_struct
id|notes_merge_options
op_star
id|o
comma
r_struct
id|notes_merge_pair
op_star
id|changes
comma
r_int
id|len
comma
r_const
r_int
r_char
op_star
id|base
comma
r_const
r_int
r_char
op_star
id|local
)paren
(brace
r_struct
id|diff_options
id|opt
suffix:semicolon
r_int
id|i
suffix:semicolon
id|trace_printf
c_func
(paren
l_string|&quot;&bslash;tdiff_tree_local(len = %i, base = %.7s, local = %.7s)&bslash;n&quot;
comma
id|len
comma
id|sha1_to_hex
c_func
(paren
id|base
)paren
comma
id|sha1_to_hex
c_func
(paren
id|local
)paren
)paren
suffix:semicolon
id|diff_setup
c_func
(paren
op_amp
id|opt
)paren
suffix:semicolon
id|DIFF_OPT_SET
c_func
(paren
op_amp
id|opt
comma
id|RECURSIVE
)paren
suffix:semicolon
id|opt.output_format
op_assign
id|DIFF_FORMAT_NO_OUTPUT
suffix:semicolon
r_if
c_cond
(paren
id|diff_setup_done
c_func
(paren
op_amp
id|opt
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;diff_setup_done failed&quot;
)paren
suffix:semicolon
id|diff_tree_sha1
c_func
(paren
id|base
comma
id|local
comma
l_string|&quot;&quot;
comma
op_amp
id|opt
)paren
suffix:semicolon
id|diffcore_std
c_func
(paren
op_amp
id|opt
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|diff_queued_diff.nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|diff_filepair
op_star
id|p
op_assign
id|diff_queued_diff.queue
(braket
id|i
)braket
suffix:semicolon
r_struct
id|notes_merge_pair
op_star
id|mp
suffix:semicolon
r_int
id|match
suffix:semicolon
r_int
r_char
id|obj
(braket
l_int|20
)braket
suffix:semicolon
r_if
c_cond
(paren
id|verify_notes_filepair
c_func
(paren
id|p
comma
id|obj
)paren
)paren
(brace
id|trace_printf
c_func
(paren
l_string|&quot;&bslash;t&bslash;tCannot merge entry &squot;%s&squot; (%c): &quot;
l_string|&quot;%.7s -&gt; %.7s. Skipping!&bslash;n&quot;
comma
id|p-&gt;one-&gt;path
comma
id|p-&gt;status
comma
id|sha1_to_hex
c_func
(paren
id|p-&gt;one-&gt;sha1
)paren
comma
id|sha1_to_hex
c_func
(paren
id|p-&gt;two-&gt;sha1
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|mp
op_assign
id|find_notes_merge_pair_pos
c_func
(paren
id|changes
comma
id|len
comma
id|obj
comma
l_int|0
comma
op_amp
id|match
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|match
)paren
(brace
id|trace_printf
c_func
(paren
l_string|&quot;&bslash;t&bslash;tIgnoring local-only change for %s: &quot;
l_string|&quot;%.7s -&gt; %.7s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|obj
)paren
comma
id|sha1_to_hex
c_func
(paren
id|p-&gt;one-&gt;sha1
)paren
comma
id|sha1_to_hex
c_func
(paren
id|p-&gt;two-&gt;sha1
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
m_assert
(paren
op_logical_neg
id|hashcmp
c_func
(paren
id|mp-&gt;obj
comma
id|obj
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_null_sha1
c_func
(paren
id|p-&gt;two-&gt;sha1
)paren
)paren
(brace
multiline_comment|/* deletion */
multiline_comment|/*&n;&t;&t;&t; * Either this is a true deletion (1), or it is part&n;&t;&t;&t; * of an A/D pair (2), or D/A pair (3):&n;&t;&t;&t; *&n;&t;&t;&t; * (1) mp-&gt;local is uninitialized; set it to null_sha1&n;&t;&t;&t; * (2) mp-&gt;local is not uninitialized; don&squot;t touch it&n;&t;&t;&t; * (3) mp-&gt;local is uninitialized; set it to null_sha1&n;&t;&t;&t; *     (will be overwritten by following addition)&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|hashcmp
c_func
(paren
id|mp-&gt;local
comma
id|uninitialized
)paren
)paren
id|hashclr
c_func
(paren
id|mp-&gt;local
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|is_null_sha1
c_func
(paren
id|p-&gt;one-&gt;sha1
)paren
)paren
(brace
multiline_comment|/* addition */
multiline_comment|/*&n;&t;&t;&t; * Either this is a true addition (1), or it is part&n;&t;&t;&t; * of an A/D pair (2), or D/A pair (3):&n;&t;&t;&t; *&n;&t;&t;&t; * (1) mp-&gt;local is uninitialized; set to p-&gt;two-&gt;sha1&n;&t;&t;&t; * (2) mp-&gt;local is uninitialized; set to p-&gt;two-&gt;sha1&n;&t;&t;&t; * (3) mp-&gt;local is null_sha1;     set to p-&gt;two-&gt;sha1&n;&t;&t;&t; */
m_assert
(paren
id|is_null_sha1
c_func
(paren
id|mp-&gt;local
)paren
op_logical_or
op_logical_neg
id|hashcmp
c_func
(paren
id|mp-&gt;local
comma
id|uninitialized
)paren
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|mp-&gt;local
comma
id|p-&gt;two-&gt;sha1
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* modification */
multiline_comment|/*&n;&t;&t;&t; * This is a true modification. p-&gt;one-&gt;sha1 shall&n;&t;&t;&t; * match mp-&gt;base, and mp-&gt;local shall be uninitialized.&n;&t;&t;&t; * Set mp-&gt;local to p-&gt;two-&gt;sha1.&n;&t;&t;&t; */
m_assert
(paren
op_logical_neg
id|hashcmp
c_func
(paren
id|p-&gt;one-&gt;sha1
comma
id|mp-&gt;base
)paren
)paren
suffix:semicolon
m_assert
(paren
op_logical_neg
id|hashcmp
c_func
(paren
id|mp-&gt;local
comma
id|uninitialized
)paren
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|mp-&gt;local
comma
id|p-&gt;two-&gt;sha1
)paren
suffix:semicolon
)brace
id|trace_printf
c_func
(paren
l_string|&quot;&bslash;t&bslash;tStored local change for %s: %.7s -&gt; %.7s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|mp-&gt;obj
)paren
comma
id|sha1_to_hex
c_func
(paren
id|mp-&gt;base
)paren
comma
id|sha1_to_hex
c_func
(paren
id|mp-&gt;local
)paren
)paren
suffix:semicolon
)brace
id|diff_flush
c_func
(paren
op_amp
id|opt
)paren
suffix:semicolon
id|diff_tree_release_paths
c_func
(paren
op_amp
id|opt
)paren
suffix:semicolon
)brace
DECL|function|merge_one_change
r_static
r_int
id|merge_one_change
c_func
(paren
r_struct
id|notes_merge_options
op_star
id|o
comma
r_struct
id|notes_merge_pair
op_star
id|p
comma
r_struct
id|notes_tree
op_star
id|t
)paren
(brace
multiline_comment|/*&n;&t; * Return 0 if change was resolved (and added to notes_tree),&n;&t; * 1 if conflict&n;&t; */
r_switch
c_cond
(paren
id|o-&gt;strategy
)paren
(brace
r_case
id|NOTES_MERGE_RESOLVE_MANUAL
suffix:colon
r_return
l_int|1
suffix:semicolon
r_case
id|NOTES_MERGE_RESOLVE_OURS
suffix:colon
id|OUTPUT
c_func
(paren
id|o
comma
l_int|2
comma
l_string|&quot;Using local notes for %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|p-&gt;obj
)paren
)paren
suffix:semicolon
multiline_comment|/* nothing to do */
r_return
l_int|0
suffix:semicolon
r_case
id|NOTES_MERGE_RESOLVE_THEIRS
suffix:colon
id|OUTPUT
c_func
(paren
id|o
comma
l_int|2
comma
l_string|&quot;Using remote notes for %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|p-&gt;obj
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|add_note
c_func
(paren
id|t
comma
id|p-&gt;obj
comma
id|p-&gt;remote
comma
id|combine_notes_overwrite
)paren
)paren
id|die
c_func
(paren
l_string|&quot;BUG: combine_notes_overwrite failed&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|NOTES_MERGE_RESOLVE_UNION
suffix:colon
id|OUTPUT
c_func
(paren
id|o
comma
l_int|2
comma
l_string|&quot;Concatenating local and remote notes for %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|p-&gt;obj
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|add_note
c_func
(paren
id|t
comma
id|p-&gt;obj
comma
id|p-&gt;remote
comma
id|combine_notes_concatenate
)paren
)paren
id|die
c_func
(paren
l_string|&quot;failed to concatenate notes &quot;
l_string|&quot;(combine_notes_concatenate)&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|die
c_func
(paren
l_string|&quot;Unknown strategy (%i).&quot;
comma
id|o-&gt;strategy
)paren
suffix:semicolon
)brace
DECL|function|merge_changes
r_static
r_int
id|merge_changes
c_func
(paren
r_struct
id|notes_merge_options
op_star
id|o
comma
r_struct
id|notes_merge_pair
op_star
id|changes
comma
r_int
op_star
id|num_changes
comma
r_struct
id|notes_tree
op_star
id|t
)paren
(brace
r_int
id|i
comma
id|conflicts
op_assign
l_int|0
suffix:semicolon
id|trace_printf
c_func
(paren
l_string|&quot;&bslash;tmerge_changes(num_changes = %i)&bslash;n&quot;
comma
op_star
id|num_changes
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
op_star
id|num_changes
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|notes_merge_pair
op_star
id|p
op_assign
id|changes
op_plus
id|i
suffix:semicolon
id|trace_printf
c_func
(paren
l_string|&quot;&bslash;t&bslash;t%.7s: %.7s -&gt; %.7s/%.7s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|p-&gt;obj
)paren
comma
id|sha1_to_hex
c_func
(paren
id|p-&gt;base
)paren
comma
id|sha1_to_hex
c_func
(paren
id|p-&gt;local
)paren
comma
id|sha1_to_hex
c_func
(paren
id|p-&gt;remote
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hashcmp
c_func
(paren
id|p-&gt;base
comma
id|p-&gt;remote
)paren
)paren
(brace
multiline_comment|/* no remote change; nothing to do */
id|trace_printf
c_func
(paren
l_string|&quot;&bslash;t&bslash;t&bslash;tskipping (no remote change)&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|hashcmp
c_func
(paren
id|p-&gt;local
comma
id|p-&gt;remote
)paren
)paren
(brace
multiline_comment|/* same change in local and remote; nothing to do */
id|trace_printf
c_func
(paren
l_string|&quot;&bslash;t&bslash;t&bslash;tskipping (local == remote)&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|hashcmp
c_func
(paren
id|p-&gt;local
comma
id|uninitialized
)paren
op_logical_or
op_logical_neg
id|hashcmp
c_func
(paren
id|p-&gt;local
comma
id|p-&gt;base
)paren
)paren
(brace
multiline_comment|/* no local change; adopt remote change */
id|trace_printf
c_func
(paren
l_string|&quot;&bslash;t&bslash;t&bslash;tno local change, adopted remote&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|add_note
c_func
(paren
id|t
comma
id|p-&gt;obj
comma
id|p-&gt;remote
comma
id|combine_notes_overwrite
)paren
)paren
id|die
c_func
(paren
l_string|&quot;BUG: combine_notes_overwrite failed&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* need file-level merge between local and remote */
id|trace_printf
c_func
(paren
l_string|&quot;&bslash;t&bslash;t&bslash;tneed content-level merge&bslash;n&quot;
)paren
suffix:semicolon
id|conflicts
op_add_assign
id|merge_one_change
c_func
(paren
id|o
comma
id|p
comma
id|t
)paren
suffix:semicolon
)brace
)brace
r_return
id|conflicts
suffix:semicolon
)brace
DECL|function|merge_from_diffs
r_static
r_int
id|merge_from_diffs
c_func
(paren
r_struct
id|notes_merge_options
op_star
id|o
comma
r_const
r_int
r_char
op_star
id|base
comma
r_const
r_int
r_char
op_star
id|local
comma
r_const
r_int
r_char
op_star
id|remote
comma
r_struct
id|notes_tree
op_star
id|t
)paren
(brace
r_struct
id|notes_merge_pair
op_star
id|changes
suffix:semicolon
r_int
id|num_changes
comma
id|conflicts
suffix:semicolon
id|trace_printf
c_func
(paren
l_string|&quot;&bslash;tmerge_from_diffs(base = %.7s, local = %.7s, &quot;
l_string|&quot;remote = %.7s)&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|base
)paren
comma
id|sha1_to_hex
c_func
(paren
id|local
)paren
comma
id|sha1_to_hex
c_func
(paren
id|remote
)paren
)paren
suffix:semicolon
id|changes
op_assign
id|diff_tree_remote
c_func
(paren
id|o
comma
id|base
comma
id|remote
comma
op_amp
id|num_changes
)paren
suffix:semicolon
id|diff_tree_local
c_func
(paren
id|o
comma
id|changes
comma
id|num_changes
comma
id|base
comma
id|local
)paren
suffix:semicolon
id|conflicts
op_assign
id|merge_changes
c_func
(paren
id|o
comma
id|changes
comma
op_amp
id|num_changes
comma
id|t
)paren
suffix:semicolon
id|free
c_func
(paren
id|changes
)paren
suffix:semicolon
id|OUTPUT
c_func
(paren
id|o
comma
l_int|4
comma
l_string|&quot;Merge result: %i unmerged notes and a %s notes tree&quot;
comma
id|conflicts
comma
id|t-&gt;dirty
ques
c_cond
l_string|&quot;dirty&quot;
suffix:colon
l_string|&quot;clean&quot;
)paren
suffix:semicolon
r_return
id|conflicts
ques
c_cond
l_int|1
suffix:colon
l_int|1
suffix:semicolon
)brace
DECL|function|create_notes_commit
r_void
id|create_notes_commit
c_func
(paren
r_struct
id|notes_tree
op_star
id|t
comma
r_struct
id|commit_list
op_star
id|parents
comma
r_const
r_char
op_star
id|msg
comma
r_int
r_char
op_star
id|result_sha1
)paren
(brace
r_int
r_char
id|tree_sha1
(braket
l_int|20
)braket
suffix:semicolon
m_assert
(paren
id|t-&gt;initialized
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write_notes_tree
c_func
(paren
id|t
comma
id|tree_sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Failed to write notes tree to database&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parents
)paren
(brace
multiline_comment|/* Deduce parent commit from t-&gt;ref */
r_int
r_char
id|parent_sha1
(braket
l_int|20
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|read_ref
c_func
(paren
id|t-&gt;ref
comma
id|parent_sha1
)paren
)paren
(brace
r_struct
id|commit
op_star
id|parent
op_assign
id|lookup_commit
c_func
(paren
id|parent_sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parent
op_logical_or
id|parse_commit
c_func
(paren
id|parent
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Failed to find/parse commit %s&quot;
comma
id|t-&gt;ref
)paren
suffix:semicolon
id|commit_list_insert
c_func
(paren
id|parent
comma
op_amp
id|parents
)paren
suffix:semicolon
)brace
multiline_comment|/* else: t-&gt;ref points to nothing, assume root/orphan commit */
)brace
r_if
c_cond
(paren
id|commit_tree
c_func
(paren
id|msg
comma
id|tree_sha1
comma
id|parents
comma
id|result_sha1
comma
l_int|NULL
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Failed to commit notes tree to database&quot;
)paren
suffix:semicolon
)brace
DECL|function|notes_merge
r_int
id|notes_merge
c_func
(paren
r_struct
id|notes_merge_options
op_star
id|o
comma
r_struct
id|notes_tree
op_star
id|local_tree
comma
r_int
r_char
op_star
id|result_sha1
)paren
(brace
r_int
r_char
id|local_sha1
(braket
l_int|20
)braket
comma
id|remote_sha1
(braket
l_int|20
)braket
suffix:semicolon
r_struct
id|commit
op_star
id|local
comma
op_star
id|remote
suffix:semicolon
r_struct
id|commit_list
op_star
id|bases
op_assign
l_int|NULL
suffix:semicolon
r_const
r_int
r_char
op_star
id|base_sha1
comma
op_star
id|base_tree_sha1
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
m_assert
(paren
id|o-&gt;local_ref
op_logical_and
id|o-&gt;remote_ref
)paren
suffix:semicolon
m_assert
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|o-&gt;local_ref
comma
id|local_tree-&gt;ref
)paren
)paren
suffix:semicolon
id|hashclr
c_func
(paren
id|result_sha1
)paren
suffix:semicolon
id|trace_printf
c_func
(paren
l_string|&quot;notes_merge(o-&gt;local_ref = %s, o-&gt;remote_ref = %s)&bslash;n&quot;
comma
id|o-&gt;local_ref
comma
id|o-&gt;remote_ref
)paren
suffix:semicolon
multiline_comment|/* Dereference o-&gt;local_ref into local_sha1 */
r_if
c_cond
(paren
op_logical_neg
id|resolve_ref
c_func
(paren
id|o-&gt;local_ref
comma
id|local_sha1
comma
l_int|0
comma
l_int|NULL
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Failed to resolve local notes ref &squot;%s&squot;&quot;
comma
id|o-&gt;local_ref
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|check_ref_format
c_func
(paren
id|o-&gt;local_ref
)paren
op_logical_and
id|is_null_sha1
c_func
(paren
id|local_sha1
)paren
)paren
id|local
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* local_sha1 == null_sha1 indicates unborn ref */
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|local
op_assign
id|lookup_commit_reference
c_func
(paren
id|local_sha1
)paren
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Could not parse local commit %s (%s)&quot;
comma
id|sha1_to_hex
c_func
(paren
id|local_sha1
)paren
comma
id|o-&gt;local_ref
)paren
suffix:semicolon
id|trace_printf
c_func
(paren
l_string|&quot;&bslash;tlocal commit: %.7s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|local_sha1
)paren
)paren
suffix:semicolon
multiline_comment|/* Dereference o-&gt;remote_ref into remote_sha1 */
r_if
c_cond
(paren
id|get_sha1
c_func
(paren
id|o-&gt;remote_ref
comma
id|remote_sha1
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Failed to get remote_sha1. If o-&gt;remote_ref looks like an&n;&t;&t; * unborn ref, perform the merge using an empty notes tree.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|check_ref_format
c_func
(paren
id|o-&gt;remote_ref
)paren
)paren
(brace
id|hashclr
c_func
(paren
id|remote_sha1
)paren
suffix:semicolon
id|remote
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|die
c_func
(paren
l_string|&quot;Failed to resolve remote notes ref &squot;%s&squot;&quot;
comma
id|o-&gt;remote_ref
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|remote
op_assign
id|lookup_commit_reference
c_func
(paren
id|remote_sha1
)paren
)paren
)paren
(brace
id|die
c_func
(paren
l_string|&quot;Could not parse remote commit %s (%s)&quot;
comma
id|sha1_to_hex
c_func
(paren
id|remote_sha1
)paren
comma
id|o-&gt;remote_ref
)paren
suffix:semicolon
)brace
id|trace_printf
c_func
(paren
l_string|&quot;&bslash;tremote commit: %.7s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|remote_sha1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|local
op_logical_and
op_logical_neg
id|remote
)paren
id|die
c_func
(paren
l_string|&quot;Cannot merge empty notes ref (%s) into empty notes ref &quot;
l_string|&quot;(%s)&quot;
comma
id|o-&gt;remote_ref
comma
id|o-&gt;local_ref
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|local
)paren
(brace
multiline_comment|/* result == remote commit */
id|hashcpy
c_func
(paren
id|result_sha1
comma
id|remote_sha1
)paren
suffix:semicolon
r_goto
id|found_result
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|remote
)paren
(brace
multiline_comment|/* result == local commit */
id|hashcpy
c_func
(paren
id|result_sha1
comma
id|local_sha1
)paren
suffix:semicolon
r_goto
id|found_result
suffix:semicolon
)brace
m_assert
(paren
id|local
op_logical_and
id|remote
)paren
suffix:semicolon
multiline_comment|/* Find merge bases */
id|bases
op_assign
id|get_merge_bases
c_func
(paren
id|local
comma
id|remote
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bases
)paren
(brace
id|base_sha1
op_assign
id|null_sha1
suffix:semicolon
id|base_tree_sha1
op_assign
(paren
r_int
r_char
op_star
)paren
id|EMPTY_TREE_SHA1_BIN
suffix:semicolon
id|OUTPUT
c_func
(paren
id|o
comma
l_int|4
comma
l_string|&quot;No merge base found; doing history-less merge&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|bases-&gt;next
)paren
(brace
id|base_sha1
op_assign
id|bases-&gt;item-&gt;object.sha1
suffix:semicolon
id|base_tree_sha1
op_assign
id|bases-&gt;item-&gt;tree-&gt;object.sha1
suffix:semicolon
id|OUTPUT
c_func
(paren
id|o
comma
l_int|4
comma
l_string|&quot;One merge base found (%.7s)&quot;
comma
id|sha1_to_hex
c_func
(paren
id|base_sha1
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* TODO: How to handle multiple merge-bases? */
id|base_sha1
op_assign
id|bases-&gt;item-&gt;object.sha1
suffix:semicolon
id|base_tree_sha1
op_assign
id|bases-&gt;item-&gt;tree-&gt;object.sha1
suffix:semicolon
id|OUTPUT
c_func
(paren
id|o
comma
l_int|3
comma
l_string|&quot;Multiple merge bases found. Using the first &quot;
l_string|&quot;(%.7s)&quot;
comma
id|sha1_to_hex
c_func
(paren
id|base_sha1
)paren
)paren
suffix:semicolon
)brace
id|OUTPUT
c_func
(paren
id|o
comma
l_int|4
comma
l_string|&quot;Merging remote commit %.7s into local commit %.7s with &quot;
l_string|&quot;merge-base %.7s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|remote-&gt;object.sha1
)paren
comma
id|sha1_to_hex
c_func
(paren
id|local-&gt;object.sha1
)paren
comma
id|sha1_to_hex
c_func
(paren
id|base_sha1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hashcmp
c_func
(paren
id|remote-&gt;object.sha1
comma
id|base_sha1
)paren
)paren
(brace
multiline_comment|/* Already merged; result == local commit */
id|OUTPUT
c_func
(paren
id|o
comma
l_int|2
comma
l_string|&quot;Already up-to-date!&quot;
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|result_sha1
comma
id|local-&gt;object.sha1
)paren
suffix:semicolon
r_goto
id|found_result
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|hashcmp
c_func
(paren
id|local-&gt;object.sha1
comma
id|base_sha1
)paren
)paren
(brace
multiline_comment|/* Fast-forward; result == remote commit */
id|OUTPUT
c_func
(paren
id|o
comma
l_int|2
comma
l_string|&quot;Fast-forward&quot;
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|result_sha1
comma
id|remote-&gt;object.sha1
)paren
suffix:semicolon
r_goto
id|found_result
suffix:semicolon
)brace
id|result
op_assign
id|merge_from_diffs
c_func
(paren
id|o
comma
id|base_tree_sha1
comma
id|local-&gt;tree-&gt;object.sha1
comma
id|remote-&gt;tree-&gt;object.sha1
comma
id|local_tree
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OG
l_int|0
)paren
(brace
multiline_comment|/* successful non-trivial merge */
multiline_comment|/* Commit result */
r_struct
id|commit_list
op_star
id|parents
op_assign
l_int|NULL
suffix:semicolon
id|commit_list_insert
c_func
(paren
id|remote
comma
op_amp
id|parents
)paren
suffix:semicolon
multiline_comment|/* LIFO order */
id|commit_list_insert
c_func
(paren
id|local
comma
op_amp
id|parents
)paren
suffix:semicolon
id|create_notes_commit
c_func
(paren
id|local_tree
comma
id|parents
comma
id|o-&gt;commit_msg
comma
id|result_sha1
)paren
suffix:semicolon
)brace
id|found_result
suffix:colon
id|free_commit_list
c_func
(paren
id|bases
)paren
suffix:semicolon
id|trace_printf
c_func
(paren
l_string|&quot;notes_merge(): result = %i, result_sha1 = %.7s&bslash;n&quot;
comma
id|result
comma
id|sha1_to_hex
c_func
(paren
id|result_sha1
)paren
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
eof
