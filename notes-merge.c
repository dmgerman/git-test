macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;commit.h&quot;
macro_line|#include &quot;refs.h&quot;
macro_line|#include &quot;diff.h&quot;
macro_line|#include &quot;diffcore.h&quot;
macro_line|#include &quot;xdiff-interface.h&quot;
macro_line|#include &quot;ll-merge.h&quot;
macro_line|#include &quot;dir.h&quot;
macro_line|#include &quot;notes.h&quot;
macro_line|#include &quot;notes-merge.h&quot;
macro_line|#include &quot;strbuf.h&quot;
DECL|struct|notes_merge_pair
r_struct
id|notes_merge_pair
(brace
DECL|member|obj
DECL|member|base
DECL|member|local
DECL|member|remote
r_int
r_char
id|obj
(braket
l_int|20
)braket
comma
id|base
(braket
l_int|20
)braket
comma
id|local
(braket
l_int|20
)braket
comma
id|remote
(braket
l_int|20
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|function|init_notes_merge_options
r_void
id|init_notes_merge_options
c_func
(paren
r_struct
id|notes_merge_options
op_star
id|o
)paren
(brace
id|memset
c_func
(paren
id|o
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|notes_merge_options
)paren
)paren
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
(paren
id|o-&gt;commit_msg
)paren
comma
l_int|0
)paren
suffix:semicolon
id|o-&gt;verbosity
op_assign
id|NOTES_MERGE_VERBOSITY_DEFAULT
suffix:semicolon
)brace
DECL|macro|OUTPUT
mdefine_line|#define OUTPUT(o, v, ...) &bslash;&n;&t;do { &bslash;&n;&t;&t;if ((o)-&gt;verbosity &gt;= (v)) { &bslash;&n;&t;&t;&t;printf(__VA_ARGS__); &bslash;&n;&t;&t;&t;puts(&quot;&quot;); &bslash;&n;&t;&t;} &bslash;&n;&t;} while (0)
DECL|function|path_to_sha1
r_static
r_int
id|path_to_sha1
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_int
r_char
op_star
id|sha1
)paren
(brace
r_char
id|hex_sha1
(braket
l_int|40
)braket
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_star
id|path
op_logical_and
id|i
OL
l_int|40
)paren
(brace
r_if
c_cond
(paren
op_star
id|path
op_ne
l_char|&squot;/&squot;
)paren
id|hex_sha1
(braket
id|i
op_increment
)braket
op_assign
op_star
id|path
suffix:semicolon
id|path
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|path
op_logical_or
id|i
op_ne
l_int|40
)paren
r_return
l_int|1
suffix:semicolon
r_return
id|get_sha1_hex
c_func
(paren
id|hex_sha1
comma
id|sha1
)paren
suffix:semicolon
)brace
DECL|function|verify_notes_filepair
r_static
r_int
id|verify_notes_filepair
c_func
(paren
r_struct
id|diff_filepair
op_star
id|p
comma
r_int
r_char
op_star
id|sha1
)paren
(brace
r_switch
c_cond
(paren
id|p-&gt;status
)paren
(brace
r_case
id|DIFF_STATUS_MODIFIED
suffix:colon
m_assert
(paren
id|p-&gt;one-&gt;mode
op_eq
id|p-&gt;two-&gt;mode
)paren
suffix:semicolon
m_assert
(paren
op_logical_neg
id|is_null_sha1
c_func
(paren
id|p-&gt;one-&gt;sha1
)paren
)paren
suffix:semicolon
m_assert
(paren
op_logical_neg
id|is_null_sha1
c_func
(paren
id|p-&gt;two-&gt;sha1
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DIFF_STATUS_ADDED
suffix:colon
m_assert
(paren
id|is_null_sha1
c_func
(paren
id|p-&gt;one-&gt;sha1
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DIFF_STATUS_DELETED
suffix:colon
m_assert
(paren
id|is_null_sha1
c_func
(paren
id|p-&gt;two-&gt;sha1
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
l_int|1
suffix:semicolon
)brace
m_assert
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|p-&gt;one-&gt;path
comma
id|p-&gt;two-&gt;path
)paren
)paren
suffix:semicolon
r_return
id|path_to_sha1
c_func
(paren
id|p-&gt;one-&gt;path
comma
id|sha1
)paren
suffix:semicolon
)brace
DECL|function|find_notes_merge_pair_pos
r_static
r_struct
id|notes_merge_pair
op_star
id|find_notes_merge_pair_pos
c_func
(paren
r_struct
id|notes_merge_pair
op_star
id|list
comma
r_int
id|len
comma
r_int
r_char
op_star
id|obj
comma
r_int
id|insert_new
comma
r_int
op_star
id|occupied
)paren
(brace
multiline_comment|/*&n;&t; * Both diff_tree_remote() and diff_tree_local() tend to process&n;&t; * merge_pairs in ascending order. Therefore, cache last returned&n;&t; * index, and search sequentially from there until the appropriate&n;&t; * position is found.&n;&t; *&n;&t; * Since inserts only happen from diff_tree_remote() (which mainly&n;&t; * _appends_), we don&squot;t care that inserting into the middle of the&n;&t; * list is expensive (using memmove()).&n;&t; */
r_static
r_int
id|last_index
suffix:semicolon
r_int
id|i
op_assign
id|last_index
OL
id|len
ques
c_cond
id|last_index
suffix:colon
id|len
l_int|1
suffix:semicolon
r_int
id|prev_cmp
op_assign
l_int|0
comma
id|cmp
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|i
op_ge
l_int|0
op_logical_and
id|i
OL
id|len
)paren
(brace
id|cmp
op_assign
id|hashcmp
c_func
(paren
id|obj
comma
id|list
(braket
id|i
)braket
dot
id|obj
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmp
)paren
multiline_comment|/* obj belongs @ i */
r_break
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cmp
OL
l_int|0
op_logical_and
id|prev_cmp
op_le
l_int|0
)paren
multiline_comment|/* obj belongs &lt; i */
id|i
op_decrement
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cmp
OL
l_int|0
)paren
multiline_comment|/* obj belongs between i-1 and i */
r_break
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cmp
OG
l_int|0
op_logical_and
id|prev_cmp
op_ge
l_int|0
)paren
multiline_comment|/* obj belongs &gt; i */
id|i
op_increment
suffix:semicolon
r_else
multiline_comment|/* if (cmp &gt; 0) */
(brace
multiline_comment|/* obj belongs between i and i+1 */
id|i
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
id|prev_cmp
op_assign
id|cmp
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
id|i
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* obj belongs at, or immediately preceding, index i (0 &lt;= i &lt;= len) */
r_if
c_cond
(paren
op_logical_neg
id|cmp
)paren
op_star
id|occupied
op_assign
l_int|1
suffix:semicolon
r_else
(brace
op_star
id|occupied
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|insert_new
op_logical_and
id|i
OL
id|len
)paren
(brace
id|memmove
c_func
(paren
id|list
op_plus
id|i
op_plus
l_int|1
comma
id|list
op_plus
id|i
comma
(paren
id|len
id|i
)paren
op_star
r_sizeof
(paren
r_struct
id|notes_merge_pair
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|list
op_plus
id|i
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|notes_merge_pair
)paren
)paren
suffix:semicolon
)brace
)brace
id|last_index
op_assign
id|i
suffix:semicolon
r_return
id|list
op_plus
id|i
suffix:semicolon
)brace
DECL|variable|uninitialized
r_static
r_int
r_char
id|uninitialized
(braket
l_int|20
)braket
op_assign
l_string|&quot;&bslash;xff&bslash;xff&bslash;xff&bslash;xff&bslash;xff&bslash;xff&bslash;xff&bslash;xff&bslash;xff&bslash;xff&quot;
"&bslash;"
l_string|&quot;&bslash;xff&bslash;xff&bslash;xff&bslash;xff&bslash;xff&bslash;xff&bslash;xff&bslash;xff&bslash;xff&bslash;xff&quot;
suffix:semicolon
DECL|function|diff_tree_remote
r_static
r_struct
id|notes_merge_pair
op_star
id|diff_tree_remote
c_func
(paren
r_struct
id|notes_merge_options
op_star
id|o
comma
r_const
r_int
r_char
op_star
id|base
comma
r_const
r_int
r_char
op_star
id|remote
comma
r_int
op_star
id|num_changes
)paren
(brace
r_struct
id|diff_options
id|opt
suffix:semicolon
r_struct
id|notes_merge_pair
op_star
id|changes
suffix:semicolon
r_int
id|i
comma
id|len
op_assign
l_int|0
suffix:semicolon
id|trace_printf
c_func
(paren
l_string|&quot;&bslash;tdiff_tree_remote(base = %.7s, remote = %.7s)&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|base
)paren
comma
id|sha1_to_hex
c_func
(paren
id|remote
)paren
)paren
suffix:semicolon
id|diff_setup
c_func
(paren
op_amp
id|opt
)paren
suffix:semicolon
id|DIFF_OPT_SET
c_func
(paren
op_amp
id|opt
comma
id|RECURSIVE
)paren
suffix:semicolon
id|opt.output_format
op_assign
id|DIFF_FORMAT_NO_OUTPUT
suffix:semicolon
r_if
c_cond
(paren
id|diff_setup_done
c_func
(paren
op_amp
id|opt
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;diff_setup_done failed&quot;
)paren
suffix:semicolon
id|diff_tree_sha1
c_func
(paren
id|base
comma
id|remote
comma
l_string|&quot;&quot;
comma
op_amp
id|opt
)paren
suffix:semicolon
id|diffcore_std
c_func
(paren
op_amp
id|opt
)paren
suffix:semicolon
id|changes
op_assign
id|xcalloc
c_func
(paren
id|diff_queued_diff.nr
comma
r_sizeof
(paren
r_struct
id|notes_merge_pair
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|diff_queued_diff.nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|diff_filepair
op_star
id|p
op_assign
id|diff_queued_diff.queue
(braket
id|i
)braket
suffix:semicolon
r_struct
id|notes_merge_pair
op_star
id|mp
suffix:semicolon
r_int
id|occupied
suffix:semicolon
r_int
r_char
id|obj
(braket
l_int|20
)braket
suffix:semicolon
r_if
c_cond
(paren
id|verify_notes_filepair
c_func
(paren
id|p
comma
id|obj
)paren
)paren
(brace
id|trace_printf
c_func
(paren
l_string|&quot;&bslash;t&bslash;tCannot merge entry &squot;%s&squot; (%c): &quot;
l_string|&quot;%.7s -&gt; %.7s. Skipping!&bslash;n&quot;
comma
id|p-&gt;one-&gt;path
comma
id|p-&gt;status
comma
id|sha1_to_hex
c_func
(paren
id|p-&gt;one-&gt;sha1
)paren
comma
id|sha1_to_hex
c_func
(paren
id|p-&gt;two-&gt;sha1
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|mp
op_assign
id|find_notes_merge_pair_pos
c_func
(paren
id|changes
comma
id|len
comma
id|obj
comma
l_int|1
comma
op_amp
id|occupied
)paren
suffix:semicolon
r_if
c_cond
(paren
id|occupied
)paren
(brace
multiline_comment|/* We&squot;ve found an addition/deletion pair */
m_assert
(paren
op_logical_neg
id|hashcmp
c_func
(paren
id|mp-&gt;obj
comma
id|obj
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_null_sha1
c_func
(paren
id|p-&gt;one-&gt;sha1
)paren
)paren
(brace
multiline_comment|/* addition */
m_assert
(paren
id|is_null_sha1
c_func
(paren
id|mp-&gt;remote
)paren
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|mp-&gt;remote
comma
id|p-&gt;two-&gt;sha1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|is_null_sha1
c_func
(paren
id|p-&gt;two-&gt;sha1
)paren
)paren
(brace
multiline_comment|/* deletion */
m_assert
(paren
id|is_null_sha1
c_func
(paren
id|mp-&gt;base
)paren
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|mp-&gt;base
comma
id|p-&gt;one-&gt;sha1
)paren
suffix:semicolon
)brace
r_else
m_assert
(paren
op_logical_neg
l_string|&quot;Invalid existing change recorded&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|hashcpy
c_func
(paren
id|mp-&gt;obj
comma
id|obj
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|mp-&gt;base
comma
id|p-&gt;one-&gt;sha1
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|mp-&gt;local
comma
id|uninitialized
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|mp-&gt;remote
comma
id|p-&gt;two-&gt;sha1
)paren
suffix:semicolon
id|len
op_increment
suffix:semicolon
)brace
id|trace_printf
c_func
(paren
l_string|&quot;&bslash;t&bslash;tStored remote change for %s: %.7s -&gt; %.7s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|mp-&gt;obj
)paren
comma
id|sha1_to_hex
c_func
(paren
id|mp-&gt;base
)paren
comma
id|sha1_to_hex
c_func
(paren
id|mp-&gt;remote
)paren
)paren
suffix:semicolon
)brace
id|diff_flush
c_func
(paren
op_amp
id|opt
)paren
suffix:semicolon
id|diff_tree_release_paths
c_func
(paren
op_amp
id|opt
)paren
suffix:semicolon
op_star
id|num_changes
op_assign
id|len
suffix:semicolon
r_return
id|changes
suffix:semicolon
)brace
DECL|function|diff_tree_local
r_static
r_void
id|diff_tree_local
c_func
(paren
r_struct
id|notes_merge_options
op_star
id|o
comma
r_struct
id|notes_merge_pair
op_star
id|changes
comma
r_int
id|len
comma
r_const
r_int
r_char
op_star
id|base
comma
r_const
r_int
r_char
op_star
id|local
)paren
(brace
r_struct
id|diff_options
id|opt
suffix:semicolon
r_int
id|i
suffix:semicolon
id|trace_printf
c_func
(paren
l_string|&quot;&bslash;tdiff_tree_local(len = %i, base = %.7s, local = %.7s)&bslash;n&quot;
comma
id|len
comma
id|sha1_to_hex
c_func
(paren
id|base
)paren
comma
id|sha1_to_hex
c_func
(paren
id|local
)paren
)paren
suffix:semicolon
id|diff_setup
c_func
(paren
op_amp
id|opt
)paren
suffix:semicolon
id|DIFF_OPT_SET
c_func
(paren
op_amp
id|opt
comma
id|RECURSIVE
)paren
suffix:semicolon
id|opt.output_format
op_assign
id|DIFF_FORMAT_NO_OUTPUT
suffix:semicolon
r_if
c_cond
(paren
id|diff_setup_done
c_func
(paren
op_amp
id|opt
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;diff_setup_done failed&quot;
)paren
suffix:semicolon
id|diff_tree_sha1
c_func
(paren
id|base
comma
id|local
comma
l_string|&quot;&quot;
comma
op_amp
id|opt
)paren
suffix:semicolon
id|diffcore_std
c_func
(paren
op_amp
id|opt
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|diff_queued_diff.nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|diff_filepair
op_star
id|p
op_assign
id|diff_queued_diff.queue
(braket
id|i
)braket
suffix:semicolon
r_struct
id|notes_merge_pair
op_star
id|mp
suffix:semicolon
r_int
id|match
suffix:semicolon
r_int
r_char
id|obj
(braket
l_int|20
)braket
suffix:semicolon
r_if
c_cond
(paren
id|verify_notes_filepair
c_func
(paren
id|p
comma
id|obj
)paren
)paren
(brace
id|trace_printf
c_func
(paren
l_string|&quot;&bslash;t&bslash;tCannot merge entry &squot;%s&squot; (%c): &quot;
l_string|&quot;%.7s -&gt; %.7s. Skipping!&bslash;n&quot;
comma
id|p-&gt;one-&gt;path
comma
id|p-&gt;status
comma
id|sha1_to_hex
c_func
(paren
id|p-&gt;one-&gt;sha1
)paren
comma
id|sha1_to_hex
c_func
(paren
id|p-&gt;two-&gt;sha1
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|mp
op_assign
id|find_notes_merge_pair_pos
c_func
(paren
id|changes
comma
id|len
comma
id|obj
comma
l_int|0
comma
op_amp
id|match
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|match
)paren
(brace
id|trace_printf
c_func
(paren
l_string|&quot;&bslash;t&bslash;tIgnoring local-only change for %s: &quot;
l_string|&quot;%.7s -&gt; %.7s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|obj
)paren
comma
id|sha1_to_hex
c_func
(paren
id|p-&gt;one-&gt;sha1
)paren
comma
id|sha1_to_hex
c_func
(paren
id|p-&gt;two-&gt;sha1
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
m_assert
(paren
op_logical_neg
id|hashcmp
c_func
(paren
id|mp-&gt;obj
comma
id|obj
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_null_sha1
c_func
(paren
id|p-&gt;two-&gt;sha1
)paren
)paren
(brace
multiline_comment|/* deletion */
multiline_comment|/*&n;&t;&t;&t; * Either this is a true deletion (1), or it is part&n;&t;&t;&t; * of an A/D pair (2), or D/A pair (3):&n;&t;&t;&t; *&n;&t;&t;&t; * (1) mp-&gt;local is uninitialized; set it to null_sha1&n;&t;&t;&t; * (2) mp-&gt;local is not uninitialized; don&squot;t touch it&n;&t;&t;&t; * (3) mp-&gt;local is uninitialized; set it to null_sha1&n;&t;&t;&t; *     (will be overwritten by following addition)&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|hashcmp
c_func
(paren
id|mp-&gt;local
comma
id|uninitialized
)paren
)paren
id|hashclr
c_func
(paren
id|mp-&gt;local
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|is_null_sha1
c_func
(paren
id|p-&gt;one-&gt;sha1
)paren
)paren
(brace
multiline_comment|/* addition */
multiline_comment|/*&n;&t;&t;&t; * Either this is a true addition (1), or it is part&n;&t;&t;&t; * of an A/D pair (2), or D/A pair (3):&n;&t;&t;&t; *&n;&t;&t;&t; * (1) mp-&gt;local is uninitialized; set to p-&gt;two-&gt;sha1&n;&t;&t;&t; * (2) mp-&gt;local is uninitialized; set to p-&gt;two-&gt;sha1&n;&t;&t;&t; * (3) mp-&gt;local is null_sha1;     set to p-&gt;two-&gt;sha1&n;&t;&t;&t; */
m_assert
(paren
id|is_null_sha1
c_func
(paren
id|mp-&gt;local
)paren
op_logical_or
op_logical_neg
id|hashcmp
c_func
(paren
id|mp-&gt;local
comma
id|uninitialized
)paren
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|mp-&gt;local
comma
id|p-&gt;two-&gt;sha1
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* modification */
multiline_comment|/*&n;&t;&t;&t; * This is a true modification. p-&gt;one-&gt;sha1 shall&n;&t;&t;&t; * match mp-&gt;base, and mp-&gt;local shall be uninitialized.&n;&t;&t;&t; * Set mp-&gt;local to p-&gt;two-&gt;sha1.&n;&t;&t;&t; */
m_assert
(paren
op_logical_neg
id|hashcmp
c_func
(paren
id|p-&gt;one-&gt;sha1
comma
id|mp-&gt;base
)paren
)paren
suffix:semicolon
m_assert
(paren
op_logical_neg
id|hashcmp
c_func
(paren
id|mp-&gt;local
comma
id|uninitialized
)paren
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|mp-&gt;local
comma
id|p-&gt;two-&gt;sha1
)paren
suffix:semicolon
)brace
id|trace_printf
c_func
(paren
l_string|&quot;&bslash;t&bslash;tStored local change for %s: %.7s -&gt; %.7s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|mp-&gt;obj
)paren
comma
id|sha1_to_hex
c_func
(paren
id|mp-&gt;base
)paren
comma
id|sha1_to_hex
c_func
(paren
id|mp-&gt;local
)paren
)paren
suffix:semicolon
)brace
id|diff_flush
c_func
(paren
op_amp
id|opt
)paren
suffix:semicolon
id|diff_tree_release_paths
c_func
(paren
op_amp
id|opt
)paren
suffix:semicolon
)brace
DECL|function|check_notes_merge_worktree
r_static
r_void
id|check_notes_merge_worktree
c_func
(paren
r_struct
id|notes_merge_options
op_star
id|o
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|o-&gt;has_worktree
)paren
(brace
multiline_comment|/*&n;&t;&t; * Must establish NOTES_MERGE_WORKTREE.&n;&t;&t; * Abort if NOTES_MERGE_WORKTREE already exists&n;&t;&t; */
r_if
c_cond
(paren
id|file_exists
c_func
(paren
id|git_path
c_func
(paren
id|NOTES_MERGE_WORKTREE
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|advice_resolve_conflict
)paren
id|die
c_func
(paren
l_string|&quot;You have not concluded your previous &quot;
l_string|&quot;notes merge (%s exists).&bslash;nPlease, use &quot;
l_string|&quot;&squot;git notes merge --commit&squot; or &squot;git notes &quot;
l_string|&quot;merge --abort&squot; to commit/abort the &quot;
l_string|&quot;previous merge before you start a new &quot;
l_string|&quot;notes merge.&quot;
comma
id|git_path
c_func
(paren
l_string|&quot;NOTES_MERGE_*&quot;
)paren
)paren
suffix:semicolon
r_else
id|die
c_func
(paren
l_string|&quot;You have not concluded your notes merge &quot;
l_string|&quot;(%s exists).&quot;
comma
id|git_path
c_func
(paren
l_string|&quot;NOTES_MERGE_*&quot;
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|safe_create_leading_directories
c_func
(paren
id|git_path
c_func
(paren
id|NOTES_MERGE_WORKTREE
l_string|&quot;/.test&quot;
)paren
)paren
)paren
id|die_errno
c_func
(paren
l_string|&quot;unable to create directory %s&quot;
comma
id|git_path
c_func
(paren
id|NOTES_MERGE_WORKTREE
)paren
)paren
suffix:semicolon
id|o-&gt;has_worktree
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|file_exists
c_func
(paren
id|git_path
c_func
(paren
id|NOTES_MERGE_WORKTREE
)paren
)paren
)paren
multiline_comment|/* NOTES_MERGE_WORKTREE should already be established */
id|die
c_func
(paren
l_string|&quot;missing &squot;%s&squot;. This should not happen&quot;
comma
id|git_path
c_func
(paren
id|NOTES_MERGE_WORKTREE
)paren
)paren
suffix:semicolon
)brace
DECL|function|write_buf_to_worktree
r_static
r_void
id|write_buf_to_worktree
c_func
(paren
r_const
r_int
r_char
op_star
id|obj
comma
r_const
r_char
op_star
id|buf
comma
r_int
r_int
id|size
)paren
(brace
r_int
id|fd
suffix:semicolon
r_char
op_star
id|path
op_assign
id|git_path
c_func
(paren
id|NOTES_MERGE_WORKTREE
l_string|&quot;/%s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|obj
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|safe_create_leading_directories
c_func
(paren
id|path
)paren
)paren
id|die_errno
c_func
(paren
l_string|&quot;unable to create directory for &squot;%s&squot;&quot;
comma
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file_exists
c_func
(paren
id|path
)paren
)paren
id|die
c_func
(paren
l_string|&quot;found existing file at &squot;%s&squot;&quot;
comma
id|path
)paren
suffix:semicolon
id|fd
op_assign
id|open
c_func
(paren
id|path
comma
id|O_WRONLY
op_or
id|O_TRUNC
op_or
id|O_CREAT
comma
l_int|0666
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
id|die_errno
c_func
(paren
l_string|&quot;failed to open &squot;%s&squot;&quot;
comma
id|path
)paren
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
r_int
id|ret
op_assign
id|write_in_full
c_func
(paren
id|fd
comma
id|buf
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
multiline_comment|/* Ignore epipe */
r_if
c_cond
(paren
id|errno
op_eq
id|EPIPE
)paren
r_break
suffix:semicolon
id|die_errno
c_func
(paren
l_string|&quot;notes-merge&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
id|die
c_func
(paren
l_string|&quot;notes-merge: disk full?&quot;
)paren
suffix:semicolon
)brace
id|size
op_sub_assign
id|ret
suffix:semicolon
id|buf
op_add_assign
id|ret
suffix:semicolon
)brace
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
)brace
DECL|function|write_note_to_worktree
r_static
r_void
id|write_note_to_worktree
c_func
(paren
r_const
r_int
r_char
op_star
id|obj
comma
r_const
r_int
r_char
op_star
id|note
)paren
(brace
r_enum
id|object_type
id|type
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_void
op_star
id|buf
op_assign
id|read_sha1_file
c_func
(paren
id|note
comma
op_amp
id|type
comma
op_amp
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
id|die
c_func
(paren
l_string|&quot;cannot read note %s for object %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|note
)paren
comma
id|sha1_to_hex
c_func
(paren
id|obj
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
id|OBJ_BLOB
)paren
id|die
c_func
(paren
l_string|&quot;blob expected in note %s for object %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|note
)paren
comma
id|sha1_to_hex
c_func
(paren
id|obj
)paren
)paren
suffix:semicolon
id|write_buf_to_worktree
c_func
(paren
id|obj
comma
id|buf
comma
id|size
)paren
suffix:semicolon
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
DECL|function|ll_merge_in_worktree
r_static
r_int
id|ll_merge_in_worktree
c_func
(paren
r_struct
id|notes_merge_options
op_star
id|o
comma
r_struct
id|notes_merge_pair
op_star
id|p
)paren
(brace
id|mmbuffer_t
id|result_buf
suffix:semicolon
id|mmfile_t
id|base
comma
id|local
comma
id|remote
suffix:semicolon
r_int
id|status
suffix:semicolon
id|read_mmblob
c_func
(paren
op_amp
id|base
comma
id|p-&gt;base
)paren
suffix:semicolon
id|read_mmblob
c_func
(paren
op_amp
id|local
comma
id|p-&gt;local
)paren
suffix:semicolon
id|read_mmblob
c_func
(paren
op_amp
id|remote
comma
id|p-&gt;remote
)paren
suffix:semicolon
id|status
op_assign
id|ll_merge
c_func
(paren
op_amp
id|result_buf
comma
id|sha1_to_hex
c_func
(paren
id|p-&gt;obj
)paren
comma
op_amp
id|base
comma
l_int|NULL
comma
op_amp
id|local
comma
id|o-&gt;local_ref
comma
op_amp
id|remote
comma
id|o-&gt;remote_ref
comma
l_int|NULL
)paren
suffix:semicolon
id|free
c_func
(paren
id|base.ptr
)paren
suffix:semicolon
id|free
c_func
(paren
id|local.ptr
)paren
suffix:semicolon
id|free
c_func
(paren
id|remote.ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
OL
l_int|0
)paren
op_logical_or
op_logical_neg
id|result_buf.ptr
)paren
id|die
c_func
(paren
l_string|&quot;Failed to execute internal merge&quot;
)paren
suffix:semicolon
id|write_buf_to_worktree
c_func
(paren
id|p-&gt;obj
comma
id|result_buf.ptr
comma
id|result_buf.size
)paren
suffix:semicolon
id|free
c_func
(paren
id|result_buf.ptr
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
DECL|function|merge_one_change_manual
r_static
r_int
id|merge_one_change_manual
c_func
(paren
r_struct
id|notes_merge_options
op_star
id|o
comma
r_struct
id|notes_merge_pair
op_star
id|p
comma
r_struct
id|notes_tree
op_star
id|t
)paren
(brace
r_const
r_char
op_star
id|lref
op_assign
id|o-&gt;local_ref
ques
c_cond
id|o-&gt;local_ref
suffix:colon
l_string|&quot;local version&quot;
suffix:semicolon
r_const
r_char
op_star
id|rref
op_assign
id|o-&gt;remote_ref
ques
c_cond
id|o-&gt;remote_ref
suffix:colon
l_string|&quot;remote version&quot;
suffix:semicolon
id|trace_printf
c_func
(paren
l_string|&quot;&bslash;t&bslash;t&bslash;tmerge_one_change_manual(obj = %.7s, base = %.7s, &quot;
l_string|&quot;local = %.7s, remote = %.7s)&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|p-&gt;obj
)paren
comma
id|sha1_to_hex
c_func
(paren
id|p-&gt;base
)paren
comma
id|sha1_to_hex
c_func
(paren
id|p-&gt;local
)paren
comma
id|sha1_to_hex
c_func
(paren
id|p-&gt;remote
)paren
)paren
suffix:semicolon
multiline_comment|/* add &quot;Conflicts:&quot; section to commit message first time through */
r_if
c_cond
(paren
op_logical_neg
id|o-&gt;has_worktree
)paren
id|strbuf_addstr
c_func
(paren
op_amp
(paren
id|o-&gt;commit_msg
)paren
comma
l_string|&quot;&bslash;n&bslash;nConflicts:&bslash;n&quot;
)paren
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
(paren
id|o-&gt;commit_msg
)paren
comma
l_string|&quot;&bslash;t%s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|p-&gt;obj
)paren
)paren
suffix:semicolon
id|OUTPUT
c_func
(paren
id|o
comma
l_int|2
comma
l_string|&quot;Auto-merging notes for %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|p-&gt;obj
)paren
)paren
suffix:semicolon
id|check_notes_merge_worktree
c_func
(paren
id|o
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_null_sha1
c_func
(paren
id|p-&gt;local
)paren
)paren
(brace
multiline_comment|/* D/F conflict, checkout p-&gt;remote */
m_assert
(paren
op_logical_neg
id|is_null_sha1
c_func
(paren
id|p-&gt;remote
)paren
)paren
suffix:semicolon
id|OUTPUT
c_func
(paren
id|o
comma
l_int|1
comma
l_string|&quot;CONFLICT (delete/modify): Notes for object %s &quot;
l_string|&quot;deleted in %s and modified in %s. Version from %s &quot;
l_string|&quot;left in tree.&quot;
comma
id|sha1_to_hex
c_func
(paren
id|p-&gt;obj
)paren
comma
id|lref
comma
id|rref
comma
id|rref
)paren
suffix:semicolon
id|write_note_to_worktree
c_func
(paren
id|p-&gt;obj
comma
id|p-&gt;remote
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|is_null_sha1
c_func
(paren
id|p-&gt;remote
)paren
)paren
(brace
multiline_comment|/* D/F conflict, checkout p-&gt;local */
m_assert
(paren
op_logical_neg
id|is_null_sha1
c_func
(paren
id|p-&gt;local
)paren
)paren
suffix:semicolon
id|OUTPUT
c_func
(paren
id|o
comma
l_int|1
comma
l_string|&quot;CONFLICT (delete/modify): Notes for object %s &quot;
l_string|&quot;deleted in %s and modified in %s. Version from %s &quot;
l_string|&quot;left in tree.&quot;
comma
id|sha1_to_hex
c_func
(paren
id|p-&gt;obj
)paren
comma
id|rref
comma
id|lref
comma
id|lref
)paren
suffix:semicolon
id|write_note_to_worktree
c_func
(paren
id|p-&gt;obj
comma
id|p-&gt;local
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* &quot;regular&quot; conflict, checkout result of ll_merge() */
r_const
r_char
op_star
id|reason
op_assign
l_string|&quot;content&quot;
suffix:semicolon
r_if
c_cond
(paren
id|is_null_sha1
c_func
(paren
id|p-&gt;base
)paren
)paren
id|reason
op_assign
l_string|&quot;add/add&quot;
suffix:semicolon
m_assert
(paren
op_logical_neg
id|is_null_sha1
c_func
(paren
id|p-&gt;local
)paren
)paren
suffix:semicolon
m_assert
(paren
op_logical_neg
id|is_null_sha1
c_func
(paren
id|p-&gt;remote
)paren
)paren
suffix:semicolon
id|OUTPUT
c_func
(paren
id|o
comma
l_int|1
comma
l_string|&quot;CONFLICT (%s): Merge conflict in notes for &quot;
l_string|&quot;object %s&quot;
comma
id|reason
comma
id|sha1_to_hex
c_func
(paren
id|p-&gt;obj
)paren
)paren
suffix:semicolon
id|ll_merge_in_worktree
c_func
(paren
id|o
comma
id|p
)paren
suffix:semicolon
)brace
id|trace_printf
c_func
(paren
l_string|&quot;&bslash;t&bslash;t&bslash;tremoving from partial merge result&bslash;n&quot;
)paren
suffix:semicolon
id|remove_note
c_func
(paren
id|t
comma
id|p-&gt;obj
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|merge_one_change
r_static
r_int
id|merge_one_change
c_func
(paren
r_struct
id|notes_merge_options
op_star
id|o
comma
r_struct
id|notes_merge_pair
op_star
id|p
comma
r_struct
id|notes_tree
op_star
id|t
)paren
(brace
multiline_comment|/*&n;&t; * Return 0 if change is successfully resolved (stored in notes_tree).&n;&t; * Return 1 is change results in a conflict (NOT stored in notes_tree,&n;&t; * but instead written to NOTES_MERGE_WORKTREE with conflict markers).&n;&t; */
r_switch
c_cond
(paren
id|o-&gt;strategy
)paren
(brace
r_case
id|NOTES_MERGE_RESOLVE_MANUAL
suffix:colon
r_return
id|merge_one_change_manual
c_func
(paren
id|o
comma
id|p
comma
id|t
)paren
suffix:semicolon
r_case
id|NOTES_MERGE_RESOLVE_OURS
suffix:colon
id|OUTPUT
c_func
(paren
id|o
comma
l_int|2
comma
l_string|&quot;Using local notes for %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|p-&gt;obj
)paren
)paren
suffix:semicolon
multiline_comment|/* nothing to do */
r_return
l_int|0
suffix:semicolon
r_case
id|NOTES_MERGE_RESOLVE_THEIRS
suffix:colon
id|OUTPUT
c_func
(paren
id|o
comma
l_int|2
comma
l_string|&quot;Using remote notes for %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|p-&gt;obj
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|add_note
c_func
(paren
id|t
comma
id|p-&gt;obj
comma
id|p-&gt;remote
comma
id|combine_notes_overwrite
)paren
)paren
id|die
c_func
(paren
l_string|&quot;BUG: combine_notes_overwrite failed&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|NOTES_MERGE_RESOLVE_UNION
suffix:colon
id|OUTPUT
c_func
(paren
id|o
comma
l_int|2
comma
l_string|&quot;Concatenating local and remote notes for %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|p-&gt;obj
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|add_note
c_func
(paren
id|t
comma
id|p-&gt;obj
comma
id|p-&gt;remote
comma
id|combine_notes_concatenate
)paren
)paren
id|die
c_func
(paren
l_string|&quot;failed to concatenate notes &quot;
l_string|&quot;(combine_notes_concatenate)&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|NOTES_MERGE_RESOLVE_CAT_SORT_UNIQ
suffix:colon
id|OUTPUT
c_func
(paren
id|o
comma
l_int|2
comma
l_string|&quot;Concatenating unique lines in local and remote &quot;
l_string|&quot;notes for %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|p-&gt;obj
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|add_note
c_func
(paren
id|t
comma
id|p-&gt;obj
comma
id|p-&gt;remote
comma
id|combine_notes_cat_sort_uniq
)paren
)paren
id|die
c_func
(paren
l_string|&quot;failed to concatenate notes &quot;
l_string|&quot;(combine_notes_cat_sort_uniq)&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|die
c_func
(paren
l_string|&quot;Unknown strategy (%i).&quot;
comma
id|o-&gt;strategy
)paren
suffix:semicolon
)brace
DECL|function|merge_changes
r_static
r_int
id|merge_changes
c_func
(paren
r_struct
id|notes_merge_options
op_star
id|o
comma
r_struct
id|notes_merge_pair
op_star
id|changes
comma
r_int
op_star
id|num_changes
comma
r_struct
id|notes_tree
op_star
id|t
)paren
(brace
r_int
id|i
comma
id|conflicts
op_assign
l_int|0
suffix:semicolon
id|trace_printf
c_func
(paren
l_string|&quot;&bslash;tmerge_changes(num_changes = %i)&bslash;n&quot;
comma
op_star
id|num_changes
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
op_star
id|num_changes
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|notes_merge_pair
op_star
id|p
op_assign
id|changes
op_plus
id|i
suffix:semicolon
id|trace_printf
c_func
(paren
l_string|&quot;&bslash;t&bslash;t%.7s: %.7s -&gt; %.7s/%.7s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|p-&gt;obj
)paren
comma
id|sha1_to_hex
c_func
(paren
id|p-&gt;base
)paren
comma
id|sha1_to_hex
c_func
(paren
id|p-&gt;local
)paren
comma
id|sha1_to_hex
c_func
(paren
id|p-&gt;remote
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hashcmp
c_func
(paren
id|p-&gt;base
comma
id|p-&gt;remote
)paren
)paren
(brace
multiline_comment|/* no remote change; nothing to do */
id|trace_printf
c_func
(paren
l_string|&quot;&bslash;t&bslash;t&bslash;tskipping (no remote change)&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|hashcmp
c_func
(paren
id|p-&gt;local
comma
id|p-&gt;remote
)paren
)paren
(brace
multiline_comment|/* same change in local and remote; nothing to do */
id|trace_printf
c_func
(paren
l_string|&quot;&bslash;t&bslash;t&bslash;tskipping (local == remote)&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|hashcmp
c_func
(paren
id|p-&gt;local
comma
id|uninitialized
)paren
op_logical_or
op_logical_neg
id|hashcmp
c_func
(paren
id|p-&gt;local
comma
id|p-&gt;base
)paren
)paren
(brace
multiline_comment|/* no local change; adopt remote change */
id|trace_printf
c_func
(paren
l_string|&quot;&bslash;t&bslash;t&bslash;tno local change, adopted remote&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|add_note
c_func
(paren
id|t
comma
id|p-&gt;obj
comma
id|p-&gt;remote
comma
id|combine_notes_overwrite
)paren
)paren
id|die
c_func
(paren
l_string|&quot;BUG: combine_notes_overwrite failed&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* need file-level merge between local and remote */
id|trace_printf
c_func
(paren
l_string|&quot;&bslash;t&bslash;t&bslash;tneed content-level merge&bslash;n&quot;
)paren
suffix:semicolon
id|conflicts
op_add_assign
id|merge_one_change
c_func
(paren
id|o
comma
id|p
comma
id|t
)paren
suffix:semicolon
)brace
)brace
r_return
id|conflicts
suffix:semicolon
)brace
DECL|function|merge_from_diffs
r_static
r_int
id|merge_from_diffs
c_func
(paren
r_struct
id|notes_merge_options
op_star
id|o
comma
r_const
r_int
r_char
op_star
id|base
comma
r_const
r_int
r_char
op_star
id|local
comma
r_const
r_int
r_char
op_star
id|remote
comma
r_struct
id|notes_tree
op_star
id|t
)paren
(brace
r_struct
id|notes_merge_pair
op_star
id|changes
suffix:semicolon
r_int
id|num_changes
comma
id|conflicts
suffix:semicolon
id|trace_printf
c_func
(paren
l_string|&quot;&bslash;tmerge_from_diffs(base = %.7s, local = %.7s, &quot;
l_string|&quot;remote = %.7s)&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|base
)paren
comma
id|sha1_to_hex
c_func
(paren
id|local
)paren
comma
id|sha1_to_hex
c_func
(paren
id|remote
)paren
)paren
suffix:semicolon
id|changes
op_assign
id|diff_tree_remote
c_func
(paren
id|o
comma
id|base
comma
id|remote
comma
op_amp
id|num_changes
)paren
suffix:semicolon
id|diff_tree_local
c_func
(paren
id|o
comma
id|changes
comma
id|num_changes
comma
id|base
comma
id|local
)paren
suffix:semicolon
id|conflicts
op_assign
id|merge_changes
c_func
(paren
id|o
comma
id|changes
comma
op_amp
id|num_changes
comma
id|t
)paren
suffix:semicolon
id|free
c_func
(paren
id|changes
)paren
suffix:semicolon
id|OUTPUT
c_func
(paren
id|o
comma
l_int|4
comma
l_string|&quot;Merge result: %i unmerged notes and a %s notes tree&quot;
comma
id|conflicts
comma
id|t-&gt;dirty
ques
c_cond
l_string|&quot;dirty&quot;
suffix:colon
l_string|&quot;clean&quot;
)paren
suffix:semicolon
r_return
id|conflicts
ques
c_cond
l_int|1
suffix:colon
l_int|1
suffix:semicolon
)brace
DECL|function|create_notes_commit
r_void
id|create_notes_commit
c_func
(paren
r_struct
id|notes_tree
op_star
id|t
comma
r_struct
id|commit_list
op_star
id|parents
comma
r_const
r_char
op_star
id|msg
comma
r_int
r_char
op_star
id|result_sha1
)paren
(brace
r_int
r_char
id|tree_sha1
(braket
l_int|20
)braket
suffix:semicolon
m_assert
(paren
id|t-&gt;initialized
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write_notes_tree
c_func
(paren
id|t
comma
id|tree_sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Failed to write notes tree to database&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parents
)paren
(brace
multiline_comment|/* Deduce parent commit from t-&gt;ref */
r_int
r_char
id|parent_sha1
(braket
l_int|20
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|read_ref
c_func
(paren
id|t-&gt;ref
comma
id|parent_sha1
)paren
)paren
(brace
r_struct
id|commit
op_star
id|parent
op_assign
id|lookup_commit
c_func
(paren
id|parent_sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parent
op_logical_or
id|parse_commit
c_func
(paren
id|parent
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Failed to find/parse commit %s&quot;
comma
id|t-&gt;ref
)paren
suffix:semicolon
id|commit_list_insert
c_func
(paren
id|parent
comma
op_amp
id|parents
)paren
suffix:semicolon
)brace
multiline_comment|/* else: t-&gt;ref points to nothing, assume root/orphan commit */
)brace
r_if
c_cond
(paren
id|commit_tree
c_func
(paren
id|msg
comma
id|tree_sha1
comma
id|parents
comma
id|result_sha1
comma
l_int|NULL
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Failed to commit notes tree to database&quot;
)paren
suffix:semicolon
)brace
DECL|function|notes_merge
r_int
id|notes_merge
c_func
(paren
r_struct
id|notes_merge_options
op_star
id|o
comma
r_struct
id|notes_tree
op_star
id|local_tree
comma
r_int
r_char
op_star
id|result_sha1
)paren
(brace
r_int
r_char
id|local_sha1
(braket
l_int|20
)braket
comma
id|remote_sha1
(braket
l_int|20
)braket
suffix:semicolon
r_struct
id|commit
op_star
id|local
comma
op_star
id|remote
suffix:semicolon
r_struct
id|commit_list
op_star
id|bases
op_assign
l_int|NULL
suffix:semicolon
r_const
r_int
r_char
op_star
id|base_sha1
comma
op_star
id|base_tree_sha1
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
m_assert
(paren
id|o-&gt;local_ref
op_logical_and
id|o-&gt;remote_ref
)paren
suffix:semicolon
m_assert
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|o-&gt;local_ref
comma
id|local_tree-&gt;ref
)paren
)paren
suffix:semicolon
id|hashclr
c_func
(paren
id|result_sha1
)paren
suffix:semicolon
id|trace_printf
c_func
(paren
l_string|&quot;notes_merge(o-&gt;local_ref = %s, o-&gt;remote_ref = %s)&bslash;n&quot;
comma
id|o-&gt;local_ref
comma
id|o-&gt;remote_ref
)paren
suffix:semicolon
multiline_comment|/* Dereference o-&gt;local_ref into local_sha1 */
r_if
c_cond
(paren
id|read_ref_full
c_func
(paren
id|o-&gt;local_ref
comma
id|local_sha1
comma
l_int|0
comma
l_int|NULL
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Failed to resolve local notes ref &squot;%s&squot;&quot;
comma
id|o-&gt;local_ref
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|check_refname_format
c_func
(paren
id|o-&gt;local_ref
comma
l_int|0
)paren
op_logical_and
id|is_null_sha1
c_func
(paren
id|local_sha1
)paren
)paren
id|local
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* local_sha1 == null_sha1 indicates unborn ref */
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|local
op_assign
id|lookup_commit_reference
c_func
(paren
id|local_sha1
)paren
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Could not parse local commit %s (%s)&quot;
comma
id|sha1_to_hex
c_func
(paren
id|local_sha1
)paren
comma
id|o-&gt;local_ref
)paren
suffix:semicolon
id|trace_printf
c_func
(paren
l_string|&quot;&bslash;tlocal commit: %.7s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|local_sha1
)paren
)paren
suffix:semicolon
multiline_comment|/* Dereference o-&gt;remote_ref into remote_sha1 */
r_if
c_cond
(paren
id|get_sha1
c_func
(paren
id|o-&gt;remote_ref
comma
id|remote_sha1
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Failed to get remote_sha1. If o-&gt;remote_ref looks like an&n;&t;&t; * unborn ref, perform the merge using an empty notes tree.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|check_refname_format
c_func
(paren
id|o-&gt;remote_ref
comma
l_int|0
)paren
)paren
(brace
id|hashclr
c_func
(paren
id|remote_sha1
)paren
suffix:semicolon
id|remote
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|die
c_func
(paren
l_string|&quot;Failed to resolve remote notes ref &squot;%s&squot;&quot;
comma
id|o-&gt;remote_ref
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|remote
op_assign
id|lookup_commit_reference
c_func
(paren
id|remote_sha1
)paren
)paren
)paren
(brace
id|die
c_func
(paren
l_string|&quot;Could not parse remote commit %s (%s)&quot;
comma
id|sha1_to_hex
c_func
(paren
id|remote_sha1
)paren
comma
id|o-&gt;remote_ref
)paren
suffix:semicolon
)brace
id|trace_printf
c_func
(paren
l_string|&quot;&bslash;tremote commit: %.7s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|remote_sha1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|local
op_logical_and
op_logical_neg
id|remote
)paren
id|die
c_func
(paren
l_string|&quot;Cannot merge empty notes ref (%s) into empty notes ref &quot;
l_string|&quot;(%s)&quot;
comma
id|o-&gt;remote_ref
comma
id|o-&gt;local_ref
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|local
)paren
(brace
multiline_comment|/* result == remote commit */
id|hashcpy
c_func
(paren
id|result_sha1
comma
id|remote_sha1
)paren
suffix:semicolon
r_goto
id|found_result
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|remote
)paren
(brace
multiline_comment|/* result == local commit */
id|hashcpy
c_func
(paren
id|result_sha1
comma
id|local_sha1
)paren
suffix:semicolon
r_goto
id|found_result
suffix:semicolon
)brace
m_assert
(paren
id|local
op_logical_and
id|remote
)paren
suffix:semicolon
multiline_comment|/* Find merge bases */
id|bases
op_assign
id|get_merge_bases
c_func
(paren
id|local
comma
id|remote
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bases
)paren
(brace
id|base_sha1
op_assign
id|null_sha1
suffix:semicolon
id|base_tree_sha1
op_assign
id|EMPTY_TREE_SHA1_BIN
suffix:semicolon
id|OUTPUT
c_func
(paren
id|o
comma
l_int|4
comma
l_string|&quot;No merge base found; doing history-less merge&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|bases-&gt;next
)paren
(brace
id|base_sha1
op_assign
id|bases-&gt;item-&gt;object.sha1
suffix:semicolon
id|base_tree_sha1
op_assign
id|bases-&gt;item-&gt;tree-&gt;object.sha1
suffix:semicolon
id|OUTPUT
c_func
(paren
id|o
comma
l_int|4
comma
l_string|&quot;One merge base found (%.7s)&quot;
comma
id|sha1_to_hex
c_func
(paren
id|base_sha1
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* TODO: How to handle multiple merge-bases? */
id|base_sha1
op_assign
id|bases-&gt;item-&gt;object.sha1
suffix:semicolon
id|base_tree_sha1
op_assign
id|bases-&gt;item-&gt;tree-&gt;object.sha1
suffix:semicolon
id|OUTPUT
c_func
(paren
id|o
comma
l_int|3
comma
l_string|&quot;Multiple merge bases found. Using the first &quot;
l_string|&quot;(%.7s)&quot;
comma
id|sha1_to_hex
c_func
(paren
id|base_sha1
)paren
)paren
suffix:semicolon
)brace
id|OUTPUT
c_func
(paren
id|o
comma
l_int|4
comma
l_string|&quot;Merging remote commit %.7s into local commit %.7s with &quot;
l_string|&quot;merge-base %.7s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|remote-&gt;object.sha1
)paren
comma
id|sha1_to_hex
c_func
(paren
id|local-&gt;object.sha1
)paren
comma
id|sha1_to_hex
c_func
(paren
id|base_sha1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hashcmp
c_func
(paren
id|remote-&gt;object.sha1
comma
id|base_sha1
)paren
)paren
(brace
multiline_comment|/* Already merged; result == local commit */
id|OUTPUT
c_func
(paren
id|o
comma
l_int|2
comma
l_string|&quot;Already up-to-date!&quot;
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|result_sha1
comma
id|local-&gt;object.sha1
)paren
suffix:semicolon
r_goto
id|found_result
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|hashcmp
c_func
(paren
id|local-&gt;object.sha1
comma
id|base_sha1
)paren
)paren
(brace
multiline_comment|/* Fast-forward; result == remote commit */
id|OUTPUT
c_func
(paren
id|o
comma
l_int|2
comma
l_string|&quot;Fast-forward&quot;
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|result_sha1
comma
id|remote-&gt;object.sha1
)paren
suffix:semicolon
r_goto
id|found_result
suffix:semicolon
)brace
id|result
op_assign
id|merge_from_diffs
c_func
(paren
id|o
comma
id|base_tree_sha1
comma
id|local-&gt;tree-&gt;object.sha1
comma
id|remote-&gt;tree-&gt;object.sha1
comma
id|local_tree
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
l_int|0
)paren
(brace
multiline_comment|/* non-trivial merge (with or without conflicts) */
multiline_comment|/* Commit (partial) result */
r_struct
id|commit_list
op_star
id|parents
op_assign
l_int|NULL
suffix:semicolon
id|commit_list_insert
c_func
(paren
id|remote
comma
op_amp
id|parents
)paren
suffix:semicolon
multiline_comment|/* LIFO order */
id|commit_list_insert
c_func
(paren
id|local
comma
op_amp
id|parents
)paren
suffix:semicolon
id|create_notes_commit
c_func
(paren
id|local_tree
comma
id|parents
comma
id|o-&gt;commit_msg.buf
comma
id|result_sha1
)paren
suffix:semicolon
)brace
id|found_result
suffix:colon
id|free_commit_list
c_func
(paren
id|bases
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
(paren
id|o-&gt;commit_msg
)paren
)paren
suffix:semicolon
id|trace_printf
c_func
(paren
l_string|&quot;notes_merge(): result = %i, result_sha1 = %.7s&bslash;n&quot;
comma
id|result
comma
id|sha1_to_hex
c_func
(paren
id|result_sha1
)paren
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|notes_merge_commit
r_int
id|notes_merge_commit
c_func
(paren
r_struct
id|notes_merge_options
op_star
id|o
comma
r_struct
id|notes_tree
op_star
id|partial_tree
comma
r_struct
id|commit
op_star
id|partial_commit
comma
r_int
r_char
op_star
id|result_sha1
)paren
(brace
multiline_comment|/*&n;&t; * Iterate through files in .git/NOTES_MERGE_WORKTREE and add all&n;&t; * found notes to &squot;partial_tree&squot;. Write the updates notes tree to&n;&t; * the DB, and commit the resulting tree object while reusing the&n;&t; * commit message and parents from &squot;partial_commit&squot;.&n;&t; * Finally store the new commit object SHA1 into &squot;result_sha1&squot;.&n;&t; */
r_struct
id|dir_struct
id|dir
suffix:semicolon
r_char
op_star
id|path
op_assign
id|xstrdup
c_func
(paren
id|git_path
c_func
(paren
id|NOTES_MERGE_WORKTREE
l_string|&quot;/&quot;
)paren
)paren
suffix:semicolon
r_int
id|path_len
op_assign
id|strlen
c_func
(paren
id|path
)paren
comma
id|i
suffix:semicolon
r_const
r_char
op_star
id|msg
op_assign
id|strstr
c_func
(paren
id|partial_commit-&gt;buffer
comma
l_string|&quot;&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
id|OUTPUT
c_func
(paren
id|o
comma
l_int|3
comma
l_string|&quot;Committing notes in notes merge worktree at %.*s&quot;
comma
id|path_len
l_int|1
comma
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|msg
op_logical_or
id|msg
(braket
l_int|2
)braket
op_eq
l_char|&squot;&bslash;0&squot;
)paren
id|die
c_func
(paren
l_string|&quot;partial notes commit has empty message&quot;
)paren
suffix:semicolon
id|msg
op_add_assign
l_int|2
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|dir
comma
l_int|0
comma
r_sizeof
(paren
id|dir
)paren
)paren
suffix:semicolon
id|read_directory
c_func
(paren
op_amp
id|dir
comma
id|path
comma
id|path_len
comma
l_int|NULL
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dir.nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|dir_entry
op_star
id|ent
op_assign
id|dir.entries
(braket
id|i
)braket
suffix:semicolon
r_struct
id|stat
id|st
suffix:semicolon
r_const
r_char
op_star
id|relpath
op_assign
id|ent-&gt;name
op_plus
id|path_len
suffix:semicolon
r_int
r_char
id|obj_sha1
(braket
l_int|20
)braket
comma
id|blob_sha1
(braket
l_int|20
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ent-&gt;len
id|path_len
op_ne
l_int|40
op_logical_or
id|get_sha1_hex
c_func
(paren
id|relpath
comma
id|obj_sha1
)paren
)paren
(brace
id|OUTPUT
c_func
(paren
id|o
comma
l_int|3
comma
l_string|&quot;Skipping non-SHA1 entry &squot;%s&squot;&quot;
comma
id|ent-&gt;name
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* write file as blob, and add to partial_tree */
r_if
c_cond
(paren
id|stat
c_func
(paren
id|ent-&gt;name
comma
op_amp
id|st
)paren
)paren
id|die_errno
c_func
(paren
l_string|&quot;Failed to stat &squot;%s&squot;&quot;
comma
id|ent-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index_path
c_func
(paren
id|blob_sha1
comma
id|ent-&gt;name
comma
op_amp
id|st
comma
id|HASH_WRITE_OBJECT
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Failed to write blob object from &squot;%s&squot;&quot;
comma
id|ent-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|add_note
c_func
(paren
id|partial_tree
comma
id|obj_sha1
comma
id|blob_sha1
comma
l_int|NULL
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Failed to add resolved note &squot;%s&squot; to notes tree&quot;
comma
id|ent-&gt;name
)paren
suffix:semicolon
id|OUTPUT
c_func
(paren
id|o
comma
l_int|4
comma
l_string|&quot;Added resolved note for object %s: %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|obj_sha1
)paren
comma
id|sha1_to_hex
c_func
(paren
id|blob_sha1
)paren
)paren
suffix:semicolon
)brace
id|create_notes_commit
c_func
(paren
id|partial_tree
comma
id|partial_commit-&gt;parents
comma
id|msg
comma
id|result_sha1
)paren
suffix:semicolon
id|OUTPUT
c_func
(paren
id|o
comma
l_int|4
comma
l_string|&quot;Finalized notes merge commit: %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|result_sha1
)paren
)paren
suffix:semicolon
id|free
c_func
(paren
id|path
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|notes_merge_abort
r_int
id|notes_merge_abort
c_func
(paren
r_struct
id|notes_merge_options
op_star
id|o
)paren
(brace
multiline_comment|/* Remove .git/NOTES_MERGE_WORKTREE directory and all files within */
r_struct
id|strbuf
id|buf
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|buf
comma
id|git_path
c_func
(paren
id|NOTES_MERGE_WORKTREE
)paren
)paren
suffix:semicolon
id|OUTPUT
c_func
(paren
id|o
comma
l_int|3
comma
l_string|&quot;Removing notes merge worktree at %s&quot;
comma
id|buf.buf
)paren
suffix:semicolon
id|ret
op_assign
id|remove_dir_recursively
c_func
(paren
op_amp
id|buf
comma
l_int|0
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|buf
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
eof
