macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;commit.h&quot;
macro_line|#include &quot;refs.h&quot;
macro_line|#include &quot;notes-merge.h&quot;
DECL|function|init_notes_merge_options
r_void
id|init_notes_merge_options
c_func
(paren
r_struct
id|notes_merge_options
op_star
id|o
)paren
(brace
id|memset
c_func
(paren
id|o
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|notes_merge_options
)paren
)paren
suffix:semicolon
id|o-&gt;verbosity
op_assign
id|NOTES_MERGE_VERBOSITY_DEFAULT
suffix:semicolon
)brace
DECL|macro|OUTPUT
mdefine_line|#define OUTPUT(o, v, ...) &bslash;&n;&t;do { &bslash;&n;&t;&t;if ((o)-&gt;verbosity &gt;= (v)) { &bslash;&n;&t;&t;&t;printf(__VA_ARGS__); &bslash;&n;&t;&t;&t;puts(&quot;&quot;); &bslash;&n;&t;&t;} &bslash;&n;&t;} while (0)
DECL|function|notes_merge
r_int
id|notes_merge
c_func
(paren
r_struct
id|notes_merge_options
op_star
id|o
comma
r_int
r_char
op_star
id|result_sha1
)paren
(brace
r_int
r_char
id|local_sha1
(braket
l_int|20
)braket
comma
id|remote_sha1
(braket
l_int|20
)braket
suffix:semicolon
r_struct
id|commit
op_star
id|local
comma
op_star
id|remote
suffix:semicolon
r_struct
id|commit_list
op_star
id|bases
op_assign
l_int|NULL
suffix:semicolon
r_const
r_int
r_char
op_star
id|base_sha1
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
m_assert
(paren
id|o-&gt;local_ref
op_logical_and
id|o-&gt;remote_ref
)paren
suffix:semicolon
id|hashclr
c_func
(paren
id|result_sha1
)paren
suffix:semicolon
id|trace_printf
c_func
(paren
l_string|&quot;notes_merge(o-&gt;local_ref = %s, o-&gt;remote_ref = %s)&bslash;n&quot;
comma
id|o-&gt;local_ref
comma
id|o-&gt;remote_ref
)paren
suffix:semicolon
multiline_comment|/* Dereference o-&gt;local_ref into local_sha1 */
r_if
c_cond
(paren
op_logical_neg
id|resolve_ref
c_func
(paren
id|o-&gt;local_ref
comma
id|local_sha1
comma
l_int|0
comma
l_int|NULL
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Failed to resolve local notes ref &squot;%s&squot;&quot;
comma
id|o-&gt;local_ref
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|check_ref_format
c_func
(paren
id|o-&gt;local_ref
)paren
op_logical_and
id|is_null_sha1
c_func
(paren
id|local_sha1
)paren
)paren
id|local
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* local_sha1 == null_sha1 indicates unborn ref */
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|local
op_assign
id|lookup_commit_reference
c_func
(paren
id|local_sha1
)paren
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Could not parse local commit %s (%s)&quot;
comma
id|sha1_to_hex
c_func
(paren
id|local_sha1
)paren
comma
id|o-&gt;local_ref
)paren
suffix:semicolon
id|trace_printf
c_func
(paren
l_string|&quot;&bslash;tlocal commit: %.7s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|local_sha1
)paren
)paren
suffix:semicolon
multiline_comment|/* Dereference o-&gt;remote_ref into remote_sha1 */
r_if
c_cond
(paren
id|get_sha1
c_func
(paren
id|o-&gt;remote_ref
comma
id|remote_sha1
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Failed to get remote_sha1. If o-&gt;remote_ref looks like an&n;&t;&t; * unborn ref, perform the merge using an empty notes tree.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|check_ref_format
c_func
(paren
id|o-&gt;remote_ref
)paren
)paren
(brace
id|hashclr
c_func
(paren
id|remote_sha1
)paren
suffix:semicolon
id|remote
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|die
c_func
(paren
l_string|&quot;Failed to resolve remote notes ref &squot;%s&squot;&quot;
comma
id|o-&gt;remote_ref
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|remote
op_assign
id|lookup_commit_reference
c_func
(paren
id|remote_sha1
)paren
)paren
)paren
(brace
id|die
c_func
(paren
l_string|&quot;Could not parse remote commit %s (%s)&quot;
comma
id|sha1_to_hex
c_func
(paren
id|remote_sha1
)paren
comma
id|o-&gt;remote_ref
)paren
suffix:semicolon
)brace
id|trace_printf
c_func
(paren
l_string|&quot;&bslash;tremote commit: %.7s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|remote_sha1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|local
op_logical_and
op_logical_neg
id|remote
)paren
id|die
c_func
(paren
l_string|&quot;Cannot merge empty notes ref (%s) into empty notes ref &quot;
l_string|&quot;(%s)&quot;
comma
id|o-&gt;remote_ref
comma
id|o-&gt;local_ref
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|local
)paren
(brace
multiline_comment|/* result == remote commit */
id|hashcpy
c_func
(paren
id|result_sha1
comma
id|remote_sha1
)paren
suffix:semicolon
r_goto
id|found_result
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|remote
)paren
(brace
multiline_comment|/* result == local commit */
id|hashcpy
c_func
(paren
id|result_sha1
comma
id|local_sha1
)paren
suffix:semicolon
r_goto
id|found_result
suffix:semicolon
)brace
m_assert
(paren
id|local
op_logical_and
id|remote
)paren
suffix:semicolon
multiline_comment|/* Find merge bases */
id|bases
op_assign
id|get_merge_bases
c_func
(paren
id|local
comma
id|remote
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bases
)paren
(brace
id|base_sha1
op_assign
id|null_sha1
suffix:semicolon
id|OUTPUT
c_func
(paren
id|o
comma
l_int|4
comma
l_string|&quot;No merge base found; doing history-less merge&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|bases-&gt;next
)paren
(brace
id|base_sha1
op_assign
id|bases-&gt;item-&gt;object.sha1
suffix:semicolon
id|OUTPUT
c_func
(paren
id|o
comma
l_int|4
comma
l_string|&quot;One merge base found (%.7s)&quot;
comma
id|sha1_to_hex
c_func
(paren
id|base_sha1
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* TODO: How to handle multiple merge-bases? */
id|base_sha1
op_assign
id|bases-&gt;item-&gt;object.sha1
suffix:semicolon
id|OUTPUT
c_func
(paren
id|o
comma
l_int|3
comma
l_string|&quot;Multiple merge bases found. Using the first &quot;
l_string|&quot;(%.7s)&quot;
comma
id|sha1_to_hex
c_func
(paren
id|base_sha1
)paren
)paren
suffix:semicolon
)brace
id|OUTPUT
c_func
(paren
id|o
comma
l_int|4
comma
l_string|&quot;Merging remote commit %.7s into local commit %.7s with &quot;
l_string|&quot;merge-base %.7s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|remote-&gt;object.sha1
)paren
comma
id|sha1_to_hex
c_func
(paren
id|local-&gt;object.sha1
)paren
comma
id|sha1_to_hex
c_func
(paren
id|base_sha1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hashcmp
c_func
(paren
id|remote-&gt;object.sha1
comma
id|base_sha1
)paren
)paren
(brace
multiline_comment|/* Already merged; result == local commit */
id|OUTPUT
c_func
(paren
id|o
comma
l_int|2
comma
l_string|&quot;Already up-to-date!&quot;
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|result_sha1
comma
id|local-&gt;object.sha1
)paren
suffix:semicolon
r_goto
id|found_result
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|hashcmp
c_func
(paren
id|local-&gt;object.sha1
comma
id|base_sha1
)paren
)paren
(brace
multiline_comment|/* Fast-forward; result == remote commit */
id|OUTPUT
c_func
(paren
id|o
comma
l_int|2
comma
l_string|&quot;Fast-forward&quot;
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|result_sha1
comma
id|remote-&gt;object.sha1
)paren
suffix:semicolon
r_goto
id|found_result
suffix:semicolon
)brace
multiline_comment|/* TODO: */
id|result
op_assign
id|error
c_func
(paren
l_string|&quot;notes_merge() cannot yet handle real merges.&quot;
)paren
suffix:semicolon
id|found_result
suffix:colon
id|free_commit_list
c_func
(paren
id|bases
)paren
suffix:semicolon
id|trace_printf
c_func
(paren
l_string|&quot;notes_merge(): result = %i, result_sha1 = %.7s&bslash;n&quot;
comma
id|result
comma
id|sha1_to_hex
c_func
(paren
id|result_sha1
)paren
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
eof
