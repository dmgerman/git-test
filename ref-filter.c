macro_line|#include &quot;builtin.h&quot;
macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;parse-options.h&quot;
macro_line|#include &quot;refs.h&quot;
macro_line|#include &quot;wildmatch.h&quot;
macro_line|#include &quot;commit.h&quot;
macro_line|#include &quot;remote.h&quot;
macro_line|#include &quot;color.h&quot;
macro_line|#include &quot;tag.h&quot;
macro_line|#include &quot;quote.h&quot;
macro_line|#include &quot;ref-filter.h&quot;
macro_line|#include &quot;revision.h&quot;
macro_line|#include &quot;utf8.h&quot;
macro_line|#include &quot;git-compat-util.h&quot;
macro_line|#include &quot;version.h&quot;
DECL|enumerator|FIELD_STR
DECL|enumerator|FIELD_ULONG
DECL|enumerator|FIELD_TIME
DECL|typedef|cmp_type
r_typedef
r_enum
(brace
id|FIELD_STR
comma
id|FIELD_ULONG
comma
id|FIELD_TIME
)brace
id|cmp_type
suffix:semicolon
r_static
r_struct
(brace
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
DECL|member|cmp_type
id|cmp_type
id|cmp_type
suffix:semicolon
DECL|variable|valid_atom
)brace
id|valid_atom
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;refname&quot;
)brace
comma
(brace
l_string|&quot;objecttype&quot;
)brace
comma
(brace
l_string|&quot;objectsize&quot;
comma
id|FIELD_ULONG
)brace
comma
(brace
l_string|&quot;objectname&quot;
)brace
comma
(brace
l_string|&quot;tree&quot;
)brace
comma
(brace
l_string|&quot;parent&quot;
)brace
comma
(brace
l_string|&quot;numparent&quot;
comma
id|FIELD_ULONG
)brace
comma
(brace
l_string|&quot;object&quot;
)brace
comma
(brace
l_string|&quot;type&quot;
)brace
comma
(brace
l_string|&quot;tag&quot;
)brace
comma
(brace
l_string|&quot;author&quot;
)brace
comma
(brace
l_string|&quot;authorname&quot;
)brace
comma
(brace
l_string|&quot;authoremail&quot;
)brace
comma
(brace
l_string|&quot;authordate&quot;
comma
id|FIELD_TIME
)brace
comma
(brace
l_string|&quot;committer&quot;
)brace
comma
(brace
l_string|&quot;committername&quot;
)brace
comma
(brace
l_string|&quot;committeremail&quot;
)brace
comma
(brace
l_string|&quot;committerdate&quot;
comma
id|FIELD_TIME
)brace
comma
(brace
l_string|&quot;tagger&quot;
)brace
comma
(brace
l_string|&quot;taggername&quot;
)brace
comma
(brace
l_string|&quot;taggeremail&quot;
)brace
comma
(brace
l_string|&quot;taggerdate&quot;
comma
id|FIELD_TIME
)brace
comma
(brace
l_string|&quot;creator&quot;
)brace
comma
(brace
l_string|&quot;creatordate&quot;
comma
id|FIELD_TIME
)brace
comma
(brace
l_string|&quot;subject&quot;
)brace
comma
(brace
l_string|&quot;body&quot;
)brace
comma
(brace
l_string|&quot;contents&quot;
)brace
comma
(brace
l_string|&quot;upstream&quot;
)brace
comma
(brace
l_string|&quot;push&quot;
)brace
comma
(brace
l_string|&quot;symref&quot;
)brace
comma
(brace
l_string|&quot;flag&quot;
)brace
comma
(brace
l_string|&quot;HEAD&quot;
)brace
comma
(brace
l_string|&quot;color&quot;
)brace
comma
(brace
l_string|&quot;align&quot;
)brace
comma
(brace
l_string|&quot;end&quot;
)brace
comma
)brace
suffix:semicolon
DECL|macro|REF_FORMATTING_STATE_INIT
mdefine_line|#define REF_FORMATTING_STATE_INIT  { 0, NULL }
DECL|struct|align
r_struct
id|align
(brace
DECL|member|position
id|align_type
id|position
suffix:semicolon
DECL|member|width
r_int
r_int
id|width
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|contents
r_struct
id|contents
(brace
DECL|member|lines
r_int
r_int
id|lines
suffix:semicolon
DECL|member|oid
r_struct
id|object_id
id|oid
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|ref_formatting_stack
r_struct
id|ref_formatting_stack
(brace
DECL|member|prev
r_struct
id|ref_formatting_stack
op_star
id|prev
suffix:semicolon
DECL|member|output
r_struct
id|strbuf
id|output
suffix:semicolon
DECL|member|at_end
r_void
(paren
op_star
id|at_end
)paren
(paren
r_struct
id|ref_formatting_stack
op_star
id|stack
)paren
suffix:semicolon
DECL|member|at_end_data
r_void
op_star
id|at_end_data
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|ref_formatting_state
r_struct
id|ref_formatting_state
(brace
DECL|member|quote_style
r_int
id|quote_style
suffix:semicolon
DECL|member|stack
r_struct
id|ref_formatting_stack
op_star
id|stack
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|atom_value
r_struct
id|atom_value
(brace
DECL|member|s
r_const
r_char
op_star
id|s
suffix:semicolon
r_union
(brace
DECL|member|align
r_struct
id|align
id|align
suffix:semicolon
DECL|member|contents
r_struct
id|contents
id|contents
suffix:semicolon
DECL|member|u
)brace
id|u
suffix:semicolon
DECL|member|handler
r_void
(paren
op_star
id|handler
)paren
(paren
r_struct
id|atom_value
op_star
id|atomv
comma
r_struct
id|ref_formatting_state
op_star
id|state
)paren
suffix:semicolon
DECL|member|ul
r_int
r_int
id|ul
suffix:semicolon
multiline_comment|/* used for sorting when not FIELD_STR */
)brace
suffix:semicolon
multiline_comment|/*&n; * An atom is a valid field atom listed above, possibly prefixed with&n; * a &quot;*&quot; to denote deref_tag().&n; *&n; * We parse given format string and sort specifiers, and make a list&n; * of properties that we need to extract out of objects.  ref_array_item&n; * structure will hold an array of values extracted that can be&n; * indexed with the &quot;atom number&quot;, which is an index into this&n; * array.&n; */
DECL|variable|used_atom
r_static
r_const
r_char
op_star
op_star
id|used_atom
suffix:semicolon
DECL|variable|used_atom_type
r_static
id|cmp_type
op_star
id|used_atom_type
suffix:semicolon
DECL|variable|used_atom_cnt
DECL|variable|need_tagged
DECL|variable|need_symref
r_static
r_int
id|used_atom_cnt
comma
id|need_tagged
comma
id|need_symref
suffix:semicolon
DECL|variable|need_color_reset_at_eol
r_static
r_int
id|need_color_reset_at_eol
suffix:semicolon
multiline_comment|/*&n; * Used to parse format string and sort specifiers&n; */
DECL|function|parse_ref_filter_atom
r_int
id|parse_ref_filter_atom
c_func
(paren
r_const
r_char
op_star
id|atom
comma
r_const
r_char
op_star
id|ep
)paren
(brace
r_const
r_char
op_star
id|sp
suffix:semicolon
r_int
id|i
comma
id|at
suffix:semicolon
id|sp
op_assign
id|atom
suffix:semicolon
r_if
c_cond
(paren
op_star
id|sp
op_eq
l_char|&squot;*&squot;
op_logical_and
id|sp
OL
id|ep
)paren
id|sp
op_increment
suffix:semicolon
multiline_comment|/* deref */
r_if
c_cond
(paren
id|ep
op_le
id|sp
)paren
id|die
c_func
(paren
l_string|&quot;malformed field name: %.*s&quot;
comma
(paren
r_int
)paren
(paren
id|ep
op_minus
id|atom
)paren
comma
id|atom
)paren
suffix:semicolon
multiline_comment|/* Do we have the atom already used elsewhere? */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|used_atom_cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|used_atom
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
id|ep
id|atom
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|used_atom
(braket
id|i
)braket
comma
id|atom
comma
id|len
)paren
)paren
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/* Is the atom a valid one? */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|valid_atom
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|valid_atom
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the atom name has a colon, strip it and everything after&n;&t;&t; * it off - it specifies the format for this entry, and&n;&t;&t; * shouldn&squot;t be used for checking against the valid_atom&n;&t;&t; * table.&n;&t;&t; */
r_const
r_char
op_star
id|formatp
op_assign
id|strchr
c_func
(paren
id|sp
comma
l_char|&squot;:&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|formatp
op_logical_or
id|ep
OL
id|formatp
)paren
id|formatp
op_assign
id|ep
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
id|formatp
id|sp
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|valid_atom
(braket
id|i
)braket
dot
id|name
comma
id|sp
comma
id|len
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ARRAY_SIZE
c_func
(paren
id|valid_atom
)paren
op_le
id|i
)paren
id|die
c_func
(paren
l_string|&quot;unknown field name: %.*s&quot;
comma
(paren
r_int
)paren
(paren
id|ep
op_minus
id|atom
)paren
comma
id|atom
)paren
suffix:semicolon
multiline_comment|/* Add it in, including the deref prefix */
id|at
op_assign
id|used_atom_cnt
suffix:semicolon
id|used_atom_cnt
op_increment
suffix:semicolon
id|REALLOC_ARRAY
c_func
(paren
id|used_atom
comma
id|used_atom_cnt
)paren
suffix:semicolon
id|REALLOC_ARRAY
c_func
(paren
id|used_atom_type
comma
id|used_atom_cnt
)paren
suffix:semicolon
id|used_atom
(braket
id|at
)braket
op_assign
id|xmemdupz
c_func
(paren
id|atom
comma
id|ep
id|atom
)paren
suffix:semicolon
id|used_atom_type
(braket
id|at
)braket
op_assign
id|valid_atom
(braket
id|i
)braket
dot
id|cmp_type
suffix:semicolon
r_if
c_cond
(paren
op_star
id|atom
op_eq
l_char|&squot;*&squot;
)paren
id|need_tagged
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|used_atom
(braket
id|at
)braket
comma
l_string|&quot;symref&quot;
)paren
)paren
id|need_symref
op_assign
l_int|1
suffix:semicolon
r_return
id|at
suffix:semicolon
)brace
DECL|function|quote_formatting
r_static
r_void
id|quote_formatting
c_func
(paren
r_struct
id|strbuf
op_star
id|s
comma
r_const
r_char
op_star
id|str
comma
r_int
id|quote_style
)paren
(brace
r_switch
c_cond
(paren
id|quote_style
)paren
(brace
r_case
id|QUOTE_NONE
suffix:colon
id|strbuf_addstr
c_func
(paren
id|s
comma
id|str
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QUOTE_SHELL
suffix:colon
id|sq_quote_buf
c_func
(paren
id|s
comma
id|str
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QUOTE_PERL
suffix:colon
id|perl_quote_buf
c_func
(paren
id|s
comma
id|str
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QUOTE_PYTHON
suffix:colon
id|python_quote_buf
c_func
(paren
id|s
comma
id|str
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QUOTE_TCL
suffix:colon
id|tcl_quote_buf
c_func
(paren
id|s
comma
id|str
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|function|append_atom
r_static
r_void
id|append_atom
c_func
(paren
r_struct
id|atom_value
op_star
id|v
comma
r_struct
id|ref_formatting_state
op_star
id|state
)paren
(brace
multiline_comment|/*&n;&t; * Quote formatting is only done when the stack has a single&n;&t; * element. Otherwise quote formatting is done on the&n;&t; * element&squot;s entire output strbuf when the %(end) atom is&n;&t; * encountered.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|state-&gt;stack-&gt;prev
)paren
id|quote_formatting
c_func
(paren
op_amp
id|state-&gt;stack-&gt;output
comma
id|v-&gt;s
comma
id|state-&gt;quote_style
)paren
suffix:semicolon
r_else
id|strbuf_addstr
c_func
(paren
op_amp
id|state-&gt;stack-&gt;output
comma
id|v-&gt;s
)paren
suffix:semicolon
)brace
DECL|function|push_stack_element
r_static
r_void
id|push_stack_element
c_func
(paren
r_struct
id|ref_formatting_stack
op_star
op_star
id|stack
)paren
(brace
r_struct
id|ref_formatting_stack
op_star
id|s
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|ref_formatting_stack
)paren
)paren
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|s-&gt;output
comma
l_int|0
)paren
suffix:semicolon
id|s-&gt;prev
op_assign
op_star
id|stack
suffix:semicolon
op_star
id|stack
op_assign
id|s
suffix:semicolon
)brace
DECL|function|pop_stack_element
r_static
r_void
id|pop_stack_element
c_func
(paren
r_struct
id|ref_formatting_stack
op_star
op_star
id|stack
)paren
(brace
r_struct
id|ref_formatting_stack
op_star
id|current
op_assign
op_star
id|stack
suffix:semicolon
r_struct
id|ref_formatting_stack
op_star
id|prev
op_assign
id|current-&gt;prev
suffix:semicolon
r_if
c_cond
(paren
id|prev
)paren
id|strbuf_addbuf
c_func
(paren
op_amp
id|prev-&gt;output
comma
op_amp
id|current-&gt;output
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|current-&gt;output
)paren
suffix:semicolon
id|free
c_func
(paren
id|current
)paren
suffix:semicolon
op_star
id|stack
op_assign
id|prev
suffix:semicolon
)brace
DECL|function|end_align_handler
r_static
r_void
id|end_align_handler
c_func
(paren
r_struct
id|ref_formatting_stack
op_star
id|stack
)paren
(brace
r_struct
id|align
op_star
id|align
op_assign
(paren
r_struct
id|align
op_star
)paren
id|stack-&gt;at_end_data
suffix:semicolon
r_struct
id|strbuf
id|s
op_assign
id|STRBUF_INIT
suffix:semicolon
id|strbuf_utf8_align
c_func
(paren
op_amp
id|s
comma
id|align-&gt;position
comma
id|align-&gt;width
comma
id|stack-&gt;output.buf
)paren
suffix:semicolon
id|strbuf_swap
c_func
(paren
op_amp
id|stack-&gt;output
comma
op_amp
id|s
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|s
)paren
suffix:semicolon
)brace
DECL|function|align_atom_handler
r_static
r_void
id|align_atom_handler
c_func
(paren
r_struct
id|atom_value
op_star
id|atomv
comma
r_struct
id|ref_formatting_state
op_star
id|state
)paren
(brace
r_struct
id|ref_formatting_stack
op_star
r_new
suffix:semicolon
id|push_stack_element
c_func
(paren
op_amp
id|state-&gt;stack
)paren
suffix:semicolon
r_new
op_assign
id|state-&gt;stack
suffix:semicolon
r_new
op_member_access_from_pointer
id|at_end
op_assign
id|end_align_handler
suffix:semicolon
r_new
op_member_access_from_pointer
id|at_end_data
op_assign
op_amp
id|atomv-&gt;u.align
suffix:semicolon
)brace
DECL|function|end_atom_handler
r_static
r_void
id|end_atom_handler
c_func
(paren
r_struct
id|atom_value
op_star
id|atomv
comma
r_struct
id|ref_formatting_state
op_star
id|state
)paren
(brace
r_struct
id|ref_formatting_stack
op_star
id|current
op_assign
id|state-&gt;stack
suffix:semicolon
r_struct
id|strbuf
id|s
op_assign
id|STRBUF_INIT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|current-&gt;at_end
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;format: %%(end) atom used without corresponding atom&quot;
)paren
)paren
suffix:semicolon
id|current
op_member_access_from_pointer
id|at_end
c_func
(paren
id|current
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Perform quote formatting when the stack element is that of&n;&t; * a supporting atom. If nested then perform quote formatting&n;&t; * only on the topmost supporting atom.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|state-&gt;stack-&gt;prev-&gt;prev
)paren
(brace
id|quote_formatting
c_func
(paren
op_amp
id|s
comma
id|current-&gt;output.buf
comma
id|state-&gt;quote_style
)paren
suffix:semicolon
id|strbuf_swap
c_func
(paren
op_amp
id|current-&gt;output
comma
op_amp
id|s
)paren
suffix:semicolon
)brace
id|strbuf_release
c_func
(paren
op_amp
id|s
)paren
suffix:semicolon
id|pop_stack_element
c_func
(paren
op_amp
id|state-&gt;stack
)paren
suffix:semicolon
)brace
DECL|function|match_atom_name
r_static
r_int
id|match_atom_name
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_const
r_char
op_star
id|atom_name
comma
r_const
r_char
op_star
op_star
id|val
)paren
(brace
r_const
r_char
op_star
id|body
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skip_prefix
c_func
(paren
id|name
comma
id|atom_name
comma
op_amp
id|body
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* doesn&squot;t even begin with &quot;atom_name&quot; */
r_if
c_cond
(paren
op_logical_neg
id|body
(braket
l_int|0
)braket
)paren
(brace
op_star
id|val
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* %(atom_name) and no customization */
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|body
(braket
l_int|0
)braket
op_ne
l_char|&squot;:&squot;
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* &quot;atom_namefoo&quot; is not &quot;atom_name&quot; or &quot;atom_name:...&quot; */
op_star
id|val
op_assign
id|body
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* &quot;atom_name:val&quot; */
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * In a format string, find the next occurrence of %(atom).&n; */
DECL|function|find_next
r_static
r_const
r_char
op_star
id|find_next
c_func
(paren
r_const
r_char
op_star
id|cp
)paren
(brace
r_while
c_loop
(paren
op_star
id|cp
)paren
(brace
r_if
c_cond
(paren
op_star
id|cp
op_eq
l_char|&squot;%&squot;
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * %( is the start of an atom;&n;&t;&t;&t; * %% is a quoted per-cent.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|cp
(braket
l_int|1
)braket
op_eq
l_char|&squot;(&squot;
)paren
r_return
id|cp
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cp
(braket
l_int|1
)braket
op_eq
l_char|&squot;%&squot;
)paren
id|cp
op_increment
suffix:semicolon
multiline_comment|/* skip over two % */
multiline_comment|/* otherwise this is a singleton, literal % */
)brace
id|cp
op_increment
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Make sure the format string is well formed, and parse out&n; * the used atoms.&n; */
DECL|function|verify_ref_format
r_int
id|verify_ref_format
c_func
(paren
r_const
r_char
op_star
id|format
)paren
(brace
r_const
r_char
op_star
id|cp
comma
op_star
id|sp
suffix:semicolon
id|need_color_reset_at_eol
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|cp
op_assign
id|format
suffix:semicolon
op_star
id|cp
op_logical_and
(paren
id|sp
op_assign
id|find_next
c_func
(paren
id|cp
)paren
)paren
suffix:semicolon
)paren
(brace
r_const
r_char
op_star
id|color
comma
op_star
id|ep
op_assign
id|strchr
c_func
(paren
id|sp
comma
l_char|&squot;)&squot;
)paren
suffix:semicolon
r_int
id|at
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ep
)paren
r_return
id|error
c_func
(paren
l_string|&quot;malformed format string %s&quot;
comma
id|sp
)paren
suffix:semicolon
multiline_comment|/* sp points at &quot;%(&quot; and ep points at the closing &quot;)&quot; */
id|at
op_assign
id|parse_ref_filter_atom
c_func
(paren
id|sp
op_plus
l_int|2
comma
id|ep
)paren
suffix:semicolon
id|cp
op_assign
id|ep
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|skip_prefix
c_func
(paren
id|used_atom
(braket
id|at
)braket
comma
l_string|&quot;color:&quot;
comma
op_amp
id|color
)paren
)paren
id|need_color_reset_at_eol
op_assign
op_logical_neg
op_logical_neg
id|strcmp
c_func
(paren
id|color
comma
l_string|&quot;reset&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Given an object name, read the object data and size, and return a&n; * &quot;struct object&quot;.  If the object data we are returning is also borrowed&n; * by the &quot;struct object&quot; representation, set *eaten as well---it is a&n; * signal from parse_object_buffer to us not to free the buffer.&n; */
DECL|function|get_obj
r_static
r_void
op_star
id|get_obj
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
comma
r_struct
id|object
op_star
op_star
id|obj
comma
r_int
r_int
op_star
id|sz
comma
r_int
op_star
id|eaten
)paren
(brace
r_enum
id|object_type
id|type
suffix:semicolon
r_void
op_star
id|buf
op_assign
id|read_sha1_file
c_func
(paren
id|sha1
comma
op_amp
id|type
comma
id|sz
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf
)paren
op_star
id|obj
op_assign
id|parse_object_buffer
c_func
(paren
id|sha1
comma
id|type
comma
op_star
id|sz
comma
id|buf
comma
id|eaten
)paren
suffix:semicolon
r_else
op_star
id|obj
op_assign
l_int|NULL
suffix:semicolon
r_return
id|buf
suffix:semicolon
)brace
DECL|function|grab_objectname
r_static
r_int
id|grab_objectname
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_struct
id|atom_value
op_star
id|v
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;objectname&quot;
)paren
)paren
(brace
r_char
op_star
id|s
op_assign
id|xmalloc
c_func
(paren
l_int|41
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|s
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
id|v-&gt;s
op_assign
id|s
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;objectname:short&quot;
)paren
)paren
(brace
id|v-&gt;s
op_assign
id|xstrdup
c_func
(paren
id|find_unique_abbrev
c_func
(paren
id|sha1
comma
id|DEFAULT_ABBREV
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* See grab_values */
DECL|function|grab_common_values
r_static
r_void
id|grab_common_values
c_func
(paren
r_struct
id|atom_value
op_star
id|val
comma
r_int
id|deref
comma
r_struct
id|object
op_star
id|obj
comma
r_void
op_star
id|buf
comma
r_int
r_int
id|sz
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|used_atom_cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_char
op_star
id|name
op_assign
id|used_atom
(braket
id|i
)braket
suffix:semicolon
r_struct
id|atom_value
op_star
id|v
op_assign
op_amp
id|val
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_logical_neg
id|deref
op_ne
(paren
op_star
id|name
op_eq
l_char|&squot;*&squot;
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|deref
)paren
id|name
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;objecttype&quot;
)paren
)paren
id|v-&gt;s
op_assign
r_typename
(paren
id|obj-&gt;type
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;objectsize&quot;
)paren
)paren
(brace
r_char
op_star
id|s
op_assign
id|xmalloc
c_func
(paren
l_int|40
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|s
comma
l_string|&quot;%lu&quot;
comma
id|sz
)paren
suffix:semicolon
id|v-&gt;ul
op_assign
id|sz
suffix:semicolon
id|v-&gt;s
op_assign
id|s
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|deref
)paren
id|grab_objectname
c_func
(paren
id|name
comma
id|obj-&gt;sha1
comma
id|v
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* See grab_values */
DECL|function|grab_tag_values
r_static
r_void
id|grab_tag_values
c_func
(paren
r_struct
id|atom_value
op_star
id|val
comma
r_int
id|deref
comma
r_struct
id|object
op_star
id|obj
comma
r_void
op_star
id|buf
comma
r_int
r_int
id|sz
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|tag
op_star
id|tag
op_assign
(paren
r_struct
id|tag
op_star
)paren
id|obj
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|used_atom_cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_char
op_star
id|name
op_assign
id|used_atom
(braket
id|i
)braket
suffix:semicolon
r_struct
id|atom_value
op_star
id|v
op_assign
op_amp
id|val
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_logical_neg
id|deref
op_ne
(paren
op_star
id|name
op_eq
l_char|&squot;*&squot;
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|deref
)paren
id|name
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;tag&quot;
)paren
)paren
id|v-&gt;s
op_assign
id|tag-&gt;tag
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;type&quot;
)paren
op_logical_and
id|tag-&gt;tagged
)paren
id|v-&gt;s
op_assign
r_typename
(paren
id|tag-&gt;tagged-&gt;type
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;object&quot;
)paren
op_logical_and
id|tag-&gt;tagged
)paren
(brace
r_char
op_star
id|s
op_assign
id|xmalloc
c_func
(paren
l_int|41
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|s
comma
id|sha1_to_hex
c_func
(paren
id|tag-&gt;tagged-&gt;sha1
)paren
)paren
suffix:semicolon
id|v-&gt;s
op_assign
id|s
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* See grab_values */
DECL|function|grab_commit_values
r_static
r_void
id|grab_commit_values
c_func
(paren
r_struct
id|atom_value
op_star
id|val
comma
r_int
id|deref
comma
r_struct
id|object
op_star
id|obj
comma
r_void
op_star
id|buf
comma
r_int
r_int
id|sz
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|commit
op_star
id|commit
op_assign
(paren
r_struct
id|commit
op_star
)paren
id|obj
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|used_atom_cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_char
op_star
id|name
op_assign
id|used_atom
(braket
id|i
)braket
suffix:semicolon
r_struct
id|atom_value
op_star
id|v
op_assign
op_amp
id|val
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_logical_neg
id|deref
op_ne
(paren
op_star
id|name
op_eq
l_char|&squot;*&squot;
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|deref
)paren
id|name
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;tree&quot;
)paren
)paren
(brace
r_char
op_star
id|s
op_assign
id|xmalloc
c_func
(paren
l_int|41
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|s
comma
id|sha1_to_hex
c_func
(paren
id|commit-&gt;tree-&gt;object.sha1
)paren
)paren
suffix:semicolon
id|v-&gt;s
op_assign
id|s
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;numparent&quot;
)paren
)paren
(brace
r_char
op_star
id|s
op_assign
id|xmalloc
c_func
(paren
l_int|40
)paren
suffix:semicolon
id|v-&gt;ul
op_assign
id|commit_list_count
c_func
(paren
id|commit-&gt;parents
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|s
comma
l_string|&quot;%lu&quot;
comma
id|v-&gt;ul
)paren
suffix:semicolon
id|v-&gt;s
op_assign
id|s
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;parent&quot;
)paren
)paren
(brace
r_int
id|num
op_assign
id|commit_list_count
c_func
(paren
id|commit-&gt;parents
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|commit_list
op_star
id|parents
suffix:semicolon
r_char
op_star
id|s
op_assign
id|xmalloc
c_func
(paren
l_int|41
op_star
id|num
op_plus
l_int|1
)paren
suffix:semicolon
id|v-&gt;s
op_assign
id|s
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|parents
op_assign
id|commit-&gt;parents
suffix:semicolon
id|parents
suffix:semicolon
id|parents
op_assign
id|parents-&gt;next
comma
id|i
op_assign
id|i
op_plus
l_int|41
)paren
(brace
r_struct
id|commit
op_star
id|parent
op_assign
id|parents-&gt;item
suffix:semicolon
id|strcpy
c_func
(paren
id|s
op_plus
id|i
comma
id|sha1_to_hex
c_func
(paren
id|parent-&gt;object.sha1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parents-&gt;next
)paren
id|s
(braket
id|i
op_plus
l_int|40
)braket
op_assign
l_char|&squot; &squot;
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
op_star
id|s
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
)brace
)brace
DECL|function|find_wholine
r_static
r_const
r_char
op_star
id|find_wholine
c_func
(paren
r_const
r_char
op_star
id|who
comma
r_int
id|wholen
comma
r_const
r_char
op_star
id|buf
comma
r_int
r_int
id|sz
)paren
(brace
r_const
r_char
op_star
id|eol
suffix:semicolon
r_while
c_loop
(paren
op_star
id|buf
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|buf
comma
id|who
comma
id|wholen
)paren
op_logical_and
id|buf
(braket
id|wholen
)braket
op_eq
l_char|&squot; &squot;
)paren
r_return
id|buf
op_plus
id|wholen
op_plus
l_int|1
suffix:semicolon
id|eol
op_assign
id|strchr
c_func
(paren
id|buf
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|eol
)paren
r_return
l_string|&quot;&quot;
suffix:semicolon
id|eol
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|eol
op_eq
l_char|&squot;&bslash;n&squot;
)paren
r_return
l_string|&quot;&quot;
suffix:semicolon
multiline_comment|/* end of header */
id|buf
op_assign
id|eol
suffix:semicolon
)brace
r_return
l_string|&quot;&quot;
suffix:semicolon
)brace
DECL|function|copy_line
r_static
r_const
r_char
op_star
id|copy_line
c_func
(paren
r_const
r_char
op_star
id|buf
)paren
(brace
r_const
r_char
op_star
id|eol
op_assign
id|strchrnul
c_func
(paren
id|buf
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_return
id|xmemdupz
c_func
(paren
id|buf
comma
id|eol
id|buf
)paren
suffix:semicolon
)brace
DECL|function|copy_name
r_static
r_const
r_char
op_star
id|copy_name
c_func
(paren
r_const
r_char
op_star
id|buf
)paren
(brace
r_const
r_char
op_star
id|cp
suffix:semicolon
r_for
c_loop
(paren
id|cp
op_assign
id|buf
suffix:semicolon
op_star
id|cp
op_logical_and
op_star
id|cp
op_ne
l_char|&squot;&bslash;n&squot;
suffix:semicolon
id|cp
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|cp
comma
l_string|&quot; &lt;&quot;
comma
l_int|2
)paren
)paren
r_return
id|xmemdupz
c_func
(paren
id|buf
comma
id|cp
id|buf
)paren
suffix:semicolon
)brace
r_return
l_string|&quot;&quot;
suffix:semicolon
)brace
DECL|function|copy_email
r_static
r_const
r_char
op_star
id|copy_email
c_func
(paren
r_const
r_char
op_star
id|buf
)paren
(brace
r_const
r_char
op_star
id|email
op_assign
id|strchr
c_func
(paren
id|buf
comma
l_char|&squot;&lt;&squot;
)paren
suffix:semicolon
r_const
r_char
op_star
id|eoemail
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|email
)paren
r_return
l_string|&quot;&quot;
suffix:semicolon
id|eoemail
op_assign
id|strchr
c_func
(paren
id|email
comma
l_char|&squot;&gt;&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|eoemail
)paren
r_return
l_string|&quot;&quot;
suffix:semicolon
r_return
id|xmemdupz
c_func
(paren
id|email
comma
id|eoemail
op_plus
l_int|1
id|email
)paren
suffix:semicolon
)brace
DECL|function|copy_subject
r_static
r_char
op_star
id|copy_subject
c_func
(paren
r_const
r_char
op_star
id|buf
comma
r_int
r_int
id|len
)paren
(brace
r_char
op_star
id|r
op_assign
id|xmemdupz
c_func
(paren
id|buf
comma
id|len
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|r
(braket
id|i
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|r
(braket
id|i
)braket
op_assign
l_char|&squot; &squot;
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
DECL|function|grab_date
r_static
r_void
id|grab_date
c_func
(paren
r_const
r_char
op_star
id|buf
comma
r_struct
id|atom_value
op_star
id|v
comma
r_const
r_char
op_star
id|atomname
)paren
(brace
r_const
r_char
op_star
id|eoemail
op_assign
id|strstr
c_func
(paren
id|buf
comma
l_string|&quot;&gt; &quot;
)paren
suffix:semicolon
r_char
op_star
id|zone
suffix:semicolon
r_int
r_int
id|timestamp
suffix:semicolon
r_int
id|tz
suffix:semicolon
r_struct
id|date_mode
id|date_mode
op_assign
(brace
id|DATE_NORMAL
)brace
suffix:semicolon
r_const
r_char
op_star
id|formatp
suffix:semicolon
multiline_comment|/*&n;&t; * We got here because atomname ends in &quot;date&quot; or &quot;date&lt;something&gt;&quot;;&n;&t; * it&squot;s not possible that &lt;something&gt; is not &quot;:&lt;format&gt;&quot; because&n;&t; * parse_ref_filter_atom() wouldn&squot;t have allowed it, so we can assume that no&n;&t; * &quot;:&quot; means no format is specified, and use the default.&n;&t; */
id|formatp
op_assign
id|strchr
c_func
(paren
id|atomname
comma
l_char|&squot;:&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|formatp
op_ne
l_int|NULL
)paren
(brace
id|formatp
op_increment
suffix:semicolon
id|parse_date_format
c_func
(paren
id|formatp
comma
op_amp
id|date_mode
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|eoemail
)paren
r_goto
id|bad
suffix:semicolon
id|timestamp
op_assign
id|strtoul
c_func
(paren
id|eoemail
op_plus
l_int|2
comma
op_amp
id|zone
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timestamp
op_eq
id|ULONG_MAX
)paren
r_goto
id|bad
suffix:semicolon
id|tz
op_assign
id|strtol
c_func
(paren
id|zone
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tz
op_eq
id|LONG_MIN
op_logical_or
id|tz
op_eq
id|LONG_MAX
)paren
op_logical_and
id|errno
op_eq
id|ERANGE
)paren
r_goto
id|bad
suffix:semicolon
id|v-&gt;s
op_assign
id|xstrdup
c_func
(paren
id|show_date
c_func
(paren
id|timestamp
comma
id|tz
comma
op_amp
id|date_mode
)paren
)paren
suffix:semicolon
id|v-&gt;ul
op_assign
id|timestamp
suffix:semicolon
r_return
suffix:semicolon
id|bad
suffix:colon
id|v-&gt;s
op_assign
l_string|&quot;&quot;
suffix:semicolon
id|v-&gt;ul
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* See grab_values */
DECL|function|grab_person
r_static
r_void
id|grab_person
c_func
(paren
r_const
r_char
op_star
id|who
comma
r_struct
id|atom_value
op_star
id|val
comma
r_int
id|deref
comma
r_struct
id|object
op_star
id|obj
comma
r_void
op_star
id|buf
comma
r_int
r_int
id|sz
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|wholen
op_assign
id|strlen
c_func
(paren
id|who
)paren
suffix:semicolon
r_const
r_char
op_star
id|wholine
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|used_atom_cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_char
op_star
id|name
op_assign
id|used_atom
(braket
id|i
)braket
suffix:semicolon
r_struct
id|atom_value
op_star
id|v
op_assign
op_amp
id|val
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_logical_neg
id|deref
op_ne
(paren
op_star
id|name
op_eq
l_char|&squot;*&squot;
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|deref
)paren
id|name
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|who
comma
id|name
comma
id|wholen
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|name
(braket
id|wholen
)braket
op_ne
l_int|0
op_logical_and
id|strcmp
c_func
(paren
id|name
op_plus
id|wholen
comma
l_string|&quot;name&quot;
)paren
op_logical_and
id|strcmp
c_func
(paren
id|name
op_plus
id|wholen
comma
l_string|&quot;email&quot;
)paren
op_logical_and
op_logical_neg
id|starts_with
c_func
(paren
id|name
op_plus
id|wholen
comma
l_string|&quot;date&quot;
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wholine
)paren
id|wholine
op_assign
id|find_wholine
c_func
(paren
id|who
comma
id|wholen
comma
id|buf
comma
id|sz
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wholine
)paren
r_return
suffix:semicolon
multiline_comment|/* no point looking for it */
r_if
c_cond
(paren
id|name
(braket
id|wholen
)braket
op_eq
l_int|0
)paren
id|v-&gt;s
op_assign
id|copy_line
c_func
(paren
id|wholine
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
op_plus
id|wholen
comma
l_string|&quot;name&quot;
)paren
)paren
id|v-&gt;s
op_assign
id|copy_name
c_func
(paren
id|wholine
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
op_plus
id|wholen
comma
l_string|&quot;email&quot;
)paren
)paren
id|v-&gt;s
op_assign
id|copy_email
c_func
(paren
id|wholine
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|name
op_plus
id|wholen
comma
l_string|&quot;date&quot;
)paren
)paren
id|grab_date
c_func
(paren
id|wholine
comma
id|v
comma
id|name
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * For a tag or a commit object, if &quot;creator&quot; or &quot;creatordate&quot; is&n;&t; * requested, do something special.&n;&t; */
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|who
comma
l_string|&quot;tagger&quot;
)paren
op_logical_and
id|strcmp
c_func
(paren
id|who
comma
l_string|&quot;committer&quot;
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* &quot;author&quot; for commit object is not wanted */
r_if
c_cond
(paren
op_logical_neg
id|wholine
)paren
id|wholine
op_assign
id|find_wholine
c_func
(paren
id|who
comma
id|wholen
comma
id|buf
comma
id|sz
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wholine
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|used_atom_cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_char
op_star
id|name
op_assign
id|used_atom
(braket
id|i
)braket
suffix:semicolon
r_struct
id|atom_value
op_star
id|v
op_assign
op_amp
id|val
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_logical_neg
id|deref
op_ne
(paren
op_star
id|name
op_eq
l_char|&squot;*&squot;
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|deref
)paren
id|name
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|name
comma
l_string|&quot;creatordate&quot;
)paren
)paren
id|grab_date
c_func
(paren
id|wholine
comma
id|v
comma
id|name
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;creator&quot;
)paren
)paren
id|v-&gt;s
op_assign
id|copy_line
c_func
(paren
id|wholine
)paren
suffix:semicolon
)brace
)brace
DECL|function|find_subpos
r_static
r_void
id|find_subpos
c_func
(paren
r_const
r_char
op_star
id|buf
comma
r_int
r_int
id|sz
comma
r_const
r_char
op_star
op_star
id|sub
comma
r_int
r_int
op_star
id|sublen
comma
r_const
r_char
op_star
op_star
id|body
comma
r_int
r_int
op_star
id|bodylen
comma
r_int
r_int
op_star
id|nonsiglen
comma
r_const
r_char
op_star
op_star
id|sig
comma
r_int
r_int
op_star
id|siglen
)paren
(brace
r_const
r_char
op_star
id|eol
suffix:semicolon
multiline_comment|/* skip past header until we hit empty line */
r_while
c_loop
(paren
op_star
id|buf
op_logical_and
op_star
id|buf
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|eol
op_assign
id|strchrnul
c_func
(paren
id|buf
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|eol
)paren
id|eol
op_increment
suffix:semicolon
id|buf
op_assign
id|eol
suffix:semicolon
)brace
multiline_comment|/* skip any empty lines */
r_while
c_loop
(paren
op_star
id|buf
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|buf
op_increment
suffix:semicolon
multiline_comment|/* parse signature first; we might not even have a subject line */
op_star
id|sig
op_assign
id|buf
op_plus
id|parse_signature
c_func
(paren
id|buf
comma
id|strlen
c_func
(paren
id|buf
)paren
)paren
suffix:semicolon
op_star
id|siglen
op_assign
id|strlen
c_func
(paren
op_star
id|sig
)paren
suffix:semicolon
multiline_comment|/* subject is first non-empty line */
op_star
id|sub
op_assign
id|buf
suffix:semicolon
multiline_comment|/* subject goes to first empty line */
r_while
c_loop
(paren
id|buf
OL
op_star
id|sig
op_logical_and
op_star
id|buf
op_logical_and
op_star
id|buf
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|eol
op_assign
id|strchrnul
c_func
(paren
id|buf
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|eol
)paren
id|eol
op_increment
suffix:semicolon
id|buf
op_assign
id|eol
suffix:semicolon
)brace
op_star
id|sublen
op_assign
id|buf
op_star
id|sub
suffix:semicolon
multiline_comment|/* drop trailing newline, if present */
r_if
c_cond
(paren
op_star
id|sublen
op_logical_and
(paren
op_star
id|sub
)paren
(braket
op_star
id|sublen
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
op_star
id|sublen
op_sub_assign
l_int|1
suffix:semicolon
multiline_comment|/* skip any empty lines */
r_while
c_loop
(paren
op_star
id|buf
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|buf
op_increment
suffix:semicolon
op_star
id|body
op_assign
id|buf
suffix:semicolon
op_star
id|bodylen
op_assign
id|strlen
c_func
(paren
id|buf
)paren
suffix:semicolon
op_star
id|nonsiglen
op_assign
op_star
id|sig
id|buf
suffix:semicolon
)brace
multiline_comment|/*&n; * If &squot;lines&squot; is greater than 0, append that many lines from the given&n; * &squot;buf&squot; of length &squot;size&squot; to the given strbuf.&n; */
DECL|function|append_lines
r_static
r_void
id|append_lines
c_func
(paren
r_struct
id|strbuf
op_star
id|out
comma
r_const
r_char
op_star
id|buf
comma
r_int
r_int
id|size
comma
r_int
id|lines
)paren
(brace
r_int
id|i
suffix:semicolon
r_const
r_char
op_star
id|sp
comma
op_star
id|eol
suffix:semicolon
r_int
id|len
suffix:semicolon
id|sp
op_assign
id|buf
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lines
op_logical_and
id|sp
OL
id|buf
op_plus
id|size
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
)paren
id|strbuf_addstr
c_func
(paren
id|out
comma
l_string|&quot;&bslash;n    &quot;
)paren
suffix:semicolon
id|eol
op_assign
id|memchr
c_func
(paren
id|sp
comma
l_char|&squot;&bslash;n&squot;
comma
id|size
(paren
id|sp
id|buf
)paren
)paren
suffix:semicolon
id|len
op_assign
id|eol
ques
c_cond
id|eol
id|sp
suffix:colon
id|size
(paren
id|sp
id|buf
)paren
suffix:semicolon
id|strbuf_add
c_func
(paren
id|out
comma
id|sp
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|eol
)paren
r_break
suffix:semicolon
id|sp
op_assign
id|eol
op_plus
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* See grab_values */
DECL|function|grab_sub_body_contents
r_static
r_void
id|grab_sub_body_contents
c_func
(paren
r_struct
id|atom_value
op_star
id|val
comma
r_int
id|deref
comma
r_struct
id|object
op_star
id|obj
comma
r_void
op_star
id|buf
comma
r_int
r_int
id|sz
)paren
(brace
r_int
id|i
suffix:semicolon
r_const
r_char
op_star
id|subpos
op_assign
l_int|NULL
comma
op_star
id|bodypos
op_assign
l_int|NULL
comma
op_star
id|sigpos
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|sublen
op_assign
l_int|0
comma
id|bodylen
op_assign
l_int|0
comma
id|nonsiglen
op_assign
l_int|0
comma
id|siglen
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|used_atom_cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_char
op_star
id|name
op_assign
id|used_atom
(braket
id|i
)braket
suffix:semicolon
r_struct
id|atom_value
op_star
id|v
op_assign
op_amp
id|val
(braket
id|i
)braket
suffix:semicolon
r_const
r_char
op_star
id|valp
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_logical_neg
id|deref
op_ne
(paren
op_star
id|name
op_eq
l_char|&squot;*&squot;
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|deref
)paren
id|name
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;subject&quot;
)paren
op_logical_and
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;body&quot;
)paren
op_logical_and
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;contents&quot;
)paren
op_logical_and
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;contents:subject&quot;
)paren
op_logical_and
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;contents:body&quot;
)paren
op_logical_and
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;contents:signature&quot;
)paren
op_logical_and
op_logical_neg
id|starts_with
c_func
(paren
id|name
comma
l_string|&quot;contents:lines=&quot;
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|subpos
)paren
id|find_subpos
c_func
(paren
id|buf
comma
id|sz
comma
op_amp
id|subpos
comma
op_amp
id|sublen
comma
op_amp
id|bodypos
comma
op_amp
id|bodylen
comma
op_amp
id|nonsiglen
comma
op_amp
id|sigpos
comma
op_amp
id|siglen
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;subject&quot;
)paren
)paren
id|v-&gt;s
op_assign
id|copy_subject
c_func
(paren
id|subpos
comma
id|sublen
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;contents:subject&quot;
)paren
)paren
id|v-&gt;s
op_assign
id|copy_subject
c_func
(paren
id|subpos
comma
id|sublen
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;body&quot;
)paren
)paren
id|v-&gt;s
op_assign
id|xmemdupz
c_func
(paren
id|bodypos
comma
id|bodylen
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;contents:body&quot;
)paren
)paren
id|v-&gt;s
op_assign
id|xmemdupz
c_func
(paren
id|bodypos
comma
id|nonsiglen
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;contents:signature&quot;
)paren
)paren
id|v-&gt;s
op_assign
id|xmemdupz
c_func
(paren
id|sigpos
comma
id|siglen
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;contents&quot;
)paren
)paren
id|v-&gt;s
op_assign
id|xstrdup
c_func
(paren
id|subpos
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|skip_prefix
c_func
(paren
id|name
comma
l_string|&quot;contents:lines=&quot;
comma
op_amp
id|valp
)paren
)paren
(brace
r_struct
id|strbuf
id|s
op_assign
id|STRBUF_INIT
suffix:semicolon
r_const
r_char
op_star
id|contents_end
op_assign
id|bodylen
op_plus
id|bodypos
id|siglen
suffix:semicolon
r_if
c_cond
(paren
id|strtoul_ui
c_func
(paren
id|valp
comma
l_int|10
comma
op_amp
id|v-&gt;u.contents.lines
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;positive value expected contents:lines=%s&quot;
)paren
comma
id|valp
)paren
suffix:semicolon
multiline_comment|/*  Size is the length of the message after removing the signature */
id|append_lines
c_func
(paren
op_amp
id|s
comma
id|subpos
comma
id|contents_end
id|subpos
comma
id|v-&gt;u.contents.lines
)paren
suffix:semicolon
id|v-&gt;s
op_assign
id|strbuf_detach
c_func
(paren
op_amp
id|s
comma
l_int|NULL
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * We want to have empty print-string for field requests&n; * that do not apply (e.g. &quot;authordate&quot; for a tag object)&n; */
DECL|function|fill_missing_values
r_static
r_void
id|fill_missing_values
c_func
(paren
r_struct
id|atom_value
op_star
id|val
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|used_atom_cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|atom_value
op_star
id|v
op_assign
op_amp
id|val
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|v-&gt;s
op_eq
l_int|NULL
)paren
id|v-&gt;s
op_assign
l_string|&quot;&quot;
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * val is a list of atom_value to hold returned values.  Extract&n; * the values for atoms in used_atom array out of (obj, buf, sz).&n; * when deref is false, (obj, buf, sz) is the object that is&n; * pointed at by the ref itself; otherwise it is the object the&n; * ref (which is a tag) refers to.&n; */
DECL|function|grab_values
r_static
r_void
id|grab_values
c_func
(paren
r_struct
id|atom_value
op_star
id|val
comma
r_int
id|deref
comma
r_struct
id|object
op_star
id|obj
comma
r_void
op_star
id|buf
comma
r_int
r_int
id|sz
)paren
(brace
id|grab_common_values
c_func
(paren
id|val
comma
id|deref
comma
id|obj
comma
id|buf
comma
id|sz
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|obj-&gt;type
)paren
(brace
r_case
id|OBJ_TAG
suffix:colon
id|grab_tag_values
c_func
(paren
id|val
comma
id|deref
comma
id|obj
comma
id|buf
comma
id|sz
)paren
suffix:semicolon
id|grab_sub_body_contents
c_func
(paren
id|val
comma
id|deref
comma
id|obj
comma
id|buf
comma
id|sz
)paren
suffix:semicolon
id|grab_person
c_func
(paren
l_string|&quot;tagger&quot;
comma
id|val
comma
id|deref
comma
id|obj
comma
id|buf
comma
id|sz
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OBJ_COMMIT
suffix:colon
id|grab_commit_values
c_func
(paren
id|val
comma
id|deref
comma
id|obj
comma
id|buf
comma
id|sz
)paren
suffix:semicolon
id|grab_sub_body_contents
c_func
(paren
id|val
comma
id|deref
comma
id|obj
comma
id|buf
comma
id|sz
)paren
suffix:semicolon
id|grab_person
c_func
(paren
l_string|&quot;author&quot;
comma
id|val
comma
id|deref
comma
id|obj
comma
id|buf
comma
id|sz
)paren
suffix:semicolon
id|grab_person
c_func
(paren
l_string|&quot;committer&quot;
comma
id|val
comma
id|deref
comma
id|obj
comma
id|buf
comma
id|sz
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OBJ_TREE
suffix:colon
multiline_comment|/* grab_tree_values(val, deref, obj, buf, sz); */
r_break
suffix:semicolon
r_case
id|OBJ_BLOB
suffix:colon
multiline_comment|/* grab_blob_values(val, deref, obj, buf, sz); */
r_break
suffix:semicolon
r_default
suffix:colon
id|die
c_func
(paren
l_string|&quot;Eh?  Object of type %d?&quot;
comma
id|obj-&gt;type
)paren
suffix:semicolon
)brace
)brace
DECL|function|copy_advance
r_static
r_inline
r_char
op_star
id|copy_advance
c_func
(paren
r_char
op_star
id|dst
comma
r_const
r_char
op_star
id|src
)paren
(brace
r_while
c_loop
(paren
op_star
id|src
)paren
op_star
id|dst
op_increment
op_assign
op_star
id|src
op_increment
suffix:semicolon
r_return
id|dst
suffix:semicolon
)brace
multiline_comment|/*&n; * Parse the object referred by ref, and grab needed value.&n; */
DECL|function|populate_value
r_static
r_void
id|populate_value
c_func
(paren
r_struct
id|ref_array_item
op_star
id|ref
)paren
(brace
r_void
op_star
id|buf
suffix:semicolon
r_struct
id|object
op_star
id|obj
suffix:semicolon
r_int
id|eaten
comma
id|i
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_const
r_int
r_char
op_star
id|tagged
suffix:semicolon
id|ref-&gt;value
op_assign
id|xcalloc
c_func
(paren
id|used_atom_cnt
comma
r_sizeof
(paren
r_struct
id|atom_value
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|need_symref
op_logical_and
(paren
id|ref-&gt;flag
op_amp
id|REF_ISSYMREF
)paren
op_logical_and
op_logical_neg
id|ref-&gt;symref
)paren
(brace
r_int
r_char
id|unused1
(braket
l_int|20
)braket
suffix:semicolon
id|ref-&gt;symref
op_assign
id|resolve_refdup
c_func
(paren
id|ref-&gt;refname
comma
id|RESOLVE_REF_READING
comma
id|unused1
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ref-&gt;symref
)paren
id|ref-&gt;symref
op_assign
l_string|&quot;&quot;
suffix:semicolon
)brace
multiline_comment|/* Fill in specials first */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|used_atom_cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_char
op_star
id|name
op_assign
id|used_atom
(braket
id|i
)braket
suffix:semicolon
r_struct
id|atom_value
op_star
id|v
op_assign
op_amp
id|ref-&gt;value
(braket
id|i
)braket
suffix:semicolon
r_int
id|deref
op_assign
l_int|0
suffix:semicolon
r_const
r_char
op_star
id|refname
suffix:semicolon
r_const
r_char
op_star
id|formatp
suffix:semicolon
r_const
r_char
op_star
id|valp
suffix:semicolon
r_struct
id|branch
op_star
id|branch
op_assign
l_int|NULL
suffix:semicolon
id|v-&gt;handler
op_assign
id|append_atom
suffix:semicolon
r_if
c_cond
(paren
op_star
id|name
op_eq
l_char|&squot;*&squot;
)paren
(brace
id|deref
op_assign
l_int|1
suffix:semicolon
id|name
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|name
comma
l_string|&quot;refname&quot;
)paren
)paren
id|refname
op_assign
id|ref-&gt;refname
suffix:semicolon
r_else
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|name
comma
l_string|&quot;symref&quot;
)paren
)paren
id|refname
op_assign
id|ref-&gt;symref
ques
c_cond
id|ref-&gt;symref
suffix:colon
l_string|&quot;&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|name
comma
l_string|&quot;upstream&quot;
)paren
)paren
(brace
r_const
r_char
op_star
id|branch_name
suffix:semicolon
multiline_comment|/* only local branches may have an upstream */
r_if
c_cond
(paren
op_logical_neg
id|skip_prefix
c_func
(paren
id|ref-&gt;refname
comma
l_string|&quot;refs/heads/&quot;
comma
op_amp
id|branch_name
)paren
)paren
r_continue
suffix:semicolon
id|branch
op_assign
id|branch_get
c_func
(paren
id|branch_name
)paren
suffix:semicolon
id|refname
op_assign
id|branch_get_upstream
c_func
(paren
id|branch
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|refname
)paren
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|name
comma
l_string|&quot;push&quot;
)paren
)paren
(brace
r_const
r_char
op_star
id|branch_name
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skip_prefix
c_func
(paren
id|ref-&gt;refname
comma
l_string|&quot;refs/heads/&quot;
comma
op_amp
id|branch_name
)paren
)paren
r_continue
suffix:semicolon
id|branch
op_assign
id|branch_get
c_func
(paren
id|branch_name
)paren
suffix:semicolon
id|refname
op_assign
id|branch_get_push
c_func
(paren
id|branch
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|refname
)paren
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|match_atom_name
c_func
(paren
id|name
comma
l_string|&quot;color&quot;
comma
op_amp
id|valp
)paren
)paren
(brace
r_char
id|color
(braket
id|COLOR_MAXLEN
)braket
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|valp
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;expected format: %%(color:&lt;color&gt;)&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|color_parse
c_func
(paren
id|valp
comma
id|color
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;unable to parse format&quot;
)paren
)paren
suffix:semicolon
id|v-&gt;s
op_assign
id|xstrdup
c_func
(paren
id|color
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;flag&quot;
)paren
)paren
(brace
r_char
id|buf
(braket
l_int|256
)braket
comma
op_star
id|cp
op_assign
id|buf
suffix:semicolon
r_if
c_cond
(paren
id|ref-&gt;flag
op_amp
id|REF_ISSYMREF
)paren
id|cp
op_assign
id|copy_advance
c_func
(paren
id|cp
comma
l_string|&quot;,symref&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ref-&gt;flag
op_amp
id|REF_ISPACKED
)paren
id|cp
op_assign
id|copy_advance
c_func
(paren
id|cp
comma
l_string|&quot;,packed&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp
op_eq
id|buf
)paren
id|v-&gt;s
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_else
(brace
op_star
id|cp
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|v-&gt;s
op_assign
id|xstrdup
c_func
(paren
id|buf
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|deref
op_logical_and
id|grab_objectname
c_func
(paren
id|name
comma
id|ref-&gt;objectname
comma
id|v
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;HEAD&quot;
)paren
)paren
(brace
r_const
r_char
op_star
id|head
suffix:semicolon
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
id|head
op_assign
id|resolve_ref_unsafe
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|RESOLVE_REF_READING
comma
id|sha1
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|ref-&gt;refname
comma
id|head
)paren
)paren
id|v-&gt;s
op_assign
l_string|&quot;*&quot;
suffix:semicolon
r_else
id|v-&gt;s
op_assign
l_string|&quot; &quot;
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|match_atom_name
c_func
(paren
id|name
comma
l_string|&quot;align&quot;
comma
op_amp
id|valp
)paren
)paren
(brace
r_struct
id|align
op_star
id|align
op_assign
op_amp
id|v-&gt;u.align
suffix:semicolon
r_struct
id|strbuf
op_star
op_star
id|s
comma
op_star
op_star
id|to_free
suffix:semicolon
r_int
id|width
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|valp
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;expected format: %%(align:&lt;width&gt;,&lt;position&gt;)&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * TODO: Implement a function similar to strbuf_split_str()&n;&t;&t;&t; * which would omit the separator from the end of each value.&n;&t;&t;&t; */
id|s
op_assign
id|to_free
op_assign
id|strbuf_split_str
c_func
(paren
id|valp
comma
l_char|&squot;,&squot;
comma
l_int|0
)paren
suffix:semicolon
id|align-&gt;position
op_assign
id|ALIGN_LEFT
suffix:semicolon
r_while
c_loop
(paren
op_star
id|s
)paren
(brace
multiline_comment|/*  Strip trailing comma */
r_if
c_cond
(paren
id|s
(braket
l_int|1
)braket
)paren
id|strbuf_setlen
c_func
(paren
id|s
(braket
l_int|0
)braket
comma
id|s
(braket
l_int|0
)braket
op_member_access_from_pointer
id|len
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strtoul_ui
c_func
(paren
id|s
(braket
l_int|0
)braket
op_member_access_from_pointer
id|buf
comma
l_int|10
comma
(paren
r_int
r_int
op_star
)paren
op_amp
id|width
)paren
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|s
(braket
l_int|0
)braket
op_member_access_from_pointer
id|buf
comma
l_string|&quot;left&quot;
)paren
)paren
id|align-&gt;position
op_assign
id|ALIGN_LEFT
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|s
(braket
l_int|0
)braket
op_member_access_from_pointer
id|buf
comma
l_string|&quot;right&quot;
)paren
)paren
id|align-&gt;position
op_assign
id|ALIGN_RIGHT
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|s
(braket
l_int|0
)braket
op_member_access_from_pointer
id|buf
comma
l_string|&quot;middle&quot;
)paren
)paren
id|align-&gt;position
op_assign
id|ALIGN_MIDDLE
suffix:semicolon
r_else
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;improper format entered align:%s&quot;
)paren
comma
id|s
(braket
l_int|0
)braket
op_member_access_from_pointer
id|buf
)paren
suffix:semicolon
id|s
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|width
OL
l_int|0
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;positive width expected with the %%(align) atom&quot;
)paren
)paren
suffix:semicolon
id|align-&gt;width
op_assign
id|width
suffix:semicolon
id|strbuf_list_free
c_func
(paren
id|to_free
)paren
suffix:semicolon
id|v-&gt;handler
op_assign
id|align_atom_handler
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;end&quot;
)paren
)paren
(brace
id|v-&gt;handler
op_assign
id|end_atom_handler
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
r_continue
suffix:semicolon
id|formatp
op_assign
id|strchr
c_func
(paren
id|name
comma
l_char|&squot;:&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|formatp
)paren
(brace
r_int
id|num_ours
comma
id|num_theirs
suffix:semicolon
id|formatp
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|formatp
comma
l_string|&quot;short&quot;
)paren
)paren
id|refname
op_assign
id|shorten_unambiguous_ref
c_func
(paren
id|refname
comma
id|warn_ambiguous_refs
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|formatp
comma
l_string|&quot;track&quot;
)paren
op_logical_and
(paren
id|starts_with
c_func
(paren
id|name
comma
l_string|&quot;upstream&quot;
)paren
op_logical_or
id|starts_with
c_func
(paren
id|name
comma
l_string|&quot;push&quot;
)paren
)paren
)paren
(brace
r_char
id|buf
(braket
l_int|40
)braket
suffix:semicolon
r_if
c_cond
(paren
id|stat_tracking_info
c_func
(paren
id|branch
comma
op_amp
id|num_ours
comma
op_amp
id|num_theirs
comma
l_int|NULL
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|num_ours
op_logical_and
op_logical_neg
id|num_theirs
)paren
id|v-&gt;s
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|num_ours
)paren
(brace
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;[behind %d]&quot;
comma
id|num_theirs
)paren
suffix:semicolon
id|v-&gt;s
op_assign
id|xstrdup
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|num_theirs
)paren
(brace
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;[ahead %d]&quot;
comma
id|num_ours
)paren
suffix:semicolon
id|v-&gt;s
op_assign
id|xstrdup
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
r_else
(brace
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;[ahead %d, behind %d]&quot;
comma
id|num_ours
comma
id|num_theirs
)paren
suffix:semicolon
id|v-&gt;s
op_assign
id|xstrdup
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|formatp
comma
l_string|&quot;trackshort&quot;
)paren
op_logical_and
(paren
id|starts_with
c_func
(paren
id|name
comma
l_string|&quot;upstream&quot;
)paren
op_logical_or
id|starts_with
c_func
(paren
id|name
comma
l_string|&quot;push&quot;
)paren
)paren
)paren
(brace
m_assert
(paren
id|branch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat_tracking_info
c_func
(paren
id|branch
comma
op_amp
id|num_ours
comma
op_amp
id|num_theirs
comma
l_int|NULL
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|num_ours
op_logical_and
op_logical_neg
id|num_theirs
)paren
id|v-&gt;s
op_assign
l_string|&quot;=&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|num_ours
)paren
id|v-&gt;s
op_assign
l_string|&quot;&lt;&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|num_theirs
)paren
id|v-&gt;s
op_assign
l_string|&quot;&gt;&quot;
suffix:semicolon
r_else
id|v-&gt;s
op_assign
l_string|&quot;&lt;&gt;&quot;
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
id|die
c_func
(paren
l_string|&quot;unknown %.*s format %s&quot;
comma
(paren
r_int
)paren
(paren
id|formatp
id|name
)paren
comma
id|name
comma
id|formatp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|deref
)paren
id|v-&gt;s
op_assign
id|refname
suffix:semicolon
r_else
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|refname
)paren
suffix:semicolon
r_char
op_star
id|s
op_assign
id|xmalloc
c_func
(paren
id|len
op_plus
l_int|4
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|s
comma
l_string|&quot;%s^{}&quot;
comma
id|refname
)paren
suffix:semicolon
id|v-&gt;s
op_assign
id|s
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|used_atom_cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|atom_value
op_star
id|v
op_assign
op_amp
id|ref-&gt;value
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|v-&gt;s
op_eq
l_int|NULL
)paren
r_goto
id|need_obj
suffix:semicolon
)brace
r_return
suffix:semicolon
id|need_obj
suffix:colon
id|buf
op_assign
id|get_obj
c_func
(paren
id|ref-&gt;objectname
comma
op_amp
id|obj
comma
op_amp
id|size
comma
op_amp
id|eaten
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
id|die
c_func
(paren
l_string|&quot;missing object %s for %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|ref-&gt;objectname
)paren
comma
id|ref-&gt;refname
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|obj
)paren
id|die
c_func
(paren
l_string|&quot;parse_object_buffer failed on %s for %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|ref-&gt;objectname
)paren
comma
id|ref-&gt;refname
)paren
suffix:semicolon
id|grab_values
c_func
(paren
id|ref-&gt;value
comma
l_int|0
comma
id|obj
comma
id|buf
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|eaten
)paren
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If there is no atom that wants to know about tagged&n;&t; * object, we are done.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|need_tagged
op_logical_or
(paren
id|obj-&gt;type
op_ne
id|OBJ_TAG
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * If it is a tag object, see if we use a value that derefs&n;&t; * the object, and if we do grab the object it refers to.&n;&t; */
id|tagged
op_assign
(paren
(paren
r_struct
id|tag
op_star
)paren
id|obj
)paren
op_member_access_from_pointer
id|tagged-&gt;sha1
suffix:semicolon
multiline_comment|/*&n;&t; * NEEDSWORK: This derefs tag only once, which&n;&t; * is good to deal with chains of trust, but&n;&t; * is not consistent with what deref_tag() does&n;&t; * which peels the onion to the core.&n;&t; */
id|buf
op_assign
id|get_obj
c_func
(paren
id|tagged
comma
op_amp
id|obj
comma
op_amp
id|size
comma
op_amp
id|eaten
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
id|die
c_func
(paren
l_string|&quot;missing object %s for %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|tagged
)paren
comma
id|ref-&gt;refname
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|obj
)paren
id|die
c_func
(paren
l_string|&quot;parse_object_buffer failed on %s for %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|tagged
)paren
comma
id|ref-&gt;refname
)paren
suffix:semicolon
id|grab_values
c_func
(paren
id|ref-&gt;value
comma
l_int|1
comma
id|obj
comma
id|buf
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|eaten
)paren
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Given a ref, return the value for the atom.  This lazily gets value&n; * out of the object by calling populate value.&n; */
DECL|function|get_ref_atom_value
r_static
r_void
id|get_ref_atom_value
c_func
(paren
r_struct
id|ref_array_item
op_star
id|ref
comma
r_int
id|atom
comma
r_struct
id|atom_value
op_star
op_star
id|v
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ref-&gt;value
)paren
(brace
id|populate_value
c_func
(paren
id|ref
)paren
suffix:semicolon
id|fill_missing_values
c_func
(paren
id|ref-&gt;value
)paren
suffix:semicolon
)brace
op_star
id|v
op_assign
op_amp
id|ref-&gt;value
(braket
id|atom
)braket
suffix:semicolon
)brace
DECL|enum|contains_result
r_enum
id|contains_result
(brace
DECL|enumerator|CONTAINS_UNKNOWN
id|CONTAINS_UNKNOWN
op_assign
l_int|1
comma
DECL|enumerator|CONTAINS_NO
id|CONTAINS_NO
op_assign
l_int|0
comma
DECL|enumerator|CONTAINS_YES
id|CONTAINS_YES
op_assign
l_int|1
)brace
suffix:semicolon
multiline_comment|/*&n; * Mimicking the real stack, this stack lives on the heap, avoiding stack&n; * overflows.&n; *&n; * At each recursion step, the stack items points to the commits whose&n; * ancestors are to be inspected.&n; */
DECL|struct|contains_stack
r_struct
id|contains_stack
(brace
DECL|member|nr
DECL|member|alloc
r_int
id|nr
comma
id|alloc
suffix:semicolon
DECL|struct|contains_stack_entry
r_struct
id|contains_stack_entry
(brace
DECL|member|commit
r_struct
id|commit
op_star
id|commit
suffix:semicolon
DECL|member|parents
r_struct
id|commit_list
op_star
id|parents
suffix:semicolon
DECL|member|contains_stack
)brace
op_star
id|contains_stack
suffix:semicolon
)brace
suffix:semicolon
DECL|function|in_commit_list
r_static
r_int
id|in_commit_list
c_func
(paren
r_const
r_struct
id|commit_list
op_star
id|want
comma
r_struct
id|commit
op_star
id|c
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|want
suffix:semicolon
id|want
op_assign
id|want-&gt;next
)paren
r_if
c_cond
(paren
op_logical_neg
id|hashcmp
c_func
(paren
id|want-&gt;item-&gt;object.sha1
comma
id|c-&gt;object.sha1
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Test whether the candidate or one of its parents is contained in the list.&n; * Do not recurse to find out, though, but return -1 if inconclusive.&n; */
DECL|function|contains_test
r_static
r_enum
id|contains_result
id|contains_test
c_func
(paren
r_struct
id|commit
op_star
id|candidate
comma
r_const
r_struct
id|commit_list
op_star
id|want
)paren
(brace
multiline_comment|/* was it previously marked as containing a want commit? */
r_if
c_cond
(paren
id|candidate-&gt;object.flags
op_amp
id|TMP_MARK
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* or marked as not possibly containing a want commit? */
r_if
c_cond
(paren
id|candidate-&gt;object.flags
op_amp
id|UNINTERESTING
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* or are we it? */
r_if
c_cond
(paren
id|in_commit_list
c_func
(paren
id|want
comma
id|candidate
)paren
)paren
(brace
id|candidate-&gt;object.flags
op_or_assign
id|TMP_MARK
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|parse_commit
c_func
(paren
id|candidate
)paren
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|push_to_contains_stack
r_static
r_void
id|push_to_contains_stack
c_func
(paren
r_struct
id|commit
op_star
id|candidate
comma
r_struct
id|contains_stack
op_star
id|contains_stack
)paren
(brace
id|ALLOC_GROW
c_func
(paren
id|contains_stack-&gt;contains_stack
comma
id|contains_stack-&gt;nr
op_plus
l_int|1
comma
id|contains_stack-&gt;alloc
)paren
suffix:semicolon
id|contains_stack-&gt;contains_stack
(braket
id|contains_stack-&gt;nr
)braket
dot
id|commit
op_assign
id|candidate
suffix:semicolon
id|contains_stack-&gt;contains_stack
(braket
id|contains_stack-&gt;nr
op_increment
)braket
dot
id|parents
op_assign
id|candidate-&gt;parents
suffix:semicolon
)brace
DECL|function|contains_tag_algo
r_static
r_enum
id|contains_result
id|contains_tag_algo
c_func
(paren
r_struct
id|commit
op_star
id|candidate
comma
r_const
r_struct
id|commit_list
op_star
id|want
)paren
(brace
r_struct
id|contains_stack
id|contains_stack
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|NULL
)brace
suffix:semicolon
r_int
id|result
op_assign
id|contains_test
c_func
(paren
id|candidate
comma
id|want
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|CONTAINS_UNKNOWN
)paren
r_return
id|result
suffix:semicolon
id|push_to_contains_stack
c_func
(paren
id|candidate
comma
op_amp
id|contains_stack
)paren
suffix:semicolon
r_while
c_loop
(paren
id|contains_stack.nr
)paren
(brace
r_struct
id|contains_stack_entry
op_star
id|entry
op_assign
op_amp
id|contains_stack.contains_stack
(braket
id|contains_stack.nr
l_int|1
)braket
suffix:semicolon
r_struct
id|commit
op_star
id|commit
op_assign
id|entry-&gt;commit
suffix:semicolon
r_struct
id|commit_list
op_star
id|parents
op_assign
id|entry-&gt;parents
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parents
)paren
(brace
id|commit-&gt;object.flags
op_or_assign
id|UNINTERESTING
suffix:semicolon
id|contains_stack.nr
op_decrement
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If we just popped the stack, parents-&gt;item has been marked,&n;&t;&t; * therefore contains_test will return a meaningful 0 or 1.&n;&t;&t; */
r_else
r_switch
c_cond
(paren
id|contains_test
c_func
(paren
id|parents-&gt;item
comma
id|want
)paren
)paren
(brace
r_case
id|CONTAINS_YES
suffix:colon
id|commit-&gt;object.flags
op_or_assign
id|TMP_MARK
suffix:semicolon
id|contains_stack.nr
op_decrement
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CONTAINS_NO
suffix:colon
id|entry-&gt;parents
op_assign
id|parents-&gt;next
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CONTAINS_UNKNOWN
suffix:colon
id|push_to_contains_stack
c_func
(paren
id|parents-&gt;item
comma
op_amp
id|contains_stack
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|free
c_func
(paren
id|contains_stack.contains_stack
)paren
suffix:semicolon
r_return
id|contains_test
c_func
(paren
id|candidate
comma
id|want
)paren
suffix:semicolon
)brace
DECL|function|commit_contains
r_static
r_int
id|commit_contains
c_func
(paren
r_struct
id|ref_filter
op_star
id|filter
comma
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_if
c_cond
(paren
id|filter-&gt;with_commit_tag_algo
)paren
r_return
id|contains_tag_algo
c_func
(paren
id|commit
comma
id|filter-&gt;with_commit
)paren
suffix:semicolon
r_return
id|is_descendant_of
c_func
(paren
id|commit
comma
id|filter-&gt;with_commit
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Return 1 if the refname matches one of the patterns, otherwise 0.&n; * A pattern can be a literal prefix (e.g. a refname &quot;refs/heads/master&quot;&n; * matches a pattern &quot;refs/heads/mas&quot;) or a wildcard (e.g. the same ref&n; * matches &quot;refs/heads/mas*&quot;, too).&n; */
DECL|function|match_pattern
r_static
r_int
id|match_pattern
c_func
(paren
r_const
r_char
op_star
op_star
id|patterns
comma
r_const
r_char
op_star
id|refname
)paren
(brace
multiline_comment|/*&n;&t; * When no &squot;--format&squot; option is given we need to skip the prefix&n;&t; * for matching refs of tags and branches.&n;&t; */
(paren
r_void
)paren
(paren
id|skip_prefix
c_func
(paren
id|refname
comma
l_string|&quot;refs/tags/&quot;
comma
op_amp
id|refname
)paren
op_logical_or
id|skip_prefix
c_func
(paren
id|refname
comma
l_string|&quot;refs/heads/&quot;
comma
op_amp
id|refname
)paren
op_logical_or
id|skip_prefix
c_func
(paren
id|refname
comma
l_string|&quot;refs/remotes/&quot;
comma
op_amp
id|refname
)paren
op_logical_or
id|skip_prefix
c_func
(paren
id|refname
comma
l_string|&quot;refs/&quot;
comma
op_amp
id|refname
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
op_star
id|patterns
suffix:semicolon
id|patterns
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|wildmatch
c_func
(paren
op_star
id|patterns
comma
id|refname
comma
l_int|0
comma
l_int|NULL
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Return 1 if the refname matches one of the patterns, otherwise 0.&n; * A pattern can be path prefix (e.g. a refname &quot;refs/heads/master&quot;&n; * matches a pattern &quot;refs/heads/&quot; but not &quot;refs/heads/m&quot;) or a&n; * wildcard (e.g. the same ref matches &quot;refs/heads/m*&quot;, too).&n; */
DECL|function|match_name_as_path
r_static
r_int
id|match_name_as_path
c_func
(paren
r_const
r_char
op_star
op_star
id|pattern
comma
r_const
r_char
op_star
id|refname
)paren
(brace
r_int
id|namelen
op_assign
id|strlen
c_func
(paren
id|refname
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
op_star
id|pattern
suffix:semicolon
id|pattern
op_increment
)paren
(brace
r_const
r_char
op_star
id|p
op_assign
op_star
id|pattern
suffix:semicolon
r_int
id|plen
op_assign
id|strlen
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|plen
op_le
id|namelen
)paren
op_logical_and
op_logical_neg
id|strncmp
c_func
(paren
id|refname
comma
id|p
comma
id|plen
)paren
op_logical_and
(paren
id|refname
(braket
id|plen
)braket
op_eq
l_char|&squot;&bslash;0&squot;
op_logical_or
id|refname
(braket
id|plen
)braket
op_eq
l_char|&squot;/&squot;
op_logical_or
id|p
(braket
id|plen
op_minus
l_int|1
)braket
op_eq
l_char|&squot;/&squot;
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wildmatch
c_func
(paren
id|p
comma
id|refname
comma
id|WM_PATHNAME
comma
l_int|NULL
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Return 1 if the refname matches one of the patterns, otherwise 0. */
DECL|function|filter_pattern_match
r_static
r_int
id|filter_pattern_match
c_func
(paren
r_struct
id|ref_filter
op_star
id|filter
comma
r_const
r_char
op_star
id|refname
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|filter-&gt;name_patterns
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* No pattern always matches */
r_if
c_cond
(paren
id|filter-&gt;match_as_path
)paren
r_return
id|match_name_as_path
c_func
(paren
id|filter-&gt;name_patterns
comma
id|refname
)paren
suffix:semicolon
r_return
id|match_pattern
c_func
(paren
id|filter-&gt;name_patterns
comma
id|refname
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Given a ref (sha1, refname), check if the ref belongs to the array&n; * of sha1s. If the given ref is a tag, check if the given tag points&n; * at one of the sha1s in the given sha1 array.&n; * the given sha1_array.&n; * NEEDSWORK:&n; * 1. Only a single level of inderection is obtained, we might want to&n; * change this to account for multiple levels (e.g. annotated tags&n; * pointing to annotated tags pointing to a commit.)&n; * 2. As the refs are cached we might know what refname peels to without&n; * the need to parse the object via parse_object(). peel_ref() might be a&n; * more efficient alternative to obtain the pointee.&n; */
DECL|function|match_points_at
r_static
r_const
r_int
r_char
op_star
id|match_points_at
c_func
(paren
r_struct
id|sha1_array
op_star
id|points_at
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_const
r_char
op_star
id|refname
)paren
(brace
r_const
r_int
r_char
op_star
id|tagged_sha1
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|object
op_star
id|obj
suffix:semicolon
r_if
c_cond
(paren
id|sha1_array_lookup
c_func
(paren
id|points_at
comma
id|sha1
)paren
op_ge
l_int|0
)paren
r_return
id|sha1
suffix:semicolon
id|obj
op_assign
id|parse_object
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|obj
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;malformed object at &squot;%s&squot;&quot;
)paren
comma
id|refname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|obj-&gt;type
op_eq
id|OBJ_TAG
)paren
id|tagged_sha1
op_assign
(paren
(paren
r_struct
id|tag
op_star
)paren
id|obj
)paren
op_member_access_from_pointer
id|tagged-&gt;sha1
suffix:semicolon
r_if
c_cond
(paren
id|tagged_sha1
op_logical_and
id|sha1_array_lookup
c_func
(paren
id|points_at
comma
id|tagged_sha1
)paren
op_ge
l_int|0
)paren
r_return
id|tagged_sha1
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Allocate space for a new ref_array_item and copy the objectname and flag to it */
DECL|function|new_ref_array_item
r_static
r_struct
id|ref_array_item
op_star
id|new_ref_array_item
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_const
r_int
r_char
op_star
id|objectname
comma
r_int
id|flag
)paren
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|refname
)paren
suffix:semicolon
r_struct
id|ref_array_item
op_star
id|ref
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|ref_array_item
)paren
op_plus
id|len
op_plus
l_int|1
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ref-&gt;refname
comma
id|refname
comma
id|len
)paren
suffix:semicolon
id|ref-&gt;refname
(braket
id|len
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|hashcpy
c_func
(paren
id|ref-&gt;objectname
comma
id|objectname
)paren
suffix:semicolon
id|ref-&gt;flag
op_assign
id|flag
suffix:semicolon
r_return
id|ref
suffix:semicolon
)brace
DECL|function|filter_ref_kind
r_static
r_int
id|filter_ref_kind
c_func
(paren
r_struct
id|ref_filter
op_star
id|filter
comma
r_const
r_char
op_star
id|refname
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_static
r_struct
(brace
r_const
r_char
op_star
id|prefix
suffix:semicolon
r_int
r_int
id|kind
suffix:semicolon
)brace
id|ref_kind
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;refs/heads/&quot;
comma
id|FILTER_REFS_BRANCHES
)brace
comma
(brace
l_string|&quot;refs/remotes/&quot;
comma
id|FILTER_REFS_REMOTES
)brace
comma
(brace
l_string|&quot;refs/tags/&quot;
comma
id|FILTER_REFS_TAGS
)brace
)brace
suffix:semicolon
r_if
c_cond
(paren
id|filter-&gt;kind
op_eq
id|FILTER_REFS_BRANCHES
op_logical_or
id|filter-&gt;kind
op_eq
id|FILTER_REFS_REMOTES
op_logical_or
id|filter-&gt;kind
op_eq
id|FILTER_REFS_TAGS
)paren
r_return
id|filter-&gt;kind
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|refname
comma
l_string|&quot;HEAD&quot;
)paren
)paren
r_return
id|FILTER_REFS_DETACHED_HEAD
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|ref_kind
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|refname
comma
id|ref_kind
(braket
id|i
)braket
dot
id|prefix
)paren
)paren
r_return
id|ref_kind
(braket
id|i
)braket
dot
id|kind
suffix:semicolon
)brace
r_return
id|FILTER_REFS_OTHERS
suffix:semicolon
)brace
multiline_comment|/*&n; * A call-back given to for_each_ref().  Filter refs and keep them for&n; * later object processing.&n; */
DECL|function|ref_filter_handler
r_static
r_int
id|ref_filter_handler
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_const
r_struct
id|object_id
op_star
id|oid
comma
r_int
id|flag
comma
r_void
op_star
id|cb_data
)paren
(brace
r_struct
id|ref_filter_cbdata
op_star
id|ref_cbdata
op_assign
id|cb_data
suffix:semicolon
r_struct
id|ref_filter
op_star
id|filter
op_assign
id|ref_cbdata-&gt;filter
suffix:semicolon
r_struct
id|ref_array_item
op_star
id|ref
suffix:semicolon
r_struct
id|commit
op_star
id|commit
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|kind
suffix:semicolon
r_if
c_cond
(paren
id|flag
op_amp
id|REF_BAD_NAME
)paren
(brace
id|warning
c_func
(paren
l_string|&quot;ignoring ref with broken name %s&quot;
comma
id|refname
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flag
op_amp
id|REF_ISBROKEN
)paren
(brace
id|warning
c_func
(paren
l_string|&quot;ignoring broken ref %s&quot;
comma
id|refname
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Obtain the current ref kind from filter_ref_kind() and ignore unwanted refs. */
id|kind
op_assign
id|filter_ref_kind
c_func
(paren
id|filter
comma
id|refname
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|kind
op_amp
id|filter-&gt;kind
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|filter_pattern_match
c_func
(paren
id|filter
comma
id|refname
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|filter-&gt;points_at.nr
op_logical_and
op_logical_neg
id|match_points_at
c_func
(paren
op_amp
id|filter-&gt;points_at
comma
id|oid-&gt;hash
comma
id|refname
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * A merge filter is applied on refs pointing to commits. Hence&n;&t; * obtain the commit using the &squot;oid&squot; available and discard all&n;&t; * non-commits early. The actual filtering is done later.&n;&t; */
r_if
c_cond
(paren
id|filter-&gt;merge_commit
op_logical_or
id|filter-&gt;with_commit
op_logical_or
id|filter-&gt;verbose
)paren
(brace
id|commit
op_assign
id|lookup_commit_reference_gently
c_func
(paren
id|oid-&gt;hash
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|commit
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* We perform the filtering for the &squot;--contains&squot; option */
r_if
c_cond
(paren
id|filter-&gt;with_commit
op_logical_and
op_logical_neg
id|commit_contains
c_func
(paren
id|filter
comma
id|commit
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We do not open the object yet; sort may only need refname&n;&t; * to do its job and the resulting list may yet to be pruned&n;&t; * by maxcount logic.&n;&t; */
id|ref
op_assign
id|new_ref_array_item
c_func
(paren
id|refname
comma
id|oid-&gt;hash
comma
id|flag
)paren
suffix:semicolon
id|ref-&gt;commit
op_assign
id|commit
suffix:semicolon
id|REALLOC_ARRAY
c_func
(paren
id|ref_cbdata-&gt;array-&gt;items
comma
id|ref_cbdata-&gt;array-&gt;nr
op_plus
l_int|1
)paren
suffix:semicolon
id|ref_cbdata-&gt;array-&gt;items
(braket
id|ref_cbdata-&gt;array-&gt;nr
op_increment
)braket
op_assign
id|ref
suffix:semicolon
id|ref-&gt;kind
op_assign
id|kind
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  Free memory allocated for a ref_array_item */
DECL|function|free_array_item
r_static
r_void
id|free_array_item
c_func
(paren
r_struct
id|ref_array_item
op_star
id|item
)paren
(brace
id|free
c_func
(paren
(paren
r_char
op_star
)paren
id|item-&gt;symref
)paren
suffix:semicolon
id|free
c_func
(paren
id|item
)paren
suffix:semicolon
)brace
multiline_comment|/* Free all memory allocated for ref_array */
DECL|function|ref_array_clear
r_void
id|ref_array_clear
c_func
(paren
r_struct
id|ref_array
op_star
id|array
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|array-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
id|free_array_item
c_func
(paren
id|array-&gt;items
(braket
id|i
)braket
)paren
suffix:semicolon
id|free
c_func
(paren
id|array-&gt;items
)paren
suffix:semicolon
id|array-&gt;items
op_assign
l_int|NULL
suffix:semicolon
id|array-&gt;nr
op_assign
id|array-&gt;alloc
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|do_merge_filter
r_static
r_void
id|do_merge_filter
c_func
(paren
r_struct
id|ref_filter_cbdata
op_star
id|ref_cbdata
)paren
(brace
r_struct
id|rev_info
id|revs
suffix:semicolon
r_int
id|i
comma
id|old_nr
suffix:semicolon
r_struct
id|ref_filter
op_star
id|filter
op_assign
id|ref_cbdata-&gt;filter
suffix:semicolon
r_struct
id|ref_array
op_star
id|array
op_assign
id|ref_cbdata-&gt;array
suffix:semicolon
r_struct
id|commit
op_star
op_star
id|to_clear
op_assign
id|xcalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|commit
op_star
)paren
comma
id|array-&gt;nr
)paren
suffix:semicolon
id|init_revisions
c_func
(paren
op_amp
id|revs
comma
l_int|NULL
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|array-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|ref_array_item
op_star
id|item
op_assign
id|array-&gt;items
(braket
id|i
)braket
suffix:semicolon
id|add_pending_object
c_func
(paren
op_amp
id|revs
comma
op_amp
id|item-&gt;commit-&gt;object
comma
id|item-&gt;refname
)paren
suffix:semicolon
id|to_clear
(braket
id|i
)braket
op_assign
id|item-&gt;commit
suffix:semicolon
)brace
id|filter-&gt;merge_commit-&gt;object.flags
op_or_assign
id|UNINTERESTING
suffix:semicolon
id|add_pending_object
c_func
(paren
op_amp
id|revs
comma
op_amp
id|filter-&gt;merge_commit-&gt;object
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
id|revs.limited
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|prepare_revision_walk
c_func
(paren
op_amp
id|revs
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;revision walk setup failed&quot;
)paren
)paren
suffix:semicolon
id|old_nr
op_assign
id|array-&gt;nr
suffix:semicolon
id|array-&gt;nr
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|old_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|ref_array_item
op_star
id|item
op_assign
id|array-&gt;items
(braket
id|i
)braket
suffix:semicolon
r_struct
id|commit
op_star
id|commit
op_assign
id|item-&gt;commit
suffix:semicolon
r_int
id|is_merged
op_assign
op_logical_neg
op_logical_neg
(paren
id|commit-&gt;object.flags
op_amp
id|UNINTERESTING
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_merged
op_eq
(paren
id|filter-&gt;merge
op_eq
id|REF_FILTER_MERGED_INCLUDE
)paren
)paren
id|array-&gt;items
(braket
id|array-&gt;nr
op_increment
)braket
op_assign
id|array-&gt;items
(braket
id|i
)braket
suffix:semicolon
r_else
id|free_array_item
c_func
(paren
id|item
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|old_nr
suffix:semicolon
id|i
op_increment
)paren
id|clear_commit_marks
c_func
(paren
id|to_clear
(braket
id|i
)braket
comma
id|ALL_REV_FLAGS
)paren
suffix:semicolon
id|clear_commit_marks
c_func
(paren
id|filter-&gt;merge_commit
comma
id|ALL_REV_FLAGS
)paren
suffix:semicolon
id|free
c_func
(paren
id|to_clear
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * API for filtering a set of refs. Based on the type of refs the user&n; * has requested, we iterate through those refs and apply filters&n; * as per the given ref_filter structure and finally store the&n; * filtered refs in the ref_array structure.&n; */
DECL|function|filter_refs
r_int
id|filter_refs
c_func
(paren
r_struct
id|ref_array
op_star
id|array
comma
r_struct
id|ref_filter
op_star
id|filter
comma
r_int
r_int
id|type
)paren
(brace
r_struct
id|ref_filter_cbdata
id|ref_cbdata
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|broken
op_assign
l_int|0
suffix:semicolon
id|ref_cbdata.array
op_assign
id|array
suffix:semicolon
id|ref_cbdata.filter
op_assign
id|filter
suffix:semicolon
r_if
c_cond
(paren
id|type
op_amp
id|FILTER_REFS_INCLUDE_BROKEN
)paren
id|broken
op_assign
l_int|1
suffix:semicolon
id|filter-&gt;kind
op_assign
id|type
op_amp
id|FILTER_REFS_KIND_MASK
suffix:semicolon
multiline_comment|/*  Simple per-ref filtering */
r_if
c_cond
(paren
op_logical_neg
id|filter-&gt;kind
)paren
id|die
c_func
(paren
l_string|&quot;filter_refs: invalid type&quot;
)paren
suffix:semicolon
r_else
(brace
multiline_comment|/*&n;&t;&t; * For common cases where we need only branches or remotes or tags,&n;&t;&t; * we only iterate through those refs. If a mix of refs is needed,&n;&t;&t; * we iterate over all refs and filter out required refs with the help&n;&t;&t; * of filter_ref_kind().&n;&t;&t; */
r_if
c_cond
(paren
id|filter-&gt;kind
op_eq
id|FILTER_REFS_BRANCHES
)paren
id|ret
op_assign
id|for_each_fullref_in
c_func
(paren
l_string|&quot;refs/heads/&quot;
comma
id|ref_filter_handler
comma
op_amp
id|ref_cbdata
comma
id|broken
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|filter-&gt;kind
op_eq
id|FILTER_REFS_REMOTES
)paren
id|ret
op_assign
id|for_each_fullref_in
c_func
(paren
l_string|&quot;refs/remotes/&quot;
comma
id|ref_filter_handler
comma
op_amp
id|ref_cbdata
comma
id|broken
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|filter-&gt;kind
op_eq
id|FILTER_REFS_TAGS
)paren
id|ret
op_assign
id|for_each_fullref_in
c_func
(paren
l_string|&quot;refs/tags/&quot;
comma
id|ref_filter_handler
comma
op_amp
id|ref_cbdata
comma
id|broken
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|filter-&gt;kind
op_amp
id|FILTER_REFS_ALL
)paren
id|ret
op_assign
id|for_each_fullref_in
c_func
(paren
l_string|&quot;&quot;
comma
id|ref_filter_handler
comma
op_amp
id|ref_cbdata
comma
id|broken
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
op_logical_and
(paren
id|filter-&gt;kind
op_amp
id|FILTER_REFS_DETACHED_HEAD
)paren
)paren
id|head_ref
c_func
(paren
id|ref_filter_handler
comma
op_amp
id|ref_cbdata
)paren
suffix:semicolon
)brace
multiline_comment|/*  Filters that need revision walking */
r_if
c_cond
(paren
id|filter-&gt;merge_commit
)paren
id|do_merge_filter
c_func
(paren
op_amp
id|ref_cbdata
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|cmp_ref_sorting
r_static
r_int
id|cmp_ref_sorting
c_func
(paren
r_struct
id|ref_sorting
op_star
id|s
comma
r_struct
id|ref_array_item
op_star
id|a
comma
r_struct
id|ref_array_item
op_star
id|b
)paren
(brace
r_struct
id|atom_value
op_star
id|va
comma
op_star
id|vb
suffix:semicolon
r_int
id|cmp
suffix:semicolon
id|cmp_type
id|cmp_type
op_assign
id|used_atom_type
(braket
id|s-&gt;atom
)braket
suffix:semicolon
id|get_ref_atom_value
c_func
(paren
id|a
comma
id|s-&gt;atom
comma
op_amp
id|va
)paren
suffix:semicolon
id|get_ref_atom_value
c_func
(paren
id|b
comma
id|s-&gt;atom
comma
op_amp
id|vb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;version
)paren
id|cmp
op_assign
id|versioncmp
c_func
(paren
id|va-&gt;s
comma
id|vb-&gt;s
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cmp_type
op_eq
id|FIELD_STR
)paren
id|cmp
op_assign
id|strcmp
c_func
(paren
id|va-&gt;s
comma
id|vb-&gt;s
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|va-&gt;ul
OL
id|vb-&gt;ul
)paren
id|cmp
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|va-&gt;ul
op_eq
id|vb-&gt;ul
)paren
id|cmp
op_assign
l_int|0
suffix:semicolon
r_else
id|cmp
op_assign
l_int|1
suffix:semicolon
)brace
r_return
(paren
id|s-&gt;reverse
)paren
ques
c_cond
id|cmp
suffix:colon
id|cmp
suffix:semicolon
)brace
DECL|variable|ref_sorting
r_static
r_struct
id|ref_sorting
op_star
id|ref_sorting
suffix:semicolon
DECL|function|compare_refs
r_static
r_int
id|compare_refs
c_func
(paren
r_const
r_void
op_star
id|a_
comma
r_const
r_void
op_star
id|b_
)paren
(brace
r_struct
id|ref_array_item
op_star
id|a
op_assign
op_star
(paren
(paren
r_struct
id|ref_array_item
op_star
op_star
)paren
id|a_
)paren
suffix:semicolon
r_struct
id|ref_array_item
op_star
id|b
op_assign
op_star
(paren
(paren
r_struct
id|ref_array_item
op_star
op_star
)paren
id|b_
)paren
suffix:semicolon
r_struct
id|ref_sorting
op_star
id|s
suffix:semicolon
r_for
c_loop
(paren
id|s
op_assign
id|ref_sorting
suffix:semicolon
id|s
suffix:semicolon
id|s
op_assign
id|s-&gt;next
)paren
(brace
r_int
id|cmp
op_assign
id|cmp_ref_sorting
c_func
(paren
id|s
comma
id|a
comma
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmp
)paren
r_return
id|cmp
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ref_array_sort
r_void
id|ref_array_sort
c_func
(paren
r_struct
id|ref_sorting
op_star
id|sorting
comma
r_struct
id|ref_array
op_star
id|array
)paren
(brace
id|ref_sorting
op_assign
id|sorting
suffix:semicolon
id|qsort
c_func
(paren
id|array-&gt;items
comma
id|array-&gt;nr
comma
r_sizeof
(paren
r_struct
id|ref_array_item
op_star
)paren
comma
id|compare_refs
)paren
suffix:semicolon
)brace
DECL|function|hex1
r_static
r_int
id|hex1
c_func
(paren
r_char
id|ch
)paren
(brace
r_if
c_cond
(paren
l_char|&squot;0&squot;
op_le
id|ch
op_logical_and
id|ch
op_le
l_char|&squot;9&squot;
)paren
r_return
id|ch
l_char|&squot;0&squot;
suffix:semicolon
r_else
r_if
c_cond
(paren
l_char|&squot;a&squot;
op_le
id|ch
op_logical_and
id|ch
op_le
l_char|&squot;f&squot;
)paren
r_return
id|ch
l_char|&squot;a&squot;
op_plus
l_int|10
suffix:semicolon
r_else
r_if
c_cond
(paren
l_char|&squot;A&squot;
op_le
id|ch
op_logical_and
id|ch
op_le
l_char|&squot;F&squot;
)paren
r_return
id|ch
l_char|&squot;A&squot;
op_plus
l_int|10
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|hex2
r_static
r_int
id|hex2
c_func
(paren
r_const
r_char
op_star
id|cp
)paren
(brace
r_if
c_cond
(paren
id|cp
(braket
l_int|0
)braket
op_logical_and
id|cp
(braket
l_int|1
)braket
)paren
r_return
(paren
id|hex1
c_func
(paren
id|cp
(braket
l_int|0
)braket
)paren
op_lshift
l_int|4
)paren
op_or
id|hex1
c_func
(paren
id|cp
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_else
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|append_literal
r_static
r_void
id|append_literal
c_func
(paren
r_const
r_char
op_star
id|cp
comma
r_const
r_char
op_star
id|ep
comma
r_struct
id|ref_formatting_state
op_star
id|state
)paren
(brace
r_struct
id|strbuf
op_star
id|s
op_assign
op_amp
id|state-&gt;stack-&gt;output
suffix:semicolon
r_while
c_loop
(paren
op_star
id|cp
op_logical_and
(paren
op_logical_neg
id|ep
op_logical_or
id|cp
OL
id|ep
)paren
)paren
(brace
r_if
c_cond
(paren
op_star
id|cp
op_eq
l_char|&squot;%&squot;
)paren
(brace
r_if
c_cond
(paren
id|cp
(braket
l_int|1
)braket
op_eq
l_char|&squot;%&squot;
)paren
id|cp
op_increment
suffix:semicolon
r_else
(brace
r_int
id|ch
op_assign
id|hex2
c_func
(paren
id|cp
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_le
id|ch
)paren
(brace
id|strbuf_addch
c_func
(paren
id|s
comma
id|ch
)paren
suffix:semicolon
id|cp
op_add_assign
l_int|3
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
)brace
id|strbuf_addch
c_func
(paren
id|s
comma
op_star
id|cp
)paren
suffix:semicolon
id|cp
op_increment
suffix:semicolon
)brace
)brace
DECL|function|show_ref_array_item
r_void
id|show_ref_array_item
c_func
(paren
r_struct
id|ref_array_item
op_star
id|info
comma
r_const
r_char
op_star
id|format
comma
r_int
id|quote_style
)paren
(brace
r_const
r_char
op_star
id|cp
comma
op_star
id|sp
comma
op_star
id|ep
suffix:semicolon
r_struct
id|strbuf
op_star
id|final_buf
suffix:semicolon
r_struct
id|ref_formatting_state
id|state
op_assign
id|REF_FORMATTING_STATE_INIT
suffix:semicolon
id|state.quote_style
op_assign
id|quote_style
suffix:semicolon
id|push_stack_element
c_func
(paren
op_amp
id|state.stack
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cp
op_assign
id|format
suffix:semicolon
op_star
id|cp
op_logical_and
(paren
id|sp
op_assign
id|find_next
c_func
(paren
id|cp
)paren
)paren
suffix:semicolon
id|cp
op_assign
id|ep
op_plus
l_int|1
)paren
(brace
r_struct
id|atom_value
op_star
id|atomv
suffix:semicolon
id|ep
op_assign
id|strchr
c_func
(paren
id|sp
comma
l_char|&squot;)&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp
OL
id|sp
)paren
id|append_literal
c_func
(paren
id|cp
comma
id|sp
comma
op_amp
id|state
)paren
suffix:semicolon
id|get_ref_atom_value
c_func
(paren
id|info
comma
id|parse_ref_filter_atom
c_func
(paren
id|sp
op_plus
l_int|2
comma
id|ep
)paren
comma
op_amp
id|atomv
)paren
suffix:semicolon
id|atomv
op_member_access_from_pointer
id|handler
c_func
(paren
id|atomv
comma
op_amp
id|state
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|cp
)paren
(brace
id|sp
op_assign
id|cp
op_plus
id|strlen
c_func
(paren
id|cp
)paren
suffix:semicolon
id|append_literal
c_func
(paren
id|cp
comma
id|sp
comma
op_amp
id|state
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|need_color_reset_at_eol
)paren
(brace
r_struct
id|atom_value
id|resetv
suffix:semicolon
r_char
id|color
(braket
id|COLOR_MAXLEN
)braket
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_if
c_cond
(paren
id|color_parse
c_func
(paren
l_string|&quot;reset&quot;
comma
id|color
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;BUG: couldn&squot;t parse &squot;reset&squot; as a color&quot;
)paren
suffix:semicolon
id|resetv.s
op_assign
id|color
suffix:semicolon
id|append_atom
c_func
(paren
op_amp
id|resetv
comma
op_amp
id|state
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|state.stack-&gt;prev
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;format: %%(end) atom missing&quot;
)paren
)paren
suffix:semicolon
id|final_buf
op_assign
op_amp
id|state.stack-&gt;output
suffix:semicolon
id|fwrite
c_func
(paren
id|final_buf-&gt;buf
comma
l_int|1
comma
id|final_buf-&gt;len
comma
id|stdout
)paren
suffix:semicolon
id|pop_stack_element
c_func
(paren
op_amp
id|state.stack
)paren
suffix:semicolon
id|putchar
c_func
(paren
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
multiline_comment|/*  If no sorting option is given, use refname to sort as default */
DECL|function|ref_default_sorting
r_struct
id|ref_sorting
op_star
id|ref_default_sorting
c_func
(paren
r_void
)paren
(brace
r_static
r_const
r_char
id|cstr_name
(braket
)braket
op_assign
l_string|&quot;refname&quot;
suffix:semicolon
r_struct
id|ref_sorting
op_star
id|sorting
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|sorting
)paren
)paren
suffix:semicolon
id|sorting-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|sorting-&gt;atom
op_assign
id|parse_ref_filter_atom
c_func
(paren
id|cstr_name
comma
id|cstr_name
op_plus
id|strlen
c_func
(paren
id|cstr_name
)paren
)paren
suffix:semicolon
r_return
id|sorting
suffix:semicolon
)brace
DECL|function|parse_opt_ref_sorting
r_int
id|parse_opt_ref_sorting
c_func
(paren
r_const
r_struct
id|option
op_star
id|opt
comma
r_const
r_char
op_star
id|arg
comma
r_int
id|unset
)paren
(brace
r_struct
id|ref_sorting
op_star
op_star
id|sorting_tail
op_assign
id|opt-&gt;value
suffix:semicolon
r_struct
id|ref_sorting
op_star
id|s
suffix:semicolon
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
multiline_comment|/* should --no-sort void the list ? */
r_return
l_int|1
suffix:semicolon
id|s
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|s
)paren
)paren
suffix:semicolon
id|s-&gt;next
op_assign
op_star
id|sorting_tail
suffix:semicolon
op_star
id|sorting_tail
op_assign
id|s
suffix:semicolon
r_if
c_cond
(paren
op_star
id|arg
op_eq
l_char|&squot;-&squot;
)paren
(brace
id|s-&gt;reverse
op_assign
l_int|1
suffix:semicolon
id|arg
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skip_prefix
c_func
(paren
id|arg
comma
l_string|&quot;version:&quot;
comma
op_amp
id|arg
)paren
op_logical_or
id|skip_prefix
c_func
(paren
id|arg
comma
l_string|&quot;v:&quot;
comma
op_amp
id|arg
)paren
)paren
id|s-&gt;version
op_assign
l_int|1
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|arg
)paren
suffix:semicolon
id|s-&gt;atom
op_assign
id|parse_ref_filter_atom
c_func
(paren
id|arg
comma
id|arg
op_plus
id|len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|parse_opt_merge_filter
r_int
id|parse_opt_merge_filter
c_func
(paren
r_const
r_struct
id|option
op_star
id|opt
comma
r_const
r_char
op_star
id|arg
comma
r_int
id|unset
)paren
(brace
r_struct
id|ref_filter
op_star
id|rf
op_assign
id|opt-&gt;value
suffix:semicolon
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
id|rf-&gt;merge
op_assign
id|starts_with
c_func
(paren
id|opt-&gt;long_name
comma
l_string|&quot;no&quot;
)paren
ques
c_cond
id|REF_FILTER_MERGED_OMIT
suffix:colon
id|REF_FILTER_MERGED_INCLUDE
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1
c_func
(paren
id|arg
comma
id|sha1
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;malformed object name %s&quot;
)paren
comma
id|arg
)paren
suffix:semicolon
id|rf-&gt;merge_commit
op_assign
id|lookup_commit_reference_gently
c_func
(paren
id|sha1
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rf-&gt;merge_commit
)paren
r_return
id|opterror
c_func
(paren
id|opt
comma
l_string|&quot;must point to a commit&quot;
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
