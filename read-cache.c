multiline_comment|/*&n; * GIT - The information manager from hell&n; *&n; * Copyright (C) Linus Torvalds, 2005&n; */
DECL|macro|NO_THE_INDEX_COMPATIBILITY_MACROS
mdefine_line|#define NO_THE_INDEX_COMPATIBILITY_MACROS
macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;cache-tree.h&quot;
macro_line|#include &quot;refs.h&quot;
macro_line|#include &quot;dir.h&quot;
multiline_comment|/* Index extensions.&n; *&n; * The first letter should be &squot;A&squot;..&squot;Z&squot; for extensions that are not&n; * necessary for a correct operation (i.e. optimization data).&n; * When new extensions are added that _needs_ to be understood in&n; * order to correctly interpret the index file, pick character that&n; * is outside the range, to cause the reader to abort.&n; */
DECL|macro|CACHE_EXT
mdefine_line|#define CACHE_EXT(s) ( (s[0]&lt;&lt;24)|(s[1]&lt;&lt;16)|(s[2]&lt;&lt;8)|(s[3]) )
DECL|macro|CACHE_EXT_TREE
mdefine_line|#define CACHE_EXT_TREE 0x54524545&t;/* &quot;TREE&quot; */
DECL|variable|the_index
r_struct
id|index_state
id|the_index
suffix:semicolon
DECL|function|set_index_entry
r_static
r_void
id|set_index_entry
c_func
(paren
r_struct
id|index_state
op_star
id|istate
comma
r_int
id|nr
comma
r_struct
id|cache_entry
op_star
id|ce
)paren
(brace
id|istate-&gt;cache
(braket
id|nr
)braket
op_assign
id|ce
suffix:semicolon
id|add_name_hash
c_func
(paren
id|istate
comma
id|ce
)paren
suffix:semicolon
)brace
DECL|function|replace_index_entry
r_static
r_void
id|replace_index_entry
c_func
(paren
r_struct
id|index_state
op_star
id|istate
comma
r_int
id|nr
comma
r_struct
id|cache_entry
op_star
id|ce
)paren
(brace
r_struct
id|cache_entry
op_star
id|old
op_assign
id|istate-&gt;cache
(braket
id|nr
)braket
suffix:semicolon
id|remove_name_hash
c_func
(paren
id|old
)paren
suffix:semicolon
id|set_index_entry
c_func
(paren
id|istate
comma
id|nr
comma
id|ce
)paren
suffix:semicolon
id|istate-&gt;cache_changed
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|rename_index_entry_at
r_void
id|rename_index_entry_at
c_func
(paren
r_struct
id|index_state
op_star
id|istate
comma
r_int
id|nr
comma
r_const
r_char
op_star
id|new_name
)paren
(brace
r_struct
id|cache_entry
op_star
id|old
op_assign
id|istate-&gt;cache
(braket
id|nr
)braket
comma
op_star
r_new
suffix:semicolon
r_int
id|namelen
op_assign
id|strlen
c_func
(paren
id|new_name
)paren
suffix:semicolon
r_new
op_assign
id|xmalloc
c_func
(paren
id|cache_entry_size
c_func
(paren
id|namelen
)paren
)paren
suffix:semicolon
id|copy_cache_entry
c_func
(paren
r_new
comma
id|old
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|ce_flags
op_and_assign
op_complement
(paren
id|CE_STATE_MASK
op_or
id|CE_NAMEMASK
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|ce_flags
op_or_assign
(paren
id|namelen
op_ge
id|CE_NAMEMASK
ques
c_cond
id|CE_NAMEMASK
suffix:colon
id|namelen
)paren
suffix:semicolon
id|memcpy
c_func
(paren
r_new
op_member_access_from_pointer
id|name
comma
id|new_name
comma
id|namelen
op_plus
l_int|1
)paren
suffix:semicolon
id|cache_tree_invalidate_path
c_func
(paren
id|istate-&gt;cache_tree
comma
id|old-&gt;name
)paren
suffix:semicolon
id|remove_index_entry_at
c_func
(paren
id|istate
comma
id|nr
)paren
suffix:semicolon
id|add_index_entry
c_func
(paren
id|istate
comma
r_new
comma
id|ADD_CACHE_OK_TO_ADD
op_or
id|ADD_CACHE_OK_TO_REPLACE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This only updates the &quot;non-critical&quot; parts of the directory&n; * cache, ie the parts that aren&squot;t tracked by GIT, and only used&n; * to validate the cache.&n; */
DECL|function|fill_stat_cache_info
r_void
id|fill_stat_cache_info
c_func
(paren
r_struct
id|cache_entry
op_star
id|ce
comma
r_struct
id|stat
op_star
id|st
)paren
(brace
id|ce-&gt;ce_ctime
op_assign
id|st-&gt;st_ctime
suffix:semicolon
id|ce-&gt;ce_mtime
op_assign
id|st-&gt;st_mtime
suffix:semicolon
id|ce-&gt;ce_dev
op_assign
id|st-&gt;st_dev
suffix:semicolon
id|ce-&gt;ce_ino
op_assign
id|st-&gt;st_ino
suffix:semicolon
id|ce-&gt;ce_uid
op_assign
id|st-&gt;st_uid
suffix:semicolon
id|ce-&gt;ce_gid
op_assign
id|st-&gt;st_gid
suffix:semicolon
id|ce-&gt;ce_size
op_assign
id|st-&gt;st_size
suffix:semicolon
r_if
c_cond
(paren
id|assume_unchanged
)paren
id|ce-&gt;ce_flags
op_or_assign
id|CE_VALID
suffix:semicolon
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|st-&gt;st_mode
)paren
)paren
id|ce_mark_uptodate
c_func
(paren
id|ce
)paren
suffix:semicolon
)brace
DECL|function|ce_compare_data
r_static
r_int
id|ce_compare_data
c_func
(paren
r_struct
id|cache_entry
op_star
id|ce
comma
r_struct
id|stat
op_star
id|st
)paren
(brace
r_int
id|match
op_assign
l_int|1
suffix:semicolon
r_int
id|fd
op_assign
id|open
c_func
(paren
id|ce-&gt;name
comma
id|O_RDONLY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
op_ge
l_int|0
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|index_fd
c_func
(paren
id|sha1
comma
id|fd
comma
id|st
comma
l_int|0
comma
id|OBJ_BLOB
comma
id|ce-&gt;name
)paren
)paren
id|match
op_assign
id|hashcmp
c_func
(paren
id|sha1
comma
id|ce-&gt;sha1
)paren
suffix:semicolon
multiline_comment|/* index_fd() closed the file descriptor already */
)brace
r_return
id|match
suffix:semicolon
)brace
DECL|function|ce_compare_link
r_static
r_int
id|ce_compare_link
c_func
(paren
r_struct
id|cache_entry
op_star
id|ce
comma
r_int
id|expected_size
)paren
(brace
r_int
id|match
op_assign
l_int|1
suffix:semicolon
r_char
op_star
id|target
suffix:semicolon
r_void
op_star
id|buffer
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_enum
id|object_type
id|type
suffix:semicolon
r_int
id|len
suffix:semicolon
id|target
op_assign
id|xmalloc
c_func
(paren
id|expected_size
)paren
suffix:semicolon
id|len
op_assign
id|readlink
c_func
(paren
id|ce-&gt;name
comma
id|target
comma
id|expected_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
id|expected_size
)paren
(brace
id|free
c_func
(paren
id|target
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|buffer
op_assign
id|read_sha1_file
c_func
(paren
id|ce-&gt;sha1
comma
op_amp
id|type
comma
op_amp
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer
)paren
(brace
id|free
c_func
(paren
id|target
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|size
op_eq
id|expected_size
)paren
id|match
op_assign
id|memcmp
c_func
(paren
id|buffer
comma
id|target
comma
id|size
)paren
suffix:semicolon
id|free
c_func
(paren
id|buffer
)paren
suffix:semicolon
id|free
c_func
(paren
id|target
)paren
suffix:semicolon
r_return
id|match
suffix:semicolon
)brace
DECL|function|ce_compare_gitlink
r_static
r_int
id|ce_compare_gitlink
c_func
(paren
r_struct
id|cache_entry
op_star
id|ce
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * We don&squot;t actually require that the .git directory&n;&t; * under GITLINK directory be a valid git directory. It&n;&t; * might even be missing (in case nobody populated that&n;&t; * sub-project).&n;&t; *&n;&t; * If so, we consider it always to match.&n;&t; */
r_if
c_cond
(paren
id|resolve_gitlink_ref
c_func
(paren
id|ce-&gt;name
comma
l_string|&quot;HEAD&quot;
comma
id|sha1
)paren
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|hashcmp
c_func
(paren
id|sha1
comma
id|ce-&gt;sha1
)paren
suffix:semicolon
)brace
DECL|function|ce_modified_check_fs
r_static
r_int
id|ce_modified_check_fs
c_func
(paren
r_struct
id|cache_entry
op_star
id|ce
comma
r_struct
id|stat
op_star
id|st
)paren
(brace
r_switch
c_cond
(paren
id|st-&gt;st_mode
op_amp
id|S_IFMT
)paren
(brace
r_case
id|S_IFREG
suffix:colon
r_if
c_cond
(paren
id|ce_compare_data
c_func
(paren
id|ce
comma
id|st
)paren
)paren
r_return
id|DATA_CHANGED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_IFLNK
suffix:colon
r_if
c_cond
(paren
id|ce_compare_link
c_func
(paren
id|ce
comma
id|xsize_t
c_func
(paren
id|st-&gt;st_size
)paren
)paren
)paren
r_return
id|DATA_CHANGED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_IFDIR
suffix:colon
r_if
c_cond
(paren
id|S_ISGITLINK
c_func
(paren
id|ce-&gt;ce_mode
)paren
)paren
r_return
id|ce_compare_gitlink
c_func
(paren
id|ce
)paren
ques
c_cond
id|DATA_CHANGED
suffix:colon
l_int|0
suffix:semicolon
r_default
suffix:colon
r_return
id|TYPE_CHANGED
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|is_empty_blob_sha1
r_static
r_int
id|is_empty_blob_sha1
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_static
r_const
r_int
r_char
id|empty_blob_sha1
(braket
l_int|20
)braket
op_assign
(brace
l_int|0xe6
comma
l_int|0x9d
comma
l_int|0xe2
comma
l_int|0x9b
comma
l_int|0xb2
comma
l_int|0xd1
comma
l_int|0xd6
comma
l_int|0x43
comma
l_int|0x4b
comma
l_int|0x8b
comma
l_int|0x29
comma
l_int|0xae
comma
l_int|0x77
comma
l_int|0x5a
comma
l_int|0xd8
comma
l_int|0xc2
comma
l_int|0xe4
comma
l_int|0x8c
comma
l_int|0x53
comma
l_int|0x91
)brace
suffix:semicolon
r_return
op_logical_neg
id|hashcmp
c_func
(paren
id|sha1
comma
id|empty_blob_sha1
)paren
suffix:semicolon
)brace
DECL|function|ce_match_stat_basic
r_static
r_int
id|ce_match_stat_basic
c_func
(paren
r_struct
id|cache_entry
op_star
id|ce
comma
r_struct
id|stat
op_star
id|st
)paren
(brace
r_int
r_int
id|changed
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ce-&gt;ce_flags
op_amp
id|CE_REMOVE
)paren
r_return
id|MODE_CHANGED
op_or
id|DATA_CHANGED
op_or
id|TYPE_CHANGED
suffix:semicolon
r_switch
c_cond
(paren
id|ce-&gt;ce_mode
op_amp
id|S_IFMT
)paren
(brace
r_case
id|S_IFREG
suffix:colon
id|changed
op_or_assign
op_logical_neg
id|S_ISREG
c_func
(paren
id|st-&gt;st_mode
)paren
ques
c_cond
id|TYPE_CHANGED
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* We consider only the owner x bit to be relevant for&n;&t;&t; * &quot;mode changes&quot;&n;&t;&t; */
r_if
c_cond
(paren
id|trust_executable_bit
op_logical_and
(paren
l_int|0100
op_amp
(paren
id|ce-&gt;ce_mode
op_xor
id|st-&gt;st_mode
)paren
)paren
)paren
id|changed
op_or_assign
id|MODE_CHANGED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_IFLNK
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|S_ISLNK
c_func
(paren
id|st-&gt;st_mode
)paren
op_logical_and
(paren
id|has_symlinks
op_logical_or
op_logical_neg
id|S_ISREG
c_func
(paren
id|st-&gt;st_mode
)paren
)paren
)paren
id|changed
op_or_assign
id|TYPE_CHANGED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_IFGITLINK
suffix:colon
multiline_comment|/* We ignore most of the st_xxx fields for gitlinks */
r_if
c_cond
(paren
op_logical_neg
id|S_ISDIR
c_func
(paren
id|st-&gt;st_mode
)paren
)paren
id|changed
op_or_assign
id|TYPE_CHANGED
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ce_compare_gitlink
c_func
(paren
id|ce
)paren
)paren
id|changed
op_or_assign
id|DATA_CHANGED
suffix:semicolon
r_return
id|changed
suffix:semicolon
r_default
suffix:colon
id|die
c_func
(paren
l_string|&quot;internal error: ce_mode is %o&quot;
comma
id|ce-&gt;ce_mode
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ce-&gt;ce_mtime
op_ne
(paren
r_int
r_int
)paren
id|st-&gt;st_mtime
)paren
id|changed
op_or_assign
id|MTIME_CHANGED
suffix:semicolon
r_if
c_cond
(paren
id|trust_ctime
op_logical_and
id|ce-&gt;ce_ctime
op_ne
(paren
r_int
r_int
)paren
id|st-&gt;st_ctime
)paren
id|changed
op_or_assign
id|CTIME_CHANGED
suffix:semicolon
r_if
c_cond
(paren
id|ce-&gt;ce_uid
op_ne
(paren
r_int
r_int
)paren
id|st-&gt;st_uid
op_logical_or
id|ce-&gt;ce_gid
op_ne
(paren
r_int
r_int
)paren
id|st-&gt;st_gid
)paren
id|changed
op_or_assign
id|OWNER_CHANGED
suffix:semicolon
r_if
c_cond
(paren
id|ce-&gt;ce_ino
op_ne
(paren
r_int
r_int
)paren
id|st-&gt;st_ino
)paren
id|changed
op_or_assign
id|INODE_CHANGED
suffix:semicolon
macro_line|#ifdef USE_STDEV
multiline_comment|/*&n;&t; * st_dev breaks on network filesystems where different&n;&t; * clients will have different views of what &quot;device&quot;&n;&t; * the filesystem is on&n;&t; */
r_if
c_cond
(paren
id|ce-&gt;ce_dev
op_ne
(paren
r_int
r_int
)paren
id|st-&gt;st_dev
)paren
id|changed
op_or_assign
id|INODE_CHANGED
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|ce-&gt;ce_size
op_ne
(paren
r_int
r_int
)paren
id|st-&gt;st_size
)paren
id|changed
op_or_assign
id|DATA_CHANGED
suffix:semicolon
multiline_comment|/* Racily smudged entry? */
r_if
c_cond
(paren
op_logical_neg
id|ce-&gt;ce_size
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|is_empty_blob_sha1
c_func
(paren
id|ce-&gt;sha1
)paren
)paren
id|changed
op_or_assign
id|DATA_CHANGED
suffix:semicolon
)brace
r_return
id|changed
suffix:semicolon
)brace
DECL|function|is_racy_timestamp
r_static
r_int
id|is_racy_timestamp
c_func
(paren
r_const
r_struct
id|index_state
op_star
id|istate
comma
r_struct
id|cache_entry
op_star
id|ce
)paren
(brace
r_return
(paren
op_logical_neg
id|S_ISGITLINK
c_func
(paren
id|ce-&gt;ce_mode
)paren
op_logical_and
id|istate-&gt;timestamp
op_logical_and
(paren
(paren
r_int
r_int
)paren
id|istate-&gt;timestamp
)paren
op_le
id|ce-&gt;ce_mtime
)paren
suffix:semicolon
)brace
DECL|function|ie_match_stat
r_int
id|ie_match_stat
c_func
(paren
r_const
r_struct
id|index_state
op_star
id|istate
comma
r_struct
id|cache_entry
op_star
id|ce
comma
r_struct
id|stat
op_star
id|st
comma
r_int
r_int
id|options
)paren
(brace
r_int
r_int
id|changed
suffix:semicolon
r_int
id|ignore_valid
op_assign
id|options
op_amp
id|CE_MATCH_IGNORE_VALID
suffix:semicolon
r_int
id|assume_racy_is_modified
op_assign
id|options
op_amp
id|CE_MATCH_RACY_IS_DIRTY
suffix:semicolon
multiline_comment|/*&n;&t; * If it&squot;s marked as always valid in the index, it&squot;s&n;&t; * valid whatever the checked-out copy says.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ignore_valid
op_logical_and
(paren
id|ce-&gt;ce_flags
op_amp
id|CE_VALID
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|changed
op_assign
id|ce_match_stat_basic
c_func
(paren
id|ce
comma
id|st
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Within 1 second of this sequence:&n;&t; * &t;echo xyzzy &gt;file &amp;&amp; git-update-index --add file&n;&t; * running this command:&n;&t; * &t;echo frotz &gt;file&n;&t; * would give a falsely clean cache entry.  The mtime and&n;&t; * length match the cache, and other stat fields do not change.&n;&t; *&n;&t; * We could detect this at update-index time (the cache entry&n;&t; * being registered/updated records the same time as &quot;now&quot;)&n;&t; * and delay the return from git-update-index, but that would&n;&t; * effectively mean we can make at most one commit per second,&n;&t; * which is not acceptable.  Instead, we check cache entries&n;&t; * whose mtime are the same as the index file timestamp more&n;&t; * carefully than others.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|changed
op_logical_and
id|is_racy_timestamp
c_func
(paren
id|istate
comma
id|ce
)paren
)paren
(brace
r_if
c_cond
(paren
id|assume_racy_is_modified
)paren
id|changed
op_or_assign
id|DATA_CHANGED
suffix:semicolon
r_else
id|changed
op_or_assign
id|ce_modified_check_fs
c_func
(paren
id|ce
comma
id|st
)paren
suffix:semicolon
)brace
r_return
id|changed
suffix:semicolon
)brace
DECL|function|ie_modified
r_int
id|ie_modified
c_func
(paren
r_const
r_struct
id|index_state
op_star
id|istate
comma
r_struct
id|cache_entry
op_star
id|ce
comma
r_struct
id|stat
op_star
id|st
comma
r_int
r_int
id|options
)paren
(brace
r_int
id|changed
comma
id|changed_fs
suffix:semicolon
id|changed
op_assign
id|ie_match_stat
c_func
(paren
id|istate
comma
id|ce
comma
id|st
comma
id|options
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|changed
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If the mode or type has changed, there&squot;s no point in trying&n;&t; * to refresh the entry - it&squot;s not going to match&n;&t; */
r_if
c_cond
(paren
id|changed
op_amp
(paren
id|MODE_CHANGED
op_or
id|TYPE_CHANGED
)paren
)paren
r_return
id|changed
suffix:semicolon
multiline_comment|/*&n;&t; * Immediately after read-tree or update-index --cacheinfo,&n;&t; * the length field is zero, as we have never even read the&n;&t; * lstat(2) information once, and we cannot trust DATA_CHANGED&n;&t; * returned by ie_match_stat() which in turn was returned by&n;&t; * ce_match_stat_basic() to signal that the filesize of the&n;&t; * blob changed.  We have to actually go to the filesystem to&n;&t; * see if the contents match, and if so, should answer &quot;unchanged&quot;.&n;&t; *&n;&t; * The logic does not apply to gitlinks, as ce_match_stat_basic()&n;&t; * already has checked the actual HEAD from the filesystem in the&n;&t; * subproject.  If ie_match_stat() already said it is different,&n;&t; * then we know it is.&n;&t; */
r_if
c_cond
(paren
(paren
id|changed
op_amp
id|DATA_CHANGED
)paren
op_logical_and
(paren
id|S_ISGITLINK
c_func
(paren
id|ce-&gt;ce_mode
)paren
op_logical_or
id|ce-&gt;ce_size
op_ne
l_int|0
)paren
)paren
r_return
id|changed
suffix:semicolon
id|changed_fs
op_assign
id|ce_modified_check_fs
c_func
(paren
id|ce
comma
id|st
)paren
suffix:semicolon
r_if
c_cond
(paren
id|changed_fs
)paren
r_return
id|changed
op_or
id|changed_fs
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|base_name_compare
r_int
id|base_name_compare
c_func
(paren
r_const
r_char
op_star
id|name1
comma
r_int
id|len1
comma
r_int
id|mode1
comma
r_const
r_char
op_star
id|name2
comma
r_int
id|len2
comma
r_int
id|mode2
)paren
(brace
r_int
r_char
id|c1
comma
id|c2
suffix:semicolon
r_int
id|len
op_assign
id|len1
OL
id|len2
ques
c_cond
id|len1
suffix:colon
id|len2
suffix:semicolon
r_int
id|cmp
suffix:semicolon
id|cmp
op_assign
id|memcmp
c_func
(paren
id|name1
comma
id|name2
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmp
)paren
r_return
id|cmp
suffix:semicolon
id|c1
op_assign
id|name1
(braket
id|len
)braket
suffix:semicolon
id|c2
op_assign
id|name2
(braket
id|len
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c1
op_logical_and
id|S_ISDIR
c_func
(paren
id|mode1
)paren
)paren
id|c1
op_assign
l_char|&squot;/&squot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c2
op_logical_and
id|S_ISDIR
c_func
(paren
id|mode2
)paren
)paren
id|c2
op_assign
l_char|&squot;/&squot;
suffix:semicolon
r_return
(paren
id|c1
OL
id|c2
)paren
ques
c_cond
l_int|1
suffix:colon
(paren
id|c1
OG
id|c2
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * df_name_compare() is identical to base_name_compare(), except it&n; * compares conflicting directory/file entries as equal. Note that&n; * while a directory name compares as equal to a regular file, they&n; * then individually compare _differently_ to a filename that has&n; * a dot after the basename (because &squot;&bslash;0&squot; &lt; &squot;.&squot; &lt; &squot;/&squot;).&n; *&n; * This is used by routines that want to traverse the git namespace&n; * but then handle conflicting entries together when possible.&n; */
DECL|function|df_name_compare
r_int
id|df_name_compare
c_func
(paren
r_const
r_char
op_star
id|name1
comma
r_int
id|len1
comma
r_int
id|mode1
comma
r_const
r_char
op_star
id|name2
comma
r_int
id|len2
comma
r_int
id|mode2
)paren
(brace
r_int
id|len
op_assign
id|len1
OL
id|len2
ques
c_cond
id|len1
suffix:colon
id|len2
comma
id|cmp
suffix:semicolon
r_int
r_char
id|c1
comma
id|c2
suffix:semicolon
id|cmp
op_assign
id|memcmp
c_func
(paren
id|name1
comma
id|name2
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmp
)paren
r_return
id|cmp
suffix:semicolon
multiline_comment|/* Directories and files compare equal (same length, same name) */
r_if
c_cond
(paren
id|len1
op_eq
id|len2
)paren
r_return
l_int|0
suffix:semicolon
id|c1
op_assign
id|name1
(braket
id|len
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c1
op_logical_and
id|S_ISDIR
c_func
(paren
id|mode1
)paren
)paren
id|c1
op_assign
l_char|&squot;/&squot;
suffix:semicolon
id|c2
op_assign
id|name2
(braket
id|len
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c2
op_logical_and
id|S_ISDIR
c_func
(paren
id|mode2
)paren
)paren
id|c2
op_assign
l_char|&squot;/&squot;
suffix:semicolon
r_if
c_cond
(paren
id|c1
op_eq
l_char|&squot;/&squot;
op_logical_and
op_logical_neg
id|c2
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|c2
op_eq
l_char|&squot;/&squot;
op_logical_and
op_logical_neg
id|c1
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|c1
id|c2
suffix:semicolon
)brace
DECL|function|cache_name_compare
r_int
id|cache_name_compare
c_func
(paren
r_const
r_char
op_star
id|name1
comma
r_int
id|flags1
comma
r_const
r_char
op_star
id|name2
comma
r_int
id|flags2
)paren
(brace
r_int
id|len1
op_assign
id|flags1
op_amp
id|CE_NAMEMASK
suffix:semicolon
r_int
id|len2
op_assign
id|flags2
op_amp
id|CE_NAMEMASK
suffix:semicolon
r_int
id|len
op_assign
id|len1
OL
id|len2
ques
c_cond
id|len1
suffix:colon
id|len2
suffix:semicolon
r_int
id|cmp
suffix:semicolon
id|cmp
op_assign
id|memcmp
c_func
(paren
id|name1
comma
id|name2
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmp
)paren
r_return
id|cmp
suffix:semicolon
r_if
c_cond
(paren
id|len1
OL
id|len2
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|len1
OG
id|len2
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Compare stages  */
id|flags1
op_and_assign
id|CE_STAGEMASK
suffix:semicolon
id|flags2
op_and_assign
id|CE_STAGEMASK
suffix:semicolon
r_if
c_cond
(paren
id|flags1
OL
id|flags2
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|flags1
OG
id|flags2
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|index_name_pos
r_int
id|index_name_pos
c_func
(paren
r_const
r_struct
id|index_state
op_star
id|istate
comma
r_const
r_char
op_star
id|name
comma
r_int
id|namelen
)paren
(brace
r_int
id|first
comma
id|last
suffix:semicolon
id|first
op_assign
l_int|0
suffix:semicolon
id|last
op_assign
id|istate-&gt;cache_nr
suffix:semicolon
r_while
c_loop
(paren
id|last
OG
id|first
)paren
(brace
r_int
id|next
op_assign
(paren
id|last
op_plus
id|first
)paren
op_rshift
l_int|1
suffix:semicolon
r_struct
id|cache_entry
op_star
id|ce
op_assign
id|istate-&gt;cache
(braket
id|next
)braket
suffix:semicolon
r_int
id|cmp
op_assign
id|cache_name_compare
c_func
(paren
id|name
comma
id|namelen
comma
id|ce-&gt;name
comma
id|ce-&gt;ce_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmp
)paren
r_return
id|next
suffix:semicolon
r_if
c_cond
(paren
id|cmp
OL
l_int|0
)paren
(brace
id|last
op_assign
id|next
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|first
op_assign
id|next
op_plus
l_int|1
suffix:semicolon
)brace
r_return
id|first
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Remove entry, return true if there are more entries to go.. */
DECL|function|remove_index_entry_at
r_int
id|remove_index_entry_at
c_func
(paren
r_struct
id|index_state
op_star
id|istate
comma
r_int
id|pos
)paren
(brace
r_struct
id|cache_entry
op_star
id|ce
op_assign
id|istate-&gt;cache
(braket
id|pos
)braket
suffix:semicolon
id|remove_name_hash
c_func
(paren
id|ce
)paren
suffix:semicolon
id|istate-&gt;cache_changed
op_assign
l_int|1
suffix:semicolon
id|istate-&gt;cache_nr
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_ge
id|istate-&gt;cache_nr
)paren
r_return
l_int|0
suffix:semicolon
id|memmove
c_func
(paren
id|istate-&gt;cache
op_plus
id|pos
comma
id|istate-&gt;cache
op_plus
id|pos
op_plus
l_int|1
comma
(paren
id|istate-&gt;cache_nr
id|pos
)paren
op_star
r_sizeof
(paren
r_struct
id|cache_entry
op_star
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|remove_file_from_index
r_int
id|remove_file_from_index
c_func
(paren
r_struct
id|index_state
op_star
id|istate
comma
r_const
r_char
op_star
id|path
)paren
(brace
r_int
id|pos
op_assign
id|index_name_pos
c_func
(paren
id|istate
comma
id|path
comma
id|strlen
c_func
(paren
id|path
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
l_int|0
)paren
id|pos
op_assign
id|pos
op_minus
l_int|1
suffix:semicolon
id|cache_tree_invalidate_path
c_func
(paren
id|istate-&gt;cache_tree
comma
id|path
)paren
suffix:semicolon
r_while
c_loop
(paren
id|pos
OL
id|istate-&gt;cache_nr
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|istate-&gt;cache
(braket
id|pos
)braket
op_member_access_from_pointer
id|name
comma
id|path
)paren
)paren
id|remove_index_entry_at
c_func
(paren
id|istate
comma
id|pos
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|compare_name
r_static
r_int
id|compare_name
c_func
(paren
r_struct
id|cache_entry
op_star
id|ce
comma
r_const
r_char
op_star
id|path
comma
r_int
id|namelen
)paren
(brace
r_return
id|namelen
op_ne
id|ce_namelen
c_func
(paren
id|ce
)paren
op_logical_or
id|memcmp
c_func
(paren
id|path
comma
id|ce-&gt;name
comma
id|namelen
)paren
suffix:semicolon
)brace
DECL|function|index_name_pos_also_unmerged
r_static
r_int
id|index_name_pos_also_unmerged
c_func
(paren
r_struct
id|index_state
op_star
id|istate
comma
r_const
r_char
op_star
id|path
comma
r_int
id|namelen
)paren
(brace
r_int
id|pos
op_assign
id|index_name_pos
c_func
(paren
id|istate
comma
id|path
comma
id|namelen
)paren
suffix:semicolon
r_struct
id|cache_entry
op_star
id|ce
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_ge
l_int|0
)paren
r_return
id|pos
suffix:semicolon
multiline_comment|/* maybe unmerged? */
id|pos
op_assign
l_int|1
id|pos
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_ge
id|istate-&gt;cache_nr
op_logical_or
id|compare_name
c_func
(paren
(paren
id|ce
op_assign
id|istate-&gt;cache
(braket
id|pos
)braket
)paren
comma
id|path
comma
id|namelen
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* order of preference: stage 2, 1, 3 */
r_if
c_cond
(paren
id|ce_stage
c_func
(paren
id|ce
)paren
op_eq
l_int|1
op_logical_and
id|pos
op_plus
l_int|1
OL
id|istate-&gt;cache_nr
op_logical_and
id|ce_stage
c_func
(paren
(paren
id|ce
op_assign
id|istate-&gt;cache
(braket
id|pos
op_plus
l_int|1
)braket
)paren
)paren
op_eq
l_int|2
op_logical_and
op_logical_neg
id|compare_name
c_func
(paren
id|ce
comma
id|path
comma
id|namelen
)paren
)paren
id|pos
op_increment
suffix:semicolon
r_return
id|pos
suffix:semicolon
)brace
DECL|function|different_name
r_static
r_int
id|different_name
c_func
(paren
r_struct
id|cache_entry
op_star
id|ce
comma
r_struct
id|cache_entry
op_star
id|alias
)paren
(brace
r_int
id|len
op_assign
id|ce_namelen
c_func
(paren
id|ce
)paren
suffix:semicolon
r_return
id|ce_namelen
c_func
(paren
id|alias
)paren
op_ne
id|len
op_logical_or
id|memcmp
c_func
(paren
id|ce-&gt;name
comma
id|alias-&gt;name
comma
id|len
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * If we add a filename that aliases in the cache, we will use the&n; * name that we already have - but we don&squot;t want to update the same&n; * alias twice, because that implies that there were actually two&n; * different files with aliasing names!&n; *&n; * So we use the CE_ADDED flag to verify that the alias was an old&n; * one before we accept it as&n; */
DECL|function|create_alias_ce
r_static
r_struct
id|cache_entry
op_star
id|create_alias_ce
c_func
(paren
r_struct
id|cache_entry
op_star
id|ce
comma
r_struct
id|cache_entry
op_star
id|alias
)paren
(brace
r_int
id|len
suffix:semicolon
r_struct
id|cache_entry
op_star
r_new
suffix:semicolon
r_if
c_cond
(paren
id|alias-&gt;ce_flags
op_amp
id|CE_ADDED
)paren
id|die
c_func
(paren
l_string|&quot;Will not add file alias &squot;%s&squot; (&squot;%s&squot; already exists in index)&quot;
comma
id|ce-&gt;name
comma
id|alias-&gt;name
)paren
suffix:semicolon
multiline_comment|/* Ok, create the new entry using the name of the existing alias */
id|len
op_assign
id|ce_namelen
c_func
(paren
id|alias
)paren
suffix:semicolon
r_new
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
id|cache_entry_size
c_func
(paren
id|len
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
r_new
op_member_access_from_pointer
id|name
comma
id|alias-&gt;name
comma
id|len
)paren
suffix:semicolon
id|copy_cache_entry
c_func
(paren
r_new
comma
id|ce
)paren
suffix:semicolon
id|free
c_func
(paren
id|ce
)paren
suffix:semicolon
r_return
r_new
suffix:semicolon
)brace
DECL|function|add_to_index
r_int
id|add_to_index
c_func
(paren
r_struct
id|index_state
op_star
id|istate
comma
r_const
r_char
op_star
id|path
comma
r_struct
id|stat
op_star
id|st
comma
r_int
id|flags
)paren
(brace
r_int
id|size
comma
id|namelen
comma
id|was_same
suffix:semicolon
id|mode_t
id|st_mode
op_assign
id|st-&gt;st_mode
suffix:semicolon
r_struct
id|cache_entry
op_star
id|ce
comma
op_star
id|alias
suffix:semicolon
r_int
id|ce_option
op_assign
id|CE_MATCH_IGNORE_VALID
op_or
id|CE_MATCH_RACY_IS_DIRTY
suffix:semicolon
r_int
id|verbose
op_assign
id|flags
op_amp
(paren
id|ADD_CACHE_VERBOSE
op_or
id|ADD_CACHE_PRETEND
)paren
suffix:semicolon
r_int
id|pretend
op_assign
id|flags
op_amp
id|ADD_CACHE_PRETEND
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISREG
c_func
(paren
id|st_mode
)paren
op_logical_and
op_logical_neg
id|S_ISLNK
c_func
(paren
id|st_mode
)paren
op_logical_and
op_logical_neg
id|S_ISDIR
c_func
(paren
id|st_mode
)paren
)paren
r_return
id|error
c_func
(paren
l_string|&quot;%s: can only add regular files, symbolic links or git-directories&quot;
comma
id|path
)paren
suffix:semicolon
id|namelen
op_assign
id|strlen
c_func
(paren
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|st_mode
)paren
)paren
(brace
r_while
c_loop
(paren
id|namelen
op_logical_and
id|path
(braket
id|namelen
op_minus
l_int|1
)braket
op_eq
l_char|&squot;/&squot;
)paren
id|namelen
op_decrement
suffix:semicolon
)brace
id|size
op_assign
id|cache_entry_size
c_func
(paren
id|namelen
)paren
suffix:semicolon
id|ce
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
id|size
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ce-&gt;name
comma
id|path
comma
id|namelen
)paren
suffix:semicolon
id|ce-&gt;ce_flags
op_assign
id|namelen
suffix:semicolon
id|fill_stat_cache_info
c_func
(paren
id|ce
comma
id|st
)paren
suffix:semicolon
r_if
c_cond
(paren
id|trust_executable_bit
op_logical_and
id|has_symlinks
)paren
id|ce-&gt;ce_mode
op_assign
id|create_ce_mode
c_func
(paren
id|st_mode
)paren
suffix:semicolon
r_else
(brace
multiline_comment|/* If there is an existing entry, pick the mode bits and type&n;&t;&t; * from it, otherwise assume unexecutable regular file.&n;&t;&t; */
r_struct
id|cache_entry
op_star
id|ent
suffix:semicolon
r_int
id|pos
op_assign
id|index_name_pos_also_unmerged
c_func
(paren
id|istate
comma
id|path
comma
id|namelen
)paren
suffix:semicolon
id|ent
op_assign
(paren
l_int|0
op_le
id|pos
)paren
ques
c_cond
id|istate-&gt;cache
(braket
id|pos
)braket
suffix:colon
l_int|NULL
suffix:semicolon
id|ce-&gt;ce_mode
op_assign
id|ce_mode_from_stat
c_func
(paren
id|ent
comma
id|st_mode
)paren
suffix:semicolon
)brace
id|alias
op_assign
id|index_name_exists
c_func
(paren
id|istate
comma
id|ce-&gt;name
comma
id|ce_namelen
c_func
(paren
id|ce
)paren
comma
id|ignore_case
)paren
suffix:semicolon
r_if
c_cond
(paren
id|alias
op_logical_and
op_logical_neg
id|ce_stage
c_func
(paren
id|alias
)paren
op_logical_and
op_logical_neg
id|ie_match_stat
c_func
(paren
id|istate
comma
id|alias
comma
id|st
comma
id|ce_option
)paren
)paren
(brace
multiline_comment|/* Nothing changed, really */
id|free
c_func
(paren
id|ce
)paren
suffix:semicolon
id|ce_mark_uptodate
c_func
(paren
id|alias
)paren
suffix:semicolon
id|alias-&gt;ce_flags
op_or_assign
id|CE_ADDED
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|index_path
c_func
(paren
id|ce-&gt;sha1
comma
id|path
comma
id|st
comma
l_int|1
)paren
)paren
r_return
id|error
c_func
(paren
l_string|&quot;unable to index file %s&quot;
comma
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ignore_case
op_logical_and
id|alias
op_logical_and
id|different_name
c_func
(paren
id|ce
comma
id|alias
)paren
)paren
id|ce
op_assign
id|create_alias_ce
c_func
(paren
id|ce
comma
id|alias
)paren
suffix:semicolon
id|ce-&gt;ce_flags
op_or_assign
id|CE_ADDED
suffix:semicolon
multiline_comment|/* It was suspected to be racily clean, but it turns out to be Ok */
id|was_same
op_assign
(paren
id|alias
op_logical_and
op_logical_neg
id|ce_stage
c_func
(paren
id|alias
)paren
op_logical_and
op_logical_neg
id|hashcmp
c_func
(paren
id|alias-&gt;sha1
comma
id|ce-&gt;sha1
)paren
op_logical_and
id|ce-&gt;ce_mode
op_eq
id|alias-&gt;ce_mode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pretend
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|add_index_entry
c_func
(paren
id|istate
comma
id|ce
comma
id|ADD_CACHE_OK_TO_ADD
op_or
id|ADD_CACHE_OK_TO_REPLACE
)paren
)paren
r_return
id|error
c_func
(paren
l_string|&quot;unable to add %s to index&quot;
comma
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|verbose
op_logical_and
op_logical_neg
id|was_same
)paren
id|printf
c_func
(paren
l_string|&quot;add &squot;%s&squot;&bslash;n&quot;
comma
id|path
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|add_file_to_index
r_int
id|add_file_to_index
c_func
(paren
r_struct
id|index_state
op_star
id|istate
comma
r_const
r_char
op_star
id|path
comma
r_int
id|flags
)paren
(brace
r_struct
id|stat
id|st
suffix:semicolon
r_if
c_cond
(paren
id|lstat
c_func
(paren
id|path
comma
op_amp
id|st
)paren
)paren
id|die
c_func
(paren
l_string|&quot;%s: unable to stat (%s)&quot;
comma
id|path
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_return
id|add_to_index
c_func
(paren
id|istate
comma
id|path
comma
op_amp
id|st
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|make_cache_entry
r_struct
id|cache_entry
op_star
id|make_cache_entry
c_func
(paren
r_int
r_int
id|mode
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_const
r_char
op_star
id|path
comma
r_int
id|stage
comma
r_int
id|refresh
)paren
(brace
r_int
id|size
comma
id|len
suffix:semicolon
r_struct
id|cache_entry
op_star
id|ce
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|verify_path
c_func
(paren
id|path
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|path
)paren
suffix:semicolon
id|size
op_assign
id|cache_entry_size
c_func
(paren
id|len
)paren
suffix:semicolon
id|ce
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
id|size
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|ce-&gt;sha1
comma
id|sha1
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ce-&gt;name
comma
id|path
comma
id|len
)paren
suffix:semicolon
id|ce-&gt;ce_flags
op_assign
id|create_ce_flags
c_func
(paren
id|len
comma
id|stage
)paren
suffix:semicolon
id|ce-&gt;ce_mode
op_assign
id|create_ce_mode
c_func
(paren
id|mode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|refresh
)paren
r_return
id|refresh_cache_entry
c_func
(paren
id|ce
comma
l_int|0
)paren
suffix:semicolon
r_return
id|ce
suffix:semicolon
)brace
DECL|function|ce_same_name
r_int
id|ce_same_name
c_func
(paren
r_struct
id|cache_entry
op_star
id|a
comma
r_struct
id|cache_entry
op_star
id|b
)paren
(brace
r_int
id|len
op_assign
id|ce_namelen
c_func
(paren
id|a
)paren
suffix:semicolon
r_return
id|ce_namelen
c_func
(paren
id|b
)paren
op_eq
id|len
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|a-&gt;name
comma
id|b-&gt;name
comma
id|len
)paren
suffix:semicolon
)brace
DECL|function|ce_path_match
r_int
id|ce_path_match
c_func
(paren
r_const
r_struct
id|cache_entry
op_star
id|ce
comma
r_const
r_char
op_star
op_star
id|pathspec
)paren
(brace
r_const
r_char
op_star
id|match
comma
op_star
id|name
suffix:semicolon
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pathspec
)paren
r_return
l_int|1
suffix:semicolon
id|len
op_assign
id|ce_namelen
c_func
(paren
id|ce
)paren
suffix:semicolon
id|name
op_assign
id|ce-&gt;name
suffix:semicolon
r_while
c_loop
(paren
(paren
id|match
op_assign
op_star
id|pathspec
op_increment
)paren
op_ne
l_int|NULL
)paren
(brace
r_int
id|matchlen
op_assign
id|strlen
c_func
(paren
id|match
)paren
suffix:semicolon
r_if
c_cond
(paren
id|matchlen
OG
id|len
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|name
comma
id|match
comma
id|matchlen
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|matchlen
op_logical_and
id|name
(braket
id|matchlen
op_minus
l_int|1
)braket
op_eq
l_char|&squot;/&squot;
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|name
(braket
id|matchlen
)braket
op_eq
l_char|&squot;/&squot;
op_logical_or
op_logical_neg
id|name
(braket
id|matchlen
)braket
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|matchlen
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * We fundamentally don&squot;t like some paths: we don&squot;t want&n; * dot or dot-dot anywhere, and for obvious reasons don&squot;t&n; * want to recurse into &quot;.git&quot; either.&n; *&n; * Also, we don&squot;t want double slashes or slashes at the&n; * end that can make pathnames ambiguous.&n; */
DECL|function|verify_dotfile
r_static
r_int
id|verify_dotfile
c_func
(paren
r_const
r_char
op_star
id|rest
)paren
(brace
multiline_comment|/*&n;&t; * The first character was &squot;.&squot;, but that&n;&t; * has already been discarded, we now test&n;&t; * the rest.&n;&t; */
r_switch
c_cond
(paren
op_star
id|rest
)paren
(brace
multiline_comment|/* &quot;.&quot; is not allowed */
r_case
l_char|&squot;&bslash;0&squot;
suffix:colon
r_case
l_char|&squot;/&squot;
suffix:colon
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * &quot;.git&quot; followed by  NUL or slash is bad. This&n;&t; * shares the path end test with the &quot;..&quot; case.&n;&t; */
r_case
l_char|&squot;g&squot;
suffix:colon
r_if
c_cond
(paren
id|rest
(braket
l_int|1
)braket
op_ne
l_char|&squot;i&squot;
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|rest
(braket
l_int|2
)braket
op_ne
l_char|&squot;t&squot;
)paren
r_break
suffix:semicolon
id|rest
op_add_assign
l_int|2
suffix:semicolon
multiline_comment|/* fallthrough */
r_case
l_char|&squot;.&squot;
suffix:colon
r_if
c_cond
(paren
id|rest
(braket
l_int|1
)braket
op_eq
l_char|&squot;&bslash;0&squot;
op_logical_or
id|rest
(braket
l_int|1
)braket
op_eq
l_char|&squot;/&squot;
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|verify_path
r_int
id|verify_path
c_func
(paren
r_const
r_char
op_star
id|path
)paren
(brace
r_char
id|c
suffix:semicolon
r_goto
id|inside
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;/&squot;
)paren
(brace
id|inside
suffix:colon
id|c
op_assign
op_star
id|path
op_increment
suffix:semicolon
r_switch
c_cond
(paren
id|c
)paren
(brace
r_default
suffix:colon
r_continue
suffix:semicolon
r_case
l_char|&squot;/&squot;
suffix:colon
r_case
l_char|&squot;&bslash;0&squot;
suffix:colon
r_break
suffix:semicolon
r_case
l_char|&squot;.&squot;
suffix:colon
r_if
c_cond
(paren
id|verify_dotfile
c_func
(paren
id|path
)paren
)paren
r_continue
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|c
op_assign
op_star
id|path
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Do we have another file that has the beginning components being a&n; * proper superset of the name we&squot;re trying to add?&n; */
DECL|function|has_file_name
r_static
r_int
id|has_file_name
c_func
(paren
r_struct
id|index_state
op_star
id|istate
comma
r_const
r_struct
id|cache_entry
op_star
id|ce
comma
r_int
id|pos
comma
r_int
id|ok_to_replace
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_int
id|len
op_assign
id|ce_namelen
c_func
(paren
id|ce
)paren
suffix:semicolon
r_int
id|stage
op_assign
id|ce_stage
c_func
(paren
id|ce
)paren
suffix:semicolon
r_const
r_char
op_star
id|name
op_assign
id|ce-&gt;name
suffix:semicolon
r_while
c_loop
(paren
id|pos
OL
id|istate-&gt;cache_nr
)paren
(brace
r_struct
id|cache_entry
op_star
id|p
op_assign
id|istate-&gt;cache
(braket
id|pos
op_increment
)braket
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ge
id|ce_namelen
c_func
(paren
id|p
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|name
comma
id|p-&gt;name
comma
id|len
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|ce_stage
c_func
(paren
id|p
)paren
op_ne
id|stage
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;name
(braket
id|len
)braket
op_ne
l_char|&squot;/&squot;
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;ce_flags
op_amp
id|CE_REMOVE
)paren
r_continue
suffix:semicolon
id|retval
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ok_to_replace
)paren
r_break
suffix:semicolon
id|remove_index_entry_at
c_func
(paren
id|istate
comma
op_decrement
id|pos
)paren
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Do we have another file with a pathname that is a proper&n; * subset of the name we&squot;re trying to add?&n; */
DECL|function|has_dir_name
r_static
r_int
id|has_dir_name
c_func
(paren
r_struct
id|index_state
op_star
id|istate
comma
r_const
r_struct
id|cache_entry
op_star
id|ce
comma
r_int
id|pos
comma
r_int
id|ok_to_replace
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_int
id|stage
op_assign
id|ce_stage
c_func
(paren
id|ce
)paren
suffix:semicolon
r_const
r_char
op_star
id|name
op_assign
id|ce-&gt;name
suffix:semicolon
r_const
r_char
op_star
id|slash
op_assign
id|name
op_plus
id|ce_namelen
c_func
(paren
id|ce
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|len
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_star
op_decrement
id|slash
op_eq
l_char|&squot;/&squot;
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|slash
op_le
id|ce-&gt;name
)paren
r_return
id|retval
suffix:semicolon
)brace
id|len
op_assign
id|slash
id|name
suffix:semicolon
id|pos
op_assign
id|index_name_pos
c_func
(paren
id|istate
comma
id|name
comma
id|create_ce_flags
c_func
(paren
id|len
comma
id|stage
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_ge
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Found one, but not so fast.  This could&n;&t;&t;&t; * be a marker that says &quot;I was here, but&n;&t;&t;&t; * I am being removed&quot;.  Such an entry is&n;&t;&t;&t; * not a part of the resulting tree, and&n;&t;&t;&t; * it is Ok to have a directory at the same&n;&t;&t;&t; * path.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|istate-&gt;cache
(braket
id|pos
)braket
op_member_access_from_pointer
id|ce_flags
op_amp
id|CE_REMOVE
)paren
)paren
(brace
id|retval
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ok_to_replace
)paren
r_break
suffix:semicolon
id|remove_index_entry_at
c_func
(paren
id|istate
comma
id|pos
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
r_else
id|pos
op_assign
id|pos
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Trivial optimization: if we find an entry that&n;&t;&t; * already matches the sub-directory, then we know&n;&t;&t; * we&squot;re ok, and we can exit.&n;&t;&t; */
r_while
c_loop
(paren
id|pos
OL
id|istate-&gt;cache_nr
)paren
(brace
r_struct
id|cache_entry
op_star
id|p
op_assign
id|istate-&gt;cache
(braket
id|pos
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ce_namelen
c_func
(paren
id|p
)paren
op_le
id|len
)paren
op_logical_or
(paren
id|p-&gt;name
(braket
id|len
)braket
op_ne
l_char|&squot;/&squot;
)paren
op_logical_or
id|memcmp
c_func
(paren
id|p-&gt;name
comma
id|name
comma
id|len
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* not our subdirectory */
r_if
c_cond
(paren
id|ce_stage
c_func
(paren
id|p
)paren
op_eq
id|stage
op_logical_and
op_logical_neg
(paren
id|p-&gt;ce_flags
op_amp
id|CE_REMOVE
)paren
)paren
multiline_comment|/*&n;&t;&t;&t;&t; * p is at the same stage as our entry, and&n;&t;&t;&t;&t; * is a subdirectory of what we are looking&n;&t;&t;&t;&t; * at, so we cannot have conflicts at our&n;&t;&t;&t;&t; * level or anything shorter.&n;&t;&t;&t;&t; */
r_return
id|retval
suffix:semicolon
id|pos
op_increment
suffix:semicolon
)brace
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* We may be in a situation where we already have path/file and path&n; * is being added, or we already have path and path/file is being&n; * added.  Either one would result in a nonsense tree that has path&n; * twice when git-write-tree tries to write it out.  Prevent it.&n; *&n; * If ok-to-replace is specified, we remove the conflicting entries&n; * from the cache so the caller should recompute the insert position.&n; * When this happens, we return non-zero.&n; */
DECL|function|check_file_directory_conflict
r_static
r_int
id|check_file_directory_conflict
c_func
(paren
r_struct
id|index_state
op_star
id|istate
comma
r_const
r_struct
id|cache_entry
op_star
id|ce
comma
r_int
id|pos
comma
r_int
id|ok_to_replace
)paren
(brace
r_int
id|retval
suffix:semicolon
multiline_comment|/*&n;&t; * When ce is an &quot;I am going away&quot; entry, we allow it to be added&n;&t; */
r_if
c_cond
(paren
id|ce-&gt;ce_flags
op_amp
id|CE_REMOVE
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * We check if the path is a sub-path of a subsequent pathname&n;&t; * first, since removing those will not change the position&n;&t; * in the array.&n;&t; */
id|retval
op_assign
id|has_file_name
c_func
(paren
id|istate
comma
id|ce
comma
id|pos
comma
id|ok_to_replace
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Then check if the path might have a clashing sub-directory&n;&t; * before it.&n;&t; */
r_return
id|retval
op_plus
id|has_dir_name
c_func
(paren
id|istate
comma
id|ce
comma
id|pos
comma
id|ok_to_replace
)paren
suffix:semicolon
)brace
DECL|function|add_index_entry_with_check
r_static
r_int
id|add_index_entry_with_check
c_func
(paren
r_struct
id|index_state
op_star
id|istate
comma
r_struct
id|cache_entry
op_star
id|ce
comma
r_int
id|option
)paren
(brace
r_int
id|pos
suffix:semicolon
r_int
id|ok_to_add
op_assign
id|option
op_amp
id|ADD_CACHE_OK_TO_ADD
suffix:semicolon
r_int
id|ok_to_replace
op_assign
id|option
op_amp
id|ADD_CACHE_OK_TO_REPLACE
suffix:semicolon
r_int
id|skip_df_check
op_assign
id|option
op_amp
id|ADD_CACHE_SKIP_DFCHECK
suffix:semicolon
id|cache_tree_invalidate_path
c_func
(paren
id|istate-&gt;cache_tree
comma
id|ce-&gt;name
)paren
suffix:semicolon
id|pos
op_assign
id|index_name_pos
c_func
(paren
id|istate
comma
id|ce-&gt;name
comma
id|ce-&gt;ce_flags
)paren
suffix:semicolon
multiline_comment|/* existing match? Just replace it. */
r_if
c_cond
(paren
id|pos
op_ge
l_int|0
)paren
(brace
id|replace_index_entry
c_func
(paren
id|istate
comma
id|pos
comma
id|ce
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|pos
op_assign
id|pos
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Inserting a merged entry (&quot;stage 0&quot;) into the index&n;&t; * will always replace all non-merged entries..&n;&t; */
r_if
c_cond
(paren
id|pos
OL
id|istate-&gt;cache_nr
op_logical_and
id|ce_stage
c_func
(paren
id|ce
)paren
op_eq
l_int|0
)paren
(brace
r_while
c_loop
(paren
id|ce_same_name
c_func
(paren
id|istate-&gt;cache
(braket
id|pos
)braket
comma
id|ce
)paren
)paren
(brace
id|ok_to_add
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|remove_index_entry_at
c_func
(paren
id|istate
comma
id|pos
)paren
)paren
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|ok_to_add
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|verify_path
c_func
(paren
id|ce-&gt;name
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skip_df_check
op_logical_and
id|check_file_directory_conflict
c_func
(paren
id|istate
comma
id|ce
comma
id|pos
comma
id|ok_to_replace
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ok_to_replace
)paren
r_return
id|error
c_func
(paren
l_string|&quot;&squot;%s&squot; appears as both a file and as a directory&quot;
comma
id|ce-&gt;name
)paren
suffix:semicolon
id|pos
op_assign
id|index_name_pos
c_func
(paren
id|istate
comma
id|ce-&gt;name
comma
id|ce-&gt;ce_flags
)paren
suffix:semicolon
id|pos
op_assign
id|pos
op_minus
l_int|1
suffix:semicolon
)brace
r_return
id|pos
op_plus
l_int|1
suffix:semicolon
)brace
DECL|function|add_index_entry
r_int
id|add_index_entry
c_func
(paren
r_struct
id|index_state
op_star
id|istate
comma
r_struct
id|cache_entry
op_star
id|ce
comma
r_int
id|option
)paren
(brace
r_int
id|pos
suffix:semicolon
r_if
c_cond
(paren
id|option
op_amp
id|ADD_CACHE_JUST_APPEND
)paren
id|pos
op_assign
id|istate-&gt;cache_nr
suffix:semicolon
r_else
(brace
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|add_index_entry_with_check
c_func
(paren
id|istate
comma
id|ce
comma
id|option
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_le
l_int|0
)paren
r_return
id|ret
suffix:semicolon
id|pos
op_assign
id|ret
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Make sure the array is big enough .. */
r_if
c_cond
(paren
id|istate-&gt;cache_nr
op_eq
id|istate-&gt;cache_alloc
)paren
(brace
id|istate-&gt;cache_alloc
op_assign
id|alloc_nr
c_func
(paren
id|istate-&gt;cache_alloc
)paren
suffix:semicolon
id|istate-&gt;cache
op_assign
id|xrealloc
c_func
(paren
id|istate-&gt;cache
comma
id|istate-&gt;cache_alloc
op_star
r_sizeof
(paren
r_struct
id|cache_entry
op_star
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Add it in.. */
id|istate-&gt;cache_nr
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|istate-&gt;cache_nr
OG
id|pos
op_plus
l_int|1
)paren
id|memmove
c_func
(paren
id|istate-&gt;cache
op_plus
id|pos
op_plus
l_int|1
comma
id|istate-&gt;cache
op_plus
id|pos
comma
(paren
id|istate-&gt;cache_nr
id|pos
l_int|1
)paren
op_star
r_sizeof
(paren
id|ce
)paren
)paren
suffix:semicolon
id|set_index_entry
c_func
(paren
id|istate
comma
id|pos
comma
id|ce
)paren
suffix:semicolon
id|istate-&gt;cache_changed
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * &quot;refresh&quot; does not calculate a new sha1 file or bring the&n; * cache up-to-date for mode/content changes. But what it&n; * _does_ do is to &quot;re-match&quot; the stat information of a file&n; * with the cache, so that you can refresh the cache for a&n; * file that hasn&squot;t been changed but where the stat entry is&n; * out of date.&n; *&n; * For example, you&squot;d want to do this after doing a &quot;git-read-tree&quot;,&n; * to link up the stat cache details with the proper files.&n; */
DECL|function|refresh_cache_ent
r_static
r_struct
id|cache_entry
op_star
id|refresh_cache_ent
c_func
(paren
r_struct
id|index_state
op_star
id|istate
comma
r_struct
id|cache_entry
op_star
id|ce
comma
r_int
r_int
id|options
comma
r_int
op_star
id|err
)paren
(brace
r_struct
id|stat
id|st
suffix:semicolon
r_struct
id|cache_entry
op_star
id|updated
suffix:semicolon
r_int
id|changed
comma
id|size
suffix:semicolon
r_int
id|ignore_valid
op_assign
id|options
op_amp
id|CE_MATCH_IGNORE_VALID
suffix:semicolon
r_if
c_cond
(paren
id|ce_uptodate
c_func
(paren
id|ce
)paren
)paren
r_return
id|ce
suffix:semicolon
multiline_comment|/*&n;&t; * CE_VALID means the user promised us that the change to&n;&t; * the work tree does not matter and told us not to worry.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ignore_valid
op_logical_and
(paren
id|ce-&gt;ce_flags
op_amp
id|CE_VALID
)paren
)paren
(brace
id|ce_mark_uptodate
c_func
(paren
id|ce
)paren
suffix:semicolon
r_return
id|ce
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lstat
c_func
(paren
id|ce-&gt;name
comma
op_amp
id|st
)paren
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|err
)paren
op_star
id|err
op_assign
id|errno
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|changed
op_assign
id|ie_match_stat
c_func
(paren
id|istate
comma
id|ce
comma
op_amp
id|st
comma
id|options
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|changed
)paren
(brace
multiline_comment|/*&n;&t;&t; * The path is unchanged.  If we were told to ignore&n;&t;&t; * valid bit, then we did the actual stat check and&n;&t;&t; * found that the entry is unmodified.  If the entry&n;&t;&t; * is not marked VALID, this is the place to mark it&n;&t;&t; * valid again, under &quot;assume unchanged&quot; mode.&n;&t;&t; */
r_if
c_cond
(paren
id|ignore_valid
op_logical_and
id|assume_unchanged
op_logical_and
op_logical_neg
(paren
id|ce-&gt;ce_flags
op_amp
id|CE_VALID
)paren
)paren
suffix:semicolon
multiline_comment|/* mark this one VALID again */
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * We do not mark the index itself &quot;modified&quot;&n;&t;&t;&t; * because CE_UPTODATE flag is in-core only;&n;&t;&t;&t; * we are not going to write this change out.&n;&t;&t;&t; */
id|ce_mark_uptodate
c_func
(paren
id|ce
)paren
suffix:semicolon
r_return
id|ce
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ie_modified
c_func
(paren
id|istate
comma
id|ce
comma
op_amp
id|st
comma
id|options
)paren
)paren
(brace
r_if
c_cond
(paren
id|err
)paren
op_star
id|err
op_assign
id|EINVAL
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|size
op_assign
id|ce_size
c_func
(paren
id|ce
)paren
suffix:semicolon
id|updated
op_assign
id|xmalloc
c_func
(paren
id|size
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|updated
comma
id|ce
comma
id|size
)paren
suffix:semicolon
id|fill_stat_cache_info
c_func
(paren
id|updated
comma
op_amp
id|st
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If ignore_valid is not set, we should leave CE_VALID bit&n;&t; * alone.  Otherwise, paths marked with --no-assume-unchanged&n;&t; * (i.e. things to be edited) will reacquire CE_VALID bit&n;&t; * automatically, which is not really what we want.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ignore_valid
op_logical_and
id|assume_unchanged
op_logical_and
op_logical_neg
(paren
id|ce-&gt;ce_flags
op_amp
id|CE_VALID
)paren
)paren
id|updated-&gt;ce_flags
op_and_assign
op_complement
id|CE_VALID
suffix:semicolon
r_return
id|updated
suffix:semicolon
)brace
DECL|function|refresh_index
r_int
id|refresh_index
c_func
(paren
r_struct
id|index_state
op_star
id|istate
comma
r_int
r_int
id|flags
comma
r_const
r_char
op_star
op_star
id|pathspec
comma
r_char
op_star
id|seen
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|has_errors
op_assign
l_int|0
suffix:semicolon
r_int
id|really
op_assign
(paren
id|flags
op_amp
id|REFRESH_REALLY
)paren
op_ne
l_int|0
suffix:semicolon
r_int
id|allow_unmerged
op_assign
(paren
id|flags
op_amp
id|REFRESH_UNMERGED
)paren
op_ne
l_int|0
suffix:semicolon
r_int
id|quiet
op_assign
(paren
id|flags
op_amp
id|REFRESH_QUIET
)paren
op_ne
l_int|0
suffix:semicolon
r_int
id|not_new
op_assign
(paren
id|flags
op_amp
id|REFRESH_IGNORE_MISSING
)paren
op_ne
l_int|0
suffix:semicolon
r_int
id|ignore_submodules
op_assign
(paren
id|flags
op_amp
id|REFRESH_IGNORE_SUBMODULES
)paren
op_ne
l_int|0
suffix:semicolon
r_int
r_int
id|options
op_assign
id|really
ques
c_cond
id|CE_MATCH_IGNORE_VALID
suffix:colon
l_int|0
suffix:semicolon
r_const
r_char
op_star
id|needs_update_message
suffix:semicolon
id|needs_update_message
op_assign
(paren
(paren
id|flags
op_amp
id|REFRESH_SAY_CHANGED
)paren
ques
c_cond
l_string|&quot;locally modified&quot;
suffix:colon
l_string|&quot;needs update&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|istate-&gt;cache_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|cache_entry
op_star
id|ce
comma
op_star
r_new
suffix:semicolon
r_int
id|cache_errno
op_assign
l_int|0
suffix:semicolon
id|ce
op_assign
id|istate-&gt;cache
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ignore_submodules
op_logical_and
id|S_ISGITLINK
c_func
(paren
id|ce-&gt;ce_mode
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|ce_stage
c_func
(paren
id|ce
)paren
)paren
(brace
r_while
c_loop
(paren
(paren
id|i
OL
id|istate-&gt;cache_nr
)paren
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|istate-&gt;cache
(braket
id|i
)braket
op_member_access_from_pointer
id|name
comma
id|ce-&gt;name
)paren
)paren
id|i
op_increment
suffix:semicolon
id|i
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|allow_unmerged
)paren
r_continue
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s: needs merge&bslash;n&quot;
comma
id|ce-&gt;name
)paren
suffix:semicolon
id|has_errors
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pathspec
op_logical_and
op_logical_neg
id|match_pathspec
c_func
(paren
id|pathspec
comma
id|ce-&gt;name
comma
id|strlen
c_func
(paren
id|ce-&gt;name
)paren
comma
l_int|0
comma
id|seen
)paren
)paren
r_continue
suffix:semicolon
r_new
op_assign
id|refresh_cache_ent
c_func
(paren
id|istate
comma
id|ce
comma
id|options
comma
op_amp
id|cache_errno
)paren
suffix:semicolon
r_if
c_cond
(paren
r_new
op_eq
id|ce
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
)paren
(brace
r_if
c_cond
(paren
id|not_new
op_logical_and
id|cache_errno
op_eq
id|ENOENT
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|really
op_logical_and
id|cache_errno
op_eq
id|EINVAL
)paren
(brace
multiline_comment|/* If we are doing --really-refresh that&n;&t;&t;&t;&t; * means the index is not valid anymore.&n;&t;&t;&t;&t; */
id|ce-&gt;ce_flags
op_and_assign
op_complement
id|CE_VALID
suffix:semicolon
id|istate-&gt;cache_changed
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|quiet
)paren
r_continue
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s: %s&bslash;n&quot;
comma
id|ce-&gt;name
comma
id|needs_update_message
)paren
suffix:semicolon
id|has_errors
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|replace_index_entry
c_func
(paren
id|istate
comma
id|i
comma
r_new
)paren
suffix:semicolon
)brace
r_return
id|has_errors
suffix:semicolon
)brace
DECL|function|refresh_cache_entry
r_struct
id|cache_entry
op_star
id|refresh_cache_entry
c_func
(paren
r_struct
id|cache_entry
op_star
id|ce
comma
r_int
id|really
)paren
(brace
r_return
id|refresh_cache_ent
c_func
(paren
op_amp
id|the_index
comma
id|ce
comma
id|really
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|verify_hdr
r_static
r_int
id|verify_hdr
c_func
(paren
r_struct
id|cache_header
op_star
id|hdr
comma
r_int
r_int
id|size
)paren
(brace
id|SHA_CTX
id|c
suffix:semicolon
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hdr-&gt;hdr_signature
op_ne
id|htonl
c_func
(paren
id|CACHE_SIGNATURE
)paren
)paren
r_return
id|error
c_func
(paren
l_string|&quot;bad signature&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hdr-&gt;hdr_version
op_ne
id|htonl
c_func
(paren
l_int|2
)paren
)paren
r_return
id|error
c_func
(paren
l_string|&quot;bad index version&quot;
)paren
suffix:semicolon
id|SHA1_Init
c_func
(paren
op_amp
id|c
)paren
suffix:semicolon
id|SHA1_Update
c_func
(paren
op_amp
id|c
comma
id|hdr
comma
id|size
l_int|20
)paren
suffix:semicolon
id|SHA1_Final
c_func
(paren
id|sha1
comma
op_amp
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hashcmp
c_func
(paren
id|sha1
comma
(paren
r_int
r_char
op_star
)paren
id|hdr
op_plus
id|size
l_int|20
)paren
)paren
r_return
id|error
c_func
(paren
l_string|&quot;bad index file sha1 signature&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|read_index_extension
r_static
r_int
id|read_index_extension
c_func
(paren
r_struct
id|index_state
op_star
id|istate
comma
r_const
r_char
op_star
id|ext
comma
r_void
op_star
id|data
comma
r_int
r_int
id|sz
)paren
(brace
r_switch
c_cond
(paren
id|CACHE_EXT
c_func
(paren
id|ext
)paren
)paren
(brace
r_case
id|CACHE_EXT_TREE
suffix:colon
id|istate-&gt;cache_tree
op_assign
id|cache_tree_read
c_func
(paren
id|data
comma
id|sz
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
op_star
id|ext
OL
l_char|&squot;A&squot;
op_logical_or
l_char|&squot;Z&squot;
OL
op_star
id|ext
)paren
r_return
id|error
c_func
(paren
l_string|&quot;index uses %.4s extension, which we do not understand&quot;
comma
id|ext
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;ignoring %.4s extension&bslash;n&quot;
comma
id|ext
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|read_index
r_int
id|read_index
c_func
(paren
r_struct
id|index_state
op_star
id|istate
)paren
(brace
r_return
id|read_index_from
c_func
(paren
id|istate
comma
id|get_index_file
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
DECL|function|convert_from_disk
r_static
r_void
id|convert_from_disk
c_func
(paren
r_struct
id|ondisk_cache_entry
op_star
id|ondisk
comma
r_struct
id|cache_entry
op_star
id|ce
)paren
(brace
r_int
id|len
suffix:semicolon
id|ce-&gt;ce_ctime
op_assign
id|ntohl
c_func
(paren
id|ondisk-&gt;ctime.sec
)paren
suffix:semicolon
id|ce-&gt;ce_mtime
op_assign
id|ntohl
c_func
(paren
id|ondisk-&gt;mtime.sec
)paren
suffix:semicolon
id|ce-&gt;ce_dev
op_assign
id|ntohl
c_func
(paren
id|ondisk-&gt;dev
)paren
suffix:semicolon
id|ce-&gt;ce_ino
op_assign
id|ntohl
c_func
(paren
id|ondisk-&gt;ino
)paren
suffix:semicolon
id|ce-&gt;ce_mode
op_assign
id|ntohl
c_func
(paren
id|ondisk-&gt;mode
)paren
suffix:semicolon
id|ce-&gt;ce_uid
op_assign
id|ntohl
c_func
(paren
id|ondisk-&gt;uid
)paren
suffix:semicolon
id|ce-&gt;ce_gid
op_assign
id|ntohl
c_func
(paren
id|ondisk-&gt;gid
)paren
suffix:semicolon
id|ce-&gt;ce_size
op_assign
id|ntohl
c_func
(paren
id|ondisk-&gt;size
)paren
suffix:semicolon
multiline_comment|/* On-disk flags are just 16 bits */
id|ce-&gt;ce_flags
op_assign
id|ntohs
c_func
(paren
id|ondisk-&gt;flags
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|ce-&gt;sha1
comma
id|ondisk-&gt;sha1
)paren
suffix:semicolon
id|len
op_assign
id|ce-&gt;ce_flags
op_amp
id|CE_NAMEMASK
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
id|CE_NAMEMASK
)paren
id|len
op_assign
id|strlen
c_func
(paren
id|ondisk-&gt;name
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * NEEDSWORK: If the original index is crafted, this copy could&n;&t; * go unchecked.&n;&t; */
id|memcpy
c_func
(paren
id|ce-&gt;name
comma
id|ondisk-&gt;name
comma
id|len
op_plus
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|estimate_cache_size
r_static
r_inline
r_int
id|estimate_cache_size
c_func
(paren
r_int
id|ondisk_size
comma
r_int
r_int
id|entries
)paren
(brace
r_int
id|per_entry
suffix:semicolon
id|per_entry
op_assign
r_sizeof
(paren
r_struct
id|cache_entry
)paren
r_sizeof
(paren
r_struct
id|ondisk_cache_entry
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Alignment can cause differences. This should be &quot;alignof&quot;, but&n;&t; * since that&squot;s a gcc&squot;ism, just use the size of a pointer.&n;&t; */
id|per_entry
op_add_assign
r_sizeof
(paren
r_void
op_star
)paren
suffix:semicolon
r_return
id|ondisk_size
op_plus
id|entries
op_star
id|per_entry
suffix:semicolon
)brace
multiline_comment|/* remember to discard_cache() before reading a different cache! */
DECL|function|read_index_from
r_int
id|read_index_from
c_func
(paren
r_struct
id|index_state
op_star
id|istate
comma
r_const
r_char
op_star
id|path
)paren
(brace
r_int
id|fd
comma
id|i
suffix:semicolon
r_struct
id|stat
id|st
suffix:semicolon
r_int
r_int
id|src_offset
comma
id|dst_offset
suffix:semicolon
r_struct
id|cache_header
op_star
id|hdr
suffix:semicolon
r_void
op_star
id|mmap
suffix:semicolon
r_int
id|mmap_size
suffix:semicolon
id|errno
op_assign
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|istate-&gt;initialized
)paren
r_return
id|istate-&gt;cache_nr
suffix:semicolon
id|errno
op_assign
id|ENOENT
suffix:semicolon
id|istate-&gt;timestamp
op_assign
l_int|0
suffix:semicolon
id|fd
op_assign
id|open
c_func
(paren
id|path
comma
id|O_RDONLY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|errno
op_eq
id|ENOENT
)paren
r_return
l_int|0
suffix:semicolon
id|die
c_func
(paren
l_string|&quot;index file open failed (%s)&quot;
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fstat
c_func
(paren
id|fd
comma
op_amp
id|st
)paren
)paren
id|die
c_func
(paren
l_string|&quot;cannot stat the open index (%s)&quot;
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
id|errno
op_assign
id|EINVAL
suffix:semicolon
id|mmap_size
op_assign
id|xsize_t
c_func
(paren
id|st.st_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mmap_size
OL
r_sizeof
(paren
r_struct
id|cache_header
)paren
op_plus
l_int|20
)paren
id|die
c_func
(paren
l_string|&quot;index file smaller than expected&quot;
)paren
suffix:semicolon
id|mmap
op_assign
id|xmmap
c_func
(paren
l_int|NULL
comma
id|mmap_size
comma
id|PROT_READ
op_or
id|PROT_WRITE
comma
id|MAP_PRIVATE
comma
id|fd
comma
l_int|0
)paren
suffix:semicolon
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mmap
op_eq
id|MAP_FAILED
)paren
id|die
c_func
(paren
l_string|&quot;unable to map index file&quot;
)paren
suffix:semicolon
id|hdr
op_assign
id|mmap
suffix:semicolon
r_if
c_cond
(paren
id|verify_hdr
c_func
(paren
id|hdr
comma
id|mmap_size
)paren
OL
l_int|0
)paren
r_goto
id|unmap
suffix:semicolon
id|istate-&gt;cache_nr
op_assign
id|ntohl
c_func
(paren
id|hdr-&gt;hdr_entries
)paren
suffix:semicolon
id|istate-&gt;cache_alloc
op_assign
id|alloc_nr
c_func
(paren
id|istate-&gt;cache_nr
)paren
suffix:semicolon
id|istate-&gt;cache
op_assign
id|xcalloc
c_func
(paren
id|istate-&gt;cache_alloc
comma
r_sizeof
(paren
r_struct
id|cache_entry
op_star
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The disk format is actually larger than the in-memory format,&n;&t; * due to space for nsec etc, so even though the in-memory one&n;&t; * has room for a few  more flags, we can allocate using the same&n;&t; * index size&n;&t; */
id|istate-&gt;alloc
op_assign
id|xmalloc
c_func
(paren
id|estimate_cache_size
c_func
(paren
id|mmap_size
comma
id|istate-&gt;cache_nr
)paren
)paren
suffix:semicolon
id|istate-&gt;initialized
op_assign
l_int|1
suffix:semicolon
id|src_offset
op_assign
r_sizeof
(paren
op_star
id|hdr
)paren
suffix:semicolon
id|dst_offset
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|istate-&gt;cache_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|ondisk_cache_entry
op_star
id|disk_ce
suffix:semicolon
r_struct
id|cache_entry
op_star
id|ce
suffix:semicolon
id|disk_ce
op_assign
(paren
r_struct
id|ondisk_cache_entry
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|mmap
op_plus
id|src_offset
)paren
suffix:semicolon
id|ce
op_assign
(paren
r_struct
id|cache_entry
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|istate-&gt;alloc
op_plus
id|dst_offset
)paren
suffix:semicolon
id|convert_from_disk
c_func
(paren
id|disk_ce
comma
id|ce
)paren
suffix:semicolon
id|set_index_entry
c_func
(paren
id|istate
comma
id|i
comma
id|ce
)paren
suffix:semicolon
id|src_offset
op_add_assign
id|ondisk_ce_size
c_func
(paren
id|ce
)paren
suffix:semicolon
id|dst_offset
op_add_assign
id|ce_size
c_func
(paren
id|ce
)paren
suffix:semicolon
)brace
id|istate-&gt;timestamp
op_assign
id|st.st_mtime
suffix:semicolon
r_while
c_loop
(paren
id|src_offset
op_le
id|mmap_size
l_int|20
l_int|8
)paren
(brace
multiline_comment|/* After an array of active_nr index entries,&n;&t;&t; * there can be arbitrary number of extended&n;&t;&t; * sections, each of which is prefixed with&n;&t;&t; * extension name (4-byte) and section length&n;&t;&t; * in 4-byte network byte order.&n;&t;&t; */
r_int
r_int
id|extsize
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|extsize
comma
(paren
r_char
op_star
)paren
id|mmap
op_plus
id|src_offset
op_plus
l_int|4
comma
l_int|4
)paren
suffix:semicolon
id|extsize
op_assign
id|ntohl
c_func
(paren
id|extsize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_index_extension
c_func
(paren
id|istate
comma
(paren
r_const
r_char
op_star
)paren
id|mmap
op_plus
id|src_offset
comma
(paren
r_char
op_star
)paren
id|mmap
op_plus
id|src_offset
op_plus
l_int|8
comma
id|extsize
)paren
OL
l_int|0
)paren
r_goto
id|unmap
suffix:semicolon
id|src_offset
op_add_assign
l_int|8
suffix:semicolon
id|src_offset
op_add_assign
id|extsize
suffix:semicolon
)brace
id|munmap
c_func
(paren
id|mmap
comma
id|mmap_size
)paren
suffix:semicolon
r_return
id|istate-&gt;cache_nr
suffix:semicolon
id|unmap
suffix:colon
id|munmap
c_func
(paren
id|mmap
comma
id|mmap_size
)paren
suffix:semicolon
id|errno
op_assign
id|EINVAL
suffix:semicolon
id|die
c_func
(paren
l_string|&quot;index file corrupt&quot;
)paren
suffix:semicolon
)brace
DECL|function|discard_index
r_int
id|discard_index
c_func
(paren
r_struct
id|index_state
op_star
id|istate
)paren
(brace
id|istate-&gt;cache_nr
op_assign
l_int|0
suffix:semicolon
id|istate-&gt;cache_changed
op_assign
l_int|0
suffix:semicolon
id|istate-&gt;timestamp
op_assign
l_int|0
suffix:semicolon
id|istate-&gt;name_hash_initialized
op_assign
l_int|0
suffix:semicolon
id|free_hash
c_func
(paren
op_amp
id|istate-&gt;name_hash
)paren
suffix:semicolon
id|cache_tree_free
c_func
(paren
op_amp
(paren
id|istate-&gt;cache_tree
)paren
)paren
suffix:semicolon
id|free
c_func
(paren
id|istate-&gt;alloc
)paren
suffix:semicolon
id|istate-&gt;alloc
op_assign
l_int|NULL
suffix:semicolon
id|istate-&gt;initialized
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* no need to throw away allocated active_cache */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|unmerged_index
r_int
id|unmerged_index
c_func
(paren
r_const
r_struct
id|index_state
op_star
id|istate
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|istate-&gt;cache_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ce_stage
c_func
(paren
id|istate-&gt;cache
(braket
id|i
)braket
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|WRITE_BUFFER_SIZE
mdefine_line|#define WRITE_BUFFER_SIZE 8192
DECL|variable|write_buffer
r_static
r_int
r_char
id|write_buffer
(braket
id|WRITE_BUFFER_SIZE
)braket
suffix:semicolon
DECL|variable|write_buffer_len
r_static
r_int
r_int
id|write_buffer_len
suffix:semicolon
DECL|function|ce_write_flush
r_static
r_int
id|ce_write_flush
c_func
(paren
id|SHA_CTX
op_star
id|context
comma
r_int
id|fd
)paren
(brace
r_int
r_int
id|buffered
op_assign
id|write_buffer_len
suffix:semicolon
r_if
c_cond
(paren
id|buffered
)paren
(brace
id|SHA1_Update
c_func
(paren
id|context
comma
id|write_buffer
comma
id|buffered
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write_in_full
c_func
(paren
id|fd
comma
id|write_buffer
comma
id|buffered
)paren
op_ne
id|buffered
)paren
r_return
l_int|1
suffix:semicolon
id|write_buffer_len
op_assign
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ce_write
r_static
r_int
id|ce_write
c_func
(paren
id|SHA_CTX
op_star
id|context
comma
r_int
id|fd
comma
r_void
op_star
id|data
comma
r_int
r_int
id|len
)paren
(brace
r_while
c_loop
(paren
id|len
)paren
(brace
r_int
r_int
id|buffered
op_assign
id|write_buffer_len
suffix:semicolon
r_int
r_int
id|partial
op_assign
id|WRITE_BUFFER_SIZE
id|buffered
suffix:semicolon
r_if
c_cond
(paren
id|partial
OG
id|len
)paren
id|partial
op_assign
id|len
suffix:semicolon
id|memcpy
c_func
(paren
id|write_buffer
op_plus
id|buffered
comma
id|data
comma
id|partial
)paren
suffix:semicolon
id|buffered
op_add_assign
id|partial
suffix:semicolon
r_if
c_cond
(paren
id|buffered
op_eq
id|WRITE_BUFFER_SIZE
)paren
(brace
id|write_buffer_len
op_assign
id|buffered
suffix:semicolon
r_if
c_cond
(paren
id|ce_write_flush
c_func
(paren
id|context
comma
id|fd
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|buffered
op_assign
l_int|0
suffix:semicolon
)brace
id|write_buffer_len
op_assign
id|buffered
suffix:semicolon
id|len
op_sub_assign
id|partial
suffix:semicolon
id|data
op_assign
(paren
r_char
op_star
)paren
id|data
op_plus
id|partial
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|write_index_ext_header
r_static
r_int
id|write_index_ext_header
c_func
(paren
id|SHA_CTX
op_star
id|context
comma
r_int
id|fd
comma
r_int
r_int
id|ext
comma
r_int
r_int
id|sz
)paren
(brace
id|ext
op_assign
id|htonl
c_func
(paren
id|ext
)paren
suffix:semicolon
id|sz
op_assign
id|htonl
c_func
(paren
id|sz
)paren
suffix:semicolon
r_return
(paren
(paren
id|ce_write
c_func
(paren
id|context
comma
id|fd
comma
op_amp
id|ext
comma
l_int|4
)paren
OL
l_int|0
)paren
op_logical_or
(paren
id|ce_write
c_func
(paren
id|context
comma
id|fd
comma
op_amp
id|sz
comma
l_int|4
)paren
OL
l_int|0
)paren
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|function|ce_flush
r_static
r_int
id|ce_flush
c_func
(paren
id|SHA_CTX
op_star
id|context
comma
r_int
id|fd
)paren
(brace
r_int
r_int
id|left
op_assign
id|write_buffer_len
suffix:semicolon
r_if
c_cond
(paren
id|left
)paren
(brace
id|write_buffer_len
op_assign
l_int|0
suffix:semicolon
id|SHA1_Update
c_func
(paren
id|context
comma
id|write_buffer
comma
id|left
)paren
suffix:semicolon
)brace
multiline_comment|/* Flush first if not enough space for SHA1 signature */
r_if
c_cond
(paren
id|left
op_plus
l_int|20
OG
id|WRITE_BUFFER_SIZE
)paren
(brace
r_if
c_cond
(paren
id|write_in_full
c_func
(paren
id|fd
comma
id|write_buffer
comma
id|left
)paren
op_ne
id|left
)paren
r_return
l_int|1
suffix:semicolon
id|left
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Append the SHA1 signature at the end */
id|SHA1_Final
c_func
(paren
id|write_buffer
op_plus
id|left
comma
id|context
)paren
suffix:semicolon
id|left
op_add_assign
l_int|20
suffix:semicolon
r_return
(paren
id|write_in_full
c_func
(paren
id|fd
comma
id|write_buffer
comma
id|left
)paren
op_ne
id|left
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|function|ce_smudge_racily_clean_entry
r_static
r_void
id|ce_smudge_racily_clean_entry
c_func
(paren
r_struct
id|cache_entry
op_star
id|ce
)paren
(brace
multiline_comment|/*&n;&t; * The only thing we care about in this function is to smudge the&n;&t; * falsely clean entry due to touch-update-touch race, so we leave&n;&t; * everything else as they are.  We are called for entries whose&n;&t; * ce_mtime match the index file mtime.&n;&t; *&n;&t; * Note that this actually does not do much for gitlinks, for&n;&t; * which ce_match_stat_basic() always goes to the actual&n;&t; * contents.  The caller checks with is_racy_timestamp() which&n;&t; * always says &quot;no&quot; for gitlinks, so we are not called for them ;-)&n;&t; */
r_struct
id|stat
id|st
suffix:semicolon
r_if
c_cond
(paren
id|lstat
c_func
(paren
id|ce-&gt;name
comma
op_amp
id|st
)paren
OL
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|ce_match_stat_basic
c_func
(paren
id|ce
comma
op_amp
id|st
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|ce_modified_check_fs
c_func
(paren
id|ce
comma
op_amp
id|st
)paren
)paren
(brace
multiline_comment|/* This is &quot;racily clean&quot;; smudge it.  Note that this&n;&t;&t; * is a tricky code.  At first glance, it may appear&n;&t;&t; * that it can break with this sequence:&n;&t;&t; *&n;&t;&t; * $ echo xyzzy &gt;frotz&n;&t;&t; * $ git-update-index --add frotz&n;&t;&t; * $ : &gt;frotz&n;&t;&t; * $ sleep 3&n;&t;&t; * $ echo filfre &gt;nitfol&n;&t;&t; * $ git-update-index --add nitfol&n;&t;&t; *&n;&t;&t; * but it does not.  When the second update-index runs,&n;&t;&t; * it notices that the entry &quot;frotz&quot; has the same timestamp&n;&t;&t; * as index, and if we were to smudge it by resetting its&n;&t;&t; * size to zero here, then the object name recorded&n;&t;&t; * in index is the 6-byte file but the cached stat information&n;&t;&t; * becomes zero --- which would then match what we would&n;&t;&t; * obtain from the filesystem next time we stat(&quot;frotz&quot;).&n;&t;&t; *&n;&t;&t; * However, the second update-index, before calling&n;&t;&t; * this function, notices that the cached size is 6&n;&t;&t; * bytes and what is on the filesystem is an empty&n;&t;&t; * file, and never calls us, so the cached size information&n;&t;&t; * for &quot;frotz&quot; stays 6 which does not match the filesystem.&n;&t;&t; */
id|ce-&gt;ce_size
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|ce_write_entry
r_static
r_int
id|ce_write_entry
c_func
(paren
id|SHA_CTX
op_star
id|c
comma
r_int
id|fd
comma
r_struct
id|cache_entry
op_star
id|ce
)paren
(brace
r_int
id|size
op_assign
id|ondisk_ce_size
c_func
(paren
id|ce
)paren
suffix:semicolon
r_struct
id|ondisk_cache_entry
op_star
id|ondisk
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
id|size
)paren
suffix:semicolon
id|ondisk-&gt;ctime.sec
op_assign
id|htonl
c_func
(paren
id|ce-&gt;ce_ctime
)paren
suffix:semicolon
id|ondisk-&gt;ctime.nsec
op_assign
l_int|0
suffix:semicolon
id|ondisk-&gt;mtime.sec
op_assign
id|htonl
c_func
(paren
id|ce-&gt;ce_mtime
)paren
suffix:semicolon
id|ondisk-&gt;mtime.nsec
op_assign
l_int|0
suffix:semicolon
id|ondisk-&gt;dev
op_assign
id|htonl
c_func
(paren
id|ce-&gt;ce_dev
)paren
suffix:semicolon
id|ondisk-&gt;ino
op_assign
id|htonl
c_func
(paren
id|ce-&gt;ce_ino
)paren
suffix:semicolon
id|ondisk-&gt;mode
op_assign
id|htonl
c_func
(paren
id|ce-&gt;ce_mode
)paren
suffix:semicolon
id|ondisk-&gt;uid
op_assign
id|htonl
c_func
(paren
id|ce-&gt;ce_uid
)paren
suffix:semicolon
id|ondisk-&gt;gid
op_assign
id|htonl
c_func
(paren
id|ce-&gt;ce_gid
)paren
suffix:semicolon
id|ondisk-&gt;size
op_assign
id|htonl
c_func
(paren
id|ce-&gt;ce_size
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|ondisk-&gt;sha1
comma
id|ce-&gt;sha1
)paren
suffix:semicolon
id|ondisk-&gt;flags
op_assign
id|htons
c_func
(paren
id|ce-&gt;ce_flags
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ondisk-&gt;name
comma
id|ce-&gt;name
comma
id|ce_namelen
c_func
(paren
id|ce
)paren
)paren
suffix:semicolon
r_return
id|ce_write
c_func
(paren
id|c
comma
id|fd
comma
id|ondisk
comma
id|size
)paren
suffix:semicolon
)brace
DECL|function|write_index
r_int
id|write_index
c_func
(paren
r_const
r_struct
id|index_state
op_star
id|istate
comma
r_int
id|newfd
)paren
(brace
id|SHA_CTX
id|c
suffix:semicolon
r_struct
id|cache_header
id|hdr
suffix:semicolon
r_int
id|i
comma
id|err
comma
id|removed
suffix:semicolon
r_struct
id|cache_entry
op_star
op_star
id|cache
op_assign
id|istate-&gt;cache
suffix:semicolon
r_int
id|entries
op_assign
id|istate-&gt;cache_nr
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|removed
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|entries
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|cache
(braket
id|i
)braket
op_member_access_from_pointer
id|ce_flags
op_amp
id|CE_REMOVE
)paren
id|removed
op_increment
suffix:semicolon
id|hdr.hdr_signature
op_assign
id|htonl
c_func
(paren
id|CACHE_SIGNATURE
)paren
suffix:semicolon
id|hdr.hdr_version
op_assign
id|htonl
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|hdr.hdr_entries
op_assign
id|htonl
c_func
(paren
id|entries
id|removed
)paren
suffix:semicolon
id|SHA1_Init
c_func
(paren
op_amp
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ce_write
c_func
(paren
op_amp
id|c
comma
id|newfd
comma
op_amp
id|hdr
comma
r_sizeof
(paren
id|hdr
)paren
)paren
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|entries
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|cache_entry
op_star
id|ce
op_assign
id|cache
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ce-&gt;ce_flags
op_amp
id|CE_REMOVE
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ce_uptodate
c_func
(paren
id|ce
)paren
op_logical_and
id|is_racy_timestamp
c_func
(paren
id|istate
comma
id|ce
)paren
)paren
id|ce_smudge_racily_clean_entry
c_func
(paren
id|ce
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ce_write_entry
c_func
(paren
op_amp
id|c
comma
id|newfd
comma
id|ce
)paren
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Write extension data here */
r_if
c_cond
(paren
id|istate-&gt;cache_tree
)paren
(brace
r_struct
id|strbuf
id|sb
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|sb
comma
l_int|0
)paren
suffix:semicolon
id|cache_tree_write
c_func
(paren
op_amp
id|sb
comma
id|istate-&gt;cache_tree
)paren
suffix:semicolon
id|err
op_assign
id|write_index_ext_header
c_func
(paren
op_amp
id|c
comma
id|newfd
comma
id|CACHE_EXT_TREE
comma
id|sb.len
)paren
OL
l_int|0
op_logical_or
id|ce_write
c_func
(paren
op_amp
id|c
comma
id|newfd
comma
id|sb.buf
comma
id|sb.len
)paren
OL
l_int|0
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
id|ce_flush
c_func
(paren
op_amp
id|c
comma
id|newfd
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Read the index file that is potentially unmerged into given&n; * index_state, dropping any unmerged entries.  Returns true is&n; * the index is unmerged.  Callers who want to refuse to work&n; * from an unmerged state can call this and check its return value,&n; * instead of calling read_cache().&n; */
DECL|function|read_index_unmerged
r_int
id|read_index_unmerged
c_func
(paren
r_struct
id|index_state
op_star
id|istate
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|cache_entry
op_star
op_star
id|dst
suffix:semicolon
r_struct
id|cache_entry
op_star
id|last
op_assign
l_int|NULL
suffix:semicolon
id|read_index
c_func
(paren
id|istate
)paren
suffix:semicolon
id|dst
op_assign
id|istate-&gt;cache
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|istate-&gt;cache_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|cache_entry
op_star
id|ce
op_assign
id|istate-&gt;cache
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ce_stage
c_func
(paren
id|ce
)paren
)paren
(brace
id|remove_name_hash
c_func
(paren
id|ce
)paren
suffix:semicolon
r_if
c_cond
(paren
id|last
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|ce-&gt;name
comma
id|last-&gt;name
)paren
)paren
r_continue
suffix:semicolon
id|cache_tree_invalidate_path
c_func
(paren
id|istate-&gt;cache_tree
comma
id|ce-&gt;name
)paren
suffix:semicolon
id|last
op_assign
id|ce
suffix:semicolon
r_continue
suffix:semicolon
)brace
op_star
id|dst
op_increment
op_assign
id|ce
suffix:semicolon
)brace
id|istate-&gt;cache_nr
op_assign
id|dst
id|istate-&gt;cache
suffix:semicolon
r_return
op_logical_neg
op_logical_neg
id|last
suffix:semicolon
)brace
eof
