multiline_comment|/*&n; * GIT - The information manager from hell&n; *&n; * Copyright (C) Linus Torvalds, 2005&n; */
macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;cache-tree.h&quot;
multiline_comment|/* Index extensions.&n; *&n; * The first letter should be &squot;A&squot;..&squot;Z&squot; for extensions that are not&n; * necessary for a correct operation (i.e. optimization data).&n; * When new extensions are added that _needs_ to be understood in&n; * order to correctly interpret the index file, pick character that&n; * is outside the range, to cause the reader to abort.&n; */
DECL|macro|CACHE_EXT
mdefine_line|#define CACHE_EXT(s) ( (s[0]&lt;&lt;24)|(s[1]&lt;&lt;16)|(s[2]&lt;&lt;8)|(s[3]) )
DECL|macro|CACHE_EXT_TREE
mdefine_line|#define CACHE_EXT_TREE 0x54524545&t;/* &quot;TREE&quot; */
DECL|variable|active_cache
r_struct
id|cache_entry
op_star
op_star
id|active_cache
suffix:semicolon
DECL|variable|index_file_timestamp
r_static
id|time_t
id|index_file_timestamp
suffix:semicolon
DECL|variable|active_nr
DECL|variable|active_alloc
DECL|variable|active_cache_changed
r_int
r_int
id|active_nr
comma
id|active_alloc
comma
id|active_cache_changed
suffix:semicolon
DECL|variable|active_cache_tree
r_struct
id|cache_tree
op_star
id|active_cache_tree
suffix:semicolon
DECL|variable|cache_errno
r_int
id|cache_errno
suffix:semicolon
DECL|variable|cache_mmap
r_static
r_void
op_star
id|cache_mmap
suffix:semicolon
DECL|variable|cache_mmap_size
r_static
r_int
id|cache_mmap_size
suffix:semicolon
multiline_comment|/*&n; * This only updates the &quot;non-critical&quot; parts of the directory&n; * cache, ie the parts that aren&squot;t tracked by GIT, and only used&n; * to validate the cache.&n; */
DECL|function|fill_stat_cache_info
r_void
id|fill_stat_cache_info
c_func
(paren
r_struct
id|cache_entry
op_star
id|ce
comma
r_struct
id|stat
op_star
id|st
)paren
(brace
id|ce-&gt;ce_ctime.sec
op_assign
id|htonl
c_func
(paren
id|st-&gt;st_ctime
)paren
suffix:semicolon
id|ce-&gt;ce_mtime.sec
op_assign
id|htonl
c_func
(paren
id|st-&gt;st_mtime
)paren
suffix:semicolon
macro_line|#ifdef USE_NSEC
id|ce-&gt;ce_ctime.nsec
op_assign
id|htonl
c_func
(paren
id|st-&gt;st_ctim.tv_nsec
)paren
suffix:semicolon
id|ce-&gt;ce_mtime.nsec
op_assign
id|htonl
c_func
(paren
id|st-&gt;st_mtim.tv_nsec
)paren
suffix:semicolon
macro_line|#endif
id|ce-&gt;ce_dev
op_assign
id|htonl
c_func
(paren
id|st-&gt;st_dev
)paren
suffix:semicolon
id|ce-&gt;ce_ino
op_assign
id|htonl
c_func
(paren
id|st-&gt;st_ino
)paren
suffix:semicolon
id|ce-&gt;ce_uid
op_assign
id|htonl
c_func
(paren
id|st-&gt;st_uid
)paren
suffix:semicolon
id|ce-&gt;ce_gid
op_assign
id|htonl
c_func
(paren
id|st-&gt;st_gid
)paren
suffix:semicolon
id|ce-&gt;ce_size
op_assign
id|htonl
c_func
(paren
id|st-&gt;st_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|assume_unchanged
)paren
id|ce-&gt;ce_flags
op_or_assign
id|htons
c_func
(paren
id|CE_VALID
)paren
suffix:semicolon
)brace
DECL|function|ce_compare_data
r_static
r_int
id|ce_compare_data
c_func
(paren
r_struct
id|cache_entry
op_star
id|ce
comma
r_struct
id|stat
op_star
id|st
)paren
(brace
r_int
id|match
op_assign
l_int|1
suffix:semicolon
r_int
id|fd
op_assign
id|open
c_func
(paren
id|ce-&gt;name
comma
id|O_RDONLY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
op_ge
l_int|0
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|index_fd
c_func
(paren
id|sha1
comma
id|fd
comma
id|st
comma
l_int|0
comma
l_int|NULL
)paren
)paren
id|match
op_assign
id|hashcmp
c_func
(paren
id|sha1
comma
id|ce-&gt;sha1
)paren
suffix:semicolon
multiline_comment|/* index_fd() closed the file descriptor already */
)brace
r_return
id|match
suffix:semicolon
)brace
DECL|function|ce_compare_link
r_static
r_int
id|ce_compare_link
c_func
(paren
r_struct
id|cache_entry
op_star
id|ce
comma
r_int
r_int
id|expected_size
)paren
(brace
r_int
id|match
op_assign
l_int|1
suffix:semicolon
r_char
op_star
id|target
suffix:semicolon
r_void
op_star
id|buffer
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_char
id|type
(braket
l_int|10
)braket
suffix:semicolon
r_int
id|len
suffix:semicolon
id|target
op_assign
id|xmalloc
c_func
(paren
id|expected_size
)paren
suffix:semicolon
id|len
op_assign
id|readlink
c_func
(paren
id|ce-&gt;name
comma
id|target
comma
id|expected_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
id|expected_size
)paren
(brace
id|free
c_func
(paren
id|target
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|buffer
op_assign
id|read_sha1_file
c_func
(paren
id|ce-&gt;sha1
comma
id|type
comma
op_amp
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer
)paren
(brace
id|free
c_func
(paren
id|target
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|size
op_eq
id|expected_size
)paren
id|match
op_assign
id|memcmp
c_func
(paren
id|buffer
comma
id|target
comma
id|size
)paren
suffix:semicolon
id|free
c_func
(paren
id|buffer
)paren
suffix:semicolon
id|free
c_func
(paren
id|target
)paren
suffix:semicolon
r_return
id|match
suffix:semicolon
)brace
DECL|function|ce_modified_check_fs
r_static
r_int
id|ce_modified_check_fs
c_func
(paren
r_struct
id|cache_entry
op_star
id|ce
comma
r_struct
id|stat
op_star
id|st
)paren
(brace
r_switch
c_cond
(paren
id|st-&gt;st_mode
op_amp
id|S_IFMT
)paren
(brace
r_case
id|S_IFREG
suffix:colon
r_if
c_cond
(paren
id|ce_compare_data
c_func
(paren
id|ce
comma
id|st
)paren
)paren
r_return
id|DATA_CHANGED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_IFLNK
suffix:colon
r_if
c_cond
(paren
id|ce_compare_link
c_func
(paren
id|ce
comma
id|st-&gt;st_size
)paren
)paren
r_return
id|DATA_CHANGED
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
id|TYPE_CHANGED
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ce_match_stat_basic
r_static
r_int
id|ce_match_stat_basic
c_func
(paren
r_struct
id|cache_entry
op_star
id|ce
comma
r_struct
id|stat
op_star
id|st
)paren
(brace
r_int
r_int
id|changed
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|ntohl
c_func
(paren
id|ce-&gt;ce_mode
)paren
op_amp
id|S_IFMT
)paren
(brace
r_case
id|S_IFREG
suffix:colon
id|changed
op_or_assign
op_logical_neg
id|S_ISREG
c_func
(paren
id|st-&gt;st_mode
)paren
ques
c_cond
id|TYPE_CHANGED
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* We consider only the owner x bit to be relevant for&n;&t;&t; * &quot;mode changes&quot;&n;&t;&t; */
r_if
c_cond
(paren
id|trust_executable_bit
op_logical_and
(paren
l_int|0100
op_amp
(paren
id|ntohl
c_func
(paren
id|ce-&gt;ce_mode
)paren
op_xor
id|st-&gt;st_mode
)paren
)paren
)paren
id|changed
op_or_assign
id|MODE_CHANGED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_IFLNK
suffix:colon
id|changed
op_or_assign
op_logical_neg
id|S_ISLNK
c_func
(paren
id|st-&gt;st_mode
)paren
ques
c_cond
id|TYPE_CHANGED
suffix:colon
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|die
c_func
(paren
l_string|&quot;internal error: ce_mode is %o&quot;
comma
id|ntohl
c_func
(paren
id|ce-&gt;ce_mode
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ce-&gt;ce_mtime.sec
op_ne
id|htonl
c_func
(paren
id|st-&gt;st_mtime
)paren
)paren
id|changed
op_or_assign
id|MTIME_CHANGED
suffix:semicolon
r_if
c_cond
(paren
id|ce-&gt;ce_ctime.sec
op_ne
id|htonl
c_func
(paren
id|st-&gt;st_ctime
)paren
)paren
id|changed
op_or_assign
id|CTIME_CHANGED
suffix:semicolon
macro_line|#ifdef USE_NSEC
multiline_comment|/*&n;&t; * nsec seems unreliable - not all filesystems support it, so&n;&t; * as long as it is in the inode cache you get right nsec&n;&t; * but after it gets flushed, you get zero nsec.&n;&t; */
r_if
c_cond
(paren
id|ce-&gt;ce_mtime.nsec
op_ne
id|htonl
c_func
(paren
id|st-&gt;st_mtim.tv_nsec
)paren
)paren
id|changed
op_or_assign
id|MTIME_CHANGED
suffix:semicolon
r_if
c_cond
(paren
id|ce-&gt;ce_ctime.nsec
op_ne
id|htonl
c_func
(paren
id|st-&gt;st_ctim.tv_nsec
)paren
)paren
id|changed
op_or_assign
id|CTIME_CHANGED
suffix:semicolon
macro_line|#endif&t;
r_if
c_cond
(paren
id|ce-&gt;ce_uid
op_ne
id|htonl
c_func
(paren
id|st-&gt;st_uid
)paren
op_logical_or
id|ce-&gt;ce_gid
op_ne
id|htonl
c_func
(paren
id|st-&gt;st_gid
)paren
)paren
id|changed
op_or_assign
id|OWNER_CHANGED
suffix:semicolon
r_if
c_cond
(paren
id|ce-&gt;ce_ino
op_ne
id|htonl
c_func
(paren
id|st-&gt;st_ino
)paren
)paren
id|changed
op_or_assign
id|INODE_CHANGED
suffix:semicolon
macro_line|#ifdef USE_STDEV
multiline_comment|/*&n;&t; * st_dev breaks on network filesystems where different&n;&t; * clients will have different views of what &quot;device&quot;&n;&t; * the filesystem is on&n;&t; */
r_if
c_cond
(paren
id|ce-&gt;ce_dev
op_ne
id|htonl
c_func
(paren
id|st-&gt;st_dev
)paren
)paren
id|changed
op_or_assign
id|INODE_CHANGED
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|ce-&gt;ce_size
op_ne
id|htonl
c_func
(paren
id|st-&gt;st_size
)paren
)paren
id|changed
op_or_assign
id|DATA_CHANGED
suffix:semicolon
r_return
id|changed
suffix:semicolon
)brace
DECL|function|ce_match_stat
r_int
id|ce_match_stat
c_func
(paren
r_struct
id|cache_entry
op_star
id|ce
comma
r_struct
id|stat
op_star
id|st
comma
r_int
id|options
)paren
(brace
r_int
r_int
id|changed
suffix:semicolon
r_int
id|ignore_valid
op_assign
id|options
op_amp
l_int|01
suffix:semicolon
r_int
id|assume_racy_is_modified
op_assign
id|options
op_amp
l_int|02
suffix:semicolon
multiline_comment|/*&n;&t; * If it&squot;s marked as always valid in the index, it&squot;s&n;&t; * valid whatever the checked-out copy says.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ignore_valid
op_logical_and
(paren
id|ce-&gt;ce_flags
op_amp
id|htons
c_func
(paren
id|CE_VALID
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|changed
op_assign
id|ce_match_stat_basic
c_func
(paren
id|ce
comma
id|st
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Within 1 second of this sequence:&n;&t; * &t;echo xyzzy &gt;file &amp;&amp; git-update-index --add file&n;&t; * running this command:&n;&t; * &t;echo frotz &gt;file&n;&t; * would give a falsely clean cache entry.  The mtime and&n;&t; * length match the cache, and other stat fields do not change.&n;&t; *&n;&t; * We could detect this at update-index time (the cache entry&n;&t; * being registered/updated records the same time as &quot;now&quot;)&n;&t; * and delay the return from git-update-index, but that would&n;&t; * effectively mean we can make at most one commit per second,&n;&t; * which is not acceptable.  Instead, we check cache entries&n;&t; * whose mtime are the same as the index file timestamp more&n;&t; * carefully than others.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|changed
op_logical_and
id|index_file_timestamp
op_logical_and
id|index_file_timestamp
op_le
id|ntohl
c_func
(paren
id|ce-&gt;ce_mtime.sec
)paren
)paren
(brace
r_if
c_cond
(paren
id|assume_racy_is_modified
)paren
id|changed
op_or_assign
id|DATA_CHANGED
suffix:semicolon
r_else
id|changed
op_or_assign
id|ce_modified_check_fs
c_func
(paren
id|ce
comma
id|st
)paren
suffix:semicolon
)brace
r_return
id|changed
suffix:semicolon
)brace
DECL|function|ce_modified
r_int
id|ce_modified
c_func
(paren
r_struct
id|cache_entry
op_star
id|ce
comma
r_struct
id|stat
op_star
id|st
comma
r_int
id|really
)paren
(brace
r_int
id|changed
comma
id|changed_fs
suffix:semicolon
id|changed
op_assign
id|ce_match_stat
c_func
(paren
id|ce
comma
id|st
comma
id|really
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|changed
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If the mode or type has changed, there&squot;s no point in trying&n;&t; * to refresh the entry - it&squot;s not going to match&n;&t; */
r_if
c_cond
(paren
id|changed
op_amp
(paren
id|MODE_CHANGED
op_or
id|TYPE_CHANGED
)paren
)paren
r_return
id|changed
suffix:semicolon
multiline_comment|/* Immediately after read-tree or update-index --cacheinfo,&n;&t; * the length field is zero.  For other cases the ce_size&n;&t; * should match the SHA1 recorded in the index entry.&n;&t; */
r_if
c_cond
(paren
(paren
id|changed
op_amp
id|DATA_CHANGED
)paren
op_logical_and
id|ce-&gt;ce_size
op_ne
id|htonl
c_func
(paren
l_int|0
)paren
)paren
r_return
id|changed
suffix:semicolon
id|changed_fs
op_assign
id|ce_modified_check_fs
c_func
(paren
id|ce
comma
id|st
)paren
suffix:semicolon
r_if
c_cond
(paren
id|changed_fs
)paren
r_return
id|changed
op_or
id|changed_fs
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|base_name_compare
r_int
id|base_name_compare
c_func
(paren
r_const
r_char
op_star
id|name1
comma
r_int
id|len1
comma
r_int
id|mode1
comma
r_const
r_char
op_star
id|name2
comma
r_int
id|len2
comma
r_int
id|mode2
)paren
(brace
r_int
r_char
id|c1
comma
id|c2
suffix:semicolon
r_int
id|len
op_assign
id|len1
OL
id|len2
ques
c_cond
id|len1
suffix:colon
id|len2
suffix:semicolon
r_int
id|cmp
suffix:semicolon
id|cmp
op_assign
id|memcmp
c_func
(paren
id|name1
comma
id|name2
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmp
)paren
r_return
id|cmp
suffix:semicolon
id|c1
op_assign
id|name1
(braket
id|len
)braket
suffix:semicolon
id|c2
op_assign
id|name2
(braket
id|len
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c1
op_logical_and
id|S_ISDIR
c_func
(paren
id|mode1
)paren
)paren
id|c1
op_assign
l_char|&squot;/&squot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c2
op_logical_and
id|S_ISDIR
c_func
(paren
id|mode2
)paren
)paren
id|c2
op_assign
l_char|&squot;/&squot;
suffix:semicolon
r_return
(paren
id|c1
OL
id|c2
)paren
ques
c_cond
l_int|1
suffix:colon
(paren
id|c1
OG
id|c2
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|function|cache_name_compare
r_int
id|cache_name_compare
c_func
(paren
r_const
r_char
op_star
id|name1
comma
r_int
id|flags1
comma
r_const
r_char
op_star
id|name2
comma
r_int
id|flags2
)paren
(brace
r_int
id|len1
op_assign
id|flags1
op_amp
id|CE_NAMEMASK
suffix:semicolon
r_int
id|len2
op_assign
id|flags2
op_amp
id|CE_NAMEMASK
suffix:semicolon
r_int
id|len
op_assign
id|len1
OL
id|len2
ques
c_cond
id|len1
suffix:colon
id|len2
suffix:semicolon
r_int
id|cmp
suffix:semicolon
id|cmp
op_assign
id|memcmp
c_func
(paren
id|name1
comma
id|name2
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmp
)paren
r_return
id|cmp
suffix:semicolon
r_if
c_cond
(paren
id|len1
OL
id|len2
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|len1
OG
id|len2
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Compare stages  */
id|flags1
op_and_assign
id|CE_STAGEMASK
suffix:semicolon
id|flags2
op_and_assign
id|CE_STAGEMASK
suffix:semicolon
r_if
c_cond
(paren
id|flags1
OL
id|flags2
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|flags1
OG
id|flags2
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cache_name_pos
r_int
id|cache_name_pos
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_int
id|namelen
)paren
(brace
r_int
id|first
comma
id|last
suffix:semicolon
id|first
op_assign
l_int|0
suffix:semicolon
id|last
op_assign
id|active_nr
suffix:semicolon
r_while
c_loop
(paren
id|last
OG
id|first
)paren
(brace
r_int
id|next
op_assign
(paren
id|last
op_plus
id|first
)paren
op_rshift
l_int|1
suffix:semicolon
r_struct
id|cache_entry
op_star
id|ce
op_assign
id|active_cache
(braket
id|next
)braket
suffix:semicolon
r_int
id|cmp
op_assign
id|cache_name_compare
c_func
(paren
id|name
comma
id|namelen
comma
id|ce-&gt;name
comma
id|ntohs
c_func
(paren
id|ce-&gt;ce_flags
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmp
)paren
r_return
id|next
suffix:semicolon
r_if
c_cond
(paren
id|cmp
OL
l_int|0
)paren
(brace
id|last
op_assign
id|next
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|first
op_assign
id|next
op_plus
l_int|1
suffix:semicolon
)brace
r_return
id|first
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Remove entry, return true if there are more entries to go.. */
DECL|function|remove_cache_entry_at
r_int
id|remove_cache_entry_at
c_func
(paren
r_int
id|pos
)paren
(brace
id|active_cache_changed
op_assign
l_int|1
suffix:semicolon
id|active_nr
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_ge
id|active_nr
)paren
r_return
l_int|0
suffix:semicolon
id|memmove
c_func
(paren
id|active_cache
op_plus
id|pos
comma
id|active_cache
op_plus
id|pos
op_plus
l_int|1
comma
(paren
id|active_nr
id|pos
)paren
op_star
r_sizeof
(paren
r_struct
id|cache_entry
op_star
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|remove_file_from_cache
r_int
id|remove_file_from_cache
c_func
(paren
r_const
r_char
op_star
id|path
)paren
(brace
r_int
id|pos
op_assign
id|cache_name_pos
c_func
(paren
id|path
comma
id|strlen
c_func
(paren
id|path
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
l_int|0
)paren
id|pos
op_assign
id|pos
op_minus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|pos
OL
id|active_nr
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|active_cache
(braket
id|pos
)braket
op_member_access_from_pointer
id|name
comma
id|path
)paren
)paren
id|remove_cache_entry_at
c_func
(paren
id|pos
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|add_file_to_index
r_int
id|add_file_to_index
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_int
id|verbose
)paren
(brace
r_int
id|size
comma
id|namelen
suffix:semicolon
r_struct
id|stat
id|st
suffix:semicolon
r_struct
id|cache_entry
op_star
id|ce
suffix:semicolon
r_if
c_cond
(paren
id|lstat
c_func
(paren
id|path
comma
op_amp
id|st
)paren
)paren
id|die
c_func
(paren
l_string|&quot;%s: unable to stat (%s)&quot;
comma
id|path
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISREG
c_func
(paren
id|st.st_mode
)paren
op_logical_and
op_logical_neg
id|S_ISLNK
c_func
(paren
id|st.st_mode
)paren
)paren
id|die
c_func
(paren
l_string|&quot;%s: can only add regular files or symbolic links&quot;
comma
id|path
)paren
suffix:semicolon
id|namelen
op_assign
id|strlen
c_func
(paren
id|path
)paren
suffix:semicolon
id|size
op_assign
id|cache_entry_size
c_func
(paren
id|namelen
)paren
suffix:semicolon
id|ce
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
id|size
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ce-&gt;name
comma
id|path
comma
id|namelen
)paren
suffix:semicolon
id|ce-&gt;ce_flags
op_assign
id|htons
c_func
(paren
id|namelen
)paren
suffix:semicolon
id|fill_stat_cache_info
c_func
(paren
id|ce
comma
op_amp
id|st
)paren
suffix:semicolon
id|ce-&gt;ce_mode
op_assign
id|create_ce_mode
c_func
(paren
id|st.st_mode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|trust_executable_bit
)paren
(brace
multiline_comment|/* If there is an existing entry, pick the mode bits&n;&t;&t; * from it, otherwise assume unexecutable.&n;&t;&t; */
r_int
id|pos
op_assign
id|cache_name_pos
c_func
(paren
id|path
comma
id|namelen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_ge
l_int|0
)paren
id|ce-&gt;ce_mode
op_assign
id|active_cache
(braket
id|pos
)braket
op_member_access_from_pointer
id|ce_mode
suffix:semicolon
r_else
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|st.st_mode
)paren
)paren
id|ce-&gt;ce_mode
op_assign
id|create_ce_mode
c_func
(paren
id|S_IFREG
op_or
l_int|0666
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|index_path
c_func
(paren
id|ce-&gt;sha1
comma
id|path
comma
op_amp
id|st
comma
l_int|1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;unable to index file %s&quot;
comma
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|add_cache_entry
c_func
(paren
id|ce
comma
id|ADD_CACHE_OK_TO_ADD
)paren
)paren
id|die
c_func
(paren
l_string|&quot;unable to add %s to index&quot;
comma
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|verbose
)paren
id|printf
c_func
(paren
l_string|&quot;add &squot;%s&squot;&bslash;n&quot;
comma
id|path
)paren
suffix:semicolon
id|cache_tree_invalidate_path
c_func
(paren
id|active_cache_tree
comma
id|path
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ce_same_name
r_int
id|ce_same_name
c_func
(paren
r_struct
id|cache_entry
op_star
id|a
comma
r_struct
id|cache_entry
op_star
id|b
)paren
(brace
r_int
id|len
op_assign
id|ce_namelen
c_func
(paren
id|a
)paren
suffix:semicolon
r_return
id|ce_namelen
c_func
(paren
id|b
)paren
op_eq
id|len
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|a-&gt;name
comma
id|b-&gt;name
comma
id|len
)paren
suffix:semicolon
)brace
DECL|function|ce_path_match
r_int
id|ce_path_match
c_func
(paren
r_const
r_struct
id|cache_entry
op_star
id|ce
comma
r_const
r_char
op_star
op_star
id|pathspec
)paren
(brace
r_const
r_char
op_star
id|match
comma
op_star
id|name
suffix:semicolon
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pathspec
)paren
r_return
l_int|1
suffix:semicolon
id|len
op_assign
id|ce_namelen
c_func
(paren
id|ce
)paren
suffix:semicolon
id|name
op_assign
id|ce-&gt;name
suffix:semicolon
r_while
c_loop
(paren
(paren
id|match
op_assign
op_star
id|pathspec
op_increment
)paren
op_ne
l_int|NULL
)paren
(brace
r_int
id|matchlen
op_assign
id|strlen
c_func
(paren
id|match
)paren
suffix:semicolon
r_if
c_cond
(paren
id|matchlen
OG
id|len
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|name
comma
id|match
comma
id|matchlen
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|matchlen
op_logical_and
id|name
(braket
id|matchlen
op_minus
l_int|1
)braket
op_eq
l_char|&squot;/&squot;
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|name
(braket
id|matchlen
)braket
op_eq
l_char|&squot;/&squot;
op_logical_or
op_logical_neg
id|name
(braket
id|matchlen
)braket
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|matchlen
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * We fundamentally don&squot;t like some paths: we don&squot;t want&n; * dot or dot-dot anywhere, and for obvious reasons don&squot;t&n; * want to recurse into &quot;.git&quot; either.&n; *&n; * Also, we don&squot;t want double slashes or slashes at the&n; * end that can make pathnames ambiguous.&n; */
DECL|function|verify_dotfile
r_static
r_int
id|verify_dotfile
c_func
(paren
r_const
r_char
op_star
id|rest
)paren
(brace
multiline_comment|/*&n;&t; * The first character was &squot;.&squot;, but that&n;&t; * has already been discarded, we now test&n;&t; * the rest.&n;&t; */
r_switch
c_cond
(paren
op_star
id|rest
)paren
(brace
multiline_comment|/* &quot;.&quot; is not allowed */
r_case
l_char|&squot;&bslash;0&squot;
suffix:colon
r_case
l_char|&squot;/&squot;
suffix:colon
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * &quot;.git&quot; followed by  NUL or slash is bad. This&n;&t; * shares the path end test with the &quot;..&quot; case.&n;&t; */
r_case
l_char|&squot;g&squot;
suffix:colon
r_if
c_cond
(paren
id|rest
(braket
l_int|1
)braket
op_ne
l_char|&squot;i&squot;
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|rest
(braket
l_int|2
)braket
op_ne
l_char|&squot;t&squot;
)paren
r_break
suffix:semicolon
id|rest
op_add_assign
l_int|2
suffix:semicolon
multiline_comment|/* fallthrough */
r_case
l_char|&squot;.&squot;
suffix:colon
r_if
c_cond
(paren
id|rest
(braket
l_int|1
)braket
op_eq
l_char|&squot;&bslash;0&squot;
op_logical_or
id|rest
(braket
l_int|1
)braket
op_eq
l_char|&squot;/&squot;
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|verify_path
r_int
id|verify_path
c_func
(paren
r_const
r_char
op_star
id|path
)paren
(brace
r_char
id|c
suffix:semicolon
r_goto
id|inside
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;/&squot;
)paren
(brace
id|inside
suffix:colon
id|c
op_assign
op_star
id|path
op_increment
suffix:semicolon
r_switch
c_cond
(paren
id|c
)paren
(brace
r_default
suffix:colon
r_continue
suffix:semicolon
r_case
l_char|&squot;/&squot;
suffix:colon
r_case
l_char|&squot;&bslash;0&squot;
suffix:colon
r_break
suffix:semicolon
r_case
l_char|&squot;.&squot;
suffix:colon
r_if
c_cond
(paren
id|verify_dotfile
c_func
(paren
id|path
)paren
)paren
r_continue
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|c
op_assign
op_star
id|path
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Do we have another file that has the beginning components being a&n; * proper superset of the name we&squot;re trying to add?&n; */
DECL|function|has_file_name
r_static
r_int
id|has_file_name
c_func
(paren
r_const
r_struct
id|cache_entry
op_star
id|ce
comma
r_int
id|pos
comma
r_int
id|ok_to_replace
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_int
id|len
op_assign
id|ce_namelen
c_func
(paren
id|ce
)paren
suffix:semicolon
r_int
id|stage
op_assign
id|ce_stage
c_func
(paren
id|ce
)paren
suffix:semicolon
r_const
r_char
op_star
id|name
op_assign
id|ce-&gt;name
suffix:semicolon
r_while
c_loop
(paren
id|pos
OL
id|active_nr
)paren
(brace
r_struct
id|cache_entry
op_star
id|p
op_assign
id|active_cache
(braket
id|pos
op_increment
)braket
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ge
id|ce_namelen
c_func
(paren
id|p
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|name
comma
id|p-&gt;name
comma
id|len
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|ce_stage
c_func
(paren
id|p
)paren
op_ne
id|stage
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;name
(braket
id|len
)braket
op_ne
l_char|&squot;/&squot;
)paren
r_continue
suffix:semicolon
id|retval
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ok_to_replace
)paren
r_break
suffix:semicolon
id|remove_cache_entry_at
c_func
(paren
op_decrement
id|pos
)paren
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Do we have another file with a pathname that is a proper&n; * subset of the name we&squot;re trying to add?&n; */
DECL|function|has_dir_name
r_static
r_int
id|has_dir_name
c_func
(paren
r_const
r_struct
id|cache_entry
op_star
id|ce
comma
r_int
id|pos
comma
r_int
id|ok_to_replace
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_int
id|stage
op_assign
id|ce_stage
c_func
(paren
id|ce
)paren
suffix:semicolon
r_const
r_char
op_star
id|name
op_assign
id|ce-&gt;name
suffix:semicolon
r_const
r_char
op_star
id|slash
op_assign
id|name
op_plus
id|ce_namelen
c_func
(paren
id|ce
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|len
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_star
op_decrement
id|slash
op_eq
l_char|&squot;/&squot;
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|slash
op_le
id|ce-&gt;name
)paren
r_return
id|retval
suffix:semicolon
)brace
id|len
op_assign
id|slash
id|name
suffix:semicolon
id|pos
op_assign
id|cache_name_pos
c_func
(paren
id|name
comma
id|ntohs
c_func
(paren
id|create_ce_flags
c_func
(paren
id|len
comma
id|stage
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_ge
l_int|0
)paren
(brace
id|retval
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ok_to_replace
)paren
r_break
suffix:semicolon
id|remove_cache_entry_at
c_func
(paren
id|pos
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Trivial optimization: if we find an entry that&n;&t;&t; * already matches the sub-directory, then we know&n;&t;&t; * we&squot;re ok, and we can exit.&n;&t;&t; */
id|pos
op_assign
id|pos
op_minus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|pos
OL
id|active_nr
)paren
(brace
r_struct
id|cache_entry
op_star
id|p
op_assign
id|active_cache
(braket
id|pos
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ce_namelen
c_func
(paren
id|p
)paren
op_le
id|len
)paren
op_logical_or
(paren
id|p-&gt;name
(braket
id|len
)braket
op_ne
l_char|&squot;/&squot;
)paren
op_logical_or
id|memcmp
c_func
(paren
id|p-&gt;name
comma
id|name
comma
id|len
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* not our subdirectory */
r_if
c_cond
(paren
id|ce_stage
c_func
(paren
id|p
)paren
op_eq
id|stage
)paren
multiline_comment|/* p is at the same stage as our entry, and&n;&t;&t;&t;&t; * is a subdirectory of what we are looking&n;&t;&t;&t;&t; * at, so we cannot have conflicts at our&n;&t;&t;&t;&t; * level or anything shorter.&n;&t;&t;&t;&t; */
r_return
id|retval
suffix:semicolon
id|pos
op_increment
suffix:semicolon
)brace
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* We may be in a situation where we already have path/file and path&n; * is being added, or we already have path and path/file is being&n; * added.  Either one would result in a nonsense tree that has path&n; * twice when git-write-tree tries to write it out.  Prevent it.&n; * &n; * If ok-to-replace is specified, we remove the conflicting entries&n; * from the cache so the caller should recompute the insert position.&n; * When this happens, we return non-zero.&n; */
DECL|function|check_file_directory_conflict
r_static
r_int
id|check_file_directory_conflict
c_func
(paren
r_const
r_struct
id|cache_entry
op_star
id|ce
comma
r_int
id|pos
comma
r_int
id|ok_to_replace
)paren
(brace
multiline_comment|/*&n;&t; * We check if the path is a sub-path of a subsequent pathname&n;&t; * first, since removing those will not change the position&n;&t; * in the array&n;&t; */
r_int
id|retval
op_assign
id|has_file_name
c_func
(paren
id|ce
comma
id|pos
comma
id|ok_to_replace
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Then check if the path might have a clashing sub-directory&n;&t; * before it.&n;&t; */
r_return
id|retval
op_plus
id|has_dir_name
c_func
(paren
id|ce
comma
id|pos
comma
id|ok_to_replace
)paren
suffix:semicolon
)brace
DECL|function|add_cache_entry
r_int
id|add_cache_entry
c_func
(paren
r_struct
id|cache_entry
op_star
id|ce
comma
r_int
id|option
)paren
(brace
r_int
id|pos
suffix:semicolon
r_int
id|ok_to_add
op_assign
id|option
op_amp
id|ADD_CACHE_OK_TO_ADD
suffix:semicolon
r_int
id|ok_to_replace
op_assign
id|option
op_amp
id|ADD_CACHE_OK_TO_REPLACE
suffix:semicolon
r_int
id|skip_df_check
op_assign
id|option
op_amp
id|ADD_CACHE_SKIP_DFCHECK
suffix:semicolon
id|pos
op_assign
id|cache_name_pos
c_func
(paren
id|ce-&gt;name
comma
id|ntohs
c_func
(paren
id|ce-&gt;ce_flags
)paren
)paren
suffix:semicolon
multiline_comment|/* existing match? Just replace it. */
r_if
c_cond
(paren
id|pos
op_ge
l_int|0
)paren
(brace
id|active_cache_changed
op_assign
l_int|1
suffix:semicolon
id|active_cache
(braket
id|pos
)braket
op_assign
id|ce
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|pos
op_assign
id|pos
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Inserting a merged entry (&quot;stage 0&quot;) into the index&n;&t; * will always replace all non-merged entries..&n;&t; */
r_if
c_cond
(paren
id|pos
OL
id|active_nr
op_logical_and
id|ce_stage
c_func
(paren
id|ce
)paren
op_eq
l_int|0
)paren
(brace
r_while
c_loop
(paren
id|ce_same_name
c_func
(paren
id|active_cache
(braket
id|pos
)braket
comma
id|ce
)paren
)paren
(brace
id|ok_to_add
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|remove_cache_entry_at
c_func
(paren
id|pos
)paren
)paren
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|ok_to_add
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|verify_path
c_func
(paren
id|ce-&gt;name
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skip_df_check
op_logical_and
id|check_file_directory_conflict
c_func
(paren
id|ce
comma
id|pos
comma
id|ok_to_replace
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ok_to_replace
)paren
r_return
l_int|1
suffix:semicolon
id|pos
op_assign
id|cache_name_pos
c_func
(paren
id|ce-&gt;name
comma
id|ntohs
c_func
(paren
id|ce-&gt;ce_flags
)paren
)paren
suffix:semicolon
id|pos
op_assign
id|pos
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Make sure the array is big enough .. */
r_if
c_cond
(paren
id|active_nr
op_eq
id|active_alloc
)paren
(brace
id|active_alloc
op_assign
id|alloc_nr
c_func
(paren
id|active_alloc
)paren
suffix:semicolon
id|active_cache
op_assign
id|xrealloc
c_func
(paren
id|active_cache
comma
id|active_alloc
op_star
r_sizeof
(paren
r_struct
id|cache_entry
op_star
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Add it in.. */
id|active_nr
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|active_nr
OG
id|pos
)paren
id|memmove
c_func
(paren
id|active_cache
op_plus
id|pos
op_plus
l_int|1
comma
id|active_cache
op_plus
id|pos
comma
(paren
id|active_nr
id|pos
l_int|1
)paren
op_star
r_sizeof
(paren
id|ce
)paren
)paren
suffix:semicolon
id|active_cache
(braket
id|pos
)braket
op_assign
id|ce
suffix:semicolon
id|active_cache_changed
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * &quot;refresh&quot; does not calculate a new sha1 file or bring the&n; * cache up-to-date for mode/content changes. But what it&n; * _does_ do is to &quot;re-match&quot; the stat information of a file&n; * with the cache, so that you can refresh the cache for a&n; * file that hasn&squot;t been changed but where the stat entry is&n; * out of date.&n; *&n; * For example, you&squot;d want to do this after doing a &quot;git-read-tree&quot;,&n; * to link up the stat cache details with the proper files.&n; */
DECL|function|refresh_cache_entry
r_struct
id|cache_entry
op_star
id|refresh_cache_entry
c_func
(paren
r_struct
id|cache_entry
op_star
id|ce
comma
r_int
id|really
)paren
(brace
r_struct
id|stat
id|st
suffix:semicolon
r_struct
id|cache_entry
op_star
id|updated
suffix:semicolon
r_int
id|changed
comma
id|size
suffix:semicolon
r_if
c_cond
(paren
id|lstat
c_func
(paren
id|ce-&gt;name
comma
op_amp
id|st
)paren
OL
l_int|0
)paren
(brace
id|cache_errno
op_assign
id|errno
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|changed
op_assign
id|ce_match_stat
c_func
(paren
id|ce
comma
op_amp
id|st
comma
id|really
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|changed
)paren
(brace
r_if
c_cond
(paren
id|really
op_logical_and
id|assume_unchanged
op_logical_and
op_logical_neg
(paren
id|ce-&gt;ce_flags
op_amp
id|htons
c_func
(paren
id|CE_VALID
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* mark this one VALID again */
r_else
r_return
id|ce
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ce_modified
c_func
(paren
id|ce
comma
op_amp
id|st
comma
id|really
)paren
)paren
(brace
id|cache_errno
op_assign
id|EINVAL
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|size
op_assign
id|ce_size
c_func
(paren
id|ce
)paren
suffix:semicolon
id|updated
op_assign
id|xmalloc
c_func
(paren
id|size
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|updated
comma
id|ce
comma
id|size
)paren
suffix:semicolon
id|fill_stat_cache_info
c_func
(paren
id|updated
comma
op_amp
id|st
)paren
suffix:semicolon
multiline_comment|/* In this case, if really is not set, we should leave&n;&t; * CE_VALID bit alone.  Otherwise, paths marked with&n;&t; * --no-assume-unchanged (i.e. things to be edited) will&n;&t; * reacquire CE_VALID bit automatically, which is not&n;&t; * really what we want.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|really
op_logical_and
id|assume_unchanged
op_logical_and
op_logical_neg
(paren
id|ce-&gt;ce_flags
op_amp
id|htons
c_func
(paren
id|CE_VALID
)paren
)paren
)paren
id|updated-&gt;ce_flags
op_and_assign
op_complement
id|htons
c_func
(paren
id|CE_VALID
)paren
suffix:semicolon
r_return
id|updated
suffix:semicolon
)brace
DECL|function|refresh_cache
r_int
id|refresh_cache
c_func
(paren
r_int
r_int
id|flags
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|has_errors
op_assign
l_int|0
suffix:semicolon
r_int
id|really
op_assign
(paren
id|flags
op_amp
id|REFRESH_REALLY
)paren
op_ne
l_int|0
suffix:semicolon
r_int
id|allow_unmerged
op_assign
(paren
id|flags
op_amp
id|REFRESH_UNMERGED
)paren
op_ne
l_int|0
suffix:semicolon
r_int
id|quiet
op_assign
(paren
id|flags
op_amp
id|REFRESH_QUIET
)paren
op_ne
l_int|0
suffix:semicolon
r_int
id|not_new
op_assign
(paren
id|flags
op_amp
id|REFRESH_IGNORE_MISSING
)paren
op_ne
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|active_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|cache_entry
op_star
id|ce
comma
op_star
r_new
suffix:semicolon
id|ce
op_assign
id|active_cache
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ce_stage
c_func
(paren
id|ce
)paren
)paren
(brace
r_while
c_loop
(paren
(paren
id|i
OL
id|active_nr
)paren
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|active_cache
(braket
id|i
)braket
op_member_access_from_pointer
id|name
comma
id|ce-&gt;name
)paren
)paren
id|i
op_increment
suffix:semicolon
id|i
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|allow_unmerged
)paren
r_continue
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s: needs merge&bslash;n&quot;
comma
id|ce-&gt;name
)paren
suffix:semicolon
id|has_errors
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_new
op_assign
id|refresh_cache_entry
c_func
(paren
id|ce
comma
id|really
)paren
suffix:semicolon
r_if
c_cond
(paren
r_new
op_eq
id|ce
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
)paren
(brace
r_if
c_cond
(paren
id|not_new
op_logical_and
id|cache_errno
op_eq
id|ENOENT
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|really
op_logical_and
id|cache_errno
op_eq
id|EINVAL
)paren
(brace
multiline_comment|/* If we are doing --really-refresh that&n;&t;&t;&t;&t; * means the index is not valid anymore.&n;&t;&t;&t;&t; */
id|ce-&gt;ce_flags
op_and_assign
op_complement
id|htons
c_func
(paren
id|CE_VALID
)paren
suffix:semicolon
id|active_cache_changed
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|quiet
)paren
r_continue
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s: needs update&bslash;n&quot;
comma
id|ce-&gt;name
)paren
suffix:semicolon
id|has_errors
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|active_cache_changed
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* You can NOT just free active_cache[i] here, since it&n;&t;&t; * might not be necessarily malloc()ed but can also come&n;&t;&t; * from mmap(). */
id|active_cache
(braket
id|i
)braket
op_assign
r_new
suffix:semicolon
)brace
r_return
id|has_errors
suffix:semicolon
)brace
DECL|function|verify_hdr
r_static
r_int
id|verify_hdr
c_func
(paren
r_struct
id|cache_header
op_star
id|hdr
comma
r_int
r_int
id|size
)paren
(brace
id|SHA_CTX
id|c
suffix:semicolon
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hdr-&gt;hdr_signature
op_ne
id|htonl
c_func
(paren
id|CACHE_SIGNATURE
)paren
)paren
r_return
id|error
c_func
(paren
l_string|&quot;bad signature&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hdr-&gt;hdr_version
op_ne
id|htonl
c_func
(paren
l_int|2
)paren
)paren
r_return
id|error
c_func
(paren
l_string|&quot;bad index version&quot;
)paren
suffix:semicolon
id|SHA1_Init
c_func
(paren
op_amp
id|c
)paren
suffix:semicolon
id|SHA1_Update
c_func
(paren
op_amp
id|c
comma
id|hdr
comma
id|size
l_int|20
)paren
suffix:semicolon
id|SHA1_Final
c_func
(paren
id|sha1
comma
op_amp
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hashcmp
c_func
(paren
id|sha1
comma
(paren
r_int
r_char
op_star
)paren
id|hdr
op_plus
id|size
l_int|20
)paren
)paren
r_return
id|error
c_func
(paren
l_string|&quot;bad index file sha1 signature&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|read_index_extension
r_static
r_int
id|read_index_extension
c_func
(paren
r_const
r_char
op_star
id|ext
comma
r_void
op_star
id|data
comma
r_int
r_int
id|sz
)paren
(brace
r_switch
c_cond
(paren
id|CACHE_EXT
c_func
(paren
id|ext
)paren
)paren
(brace
r_case
id|CACHE_EXT_TREE
suffix:colon
id|active_cache_tree
op_assign
id|cache_tree_read
c_func
(paren
id|data
comma
id|sz
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
op_star
id|ext
OL
l_char|&squot;A&squot;
op_logical_or
l_char|&squot;Z&squot;
OL
op_star
id|ext
)paren
r_return
id|error
c_func
(paren
l_string|&quot;index uses %.4s extension, which we do not understand&quot;
comma
id|ext
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;ignoring %.4s extension&bslash;n&quot;
comma
id|ext
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|read_cache
r_int
id|read_cache
c_func
(paren
r_void
)paren
(brace
r_return
id|read_cache_from
c_func
(paren
id|get_index_file
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* remember to discard_cache() before reading a different cache! */
DECL|function|read_cache_from
r_int
id|read_cache_from
c_func
(paren
r_const
r_char
op_star
id|path
)paren
(brace
r_int
id|fd
comma
id|i
suffix:semicolon
r_struct
id|stat
id|st
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
r_struct
id|cache_header
op_star
id|hdr
suffix:semicolon
id|errno
op_assign
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|cache_mmap
)paren
r_return
id|active_nr
suffix:semicolon
id|errno
op_assign
id|ENOENT
suffix:semicolon
id|index_file_timestamp
op_assign
l_int|0
suffix:semicolon
id|fd
op_assign
id|open
c_func
(paren
id|path
comma
id|O_RDONLY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|errno
op_eq
id|ENOENT
)paren
r_return
l_int|0
suffix:semicolon
id|die
c_func
(paren
l_string|&quot;index file open failed (%s)&quot;
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
)brace
id|cache_mmap
op_assign
id|MAP_FAILED
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fstat
c_func
(paren
id|fd
comma
op_amp
id|st
)paren
)paren
(brace
id|cache_mmap_size
op_assign
id|st.st_size
suffix:semicolon
id|errno
op_assign
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|cache_mmap_size
op_ge
r_sizeof
(paren
r_struct
id|cache_header
)paren
op_plus
l_int|20
)paren
id|cache_mmap
op_assign
id|mmap
c_func
(paren
l_int|NULL
comma
id|cache_mmap_size
comma
id|PROT_READ
op_or
id|PROT_WRITE
comma
id|MAP_PRIVATE
comma
id|fd
comma
l_int|0
)paren
suffix:semicolon
)brace
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cache_mmap
op_eq
id|MAP_FAILED
)paren
id|die
c_func
(paren
l_string|&quot;index file mmap failed (%s)&quot;
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
id|hdr
op_assign
id|cache_mmap
suffix:semicolon
r_if
c_cond
(paren
id|verify_hdr
c_func
(paren
id|hdr
comma
id|cache_mmap_size
)paren
OL
l_int|0
)paren
r_goto
id|unmap
suffix:semicolon
id|active_nr
op_assign
id|ntohl
c_func
(paren
id|hdr-&gt;hdr_entries
)paren
suffix:semicolon
id|active_alloc
op_assign
id|alloc_nr
c_func
(paren
id|active_nr
)paren
suffix:semicolon
id|active_cache
op_assign
id|xcalloc
c_func
(paren
id|active_alloc
comma
r_sizeof
(paren
r_struct
id|cache_entry
op_star
)paren
)paren
suffix:semicolon
id|offset
op_assign
r_sizeof
(paren
op_star
id|hdr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|active_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|cache_entry
op_star
id|ce
op_assign
(paren
r_struct
id|cache_entry
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|cache_mmap
op_plus
id|offset
)paren
suffix:semicolon
id|offset
op_assign
id|offset
op_plus
id|ce_size
c_func
(paren
id|ce
)paren
suffix:semicolon
id|active_cache
(braket
id|i
)braket
op_assign
id|ce
suffix:semicolon
)brace
id|index_file_timestamp
op_assign
id|st.st_mtime
suffix:semicolon
r_while
c_loop
(paren
id|offset
op_le
id|cache_mmap_size
l_int|20
l_int|8
)paren
(brace
multiline_comment|/* After an array of active_nr index entries,&n;&t;&t; * there can be arbitrary number of extended&n;&t;&t; * sections, each of which is prefixed with&n;&t;&t; * extension name (4-byte) and section length&n;&t;&t; * in 4-byte network byte order.&n;&t;&t; */
r_int
r_int
id|extsize
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|extsize
comma
(paren
r_char
op_star
)paren
id|cache_mmap
op_plus
id|offset
op_plus
l_int|4
comma
l_int|4
)paren
suffix:semicolon
id|extsize
op_assign
id|ntohl
c_func
(paren
id|extsize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_index_extension
c_func
(paren
(paren
(paren
r_const
r_char
op_star
)paren
id|cache_mmap
)paren
op_plus
id|offset
comma
(paren
r_char
op_star
)paren
id|cache_mmap
op_plus
id|offset
op_plus
l_int|8
comma
id|extsize
)paren
OL
l_int|0
)paren
r_goto
id|unmap
suffix:semicolon
id|offset
op_add_assign
l_int|8
suffix:semicolon
id|offset
op_add_assign
id|extsize
suffix:semicolon
)brace
r_return
id|active_nr
suffix:semicolon
id|unmap
suffix:colon
id|munmap
c_func
(paren
id|cache_mmap
comma
id|cache_mmap_size
)paren
suffix:semicolon
id|errno
op_assign
id|EINVAL
suffix:semicolon
id|die
c_func
(paren
l_string|&quot;index file corrupt&quot;
)paren
suffix:semicolon
)brace
DECL|function|discard_cache
r_int
id|discard_cache
c_func
(paren
r_void
)paren
(brace
r_int
id|ret
suffix:semicolon
id|active_nr
op_assign
id|active_cache_changed
op_assign
l_int|0
suffix:semicolon
id|index_file_timestamp
op_assign
l_int|0
suffix:semicolon
id|cache_tree_free
c_func
(paren
op_amp
id|active_cache_tree
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cache_mmap
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|ret
op_assign
id|munmap
c_func
(paren
id|cache_mmap
comma
id|cache_mmap_size
)paren
suffix:semicolon
id|cache_mmap
op_assign
l_int|NULL
suffix:semicolon
id|cache_mmap_size
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* no need to throw away allocated active_cache */
r_return
id|ret
suffix:semicolon
)brace
DECL|macro|WRITE_BUFFER_SIZE
mdefine_line|#define WRITE_BUFFER_SIZE 8192
DECL|variable|write_buffer
r_static
r_int
r_char
id|write_buffer
(braket
id|WRITE_BUFFER_SIZE
)braket
suffix:semicolon
DECL|variable|write_buffer_len
r_static
r_int
r_int
id|write_buffer_len
suffix:semicolon
DECL|function|ce_write_flush
r_static
r_int
id|ce_write_flush
c_func
(paren
id|SHA_CTX
op_star
id|context
comma
r_int
id|fd
)paren
(brace
r_int
r_int
id|buffered
op_assign
id|write_buffer_len
suffix:semicolon
r_if
c_cond
(paren
id|buffered
)paren
(brace
id|SHA1_Update
c_func
(paren
id|context
comma
id|write_buffer
comma
id|buffered
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write
c_func
(paren
id|fd
comma
id|write_buffer
comma
id|buffered
)paren
op_ne
id|buffered
)paren
r_return
l_int|1
suffix:semicolon
id|write_buffer_len
op_assign
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ce_write
r_static
r_int
id|ce_write
c_func
(paren
id|SHA_CTX
op_star
id|context
comma
r_int
id|fd
comma
r_void
op_star
id|data
comma
r_int
r_int
id|len
)paren
(brace
r_while
c_loop
(paren
id|len
)paren
(brace
r_int
r_int
id|buffered
op_assign
id|write_buffer_len
suffix:semicolon
r_int
r_int
id|partial
op_assign
id|WRITE_BUFFER_SIZE
id|buffered
suffix:semicolon
r_if
c_cond
(paren
id|partial
OG
id|len
)paren
id|partial
op_assign
id|len
suffix:semicolon
id|memcpy
c_func
(paren
id|write_buffer
op_plus
id|buffered
comma
id|data
comma
id|partial
)paren
suffix:semicolon
id|buffered
op_add_assign
id|partial
suffix:semicolon
r_if
c_cond
(paren
id|buffered
op_eq
id|WRITE_BUFFER_SIZE
)paren
(brace
id|write_buffer_len
op_assign
id|buffered
suffix:semicolon
r_if
c_cond
(paren
id|ce_write_flush
c_func
(paren
id|context
comma
id|fd
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|buffered
op_assign
l_int|0
suffix:semicolon
)brace
id|write_buffer_len
op_assign
id|buffered
suffix:semicolon
id|len
op_sub_assign
id|partial
suffix:semicolon
id|data
op_assign
(paren
r_char
op_star
)paren
id|data
op_plus
id|partial
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|write_index_ext_header
r_static
r_int
id|write_index_ext_header
c_func
(paren
id|SHA_CTX
op_star
id|context
comma
r_int
id|fd
comma
r_int
r_int
id|ext
comma
r_int
r_int
id|sz
)paren
(brace
id|ext
op_assign
id|htonl
c_func
(paren
id|ext
)paren
suffix:semicolon
id|sz
op_assign
id|htonl
c_func
(paren
id|sz
)paren
suffix:semicolon
r_return
(paren
(paren
id|ce_write
c_func
(paren
id|context
comma
id|fd
comma
op_amp
id|ext
comma
l_int|4
)paren
OL
l_int|0
)paren
op_logical_or
(paren
id|ce_write
c_func
(paren
id|context
comma
id|fd
comma
op_amp
id|sz
comma
l_int|4
)paren
OL
l_int|0
)paren
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|function|ce_flush
r_static
r_int
id|ce_flush
c_func
(paren
id|SHA_CTX
op_star
id|context
comma
r_int
id|fd
)paren
(brace
r_int
r_int
id|left
op_assign
id|write_buffer_len
suffix:semicolon
r_if
c_cond
(paren
id|left
)paren
(brace
id|write_buffer_len
op_assign
l_int|0
suffix:semicolon
id|SHA1_Update
c_func
(paren
id|context
comma
id|write_buffer
comma
id|left
)paren
suffix:semicolon
)brace
multiline_comment|/* Flush first if not enough space for SHA1 signature */
r_if
c_cond
(paren
id|left
op_plus
l_int|20
OG
id|WRITE_BUFFER_SIZE
)paren
(brace
r_if
c_cond
(paren
id|write
c_func
(paren
id|fd
comma
id|write_buffer
comma
id|left
)paren
op_ne
id|left
)paren
r_return
l_int|1
suffix:semicolon
id|left
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Append the SHA1 signature at the end */
id|SHA1_Final
c_func
(paren
id|write_buffer
op_plus
id|left
comma
id|context
)paren
suffix:semicolon
id|left
op_add_assign
l_int|20
suffix:semicolon
r_return
(paren
id|write
c_func
(paren
id|fd
comma
id|write_buffer
comma
id|left
)paren
op_ne
id|left
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|function|ce_smudge_racily_clean_entry
r_static
r_void
id|ce_smudge_racily_clean_entry
c_func
(paren
r_struct
id|cache_entry
op_star
id|ce
)paren
(brace
multiline_comment|/*&n;&t; * The only thing we care about in this function is to smudge the&n;&t; * falsely clean entry due to touch-update-touch race, so we leave&n;&t; * everything else as they are.  We are called for entries whose&n;&t; * ce_mtime match the index file mtime.&n;&t; */
r_struct
id|stat
id|st
suffix:semicolon
r_if
c_cond
(paren
id|lstat
c_func
(paren
id|ce-&gt;name
comma
op_amp
id|st
)paren
OL
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|ce_match_stat_basic
c_func
(paren
id|ce
comma
op_amp
id|st
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|ce_modified_check_fs
c_func
(paren
id|ce
comma
op_amp
id|st
)paren
)paren
(brace
multiline_comment|/* This is &quot;racily clean&quot;; smudge it.  Note that this&n;&t;&t; * is a tricky code.  At first glance, it may appear&n;&t;&t; * that it can break with this sequence:&n;&t;&t; *&n;&t;&t; * $ echo xyzzy &gt;frotz&n;&t;&t; * $ git-update-index --add frotz&n;&t;&t; * $ : &gt;frotz&n;&t;&t; * $ sleep 3&n;&t;&t; * $ echo filfre &gt;nitfol&n;&t;&t; * $ git-update-index --add nitfol&n;&t;&t; *&n;&t;&t; * but it does not.  When the second update-index runs,&n;&t;&t; * it notices that the entry &quot;frotz&quot; has the same timestamp&n;&t;&t; * as index, and if we were to smudge it by resetting its&n;&t;&t; * size to zero here, then the object name recorded&n;&t;&t; * in index is the 6-byte file but the cached stat information&n;&t;&t; * becomes zero --- which would then match what we would&n;&t;&t; * obtain from the filesystem next time we stat(&quot;frotz&quot;). &n;&t;&t; *&n;&t;&t; * However, the second update-index, before calling&n;&t;&t; * this function, notices that the cached size is 6&n;&t;&t; * bytes and what is on the filesystem is an empty&n;&t;&t; * file, and never calls us, so the cached size information&n;&t;&t; * for &quot;frotz&quot; stays 6 which does not match the filesystem.&n;&t;&t; */
id|ce-&gt;ce_size
op_assign
id|htonl
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
)brace
DECL|function|write_cache
r_int
id|write_cache
c_func
(paren
r_int
id|newfd
comma
r_struct
id|cache_entry
op_star
op_star
id|cache
comma
r_int
id|entries
)paren
(brace
id|SHA_CTX
id|c
suffix:semicolon
r_struct
id|cache_header
id|hdr
suffix:semicolon
r_int
id|i
comma
id|removed
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|removed
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|entries
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|cache
(braket
id|i
)braket
op_member_access_from_pointer
id|ce_mode
)paren
id|removed
op_increment
suffix:semicolon
id|hdr.hdr_signature
op_assign
id|htonl
c_func
(paren
id|CACHE_SIGNATURE
)paren
suffix:semicolon
id|hdr.hdr_version
op_assign
id|htonl
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|hdr.hdr_entries
op_assign
id|htonl
c_func
(paren
id|entries
id|removed
)paren
suffix:semicolon
id|SHA1_Init
c_func
(paren
op_amp
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ce_write
c_func
(paren
op_amp
id|c
comma
id|newfd
comma
op_amp
id|hdr
comma
r_sizeof
(paren
id|hdr
)paren
)paren
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|entries
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|cache_entry
op_star
id|ce
op_assign
id|cache
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ce-&gt;ce_mode
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|index_file_timestamp
op_logical_and
id|index_file_timestamp
op_le
id|ntohl
c_func
(paren
id|ce-&gt;ce_mtime.sec
)paren
)paren
id|ce_smudge_racily_clean_entry
c_func
(paren
id|ce
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ce_write
c_func
(paren
op_amp
id|c
comma
id|newfd
comma
id|ce
comma
id|ce_size
c_func
(paren
id|ce
)paren
)paren
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Write extension data here */
r_if
c_cond
(paren
id|active_cache_tree
)paren
(brace
r_int
r_int
id|sz
suffix:semicolon
r_void
op_star
id|data
op_assign
id|cache_tree_write
c_func
(paren
id|active_cache_tree
comma
op_amp
id|sz
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data
op_logical_and
op_logical_neg
id|write_index_ext_header
c_func
(paren
op_amp
id|c
comma
id|newfd
comma
id|CACHE_EXT_TREE
comma
id|sz
)paren
op_logical_and
op_logical_neg
id|ce_write
c_func
(paren
op_amp
id|c
comma
id|newfd
comma
id|data
comma
id|sz
)paren
)paren
suffix:semicolon
r_else
(brace
id|free
c_func
(paren
id|data
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
id|ce_flush
c_func
(paren
op_amp
id|c
comma
id|newfd
)paren
suffix:semicolon
)brace
eof
