macro_line|#include &quot;cache.h&quot;
multiline_comment|/*&n; * versioncmp(): copied from string/strverscmp.c in glibc commit&n; * ee9247c38a8def24a59eb5cfb7196a98bef8cfdc, reformatted to Git coding&n; * style. The implementation is under LGPL-2.1 and Git relicenses it&n; * to GPLv2.&n; */
multiline_comment|/*&n; * states: S_N: normal, S_I: comparing integral part, S_F: comparing&n; * fractionnal parts, S_Z: idem but with leading Zeroes only&n; */
DECL|macro|S_N
mdefine_line|#define  S_N    0x0
DECL|macro|S_I
mdefine_line|#define  S_I    0x3
DECL|macro|S_F
mdefine_line|#define  S_F    0x6
DECL|macro|S_Z
mdefine_line|#define  S_Z    0x9
multiline_comment|/* result_type: CMP: return diff; LEN: compare using len_diff/diff */
DECL|macro|CMP
mdefine_line|#define  CMP    2
DECL|macro|LEN
mdefine_line|#define  LEN    3
multiline_comment|/*&n; * Compare S1 and S2 as strings holding indices/version numbers,&n; * returning less than, equal to or greater than zero if S1 is less&n; * than, equal to or greater than S2 (for more info, see the texinfo&n; * doc).&n; */
DECL|function|versioncmp
r_int
id|versioncmp
c_func
(paren
r_const
r_char
op_star
id|s1
comma
r_const
r_char
op_star
id|s2
)paren
(brace
r_const
r_int
r_char
op_star
id|p1
op_assign
(paren
r_const
r_int
r_char
op_star
)paren
id|s1
suffix:semicolon
r_const
r_int
r_char
op_star
id|p2
op_assign
(paren
r_const
r_int
r_char
op_star
)paren
id|s2
suffix:semicolon
r_int
r_char
id|c1
comma
id|c2
suffix:semicolon
r_int
id|state
comma
id|diff
suffix:semicolon
multiline_comment|/*&n;&t; * Symbol(s)    0       [1-9]   others&n;&t; * Transition   (10) 0  (01) d  (00) x&n;&t; */
r_static
r_const
r_uint8
id|next_state
(braket
)braket
op_assign
(brace
multiline_comment|/* state    x    d    0  */
multiline_comment|/* S_N */
id|S_N
comma
id|S_I
comma
id|S_Z
comma
multiline_comment|/* S_I */
id|S_N
comma
id|S_I
comma
id|S_I
comma
multiline_comment|/* S_F */
id|S_N
comma
id|S_F
comma
id|S_F
comma
multiline_comment|/* S_Z */
id|S_N
comma
id|S_F
comma
id|S_Z
)brace
suffix:semicolon
r_static
r_const
r_int8
id|result_type
(braket
)braket
op_assign
(brace
multiline_comment|/* state   x/x  x/d  x/0  d/x  d/d  d/0  0/x  0/d  0/0  */
multiline_comment|/* S_N */
id|CMP
comma
id|CMP
comma
id|CMP
comma
id|CMP
comma
id|LEN
comma
id|CMP
comma
id|CMP
comma
id|CMP
comma
id|CMP
comma
multiline_comment|/* S_I */
id|CMP
comma
l_int|1
comma
l_int|1
comma
op_plus
l_int|1
comma
id|LEN
comma
id|LEN
comma
op_plus
l_int|1
comma
id|LEN
comma
id|LEN
comma
multiline_comment|/* S_F */
id|CMP
comma
id|CMP
comma
id|CMP
comma
id|CMP
comma
id|CMP
comma
id|CMP
comma
id|CMP
comma
id|CMP
comma
id|CMP
comma
multiline_comment|/* S_Z */
id|CMP
comma
op_plus
l_int|1
comma
op_plus
l_int|1
comma
l_int|1
comma
id|CMP
comma
id|CMP
comma
l_int|1
comma
id|CMP
comma
id|CMP
)brace
suffix:semicolon
r_if
c_cond
(paren
id|p1
op_eq
id|p2
)paren
r_return
l_int|0
suffix:semicolon
id|c1
op_assign
op_star
id|p1
op_increment
suffix:semicolon
id|c2
op_assign
op_star
id|p2
op_increment
suffix:semicolon
multiline_comment|/* Hint: &squot;0&squot; is a digit too.  */
id|state
op_assign
id|S_N
op_plus
(paren
(paren
id|c1
op_eq
l_char|&squot;0&squot;
)paren
op_plus
(paren
id|isdigit
(paren
id|c1
)paren
op_ne
l_int|0
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|diff
op_assign
id|c1
id|c2
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|c1
op_eq
l_char|&squot;&bslash;0&squot;
)paren
r_return
id|diff
suffix:semicolon
id|state
op_assign
id|next_state
(braket
id|state
)braket
suffix:semicolon
id|c1
op_assign
op_star
id|p1
op_increment
suffix:semicolon
id|c2
op_assign
op_star
id|p2
op_increment
suffix:semicolon
id|state
op_add_assign
(paren
id|c1
op_eq
l_char|&squot;0&squot;
)paren
op_plus
(paren
id|isdigit
(paren
id|c1
)paren
op_ne
l_int|0
)paren
suffix:semicolon
)brace
id|state
op_assign
id|result_type
(braket
id|state
op_star
l_int|3
op_plus
(paren
(paren
(paren
id|c2
op_eq
l_char|&squot;0&squot;
)paren
op_plus
(paren
id|isdigit
(paren
id|c2
)paren
op_ne
l_int|0
)paren
)paren
)paren
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|state
)paren
(brace
r_case
id|CMP
suffix:colon
r_return
id|diff
suffix:semicolon
r_case
id|LEN
suffix:colon
r_while
c_loop
(paren
id|isdigit
(paren
op_star
id|p1
op_increment
)paren
)paren
r_if
c_cond
(paren
op_logical_neg
id|isdigit
(paren
op_star
id|p2
op_increment
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
id|isdigit
(paren
op_star
id|p2
)paren
ques
c_cond
l_int|1
suffix:colon
id|diff
suffix:semicolon
r_default
suffix:colon
r_return
id|state
suffix:semicolon
)brace
)brace
eof
