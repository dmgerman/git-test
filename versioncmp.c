macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;string-list.h&quot;
multiline_comment|/*&n; * versioncmp(): copied from string/strverscmp.c in glibc commit&n; * ee9247c38a8def24a59eb5cfb7196a98bef8cfdc, reformatted to Git coding&n; * style. The implementation is under LGPL-2.1 and Git relicenses it&n; * to GPLv2.&n; */
multiline_comment|/*&n; * states: S_N: normal, S_I: comparing integral part, S_F: comparing&n; * fractionnal parts, S_Z: idem but with leading Zeroes only&n; */
DECL|macro|S_N
mdefine_line|#define  S_N    0x0
DECL|macro|S_I
mdefine_line|#define  S_I    0x3
DECL|macro|S_F
mdefine_line|#define  S_F    0x6
DECL|macro|S_Z
mdefine_line|#define  S_Z    0x9
multiline_comment|/* result_type: CMP: return diff; LEN: compare using len_diff/diff */
DECL|macro|CMP
mdefine_line|#define  CMP    2
DECL|macro|LEN
mdefine_line|#define  LEN    3
DECL|variable|prereleases
r_static
r_const
r_struct
id|string_list
op_star
id|prereleases
suffix:semicolon
DECL|variable|initialized
r_static
r_int
id|initialized
suffix:semicolon
multiline_comment|/*&n; * p1 and p2 point to the first different character in two strings. If&n; * either p1 or p2 starts with a prerelease suffix, it will be forced&n; * to be on top.&n; *&n; * If both p1 and p2 start with (different) suffix, the order is&n; * determined by config file.&n; *&n; * Note that we don&squot;t have to deal with the situation when both p1 and&n; * p2 start with the same suffix because the common part is already&n; * consumed by the caller.&n; *&n; * Return non-zero if *diff contains the return value for versioncmp()&n; */
DECL|function|swap_prereleases
r_static
r_int
id|swap_prereleases
c_func
(paren
r_const
r_void
op_star
id|p1_
comma
r_const
r_void
op_star
id|p2_
comma
r_int
op_star
id|diff
)paren
(brace
r_const
r_char
op_star
id|p1
op_assign
id|p1_
suffix:semicolon
r_const
r_char
op_star
id|p2
op_assign
id|p2_
suffix:semicolon
r_int
id|i
comma
id|i1
op_assign
l_int|1
comma
id|i2
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|prereleases-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_char
op_star
id|suffix
op_assign
id|prereleases-&gt;items
(braket
id|i
)braket
dot
id|string
suffix:semicolon
r_if
c_cond
(paren
id|i1
op_eq
l_int|1
op_logical_and
id|starts_with
c_func
(paren
id|p1
comma
id|suffix
)paren
)paren
id|i1
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|i2
op_eq
l_int|1
op_logical_and
id|starts_with
c_func
(paren
id|p2
comma
id|suffix
)paren
)paren
id|i2
op_assign
id|i
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i1
op_eq
l_int|1
op_logical_and
id|i2
op_eq
l_int|1
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|i1
op_ge
l_int|0
op_logical_and
id|i2
op_ge
l_int|0
)paren
op_star
id|diff
op_assign
id|i1
id|i2
suffix:semicolon
r_else
r_if
c_cond
(paren
id|i1
op_ge
l_int|0
)paren
op_star
id|diff
op_assign
l_int|1
suffix:semicolon
r_else
multiline_comment|/* if (i2 &gt;= 0) */
op_star
id|diff
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Compare S1 and S2 as strings holding indices/version numbers,&n; * returning less than, equal to or greater than zero if S1 is less&n; * than, equal to or greater than S2 (for more info, see the texinfo&n; * doc).&n; */
DECL|function|versioncmp
r_int
id|versioncmp
c_func
(paren
r_const
r_char
op_star
id|s1
comma
r_const
r_char
op_star
id|s2
)paren
(brace
r_const
r_int
r_char
op_star
id|p1
op_assign
(paren
r_const
r_int
r_char
op_star
)paren
id|s1
suffix:semicolon
r_const
r_int
r_char
op_star
id|p2
op_assign
(paren
r_const
r_int
r_char
op_star
)paren
id|s2
suffix:semicolon
r_int
r_char
id|c1
comma
id|c2
suffix:semicolon
r_int
id|state
comma
id|diff
suffix:semicolon
multiline_comment|/*&n;&t; * Symbol(s)    0       [1-9]   others&n;&t; * Transition   (10) 0  (01) d  (00) x&n;&t; */
r_static
r_const
r_uint8
id|next_state
(braket
)braket
op_assign
(brace
multiline_comment|/* state    x    d    0  */
multiline_comment|/* S_N */
id|S_N
comma
id|S_I
comma
id|S_Z
comma
multiline_comment|/* S_I */
id|S_N
comma
id|S_I
comma
id|S_I
comma
multiline_comment|/* S_F */
id|S_N
comma
id|S_F
comma
id|S_F
comma
multiline_comment|/* S_Z */
id|S_N
comma
id|S_F
comma
id|S_Z
)brace
suffix:semicolon
r_static
r_const
r_int8
id|result_type
(braket
)braket
op_assign
(brace
multiline_comment|/* state   x/x  x/d  x/0  d/x  d/d  d/0  0/x  0/d  0/0  */
multiline_comment|/* S_N */
id|CMP
comma
id|CMP
comma
id|CMP
comma
id|CMP
comma
id|LEN
comma
id|CMP
comma
id|CMP
comma
id|CMP
comma
id|CMP
comma
multiline_comment|/* S_I */
id|CMP
comma
l_int|1
comma
l_int|1
comma
op_plus
l_int|1
comma
id|LEN
comma
id|LEN
comma
op_plus
l_int|1
comma
id|LEN
comma
id|LEN
comma
multiline_comment|/* S_F */
id|CMP
comma
id|CMP
comma
id|CMP
comma
id|CMP
comma
id|CMP
comma
id|CMP
comma
id|CMP
comma
id|CMP
comma
id|CMP
comma
multiline_comment|/* S_Z */
id|CMP
comma
op_plus
l_int|1
comma
op_plus
l_int|1
comma
l_int|1
comma
id|CMP
comma
id|CMP
comma
l_int|1
comma
id|CMP
comma
id|CMP
)brace
suffix:semicolon
r_if
c_cond
(paren
id|p1
op_eq
id|p2
)paren
r_return
l_int|0
suffix:semicolon
id|c1
op_assign
op_star
id|p1
op_increment
suffix:semicolon
id|c2
op_assign
op_star
id|p2
op_increment
suffix:semicolon
multiline_comment|/* Hint: &squot;0&squot; is a digit too.  */
id|state
op_assign
id|S_N
op_plus
(paren
(paren
id|c1
op_eq
l_char|&squot;0&squot;
)paren
op_plus
(paren
id|isdigit
(paren
id|c1
)paren
op_ne
l_int|0
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|diff
op_assign
id|c1
id|c2
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|c1
op_eq
l_char|&squot;&bslash;0&squot;
)paren
r_return
id|diff
suffix:semicolon
id|state
op_assign
id|next_state
(braket
id|state
)braket
suffix:semicolon
id|c1
op_assign
op_star
id|p1
op_increment
suffix:semicolon
id|c2
op_assign
op_star
id|p2
op_increment
suffix:semicolon
id|state
op_add_assign
(paren
id|c1
op_eq
l_char|&squot;0&squot;
)paren
op_plus
(paren
id|isdigit
(paren
id|c1
)paren
op_ne
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|initialized
)paren
(brace
id|initialized
op_assign
l_int|1
suffix:semicolon
id|prereleases
op_assign
id|git_config_get_value_multi
c_func
(paren
l_string|&quot;versionsort.prereleasesuffix&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|prereleases
op_logical_and
id|swap_prereleases
c_func
(paren
id|p1
l_int|1
comma
id|p2
l_int|1
comma
op_amp
id|diff
)paren
)paren
r_return
id|diff
suffix:semicolon
id|state
op_assign
id|result_type
(braket
id|state
op_star
l_int|3
op_plus
(paren
(paren
(paren
id|c2
op_eq
l_char|&squot;0&squot;
)paren
op_plus
(paren
id|isdigit
(paren
id|c2
)paren
op_ne
l_int|0
)paren
)paren
)paren
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|state
)paren
(brace
r_case
id|CMP
suffix:colon
r_return
id|diff
suffix:semicolon
r_case
id|LEN
suffix:colon
r_while
c_loop
(paren
id|isdigit
(paren
op_star
id|p1
op_increment
)paren
)paren
r_if
c_cond
(paren
op_logical_neg
id|isdigit
(paren
op_star
id|p2
op_increment
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
id|isdigit
(paren
op_star
id|p2
)paren
ques
c_cond
l_int|1
suffix:colon
id|diff
suffix:semicolon
r_default
suffix:colon
r_return
id|state
suffix:semicolon
)brace
)brace
eof
