multiline_comment|/*&n; * Another stupid program, this one parsing the headers of an&n; * email to figure out authorship and subject&n; */
macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;builtin.h&quot;
macro_line|#include &quot;utf8.h&quot;
macro_line|#include &quot;strbuf.h&quot;
DECL|variable|cmitmsg
DECL|variable|patchfile
DECL|variable|fin
DECL|variable|fout
r_static
id|FILE
op_star
id|cmitmsg
comma
op_star
id|patchfile
comma
op_star
id|fin
comma
op_star
id|fout
suffix:semicolon
DECL|variable|keep_subject
r_static
r_int
id|keep_subject
suffix:semicolon
DECL|variable|metainfo_charset
r_static
r_const
r_char
op_star
id|metainfo_charset
suffix:semicolon
DECL|variable|line
r_static
r_struct
id|strbuf
id|line
op_assign
id|STRBUF_INIT
suffix:semicolon
DECL|variable|name
r_static
r_struct
id|strbuf
id|name
op_assign
id|STRBUF_INIT
suffix:semicolon
DECL|variable|email
r_static
r_struct
id|strbuf
id|email
op_assign
id|STRBUF_INIT
suffix:semicolon
r_static
r_enum
(brace
DECL|enumerator|TE_DONTCARE
DECL|enumerator|TE_QP
DECL|enumerator|TE_BASE64
id|TE_DONTCARE
comma
id|TE_QP
comma
id|TE_BASE64
comma
DECL|variable|transfer_encoding
)brace
id|transfer_encoding
suffix:semicolon
r_static
r_enum
(brace
DECL|enumerator|TYPE_TEXT
DECL|enumerator|TYPE_OTHER
id|TYPE_TEXT
comma
id|TYPE_OTHER
comma
DECL|variable|message_type
)brace
id|message_type
suffix:semicolon
DECL|variable|charset
r_static
r_struct
id|strbuf
id|charset
op_assign
id|STRBUF_INIT
suffix:semicolon
DECL|variable|patch_lines
r_static
r_int
id|patch_lines
suffix:semicolon
DECL|variable|p_hdr_data
DECL|variable|s_hdr_data
r_static
r_struct
id|strbuf
op_star
op_star
id|p_hdr_data
comma
op_star
op_star
id|s_hdr_data
suffix:semicolon
DECL|macro|MAX_HDR_PARSED
mdefine_line|#define MAX_HDR_PARSED 10
DECL|macro|MAX_BOUNDARIES
mdefine_line|#define MAX_BOUNDARIES 5
DECL|function|get_sane_name
r_static
r_void
id|get_sane_name
c_func
(paren
r_struct
id|strbuf
op_star
id|out
comma
r_struct
id|strbuf
op_star
id|name
comma
r_struct
id|strbuf
op_star
id|email
)paren
(brace
r_struct
id|strbuf
op_star
id|src
op_assign
id|name
suffix:semicolon
r_if
c_cond
(paren
id|name-&gt;len
OL
l_int|3
op_logical_or
l_int|60
OL
id|name-&gt;len
op_logical_or
id|strchr
c_func
(paren
id|name-&gt;buf
comma
l_char|&squot;@&squot;
)paren
op_logical_or
id|strchr
c_func
(paren
id|name-&gt;buf
comma
l_char|&squot;&lt;&squot;
)paren
op_logical_or
id|strchr
c_func
(paren
id|name-&gt;buf
comma
l_char|&squot;&gt;&squot;
)paren
)paren
id|src
op_assign
id|email
suffix:semicolon
r_else
r_if
c_cond
(paren
id|name
op_eq
id|out
)paren
r_return
suffix:semicolon
id|strbuf_reset
c_func
(paren
id|out
)paren
suffix:semicolon
id|strbuf_addbuf
c_func
(paren
id|out
comma
id|src
)paren
suffix:semicolon
)brace
DECL|function|parse_bogus_from
r_static
r_void
id|parse_bogus_from
c_func
(paren
r_const
r_struct
id|strbuf
op_star
id|line
)paren
(brace
multiline_comment|/* John Doe &lt;johndoe&gt; */
r_char
op_star
id|bra
comma
op_star
id|ket
suffix:semicolon
multiline_comment|/* This is fallback, so do not bother if we already have an&n;&t; * e-mail address.&n;&t; */
r_if
c_cond
(paren
id|email.len
)paren
r_return
suffix:semicolon
id|bra
op_assign
id|strchr
c_func
(paren
id|line-&gt;buf
comma
l_char|&squot;&lt;&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bra
)paren
r_return
suffix:semicolon
id|ket
op_assign
id|strchr
c_func
(paren
id|bra
comma
l_char|&squot;&gt;&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ket
)paren
r_return
suffix:semicolon
id|strbuf_reset
c_func
(paren
op_amp
id|email
)paren
suffix:semicolon
id|strbuf_add
c_func
(paren
op_amp
id|email
comma
id|bra
op_plus
l_int|1
comma
id|ket
id|bra
l_int|1
)paren
suffix:semicolon
id|strbuf_reset
c_func
(paren
op_amp
id|name
)paren
suffix:semicolon
id|strbuf_add
c_func
(paren
op_amp
id|name
comma
id|line-&gt;buf
comma
id|bra
id|line-&gt;buf
)paren
suffix:semicolon
id|strbuf_trim
c_func
(paren
op_amp
id|name
)paren
suffix:semicolon
id|get_sane_name
c_func
(paren
op_amp
id|name
comma
op_amp
id|name
comma
op_amp
id|email
)paren
suffix:semicolon
)brace
DECL|function|handle_from
r_static
r_void
id|handle_from
c_func
(paren
r_const
r_struct
id|strbuf
op_star
id|from
)paren
(brace
r_char
op_star
id|at
suffix:semicolon
r_int
id|el
suffix:semicolon
r_struct
id|strbuf
id|f
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|f
comma
id|from-&gt;len
)paren
suffix:semicolon
id|strbuf_addbuf
c_func
(paren
op_amp
id|f
comma
id|from
)paren
suffix:semicolon
id|at
op_assign
id|strchr
c_func
(paren
id|f.buf
comma
l_char|&squot;@&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|at
)paren
(brace
id|parse_bogus_from
c_func
(paren
id|from
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we already have one email, don&squot;t take any confusing lines&n;&t; */
r_if
c_cond
(paren
id|email.len
op_logical_and
id|strchr
c_func
(paren
id|at
op_plus
l_int|1
comma
l_char|&squot;@&squot;
)paren
)paren
(brace
id|strbuf_release
c_func
(paren
op_amp
id|f
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Pick up the string around &squot;@&squot;, possibly delimited with &lt;&gt;&n;&t; * pair; that is the email part.&n;&t; */
r_while
c_loop
(paren
id|at
OG
id|f.buf
)paren
(brace
r_char
id|c
op_assign
id|at
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|isspace
c_func
(paren
id|c
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&lt;&squot;
)paren
(brace
id|at
(braket
l_int|1
)braket
op_assign
l_char|&squot; &squot;
suffix:semicolon
r_break
suffix:semicolon
)brace
id|at
op_decrement
suffix:semicolon
)brace
id|el
op_assign
id|strcspn
c_func
(paren
id|at
comma
l_string|&quot; &bslash;n&bslash;t&bslash;r&bslash;v&bslash;f&gt;&quot;
)paren
suffix:semicolon
id|strbuf_reset
c_func
(paren
op_amp
id|email
)paren
suffix:semicolon
id|strbuf_add
c_func
(paren
op_amp
id|email
comma
id|at
comma
id|el
)paren
suffix:semicolon
id|strbuf_remove
c_func
(paren
op_amp
id|f
comma
id|at
id|f.buf
comma
id|el
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* The remainder is name.  It could be &quot;John Doe &lt;john.doe@xz&gt;&quot;&n;&t; * or &quot;john.doe@xz (John Doe)&quot;, but we have removed the&n;&t; * email part, so trim from both ends, possibly removing&n;&t; * the () pair at the end.&n;&t; */
id|strbuf_trim
c_func
(paren
op_amp
id|f
)paren
suffix:semicolon
r_if
c_cond
(paren
id|f.buf
(braket
l_int|0
)braket
op_eq
l_char|&squot;(&squot;
)paren
id|strbuf_remove
c_func
(paren
op_amp
id|name
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|f.len
op_logical_and
id|f.buf
(braket
id|f.len
l_int|1
)braket
op_eq
l_char|&squot;)&squot;
)paren
id|strbuf_setlen
c_func
(paren
op_amp
id|f
comma
id|f.len
l_int|1
)paren
suffix:semicolon
id|get_sane_name
c_func
(paren
op_amp
id|name
comma
op_amp
id|f
comma
op_amp
id|email
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|f
)paren
suffix:semicolon
)brace
DECL|function|handle_header
r_static
r_void
id|handle_header
c_func
(paren
r_struct
id|strbuf
op_star
op_star
id|out
comma
r_const
r_struct
id|strbuf
op_star
id|line
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|out
)paren
(brace
op_star
id|out
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|strbuf
)paren
)paren
suffix:semicolon
id|strbuf_init
c_func
(paren
op_star
id|out
comma
id|line-&gt;len
)paren
suffix:semicolon
)brace
r_else
id|strbuf_reset
c_func
(paren
op_star
id|out
)paren
suffix:semicolon
id|strbuf_addbuf
c_func
(paren
op_star
id|out
comma
id|line
)paren
suffix:semicolon
)brace
multiline_comment|/* NOTE NOTE NOTE.  We do not claim we do full MIME.  We just attempt&n; * to have enough heuristics to grok MIME encoded patches often found&n; * on our mailing lists.  For example, we do not even treat header lines&n; * case insensitively.&n; */
DECL|function|slurp_attr
r_static
r_int
id|slurp_attr
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_const
r_char
op_star
id|name
comma
r_struct
id|strbuf
op_star
id|attr
)paren
(brace
r_const
r_char
op_star
id|ends
comma
op_star
id|ap
op_assign
id|strcasestr
c_func
(paren
id|line
comma
id|name
)paren
suffix:semicolon
r_int
id|sz
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ap
)paren
(brace
id|strbuf_setlen
c_func
(paren
id|attr
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ap
op_add_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|ap
op_eq
l_char|&squot;&quot;&squot;
)paren
(brace
id|ap
op_increment
suffix:semicolon
id|ends
op_assign
l_string|&quot;&bslash;&quot;&quot;
suffix:semicolon
)brace
r_else
id|ends
op_assign
l_string|&quot;; &bslash;t&quot;
suffix:semicolon
id|sz
op_assign
id|strcspn
c_func
(paren
id|ap
comma
id|ends
)paren
suffix:semicolon
id|strbuf_add
c_func
(paren
id|attr
comma
id|ap
comma
id|sz
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|variable|content
r_static
r_struct
id|strbuf
op_star
id|content
(braket
id|MAX_BOUNDARIES
)braket
suffix:semicolon
DECL|variable|content_top
r_static
r_struct
id|strbuf
op_star
op_star
id|content_top
op_assign
id|content
suffix:semicolon
DECL|function|handle_content_type
r_static
r_void
id|handle_content_type
c_func
(paren
r_struct
id|strbuf
op_star
id|line
)paren
(brace
r_struct
id|strbuf
op_star
id|boundary
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|strbuf
)paren
)paren
suffix:semicolon
id|strbuf_init
c_func
(paren
id|boundary
comma
id|line-&gt;len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcasestr
c_func
(paren
id|line-&gt;buf
comma
l_string|&quot;text/&quot;
)paren
)paren
id|message_type
op_assign
id|TYPE_OTHER
suffix:semicolon
r_if
c_cond
(paren
id|slurp_attr
c_func
(paren
id|line-&gt;buf
comma
l_string|&quot;boundary=&quot;
comma
id|boundary
)paren
)paren
(brace
id|strbuf_insert
c_func
(paren
id|boundary
comma
l_int|0
comma
l_string|&quot;--&quot;
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|content_top
op_increment
op_ge
op_amp
id|content
(braket
id|MAX_BOUNDARIES
)braket
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Too many boundaries to handle&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
op_star
id|content_top
op_assign
id|boundary
suffix:semicolon
id|boundary
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|slurp_attr
c_func
(paren
id|line-&gt;buf
comma
l_string|&quot;charset=&quot;
comma
op_amp
id|charset
)paren
)paren
id|strbuf_tolower
c_func
(paren
op_amp
id|charset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|boundary
)paren
(brace
id|strbuf_release
c_func
(paren
id|boundary
)paren
suffix:semicolon
id|free
c_func
(paren
id|boundary
)paren
suffix:semicolon
)brace
)brace
DECL|function|handle_content_transfer_encoding
r_static
r_void
id|handle_content_transfer_encoding
c_func
(paren
r_const
r_struct
id|strbuf
op_star
id|line
)paren
(brace
r_if
c_cond
(paren
id|strcasestr
c_func
(paren
id|line-&gt;buf
comma
l_string|&quot;base64&quot;
)paren
)paren
id|transfer_encoding
op_assign
id|TE_BASE64
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcasestr
c_func
(paren
id|line-&gt;buf
comma
l_string|&quot;quoted-printable&quot;
)paren
)paren
id|transfer_encoding
op_assign
id|TE_QP
suffix:semicolon
r_else
id|transfer_encoding
op_assign
id|TE_DONTCARE
suffix:semicolon
)brace
DECL|function|is_multipart_boundary
r_static
r_int
id|is_multipart_boundary
c_func
(paren
r_const
r_struct
id|strbuf
op_star
id|line
)paren
(brace
r_return
op_logical_neg
id|strbuf_cmp
c_func
(paren
id|line
comma
op_star
id|content_top
)paren
suffix:semicolon
)brace
DECL|function|cleanup_subject
r_static
r_void
id|cleanup_subject
c_func
(paren
r_struct
id|strbuf
op_star
id|subject
)paren
(brace
r_char
op_star
id|pos
suffix:semicolon
r_int
id|remove
suffix:semicolon
r_while
c_loop
(paren
id|subject-&gt;len
)paren
(brace
r_switch
c_cond
(paren
op_star
id|subject-&gt;buf
)paren
(brace
r_case
l_char|&squot;r&squot;
suffix:colon
r_case
l_char|&squot;R&squot;
suffix:colon
r_if
c_cond
(paren
id|subject-&gt;len
op_le
l_int|3
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|subject-&gt;buf
op_plus
l_int|1
comma
l_string|&quot;e:&quot;
comma
l_int|2
)paren
)paren
(brace
id|strbuf_remove
c_func
(paren
id|subject
comma
l_int|0
comma
l_int|3
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_char|&squot; &squot;
suffix:colon
r_case
l_char|&squot;&bslash;t&squot;
suffix:colon
r_case
l_char|&squot;:&squot;
suffix:colon
id|strbuf_remove
c_func
(paren
id|subject
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;[&squot;
suffix:colon
r_if
c_cond
(paren
(paren
id|pos
op_assign
id|strchr
c_func
(paren
id|subject-&gt;buf
comma
l_char|&squot;]&squot;
)paren
)paren
)paren
(brace
id|remove
op_assign
id|pos
id|subject-&gt;buf
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Don&squot;t remove too much. */
r_if
c_cond
(paren
id|remove
op_le
(paren
id|subject-&gt;len
id|remove
op_plus
l_int|1
)paren
op_star
l_int|2
)paren
(brace
id|strbuf_remove
c_func
(paren
id|subject
comma
l_int|0
comma
id|remove
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
r_else
id|strbuf_remove
c_func
(paren
id|subject
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|strbuf_trim
c_func
(paren
id|subject
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
DECL|function|cleanup_space
r_static
r_void
id|cleanup_space
c_func
(paren
r_struct
id|strbuf
op_star
id|sb
)paren
(brace
r_int
id|pos
comma
id|cnt
suffix:semicolon
r_for
c_loop
(paren
id|pos
op_assign
l_int|0
suffix:semicolon
id|pos
OL
id|sb-&gt;len
suffix:semicolon
id|pos
op_increment
)paren
(brace
r_if
c_cond
(paren
id|isspace
c_func
(paren
id|sb-&gt;buf
(braket
id|pos
)braket
)paren
)paren
(brace
id|sb-&gt;buf
(braket
id|pos
)braket
op_assign
l_char|&squot; &squot;
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|isspace
c_func
(paren
id|sb-&gt;buf
(braket
id|pos
op_plus
id|cnt
op_plus
l_int|1
)braket
)paren
suffix:semicolon
id|cnt
op_increment
)paren
suffix:semicolon
id|strbuf_remove
c_func
(paren
id|sb
comma
id|pos
op_plus
l_int|1
comma
id|cnt
)paren
suffix:semicolon
)brace
)brace
)brace
r_static
r_void
id|decode_header
c_func
(paren
r_struct
id|strbuf
op_star
id|line
)paren
suffix:semicolon
DECL|variable|header
r_static
r_const
r_char
op_star
id|header
(braket
id|MAX_HDR_PARSED
)braket
op_assign
(brace
l_string|&quot;From&quot;
comma
l_string|&quot;Subject&quot;
comma
l_string|&quot;Date&quot;
comma
)brace
suffix:semicolon
DECL|function|cmp_header
r_static
r_inline
r_int
id|cmp_header
c_func
(paren
r_const
r_struct
id|strbuf
op_star
id|line
comma
r_const
r_char
op_star
id|hdr
)paren
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|hdr
)paren
suffix:semicolon
r_return
op_logical_neg
id|strncasecmp
c_func
(paren
id|line-&gt;buf
comma
id|hdr
comma
id|len
)paren
op_logical_and
id|line-&gt;len
OG
id|len
op_logical_and
id|line-&gt;buf
(braket
id|len
)braket
op_eq
l_char|&squot;:&squot;
op_logical_and
id|isspace
c_func
(paren
id|line-&gt;buf
(braket
id|len
op_plus
l_int|1
)braket
)paren
suffix:semicolon
)brace
DECL|function|check_header
r_static
r_int
id|check_header
c_func
(paren
r_const
r_struct
id|strbuf
op_star
id|line
comma
r_struct
id|strbuf
op_star
id|hdr_data
(braket
)braket
comma
r_int
id|overwrite
)paren
(brace
r_int
id|i
comma
id|ret
op_assign
l_int|0
comma
id|len
suffix:semicolon
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
multiline_comment|/* search for the interesting parts */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|header
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|header
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|hdr_data
(braket
id|i
)braket
op_logical_or
id|overwrite
)paren
op_logical_and
id|cmp_header
c_func
(paren
id|line
comma
id|header
(braket
id|i
)braket
)paren
)paren
(brace
multiline_comment|/* Unwrap inline B and Q encoding, and optionally&n;&t;&t;&t; * normalize the meta information to utf8.&n;&t;&t;&t; */
id|strbuf_add
c_func
(paren
op_amp
id|sb
comma
id|line-&gt;buf
op_plus
id|len
op_plus
l_int|2
comma
id|line-&gt;len
id|len
l_int|2
)paren
suffix:semicolon
id|decode_header
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
id|handle_header
c_func
(paren
op_amp
id|hdr_data
(braket
id|i
)braket
comma
op_amp
id|sb
)paren
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
r_goto
id|check_header_out
suffix:semicolon
)brace
)brace
multiline_comment|/* Content stuff */
r_if
c_cond
(paren
id|cmp_header
c_func
(paren
id|line
comma
l_string|&quot;Content-Type&quot;
)paren
)paren
(brace
id|len
op_assign
id|strlen
c_func
(paren
l_string|&quot;Content-Type: &quot;
)paren
suffix:semicolon
id|strbuf_add
c_func
(paren
op_amp
id|sb
comma
id|line-&gt;buf
op_plus
id|len
comma
id|line-&gt;len
id|len
)paren
suffix:semicolon
id|decode_header
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
id|strbuf_insert
c_func
(paren
op_amp
id|sb
comma
l_int|0
comma
l_string|&quot;Content-Type: &quot;
comma
id|len
)paren
suffix:semicolon
id|handle_content_type
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
r_goto
id|check_header_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmp_header
c_func
(paren
id|line
comma
l_string|&quot;Content-Transfer-Encoding&quot;
)paren
)paren
(brace
id|len
op_assign
id|strlen
c_func
(paren
l_string|&quot;Content-Transfer-Encoding: &quot;
)paren
suffix:semicolon
id|strbuf_add
c_func
(paren
op_amp
id|sb
comma
id|line-&gt;buf
op_plus
id|len
comma
id|line-&gt;len
id|len
)paren
suffix:semicolon
id|decode_header
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
id|handle_content_transfer_encoding
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
r_goto
id|check_header_out
suffix:semicolon
)brace
multiline_comment|/* for inbody stuff */
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|line-&gt;buf
comma
l_string|&quot;&gt;From&quot;
)paren
op_logical_and
id|isspace
c_func
(paren
id|line-&gt;buf
(braket
l_int|5
)braket
)paren
)paren
(brace
id|ret
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Should this return 0? */
r_goto
id|check_header_out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|line-&gt;buf
comma
l_string|&quot;[PATCH]&quot;
)paren
op_logical_and
id|isspace
c_func
(paren
id|line-&gt;buf
(braket
l_int|7
)braket
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|header
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;Subject&quot;
comma
id|header
(braket
id|i
)braket
comma
l_int|7
)paren
)paren
(brace
id|handle_header
c_func
(paren
op_amp
id|hdr_data
(braket
id|i
)braket
comma
id|line
)paren
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
r_goto
id|check_header_out
suffix:semicolon
)brace
)brace
)brace
id|check_header_out
suffix:colon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|is_rfc2822_header
r_static
r_int
id|is_rfc2822_header
c_func
(paren
r_const
r_struct
id|strbuf
op_star
id|line
)paren
(brace
multiline_comment|/*&n;&t; * The section that defines the loosest possible&n;&t; * field name is &quot;3.6.8 Optional fields&quot;.&n;&t; *&n;&t; * optional-field = field-name &quot;:&quot; unstructured CRLF&n;&t; * field-name = 1*ftext&n;&t; * ftext = %d33-57 / %59-126&n;&t; */
r_int
id|ch
suffix:semicolon
r_char
op_star
id|cp
op_assign
id|line-&gt;buf
suffix:semicolon
multiline_comment|/* Count mbox From headers as headers */
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|cp
comma
l_string|&quot;From &quot;
)paren
op_logical_or
op_logical_neg
id|prefixcmp
c_func
(paren
id|cp
comma
l_string|&quot;&gt;From &quot;
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ch
op_assign
op_star
id|cp
op_increment
)paren
)paren
(brace
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;:&squot;
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
l_int|33
op_le
id|ch
op_logical_and
id|ch
op_le
l_int|57
)paren
op_logical_or
(paren
l_int|59
op_le
id|ch
op_logical_and
id|ch
op_le
l_int|126
)paren
)paren
r_continue
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|read_one_header_line
r_static
r_int
id|read_one_header_line
c_func
(paren
r_struct
id|strbuf
op_star
id|line
comma
id|FILE
op_star
id|in
)paren
(brace
multiline_comment|/* Get the first part of the line. */
r_if
c_cond
(paren
id|strbuf_getline
c_func
(paren
id|line
comma
id|in
comma
l_char|&squot;&bslash;n&squot;
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Is it an empty line or not a valid rfc2822 header?&n;&t; * If so, stop here, and return false (&quot;not a header&quot;)&n;&t; */
id|strbuf_rtrim
c_func
(paren
id|line
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|line-&gt;len
op_logical_or
op_logical_neg
id|is_rfc2822_header
c_func
(paren
id|line
)paren
)paren
(brace
multiline_comment|/* Re-add the newline */
id|strbuf_addch
c_func
(paren
id|line
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now we need to eat all the continuation lines..&n;&t; * Yuck, 2822 header &quot;folding&quot;&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|peek
suffix:semicolon
r_struct
id|strbuf
id|continuation
op_assign
id|STRBUF_INIT
suffix:semicolon
id|peek
op_assign
id|fgetc
c_func
(paren
id|in
)paren
suffix:semicolon
id|ungetc
c_func
(paren
id|peek
comma
id|in
)paren
suffix:semicolon
r_if
c_cond
(paren
id|peek
op_ne
l_char|&squot; &squot;
op_logical_and
id|peek
op_ne
l_char|&squot;&bslash;t&squot;
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|strbuf_getline
c_func
(paren
op_amp
id|continuation
comma
id|in
comma
l_char|&squot;&bslash;n&squot;
)paren
)paren
r_break
suffix:semicolon
id|continuation.buf
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
id|strbuf_rtrim
c_func
(paren
op_amp
id|continuation
)paren
suffix:semicolon
id|strbuf_addbuf
c_func
(paren
id|line
comma
op_amp
id|continuation
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|decode_q_segment
r_static
r_struct
id|strbuf
op_star
id|decode_q_segment
c_func
(paren
r_const
r_struct
id|strbuf
op_star
id|q_seg
comma
r_int
id|rfc2047
)paren
(brace
r_const
r_char
op_star
id|in
op_assign
id|q_seg-&gt;buf
suffix:semicolon
r_int
id|c
suffix:semicolon
r_struct
id|strbuf
op_star
id|out
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|strbuf
)paren
)paren
suffix:semicolon
id|strbuf_init
c_func
(paren
id|out
comma
id|q_seg-&gt;len
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
op_star
id|in
op_increment
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;=&squot;
)paren
(brace
r_int
id|d
op_assign
op_star
id|in
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|d
op_eq
l_char|&squot;&bslash;n&squot;
op_logical_or
op_logical_neg
id|d
)paren
r_break
suffix:semicolon
multiline_comment|/* drop trailing newline */
id|strbuf_addch
c_func
(paren
id|out
comma
(paren
id|hexval
c_func
(paren
id|d
)paren
op_lshift
l_int|4
)paren
op_or
id|hexval
c_func
(paren
op_star
id|in
op_increment
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rfc2047
op_logical_and
id|c
op_eq
l_char|&squot;_&squot;
)paren
multiline_comment|/* rfc2047 4.2 (2) */
id|c
op_assign
l_int|0x20
suffix:semicolon
id|strbuf_addch
c_func
(paren
id|out
comma
id|c
)paren
suffix:semicolon
)brace
r_return
id|out
suffix:semicolon
)brace
DECL|function|decode_b_segment
r_static
r_struct
id|strbuf
op_star
id|decode_b_segment
c_func
(paren
r_const
r_struct
id|strbuf
op_star
id|b_seg
)paren
(brace
multiline_comment|/* Decode in..ep, possibly in-place to ot */
r_int
id|c
comma
id|pos
op_assign
l_int|0
comma
id|acc
op_assign
l_int|0
suffix:semicolon
r_const
r_char
op_star
id|in
op_assign
id|b_seg-&gt;buf
suffix:semicolon
r_struct
id|strbuf
op_star
id|out
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|strbuf
)paren
)paren
suffix:semicolon
id|strbuf_init
c_func
(paren
id|out
comma
id|b_seg-&gt;len
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
op_star
id|in
op_increment
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;+&squot;
)paren
id|c
op_assign
l_int|62
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;/&squot;
)paren
id|c
op_assign
l_int|63
suffix:semicolon
r_else
r_if
c_cond
(paren
l_char|&squot;A&squot;
op_le
id|c
op_logical_and
id|c
op_le
l_char|&squot;Z&squot;
)paren
id|c
op_sub_assign
l_char|&squot;A&squot;
suffix:semicolon
r_else
r_if
c_cond
(paren
l_char|&squot;a&squot;
op_le
id|c
op_logical_and
id|c
op_le
l_char|&squot;z&squot;
)paren
id|c
op_sub_assign
l_char|&squot;a&squot;
l_int|26
suffix:semicolon
r_else
r_if
c_cond
(paren
l_char|&squot;0&squot;
op_le
id|c
op_logical_and
id|c
op_le
l_char|&squot;9&squot;
)paren
id|c
op_sub_assign
l_char|&squot;0&squot;
l_int|52
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;=&squot;
)paren
(brace
multiline_comment|/* padding is almost like (c == 0), except we do&n;&t;&t;&t; * not output NUL resulting only from it;&n;&t;&t;&t; * for now we just trust the data.&n;&t;&t;&t; */
id|c
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_continue
suffix:semicolon
multiline_comment|/* garbage */
r_switch
c_cond
(paren
id|pos
op_increment
)paren
(brace
r_case
l_int|0
suffix:colon
id|acc
op_assign
(paren
id|c
op_lshift
l_int|2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|strbuf_addch
c_func
(paren
id|out
comma
(paren
id|acc
op_or
(paren
id|c
op_rshift
l_int|4
)paren
)paren
)paren
suffix:semicolon
id|acc
op_assign
(paren
id|c
op_amp
l_int|15
)paren
op_lshift
l_int|4
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|strbuf_addch
c_func
(paren
id|out
comma
(paren
id|acc
op_or
(paren
id|c
op_rshift
l_int|2
)paren
)paren
)paren
suffix:semicolon
id|acc
op_assign
(paren
id|c
op_amp
l_int|3
)paren
op_lshift
l_int|6
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|strbuf_addch
c_func
(paren
id|out
comma
(paren
id|acc
op_or
id|c
)paren
)paren
suffix:semicolon
id|acc
op_assign
id|pos
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; * When there is no known charset, guess.&n; *&n; * Right now we assume that if the target is UTF-8 (the default),&n; * and it already looks like UTF-8 (which includes US-ASCII as its&n; * subset, of course) then that is what it is and there is nothing&n; * to do.&n; *&n; * Otherwise, we default to assuming it is Latin1 for historical&n; * reasons.&n; */
DECL|function|guess_charset
r_static
r_const
r_char
op_star
id|guess_charset
c_func
(paren
r_const
r_struct
id|strbuf
op_star
id|line
comma
r_const
r_char
op_star
id|target_charset
)paren
(brace
r_if
c_cond
(paren
id|is_encoding_utf8
c_func
(paren
id|target_charset
)paren
)paren
(brace
r_if
c_cond
(paren
id|is_utf8
c_func
(paren
id|line-&gt;buf
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
l_string|&quot;latin1&quot;
suffix:semicolon
)brace
DECL|function|convert_to_utf8
r_static
r_void
id|convert_to_utf8
c_func
(paren
r_struct
id|strbuf
op_star
id|line
comma
r_const
r_char
op_star
id|charset
)paren
(brace
r_char
op_star
id|out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|charset
op_logical_or
op_logical_neg
op_star
id|charset
)paren
(brace
id|charset
op_assign
id|guess_charset
c_func
(paren
id|line
comma
id|metainfo_charset
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|charset
)paren
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|metainfo_charset
comma
id|charset
)paren
)paren
r_return
suffix:semicolon
id|out
op_assign
id|reencode_string
c_func
(paren
id|line-&gt;buf
comma
id|metainfo_charset
comma
id|charset
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|out
)paren
id|die
c_func
(paren
l_string|&quot;cannot convert from %s to %s&bslash;n&quot;
comma
id|charset
comma
id|metainfo_charset
)paren
suffix:semicolon
id|strbuf_attach
c_func
(paren
id|line
comma
id|out
comma
id|strlen
c_func
(paren
id|out
)paren
comma
id|strlen
c_func
(paren
id|out
)paren
)paren
suffix:semicolon
)brace
DECL|function|decode_header_bq
r_static
r_int
id|decode_header_bq
c_func
(paren
r_struct
id|strbuf
op_star
id|it
)paren
(brace
r_char
op_star
id|in
comma
op_star
id|ep
comma
op_star
id|cp
suffix:semicolon
r_struct
id|strbuf
id|outbuf
op_assign
id|STRBUF_INIT
comma
op_star
id|dec
suffix:semicolon
r_struct
id|strbuf
id|charset_q
op_assign
id|STRBUF_INIT
comma
id|piecebuf
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|rfc2047
op_assign
l_int|0
suffix:semicolon
id|in
op_assign
id|it-&gt;buf
suffix:semicolon
r_while
c_loop
(paren
id|in
id|it-&gt;buf
op_le
id|it-&gt;len
op_logical_and
(paren
id|ep
op_assign
id|strstr
c_func
(paren
id|in
comma
l_string|&quot;=?&quot;
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_int
id|encoding
suffix:semicolon
id|strbuf_reset
c_func
(paren
op_amp
id|charset_q
)paren
suffix:semicolon
id|strbuf_reset
c_func
(paren
op_amp
id|piecebuf
)paren
suffix:semicolon
id|rfc2047
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|in
op_ne
id|ep
)paren
(brace
id|strbuf_add
c_func
(paren
op_amp
id|outbuf
comma
id|in
comma
id|ep
id|in
)paren
suffix:semicolon
id|in
op_assign
id|ep
suffix:semicolon
)brace
multiline_comment|/* E.g.&n;&t;&t; * ep : &quot;=?iso-2022-jp?B?GyR...?= foo&quot;&n;&t;&t; * ep : &quot;=?ISO-8859-1?Q?Foo=FCbar?= baz&quot;&n;&t;&t; */
id|ep
op_add_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|ep
id|it-&gt;buf
op_ge
id|it-&gt;len
op_logical_or
op_logical_neg
(paren
id|cp
op_assign
id|strchr
c_func
(paren
id|ep
comma
l_char|&squot;?&squot;
)paren
)paren
)paren
r_goto
id|decode_header_bq_out
suffix:semicolon
r_if
c_cond
(paren
id|cp
op_plus
l_int|3
id|it-&gt;buf
OG
id|it-&gt;len
)paren
r_goto
id|decode_header_bq_out
suffix:semicolon
id|strbuf_add
c_func
(paren
op_amp
id|charset_q
comma
id|ep
comma
id|cp
id|ep
)paren
suffix:semicolon
id|strbuf_tolower
c_func
(paren
op_amp
id|charset_q
)paren
suffix:semicolon
id|encoding
op_assign
id|cp
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|encoding
op_logical_or
id|cp
(braket
l_int|2
)braket
op_ne
l_char|&squot;?&squot;
)paren
r_goto
id|decode_header_bq_out
suffix:semicolon
id|ep
op_assign
id|strstr
c_func
(paren
id|cp
op_plus
l_int|3
comma
l_string|&quot;?=&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ep
)paren
r_goto
id|decode_header_bq_out
suffix:semicolon
id|strbuf_add
c_func
(paren
op_amp
id|piecebuf
comma
id|cp
op_plus
l_int|3
comma
id|ep
id|cp
l_int|3
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|tolower
c_func
(paren
id|encoding
)paren
)paren
(brace
r_default
suffix:colon
r_goto
id|decode_header_bq_out
suffix:semicolon
r_case
l_char|&squot;b&squot;
suffix:colon
id|dec
op_assign
id|decode_b_segment
c_func
(paren
op_amp
id|piecebuf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;q&squot;
suffix:colon
id|dec
op_assign
id|decode_q_segment
c_func
(paren
op_amp
id|piecebuf
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|metainfo_charset
)paren
id|convert_to_utf8
c_func
(paren
id|dec
comma
id|charset_q.buf
)paren
suffix:semicolon
id|strbuf_addbuf
c_func
(paren
op_amp
id|outbuf
comma
id|dec
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
id|dec
)paren
suffix:semicolon
id|free
c_func
(paren
id|dec
)paren
suffix:semicolon
id|in
op_assign
id|ep
op_plus
l_int|2
suffix:semicolon
)brace
id|strbuf_addstr
c_func
(paren
op_amp
id|outbuf
comma
id|in
)paren
suffix:semicolon
id|strbuf_reset
c_func
(paren
id|it
)paren
suffix:semicolon
id|strbuf_addbuf
c_func
(paren
id|it
comma
op_amp
id|outbuf
)paren
suffix:semicolon
id|decode_header_bq_out
suffix:colon
id|strbuf_release
c_func
(paren
op_amp
id|outbuf
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|charset_q
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|piecebuf
)paren
suffix:semicolon
r_return
id|rfc2047
suffix:semicolon
)brace
DECL|function|decode_header
r_static
r_void
id|decode_header
c_func
(paren
r_struct
id|strbuf
op_star
id|it
)paren
(brace
r_if
c_cond
(paren
id|decode_header_bq
c_func
(paren
id|it
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* otherwise &quot;it&quot; is a straight copy of the input.&n;&t; * This can be binary guck but there is no charset specified.&n;&t; */
r_if
c_cond
(paren
id|metainfo_charset
)paren
id|convert_to_utf8
c_func
(paren
id|it
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
DECL|function|decode_transfer_encoding
r_static
r_void
id|decode_transfer_encoding
c_func
(paren
r_struct
id|strbuf
op_star
id|line
)paren
(brace
r_struct
id|strbuf
op_star
id|ret
suffix:semicolon
r_switch
c_cond
(paren
id|transfer_encoding
)paren
(brace
r_case
id|TE_QP
suffix:colon
id|ret
op_assign
id|decode_q_segment
c_func
(paren
id|line
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TE_BASE64
suffix:colon
id|ret
op_assign
id|decode_b_segment
c_func
(paren
id|line
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TE_DONTCARE
suffix:colon
r_default
suffix:colon
r_return
suffix:semicolon
)brace
id|strbuf_reset
c_func
(paren
id|line
)paren
suffix:semicolon
id|strbuf_addbuf
c_func
(paren
id|line
comma
id|ret
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
id|ret
)paren
suffix:semicolon
id|free
c_func
(paren
id|ret
)paren
suffix:semicolon
)brace
r_static
r_void
id|handle_filter
c_func
(paren
r_struct
id|strbuf
op_star
id|line
)paren
suffix:semicolon
DECL|function|find_boundary
r_static
r_int
id|find_boundary
c_func
(paren
r_void
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
id|strbuf_getline
c_func
(paren
op_amp
id|line
comma
id|fin
comma
l_char|&squot;&bslash;n&squot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|is_multipart_boundary
c_func
(paren
op_amp
id|line
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|handle_boundary
r_static
r_int
id|handle_boundary
c_func
(paren
r_void
)paren
(brace
r_struct
id|strbuf
id|newline
op_assign
id|STRBUF_INIT
suffix:semicolon
id|strbuf_addch
c_func
(paren
op_amp
id|newline
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|again
suffix:colon
r_if
c_cond
(paren
id|line.len
op_ge
(paren
op_star
id|content_top
)paren
op_member_access_from_pointer
id|len
op_plus
l_int|2
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|line.buf
op_plus
(paren
op_star
id|content_top
)paren
op_member_access_from_pointer
id|len
comma
l_string|&quot;--&quot;
comma
l_int|2
)paren
)paren
(brace
multiline_comment|/* we hit an end boundary */
multiline_comment|/* pop the current boundary off the stack */
id|strbuf_release
c_func
(paren
op_star
id|content_top
)paren
suffix:semicolon
id|free
c_func
(paren
op_star
id|content_top
)paren
suffix:semicolon
op_star
id|content_top
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* technically won&squot;t happen as is_multipart_boundary()&n;&t;&t;   will fail first.  But just in case..&n;&t;&t; */
r_if
c_cond
(paren
id|content_top
op_decrement
OL
id|content
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Detected mismatched boundaries, &quot;
l_string|&quot;can&squot;t recover&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|handle_filter
c_func
(paren
op_amp
id|newline
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|newline
)paren
suffix:semicolon
multiline_comment|/* skip to the next boundary */
r_if
c_cond
(paren
op_logical_neg
id|find_boundary
c_func
(paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_goto
id|again
suffix:semicolon
)brace
multiline_comment|/* set some defaults */
id|transfer_encoding
op_assign
id|TE_DONTCARE
suffix:semicolon
id|strbuf_reset
c_func
(paren
op_amp
id|charset
)paren
suffix:semicolon
id|message_type
op_assign
id|TYPE_TEXT
suffix:semicolon
multiline_comment|/* slurp in this section&squot;s info */
r_while
c_loop
(paren
id|read_one_header_line
c_func
(paren
op_amp
id|line
comma
id|fin
)paren
)paren
id|check_header
c_func
(paren
op_amp
id|line
comma
id|p_hdr_data
comma
l_int|0
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|newline
)paren
suffix:semicolon
multiline_comment|/* eat the blank line after section info */
r_return
(paren
id|strbuf_getline
c_func
(paren
op_amp
id|line
comma
id|fin
comma
l_char|&squot;&bslash;n&squot;
)paren
op_eq
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|patchbreak
r_static
r_inline
r_int
id|patchbreak
c_func
(paren
r_const
r_struct
id|strbuf
op_star
id|line
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* Beginning of a &quot;diff -&quot; header? */
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|line-&gt;buf
comma
l_string|&quot;diff -&quot;
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* CVS &quot;Index: &quot; line? */
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|line-&gt;buf
comma
l_string|&quot;Index: &quot;
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * &quot;--- &lt;filename&gt;&quot; starts patches without headers&n;&t; * &quot;---&lt;sp&gt;*&quot; is a manual separator&n;&t; */
r_if
c_cond
(paren
id|line-&gt;len
OL
l_int|4
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|line-&gt;buf
comma
l_string|&quot;---&quot;
)paren
)paren
(brace
multiline_comment|/* space followed by a filename? */
r_if
c_cond
(paren
id|line-&gt;buf
(braket
l_int|3
)braket
op_eq
l_char|&squot; &squot;
op_logical_and
op_logical_neg
id|isspace
c_func
(paren
id|line-&gt;buf
(braket
l_int|4
)braket
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Just whitespace? */
r_for
c_loop
(paren
id|i
op_assign
l_int|3
suffix:semicolon
id|i
OL
id|line-&gt;len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_char
id|c
op_assign
id|line-&gt;buf
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|isspace
c_func
(paren
id|c
)paren
)paren
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|handle_commit_msg
r_static
r_int
id|handle_commit_msg
c_func
(paren
r_struct
id|strbuf
op_star
id|line
)paren
(brace
r_static
r_int
id|still_looking
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmitmsg
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|still_looking
)paren
(brace
id|strbuf_ltrim
c_func
(paren
id|line
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|line-&gt;len
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|still_looking
op_assign
id|check_header
c_func
(paren
id|line
comma
id|s_hdr_data
comma
l_int|0
)paren
)paren
op_ne
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* normalize the log message to UTF-8. */
r_if
c_cond
(paren
id|metainfo_charset
)paren
id|convert_to_utf8
c_func
(paren
id|line
comma
id|charset.buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|patchbreak
c_func
(paren
id|line
)paren
)paren
(brace
id|fclose
c_func
(paren
id|cmitmsg
)paren
suffix:semicolon
id|cmitmsg
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|fputs
c_func
(paren
id|line-&gt;buf
comma
id|cmitmsg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|handle_patch
r_static
r_void
id|handle_patch
c_func
(paren
r_const
r_struct
id|strbuf
op_star
id|line
)paren
(brace
id|fwrite
c_func
(paren
id|line-&gt;buf
comma
l_int|1
comma
id|line-&gt;len
comma
id|patchfile
)paren
suffix:semicolon
id|patch_lines
op_increment
suffix:semicolon
)brace
DECL|function|handle_filter
r_static
r_void
id|handle_filter
c_func
(paren
r_struct
id|strbuf
op_star
id|line
)paren
(brace
r_static
r_int
id|filter
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* filter tells us which part we left off on */
r_switch
c_cond
(paren
id|filter
)paren
(brace
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|handle_commit_msg
c_func
(paren
id|line
)paren
)paren
r_break
suffix:semicolon
id|filter
op_increment
suffix:semicolon
r_case
l_int|1
suffix:colon
id|handle_patch
c_func
(paren
id|line
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|function|handle_body
r_static
r_void
id|handle_body
c_func
(paren
r_void
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_struct
id|strbuf
id|prev
op_assign
id|STRBUF_INIT
suffix:semicolon
multiline_comment|/* Skip up to the first boundary */
r_if
c_cond
(paren
op_star
id|content_top
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|find_boundary
c_func
(paren
)paren
)paren
r_goto
id|handle_body_out
suffix:semicolon
)brace
r_do
(brace
id|strbuf_setlen
c_func
(paren
op_amp
id|line
comma
id|line.len
op_plus
id|len
)paren
suffix:semicolon
multiline_comment|/* process any boundary lines */
r_if
c_cond
(paren
op_star
id|content_top
op_logical_and
id|is_multipart_boundary
c_func
(paren
op_amp
id|line
)paren
)paren
(brace
multiline_comment|/* flush any leftover */
r_if
c_cond
(paren
id|line.len
)paren
id|handle_filter
c_func
(paren
op_amp
id|line
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|handle_boundary
c_func
(paren
)paren
)paren
r_goto
id|handle_body_out
suffix:semicolon
)brace
multiline_comment|/* Unwrap transfer encoding */
id|decode_transfer_encoding
c_func
(paren
op_amp
id|line
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|transfer_encoding
)paren
(brace
r_case
id|TE_BASE64
suffix:colon
r_case
id|TE_QP
suffix:colon
(brace
r_struct
id|strbuf
op_star
op_star
id|lines
comma
op_star
op_star
id|it
comma
op_star
id|sb
suffix:semicolon
multiline_comment|/* Prepend any previous partial lines */
id|strbuf_insert
c_func
(paren
op_amp
id|line
comma
l_int|0
comma
id|prev.buf
comma
id|prev.len
)paren
suffix:semicolon
id|strbuf_reset
c_func
(paren
op_amp
id|prev
)paren
suffix:semicolon
multiline_comment|/* binary data most likely doesn&squot;t have newlines */
r_if
c_cond
(paren
id|message_type
op_ne
id|TYPE_TEXT
)paren
(brace
id|handle_filter
c_func
(paren
op_amp
id|line
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * This is a decoded line that may contain&n;&t;&t;&t; * multiple new lines.  Pass only one chunk&n;&t;&t;&t; * at a time to handle_filter()&n;&t;&t;&t; */
id|lines
op_assign
id|strbuf_split
c_func
(paren
op_amp
id|line
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|it
op_assign
id|lines
suffix:semicolon
(paren
id|sb
op_assign
op_star
id|it
)paren
suffix:semicolon
id|it
op_increment
)paren
(brace
r_if
c_cond
(paren
op_star
(paren
id|it
op_plus
l_int|1
)paren
op_eq
l_int|NULL
)paren
multiline_comment|/* The last line */
r_if
c_cond
(paren
id|sb-&gt;buf
(braket
id|sb-&gt;len
l_int|1
)braket
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
multiline_comment|/* Partial line, save it for later. */
id|strbuf_addbuf
c_func
(paren
op_amp
id|prev
comma
id|sb
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|handle_filter
c_func
(paren
id|sb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * The partial chunk is saved in &quot;prev&quot; and will be&n;&t;&t;&t; * appended by the next iteration of read_line_with_nul().&n;&t;&t;&t; */
id|strbuf_list_free
c_func
(paren
id|lines
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_default
suffix:colon
id|handle_filter
c_func
(paren
op_amp
id|line
)paren
suffix:semicolon
)brace
id|strbuf_reset
c_func
(paren
op_amp
id|line
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strbuf_avail
c_func
(paren
op_amp
id|line
)paren
OL
l_int|100
)paren
id|strbuf_grow
c_func
(paren
op_amp
id|line
comma
l_int|100
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|len
op_assign
id|read_line_with_nul
c_func
(paren
id|line.buf
comma
id|strbuf_avail
c_func
(paren
op_amp
id|line
)paren
comma
id|fin
)paren
)paren
)paren
suffix:semicolon
id|handle_body_out
suffix:colon
id|strbuf_release
c_func
(paren
op_amp
id|prev
)paren
suffix:semicolon
)brace
DECL|function|output_header_lines
r_static
r_void
id|output_header_lines
c_func
(paren
id|FILE
op_star
id|fout
comma
r_const
r_char
op_star
id|hdr
comma
r_const
r_struct
id|strbuf
op_star
id|data
)paren
(brace
r_const
r_char
op_star
id|sp
op_assign
id|data-&gt;buf
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_char
op_star
id|ep
op_assign
id|strchr
c_func
(paren
id|sp
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ep
)paren
id|len
op_assign
id|strlen
c_func
(paren
id|sp
)paren
suffix:semicolon
r_else
id|len
op_assign
id|ep
id|sp
suffix:semicolon
id|fprintf
c_func
(paren
id|fout
comma
l_string|&quot;%s: %.*s&bslash;n&quot;
comma
id|hdr
comma
id|len
comma
id|sp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ep
)paren
r_break
suffix:semicolon
id|sp
op_assign
id|ep
op_plus
l_int|1
suffix:semicolon
)brace
)brace
DECL|function|handle_info
r_static
r_void
id|handle_info
c_func
(paren
r_void
)paren
(brace
r_struct
id|strbuf
op_star
id|hdr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|header
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* only print inbody headers if we output a patch file */
r_if
c_cond
(paren
id|patch_lines
op_logical_and
id|s_hdr_data
(braket
id|i
)braket
)paren
id|hdr
op_assign
id|s_hdr_data
(braket
id|i
)braket
suffix:semicolon
r_else
r_if
c_cond
(paren
id|p_hdr_data
(braket
id|i
)braket
)paren
id|hdr
op_assign
id|p_hdr_data
(braket
id|i
)braket
suffix:semicolon
r_else
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|header
(braket
id|i
)braket
comma
l_string|&quot;Subject&quot;
comma
l_int|7
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|keep_subject
)paren
(brace
id|cleanup_subject
c_func
(paren
id|hdr
)paren
suffix:semicolon
id|cleanup_space
c_func
(paren
id|hdr
)paren
suffix:semicolon
)brace
id|output_header_lines
c_func
(paren
id|fout
comma
l_string|&quot;Subject&quot;
comma
id|hdr
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|header
(braket
id|i
)braket
comma
l_string|&quot;From&quot;
comma
l_int|4
)paren
)paren
(brace
id|handle_from
c_func
(paren
id|hdr
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|fout
comma
l_string|&quot;Author: %s&bslash;n&quot;
comma
id|name.buf
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|fout
comma
l_string|&quot;Email: %s&bslash;n&quot;
comma
id|email.buf
)paren
suffix:semicolon
)brace
r_else
(brace
id|cleanup_space
c_func
(paren
id|hdr
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|fout
comma
l_string|&quot;%s: %s&bslash;n&quot;
comma
id|header
(braket
id|i
)braket
comma
id|hdr-&gt;buf
)paren
suffix:semicolon
)brace
)brace
id|fprintf
c_func
(paren
id|fout
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|mailinfo
r_static
r_int
id|mailinfo
c_func
(paren
id|FILE
op_star
id|in
comma
id|FILE
op_star
id|out
comma
r_int
id|ks
comma
r_const
r_char
op_star
id|encoding
comma
r_const
r_char
op_star
id|msg
comma
r_const
r_char
op_star
id|patch
)paren
(brace
r_int
id|peek
suffix:semicolon
id|keep_subject
op_assign
id|ks
suffix:semicolon
id|metainfo_charset
op_assign
id|encoding
suffix:semicolon
id|fin
op_assign
id|in
suffix:semicolon
id|fout
op_assign
id|out
suffix:semicolon
id|cmitmsg
op_assign
id|fopen
c_func
(paren
id|msg
comma
l_string|&quot;w&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmitmsg
)paren
(brace
id|perror
c_func
(paren
id|msg
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|patchfile
op_assign
id|fopen
c_func
(paren
id|patch
comma
l_string|&quot;w&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|patchfile
)paren
(brace
id|perror
c_func
(paren
id|patch
)paren
suffix:semicolon
id|fclose
c_func
(paren
id|cmitmsg
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|p_hdr_data
op_assign
id|xcalloc
c_func
(paren
id|MAX_HDR_PARSED
comma
r_sizeof
(paren
op_star
id|p_hdr_data
)paren
)paren
suffix:semicolon
id|s_hdr_data
op_assign
id|xcalloc
c_func
(paren
id|MAX_HDR_PARSED
comma
r_sizeof
(paren
op_star
id|s_hdr_data
)paren
)paren
suffix:semicolon
r_do
(brace
id|peek
op_assign
id|fgetc
c_func
(paren
id|in
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|isspace
c_func
(paren
id|peek
)paren
)paren
suffix:semicolon
id|ungetc
c_func
(paren
id|peek
comma
id|in
)paren
suffix:semicolon
multiline_comment|/* process the email header */
r_while
c_loop
(paren
id|read_one_header_line
c_func
(paren
op_amp
id|line
comma
id|fin
)paren
)paren
id|check_header
c_func
(paren
op_amp
id|line
comma
id|p_hdr_data
comma
l_int|1
)paren
suffix:semicolon
id|handle_body
c_func
(paren
)paren
suffix:semicolon
id|handle_info
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|mailinfo_usage
r_static
r_const
r_char
id|mailinfo_usage
(braket
)braket
op_assign
l_string|&quot;git mailinfo [-k] [-u | --encoding=&lt;encoding&gt; | -n] msg patch &lt;mail &gt;info&quot;
suffix:semicolon
DECL|function|cmd_mailinfo
r_int
id|cmd_mailinfo
c_func
(paren
r_int
id|argc
comma
r_const
r_char
op_star
op_star
id|argv
comma
r_const
r_char
op_star
id|prefix
)paren
(brace
r_const
r_char
op_star
id|def_charset
suffix:semicolon
multiline_comment|/* NEEDSWORK: might want to do the optional .git/ directory&n;&t; * discovery&n;&t; */
id|git_config
c_func
(paren
id|git_default_config
comma
l_int|NULL
)paren
suffix:semicolon
id|def_charset
op_assign
(paren
id|git_commit_encoding
ques
c_cond
id|git_commit_encoding
suffix:colon
l_string|&quot;utf-8&quot;
)paren
suffix:semicolon
id|metainfo_charset
op_assign
id|def_charset
suffix:semicolon
r_while
c_loop
(paren
l_int|1
OL
id|argc
op_logical_and
id|argv
(braket
l_int|1
)braket
(braket
l_int|0
)braket
op_eq
l_char|&squot;-&squot;
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
l_string|&quot;-k&quot;
)paren
)paren
id|keep_subject
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
l_string|&quot;-u&quot;
)paren
)paren
id|metainfo_charset
op_assign
id|def_charset
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
l_string|&quot;-n&quot;
)paren
)paren
id|metainfo_charset
op_assign
l_int|NULL
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
l_string|&quot;--encoding=&quot;
)paren
)paren
id|metainfo_charset
op_assign
id|argv
(braket
l_int|1
)braket
op_plus
l_int|11
suffix:semicolon
r_else
id|usage
c_func
(paren
id|mailinfo_usage
)paren
suffix:semicolon
id|argc
op_decrement
suffix:semicolon
id|argv
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|argc
op_ne
l_int|3
)paren
id|usage
c_func
(paren
id|mailinfo_usage
)paren
suffix:semicolon
r_return
op_logical_neg
op_logical_neg
id|mailinfo
c_func
(paren
id|stdin
comma
id|stdout
comma
id|keep_subject
comma
id|metainfo_charset
comma
id|argv
(braket
l_int|1
)braket
comma
id|argv
(braket
l_int|2
)braket
)paren
suffix:semicolon
)brace
eof
