multiline_comment|/*&n; * Another stupid program, this one parsing the headers of an&n; * email to figure out authorship and subject&n; */
macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;builtin.h&quot;
macro_line|#include &quot;utf8.h&quot;
DECL|variable|cmitmsg
DECL|variable|patchfile
DECL|variable|fin
DECL|variable|fout
r_static
id|FILE
op_star
id|cmitmsg
comma
op_star
id|patchfile
comma
op_star
id|fin
comma
op_star
id|fout
suffix:semicolon
DECL|variable|keep_subject
r_static
r_int
id|keep_subject
suffix:semicolon
DECL|variable|metainfo_charset
r_static
r_const
r_char
op_star
id|metainfo_charset
suffix:semicolon
DECL|variable|line
r_static
r_char
id|line
(braket
l_int|1000
)braket
suffix:semicolon
DECL|variable|name
r_static
r_char
id|name
(braket
l_int|1000
)braket
suffix:semicolon
DECL|variable|email
r_static
r_char
id|email
(braket
l_int|1000
)braket
suffix:semicolon
r_static
r_enum
(brace
DECL|enumerator|TE_DONTCARE
DECL|enumerator|TE_QP
DECL|enumerator|TE_BASE64
id|TE_DONTCARE
comma
id|TE_QP
comma
id|TE_BASE64
comma
DECL|variable|transfer_encoding
)brace
id|transfer_encoding
suffix:semicolon
r_static
r_enum
(brace
DECL|enumerator|TYPE_TEXT
DECL|enumerator|TYPE_OTHER
id|TYPE_TEXT
comma
id|TYPE_OTHER
comma
DECL|variable|message_type
)brace
id|message_type
suffix:semicolon
DECL|variable|charset
r_static
r_char
id|charset
(braket
l_int|256
)braket
suffix:semicolon
DECL|variable|patch_lines
r_static
r_int
id|patch_lines
suffix:semicolon
DECL|variable|p_hdr_data
DECL|variable|s_hdr_data
r_static
r_char
op_star
op_star
id|p_hdr_data
comma
op_star
op_star
id|s_hdr_data
suffix:semicolon
DECL|macro|MAX_HDR_PARSED
mdefine_line|#define MAX_HDR_PARSED 10
DECL|macro|MAX_BOUNDARIES
mdefine_line|#define MAX_BOUNDARIES 5
DECL|function|sanity_check
r_static
r_char
op_star
id|sanity_check
c_func
(paren
r_char
op_star
id|name
comma
r_char
op_star
id|email
)paren
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
template_param
l_int|60
)paren
r_return
id|email
suffix:semicolon
r_if
c_cond
(paren
id|strchr
c_func
(paren
id|name
comma
l_char|&squot;@&squot;
)paren
op_logical_or
id|strchr
c_func
(paren
id|name
comma
l_char|&squot;&lt;&squot;
)paren
op_logical_or
id|strchr
c_func
(paren
id|name
comma
l_char|&squot;&gt;&squot;
)paren
)paren
r_return
id|email
suffix:semicolon
r_return
id|name
suffix:semicolon
)brace
DECL|function|bogus_from
r_static
r_int
id|bogus_from
c_func
(paren
r_char
op_star
id|line
)paren
(brace
multiline_comment|/* John Doe &lt;johndoe&gt; */
r_char
op_star
id|bra
comma
op_star
id|ket
comma
op_star
id|dst
comma
op_star
id|cp
suffix:semicolon
multiline_comment|/* This is fallback, so do not bother if we already have an&n;&t; * e-mail address.&n;&t; */
r_if
c_cond
(paren
op_star
id|email
)paren
r_return
l_int|0
suffix:semicolon
id|bra
op_assign
id|strchr
c_func
(paren
id|line
comma
l_char|&squot;&lt;&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bra
)paren
r_return
l_int|0
suffix:semicolon
id|ket
op_assign
id|strchr
c_func
(paren
id|bra
comma
l_char|&squot;&gt;&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ket
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|dst
op_assign
id|email
comma
id|cp
op_assign
id|bra
op_plus
l_int|1
suffix:semicolon
id|cp
OL
id|ket
suffix:semicolon
)paren
op_star
id|dst
op_increment
op_assign
op_star
id|cp
op_increment
suffix:semicolon
op_star
id|dst
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|cp
op_assign
id|line
suffix:semicolon
id|isspace
c_func
(paren
op_star
id|cp
)paren
suffix:semicolon
id|cp
op_increment
)paren
suffix:semicolon
r_for
c_loop
(paren
id|bra
op_decrement
suffix:semicolon
id|isspace
c_func
(paren
op_star
id|bra
)paren
suffix:semicolon
id|bra
op_decrement
)paren
op_star
id|bra
op_assign
l_int|0
suffix:semicolon
id|cp
op_assign
id|sanity_check
c_func
(paren
id|cp
comma
id|email
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|name
comma
id|cp
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|handle_from
r_static
r_int
id|handle_from
c_func
(paren
r_char
op_star
id|in_line
)paren
(brace
r_char
id|line
(braket
l_int|1000
)braket
suffix:semicolon
r_char
op_star
id|at
suffix:semicolon
r_char
op_star
id|dst
suffix:semicolon
id|strcpy
c_func
(paren
id|line
comma
id|in_line
)paren
suffix:semicolon
id|at
op_assign
id|strchr
c_func
(paren
id|line
comma
l_char|&squot;@&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|at
)paren
r_return
id|bogus_from
c_func
(paren
id|line
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we already have one email, don&squot;t take any confusing lines&n;&t; */
r_if
c_cond
(paren
op_star
id|email
op_logical_and
id|strchr
c_func
(paren
id|at
op_plus
l_int|1
comma
l_char|&squot;@&squot;
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Pick up the string around &squot;@&squot;, possibly delimited with &lt;&gt;&n;&t; * pair; that is the email part.  White them out while copying.&n;&t; */
r_while
c_loop
(paren
id|at
OG
id|line
)paren
(brace
r_char
id|c
op_assign
id|at
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|isspace
c_func
(paren
id|c
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&lt;&squot;
)paren
(brace
id|at
(braket
l_int|1
)braket
op_assign
l_char|&squot; &squot;
suffix:semicolon
r_break
suffix:semicolon
)brace
id|at
op_decrement
suffix:semicolon
)brace
id|dst
op_assign
id|email
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
r_char
id|c
op_assign
op_star
id|at
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
op_logical_or
id|c
op_eq
l_char|&squot;&gt;&squot;
op_logical_or
id|isspace
c_func
(paren
id|c
)paren
)paren
(brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&gt;&squot;
)paren
op_star
id|at
op_assign
l_char|&squot; &squot;
suffix:semicolon
r_break
suffix:semicolon
)brace
op_star
id|at
op_increment
op_assign
l_char|&squot; &squot;
suffix:semicolon
op_star
id|dst
op_increment
op_assign
id|c
suffix:semicolon
)brace
op_star
id|dst
op_increment
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* The remainder is name.  It could be &quot;John Doe &lt;john.doe@xz&gt;&quot;&n;&t; * or &quot;john.doe@xz (John Doe)&quot;, but we have whited out the&n;&t; * email part, so trim from both ends, possibly removing&n;&t; * the () pair at the end.&n;&t; */
id|at
op_assign
id|line
op_plus
id|strlen
c_func
(paren
id|line
)paren
suffix:semicolon
r_while
c_loop
(paren
id|at
OG
id|line
)paren
(brace
r_int
r_char
id|c
op_assign
op_star
op_decrement
id|at
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|isspace
c_func
(paren
id|c
)paren
)paren
(brace
id|at
(braket
(paren
id|c
op_eq
l_char|&squot;)&squot;
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|at
op_assign
id|line
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
r_char
id|c
op_assign
op_star
id|at
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
op_logical_or
op_logical_neg
id|isspace
c_func
(paren
id|c
)paren
)paren
(brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;(&squot;
)paren
id|at
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
id|at
op_increment
suffix:semicolon
)brace
id|at
op_assign
id|sanity_check
c_func
(paren
id|at
comma
id|email
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|name
comma
id|at
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|handle_header
r_static
r_int
id|handle_header
c_func
(paren
r_char
op_star
id|line
comma
r_char
op_star
id|data
comma
r_int
id|ofs
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|line
op_logical_or
op_logical_neg
id|data
)paren
r_return
l_int|1
suffix:semicolon
id|strcpy
c_func
(paren
id|data
comma
id|line
op_plus
id|ofs
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* NOTE NOTE NOTE.  We do not claim we do full MIME.  We just attempt&n; * to have enough heuristics to grok MIME encoded patches often found&n; * on our mailing lists.  For example, we do not even treat header lines&n; * case insensitively.&n; */
DECL|function|slurp_attr
r_static
r_int
id|slurp_attr
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_const
r_char
op_star
id|name
comma
r_char
op_star
id|attr
)paren
(brace
r_const
r_char
op_star
id|ends
comma
op_star
id|ap
op_assign
id|strcasestr
c_func
(paren
id|line
comma
id|name
)paren
suffix:semicolon
r_int
id|sz
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ap
)paren
(brace
op_star
id|attr
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ap
op_add_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|ap
op_eq
l_char|&squot;&quot;&squot;
)paren
(brace
id|ap
op_increment
suffix:semicolon
id|ends
op_assign
l_string|&quot;&bslash;&quot;&quot;
suffix:semicolon
)brace
r_else
id|ends
op_assign
l_string|&quot;; &bslash;t&quot;
suffix:semicolon
id|sz
op_assign
id|strcspn
c_func
(paren
id|ap
comma
id|ends
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|attr
comma
id|ap
comma
id|sz
)paren
suffix:semicolon
id|attr
(braket
id|sz
)braket
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|struct|content_type
r_struct
id|content_type
(brace
DECL|member|boundary
r_char
op_star
id|boundary
suffix:semicolon
DECL|member|boundary_len
r_int
id|boundary_len
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|content
r_static
r_struct
id|content_type
id|content
(braket
id|MAX_BOUNDARIES
)braket
suffix:semicolon
DECL|variable|content_top
r_static
r_struct
id|content_type
op_star
id|content_top
op_assign
id|content
suffix:semicolon
DECL|function|handle_content_type
r_static
r_int
id|handle_content_type
c_func
(paren
r_char
op_star
id|line
)paren
(brace
r_char
id|boundary
(braket
l_int|256
)braket
suffix:semicolon
r_if
c_cond
(paren
id|strcasestr
c_func
(paren
id|line
comma
l_string|&quot;text/&quot;
)paren
op_eq
l_int|NULL
)paren
id|message_type
op_assign
id|TYPE_OTHER
suffix:semicolon
r_if
c_cond
(paren
id|slurp_attr
c_func
(paren
id|line
comma
l_string|&quot;boundary=&quot;
comma
id|boundary
op_plus
l_int|2
)paren
)paren
(brace
id|memcpy
c_func
(paren
id|boundary
comma
l_string|&quot;--&quot;
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|content_top
op_increment
op_ge
op_amp
id|content
(braket
id|MAX_BOUNDARIES
)braket
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Too many boundaries to handle&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|content_top-&gt;boundary_len
op_assign
id|strlen
c_func
(paren
id|boundary
)paren
suffix:semicolon
id|content_top-&gt;boundary
op_assign
id|xmalloc
c_func
(paren
id|content_top-&gt;boundary_len
op_plus
l_int|1
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|content_top-&gt;boundary
comma
id|boundary
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|slurp_attr
c_func
(paren
id|line
comma
l_string|&quot;charset=&quot;
comma
id|charset
)paren
)paren
(brace
r_int
id|i
comma
id|c
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|c
op_assign
id|charset
(braket
id|i
)braket
)paren
op_ne
l_int|0
suffix:semicolon
id|i
op_increment
)paren
id|charset
(braket
id|i
)braket
op_assign
id|tolower
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|handle_content_transfer_encoding
r_static
r_int
id|handle_content_transfer_encoding
c_func
(paren
r_char
op_star
id|line
)paren
(brace
r_if
c_cond
(paren
id|strcasestr
c_func
(paren
id|line
comma
l_string|&quot;base64&quot;
)paren
)paren
id|transfer_encoding
op_assign
id|TE_BASE64
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcasestr
c_func
(paren
id|line
comma
l_string|&quot;quoted-printable&quot;
)paren
)paren
id|transfer_encoding
op_assign
id|TE_QP
suffix:semicolon
r_else
id|transfer_encoding
op_assign
id|TE_DONTCARE
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|is_multipart_boundary
r_static
r_int
id|is_multipart_boundary
c_func
(paren
r_const
r_char
op_star
id|line
)paren
(brace
r_return
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|line
comma
id|content_top-&gt;boundary
comma
id|content_top-&gt;boundary_len
)paren
)paren
suffix:semicolon
)brace
DECL|function|eatspace
r_static
r_int
id|eatspace
c_func
(paren
r_char
op_star
id|line
)paren
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|line
)paren
suffix:semicolon
r_while
c_loop
(paren
id|len
OG
l_int|0
op_logical_and
id|isspace
c_func
(paren
id|line
(braket
id|len
op_minus
l_int|1
)braket
)paren
)paren
id|line
(braket
op_decrement
id|len
)braket
op_assign
l_int|0
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
DECL|function|cleanup_subject
r_static
r_char
op_star
id|cleanup_subject
c_func
(paren
r_char
op_star
id|subject
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_char
op_star
id|p
suffix:semicolon
r_int
id|len
comma
id|remove
suffix:semicolon
r_switch
c_cond
(paren
op_star
id|subject
)paren
(brace
r_case
l_char|&squot;r&squot;
suffix:colon
r_case
l_char|&squot;R&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;e:&quot;
comma
id|subject
op_plus
l_int|1
comma
l_int|2
)paren
)paren
(brace
id|subject
op_add_assign
l_int|3
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_char|&squot; &squot;
suffix:colon
r_case
l_char|&squot;&bslash;t&squot;
suffix:colon
r_case
l_char|&squot;:&squot;
suffix:colon
id|subject
op_increment
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;[&squot;
suffix:colon
id|p
op_assign
id|strchr
c_func
(paren
id|subject
comma
l_char|&squot;]&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
(brace
id|subject
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|len
op_assign
id|strlen
c_func
(paren
id|p
)paren
suffix:semicolon
id|remove
op_assign
id|p
id|subject
suffix:semicolon
r_if
c_cond
(paren
id|remove
op_le
id|len
op_star
l_int|2
)paren
(brace
id|subject
op_assign
id|p
op_plus
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
id|eatspace
c_func
(paren
id|subject
)paren
suffix:semicolon
r_return
id|subject
suffix:semicolon
)brace
)brace
DECL|function|cleanup_space
r_static
r_void
id|cleanup_space
c_func
(paren
r_char
op_star
id|buf
)paren
(brace
r_int
r_char
id|c
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
op_star
id|buf
)paren
op_ne
l_int|0
)paren
(brace
id|buf
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|isspace
c_func
(paren
id|c
)paren
)paren
(brace
id|buf
(braket
l_int|1
)braket
op_assign
l_char|&squot; &squot;
suffix:semicolon
id|c
op_assign
op_star
id|buf
suffix:semicolon
r_while
c_loop
(paren
id|isspace
c_func
(paren
id|c
)paren
)paren
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|buf
)paren
suffix:semicolon
id|memmove
c_func
(paren
id|buf
comma
id|buf
op_plus
l_int|1
comma
id|len
)paren
suffix:semicolon
id|c
op_assign
op_star
id|buf
suffix:semicolon
)brace
)brace
)brace
)brace
r_static
r_void
id|decode_header
c_func
(paren
r_char
op_star
id|it
comma
r_int
id|itsize
)paren
suffix:semicolon
DECL|variable|header
r_static
r_const
r_char
op_star
id|header
(braket
id|MAX_HDR_PARSED
)braket
op_assign
(brace
l_string|&quot;From&quot;
comma
l_string|&quot;Subject&quot;
comma
l_string|&quot;Date&quot;
comma
)brace
suffix:semicolon
DECL|function|check_header
r_static
r_int
id|check_header
c_func
(paren
r_char
op_star
id|line
comma
r_int
id|linesize
comma
r_char
op_star
op_star
id|hdr_data
comma
r_int
id|overwrite
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* search for the interesting parts */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|header
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|header
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|hdr_data
(braket
id|i
)braket
op_logical_or
id|overwrite
)paren
op_logical_and
op_logical_neg
id|strncasecmp
c_func
(paren
id|line
comma
id|header
(braket
id|i
)braket
comma
id|len
)paren
op_logical_and
id|line
(braket
id|len
)braket
op_eq
l_char|&squot;:&squot;
op_logical_and
id|isspace
c_func
(paren
id|line
(braket
id|len
op_plus
l_int|1
)braket
)paren
)paren
(brace
multiline_comment|/* Unwrap inline B and Q encoding, and optionally&n;&t;&t;&t; * normalize the meta information to utf8.&n;&t;&t;&t; */
id|decode_header
c_func
(paren
id|line
op_plus
id|len
op_plus
l_int|2
comma
id|linesize
id|len
l_int|2
)paren
suffix:semicolon
id|hdr_data
(braket
id|i
)braket
op_assign
id|xmalloc
c_func
(paren
l_int|1000
op_star
r_sizeof
(paren
r_char
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|handle_header
c_func
(paren
id|line
comma
id|hdr_data
(braket
id|i
)braket
comma
id|len
op_plus
l_int|2
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Content stuff */
r_if
c_cond
(paren
op_logical_neg
id|strncasecmp
c_func
(paren
id|line
comma
l_string|&quot;Content-Type&quot;
comma
l_int|12
)paren
op_logical_and
id|line
(braket
l_int|12
)braket
op_eq
l_char|&squot;:&squot;
op_logical_and
id|isspace
c_func
(paren
id|line
(braket
l_int|12
op_plus
l_int|1
)braket
)paren
)paren
(brace
id|decode_header
c_func
(paren
id|line
op_plus
l_int|12
op_plus
l_int|2
comma
id|linesize
l_int|12
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|handle_content_type
c_func
(paren
id|line
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|strncasecmp
c_func
(paren
id|line
comma
l_string|&quot;Content-Transfer-Encoding&quot;
comma
l_int|25
)paren
op_logical_and
id|line
(braket
l_int|25
)braket
op_eq
l_char|&squot;:&squot;
op_logical_and
id|isspace
c_func
(paren
id|line
(braket
l_int|25
op_plus
l_int|1
)braket
)paren
)paren
(brace
id|decode_header
c_func
(paren
id|line
op_plus
l_int|25
op_plus
l_int|2
comma
id|linesize
l_int|25
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|handle_content_transfer_encoding
c_func
(paren
id|line
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* for inbody stuff */
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;&gt;From&quot;
comma
id|line
comma
l_int|5
)paren
op_logical_and
id|isspace
c_func
(paren
id|line
(braket
l_int|5
)braket
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;[PATCH]&quot;
comma
id|line
comma
l_int|7
)paren
op_logical_and
id|isspace
c_func
(paren
id|line
(braket
l_int|7
)braket
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|header
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;Subject: &quot;
comma
id|header
(braket
id|i
)braket
comma
l_int|9
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|handle_header
c_func
(paren
id|line
comma
id|hdr_data
(braket
id|i
)braket
comma
l_int|0
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/* no match */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|is_rfc2822_header
r_static
r_int
id|is_rfc2822_header
c_func
(paren
r_char
op_star
id|line
)paren
(brace
multiline_comment|/*&n;&t; * The section that defines the loosest possible&n;&t; * field name is &quot;3.6.8 Optional fields&quot;.&n;&t; *&n;&t; * optional-field = field-name &quot;:&quot; unstructured CRLF&n;&t; * field-name = 1*ftext&n;&t; * ftext = %d33-57 / %59-126&n;&t; */
r_int
id|ch
suffix:semicolon
r_char
op_star
id|cp
op_assign
id|line
suffix:semicolon
multiline_comment|/* Count mbox From headers as headers */
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|line
comma
l_string|&quot;From &quot;
comma
l_int|5
)paren
op_logical_or
op_logical_neg
id|memcmp
c_func
(paren
id|line
comma
l_string|&quot;&gt;From &quot;
comma
l_int|6
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ch
op_assign
op_star
id|cp
op_increment
)paren
)paren
(brace
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;:&squot;
)paren
r_return
id|cp
op_ne
id|line
suffix:semicolon
r_if
c_cond
(paren
(paren
l_int|33
op_le
id|ch
op_logical_and
id|ch
op_le
l_int|57
)paren
op_logical_or
(paren
l_int|59
op_le
id|ch
op_logical_and
id|ch
op_le
l_int|126
)paren
)paren
r_continue
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * sz is size of &squot;line&squot; buffer in bytes.  Must be reasonably&n; * long enough to hold one physical real-world e-mail line.&n; */
DECL|function|read_one_header_line
r_static
r_int
id|read_one_header_line
c_func
(paren
r_char
op_star
id|line
comma
r_int
id|sz
comma
id|FILE
op_star
id|in
)paren
(brace
r_int
id|len
suffix:semicolon
multiline_comment|/*&n;&t; * We will read at most (sz-1) bytes and then potentially&n;&t; * re-add NUL after it.  Accessing line[sz] after this is safe&n;&t; * and we can allow len to grow up to and including sz.&n;&t; */
id|sz
op_decrement
suffix:semicolon
multiline_comment|/* Get the first part of the line. */
r_if
c_cond
(paren
op_logical_neg
id|fgets
c_func
(paren
id|line
comma
id|sz
comma
id|in
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Is it an empty line or not a valid rfc2822 header?&n;&t; * If so, stop here, and return false (&quot;not a header&quot;)&n;&t; */
id|len
op_assign
id|eatspace
c_func
(paren
id|line
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
op_logical_or
op_logical_neg
id|is_rfc2822_header
c_func
(paren
id|line
)paren
)paren
(brace
multiline_comment|/* Re-add the newline */
id|line
(braket
id|len
)braket
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
id|line
(braket
id|len
op_plus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now we need to eat all the continuation lines..&n;&t; * Yuck, 2822 header &quot;folding&quot;&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|peek
comma
id|addlen
suffix:semicolon
r_static
r_char
id|continuation
(braket
l_int|1000
)braket
suffix:semicolon
id|peek
op_assign
id|fgetc
c_func
(paren
id|in
)paren
suffix:semicolon
id|ungetc
c_func
(paren
id|peek
comma
id|in
)paren
suffix:semicolon
r_if
c_cond
(paren
id|peek
op_ne
l_char|&squot; &squot;
op_logical_and
id|peek
op_ne
l_char|&squot;&bslash;t&squot;
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fgets
c_func
(paren
id|continuation
comma
r_sizeof
(paren
id|continuation
)paren
comma
id|in
)paren
)paren
r_break
suffix:semicolon
id|addlen
op_assign
id|eatspace
c_func
(paren
id|continuation
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
id|sz
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|addlen
op_ge
id|sz
id|len
)paren
id|addlen
op_assign
id|sz
id|len
l_int|1
suffix:semicolon
id|memcpy
c_func
(paren
id|line
op_plus
id|len
comma
id|continuation
comma
id|addlen
)paren
suffix:semicolon
id|line
(braket
id|len
)braket
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
id|len
op_add_assign
id|addlen
suffix:semicolon
)brace
)brace
id|line
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|decode_q_segment
r_static
r_int
id|decode_q_segment
c_func
(paren
r_char
op_star
id|in
comma
r_char
op_star
id|ot
comma
r_int
id|otsize
comma
r_char
op_star
id|ep
comma
r_int
id|rfc2047
)paren
(brace
r_char
op_star
id|otbegin
op_assign
id|ot
suffix:semicolon
r_char
op_star
id|otend
op_assign
id|ot
op_plus
id|otsize
suffix:semicolon
r_int
id|c
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
op_star
id|in
op_increment
)paren
op_ne
l_int|0
op_logical_and
(paren
id|in
op_le
id|ep
)paren
)paren
(brace
r_if
c_cond
(paren
id|ot
op_eq
id|otend
)paren
(brace
op_star
op_decrement
id|ot
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;=&squot;
)paren
(brace
r_int
id|d
op_assign
op_star
id|in
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|d
op_eq
l_char|&squot;&bslash;n&squot;
op_logical_or
op_logical_neg
id|d
)paren
r_break
suffix:semicolon
multiline_comment|/* drop trailing newline */
op_star
id|ot
op_increment
op_assign
(paren
(paren
id|hexval
c_func
(paren
id|d
)paren
op_lshift
l_int|4
)paren
op_or
id|hexval
c_func
(paren
op_star
id|in
op_increment
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rfc2047
op_logical_and
id|c
op_eq
l_char|&squot;_&squot;
)paren
multiline_comment|/* rfc2047 4.2 (2) */
id|c
op_assign
l_int|0x20
suffix:semicolon
op_star
id|ot
op_increment
op_assign
id|c
suffix:semicolon
)brace
op_star
id|ot
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|ot
id|otbegin
)paren
suffix:semicolon
)brace
DECL|function|decode_b_segment
r_static
r_int
id|decode_b_segment
c_func
(paren
r_char
op_star
id|in
comma
r_char
op_star
id|ot
comma
r_int
id|otsize
comma
r_char
op_star
id|ep
)paren
(brace
multiline_comment|/* Decode in..ep, possibly in-place to ot */
r_int
id|c
comma
id|pos
op_assign
l_int|0
comma
id|acc
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|otbegin
op_assign
id|ot
suffix:semicolon
r_char
op_star
id|otend
op_assign
id|ot
op_plus
id|otsize
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
op_star
id|in
op_increment
)paren
op_ne
l_int|0
op_logical_and
(paren
id|in
op_le
id|ep
)paren
)paren
(brace
r_if
c_cond
(paren
id|ot
op_eq
id|otend
)paren
(brace
op_star
op_decrement
id|ot
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;+&squot;
)paren
id|c
op_assign
l_int|62
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;/&squot;
)paren
id|c
op_assign
l_int|63
suffix:semicolon
r_else
r_if
c_cond
(paren
l_char|&squot;A&squot;
op_le
id|c
op_logical_and
id|c
op_le
l_char|&squot;Z&squot;
)paren
id|c
op_sub_assign
l_char|&squot;A&squot;
suffix:semicolon
r_else
r_if
c_cond
(paren
l_char|&squot;a&squot;
op_le
id|c
op_logical_and
id|c
op_le
l_char|&squot;z&squot;
)paren
id|c
op_sub_assign
l_char|&squot;a&squot;
l_int|26
suffix:semicolon
r_else
r_if
c_cond
(paren
l_char|&squot;0&squot;
op_le
id|c
op_logical_and
id|c
op_le
l_char|&squot;9&squot;
)paren
id|c
op_sub_assign
l_char|&squot;0&squot;
l_int|52
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;=&squot;
)paren
(brace
multiline_comment|/* padding is almost like (c == 0), except we do&n;&t;&t;&t; * not output NUL resulting only from it;&n;&t;&t;&t; * for now we just trust the data.&n;&t;&t;&t; */
id|c
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_continue
suffix:semicolon
multiline_comment|/* garbage */
r_switch
c_cond
(paren
id|pos
op_increment
)paren
(brace
r_case
l_int|0
suffix:colon
id|acc
op_assign
(paren
id|c
op_lshift
l_int|2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
op_star
id|ot
op_increment
op_assign
(paren
id|acc
op_or
(paren
id|c
op_rshift
l_int|4
)paren
)paren
suffix:semicolon
id|acc
op_assign
(paren
id|c
op_amp
l_int|15
)paren
op_lshift
l_int|4
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
op_star
id|ot
op_increment
op_assign
(paren
id|acc
op_or
(paren
id|c
op_rshift
l_int|2
)paren
)paren
suffix:semicolon
id|acc
op_assign
(paren
id|c
op_amp
l_int|3
)paren
op_lshift
l_int|6
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
op_star
id|ot
op_increment
op_assign
(paren
id|acc
op_or
id|c
)paren
suffix:semicolon
id|acc
op_assign
id|pos
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
op_star
id|ot
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|ot
id|otbegin
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * When there is no known charset, guess.&n; *&n; * Right now we assume that if the target is UTF-8 (the default),&n; * and it already looks like UTF-8 (which includes US-ASCII as its&n; * subset, of course) then that is what it is and there is nothing&n; * to do.&n; *&n; * Otherwise, we default to assuming it is Latin1 for historical&n; * reasons.&n; */
DECL|function|guess_charset
r_static
r_const
r_char
op_star
id|guess_charset
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_const
r_char
op_star
id|target_charset
)paren
(brace
r_if
c_cond
(paren
id|is_encoding_utf8
c_func
(paren
id|target_charset
)paren
)paren
(brace
r_if
c_cond
(paren
id|is_utf8
c_func
(paren
id|line
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
l_string|&quot;latin1&quot;
suffix:semicolon
)brace
DECL|function|convert_to_utf8
r_static
r_void
id|convert_to_utf8
c_func
(paren
r_char
op_star
id|line
comma
r_int
id|linesize
comma
r_const
r_char
op_star
id|charset
)paren
(brace
r_char
op_star
id|out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|charset
op_logical_or
op_logical_neg
op_star
id|charset
)paren
(brace
id|charset
op_assign
id|guess_charset
c_func
(paren
id|line
comma
id|metainfo_charset
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|charset
)paren
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|metainfo_charset
comma
id|charset
)paren
)paren
r_return
suffix:semicolon
id|out
op_assign
id|reencode_string
c_func
(paren
id|line
comma
id|metainfo_charset
comma
id|charset
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|out
)paren
id|die
c_func
(paren
l_string|&quot;cannot convert from %s to %s&bslash;n&quot;
comma
id|charset
comma
id|metainfo_charset
)paren
suffix:semicolon
id|strlcpy
c_func
(paren
id|line
comma
id|out
comma
id|linesize
)paren
suffix:semicolon
id|free
c_func
(paren
id|out
)paren
suffix:semicolon
)brace
DECL|function|decode_header_bq
r_static
r_int
id|decode_header_bq
c_func
(paren
r_char
op_star
id|it
comma
r_int
id|itsize
)paren
(brace
r_char
op_star
id|in
comma
op_star
id|out
comma
op_star
id|ep
comma
op_star
id|cp
comma
op_star
id|sp
suffix:semicolon
r_char
id|outbuf
(braket
l_int|1000
)braket
suffix:semicolon
r_int
id|rfc2047
op_assign
l_int|0
suffix:semicolon
id|in
op_assign
id|it
suffix:semicolon
id|out
op_assign
id|outbuf
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ep
op_assign
id|strstr
c_func
(paren
id|in
comma
l_string|&quot;=?&quot;
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_int
id|sz
comma
id|encoding
suffix:semicolon
r_char
id|charset_q
(braket
l_int|256
)braket
comma
id|piecebuf
(braket
l_int|256
)braket
suffix:semicolon
id|rfc2047
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|in
op_ne
id|ep
)paren
(brace
id|sz
op_assign
id|ep
id|in
suffix:semicolon
id|memcpy
c_func
(paren
id|out
comma
id|in
comma
id|sz
)paren
suffix:semicolon
id|out
op_add_assign
id|sz
suffix:semicolon
id|in
op_add_assign
id|sz
suffix:semicolon
)brace
multiline_comment|/* E.g.&n;&t;&t; * ep : &quot;=?iso-2022-jp?B?GyR...?= foo&quot;&n;&t;&t; * ep : &quot;=?ISO-8859-1?Q?Foo=FCbar?= baz&quot;&n;&t;&t; */
id|ep
op_add_assign
l_int|2
suffix:semicolon
id|cp
op_assign
id|strchr
c_func
(paren
id|ep
comma
l_char|&squot;?&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_return
id|rfc2047
suffix:semicolon
multiline_comment|/* no munging */
r_for
c_loop
(paren
id|sp
op_assign
id|ep
suffix:semicolon
id|sp
OL
id|cp
suffix:semicolon
id|sp
op_increment
)paren
id|charset_q
(braket
id|sp
id|ep
)braket
op_assign
id|tolower
c_func
(paren
op_star
id|sp
)paren
suffix:semicolon
id|charset_q
(braket
id|cp
id|ep
)braket
op_assign
l_int|0
suffix:semicolon
id|encoding
op_assign
id|cp
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|encoding
op_logical_or
id|cp
(braket
l_int|2
)braket
op_ne
l_char|&squot;?&squot;
)paren
r_return
id|rfc2047
suffix:semicolon
multiline_comment|/* no munging */
id|ep
op_assign
id|strstr
c_func
(paren
id|cp
op_plus
l_int|3
comma
l_string|&quot;?=&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ep
)paren
r_return
id|rfc2047
suffix:semicolon
multiline_comment|/* no munging */
r_switch
c_cond
(paren
id|tolower
c_func
(paren
id|encoding
)paren
)paren
(brace
r_default
suffix:colon
r_return
id|rfc2047
suffix:semicolon
multiline_comment|/* no munging */
r_case
l_char|&squot;b&squot;
suffix:colon
id|sz
op_assign
id|decode_b_segment
c_func
(paren
id|cp
op_plus
l_int|3
comma
id|piecebuf
comma
r_sizeof
(paren
id|piecebuf
)paren
comma
id|ep
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;q&squot;
suffix:colon
id|sz
op_assign
id|decode_q_segment
c_func
(paren
id|cp
op_plus
l_int|3
comma
id|piecebuf
comma
r_sizeof
(paren
id|piecebuf
)paren
comma
id|ep
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sz
OL
l_int|0
)paren
r_return
id|rfc2047
suffix:semicolon
r_if
c_cond
(paren
id|metainfo_charset
)paren
id|convert_to_utf8
c_func
(paren
id|piecebuf
comma
r_sizeof
(paren
id|piecebuf
)paren
comma
id|charset_q
)paren
suffix:semicolon
id|sz
op_assign
id|strlen
c_func
(paren
id|piecebuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|outbuf
op_plus
r_sizeof
(paren
id|outbuf
)paren
op_le
id|out
op_plus
id|sz
)paren
r_return
id|rfc2047
suffix:semicolon
multiline_comment|/* no munging */
id|strcpy
c_func
(paren
id|out
comma
id|piecebuf
)paren
suffix:semicolon
id|out
op_add_assign
id|sz
suffix:semicolon
id|in
op_assign
id|ep
op_plus
l_int|2
suffix:semicolon
)brace
id|strcpy
c_func
(paren
id|out
comma
id|in
)paren
suffix:semicolon
id|strlcpy
c_func
(paren
id|it
comma
id|outbuf
comma
id|itsize
)paren
suffix:semicolon
r_return
id|rfc2047
suffix:semicolon
)brace
DECL|function|decode_header
r_static
r_void
id|decode_header
c_func
(paren
r_char
op_star
id|it
comma
r_int
id|itsize
)paren
(brace
r_if
c_cond
(paren
id|decode_header_bq
c_func
(paren
id|it
comma
id|itsize
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* otherwise &quot;it&quot; is a straight copy of the input.&n;&t; * This can be binary guck but there is no charset specified.&n;&t; */
r_if
c_cond
(paren
id|metainfo_charset
)paren
id|convert_to_utf8
c_func
(paren
id|it
comma
id|itsize
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
DECL|function|decode_transfer_encoding
r_static
r_int
id|decode_transfer_encoding
c_func
(paren
r_char
op_star
id|line
comma
r_int
id|linesize
comma
r_int
id|inputlen
)paren
(brace
r_char
op_star
id|ep
suffix:semicolon
r_switch
c_cond
(paren
id|transfer_encoding
)paren
(brace
r_case
id|TE_QP
suffix:colon
id|ep
op_assign
id|line
op_plus
id|inputlen
suffix:semicolon
r_return
id|decode_q_segment
c_func
(paren
id|line
comma
id|line
comma
id|linesize
comma
id|ep
comma
l_int|0
)paren
suffix:semicolon
r_case
id|TE_BASE64
suffix:colon
id|ep
op_assign
id|line
op_plus
id|inputlen
suffix:semicolon
r_return
id|decode_b_segment
c_func
(paren
id|line
comma
id|line
comma
id|linesize
comma
id|ep
)paren
suffix:semicolon
r_case
id|TE_DONTCARE
suffix:colon
r_default
suffix:colon
r_return
id|inputlen
suffix:semicolon
)brace
)brace
r_static
r_int
id|handle_filter
c_func
(paren
r_char
op_star
id|line
comma
r_int
id|linesize
comma
r_int
id|linelen
)paren
suffix:semicolon
DECL|function|find_boundary
r_static
r_int
id|find_boundary
c_func
(paren
r_void
)paren
(brace
r_while
c_loop
(paren
id|fgets
c_func
(paren
id|line
comma
r_sizeof
(paren
id|line
)paren
comma
id|fin
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|is_multipart_boundary
c_func
(paren
id|line
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|handle_boundary
r_static
r_int
id|handle_boundary
c_func
(paren
r_void
)paren
(brace
r_char
id|newline
(braket
)braket
op_assign
l_string|&quot;&bslash;n&quot;
suffix:semicolon
id|again
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|line
op_plus
id|content_top-&gt;boundary_len
comma
l_string|&quot;--&quot;
comma
l_int|2
)paren
)paren
(brace
multiline_comment|/* we hit an end boundary */
multiline_comment|/* pop the current boundary off the stack */
id|free
c_func
(paren
id|content_top-&gt;boundary
)paren
suffix:semicolon
multiline_comment|/* technically won&squot;t happen as is_multipart_boundary()&n;&t;&t;   will fail first.  But just in case..&n;&t;&t; */
r_if
c_cond
(paren
id|content_top
op_decrement
OL
id|content
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Detected mismatched boundaries, &quot;
l_string|&quot;can&squot;t recover&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|handle_filter
c_func
(paren
id|newline
comma
r_sizeof
(paren
id|newline
)paren
comma
id|strlen
c_func
(paren
id|newline
)paren
)paren
suffix:semicolon
multiline_comment|/* skip to the next boundary */
r_if
c_cond
(paren
op_logical_neg
id|find_boundary
c_func
(paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_goto
id|again
suffix:semicolon
)brace
multiline_comment|/* set some defaults */
id|transfer_encoding
op_assign
id|TE_DONTCARE
suffix:semicolon
id|charset
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|message_type
op_assign
id|TYPE_TEXT
suffix:semicolon
multiline_comment|/* slurp in this section&squot;s info */
r_while
c_loop
(paren
id|read_one_header_line
c_func
(paren
id|line
comma
r_sizeof
(paren
id|line
)paren
comma
id|fin
)paren
)paren
id|check_header
c_func
(paren
id|line
comma
r_sizeof
(paren
id|line
)paren
comma
id|p_hdr_data
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* eat the blank line after section info */
r_return
(paren
id|fgets
c_func
(paren
id|line
comma
r_sizeof
(paren
id|line
)paren
comma
id|fin
)paren
op_ne
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|patchbreak
r_static
r_inline
r_int
id|patchbreak
c_func
(paren
r_const
r_char
op_star
id|line
)paren
(brace
multiline_comment|/* Beginning of a &quot;diff -&quot; header? */
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;diff -&quot;
comma
id|line
comma
l_int|6
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* CVS &quot;Index: &quot; line? */
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;Index: &quot;
comma
id|line
comma
l_int|7
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * &quot;--- &lt;filename&gt;&quot; starts patches without headers&n;&t; * &quot;---&lt;sp&gt;*&quot; is a manual separator&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;---&quot;
comma
id|line
comma
l_int|3
)paren
)paren
(brace
id|line
op_add_assign
l_int|3
suffix:semicolon
multiline_comment|/* space followed by a filename? */
r_if
c_cond
(paren
id|line
(braket
l_int|0
)braket
op_eq
l_char|&squot; &squot;
op_logical_and
op_logical_neg
id|isspace
c_func
(paren
id|line
(braket
l_int|1
)braket
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Just whitespace? */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
r_char
id|c
op_assign
op_star
id|line
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|isspace
c_func
(paren
id|c
)paren
)paren
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|handle_commit_msg
r_static
r_int
id|handle_commit_msg
c_func
(paren
r_char
op_star
id|line
comma
r_int
id|linesize
)paren
(brace
r_static
r_int
id|still_looking
op_assign
l_int|1
suffix:semicolon
r_char
op_star
id|endline
op_assign
id|line
op_plus
id|linesize
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmitmsg
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|still_looking
)paren
(brace
r_char
op_star
id|cp
op_assign
id|line
suffix:semicolon
r_if
c_cond
(paren
id|isspace
c_func
(paren
op_star
id|line
)paren
)paren
(brace
r_for
c_loop
(paren
id|cp
op_assign
id|line
op_plus
l_int|1
suffix:semicolon
op_star
id|cp
suffix:semicolon
id|cp
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|isspace
c_func
(paren
op_star
id|cp
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|cp
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|still_looking
op_assign
id|check_header
c_func
(paren
id|cp
comma
id|endline
id|cp
comma
id|s_hdr_data
comma
l_int|0
)paren
)paren
op_ne
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* normalize the log message to UTF-8. */
r_if
c_cond
(paren
id|metainfo_charset
)paren
id|convert_to_utf8
c_func
(paren
id|line
comma
id|endline
id|line
comma
id|charset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|patchbreak
c_func
(paren
id|line
)paren
)paren
(brace
id|fclose
c_func
(paren
id|cmitmsg
)paren
suffix:semicolon
id|cmitmsg
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|fputs
c_func
(paren
id|line
comma
id|cmitmsg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|handle_patch
r_static
r_int
id|handle_patch
c_func
(paren
r_char
op_star
id|line
comma
r_int
id|len
)paren
(brace
id|fwrite
c_func
(paren
id|line
comma
l_int|1
comma
id|len
comma
id|patchfile
)paren
suffix:semicolon
id|patch_lines
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|handle_filter
r_static
r_int
id|handle_filter
c_func
(paren
r_char
op_star
id|line
comma
r_int
id|linesize
comma
r_int
id|linelen
)paren
(brace
r_static
r_int
id|filter
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* filter tells us which part we left off on&n;&t; * a non-zero return indicates we hit a filter point&n;&t; */
r_switch
c_cond
(paren
id|filter
)paren
(brace
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|handle_commit_msg
c_func
(paren
id|line
comma
id|linesize
)paren
)paren
r_break
suffix:semicolon
id|filter
op_increment
suffix:semicolon
r_case
l_int|1
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|handle_patch
c_func
(paren
id|line
comma
id|linelen
)paren
)paren
r_break
suffix:semicolon
id|filter
op_increment
suffix:semicolon
r_default
suffix:colon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|handle_body
r_static
r_void
id|handle_body
c_func
(paren
r_void
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_static
r_char
id|newline
(braket
l_int|2000
)braket
suffix:semicolon
r_static
r_char
op_star
id|np
op_assign
id|newline
suffix:semicolon
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|line
)paren
suffix:semicolon
multiline_comment|/* Skip up to the first boundary */
r_if
c_cond
(paren
id|content_top-&gt;boundary
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|find_boundary
c_func
(paren
)paren
)paren
r_return
suffix:semicolon
)brace
r_do
(brace
multiline_comment|/* process any boundary lines */
r_if
c_cond
(paren
id|content_top-&gt;boundary
op_logical_and
id|is_multipart_boundary
c_func
(paren
id|line
)paren
)paren
(brace
multiline_comment|/* flush any leftover */
r_if
c_cond
(paren
id|np
op_ne
id|newline
)paren
id|handle_filter
c_func
(paren
id|newline
comma
r_sizeof
(paren
id|newline
)paren
comma
id|np
id|newline
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|handle_boundary
c_func
(paren
)paren
)paren
r_return
suffix:semicolon
)brace
multiline_comment|/* Unwrap transfer encoding */
id|len
op_assign
id|decode_transfer_encoding
c_func
(paren
id|line
comma
r_sizeof
(paren
id|line
)paren
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Malformed input line&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|transfer_encoding
)paren
(brace
r_case
id|TE_BASE64
suffix:colon
r_case
id|TE_QP
suffix:colon
(brace
r_char
op_star
id|op
op_assign
id|line
suffix:semicolon
multiline_comment|/* binary data most likely doesn&squot;t have newlines */
r_if
c_cond
(paren
id|message_type
op_ne
id|TYPE_TEXT
)paren
(brace
id|rc
op_assign
id|handle_filter
c_func
(paren
id|line
comma
r_sizeof
(paren
id|line
)paren
comma
id|len
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * This is a decoded line that may contain&n;&t;&t;&t; * multiple new lines.  Pass only one chunk&n;&t;&t;&t; * at a time to handle_filter()&n;&t;&t;&t; */
r_do
(brace
r_while
c_loop
(paren
id|op
OL
id|line
op_plus
id|len
op_logical_and
op_star
id|op
op_ne
l_char|&squot;&bslash;n&squot;
)paren
op_star
id|np
op_increment
op_assign
op_star
id|op
op_increment
suffix:semicolon
op_star
id|np
op_assign
op_star
id|op
suffix:semicolon
r_if
c_cond
(paren
op_star
id|np
op_ne
l_int|0
)paren
(brace
multiline_comment|/* should be sitting on a new line */
op_star
(paren
op_increment
id|np
)paren
op_assign
l_int|0
suffix:semicolon
id|op
op_increment
suffix:semicolon
id|rc
op_assign
id|handle_filter
c_func
(paren
id|newline
comma
r_sizeof
(paren
id|newline
)paren
comma
id|np
id|newline
)paren
suffix:semicolon
id|np
op_assign
id|newline
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|op
OL
id|line
op_plus
id|len
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * The partial chunk is saved in newline and will be&n;&t;&t;&t; * appended by the next iteration of read_line_with_nul().&n;&t;&t;&t; */
r_break
suffix:semicolon
)brace
r_default
suffix:colon
id|rc
op_assign
id|handle_filter
c_func
(paren
id|line
comma
r_sizeof
(paren
id|line
)paren
comma
id|len
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rc
)paren
multiline_comment|/* nothing left to filter */
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|len
op_assign
id|read_line_with_nul
c_func
(paren
id|line
comma
r_sizeof
(paren
id|line
)paren
comma
id|fin
)paren
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|output_header_lines
r_static
r_void
id|output_header_lines
c_func
(paren
id|FILE
op_star
id|fout
comma
r_const
r_char
op_star
id|hdr
comma
r_char
op_star
id|data
)paren
(brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_char
op_star
id|ep
op_assign
id|strchr
c_func
(paren
id|data
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ep
)paren
id|len
op_assign
id|strlen
c_func
(paren
id|data
)paren
suffix:semicolon
r_else
id|len
op_assign
id|ep
id|data
suffix:semicolon
id|fprintf
c_func
(paren
id|fout
comma
l_string|&quot;%s: %.*s&bslash;n&quot;
comma
id|hdr
comma
id|len
comma
id|data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ep
)paren
r_break
suffix:semicolon
id|data
op_assign
id|ep
op_plus
l_int|1
suffix:semicolon
)brace
)brace
DECL|function|handle_info
r_static
r_void
id|handle_info
c_func
(paren
r_void
)paren
(brace
r_char
op_star
id|sub
suffix:semicolon
r_char
op_star
id|hdr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|header
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* only print inbody headers if we output a patch file */
r_if
c_cond
(paren
id|patch_lines
op_logical_and
id|s_hdr_data
(braket
id|i
)braket
)paren
id|hdr
op_assign
id|s_hdr_data
(braket
id|i
)braket
suffix:semicolon
r_else
r_if
c_cond
(paren
id|p_hdr_data
(braket
id|i
)braket
)paren
id|hdr
op_assign
id|p_hdr_data
(braket
id|i
)braket
suffix:semicolon
r_else
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|header
(braket
id|i
)braket
comma
l_string|&quot;Subject&quot;
comma
l_int|7
)paren
)paren
(brace
r_if
c_cond
(paren
id|keep_subject
)paren
id|sub
op_assign
id|hdr
suffix:semicolon
r_else
(brace
id|sub
op_assign
id|cleanup_subject
c_func
(paren
id|hdr
)paren
suffix:semicolon
id|cleanup_space
c_func
(paren
id|sub
)paren
suffix:semicolon
)brace
id|output_header_lines
c_func
(paren
id|fout
comma
l_string|&quot;Subject&quot;
comma
id|sub
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|header
(braket
id|i
)braket
comma
l_string|&quot;From&quot;
comma
l_int|4
)paren
)paren
(brace
id|handle_from
c_func
(paren
id|hdr
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|fout
comma
l_string|&quot;Author: %s&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|fout
comma
l_string|&quot;Email: %s&bslash;n&quot;
comma
id|email
)paren
suffix:semicolon
)brace
r_else
(brace
id|cleanup_space
c_func
(paren
id|hdr
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|fout
comma
l_string|&quot;%s: %s&bslash;n&quot;
comma
id|header
(braket
id|i
)braket
comma
id|hdr
)paren
suffix:semicolon
)brace
)brace
id|fprintf
c_func
(paren
id|fout
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|mailinfo
r_static
r_int
id|mailinfo
c_func
(paren
id|FILE
op_star
id|in
comma
id|FILE
op_star
id|out
comma
r_int
id|ks
comma
r_const
r_char
op_star
id|encoding
comma
r_const
r_char
op_star
id|msg
comma
r_const
r_char
op_star
id|patch
)paren
(brace
r_int
id|peek
suffix:semicolon
id|keep_subject
op_assign
id|ks
suffix:semicolon
id|metainfo_charset
op_assign
id|encoding
suffix:semicolon
id|fin
op_assign
id|in
suffix:semicolon
id|fout
op_assign
id|out
suffix:semicolon
id|cmitmsg
op_assign
id|fopen
c_func
(paren
id|msg
comma
l_string|&quot;w&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmitmsg
)paren
(brace
id|perror
c_func
(paren
id|msg
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|patchfile
op_assign
id|fopen
c_func
(paren
id|patch
comma
l_string|&quot;w&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|patchfile
)paren
(brace
id|perror
c_func
(paren
id|patch
)paren
suffix:semicolon
id|fclose
c_func
(paren
id|cmitmsg
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|p_hdr_data
op_assign
id|xcalloc
c_func
(paren
id|MAX_HDR_PARSED
comma
r_sizeof
(paren
r_char
op_star
)paren
)paren
suffix:semicolon
id|s_hdr_data
op_assign
id|xcalloc
c_func
(paren
id|MAX_HDR_PARSED
comma
r_sizeof
(paren
r_char
op_star
)paren
)paren
suffix:semicolon
r_do
(brace
id|peek
op_assign
id|fgetc
c_func
(paren
id|in
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|isspace
c_func
(paren
id|peek
)paren
)paren
suffix:semicolon
id|ungetc
c_func
(paren
id|peek
comma
id|in
)paren
suffix:semicolon
multiline_comment|/* process the email header */
r_while
c_loop
(paren
id|read_one_header_line
c_func
(paren
id|line
comma
r_sizeof
(paren
id|line
)paren
comma
id|fin
)paren
)paren
id|check_header
c_func
(paren
id|line
comma
r_sizeof
(paren
id|line
)paren
comma
id|p_hdr_data
comma
l_int|1
)paren
suffix:semicolon
id|handle_body
c_func
(paren
)paren
suffix:semicolon
id|handle_info
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|mailinfo_usage
r_static
r_const
r_char
id|mailinfo_usage
(braket
)braket
op_assign
l_string|&quot;git-mailinfo [-k] [-u | --encoding=&lt;encoding&gt;] msg patch &lt;mail &gt;info&quot;
suffix:semicolon
DECL|function|cmd_mailinfo
r_int
id|cmd_mailinfo
c_func
(paren
r_int
id|argc
comma
r_const
r_char
op_star
op_star
id|argv
comma
r_const
r_char
op_star
id|prefix
)paren
(brace
r_const
r_char
op_star
id|def_charset
suffix:semicolon
multiline_comment|/* NEEDSWORK: might want to do the optional .git/ directory&n;&t; * discovery&n;&t; */
id|git_config
c_func
(paren
id|git_default_config
)paren
suffix:semicolon
id|def_charset
op_assign
(paren
id|git_commit_encoding
ques
c_cond
id|git_commit_encoding
suffix:colon
l_string|&quot;utf-8&quot;
)paren
suffix:semicolon
id|metainfo_charset
op_assign
id|def_charset
suffix:semicolon
r_while
c_loop
(paren
l_int|1
OL
id|argc
op_logical_and
id|argv
(braket
l_int|1
)braket
(braket
l_int|0
)braket
op_eq
l_char|&squot;-&squot;
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
l_string|&quot;-k&quot;
)paren
)paren
id|keep_subject
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
l_string|&quot;-u&quot;
)paren
)paren
id|metainfo_charset
op_assign
id|def_charset
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
l_string|&quot;-n&quot;
)paren
)paren
id|metainfo_charset
op_assign
l_int|NULL
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
l_string|&quot;--encoding=&quot;
)paren
)paren
id|metainfo_charset
op_assign
id|argv
(braket
l_int|1
)braket
op_plus
l_int|11
suffix:semicolon
r_else
id|usage
c_func
(paren
id|mailinfo_usage
)paren
suffix:semicolon
id|argc
op_decrement
suffix:semicolon
id|argv
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|argc
op_ne
l_int|3
)paren
id|usage
c_func
(paren
id|mailinfo_usage
)paren
suffix:semicolon
r_return
op_logical_neg
op_logical_neg
id|mailinfo
c_func
(paren
id|stdin
comma
id|stdout
comma
id|keep_subject
comma
id|metainfo_charset
comma
id|argv
(braket
l_int|1
)braket
comma
id|argv
(braket
l_int|2
)braket
)paren
suffix:semicolon
)brace
eof
