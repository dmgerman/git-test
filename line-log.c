macro_line|#include &quot;git-compat-util.h&quot;
macro_line|#include &quot;line-range.h&quot;
macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;tag.h&quot;
macro_line|#include &quot;blob.h&quot;
macro_line|#include &quot;tree.h&quot;
macro_line|#include &quot;diff.h&quot;
macro_line|#include &quot;commit.h&quot;
macro_line|#include &quot;decorate.h&quot;
macro_line|#include &quot;revision.h&quot;
macro_line|#include &quot;xdiff-interface.h&quot;
macro_line|#include &quot;strbuf.h&quot;
macro_line|#include &quot;log-tree.h&quot;
macro_line|#include &quot;graph.h&quot;
macro_line|#include &quot;userdiff.h&quot;
macro_line|#include &quot;line-log.h&quot;
DECL|function|range_set_grow
r_static
r_void
id|range_set_grow
c_func
(paren
r_struct
id|range_set
op_star
id|rs
comma
r_int
id|extra
)paren
(brace
id|ALLOC_GROW
c_func
(paren
id|rs-&gt;ranges
comma
id|rs-&gt;nr
op_plus
id|extra
comma
id|rs-&gt;alloc
)paren
suffix:semicolon
)brace
multiline_comment|/* Either initialization would be fine */
DECL|macro|RANGE_SET_INIT
mdefine_line|#define RANGE_SET_INIT {0}
DECL|function|range_set_init
r_static
r_void
id|range_set_init
c_func
(paren
r_struct
id|range_set
op_star
id|rs
comma
r_int
id|prealloc
)paren
(brace
id|rs-&gt;alloc
op_assign
id|rs-&gt;nr
op_assign
l_int|0
suffix:semicolon
id|rs-&gt;ranges
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|prealloc
)paren
id|range_set_grow
c_func
(paren
id|rs
comma
id|prealloc
)paren
suffix:semicolon
)brace
DECL|function|range_set_release
r_static
r_void
id|range_set_release
c_func
(paren
r_struct
id|range_set
op_star
id|rs
)paren
(brace
id|free
c_func
(paren
id|rs-&gt;ranges
)paren
suffix:semicolon
id|rs-&gt;alloc
op_assign
id|rs-&gt;nr
op_assign
l_int|0
suffix:semicolon
id|rs-&gt;ranges
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* dst must be uninitialized! */
DECL|function|range_set_copy
r_static
r_void
id|range_set_copy
c_func
(paren
r_struct
id|range_set
op_star
id|dst
comma
r_struct
id|range_set
op_star
id|src
)paren
(brace
id|range_set_init
c_func
(paren
id|dst
comma
id|src-&gt;nr
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|dst-&gt;ranges
comma
id|src-&gt;ranges
comma
id|src-&gt;nr
op_star
r_sizeof
(paren
r_struct
id|range_set
)paren
)paren
suffix:semicolon
id|dst-&gt;nr
op_assign
id|src-&gt;nr
suffix:semicolon
)brace
DECL|function|range_set_move
r_static
r_void
id|range_set_move
c_func
(paren
r_struct
id|range_set
op_star
id|dst
comma
r_struct
id|range_set
op_star
id|src
)paren
(brace
id|range_set_release
c_func
(paren
id|dst
)paren
suffix:semicolon
id|dst-&gt;ranges
op_assign
id|src-&gt;ranges
suffix:semicolon
id|dst-&gt;nr
op_assign
id|src-&gt;nr
suffix:semicolon
id|dst-&gt;alloc
op_assign
id|src-&gt;alloc
suffix:semicolon
id|src-&gt;ranges
op_assign
l_int|NULL
suffix:semicolon
id|src-&gt;alloc
op_assign
id|src-&gt;nr
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* tack on a _new_ range _at the end_ */
DECL|function|range_set_append_unsafe
r_static
r_void
id|range_set_append_unsafe
c_func
(paren
r_struct
id|range_set
op_star
id|rs
comma
r_int
id|a
comma
r_int
id|b
)paren
(brace
m_assert
(paren
id|a
op_le
id|b
)paren
suffix:semicolon
id|range_set_grow
c_func
(paren
id|rs
comma
l_int|1
)paren
suffix:semicolon
id|rs-&gt;ranges
(braket
id|rs-&gt;nr
)braket
dot
id|start
op_assign
id|a
suffix:semicolon
id|rs-&gt;ranges
(braket
id|rs-&gt;nr
)braket
dot
id|end
op_assign
id|b
suffix:semicolon
id|rs-&gt;nr
op_increment
suffix:semicolon
)brace
DECL|function|range_set_append
r_static
r_void
id|range_set_append
c_func
(paren
r_struct
id|range_set
op_star
id|rs
comma
r_int
id|a
comma
r_int
id|b
)paren
(brace
m_assert
(paren
id|rs-&gt;nr
op_eq
l_int|0
op_logical_or
id|rs-&gt;ranges
(braket
id|rs-&gt;nr
op_minus
l_int|1
)braket
dot
id|end
op_le
id|a
)paren
suffix:semicolon
id|range_set_append_unsafe
c_func
(paren
id|rs
comma
id|a
comma
id|b
)paren
suffix:semicolon
)brace
DECL|function|range_cmp
r_static
r_int
id|range_cmp
c_func
(paren
r_const
r_void
op_star
id|_r
comma
r_const
r_void
op_star
id|_s
)paren
(brace
r_const
r_struct
id|range
op_star
id|r
op_assign
id|_r
suffix:semicolon
r_const
r_struct
id|range
op_star
id|s
op_assign
id|_s
suffix:semicolon
multiline_comment|/* this could be simply &squot;return r.start-s.start&squot;, but for the types */
r_if
c_cond
(paren
id|r-&gt;start
op_eq
id|s-&gt;start
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|r-&gt;start
OL
id|s-&gt;start
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Check that the ranges are non-empty, sorted and non-overlapping&n; */
DECL|function|range_set_check_invariants
r_static
r_void
id|range_set_check_invariants
c_func
(paren
r_struct
id|range_set
op_star
id|rs
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rs
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|rs-&gt;nr
)paren
m_assert
(paren
id|rs-&gt;ranges
(braket
l_int|0
)braket
dot
id|start
OL
id|rs-&gt;ranges
(braket
l_int|0
)braket
dot
id|end
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|rs-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
m_assert
(paren
id|rs-&gt;ranges
(braket
id|i
op_minus
l_int|1
)braket
dot
id|end
OL
id|rs-&gt;ranges
(braket
id|i
)braket
dot
id|start
)paren
suffix:semicolon
m_assert
(paren
id|rs-&gt;ranges
(braket
id|i
)braket
dot
id|start
OL
id|rs-&gt;ranges
(braket
id|i
)braket
dot
id|end
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * In-place pass of sorting and merging the ranges in the range set,&n; * to establish the invariants when we get the ranges from the user&n; */
DECL|function|sort_and_merge_range_set
r_static
r_void
id|sort_and_merge_range_set
c_func
(paren
r_struct
id|range_set
op_star
id|rs
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|o
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* output cursor */
id|qsort
c_func
(paren
id|rs-&gt;ranges
comma
id|rs-&gt;nr
comma
r_sizeof
(paren
r_struct
id|range
)paren
comma
id|range_cmp
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|rs-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|rs-&gt;ranges
(braket
id|i
)braket
dot
id|start
op_le
id|rs-&gt;ranges
(braket
id|o
op_minus
l_int|1
)braket
dot
id|end
)paren
(brace
r_if
c_cond
(paren
id|rs-&gt;ranges
(braket
id|o
op_minus
l_int|1
)braket
dot
id|end
OL
id|rs-&gt;ranges
(braket
id|i
)braket
dot
id|end
)paren
id|rs-&gt;ranges
(braket
id|o
op_minus
l_int|1
)braket
dot
id|end
op_assign
id|rs-&gt;ranges
(braket
id|i
)braket
dot
id|end
suffix:semicolon
)brace
r_else
(brace
id|rs-&gt;ranges
(braket
id|o
)braket
dot
id|start
op_assign
id|rs-&gt;ranges
(braket
id|i
)braket
dot
id|start
suffix:semicolon
id|rs-&gt;ranges
(braket
id|o
)braket
dot
id|end
op_assign
id|rs-&gt;ranges
(braket
id|i
)braket
dot
id|end
suffix:semicolon
id|o
op_increment
suffix:semicolon
)brace
)brace
m_assert
(paren
id|o
op_le
id|rs-&gt;nr
)paren
suffix:semicolon
id|rs-&gt;nr
op_assign
id|o
suffix:semicolon
id|range_set_check_invariants
c_func
(paren
id|rs
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Union of range sets (i.e., sets of line numbers).  Used to merge&n; * them when searches meet at a common ancestor.&n; *&n; * This is also where the ranges are consolidated into canonical form:&n; * overlapping and adjacent ranges are merged, and empty ranges are&n; * removed.&n; */
DECL|function|range_set_union
r_static
r_void
id|range_set_union
c_func
(paren
r_struct
id|range_set
op_star
id|out
comma
r_struct
id|range_set
op_star
id|a
comma
r_struct
id|range_set
op_star
id|b
)paren
(brace
r_int
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
comma
id|o
op_assign
l_int|0
suffix:semicolon
r_struct
id|range
op_star
id|ra
op_assign
id|a-&gt;ranges
suffix:semicolon
r_struct
id|range
op_star
id|rb
op_assign
id|b-&gt;ranges
suffix:semicolon
multiline_comment|/* cannot make an alias of out-&gt;ranges: it may change during grow */
m_assert
(paren
id|out-&gt;nr
op_eq
l_int|0
)paren
suffix:semicolon
r_while
c_loop
(paren
id|i
OL
id|a-&gt;nr
op_logical_or
id|j
OL
id|b-&gt;nr
)paren
(brace
r_struct
id|range
op_star
r_new
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
id|a-&gt;nr
op_logical_and
id|j
OL
id|b-&gt;nr
)paren
(brace
r_if
c_cond
(paren
id|ra
(braket
id|i
)braket
dot
id|start
OL
id|rb
(braket
id|j
)braket
dot
id|start
)paren
r_new
op_assign
op_amp
id|ra
(braket
id|i
op_increment
)braket
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ra
(braket
id|i
)braket
dot
id|start
OG
id|rb
(braket
id|j
)braket
dot
id|start
)paren
r_new
op_assign
op_amp
id|rb
(braket
id|j
op_increment
)braket
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ra
(braket
id|i
)braket
dot
id|end
OL
id|rb
(braket
id|j
)braket
dot
id|end
)paren
r_new
op_assign
op_amp
id|ra
(braket
id|i
op_increment
)braket
suffix:semicolon
r_else
r_new
op_assign
op_amp
id|rb
(braket
id|j
op_increment
)braket
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|i
OL
id|a-&gt;nr
)paren
multiline_comment|/* b exhausted */
r_new
op_assign
op_amp
id|ra
(braket
id|i
op_increment
)braket
suffix:semicolon
r_else
multiline_comment|/* a exhausted */
r_new
op_assign
op_amp
id|rb
(braket
id|j
op_increment
)braket
suffix:semicolon
r_if
c_cond
(paren
r_new
op_member_access_from_pointer
id|start
op_eq
r_new
op_member_access_from_pointer
id|end
)paren
suffix:semicolon
multiline_comment|/* empty range */
r_else
r_if
c_cond
(paren
op_logical_neg
id|o
op_logical_or
id|out-&gt;ranges
(braket
id|o
op_minus
l_int|1
)braket
dot
id|end
OL
r_new
op_member_access_from_pointer
id|start
)paren
(brace
id|range_set_grow
c_func
(paren
id|out
comma
l_int|1
)paren
suffix:semicolon
id|out-&gt;ranges
(braket
id|o
)braket
dot
id|start
op_assign
r_new
op_member_access_from_pointer
id|start
suffix:semicolon
id|out-&gt;ranges
(braket
id|o
)braket
dot
id|end
op_assign
r_new
op_member_access_from_pointer
id|end
suffix:semicolon
id|o
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|out-&gt;ranges
(braket
id|o
op_minus
l_int|1
)braket
dot
id|end
OL
r_new
op_member_access_from_pointer
id|end
)paren
(brace
id|out-&gt;ranges
(braket
id|o
op_minus
l_int|1
)braket
dot
id|end
op_assign
r_new
op_member_access_from_pointer
id|end
suffix:semicolon
)brace
)brace
id|out-&gt;nr
op_assign
id|o
suffix:semicolon
)brace
multiline_comment|/*&n; * Difference of range sets (out = a &bslash; b).  Pass the &quot;interesting&quot;&n; * ranges as &squot;a&squot; and the target side of the diff as &squot;b&squot;: it removes&n; * the ranges for which the commit is responsible.&n; */
DECL|function|range_set_difference
r_static
r_void
id|range_set_difference
c_func
(paren
r_struct
id|range_set
op_star
id|out
comma
r_struct
id|range_set
op_star
id|a
comma
r_struct
id|range_set
op_star
id|b
)paren
(brace
r_int
id|i
comma
id|j
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|a-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|start
op_assign
id|a-&gt;ranges
(braket
id|i
)braket
dot
id|start
suffix:semicolon
r_int
id|end
op_assign
id|a-&gt;ranges
(braket
id|i
)braket
dot
id|end
suffix:semicolon
r_while
c_loop
(paren
id|start
OL
id|end
)paren
(brace
r_while
c_loop
(paren
id|j
OL
id|b-&gt;nr
op_logical_and
id|start
op_ge
id|b-&gt;ranges
(braket
id|j
)braket
dot
id|end
)paren
multiline_comment|/*&n;&t;&t;&t;&t; * a:         |-------&n;&t;&t;&t;&t; * b: ------|&n;&t;&t;&t;&t; */
id|j
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|j
op_ge
id|b-&gt;nr
op_logical_or
id|end
OL
id|b-&gt;ranges
(braket
id|j
)braket
dot
id|start
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * b exhausted, or&n;&t;&t;&t;&t; * a:  ----|&n;&t;&t;&t;&t; * b:         |----&n;&t;&t;&t;&t; */
id|range_set_append
c_func
(paren
id|out
comma
id|start
comma
id|end
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|start
op_ge
id|b-&gt;ranges
(braket
id|j
)braket
dot
id|start
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * a:     |--????&n;&t;&t;&t;&t; * b: |------|&n;&t;&t;&t;&t; */
id|start
op_assign
id|b-&gt;ranges
(braket
id|j
)braket
dot
id|end
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|end
OG
id|b-&gt;ranges
(braket
id|j
)braket
dot
id|start
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * a: |-----|&n;&t;&t;&t;&t; * b:    |--?????&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|start
OL
id|b-&gt;ranges
(braket
id|j
)braket
dot
id|start
)paren
id|range_set_append
c_func
(paren
id|out
comma
id|start
comma
id|b-&gt;ranges
(braket
id|j
)braket
dot
id|start
)paren
suffix:semicolon
id|start
op_assign
id|b-&gt;ranges
(braket
id|j
)braket
dot
id|end
suffix:semicolon
)brace
)brace
)brace
)brace
DECL|function|diff_ranges_init
r_static
r_void
id|diff_ranges_init
c_func
(paren
r_struct
id|diff_ranges
op_star
id|diff
)paren
(brace
id|range_set_init
c_func
(paren
op_amp
id|diff-&gt;parent
comma
l_int|0
)paren
suffix:semicolon
id|range_set_init
c_func
(paren
op_amp
id|diff-&gt;target
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|diff_ranges_release
r_static
r_void
id|diff_ranges_release
c_func
(paren
r_struct
id|diff_ranges
op_star
id|diff
)paren
(brace
id|range_set_release
c_func
(paren
op_amp
id|diff-&gt;parent
)paren
suffix:semicolon
id|range_set_release
c_func
(paren
op_amp
id|diff-&gt;target
)paren
suffix:semicolon
)brace
DECL|function|line_log_data_init
r_void
id|line_log_data_init
c_func
(paren
r_struct
id|line_log_data
op_star
id|r
)paren
(brace
id|memset
c_func
(paren
id|r
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|line_log_data
)paren
)paren
suffix:semicolon
id|range_set_init
c_func
(paren
op_amp
id|r-&gt;ranges
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|line_log_data_clear
r_static
r_void
id|line_log_data_clear
c_func
(paren
r_struct
id|line_log_data
op_star
id|r
)paren
(brace
id|range_set_release
c_func
(paren
op_amp
id|r-&gt;ranges
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r-&gt;pair
)paren
id|diff_free_filepair
c_func
(paren
id|r-&gt;pair
)paren
suffix:semicolon
)brace
DECL|function|free_line_log_data
r_static
r_void
id|free_line_log_data
c_func
(paren
r_struct
id|line_log_data
op_star
id|r
)paren
(brace
r_while
c_loop
(paren
id|r
)paren
(brace
r_struct
id|line_log_data
op_star
id|next
op_assign
id|r-&gt;next
suffix:semicolon
id|line_log_data_clear
c_func
(paren
id|r
)paren
suffix:semicolon
id|free
c_func
(paren
id|r
)paren
suffix:semicolon
id|r
op_assign
id|next
suffix:semicolon
)brace
)brace
r_static
r_struct
id|line_log_data
op_star
DECL|function|search_line_log_data
id|search_line_log_data
c_func
(paren
r_struct
id|line_log_data
op_star
id|list
comma
r_const
r_char
op_star
id|path
comma
r_struct
id|line_log_data
op_star
op_star
id|insertion_point
)paren
(brace
r_struct
id|line_log_data
op_star
id|p
op_assign
id|list
suffix:semicolon
r_if
c_cond
(paren
id|insertion_point
)paren
op_star
id|insertion_point
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|p
)paren
(brace
r_int
id|cmp
op_assign
id|strcmp
c_func
(paren
id|p-&gt;path
comma
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmp
)paren
r_return
id|p
suffix:semicolon
r_if
c_cond
(paren
id|insertion_point
op_logical_and
id|cmp
OL
l_int|0
)paren
op_star
id|insertion_point
op_assign
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Note: takes ownership of &squot;path&squot;, which happens to be what the only&n; * caller needs.&n; */
DECL|function|line_log_data_insert
r_static
r_void
id|line_log_data_insert
c_func
(paren
r_struct
id|line_log_data
op_star
op_star
id|list
comma
r_char
op_star
id|path
comma
r_int
id|begin
comma
r_int
id|end
)paren
(brace
r_struct
id|line_log_data
op_star
id|ip
suffix:semicolon
r_struct
id|line_log_data
op_star
id|p
op_assign
id|search_line_log_data
c_func
(paren
op_star
id|list
comma
id|path
comma
op_amp
id|ip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
(brace
id|range_set_append_unsafe
c_func
(paren
op_amp
id|p-&gt;ranges
comma
id|begin
comma
id|end
)paren
suffix:semicolon
id|sort_and_merge_range_set
c_func
(paren
op_amp
id|p-&gt;ranges
)paren
suffix:semicolon
id|free
c_func
(paren
id|path
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|p
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|line_log_data
)paren
)paren
suffix:semicolon
id|p-&gt;path
op_assign
id|path
suffix:semicolon
id|range_set_append
c_func
(paren
op_amp
id|p-&gt;ranges
comma
id|begin
comma
id|end
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
)paren
(brace
id|p-&gt;next
op_assign
id|ip-&gt;next
suffix:semicolon
id|ip-&gt;next
op_assign
id|p
suffix:semicolon
)brace
r_else
(brace
id|p-&gt;next
op_assign
op_star
id|list
suffix:semicolon
op_star
id|list
op_assign
id|p
suffix:semicolon
)brace
)brace
DECL|struct|collect_diff_cbdata
r_struct
id|collect_diff_cbdata
(brace
DECL|member|diff
r_struct
id|diff_ranges
op_star
id|diff
suffix:semicolon
)brace
suffix:semicolon
DECL|function|collect_diff_cb
r_static
r_int
id|collect_diff_cb
c_func
(paren
r_int
id|start_a
comma
r_int
id|count_a
comma
r_int
id|start_b
comma
r_int
id|count_b
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|collect_diff_cbdata
op_star
id|d
op_assign
id|data
suffix:semicolon
r_if
c_cond
(paren
id|count_a
op_ge
l_int|0
)paren
id|range_set_append
c_func
(paren
op_amp
id|d-&gt;diff-&gt;parent
comma
id|start_a
comma
id|start_a
op_plus
id|count_a
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count_b
op_ge
l_int|0
)paren
id|range_set_append
c_func
(paren
op_amp
id|d-&gt;diff-&gt;target
comma
id|start_b
comma
id|start_b
op_plus
id|count_b
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|collect_diff
r_static
r_void
id|collect_diff
c_func
(paren
id|mmfile_t
op_star
id|parent
comma
id|mmfile_t
op_star
id|target
comma
r_struct
id|diff_ranges
op_star
id|out
)paren
(brace
r_struct
id|collect_diff_cbdata
id|cbdata
op_assign
(brace
l_int|NULL
)brace
suffix:semicolon
id|xpparam_t
id|xpp
suffix:semicolon
id|xdemitconf_t
id|xecfg
suffix:semicolon
id|xdemitcb_t
id|ecb
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|xpp
comma
l_int|0
comma
r_sizeof
(paren
id|xpp
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|xecfg
comma
l_int|0
comma
r_sizeof
(paren
id|xecfg
)paren
)paren
suffix:semicolon
id|xecfg.ctxlen
op_assign
id|xecfg.interhunkctxlen
op_assign
l_int|0
suffix:semicolon
id|cbdata.diff
op_assign
id|out
suffix:semicolon
id|xecfg.hunk_func
op_assign
id|collect_diff_cb
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|ecb
comma
l_int|0
comma
r_sizeof
(paren
id|ecb
)paren
)paren
suffix:semicolon
id|ecb.priv
op_assign
op_amp
id|cbdata
suffix:semicolon
id|xdi_diff
c_func
(paren
id|parent
comma
id|target
comma
op_amp
id|xpp
comma
op_amp
id|xecfg
comma
op_amp
id|ecb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * These are handy for debugging.  Removing them with #if 0 silences&n; * the &quot;unused function&quot; warning.&n; */
macro_line|#if 0
r_static
r_void
id|dump_range_set
c_func
(paren
r_struct
id|range_set
op_star
id|rs
comma
r_const
r_char
op_star
id|desc
)paren
(brace
r_int
id|i
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;range set %s (%d items):&bslash;n&quot;
comma
id|desc
comma
id|rs-&gt;nr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|rs-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
id|printf
c_func
(paren
l_string|&quot;&bslash;t[%ld,%ld]&bslash;n&quot;
comma
id|rs-&gt;ranges
(braket
id|i
)braket
dot
id|start
comma
id|rs-&gt;ranges
(braket
id|i
)braket
dot
id|end
)paren
suffix:semicolon
)brace
r_static
r_void
id|dump_line_log_data
c_func
(paren
r_struct
id|line_log_data
op_star
id|r
)paren
(brace
r_char
id|buf
(braket
l_int|4096
)braket
suffix:semicolon
r_while
c_loop
(paren
id|r
)paren
(brace
id|snprintf
c_func
(paren
id|buf
comma
l_int|4096
comma
l_string|&quot;file %s&bslash;n&quot;
comma
id|r-&gt;path
)paren
suffix:semicolon
id|dump_range_set
c_func
(paren
op_amp
id|r-&gt;ranges
comma
id|buf
)paren
suffix:semicolon
id|r
op_assign
id|r-&gt;next
suffix:semicolon
)brace
)brace
r_static
r_void
id|dump_diff_ranges
c_func
(paren
r_struct
id|diff_ranges
op_star
id|diff
comma
r_const
r_char
op_star
id|desc
)paren
(brace
r_int
id|i
suffix:semicolon
m_assert
(paren
id|diff-&gt;parent.nr
op_eq
id|diff-&gt;target.nr
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;diff ranges %s (%d items):&bslash;n&quot;
comma
id|desc
comma
id|diff-&gt;parent.nr
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tparent&bslash;ttarget&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|diff-&gt;parent.nr
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;t[%ld,%ld]&bslash;t[%ld,%ld]&bslash;n&quot;
comma
id|diff-&gt;parent.ranges
(braket
id|i
)braket
dot
id|start
comma
id|diff-&gt;parent.ranges
(braket
id|i
)braket
dot
id|end
comma
id|diff-&gt;target.ranges
(braket
id|i
)braket
dot
id|start
comma
id|diff-&gt;target.ranges
(braket
id|i
)braket
dot
id|end
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
DECL|function|ranges_overlap
r_static
r_int
id|ranges_overlap
c_func
(paren
r_struct
id|range
op_star
id|a
comma
r_struct
id|range
op_star
id|b
)paren
(brace
r_return
op_logical_neg
(paren
id|a-&gt;end
op_le
id|b-&gt;start
op_logical_or
id|b-&gt;end
op_le
id|a-&gt;start
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Given a diff and the set of interesting ranges, determine all hunks&n; * of the diff which touch (overlap) at least one of the interesting&n; * ranges in the target.&n; */
DECL|function|diff_ranges_filter_touched
r_static
r_void
id|diff_ranges_filter_touched
c_func
(paren
r_struct
id|diff_ranges
op_star
id|out
comma
r_struct
id|diff_ranges
op_star
id|diff
comma
r_struct
id|range_set
op_star
id|rs
)paren
(brace
r_int
id|i
comma
id|j
op_assign
l_int|0
suffix:semicolon
m_assert
(paren
id|out-&gt;target.nr
op_eq
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|diff-&gt;target.nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_while
c_loop
(paren
id|diff-&gt;target.ranges
(braket
id|i
)braket
dot
id|start
OG
id|rs-&gt;ranges
(braket
id|j
)braket
dot
id|end
)paren
(brace
id|j
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|j
op_eq
id|rs-&gt;nr
)paren
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ranges_overlap
c_func
(paren
op_amp
id|diff-&gt;target.ranges
(braket
id|i
)braket
comma
op_amp
id|rs-&gt;ranges
(braket
id|j
)braket
)paren
)paren
(brace
id|range_set_append
c_func
(paren
op_amp
id|out-&gt;parent
comma
id|diff-&gt;parent.ranges
(braket
id|i
)braket
dot
id|start
comma
id|diff-&gt;parent.ranges
(braket
id|i
)braket
dot
id|end
)paren
suffix:semicolon
id|range_set_append
c_func
(paren
op_amp
id|out-&gt;target
comma
id|diff-&gt;target.ranges
(braket
id|i
)braket
dot
id|start
comma
id|diff-&gt;target.ranges
(braket
id|i
)braket
dot
id|end
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Adjust the line counts in &squot;rs&squot; to account for the lines&n; * added/removed in the diff.&n; */
DECL|function|range_set_shift_diff
r_static
r_void
id|range_set_shift_diff
c_func
(paren
r_struct
id|range_set
op_star
id|out
comma
r_struct
id|range_set
op_star
id|rs
comma
r_struct
id|diff_ranges
op_star
id|diff
)paren
(brace
r_int
id|i
comma
id|j
op_assign
l_int|0
suffix:semicolon
r_int
id|offset
op_assign
l_int|0
suffix:semicolon
r_struct
id|range
op_star
id|src
op_assign
id|rs-&gt;ranges
suffix:semicolon
r_struct
id|range
op_star
id|target
op_assign
id|diff-&gt;target.ranges
suffix:semicolon
r_struct
id|range
op_star
id|parent
op_assign
id|diff-&gt;parent.ranges
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|rs-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_while
c_loop
(paren
id|j
OL
id|diff-&gt;target.nr
op_logical_and
id|src
(braket
id|i
)braket
dot
id|start
op_ge
id|target
(braket
id|j
)braket
dot
id|start
)paren
(brace
id|offset
op_add_assign
(paren
id|parent
(braket
id|j
)braket
dot
id|end
op_minus
id|parent
(braket
id|j
)braket
dot
id|start
)paren
(paren
id|target
(braket
id|j
)braket
dot
id|end
op_minus
id|target
(braket
id|j
)braket
dot
id|start
)paren
suffix:semicolon
id|j
op_increment
suffix:semicolon
)brace
id|range_set_append
c_func
(paren
id|out
comma
id|src
(braket
id|i
)braket
dot
id|start
op_plus
id|offset
comma
id|src
(braket
id|i
)braket
dot
id|end
op_plus
id|offset
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Given a diff and the set of interesting ranges, map the ranges&n; * across the diff.  That is: observe that the target commit takes&n; * blame for all the + (target-side) ranges.  So for every pair of&n; * ranges in the diff that was touched, we remove the latter and add&n; * its parent side.&n; */
DECL|function|range_set_map_across_diff
r_static
r_void
id|range_set_map_across_diff
c_func
(paren
r_struct
id|range_set
op_star
id|out
comma
r_struct
id|range_set
op_star
id|rs
comma
r_struct
id|diff_ranges
op_star
id|diff
comma
r_struct
id|diff_ranges
op_star
op_star
id|touched_out
)paren
(brace
r_struct
id|diff_ranges
op_star
id|touched
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|touched
)paren
)paren
suffix:semicolon
r_struct
id|range_set
id|tmp1
op_assign
id|RANGE_SET_INIT
suffix:semicolon
r_struct
id|range_set
id|tmp2
op_assign
id|RANGE_SET_INIT
suffix:semicolon
id|diff_ranges_init
c_func
(paren
id|touched
)paren
suffix:semicolon
id|diff_ranges_filter_touched
c_func
(paren
id|touched
comma
id|diff
comma
id|rs
)paren
suffix:semicolon
id|range_set_difference
c_func
(paren
op_amp
id|tmp1
comma
id|rs
comma
op_amp
id|touched-&gt;target
)paren
suffix:semicolon
id|range_set_shift_diff
c_func
(paren
op_amp
id|tmp2
comma
op_amp
id|tmp1
comma
id|diff
)paren
suffix:semicolon
id|range_set_union
c_func
(paren
id|out
comma
op_amp
id|tmp2
comma
op_amp
id|touched-&gt;parent
)paren
suffix:semicolon
id|range_set_release
c_func
(paren
op_amp
id|tmp1
)paren
suffix:semicolon
id|range_set_release
c_func
(paren
op_amp
id|tmp2
)paren
suffix:semicolon
op_star
id|touched_out
op_assign
id|touched
suffix:semicolon
)brace
DECL|function|check_single_commit
r_static
r_struct
id|commit
op_star
id|check_single_commit
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
)paren
(brace
r_struct
id|object
op_star
id|commit
op_assign
l_int|NULL
suffix:semicolon
r_int
id|found
op_assign
l_int|1
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|revs-&gt;pending.nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|object
op_star
id|obj
op_assign
id|revs-&gt;pending.objects
(braket
id|i
)braket
dot
id|item
suffix:semicolon
r_if
c_cond
(paren
id|obj-&gt;flags
op_amp
id|UNINTERESTING
)paren
r_continue
suffix:semicolon
r_while
c_loop
(paren
id|obj-&gt;type
op_eq
id|OBJ_TAG
)paren
id|obj
op_assign
id|deref_tag
c_func
(paren
id|obj
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|obj-&gt;type
op_ne
id|OBJ_COMMIT
)paren
id|die
c_func
(paren
l_string|&quot;Non commit %s?&quot;
comma
id|revs-&gt;pending.objects
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|commit
)paren
id|die
c_func
(paren
l_string|&quot;More than one commit to dig from: %s and %s?&quot;
comma
id|revs-&gt;pending.objects
(braket
id|i
)braket
dot
id|name
comma
id|revs-&gt;pending.objects
(braket
id|found
)braket
dot
id|name
)paren
suffix:semicolon
id|commit
op_assign
id|obj
suffix:semicolon
id|found
op_assign
id|i
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|commit
)paren
id|die
c_func
(paren
l_string|&quot;No commit specified?&quot;
)paren
suffix:semicolon
r_return
(paren
r_struct
id|commit
op_star
)paren
id|commit
suffix:semicolon
)brace
DECL|function|fill_blob_sha1
r_static
r_void
id|fill_blob_sha1
c_func
(paren
r_struct
id|commit
op_star
id|commit
comma
r_struct
id|diff_filespec
op_star
id|spec
)paren
(brace
r_int
id|mode
suffix:semicolon
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_if
c_cond
(paren
id|get_tree_entry
c_func
(paren
id|commit-&gt;object.sha1
comma
id|spec-&gt;path
comma
id|sha1
comma
op_amp
id|mode
)paren
)paren
id|die
c_func
(paren
l_string|&quot;There is no path %s in the commit&quot;
comma
id|spec-&gt;path
)paren
suffix:semicolon
id|fill_filespec
c_func
(paren
id|spec
comma
id|sha1
comma
l_int|1
comma
id|mode
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|fill_line_ends
r_static
r_void
id|fill_line_ends
c_func
(paren
r_struct
id|diff_filespec
op_star
id|spec
comma
r_int
op_star
id|lines
comma
r_int
r_int
op_star
op_star
id|line_ends
)paren
(brace
r_int
id|num
op_assign
l_int|0
comma
id|size
op_assign
l_int|50
suffix:semicolon
r_int
id|cur
op_assign
l_int|0
suffix:semicolon
r_int
r_int
op_star
id|ends
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
id|data
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|diff_populate_filespec
c_func
(paren
id|spec
comma
l_int|0
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Cannot read blob %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|spec-&gt;sha1
)paren
)paren
suffix:semicolon
id|ends
op_assign
id|xmalloc
c_func
(paren
id|size
op_star
r_sizeof
(paren
op_star
id|ends
)paren
)paren
suffix:semicolon
id|ends
(braket
id|cur
op_increment
)braket
op_assign
l_int|0
suffix:semicolon
id|data
op_assign
id|spec-&gt;data
suffix:semicolon
r_while
c_loop
(paren
id|num
OL
id|spec-&gt;size
)paren
(brace
r_if
c_cond
(paren
id|data
(braket
id|num
)braket
op_eq
l_char|&squot;&bslash;n&squot;
op_logical_or
id|num
op_eq
id|spec-&gt;size
l_int|1
)paren
(brace
id|ALLOC_GROW
c_func
(paren
id|ends
comma
(paren
id|cur
op_plus
l_int|1
)paren
comma
id|size
)paren
suffix:semicolon
id|ends
(braket
id|cur
op_increment
)braket
op_assign
id|num
suffix:semicolon
)brace
id|num
op_increment
suffix:semicolon
)brace
multiline_comment|/* shrink the array to fit the elements */
id|ends
op_assign
id|xrealloc
c_func
(paren
id|ends
comma
id|cur
op_star
r_sizeof
(paren
op_star
id|ends
)paren
)paren
suffix:semicolon
op_star
id|lines
op_assign
id|cur
op_minus
l_int|1
suffix:semicolon
op_star
id|line_ends
op_assign
id|ends
suffix:semicolon
)brace
DECL|struct|nth_line_cb
r_struct
id|nth_line_cb
(brace
DECL|member|spec
r_struct
id|diff_filespec
op_star
id|spec
suffix:semicolon
DECL|member|lines
r_int
id|lines
suffix:semicolon
DECL|member|line_ends
r_int
r_int
op_star
id|line_ends
suffix:semicolon
)brace
suffix:semicolon
DECL|function|nth_line
r_static
r_const
r_char
op_star
id|nth_line
c_func
(paren
r_void
op_star
id|data
comma
r_int
id|line
)paren
(brace
r_struct
id|nth_line_cb
op_star
id|d
op_assign
id|data
suffix:semicolon
m_assert
(paren
id|d
op_logical_and
id|line
op_le
id|d-&gt;lines
)paren
suffix:semicolon
m_assert
(paren
id|d-&gt;spec
op_logical_and
id|d-&gt;spec-&gt;data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|line
op_eq
l_int|0
)paren
r_return
(paren
r_char
op_star
)paren
id|d-&gt;spec-&gt;data
suffix:semicolon
r_else
r_return
(paren
r_char
op_star
)paren
id|d-&gt;spec-&gt;data
op_plus
id|d-&gt;line_ends
(braket
id|line
)braket
op_plus
l_int|1
suffix:semicolon
)brace
r_static
r_struct
id|line_log_data
op_star
DECL|function|parse_lines
id|parse_lines
c_func
(paren
r_struct
id|commit
op_star
id|commit
comma
r_const
r_char
op_star
id|prefix
comma
r_struct
id|string_list
op_star
id|args
)paren
(brace
r_int
id|lines
op_assign
l_int|0
suffix:semicolon
r_int
r_int
op_star
id|ends
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|nth_line_cb
id|cb_data
suffix:semicolon
r_struct
id|string_list_item
op_star
id|item
suffix:semicolon
r_struct
id|line_log_data
op_star
id|ranges
op_assign
l_int|NULL
suffix:semicolon
id|for_each_string_list_item
c_func
(paren
id|item
comma
id|args
)paren
(brace
r_const
r_char
op_star
id|name_part
comma
op_star
id|range_part
suffix:semicolon
r_char
op_star
id|full_name
suffix:semicolon
r_struct
id|diff_filespec
op_star
id|spec
suffix:semicolon
r_int
id|begin
op_assign
l_int|0
comma
id|end
op_assign
l_int|0
suffix:semicolon
id|name_part
op_assign
id|skip_range_arg
c_func
(paren
id|item-&gt;string
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|name_part
op_logical_or
op_star
id|name_part
op_ne
l_char|&squot;:&squot;
op_logical_or
op_logical_neg
id|name_part
(braket
l_int|1
)braket
)paren
id|die
c_func
(paren
l_string|&quot;-L argument &squot;%s&squot; not of the form start,end:file&quot;
comma
id|item-&gt;string
)paren
suffix:semicolon
id|range_part
op_assign
id|xstrndup
c_func
(paren
id|item-&gt;string
comma
id|name_part
id|item-&gt;string
)paren
suffix:semicolon
id|name_part
op_increment
suffix:semicolon
id|full_name
op_assign
id|prefix_path
c_func
(paren
id|prefix
comma
id|prefix
ques
c_cond
id|strlen
c_func
(paren
id|prefix
)paren
suffix:colon
l_int|0
comma
id|name_part
)paren
suffix:semicolon
id|spec
op_assign
id|alloc_filespec
c_func
(paren
id|full_name
)paren
suffix:semicolon
id|fill_blob_sha1
c_func
(paren
id|commit
comma
id|spec
)paren
suffix:semicolon
id|fill_line_ends
c_func
(paren
id|spec
comma
op_amp
id|lines
comma
op_amp
id|ends
)paren
suffix:semicolon
id|cb_data.spec
op_assign
id|spec
suffix:semicolon
id|cb_data.lines
op_assign
id|lines
suffix:semicolon
id|cb_data.line_ends
op_assign
id|ends
suffix:semicolon
r_if
c_cond
(paren
id|parse_range_arg
c_func
(paren
id|range_part
comma
id|nth_line
comma
op_amp
id|cb_data
comma
id|lines
comma
op_amp
id|begin
comma
op_amp
id|end
comma
id|full_name
)paren
)paren
id|die
c_func
(paren
l_string|&quot;malformed -L argument &squot;%s&squot;&quot;
comma
id|range_part
)paren
suffix:semicolon
r_if
c_cond
(paren
id|begin
OL
l_int|1
)paren
id|begin
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|end
OL
l_int|1
)paren
id|end
op_assign
id|lines
suffix:semicolon
id|begin
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|lines
OL
id|end
op_logical_or
id|lines
OL
id|begin
)paren
id|die
c_func
(paren
l_string|&quot;file %s has only %ld lines&quot;
comma
id|name_part
comma
id|lines
)paren
suffix:semicolon
id|line_log_data_insert
c_func
(paren
op_amp
id|ranges
comma
id|full_name
comma
id|begin
comma
id|end
)paren
suffix:semicolon
id|free_filespec
c_func
(paren
id|spec
)paren
suffix:semicolon
id|free
c_func
(paren
id|ends
)paren
suffix:semicolon
id|ends
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|ranges
suffix:semicolon
)brace
DECL|function|line_log_data_copy_one
r_static
r_struct
id|line_log_data
op_star
id|line_log_data_copy_one
c_func
(paren
r_struct
id|line_log_data
op_star
id|r
)paren
(brace
r_struct
id|line_log_data
op_star
id|ret
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|ret
)paren
)paren
suffix:semicolon
m_assert
(paren
id|r
)paren
suffix:semicolon
id|line_log_data_init
c_func
(paren
id|ret
)paren
suffix:semicolon
id|range_set_copy
c_func
(paren
op_amp
id|ret-&gt;ranges
comma
op_amp
id|r-&gt;ranges
)paren
suffix:semicolon
id|ret-&gt;path
op_assign
id|xstrdup
c_func
(paren
id|r-&gt;path
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_struct
id|line_log_data
op_star
DECL|function|line_log_data_copy
id|line_log_data_copy
c_func
(paren
r_struct
id|line_log_data
op_star
id|r
)paren
(brace
r_struct
id|line_log_data
op_star
id|ret
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|line_log_data
op_star
id|tmp
op_assign
l_int|NULL
comma
op_star
id|prev
op_assign
l_int|NULL
suffix:semicolon
m_assert
(paren
id|r
)paren
suffix:semicolon
id|ret
op_assign
id|tmp
op_assign
id|prev
op_assign
id|line_log_data_copy_one
c_func
(paren
id|r
)paren
suffix:semicolon
id|r
op_assign
id|r-&gt;next
suffix:semicolon
r_while
c_loop
(paren
id|r
)paren
(brace
id|tmp
op_assign
id|line_log_data_copy_one
c_func
(paren
id|r
)paren
suffix:semicolon
id|prev-&gt;next
op_assign
id|tmp
suffix:semicolon
id|prev
op_assign
id|tmp
suffix:semicolon
id|r
op_assign
id|r-&gt;next
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* merge two range sets across files */
DECL|function|line_log_data_merge
r_static
r_struct
id|line_log_data
op_star
id|line_log_data_merge
c_func
(paren
r_struct
id|line_log_data
op_star
id|a
comma
r_struct
id|line_log_data
op_star
id|b
)paren
(brace
r_struct
id|line_log_data
op_star
id|head
op_assign
l_int|NULL
comma
op_star
op_star
id|pp
op_assign
op_amp
id|head
suffix:semicolon
r_while
c_loop
(paren
id|a
op_logical_or
id|b
)paren
(brace
r_struct
id|line_log_data
op_star
id|src
suffix:semicolon
r_struct
id|line_log_data
op_star
id|src2
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|line_log_data
op_star
id|d
suffix:semicolon
r_int
id|cmp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|a
)paren
id|cmp
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|b
)paren
id|cmp
op_assign
l_int|1
suffix:semicolon
r_else
id|cmp
op_assign
id|strcmp
c_func
(paren
id|a-&gt;path
comma
id|b-&gt;path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmp
OL
l_int|0
)paren
(brace
id|src
op_assign
id|a
suffix:semicolon
id|a
op_assign
id|a-&gt;next
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cmp
op_eq
l_int|0
)paren
(brace
id|src
op_assign
id|a
suffix:semicolon
id|a
op_assign
id|a-&gt;next
suffix:semicolon
id|src2
op_assign
id|b
suffix:semicolon
id|b
op_assign
id|b-&gt;next
suffix:semicolon
)brace
r_else
(brace
id|src
op_assign
id|b
suffix:semicolon
id|b
op_assign
id|b-&gt;next
suffix:semicolon
)brace
id|d
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|line_log_data
)paren
)paren
suffix:semicolon
id|line_log_data_init
c_func
(paren
id|d
)paren
suffix:semicolon
id|d-&gt;path
op_assign
id|xstrdup
c_func
(paren
id|src-&gt;path
)paren
suffix:semicolon
op_star
id|pp
op_assign
id|d
suffix:semicolon
id|pp
op_assign
op_amp
id|d-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|src2
)paren
id|range_set_union
c_func
(paren
op_amp
id|d-&gt;ranges
comma
op_amp
id|src-&gt;ranges
comma
op_amp
id|src2-&gt;ranges
)paren
suffix:semicolon
r_else
id|range_set_copy
c_func
(paren
op_amp
id|d-&gt;ranges
comma
op_amp
id|src-&gt;ranges
)paren
suffix:semicolon
)brace
r_return
id|head
suffix:semicolon
)brace
DECL|function|add_line_range
r_static
r_void
id|add_line_range
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_struct
id|commit
op_star
id|commit
comma
r_struct
id|line_log_data
op_star
id|range
)paren
(brace
r_struct
id|line_log_data
op_star
id|old
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|line_log_data
op_star
r_new
op_assign
l_int|NULL
suffix:semicolon
id|old
op_assign
id|lookup_decoration
c_func
(paren
op_amp
id|revs-&gt;line_log_data
comma
op_amp
id|commit-&gt;object
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old
op_logical_and
id|range
)paren
(brace
r_new
op_assign
id|line_log_data_merge
c_func
(paren
id|old
comma
id|range
)paren
suffix:semicolon
id|free_line_log_data
c_func
(paren
id|old
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|range
)paren
r_new
op_assign
id|line_log_data_copy
c_func
(paren
id|range
)paren
suffix:semicolon
r_if
c_cond
(paren
r_new
)paren
id|add_decoration
c_func
(paren
op_amp
id|revs-&gt;line_log_data
comma
op_amp
id|commit-&gt;object
comma
r_new
)paren
suffix:semicolon
)brace
DECL|function|clear_commit_line_range
r_static
r_void
id|clear_commit_line_range
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_struct
id|line_log_data
op_star
id|r
suffix:semicolon
id|r
op_assign
id|lookup_decoration
c_func
(paren
op_amp
id|revs-&gt;line_log_data
comma
op_amp
id|commit-&gt;object
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|r
)paren
r_return
suffix:semicolon
id|free_line_log_data
c_func
(paren
id|r
)paren
suffix:semicolon
id|add_decoration
c_func
(paren
op_amp
id|revs-&gt;line_log_data
comma
op_amp
id|commit-&gt;object
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|lookup_line_range
r_static
r_struct
id|line_log_data
op_star
id|lookup_line_range
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_struct
id|line_log_data
op_star
id|ret
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|line_log_data
op_star
id|d
suffix:semicolon
id|ret
op_assign
id|lookup_decoration
c_func
(paren
op_amp
id|revs-&gt;line_log_data
comma
op_amp
id|commit-&gt;object
)paren
suffix:semicolon
r_for
c_loop
(paren
id|d
op_assign
id|ret
suffix:semicolon
id|d
suffix:semicolon
id|d
op_assign
id|d-&gt;next
)paren
id|range_set_check_invariants
c_func
(paren
op_amp
id|d-&gt;ranges
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|line_log_init
r_void
id|line_log_init
c_func
(paren
r_struct
id|rev_info
op_star
id|rev
comma
r_const
r_char
op_star
id|prefix
comma
r_struct
id|string_list
op_star
id|args
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|line_log_data
op_star
id|range
suffix:semicolon
id|commit
op_assign
id|check_single_commit
c_func
(paren
id|rev
)paren
suffix:semicolon
id|range
op_assign
id|parse_lines
c_func
(paren
id|commit
comma
id|prefix
comma
id|args
)paren
suffix:semicolon
id|add_line_range
c_func
(paren
id|rev
comma
id|commit
comma
id|range
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rev-&gt;diffopt.detect_rename
)paren
(brace
r_int
id|i
comma
id|count
op_assign
l_int|0
suffix:semicolon
r_struct
id|line_log_data
op_star
id|r
op_assign
id|range
suffix:semicolon
r_const
r_char
op_star
op_star
id|paths
suffix:semicolon
r_while
c_loop
(paren
id|r
)paren
(brace
id|count
op_increment
suffix:semicolon
id|r
op_assign
id|r-&gt;next
suffix:semicolon
)brace
id|paths
op_assign
id|xmalloc
c_func
(paren
(paren
id|count
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
r_char
op_star
)paren
)paren
suffix:semicolon
id|r
op_assign
id|range
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|paths
(braket
id|i
)braket
op_assign
id|xstrdup
c_func
(paren
id|r-&gt;path
)paren
suffix:semicolon
id|r
op_assign
id|r-&gt;next
suffix:semicolon
)brace
id|paths
(braket
id|count
)braket
op_assign
l_int|NULL
suffix:semicolon
id|init_pathspec
c_func
(paren
op_amp
id|rev-&gt;diffopt.pathspec
comma
id|paths
)paren
suffix:semicolon
id|free
c_func
(paren
id|paths
)paren
suffix:semicolon
)brace
)brace
DECL|function|load_tree_desc
r_static
r_void
id|load_tree_desc
c_func
(paren
r_struct
id|tree_desc
op_star
id|desc
comma
r_void
op_star
op_star
id|tree
comma
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_int
r_int
id|size
suffix:semicolon
op_star
id|tree
op_assign
id|read_object_with_reference
c_func
(paren
id|sha1
comma
id|tree_type
comma
op_amp
id|size
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|tree
)paren
id|die
c_func
(paren
l_string|&quot;Unable to read tree (%s)&quot;
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
id|init_tree_desc
c_func
(paren
id|desc
comma
op_star
id|tree
comma
id|size
)paren
suffix:semicolon
)brace
DECL|function|count_parents
r_static
r_int
id|count_parents
c_func
(paren
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_struct
id|commit_list
op_star
id|parents
op_assign
id|commit-&gt;parents
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|parents
)paren
(brace
id|count
op_increment
suffix:semicolon
id|parents
op_assign
id|parents-&gt;next
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
DECL|function|move_diff_queue
r_static
r_void
id|move_diff_queue
c_func
(paren
r_struct
id|diff_queue_struct
op_star
id|dst
comma
r_struct
id|diff_queue_struct
op_star
id|src
)paren
(brace
m_assert
(paren
id|src
op_ne
id|dst
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|dst
comma
id|src
comma
r_sizeof
(paren
r_struct
id|diff_queue_struct
)paren
)paren
suffix:semicolon
id|DIFF_QUEUE_CLEAR
c_func
(paren
id|src
)paren
suffix:semicolon
)brace
DECL|function|filter_diffs_for_paths
r_static
r_void
id|filter_diffs_for_paths
c_func
(paren
r_struct
id|line_log_data
op_star
id|range
comma
r_int
id|keep_deletions
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|diff_queue_struct
id|outq
suffix:semicolon
id|DIFF_QUEUE_CLEAR
c_func
(paren
op_amp
id|outq
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|diff_queued_diff.nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|diff_filepair
op_star
id|p
op_assign
id|diff_queued_diff.queue
(braket
id|i
)braket
suffix:semicolon
r_struct
id|line_log_data
op_star
id|rg
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|DIFF_FILE_VALID
c_func
(paren
id|p-&gt;two
)paren
)paren
(brace
r_if
c_cond
(paren
id|keep_deletions
)paren
id|diff_q
c_func
(paren
op_amp
id|outq
comma
id|p
)paren
suffix:semicolon
r_else
id|diff_free_filepair
c_func
(paren
id|p
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_for
c_loop
(paren
id|rg
op_assign
id|range
suffix:semicolon
id|rg
suffix:semicolon
id|rg
op_assign
id|rg-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|rg-&gt;path
comma
id|p-&gt;two-&gt;path
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rg
)paren
id|diff_q
c_func
(paren
op_amp
id|outq
comma
id|p
)paren
suffix:semicolon
r_else
id|diff_free_filepair
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
id|free
c_func
(paren
id|diff_queued_diff.queue
)paren
suffix:semicolon
id|diff_queued_diff
op_assign
id|outq
suffix:semicolon
)brace
DECL|function|diff_might_be_rename
r_static
r_inline
r_int
id|diff_might_be_rename
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|diff_queued_diff.nr
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|DIFF_FILE_VALID
c_func
(paren
id|diff_queued_diff.queue
(braket
id|i
)braket
op_member_access_from_pointer
id|one
)paren
)paren
(brace
multiline_comment|/* fprintf(stderr, &quot;diff_might_be_rename found creation of: %s&bslash;n&quot;, */
multiline_comment|/* &t;diff_queued_diff.queue[i]-&gt;two-&gt;path); */
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|queue_diffs
r_static
r_void
id|queue_diffs
c_func
(paren
r_struct
id|line_log_data
op_star
id|range
comma
r_struct
id|diff_options
op_star
id|opt
comma
r_struct
id|diff_queue_struct
op_star
id|queue
comma
r_struct
id|commit
op_star
id|commit
comma
r_struct
id|commit
op_star
id|parent
)paren
(brace
r_void
op_star
id|tree1
op_assign
l_int|NULL
comma
op_star
id|tree2
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|tree_desc
id|desc1
comma
id|desc2
suffix:semicolon
m_assert
(paren
id|commit
)paren
suffix:semicolon
id|load_tree_desc
c_func
(paren
op_amp
id|desc2
comma
op_amp
id|tree2
comma
id|commit-&gt;tree-&gt;object.sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parent
)paren
id|load_tree_desc
c_func
(paren
op_amp
id|desc1
comma
op_amp
id|tree1
comma
id|parent-&gt;tree-&gt;object.sha1
)paren
suffix:semicolon
r_else
id|init_tree_desc
c_func
(paren
op_amp
id|desc1
comma
l_string|&quot;&quot;
comma
l_int|0
)paren
suffix:semicolon
id|DIFF_QUEUE_CLEAR
c_func
(paren
op_amp
id|diff_queued_diff
)paren
suffix:semicolon
id|diff_tree
c_func
(paren
op_amp
id|desc1
comma
op_amp
id|desc2
comma
l_string|&quot;&quot;
comma
id|opt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opt-&gt;detect_rename
)paren
(brace
id|filter_diffs_for_paths
c_func
(paren
id|range
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|diff_might_be_rename
c_func
(paren
)paren
)paren
id|diffcore_std
c_func
(paren
id|opt
)paren
suffix:semicolon
id|filter_diffs_for_paths
c_func
(paren
id|range
comma
l_int|0
)paren
suffix:semicolon
)brace
id|move_diff_queue
c_func
(paren
id|queue
comma
op_amp
id|diff_queued_diff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tree1
)paren
id|free
c_func
(paren
id|tree1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tree2
)paren
id|free
c_func
(paren
id|tree2
)paren
suffix:semicolon
)brace
DECL|function|get_nth_line
r_static
r_char
op_star
id|get_nth_line
c_func
(paren
r_int
id|line
comma
r_int
r_int
op_star
id|ends
comma
r_void
op_star
id|data
)paren
(brace
r_if
c_cond
(paren
id|line
op_eq
l_int|0
)paren
r_return
(paren
r_char
op_star
)paren
id|data
suffix:semicolon
r_else
r_return
(paren
r_char
op_star
)paren
id|data
op_plus
id|ends
(braket
id|line
)braket
op_plus
l_int|1
suffix:semicolon
)brace
DECL|function|print_line
r_static
r_void
id|print_line
c_func
(paren
r_const
r_char
op_star
id|prefix
comma
r_char
id|first
comma
r_int
id|line
comma
r_int
r_int
op_star
id|ends
comma
r_void
op_star
id|data
comma
r_const
r_char
op_star
id|color
comma
r_const
r_char
op_star
id|reset
)paren
(brace
r_char
op_star
id|begin
op_assign
id|get_nth_line
c_func
(paren
id|line
comma
id|ends
comma
id|data
)paren
suffix:semicolon
r_char
op_star
id|end
op_assign
id|get_nth_line
c_func
(paren
id|line
op_plus
l_int|1
comma
id|ends
comma
id|data
)paren
suffix:semicolon
r_int
id|had_nl
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|end
OG
id|begin
op_logical_and
id|end
(braket
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|end
op_decrement
suffix:semicolon
id|had_nl
op_assign
l_int|1
suffix:semicolon
)brace
id|fputs
c_func
(paren
id|prefix
comma
id|stdout
)paren
suffix:semicolon
id|fputs
c_func
(paren
id|color
comma
id|stdout
)paren
suffix:semicolon
id|putchar
c_func
(paren
id|first
)paren
suffix:semicolon
id|fwrite
c_func
(paren
id|begin
comma
l_int|1
comma
id|end
op_minus
id|begin
comma
id|stdout
)paren
suffix:semicolon
id|fputs
c_func
(paren
id|reset
comma
id|stdout
)paren
suffix:semicolon
id|putchar
c_func
(paren
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|had_nl
)paren
id|fputs
c_func
(paren
l_string|&quot;&bslash;&bslash; No newline at end of file&bslash;n&quot;
comma
id|stdout
)paren
suffix:semicolon
)brace
DECL|function|output_prefix
r_static
r_char
op_star
id|output_prefix
c_func
(paren
r_struct
id|diff_options
op_star
id|opt
)paren
(brace
r_char
op_star
id|prefix
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_if
c_cond
(paren
id|opt-&gt;output_prefix
)paren
(brace
r_struct
id|strbuf
op_star
id|sb
op_assign
id|opt
op_member_access_from_pointer
id|output_prefix
c_func
(paren
id|opt
comma
id|opt-&gt;output_prefix_data
)paren
suffix:semicolon
id|prefix
op_assign
id|sb-&gt;buf
suffix:semicolon
)brace
r_return
id|prefix
suffix:semicolon
)brace
DECL|function|dump_diff_hacky_one
r_static
r_void
id|dump_diff_hacky_one
c_func
(paren
r_struct
id|rev_info
op_star
id|rev
comma
r_struct
id|line_log_data
op_star
id|range
)paren
(brace
r_int
id|i
comma
id|j
op_assign
l_int|0
suffix:semicolon
r_int
id|p_lines
comma
id|t_lines
suffix:semicolon
r_int
r_int
op_star
id|p_ends
op_assign
l_int|NULL
comma
op_star
id|t_ends
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|diff_filepair
op_star
id|pair
op_assign
id|range-&gt;pair
suffix:semicolon
r_struct
id|diff_ranges
op_star
id|diff
op_assign
op_amp
id|range-&gt;diff
suffix:semicolon
r_struct
id|diff_options
op_star
id|opt
op_assign
op_amp
id|rev-&gt;diffopt
suffix:semicolon
r_char
op_star
id|prefix
op_assign
id|output_prefix
c_func
(paren
id|opt
)paren
suffix:semicolon
r_const
r_char
op_star
id|c_reset
op_assign
id|diff_get_color
c_func
(paren
id|opt-&gt;use_color
comma
id|DIFF_RESET
)paren
suffix:semicolon
r_const
r_char
op_star
id|c_frag
op_assign
id|diff_get_color
c_func
(paren
id|opt-&gt;use_color
comma
id|DIFF_FRAGINFO
)paren
suffix:semicolon
r_const
r_char
op_star
id|c_meta
op_assign
id|diff_get_color
c_func
(paren
id|opt-&gt;use_color
comma
id|DIFF_METAINFO
)paren
suffix:semicolon
r_const
r_char
op_star
id|c_old
op_assign
id|diff_get_color
c_func
(paren
id|opt-&gt;use_color
comma
id|DIFF_FILE_OLD
)paren
suffix:semicolon
r_const
r_char
op_star
id|c_new
op_assign
id|diff_get_color
c_func
(paren
id|opt-&gt;use_color
comma
id|DIFF_FILE_NEW
)paren
suffix:semicolon
r_const
r_char
op_star
id|c_plain
op_assign
id|diff_get_color
c_func
(paren
id|opt-&gt;use_color
comma
id|DIFF_PLAIN
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pair
op_logical_or
op_logical_neg
id|diff
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|pair-&gt;one-&gt;sha1_valid
)paren
id|fill_line_ends
c_func
(paren
id|pair-&gt;one
comma
op_amp
id|p_lines
comma
op_amp
id|p_ends
)paren
suffix:semicolon
id|fill_line_ends
c_func
(paren
id|pair-&gt;two
comma
op_amp
id|t_lines
comma
op_amp
id|t_ends
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s%sdiff --git a/%s b/%s%s&bslash;n&quot;
comma
id|prefix
comma
id|c_meta
comma
id|pair-&gt;one-&gt;path
comma
id|pair-&gt;two-&gt;path
comma
id|c_reset
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s%s--- %s%s%s&bslash;n&quot;
comma
id|prefix
comma
id|c_meta
comma
id|pair-&gt;one-&gt;sha1_valid
ques
c_cond
l_string|&quot;a/&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|pair-&gt;one-&gt;sha1_valid
ques
c_cond
id|pair-&gt;one-&gt;path
suffix:colon
l_string|&quot;/dev/null&quot;
comma
id|c_reset
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s%s+++ b/%s%s&bslash;n&quot;
comma
id|prefix
comma
id|c_meta
comma
id|pair-&gt;two-&gt;path
comma
id|c_reset
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|range-&gt;ranges.nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|p_start
comma
id|p_end
suffix:semicolon
r_int
id|t_start
op_assign
id|range-&gt;ranges.ranges
(braket
id|i
)braket
dot
id|start
suffix:semicolon
r_int
id|t_end
op_assign
id|range-&gt;ranges.ranges
(braket
id|i
)braket
dot
id|end
suffix:semicolon
r_int
id|t_cur
op_assign
id|t_start
suffix:semicolon
r_int
id|j_last
suffix:semicolon
r_while
c_loop
(paren
id|j
OL
id|diff-&gt;target.nr
op_logical_and
id|diff-&gt;target.ranges
(braket
id|j
)braket
dot
id|end
OL
id|t_start
)paren
id|j
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|j
op_eq
id|diff-&gt;target.nr
op_logical_or
id|diff-&gt;target.ranges
(braket
id|j
)braket
dot
id|start
OG
id|t_end
)paren
r_continue
suffix:semicolon
multiline_comment|/* Scan ahead to determine the last diff that falls in this range */
id|j_last
op_assign
id|j
suffix:semicolon
r_while
c_loop
(paren
id|j_last
OL
id|diff-&gt;target.nr
op_logical_and
id|diff-&gt;target.ranges
(braket
id|j_last
)braket
dot
id|start
OL
id|t_end
)paren
id|j_last
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|j_last
OG
id|j
)paren
id|j_last
op_decrement
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Compute parent hunk headers: we know that the diff&n;&t;&t; * has the correct line numbers (but not all hunks).&n;&t;&t; * So it suffices to shift the start/end according to&n;&t;&t; * the line numbers of the first/last hunk(s) that&n;&t;&t; * fall in this range.&n;&t;&t; */
r_if
c_cond
(paren
id|t_start
OL
id|diff-&gt;target.ranges
(braket
id|j
)braket
dot
id|start
)paren
id|p_start
op_assign
id|diff-&gt;parent.ranges
(braket
id|j
)braket
dot
id|start
(paren
id|diff-&gt;target.ranges
(braket
id|j
)braket
dot
id|start
op_minus
id|t_start
)paren
suffix:semicolon
r_else
id|p_start
op_assign
id|diff-&gt;parent.ranges
(braket
id|j
)braket
dot
id|start
suffix:semicolon
r_if
c_cond
(paren
id|t_end
OG
id|diff-&gt;target.ranges
(braket
id|j_last
)braket
dot
id|end
)paren
id|p_end
op_assign
id|diff-&gt;parent.ranges
(braket
id|j_last
)braket
dot
id|end
op_plus
(paren
id|t_end
op_minus
id|diff-&gt;target.ranges
(braket
id|j_last
)braket
dot
id|end
)paren
suffix:semicolon
r_else
id|p_end
op_assign
id|diff-&gt;parent.ranges
(braket
id|j_last
)braket
dot
id|end
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p_start
op_logical_and
op_logical_neg
id|p_end
)paren
(brace
id|p_start
op_assign
l_int|1
suffix:semicolon
id|p_end
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Now output a diff hunk for this range */
id|printf
c_func
(paren
l_string|&quot;%s%s@@ -%ld,%ld +%ld,%ld @@%s&bslash;n&quot;
comma
id|prefix
comma
id|c_frag
comma
id|p_start
op_plus
l_int|1
comma
id|p_end
op_minus
id|p_start
comma
id|t_start
op_plus
l_int|1
comma
id|t_end
op_minus
id|t_start
comma
id|c_reset
)paren
suffix:semicolon
r_while
c_loop
(paren
id|j
OL
id|diff-&gt;target.nr
op_logical_and
id|diff-&gt;target.ranges
(braket
id|j
)braket
dot
id|start
OL
id|t_end
)paren
(brace
r_int
id|k
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|t_cur
OL
id|diff-&gt;target.ranges
(braket
id|j
)braket
dot
id|start
suffix:semicolon
id|t_cur
op_increment
)paren
id|print_line
c_func
(paren
id|prefix
comma
l_char|&squot; &squot;
comma
id|t_cur
comma
id|t_ends
comma
id|pair-&gt;two-&gt;data
comma
id|c_plain
comma
id|c_reset
)paren
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
id|diff-&gt;parent.ranges
(braket
id|j
)braket
dot
id|start
suffix:semicolon
id|k
OL
id|diff-&gt;parent.ranges
(braket
id|j
)braket
dot
id|end
suffix:semicolon
id|k
op_increment
)paren
id|print_line
c_func
(paren
id|prefix
comma
l_char|&squot;-&squot;
comma
id|k
comma
id|p_ends
comma
id|pair-&gt;one-&gt;data
comma
id|c_old
comma
id|c_reset
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|t_cur
OL
id|diff-&gt;target.ranges
(braket
id|j
)braket
dot
id|end
op_logical_and
id|t_cur
OL
id|t_end
suffix:semicolon
id|t_cur
op_increment
)paren
id|print_line
c_func
(paren
id|prefix
comma
l_char|&squot;+&squot;
comma
id|t_cur
comma
id|t_ends
comma
id|pair-&gt;two-&gt;data
comma
id|c_new
comma
id|c_reset
)paren
suffix:semicolon
id|j
op_increment
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
id|t_cur
OL
id|t_end
suffix:semicolon
id|t_cur
op_increment
)paren
id|print_line
c_func
(paren
id|prefix
comma
l_char|&squot; &squot;
comma
id|t_cur
comma
id|t_ends
comma
id|pair-&gt;two-&gt;data
comma
id|c_plain
comma
id|c_reset
)paren
suffix:semicolon
)brace
id|free
c_func
(paren
id|p_ends
)paren
suffix:semicolon
id|free
c_func
(paren
id|t_ends
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NEEDSWORK: manually building a diff here is not the Right&n; * Thing(tm).  log -L should be built into the diff pipeline.&n; */
DECL|function|dump_diff_hacky
r_static
r_void
id|dump_diff_hacky
c_func
(paren
r_struct
id|rev_info
op_star
id|rev
comma
r_struct
id|line_log_data
op_star
id|range
)paren
(brace
id|puts
c_func
(paren
id|output_prefix
c_func
(paren
op_amp
id|rev-&gt;diffopt
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|range
)paren
(brace
id|dump_diff_hacky_one
c_func
(paren
id|rev
comma
id|range
)paren
suffix:semicolon
id|range
op_assign
id|range-&gt;next
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Unlike most other functions, this destructively operates on&n; * &squot;range&squot;.&n; */
DECL|function|process_diff_filepair
r_static
r_int
id|process_diff_filepair
c_func
(paren
r_struct
id|rev_info
op_star
id|rev
comma
r_struct
id|diff_filepair
op_star
id|pair
comma
r_struct
id|line_log_data
op_star
id|range
comma
r_struct
id|diff_ranges
op_star
op_star
id|diff_out
)paren
(brace
r_struct
id|line_log_data
op_star
id|rg
op_assign
id|range
suffix:semicolon
r_struct
id|range_set
id|tmp
suffix:semicolon
r_struct
id|diff_ranges
id|diff
suffix:semicolon
id|mmfile_t
id|file_parent
comma
id|file_target
suffix:semicolon
m_assert
(paren
id|pair-&gt;two-&gt;path
)paren
suffix:semicolon
r_while
c_loop
(paren
id|rg
)paren
(brace
m_assert
(paren
id|rg-&gt;path
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|rg-&gt;path
comma
id|pair-&gt;two-&gt;path
)paren
)paren
r_break
suffix:semicolon
id|rg
op_assign
id|rg-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|rg
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|rg-&gt;ranges.nr
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
m_assert
(paren
id|pair-&gt;two-&gt;sha1_valid
)paren
suffix:semicolon
id|diff_populate_filespec
c_func
(paren
id|pair-&gt;two
comma
l_int|0
)paren
suffix:semicolon
id|file_target.ptr
op_assign
id|pair-&gt;two-&gt;data
suffix:semicolon
id|file_target.size
op_assign
id|pair-&gt;two-&gt;size
suffix:semicolon
r_if
c_cond
(paren
id|pair-&gt;one-&gt;sha1_valid
)paren
(brace
id|diff_populate_filespec
c_func
(paren
id|pair-&gt;one
comma
l_int|0
)paren
suffix:semicolon
id|file_parent.ptr
op_assign
id|pair-&gt;one-&gt;data
suffix:semicolon
id|file_parent.size
op_assign
id|pair-&gt;one-&gt;size
suffix:semicolon
)brace
r_else
(brace
id|file_parent.ptr
op_assign
l_string|&quot;&quot;
suffix:semicolon
id|file_parent.size
op_assign
l_int|0
suffix:semicolon
)brace
id|diff_ranges_init
c_func
(paren
op_amp
id|diff
)paren
suffix:semicolon
id|collect_diff
c_func
(paren
op_amp
id|file_parent
comma
op_amp
id|file_target
comma
op_amp
id|diff
)paren
suffix:semicolon
multiline_comment|/* NEEDSWORK should apply some heuristics to prevent mismatches */
id|free
c_func
(paren
id|rg-&gt;path
)paren
suffix:semicolon
id|rg-&gt;path
op_assign
id|xstrdup
c_func
(paren
id|pair-&gt;one-&gt;path
)paren
suffix:semicolon
id|range_set_init
c_func
(paren
op_amp
id|tmp
comma
l_int|0
)paren
suffix:semicolon
id|range_set_map_across_diff
c_func
(paren
op_amp
id|tmp
comma
op_amp
id|rg-&gt;ranges
comma
op_amp
id|diff
comma
id|diff_out
)paren
suffix:semicolon
id|range_set_release
c_func
(paren
op_amp
id|rg-&gt;ranges
)paren
suffix:semicolon
id|range_set_move
c_func
(paren
op_amp
id|rg-&gt;ranges
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|diff_ranges_release
c_func
(paren
op_amp
id|diff
)paren
suffix:semicolon
r_return
(paren
(paren
op_star
id|diff_out
)paren
op_member_access_from_pointer
id|parent.nr
OG
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|diff_filepair_dup
r_static
r_struct
id|diff_filepair
op_star
id|diff_filepair_dup
c_func
(paren
r_struct
id|diff_filepair
op_star
id|pair
)paren
(brace
r_struct
id|diff_filepair
op_star
r_new
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|diff_filepair
)paren
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|one
op_assign
id|pair-&gt;one
suffix:semicolon
r_new
op_member_access_from_pointer
id|two
op_assign
id|pair-&gt;two
suffix:semicolon
r_new
op_member_access_from_pointer
id|one-&gt;count
op_increment
suffix:semicolon
r_new
op_member_access_from_pointer
id|two-&gt;count
op_increment
suffix:semicolon
r_return
r_new
suffix:semicolon
)brace
DECL|function|free_diffqueues
r_static
r_void
id|free_diffqueues
c_func
(paren
r_int
id|n
comma
r_struct
id|diff_queue_struct
op_star
id|dq
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|dq
(braket
id|i
)braket
dot
id|nr
suffix:semicolon
id|j
op_increment
)paren
id|diff_free_filepair
c_func
(paren
id|dq
(braket
id|i
)braket
dot
id|queue
(braket
id|j
)braket
)paren
suffix:semicolon
id|free
c_func
(paren
id|dq
)paren
suffix:semicolon
)brace
DECL|function|process_all_files
r_static
r_int
id|process_all_files
c_func
(paren
r_struct
id|line_log_data
op_star
op_star
id|range_out
comma
r_struct
id|rev_info
op_star
id|rev
comma
r_struct
id|diff_queue_struct
op_star
id|queue
comma
r_struct
id|line_log_data
op_star
id|range
)paren
(brace
r_int
id|i
comma
id|changed
op_assign
l_int|0
suffix:semicolon
op_star
id|range_out
op_assign
id|line_log_data_copy
c_func
(paren
id|range
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|queue-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|diff_ranges
op_star
id|pairdiff
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|diff_filepair
op_star
id|pair
op_assign
id|queue-&gt;queue
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|process_diff_filepair
c_func
(paren
id|rev
comma
id|pair
comma
op_star
id|range_out
comma
op_amp
id|pairdiff
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Store away the diff for later output.  We&n;&t;&t;&t; * tuck it in the ranges we got as _input_,&n;&t;&t;&t; * since that&squot;s the commit that caused the&n;&t;&t;&t; * diff.&n;&t;&t;&t; *&n;&t;&t;&t; * NEEDSWORK not enough when we get around to&n;&t;&t;&t; * doing something interesting with merges;&n;&t;&t;&t; * currently each invocation on a merge parent&n;&t;&t;&t; * trashes the previous one&squot;s diff.&n;&t;&t;&t; *&n;&t;&t;&t; * NEEDSWORK tramples over data structures not owned here&n;&t;&t;&t; */
r_struct
id|line_log_data
op_star
id|rg
op_assign
id|range
suffix:semicolon
id|changed
op_increment
suffix:semicolon
r_while
c_loop
(paren
id|rg
op_logical_and
id|strcmp
c_func
(paren
id|rg-&gt;path
comma
id|pair-&gt;two-&gt;path
)paren
)paren
id|rg
op_assign
id|rg-&gt;next
suffix:semicolon
m_assert
(paren
id|rg
)paren
suffix:semicolon
id|rg-&gt;pair
op_assign
id|diff_filepair_dup
c_func
(paren
id|queue-&gt;queue
(braket
id|i
)braket
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|rg-&gt;diff
comma
id|pairdiff
comma
r_sizeof
(paren
r_struct
id|diff_ranges
)paren
)paren
suffix:semicolon
)brace
)brace
r_return
id|changed
suffix:semicolon
)brace
DECL|function|line_log_print
r_int
id|line_log_print
c_func
(paren
r_struct
id|rev_info
op_star
id|rev
comma
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_struct
id|line_log_data
op_star
id|range
op_assign
id|lookup_line_range
c_func
(paren
id|rev
comma
id|commit
)paren
suffix:semicolon
id|show_log
c_func
(paren
id|rev
)paren
suffix:semicolon
id|dump_diff_hacky
c_func
(paren
id|rev
comma
id|range
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|process_ranges_ordinary_commit
r_static
r_int
id|process_ranges_ordinary_commit
c_func
(paren
r_struct
id|rev_info
op_star
id|rev
comma
r_struct
id|commit
op_star
id|commit
comma
r_struct
id|line_log_data
op_star
id|range
)paren
(brace
r_struct
id|commit
op_star
id|parent
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|diff_queue_struct
id|queue
suffix:semicolon
r_struct
id|line_log_data
op_star
id|parent_range
suffix:semicolon
r_int
id|changed
suffix:semicolon
r_if
c_cond
(paren
id|commit-&gt;parents
)paren
id|parent
op_assign
id|commit-&gt;parents-&gt;item
suffix:semicolon
id|queue_diffs
c_func
(paren
id|range
comma
op_amp
id|rev-&gt;diffopt
comma
op_amp
id|queue
comma
id|commit
comma
id|parent
)paren
suffix:semicolon
id|changed
op_assign
id|process_all_files
c_func
(paren
op_amp
id|parent_range
comma
id|rev
comma
op_amp
id|queue
comma
id|range
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parent
)paren
id|add_line_range
c_func
(paren
id|rev
comma
id|parent
comma
id|parent_range
)paren
suffix:semicolon
r_return
id|changed
suffix:semicolon
)brace
DECL|function|process_ranges_merge_commit
r_static
r_int
id|process_ranges_merge_commit
c_func
(paren
r_struct
id|rev_info
op_star
id|rev
comma
r_struct
id|commit
op_star
id|commit
comma
r_struct
id|line_log_data
op_star
id|range
)paren
(brace
r_struct
id|diff_queue_struct
op_star
id|diffqueues
suffix:semicolon
r_struct
id|line_log_data
op_star
op_star
id|cand
suffix:semicolon
r_struct
id|commit
op_star
op_star
id|parents
suffix:semicolon
r_struct
id|commit_list
op_star
id|p
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|nparents
op_assign
id|count_parents
c_func
(paren
id|commit
)paren
suffix:semicolon
id|diffqueues
op_assign
id|xmalloc
c_func
(paren
id|nparents
op_star
r_sizeof
(paren
op_star
id|diffqueues
)paren
)paren
suffix:semicolon
id|cand
op_assign
id|xmalloc
c_func
(paren
id|nparents
op_star
r_sizeof
(paren
op_star
id|cand
)paren
)paren
suffix:semicolon
id|parents
op_assign
id|xmalloc
c_func
(paren
id|nparents
op_star
r_sizeof
(paren
op_star
id|parents
)paren
)paren
suffix:semicolon
id|p
op_assign
id|commit-&gt;parents
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nparents
suffix:semicolon
id|i
op_increment
)paren
(brace
id|parents
(braket
id|i
)braket
op_assign
id|p-&gt;item
suffix:semicolon
id|p
op_assign
id|p-&gt;next
suffix:semicolon
id|queue_diffs
c_func
(paren
id|range
comma
op_amp
id|rev-&gt;diffopt
comma
op_amp
id|diffqueues
(braket
id|i
)braket
comma
id|commit
comma
id|parents
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nparents
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|changed
suffix:semicolon
id|cand
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|changed
op_assign
id|process_all_files
c_func
(paren
op_amp
id|cand
(braket
id|i
)braket
comma
id|rev
comma
op_amp
id|diffqueues
(braket
id|i
)braket
comma
id|range
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|changed
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * This parent can take all the blame, so we&n;&t;&t;&t; * don&squot;t follow any other path in history&n;&t;&t;&t; */
id|add_line_range
c_func
(paren
id|rev
comma
id|parents
(braket
id|i
)braket
comma
id|cand
(braket
id|i
)braket
)paren
suffix:semicolon
id|clear_commit_line_range
c_func
(paren
id|rev
comma
id|commit
)paren
suffix:semicolon
id|commit-&gt;parents
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|commit_list
)paren
)paren
suffix:semicolon
id|commit-&gt;parents-&gt;item
op_assign
id|parents
(braket
id|i
)braket
suffix:semicolon
id|commit-&gt;parents-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|free
c_func
(paren
id|parents
)paren
suffix:semicolon
id|free
c_func
(paren
id|cand
)paren
suffix:semicolon
id|free_diffqueues
c_func
(paren
id|nparents
comma
id|diffqueues
)paren
suffix:semicolon
multiline_comment|/* NEEDSWORK leaking like a sieve */
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * No single parent took the blame.  We add the candidates&n;&t; * from the above loop to the parents.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nparents
suffix:semicolon
id|i
op_increment
)paren
(brace
id|add_line_range
c_func
(paren
id|rev
comma
id|parents
(braket
id|i
)braket
comma
id|cand
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|clear_commit_line_range
c_func
(paren
id|rev
comma
id|commit
)paren
suffix:semicolon
id|free
c_func
(paren
id|parents
)paren
suffix:semicolon
id|free
c_func
(paren
id|cand
)paren
suffix:semicolon
id|free_diffqueues
c_func
(paren
id|nparents
comma
id|diffqueues
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* NEEDSWORK evil merge detection stuff */
multiline_comment|/* NEEDSWORK leaking like a sieve */
)brace
DECL|function|process_ranges_arbitrary_commit
r_static
r_int
id|process_ranges_arbitrary_commit
c_func
(paren
r_struct
id|rev_info
op_star
id|rev
comma
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_struct
id|line_log_data
op_star
id|range
op_assign
id|lookup_line_range
c_func
(paren
id|rev
comma
id|commit
)paren
suffix:semicolon
r_int
id|changed
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|range
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|commit-&gt;parents
op_logical_or
op_logical_neg
id|commit-&gt;parents-&gt;next
)paren
id|changed
op_assign
id|process_ranges_ordinary_commit
c_func
(paren
id|rev
comma
id|commit
comma
id|range
)paren
suffix:semicolon
r_else
id|changed
op_assign
id|process_ranges_merge_commit
c_func
(paren
id|rev
comma
id|commit
comma
id|range
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|changed
)paren
id|commit-&gt;object.flags
op_or_assign
id|TREESAME
suffix:semicolon
r_return
id|changed
suffix:semicolon
)brace
DECL|function|line_log_rewrite_one
r_static
r_enum
id|rewrite_result
id|line_log_rewrite_one
c_func
(paren
r_struct
id|rev_info
op_star
id|rev
comma
r_struct
id|commit
op_star
op_star
id|pp
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|commit
op_star
id|p
op_assign
op_star
id|pp
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;parents
op_logical_and
id|p-&gt;parents-&gt;next
)paren
r_return
id|rewrite_one_ok
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;object.flags
op_amp
id|UNINTERESTING
)paren
r_return
id|rewrite_one_ok
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;object.flags
op_amp
id|TREESAME
)paren
)paren
r_return
id|rewrite_one_ok
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;parents
)paren
r_return
id|rewrite_one_noparents
suffix:semicolon
op_star
id|pp
op_assign
id|p-&gt;parents-&gt;item
suffix:semicolon
)brace
)brace
DECL|function|line_log_filter
r_int
id|line_log_filter
c_func
(paren
r_struct
id|rev_info
op_star
id|rev
)paren
(brace
r_struct
id|commit
op_star
id|commit
suffix:semicolon
r_struct
id|commit_list
op_star
id|list
op_assign
id|rev-&gt;commits
suffix:semicolon
r_struct
id|commit_list
op_star
id|out
op_assign
l_int|NULL
comma
op_star
op_star
id|pp
op_assign
op_amp
id|out
suffix:semicolon
r_while
c_loop
(paren
id|list
)paren
(brace
r_struct
id|commit_list
op_star
id|to_free
op_assign
l_int|NULL
suffix:semicolon
id|commit
op_assign
id|list-&gt;item
suffix:semicolon
r_if
c_cond
(paren
id|process_ranges_arbitrary_commit
c_func
(paren
id|rev
comma
id|commit
)paren
)paren
(brace
op_star
id|pp
op_assign
id|list
suffix:semicolon
id|pp
op_assign
op_amp
id|list-&gt;next
suffix:semicolon
)brace
r_else
id|to_free
op_assign
id|list
suffix:semicolon
id|list
op_assign
id|list-&gt;next
suffix:semicolon
id|free
c_func
(paren
id|to_free
)paren
suffix:semicolon
)brace
op_star
id|pp
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|list
op_assign
id|out
suffix:semicolon
id|list
suffix:semicolon
id|list
op_assign
id|list-&gt;next
)paren
id|rewrite_parents
c_func
(paren
id|rev
comma
id|list-&gt;item
comma
id|line_log_rewrite_one
)paren
suffix:semicolon
id|rev-&gt;commits
op_assign
id|out
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
