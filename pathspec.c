macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;dir.h&quot;
macro_line|#include &quot;pathspec.h&quot;
multiline_comment|/*&n; * Finds which of the given pathspecs match items in the index.&n; *&n; * For each pathspec, sets the corresponding entry in the seen[] array&n; * (which should be specs items long, i.e. the same size as pathspec)&n; * to the nature of the &quot;closest&quot; (i.e. most specific) match found for&n; * that pathspec in the index, if it was a closer type of match than&n; * the existing entry.  As an optimization, matching is skipped&n; * altogether if seen[] already only contains non-zero entries.&n; *&n; * If seen[] has not already been written to, it may make sense&n; * to use find_pathspecs_matching_against_index() instead.&n; */
DECL|function|add_pathspec_matches_against_index
r_void
id|add_pathspec_matches_against_index
c_func
(paren
r_const
r_char
op_star
op_star
id|pathspec
comma
r_char
op_star
id|seen
comma
r_int
id|specs
)paren
(brace
r_int
id|num_unmatched
op_assign
l_int|0
comma
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * Since we are walking the index as if we were walking the directory,&n;&t; * we have to mark the matched pathspec as seen; otherwise we will&n;&t; * mistakenly think that the user gave a pathspec that did not match&n;&t; * anything.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|specs
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|seen
(braket
id|i
)braket
)paren
id|num_unmatched
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|num_unmatched
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|active_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_struct
id|cache_entry
op_star
id|ce
op_assign
id|active_cache
(braket
id|i
)braket
suffix:semicolon
id|match_pathspec
c_func
(paren
id|pathspec
comma
id|ce-&gt;name
comma
id|ce_namelen
c_func
(paren
id|ce
)paren
comma
l_int|0
comma
id|seen
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Finds which of the given pathspecs match items in the index.&n; *&n; * This is a one-shot wrapper around add_pathspec_matches_against_index()&n; * which allocates, populates, and returns a seen[] array indicating the&n; * nature of the &quot;closest&quot; (i.e. most specific) matches which each of the&n; * given pathspecs achieves against all items in the index.&n; */
DECL|function|find_pathspecs_matching_against_index
r_char
op_star
id|find_pathspecs_matching_against_index
c_func
(paren
r_const
r_char
op_star
op_star
id|pathspec
)paren
(brace
r_char
op_star
id|seen
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|pathspec
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
suffix:semicolon
multiline_comment|/* just counting */
id|seen
op_assign
id|xcalloc
c_func
(paren
id|i
comma
l_int|1
)paren
suffix:semicolon
id|add_pathspec_matches_against_index
c_func
(paren
id|pathspec
comma
id|seen
comma
id|i
)paren
suffix:semicolon
r_return
id|seen
suffix:semicolon
)brace
multiline_comment|/*&n; * Check the index to see whether path refers to a submodule, or&n; * something inside a submodule.  If the former, returns the path with&n; * any trailing slash stripped.  If the latter, dies with an error&n; * message.&n; */
DECL|function|check_path_for_gitlink
r_const
r_char
op_star
id|check_path_for_gitlink
c_func
(paren
r_const
r_char
op_star
id|path
)paren
(brace
r_int
id|i
comma
id|path_len
op_assign
id|strlen
c_func
(paren
id|path
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|active_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_struct
id|cache_entry
op_star
id|ce
op_assign
id|active_cache
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|S_ISGITLINK
c_func
(paren
id|ce-&gt;ce_mode
)paren
)paren
(brace
r_int
id|ce_len
op_assign
id|ce_namelen
c_func
(paren
id|ce
)paren
suffix:semicolon
r_if
c_cond
(paren
id|path_len
op_le
id|ce_len
op_logical_or
id|path
(braket
id|ce_len
)braket
op_ne
l_char|&squot;/&squot;
op_logical_or
id|memcmp
c_func
(paren
id|ce-&gt;name
comma
id|path
comma
id|ce_len
)paren
)paren
multiline_comment|/* path does not refer to this&n;&t;&t;&t;&t; * submodule or anything inside it */
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|path_len
op_eq
id|ce_len
op_plus
l_int|1
)paren
(brace
multiline_comment|/* path refers to submodule;&n;&t;&t;&t;&t; * strip trailing slash */
r_return
id|xstrndup
c_func
(paren
id|ce-&gt;name
comma
id|ce_len
)paren
suffix:semicolon
)brace
r_else
(brace
id|die
(paren
id|_
c_func
(paren
l_string|&quot;Path &squot;%s&squot; is in submodule &squot;%.*s&squot;&quot;
)paren
comma
id|path
comma
id|ce_len
comma
id|ce-&gt;name
)paren
suffix:semicolon
)brace
)brace
)brace
r_return
id|path
suffix:semicolon
)brace
multiline_comment|/*&n; * Dies if the given path refers to a file inside a symlinked&n; * directory in the index.&n; */
DECL|function|die_if_path_beyond_symlink
r_void
id|die_if_path_beyond_symlink
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_const
r_char
op_star
id|prefix
)paren
(brace
r_if
c_cond
(paren
id|has_symlink_leading_path
c_func
(paren
id|path
comma
id|strlen
c_func
(paren
id|path
)paren
)paren
)paren
(brace
r_int
id|len
op_assign
id|prefix
ques
c_cond
id|strlen
c_func
(paren
id|prefix
)paren
suffix:colon
l_int|0
suffix:semicolon
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;&squot;%s&squot; is beyond a symbolic link&quot;
)paren
comma
id|path
op_plus
id|len
)paren
suffix:semicolon
)brace
)brace
eof
