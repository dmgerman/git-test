multiline_comment|/*&n; * &quot;git rm&quot; builtin command&n; *&n; * Copyright (C) Linus Torvalds 2006&n; */
macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;builtin.h&quot;
macro_line|#include &quot;dir.h&quot;
DECL|variable|builtin_rm_usage
r_static
r_const
r_char
id|builtin_rm_usage
(braket
)braket
op_assign
l_string|&quot;git-rm [-n] [-v] [-f] &lt;filepattern&gt;...&quot;
suffix:semicolon
r_static
r_struct
(brace
DECL|member|nr
DECL|member|alloc
r_int
id|nr
comma
id|alloc
suffix:semicolon
DECL|member|name
r_const
r_char
op_star
op_star
id|name
suffix:semicolon
DECL|variable|list
)brace
id|list
suffix:semicolon
DECL|function|add_list
r_static
r_void
id|add_list
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_if
c_cond
(paren
id|list.nr
op_ge
id|list.alloc
)paren
(brace
id|list.alloc
op_assign
id|alloc_nr
c_func
(paren
id|list.alloc
)paren
suffix:semicolon
id|list.name
op_assign
id|xrealloc
c_func
(paren
id|list.name
comma
id|list.alloc
op_star
r_sizeof
(paren
r_const
r_char
op_star
)paren
)paren
suffix:semicolon
)brace
id|list.name
(braket
id|list.nr
op_increment
)braket
op_assign
id|name
suffix:semicolon
)brace
DECL|function|remove_file
r_static
r_int
id|remove_file
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_int
id|ret
suffix:semicolon
r_char
op_star
id|slash
suffix:semicolon
id|ret
op_assign
id|unlink
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
op_logical_and
(paren
id|slash
op_assign
id|strrchr
c_func
(paren
id|name
comma
l_char|&squot;/&squot;
)paren
)paren
)paren
(brace
r_char
op_star
id|n
op_assign
id|strdup
c_func
(paren
id|name
)paren
suffix:semicolon
r_do
(brace
id|n
(braket
id|slash
id|name
)braket
op_assign
l_int|0
suffix:semicolon
id|name
op_assign
id|n
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|rmdir
c_func
(paren
id|name
)paren
op_logical_and
(paren
id|slash
op_assign
id|strrchr
c_func
(paren
id|name
comma
l_char|&squot;/&squot;
)paren
)paren
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|cache_file
r_static
r_struct
id|cache_file
id|cache_file
suffix:semicolon
DECL|function|cmd_rm
r_int
id|cmd_rm
c_func
(paren
r_int
id|argc
comma
r_const
r_char
op_star
op_star
id|argv
comma
r_char
op_star
op_star
id|envp
)paren
(brace
r_int
id|i
comma
id|newfd
suffix:semicolon
r_int
id|verbose
op_assign
l_int|0
comma
id|show_only
op_assign
l_int|0
comma
id|force
op_assign
l_int|0
suffix:semicolon
r_const
r_char
op_star
id|prefix
op_assign
id|setup_git_directory
c_func
(paren
)paren
suffix:semicolon
r_const
r_char
op_star
op_star
id|pathspec
suffix:semicolon
r_char
op_star
id|seen
suffix:semicolon
id|git_config
c_func
(paren
id|git_default_config
)paren
suffix:semicolon
id|newfd
op_assign
id|hold_index_file_for_update
c_func
(paren
op_amp
id|cache_file
comma
id|get_index_file
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newfd
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;unable to create new index file&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_cache
c_func
(paren
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;index file corrupt&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|argc
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_char
op_star
id|arg
op_assign
id|argv
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_star
id|arg
op_ne
l_char|&squot;-&squot;
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--&quot;
)paren
)paren
(brace
id|i
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;-n&quot;
)paren
)paren
(brace
id|show_only
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;-v&quot;
)paren
)paren
(brace
id|verbose
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;-f&quot;
)paren
)paren
(brace
id|force
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|die
c_func
(paren
id|builtin_rm_usage
)paren
suffix:semicolon
)brace
id|pathspec
op_assign
id|get_pathspec
c_func
(paren
id|prefix
comma
id|argv
op_plus
id|i
)paren
suffix:semicolon
id|seen
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|pathspec
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|pathspec
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
multiline_comment|/* nothing */
suffix:semicolon
id|seen
op_assign
id|xmalloc
c_func
(paren
id|i
)paren
suffix:semicolon
id|memset
c_func
(paren
id|seen
comma
l_int|0
comma
id|i
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|active_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|cache_entry
op_star
id|ce
op_assign
id|active_cache
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|match_pathspec
c_func
(paren
id|pathspec
comma
id|ce-&gt;name
comma
id|ce_namelen
c_func
(paren
id|ce
)paren
comma
l_int|0
comma
id|seen
)paren
)paren
r_continue
suffix:semicolon
id|add_list
c_func
(paren
id|ce-&gt;name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pathspec
)paren
(brace
r_const
r_char
op_star
id|match
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|match
op_assign
id|pathspec
(braket
id|i
)braket
)paren
op_ne
l_int|NULL
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_star
id|match
op_logical_and
op_logical_neg
id|seen
(braket
id|i
)braket
)paren
id|die
c_func
(paren
l_string|&quot;pathspec &squot;%s&squot; did not match any files&quot;
comma
id|match
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * First remove the names from the index: we won&squot;t commit&n;&t; * the index unless all of them succeed&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|list.nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_char
op_star
id|path
op_assign
id|list.name
(braket
id|i
)braket
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;rm &squot;%s&squot;&bslash;n&quot;
comma
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|remove_file_from_cache
c_func
(paren
id|path
)paren
)paren
id|die
c_func
(paren
l_string|&quot;git rm: unable to remove %s&quot;
comma
id|path
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Then, if we used &quot;-f&quot;, remove the filenames from the&n;&t; * workspace. If we fail to remove the first one, we&n;&t; * abort the &quot;git rm&quot; (but once we&squot;ve successfully removed&n;&t; * any file at all, we&squot;ll go ahead and commit to it all:&n;&t; * by then we&squot;ve already committed ourself and can&squot;t fail&n;&t; * in the middle)&n;&t; */
r_if
c_cond
(paren
id|force
)paren
(brace
r_int
id|removed
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|list.nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_char
op_star
id|path
op_assign
id|list.name
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|remove_file
c_func
(paren
id|path
)paren
)paren
(brace
id|removed
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|removed
)paren
id|die
c_func
(paren
l_string|&quot;git rm: %s: %s&quot;
comma
id|path
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|active_cache_changed
)paren
(brace
r_if
c_cond
(paren
id|write_cache
c_func
(paren
id|newfd
comma
id|active_cache
comma
id|active_nr
)paren
op_logical_or
id|commit_index_file
c_func
(paren
op_amp
id|cache_file
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Unable to write new index file&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
