macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;commit.h&quot;
macro_line|#include &quot;tag.h&quot;
macro_line|#include &quot;diff.h&quot;
macro_line|#include &quot;revision.h&quot;
macro_line|#include &quot;progress.h&quot;
macro_line|#include &quot;list-objects.h&quot;
macro_line|#include &quot;pack.h&quot;
macro_line|#include &quot;pack-bitmap.h&quot;
macro_line|#include &quot;pack-revindex.h&quot;
macro_line|#include &quot;pack-objects.h&quot;
multiline_comment|/*&n; * An entry on the bitmap index, representing the bitmap for a given&n; * commit.&n; */
DECL|struct|stored_bitmap
r_struct
id|stored_bitmap
(brace
DECL|member|sha1
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
DECL|member|root
r_struct
id|ewah_bitmap
op_star
id|root
suffix:semicolon
DECL|member|xor
r_struct
id|stored_bitmap
op_star
op_xor
suffix:semicolon
DECL|member|flags
r_int
id|flags
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * The currently active bitmap index. By design, repositories only have&n; * a single bitmap index available (the index for the biggest packfile in&n; * the repository), since bitmap indexes need full closure.&n; *&n; * If there is more than one bitmap index available (e.g. because of alternates),&n; * the active bitmap index is the largest one.&n; */
DECL|struct|bitmap_index
r_static
r_struct
id|bitmap_index
(brace
multiline_comment|/* Packfile to which this bitmap index belongs to */
DECL|member|pack
r_struct
id|packed_git
op_star
id|pack
suffix:semicolon
multiline_comment|/* reverse index for the packfile */
DECL|member|reverse_index
r_struct
id|pack_revindex
op_star
id|reverse_index
suffix:semicolon
multiline_comment|/*&n;&t; * Mark the first `reuse_objects` in the packfile as reused:&n;&t; * they will be sent as-is without using them for repacking&n;&t; * calculations&n;&t; */
DECL|member|reuse_objects
r_uint32
id|reuse_objects
suffix:semicolon
multiline_comment|/* mmapped buffer of the whole bitmap index */
DECL|member|map
r_int
r_char
op_star
id|map
suffix:semicolon
DECL|member|map_size
r_int
id|map_size
suffix:semicolon
multiline_comment|/* size of the mmaped buffer */
DECL|member|map_pos
r_int
id|map_pos
suffix:semicolon
multiline_comment|/* current position when loading the index */
multiline_comment|/*&n;&t; * Type indexes.&n;&t; *&n;&t; * Each bitmap marks which objects in the packfile  are of the given&n;&t; * type. This provides type information when yielding the objects from&n;&t; * the packfile during a walk, which allows for better delta bases.&n;&t; */
DECL|member|commits
r_struct
id|ewah_bitmap
op_star
id|commits
suffix:semicolon
DECL|member|trees
r_struct
id|ewah_bitmap
op_star
id|trees
suffix:semicolon
DECL|member|blobs
r_struct
id|ewah_bitmap
op_star
id|blobs
suffix:semicolon
DECL|member|tags
r_struct
id|ewah_bitmap
op_star
id|tags
suffix:semicolon
multiline_comment|/* Map from SHA1 -&gt; `stored_bitmap` for all the bitmapped commits */
DECL|member|bitmaps
id|khash_sha1
op_star
id|bitmaps
suffix:semicolon
multiline_comment|/* Number of bitmapped commits */
DECL|member|entry_count
r_uint32
id|entry_count
suffix:semicolon
multiline_comment|/* Name-hash cache (or NULL if not present). */
DECL|member|hashes
r_uint32
op_star
id|hashes
suffix:semicolon
multiline_comment|/*&n;&t; * Extended index.&n;&t; *&n;&t; * When trying to perform bitmap operations with objects that are not&n;&t; * packed in `pack`, these objects are added to this &quot;fake index&quot; and&n;&t; * are assumed to appear at the end of the packfile for all operations&n;&t; */
DECL|struct|eindex
r_struct
id|eindex
(brace
DECL|member|objects
r_struct
id|object
op_star
op_star
id|objects
suffix:semicolon
DECL|member|hashes
r_uint32
op_star
id|hashes
suffix:semicolon
DECL|member|count
DECL|member|alloc
r_uint32
id|count
comma
id|alloc
suffix:semicolon
DECL|member|positions
id|khash_sha1_pos
op_star
id|positions
suffix:semicolon
DECL|member|ext_index
)brace
id|ext_index
suffix:semicolon
multiline_comment|/* Bitmap result of the last performed walk */
DECL|member|result
r_struct
id|bitmap
op_star
id|result
suffix:semicolon
multiline_comment|/* Version of the bitmap index */
DECL|member|version
r_int
r_int
id|version
suffix:semicolon
DECL|member|loaded
r_int
id|loaded
suffix:colon
l_int|1
suffix:semicolon
DECL|variable|bitmap_git
)brace
id|bitmap_git
suffix:semicolon
DECL|function|lookup_stored_bitmap
r_static
r_struct
id|ewah_bitmap
op_star
id|lookup_stored_bitmap
c_func
(paren
r_struct
id|stored_bitmap
op_star
id|st
)paren
(brace
r_struct
id|ewah_bitmap
op_star
id|parent
suffix:semicolon
r_struct
id|ewah_bitmap
op_star
id|composed
suffix:semicolon
r_if
c_cond
(paren
id|st
op_member_access_from_pointer
op_xor
op_eq
l_int|NULL
)paren
r_return
id|st-&gt;root
suffix:semicolon
id|composed
op_assign
id|ewah_pool_new
c_func
(paren
)paren
suffix:semicolon
id|parent
op_assign
id|lookup_stored_bitmap
c_func
(paren
id|st
op_member_access_from_pointer
op_xor
)paren
suffix:semicolon
id|ewah_xor
c_func
(paren
id|st-&gt;root
comma
id|parent
comma
id|composed
)paren
suffix:semicolon
id|ewah_pool_free
c_func
(paren
id|st-&gt;root
)paren
suffix:semicolon
id|st-&gt;root
op_assign
id|composed
suffix:semicolon
id|st
op_member_access_from_pointer
op_xor
op_assign
l_int|NULL
suffix:semicolon
r_return
id|composed
suffix:semicolon
)brace
multiline_comment|/*&n; * Read a bitmap from the current read position on the mmaped&n; * index, and increase the read position accordingly&n; */
DECL|function|read_bitmap_1
r_static
r_struct
id|ewah_bitmap
op_star
id|read_bitmap_1
c_func
(paren
r_struct
id|bitmap_index
op_star
id|index
)paren
(brace
r_struct
id|ewah_bitmap
op_star
id|b
op_assign
id|ewah_pool_new
c_func
(paren
)paren
suffix:semicolon
r_int
id|bitmap_size
op_assign
id|ewah_read_mmap
c_func
(paren
id|b
comma
id|index-&gt;map
op_plus
id|index-&gt;map_pos
comma
id|index-&gt;map_size
id|index-&gt;map_pos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bitmap_size
OL
l_int|0
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Failed to load bitmap index (corrupted?)&quot;
)paren
suffix:semicolon
id|ewah_pool_free
c_func
(paren
id|b
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|index-&gt;map_pos
op_add_assign
id|bitmap_size
suffix:semicolon
r_return
id|b
suffix:semicolon
)brace
DECL|function|load_bitmap_header
r_static
r_int
id|load_bitmap_header
c_func
(paren
r_struct
id|bitmap_index
op_star
id|index
)paren
(brace
r_struct
id|bitmap_disk_header
op_star
id|header
op_assign
(paren
r_void
op_star
)paren
id|index-&gt;map
suffix:semicolon
r_if
c_cond
(paren
id|index-&gt;map_size
OL
r_sizeof
(paren
op_star
id|header
)paren
op_plus
l_int|20
)paren
r_return
id|error
c_func
(paren
l_string|&quot;Corrupted bitmap index (missing header data)&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|header-&gt;magic
comma
id|BITMAP_IDX_SIGNATURE
comma
r_sizeof
(paren
id|BITMAP_IDX_SIGNATURE
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|error
c_func
(paren
l_string|&quot;Corrupted bitmap index file (wrong header)&quot;
)paren
suffix:semicolon
id|index-&gt;version
op_assign
id|ntohs
c_func
(paren
id|header-&gt;version
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index-&gt;version
op_ne
l_int|1
)paren
r_return
id|error
c_func
(paren
l_string|&quot;Unsupported version for bitmap index file (%d)&quot;
comma
id|index-&gt;version
)paren
suffix:semicolon
multiline_comment|/* Parse known bitmap format options */
(brace
r_uint32
id|flags
op_assign
id|ntohs
c_func
(paren
id|header-&gt;options
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|BITMAP_OPT_FULL_DAG
)paren
op_eq
l_int|0
)paren
r_return
id|error
c_func
(paren
l_string|&quot;Unsupported options for bitmap index file &quot;
l_string|&quot;(Git requires BITMAP_OPT_FULL_DAG)&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|BITMAP_OPT_HASH_CACHE
)paren
(brace
r_int
r_char
op_star
id|end
op_assign
id|index-&gt;map
op_plus
id|index-&gt;map_size
l_int|20
suffix:semicolon
id|index-&gt;hashes
op_assign
(paren
(paren
r_uint32
op_star
)paren
id|end
)paren
id|index-&gt;pack-&gt;num_objects
suffix:semicolon
)brace
)brace
id|index-&gt;entry_count
op_assign
id|ntohl
c_func
(paren
id|header-&gt;entry_count
)paren
suffix:semicolon
id|index-&gt;map_pos
op_add_assign
r_sizeof
(paren
op_star
id|header
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|store_bitmap
r_static
r_struct
id|stored_bitmap
op_star
id|store_bitmap
c_func
(paren
r_struct
id|bitmap_index
op_star
id|index
comma
r_struct
id|ewah_bitmap
op_star
id|root
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_struct
id|stored_bitmap
op_star
id|xor_with
comma
r_int
id|flags
)paren
(brace
r_struct
id|stored_bitmap
op_star
id|stored
suffix:semicolon
id|khiter_t
id|hash_pos
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|stored
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|stored_bitmap
)paren
)paren
suffix:semicolon
id|stored-&gt;root
op_assign
id|root
suffix:semicolon
id|stored
op_member_access_from_pointer
op_xor
op_assign
id|xor_with
suffix:semicolon
id|stored-&gt;flags
op_assign
id|flags
suffix:semicolon
id|hashcpy
c_func
(paren
id|stored-&gt;sha1
comma
id|sha1
)paren
suffix:semicolon
id|hash_pos
op_assign
id|kh_put_sha1
c_func
(paren
id|index-&gt;bitmaps
comma
id|stored-&gt;sha1
comma
op_amp
id|ret
)paren
suffix:semicolon
multiline_comment|/* a 0 return code means the insertion succeeded with no changes,&n;&t; * because the SHA1 already existed on the map. this is bad, there&n;&t; * shouldn&squot;t be duplicated commits in the index */
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Duplicate entry in bitmap index: %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|kh_value
c_func
(paren
id|index-&gt;bitmaps
comma
id|hash_pos
)paren
op_assign
id|stored
suffix:semicolon
r_return
id|stored
suffix:semicolon
)brace
DECL|function|read_be32
r_static
r_inline
r_uint32
id|read_be32
c_func
(paren
r_const
r_int
r_char
op_star
id|buffer
comma
r_int
op_star
id|pos
)paren
(brace
r_uint32
id|result
op_assign
id|get_be32
c_func
(paren
id|buffer
op_plus
op_star
id|pos
)paren
suffix:semicolon
(paren
op_star
id|pos
)paren
op_add_assign
r_sizeof
(paren
id|result
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|read_u8
r_static
r_inline
r_uint8
id|read_u8
c_func
(paren
r_const
r_int
r_char
op_star
id|buffer
comma
r_int
op_star
id|pos
)paren
(brace
r_return
id|buffer
(braket
(paren
op_star
id|pos
)paren
op_increment
)braket
suffix:semicolon
)brace
DECL|macro|MAX_XOR_OFFSET
mdefine_line|#define MAX_XOR_OFFSET 160
DECL|function|load_bitmap_entries_v1
r_static
r_int
id|load_bitmap_entries_v1
c_func
(paren
r_struct
id|bitmap_index
op_star
id|index
)paren
(brace
r_uint32
id|i
suffix:semicolon
r_struct
id|stored_bitmap
op_star
id|recent_bitmaps
(braket
id|MAX_XOR_OFFSET
)braket
op_assign
(brace
l_int|NULL
)brace
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|index-&gt;entry_count
suffix:semicolon
op_increment
id|i
)paren
(brace
r_int
id|xor_offset
comma
id|flags
suffix:semicolon
r_struct
id|ewah_bitmap
op_star
id|bitmap
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|stored_bitmap
op_star
id|xor_bitmap
op_assign
l_int|NULL
suffix:semicolon
r_uint32
id|commit_idx_pos
suffix:semicolon
r_const
r_int
r_char
op_star
id|sha1
suffix:semicolon
id|commit_idx_pos
op_assign
id|read_be32
c_func
(paren
id|index-&gt;map
comma
op_amp
id|index-&gt;map_pos
)paren
suffix:semicolon
id|xor_offset
op_assign
id|read_u8
c_func
(paren
id|index-&gt;map
comma
op_amp
id|index-&gt;map_pos
)paren
suffix:semicolon
id|flags
op_assign
id|read_u8
c_func
(paren
id|index-&gt;map
comma
op_amp
id|index-&gt;map_pos
)paren
suffix:semicolon
id|sha1
op_assign
id|nth_packed_object_sha1
c_func
(paren
id|index-&gt;pack
comma
id|commit_idx_pos
)paren
suffix:semicolon
id|bitmap
op_assign
id|read_bitmap_1
c_func
(paren
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bitmap
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|xor_offset
OG
id|MAX_XOR_OFFSET
op_logical_or
id|xor_offset
OG
id|i
)paren
r_return
id|error
c_func
(paren
l_string|&quot;Corrupted bitmap pack index&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xor_offset
OG
l_int|0
)paren
(brace
id|xor_bitmap
op_assign
id|recent_bitmaps
(braket
(paren
id|i
id|xor_offset
)paren
op_mod
id|MAX_XOR_OFFSET
)braket
suffix:semicolon
r_if
c_cond
(paren
id|xor_bitmap
op_eq
l_int|NULL
)paren
r_return
id|error
c_func
(paren
l_string|&quot;Invalid XOR offset in bitmap pack index&quot;
)paren
suffix:semicolon
)brace
id|recent_bitmaps
(braket
id|i
op_mod
id|MAX_XOR_OFFSET
)braket
op_assign
id|store_bitmap
c_func
(paren
id|index
comma
id|bitmap
comma
id|sha1
comma
id|xor_bitmap
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pack_bitmap_filename
r_static
r_char
op_star
id|pack_bitmap_filename
c_func
(paren
r_struct
id|packed_git
op_star
id|p
)paren
(brace
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strip_suffix
c_func
(paren
id|p-&gt;pack_name
comma
l_string|&quot;.pack&quot;
comma
op_amp
id|len
)paren
)paren
id|die
c_func
(paren
l_string|&quot;BUG: pack_name does not end in .pack&quot;
)paren
suffix:semicolon
r_return
id|xstrfmt
c_func
(paren
l_string|&quot;%.*s.bitmap&quot;
comma
(paren
r_int
)paren
id|len
comma
id|p-&gt;pack_name
)paren
suffix:semicolon
)brace
DECL|function|open_pack_bitmap_1
r_static
r_int
id|open_pack_bitmap_1
c_func
(paren
r_struct
id|packed_git
op_star
id|packfile
)paren
(brace
r_int
id|fd
suffix:semicolon
r_struct
id|stat
id|st
suffix:semicolon
r_char
op_star
id|idx_name
suffix:semicolon
r_if
c_cond
(paren
id|open_pack_index
c_func
(paren
id|packfile
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|idx_name
op_assign
id|pack_bitmap_filename
c_func
(paren
id|packfile
)paren
suffix:semicolon
id|fd
op_assign
id|git_open_noatime
c_func
(paren
id|idx_name
)paren
suffix:semicolon
id|free
c_func
(paren
id|idx_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|fstat
c_func
(paren
id|fd
comma
op_amp
id|st
)paren
)paren
(brace
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bitmap_git.pack
)paren
(brace
id|warning
c_func
(paren
l_string|&quot;ignoring extra bitmap file: %s&quot;
comma
id|packfile-&gt;pack_name
)paren
suffix:semicolon
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|bitmap_git.pack
op_assign
id|packfile
suffix:semicolon
id|bitmap_git.map_size
op_assign
id|xsize_t
c_func
(paren
id|st.st_size
)paren
suffix:semicolon
id|bitmap_git.map
op_assign
id|xmmap
c_func
(paren
l_int|NULL
comma
id|bitmap_git.map_size
comma
id|PROT_READ
comma
id|MAP_PRIVATE
comma
id|fd
comma
l_int|0
)paren
suffix:semicolon
id|bitmap_git.map_pos
op_assign
l_int|0
suffix:semicolon
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|load_bitmap_header
c_func
(paren
op_amp
id|bitmap_git
)paren
OL
l_int|0
)paren
(brace
id|munmap
c_func
(paren
id|bitmap_git.map
comma
id|bitmap_git.map_size
)paren
suffix:semicolon
id|bitmap_git.map
op_assign
l_int|NULL
suffix:semicolon
id|bitmap_git.map_size
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|load_pack_bitmap
r_static
r_int
id|load_pack_bitmap
c_func
(paren
r_void
)paren
(brace
m_assert
(paren
id|bitmap_git.map
op_logical_and
op_logical_neg
id|bitmap_git.loaded
)paren
suffix:semicolon
id|bitmap_git.bitmaps
op_assign
id|kh_init_sha1
c_func
(paren
)paren
suffix:semicolon
id|bitmap_git.ext_index.positions
op_assign
id|kh_init_sha1_pos
c_func
(paren
)paren
suffix:semicolon
id|bitmap_git.reverse_index
op_assign
id|revindex_for_pack
c_func
(paren
id|bitmap_git.pack
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|bitmap_git.commits
op_assign
id|read_bitmap_1
c_func
(paren
op_amp
id|bitmap_git
)paren
)paren
op_logical_or
op_logical_neg
(paren
id|bitmap_git.trees
op_assign
id|read_bitmap_1
c_func
(paren
op_amp
id|bitmap_git
)paren
)paren
op_logical_or
op_logical_neg
(paren
id|bitmap_git.blobs
op_assign
id|read_bitmap_1
c_func
(paren
op_amp
id|bitmap_git
)paren
)paren
op_logical_or
op_logical_neg
(paren
id|bitmap_git.tags
op_assign
id|read_bitmap_1
c_func
(paren
op_amp
id|bitmap_git
)paren
)paren
)paren
r_goto
id|failed
suffix:semicolon
r_if
c_cond
(paren
id|load_bitmap_entries_v1
c_func
(paren
op_amp
id|bitmap_git
)paren
OL
l_int|0
)paren
r_goto
id|failed
suffix:semicolon
id|bitmap_git.loaded
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|failed
suffix:colon
id|munmap
c_func
(paren
id|bitmap_git.map
comma
id|bitmap_git.map_size
)paren
suffix:semicolon
id|bitmap_git.map
op_assign
l_int|NULL
suffix:semicolon
id|bitmap_git.map_size
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|open_pack_bitmap
r_static
r_int
id|open_pack_bitmap
c_func
(paren
r_void
)paren
(brace
r_struct
id|packed_git
op_star
id|p
suffix:semicolon
r_int
id|ret
op_assign
l_int|1
suffix:semicolon
m_assert
(paren
op_logical_neg
id|bitmap_git.map
op_logical_and
op_logical_neg
id|bitmap_git.loaded
)paren
suffix:semicolon
id|prepare_packed_git
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|packed_git
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|open_pack_bitmap_1
c_func
(paren
id|p
)paren
op_eq
l_int|0
)paren
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|prepare_bitmap_git
r_int
id|prepare_bitmap_git
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|bitmap_git.loaded
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|open_pack_bitmap
c_func
(paren
)paren
)paren
r_return
id|load_pack_bitmap
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|struct|include_data
r_struct
id|include_data
(brace
DECL|member|base
r_struct
id|bitmap
op_star
id|base
suffix:semicolon
DECL|member|seen
r_struct
id|bitmap
op_star
id|seen
suffix:semicolon
)brace
suffix:semicolon
DECL|function|bitmap_position_extended
r_static
r_inline
r_int
id|bitmap_position_extended
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
id|khash_sha1_pos
op_star
id|positions
op_assign
id|bitmap_git.ext_index.positions
suffix:semicolon
id|khiter_t
id|pos
op_assign
id|kh_get_sha1_pos
c_func
(paren
id|positions
comma
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
id|kh_end
c_func
(paren
id|positions
)paren
)paren
(brace
r_int
id|bitmap_pos
op_assign
id|kh_value
c_func
(paren
id|positions
comma
id|pos
)paren
suffix:semicolon
r_return
id|bitmap_pos
op_plus
id|bitmap_git.pack-&gt;num_objects
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|bitmap_position_packfile
r_static
r_inline
r_int
id|bitmap_position_packfile
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
id|off_t
id|offset
op_assign
id|find_pack_entry_one
c_func
(paren
id|sha1
comma
id|bitmap_git.pack
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|offset
)paren
r_return
l_int|1
suffix:semicolon
r_return
id|find_revindex_position
c_func
(paren
id|bitmap_git.reverse_index
comma
id|offset
)paren
suffix:semicolon
)brace
DECL|function|bitmap_position
r_static
r_int
id|bitmap_position
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_int
id|pos
op_assign
id|bitmap_position_packfile
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_return
(paren
id|pos
op_ge
l_int|0
)paren
ques
c_cond
id|pos
suffix:colon
id|bitmap_position_extended
c_func
(paren
id|sha1
)paren
suffix:semicolon
)brace
DECL|function|ext_index_add_object
r_static
r_int
id|ext_index_add_object
c_func
(paren
r_struct
id|object
op_star
id|object
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|eindex
op_star
id|eindex
op_assign
op_amp
id|bitmap_git.ext_index
suffix:semicolon
id|khiter_t
id|hash_pos
suffix:semicolon
r_int
id|hash_ret
suffix:semicolon
r_int
id|bitmap_pos
suffix:semicolon
id|hash_pos
op_assign
id|kh_put_sha1_pos
c_func
(paren
id|eindex-&gt;positions
comma
id|object-&gt;oid.hash
comma
op_amp
id|hash_ret
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hash_ret
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|eindex-&gt;count
op_ge
id|eindex-&gt;alloc
)paren
(brace
id|eindex-&gt;alloc
op_assign
(paren
id|eindex-&gt;alloc
op_plus
l_int|16
)paren
op_star
l_int|3
op_div
l_int|2
suffix:semicolon
id|REALLOC_ARRAY
c_func
(paren
id|eindex-&gt;objects
comma
id|eindex-&gt;alloc
)paren
suffix:semicolon
id|REALLOC_ARRAY
c_func
(paren
id|eindex-&gt;hashes
comma
id|eindex-&gt;alloc
)paren
suffix:semicolon
)brace
id|bitmap_pos
op_assign
id|eindex-&gt;count
suffix:semicolon
id|eindex-&gt;objects
(braket
id|eindex-&gt;count
)braket
op_assign
id|object
suffix:semicolon
id|eindex-&gt;hashes
(braket
id|eindex-&gt;count
)braket
op_assign
id|pack_name_hash
c_func
(paren
id|name
)paren
suffix:semicolon
id|kh_value
c_func
(paren
id|eindex-&gt;positions
comma
id|hash_pos
)paren
op_assign
id|bitmap_pos
suffix:semicolon
id|eindex-&gt;count
op_increment
suffix:semicolon
)brace
r_else
(brace
id|bitmap_pos
op_assign
id|kh_value
c_func
(paren
id|eindex-&gt;positions
comma
id|hash_pos
)paren
suffix:semicolon
)brace
r_return
id|bitmap_pos
op_plus
id|bitmap_git.pack-&gt;num_objects
suffix:semicolon
)brace
DECL|function|show_object
r_static
r_void
id|show_object
c_func
(paren
r_struct
id|object
op_star
id|object
comma
r_const
r_struct
id|name_path
op_star
id|path
comma
r_const
r_char
op_star
id|last
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|bitmap
op_star
id|base
op_assign
id|data
suffix:semicolon
r_int
id|bitmap_pos
suffix:semicolon
id|bitmap_pos
op_assign
id|bitmap_position
c_func
(paren
id|object-&gt;oid.hash
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bitmap_pos
OL
l_int|0
)paren
(brace
r_char
op_star
id|name
op_assign
id|path_name
c_func
(paren
id|path
comma
id|last
)paren
suffix:semicolon
id|bitmap_pos
op_assign
id|ext_index_add_object
c_func
(paren
id|object
comma
id|name
)paren
suffix:semicolon
id|free
c_func
(paren
id|name
)paren
suffix:semicolon
)brace
id|bitmap_set
c_func
(paren
id|base
comma
id|bitmap_pos
)paren
suffix:semicolon
)brace
DECL|function|show_commit
r_static
r_void
id|show_commit
c_func
(paren
r_struct
id|commit
op_star
id|commit
comma
r_void
op_star
id|data
)paren
(brace
)brace
DECL|function|add_to_include_set
r_static
r_int
id|add_to_include_set
c_func
(paren
r_struct
id|include_data
op_star
id|data
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
id|bitmap_pos
)paren
(brace
id|khiter_t
id|hash_pos
suffix:semicolon
r_if
c_cond
(paren
id|data-&gt;seen
op_logical_and
id|bitmap_get
c_func
(paren
id|data-&gt;seen
comma
id|bitmap_pos
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|bitmap_get
c_func
(paren
id|data-&gt;base
comma
id|bitmap_pos
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|hash_pos
op_assign
id|kh_get_sha1
c_func
(paren
id|bitmap_git.bitmaps
comma
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hash_pos
OL
id|kh_end
c_func
(paren
id|bitmap_git.bitmaps
)paren
)paren
(brace
r_struct
id|stored_bitmap
op_star
id|st
op_assign
id|kh_value
c_func
(paren
id|bitmap_git.bitmaps
comma
id|hash_pos
)paren
suffix:semicolon
id|bitmap_or_ewah
c_func
(paren
id|data-&gt;base
comma
id|lookup_stored_bitmap
c_func
(paren
id|st
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|bitmap_set
c_func
(paren
id|data-&gt;base
comma
id|bitmap_pos
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|should_include
r_static
r_int
id|should_include
c_func
(paren
r_struct
id|commit
op_star
id|commit
comma
r_void
op_star
id|_data
)paren
(brace
r_struct
id|include_data
op_star
id|data
op_assign
id|_data
suffix:semicolon
r_int
id|bitmap_pos
suffix:semicolon
id|bitmap_pos
op_assign
id|bitmap_position
c_func
(paren
id|commit-&gt;object.oid.hash
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bitmap_pos
OL
l_int|0
)paren
id|bitmap_pos
op_assign
id|ext_index_add_object
c_func
(paren
(paren
r_struct
id|object
op_star
)paren
id|commit
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|add_to_include_set
c_func
(paren
id|data
comma
id|commit-&gt;object.oid.hash
comma
id|bitmap_pos
)paren
)paren
(brace
r_struct
id|commit_list
op_star
id|parent
op_assign
id|commit-&gt;parents
suffix:semicolon
r_while
c_loop
(paren
id|parent
)paren
(brace
id|parent-&gt;item-&gt;object.flags
op_or_assign
id|SEEN
suffix:semicolon
id|parent
op_assign
id|parent-&gt;next
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|find_objects
r_static
r_struct
id|bitmap
op_star
id|find_objects
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_struct
id|object_list
op_star
id|roots
comma
r_struct
id|bitmap
op_star
id|seen
)paren
(brace
r_struct
id|bitmap
op_star
id|base
op_assign
l_int|NULL
suffix:semicolon
r_int
id|needs_walk
op_assign
l_int|0
suffix:semicolon
r_struct
id|object_list
op_star
id|not_mapped
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Go through all the roots for the walk. The ones that have bitmaps&n;&t; * on the bitmap index will be `or`ed together to form an initial&n;&t; * global reachability analysis.&n;&t; *&n;&t; * The ones without bitmaps in the index will be stored in the&n;&t; * `not_mapped_list` for further processing.&n;&t; */
r_while
c_loop
(paren
id|roots
)paren
(brace
r_struct
id|object
op_star
id|object
op_assign
id|roots-&gt;item
suffix:semicolon
id|roots
op_assign
id|roots-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|object-&gt;type
op_eq
id|OBJ_COMMIT
)paren
(brace
id|khiter_t
id|pos
op_assign
id|kh_get_sha1
c_func
(paren
id|bitmap_git.bitmaps
comma
id|object-&gt;oid.hash
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
id|kh_end
c_func
(paren
id|bitmap_git.bitmaps
)paren
)paren
(brace
r_struct
id|stored_bitmap
op_star
id|st
op_assign
id|kh_value
c_func
(paren
id|bitmap_git.bitmaps
comma
id|pos
)paren
suffix:semicolon
r_struct
id|ewah_bitmap
op_star
id|or_with
op_assign
id|lookup_stored_bitmap
c_func
(paren
id|st
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base
op_eq
l_int|NULL
)paren
id|base
op_assign
id|ewah_to_bitmap
c_func
(paren
id|or_with
)paren
suffix:semicolon
r_else
id|bitmap_or_ewah
c_func
(paren
id|base
comma
id|or_with
)paren
suffix:semicolon
id|object-&gt;flags
op_or_assign
id|SEEN
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
id|object_list_insert
c_func
(paren
id|object
comma
op_amp
id|not_mapped
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Best case scenario: We found bitmaps for all the roots,&n;&t; * so the resulting `or` bitmap has the full reachability analysis&n;&t; */
r_if
c_cond
(paren
id|not_mapped
op_eq
l_int|NULL
)paren
r_return
id|base
suffix:semicolon
id|roots
op_assign
id|not_mapped
suffix:semicolon
multiline_comment|/*&n;&t; * Let&squot;s iterate through all the roots that don&squot;t have bitmaps to&n;&t; * check if we can determine them to be reachable from the existing&n;&t; * global bitmap.&n;&t; *&n;&t; * If we cannot find them in the existing global bitmap, we&squot;ll need&n;&t; * to push them to an actual walk and run it until we can confirm&n;&t; * they are reachable&n;&t; */
r_while
c_loop
(paren
id|roots
)paren
(brace
r_struct
id|object
op_star
id|object
op_assign
id|roots-&gt;item
suffix:semicolon
r_int
id|pos
suffix:semicolon
id|roots
op_assign
id|roots-&gt;next
suffix:semicolon
id|pos
op_assign
id|bitmap_position
c_func
(paren
id|object-&gt;oid.hash
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
l_int|0
op_logical_or
id|base
op_eq
l_int|NULL
op_logical_or
op_logical_neg
id|bitmap_get
c_func
(paren
id|base
comma
id|pos
)paren
)paren
(brace
id|object-&gt;flags
op_and_assign
op_complement
id|UNINTERESTING
suffix:semicolon
id|add_pending_object
c_func
(paren
id|revs
comma
id|object
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
id|needs_walk
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|object-&gt;flags
op_or_assign
id|SEEN
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|needs_walk
)paren
(brace
r_struct
id|include_data
id|incdata
suffix:semicolon
r_if
c_cond
(paren
id|base
op_eq
l_int|NULL
)paren
id|base
op_assign
id|bitmap_new
c_func
(paren
)paren
suffix:semicolon
id|incdata.base
op_assign
id|base
suffix:semicolon
id|incdata.seen
op_assign
id|seen
suffix:semicolon
id|revs-&gt;include_check
op_assign
id|should_include
suffix:semicolon
id|revs-&gt;include_check_data
op_assign
op_amp
id|incdata
suffix:semicolon
r_if
c_cond
(paren
id|prepare_revision_walk
c_func
(paren
id|revs
)paren
)paren
id|die
c_func
(paren
l_string|&quot;revision walk setup failed&quot;
)paren
suffix:semicolon
id|traverse_commit_list
c_func
(paren
id|revs
comma
id|show_commit
comma
id|show_object
comma
id|base
)paren
suffix:semicolon
)brace
r_return
id|base
suffix:semicolon
)brace
DECL|function|show_extended_objects
r_static
r_void
id|show_extended_objects
c_func
(paren
r_struct
id|bitmap
op_star
id|objects
comma
id|show_reachable_fn
id|show_reach
)paren
(brace
r_struct
id|eindex
op_star
id|eindex
op_assign
op_amp
id|bitmap_git.ext_index
suffix:semicolon
r_uint32
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|eindex-&gt;count
suffix:semicolon
op_increment
id|i
)paren
(brace
r_struct
id|object
op_star
id|obj
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bitmap_get
c_func
(paren
id|objects
comma
id|bitmap_git.pack-&gt;num_objects
op_plus
id|i
)paren
)paren
r_continue
suffix:semicolon
id|obj
op_assign
id|eindex-&gt;objects
(braket
id|i
)braket
suffix:semicolon
id|show_reach
c_func
(paren
id|obj-&gt;oid.hash
comma
id|obj-&gt;type
comma
l_int|0
comma
id|eindex-&gt;hashes
(braket
id|i
)braket
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
DECL|function|show_objects_for_type
r_static
r_void
id|show_objects_for_type
c_func
(paren
r_struct
id|bitmap
op_star
id|objects
comma
r_struct
id|ewah_bitmap
op_star
id|type_filter
comma
r_enum
id|object_type
id|object_type
comma
id|show_reachable_fn
id|show_reach
)paren
(brace
r_int
id|pos
op_assign
l_int|0
comma
id|i
op_assign
l_int|0
suffix:semicolon
r_uint32
id|offset
suffix:semicolon
r_struct
id|ewah_iterator
id|it
suffix:semicolon
id|eword_t
id|filter
suffix:semicolon
r_if
c_cond
(paren
id|bitmap_git.reuse_objects
op_eq
id|bitmap_git.pack-&gt;num_objects
)paren
r_return
suffix:semicolon
id|ewah_iterator_init
c_func
(paren
op_amp
id|it
comma
id|type_filter
)paren
suffix:semicolon
r_while
c_loop
(paren
id|i
OL
id|objects-&gt;word_alloc
op_logical_and
id|ewah_iterator_next
c_func
(paren
op_amp
id|filter
comma
op_amp
id|it
)paren
)paren
(brace
id|eword_t
id|word
op_assign
id|objects-&gt;words
(braket
id|i
)braket
op_amp
id|filter
suffix:semicolon
r_for
c_loop
(paren
id|offset
op_assign
l_int|0
suffix:semicolon
id|offset
OL
id|BITS_IN_EWORD
suffix:semicolon
op_increment
id|offset
)paren
(brace
r_const
r_int
r_char
op_star
id|sha1
suffix:semicolon
r_struct
id|revindex_entry
op_star
id|entry
suffix:semicolon
r_uint32
id|hash
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|word
op_rshift
id|offset
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|offset
op_add_assign
id|ewah_bit_ctz64
c_func
(paren
id|word
op_rshift
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_plus
id|offset
OL
id|bitmap_git.reuse_objects
)paren
r_continue
suffix:semicolon
id|entry
op_assign
op_amp
id|bitmap_git.reverse_index-&gt;revindex
(braket
id|pos
op_plus
id|offset
)braket
suffix:semicolon
id|sha1
op_assign
id|nth_packed_object_sha1
c_func
(paren
id|bitmap_git.pack
comma
id|entry-&gt;nr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bitmap_git.hashes
)paren
id|hash
op_assign
id|ntohl
c_func
(paren
id|bitmap_git.hashes
(braket
id|entry-&gt;nr
)braket
)paren
suffix:semicolon
id|show_reach
c_func
(paren
id|sha1
comma
id|object_type
comma
l_int|0
comma
id|hash
comma
id|bitmap_git.pack
comma
id|entry-&gt;offset
)paren
suffix:semicolon
)brace
id|pos
op_add_assign
id|BITS_IN_EWORD
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
)brace
DECL|function|in_bitmapped_pack
r_static
r_int
id|in_bitmapped_pack
c_func
(paren
r_struct
id|object_list
op_star
id|roots
)paren
(brace
r_while
c_loop
(paren
id|roots
)paren
(brace
r_struct
id|object
op_star
id|object
op_assign
id|roots-&gt;item
suffix:semicolon
id|roots
op_assign
id|roots-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|find_pack_entry_one
c_func
(paren
id|object-&gt;oid.hash
comma
id|bitmap_git.pack
)paren
OG
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|prepare_bitmap_walk
r_int
id|prepare_bitmap_walk
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
r_int
id|pending_nr
op_assign
id|revs-&gt;pending.nr
suffix:semicolon
r_struct
id|object_array_entry
op_star
id|pending_e
op_assign
id|revs-&gt;pending.objects
suffix:semicolon
r_struct
id|object_list
op_star
id|wants
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|object_list
op_star
id|haves
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|bitmap
op_star
id|wants_bitmap
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|bitmap
op_star
id|haves_bitmap
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bitmap_git.loaded
)paren
(brace
multiline_comment|/* try to open a bitmapped pack, but don&squot;t parse it yet&n;&t;&t; * because we may not need to use it */
r_if
c_cond
(paren
id|open_pack_bitmap
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pending_nr
suffix:semicolon
op_increment
id|i
)paren
(brace
r_struct
id|object
op_star
id|object
op_assign
id|pending_e
(braket
id|i
)braket
dot
id|item
suffix:semicolon
r_if
c_cond
(paren
id|object-&gt;type
op_eq
id|OBJ_NONE
)paren
id|parse_object_or_die
c_func
(paren
id|object-&gt;oid.hash
comma
l_int|NULL
)paren
suffix:semicolon
r_while
c_loop
(paren
id|object-&gt;type
op_eq
id|OBJ_TAG
)paren
(brace
r_struct
id|tag
op_star
id|tag
op_assign
(paren
r_struct
id|tag
op_star
)paren
id|object
suffix:semicolon
r_if
c_cond
(paren
id|object-&gt;flags
op_amp
id|UNINTERESTING
)paren
id|object_list_insert
c_func
(paren
id|object
comma
op_amp
id|haves
)paren
suffix:semicolon
r_else
id|object_list_insert
c_func
(paren
id|object
comma
op_amp
id|wants
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tag-&gt;tagged
)paren
id|die
c_func
(paren
l_string|&quot;bad tag&quot;
)paren
suffix:semicolon
id|object
op_assign
id|parse_object_or_die
c_func
(paren
id|tag-&gt;tagged-&gt;oid.hash
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|object-&gt;flags
op_amp
id|UNINTERESTING
)paren
id|object_list_insert
c_func
(paren
id|object
comma
op_amp
id|haves
)paren
suffix:semicolon
r_else
id|object_list_insert
c_func
(paren
id|object
comma
op_amp
id|wants
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * if we have a HAVES list, but none of those haves is contained&n;&t; * in the packfile that has a bitmap, we don&squot;t have anything to&n;&t; * optimize here&n;&t; */
r_if
c_cond
(paren
id|haves
op_logical_and
op_logical_neg
id|in_bitmapped_pack
c_func
(paren
id|haves
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* if we don&squot;t want anything, we&squot;re done here */
r_if
c_cond
(paren
op_logical_neg
id|wants
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * now we&squot;re going to use bitmaps, so load the actual bitmap entries&n;&t; * from disk. this is the point of no return; after this the rev_list&n;&t; * becomes invalidated and we must perform the revwalk through bitmaps&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|bitmap_git.loaded
op_logical_and
id|load_pack_bitmap
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
id|revs-&gt;pending.nr
op_assign
l_int|0
suffix:semicolon
id|revs-&gt;pending.alloc
op_assign
l_int|0
suffix:semicolon
id|revs-&gt;pending.objects
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|haves
)paren
(brace
id|revs-&gt;ignore_missing_links
op_assign
l_int|1
suffix:semicolon
id|haves_bitmap
op_assign
id|find_objects
c_func
(paren
id|revs
comma
id|haves
comma
l_int|NULL
)paren
suffix:semicolon
id|reset_revision_walk
c_func
(paren
)paren
suffix:semicolon
id|revs-&gt;ignore_missing_links
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|haves_bitmap
op_eq
l_int|NULL
)paren
id|die
c_func
(paren
l_string|&quot;BUG: failed to perform bitmap walk&quot;
)paren
suffix:semicolon
)brace
id|wants_bitmap
op_assign
id|find_objects
c_func
(paren
id|revs
comma
id|wants
comma
id|haves_bitmap
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wants_bitmap
)paren
id|die
c_func
(paren
l_string|&quot;BUG: failed to perform bitmap walk&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|haves_bitmap
)paren
id|bitmap_and_not
c_func
(paren
id|wants_bitmap
comma
id|haves_bitmap
)paren
suffix:semicolon
id|bitmap_git.result
op_assign
id|wants_bitmap
suffix:semicolon
id|bitmap_free
c_func
(paren
id|haves_bitmap
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|reuse_partial_packfile_from_bitmap
r_int
id|reuse_partial_packfile_from_bitmap
c_func
(paren
r_struct
id|packed_git
op_star
op_star
id|packfile
comma
r_uint32
op_star
id|entries
comma
id|off_t
op_star
id|up_to
)paren
(brace
multiline_comment|/*&n;&t; * Reuse the packfile content if we need more than&n;&t; * 90% of its objects&n;&t; */
r_static
r_const
r_float
id|REUSE_PERCENT
op_assign
l_float|0.9
suffix:semicolon
r_struct
id|bitmap
op_star
id|result
op_assign
id|bitmap_git.result
suffix:semicolon
r_uint32
id|reuse_threshold
suffix:semicolon
r_uint32
id|i
comma
id|reuse_objects
op_assign
l_int|0
suffix:semicolon
m_assert
(paren
id|result
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|result-&gt;word_alloc
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|result-&gt;words
(braket
id|i
)braket
op_ne
(paren
id|eword_t
)paren
op_complement
l_int|0
)paren
(brace
id|reuse_objects
op_add_assign
id|ewah_bit_ctz64
c_func
(paren
op_complement
id|result-&gt;words
(braket
id|i
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|reuse_objects
op_add_assign
id|BITS_IN_EWORD
suffix:semicolon
)brace
macro_line|#ifdef GIT_BITMAP_DEBUG
(brace
r_const
r_int
r_char
op_star
id|sha1
suffix:semicolon
r_struct
id|revindex_entry
op_star
id|entry
suffix:semicolon
id|entry
op_assign
op_amp
id|bitmap_git.reverse_index-&gt;revindex
(braket
id|reuse_objects
)braket
suffix:semicolon
id|sha1
op_assign
id|nth_packed_object_sha1
c_func
(paren
id|bitmap_git.pack
comma
id|entry-&gt;nr
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Failed to reuse at %d (%016llx)&bslash;n&quot;
comma
id|reuse_objects
comma
id|result-&gt;words
(braket
id|i
)braket
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot; %s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|reuse_objects
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|reuse_objects
op_ge
id|bitmap_git.pack-&gt;num_objects
)paren
(brace
id|bitmap_git.reuse_objects
op_assign
op_star
id|entries
op_assign
id|bitmap_git.pack-&gt;num_objects
suffix:semicolon
op_star
id|up_to
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* reuse the full pack */
op_star
id|packfile
op_assign
id|bitmap_git.pack
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|reuse_threshold
op_assign
id|bitmap_popcount
c_func
(paren
id|bitmap_git.result
)paren
op_star
id|REUSE_PERCENT
suffix:semicolon
r_if
c_cond
(paren
id|reuse_objects
OL
id|reuse_threshold
)paren
r_return
l_int|1
suffix:semicolon
id|bitmap_git.reuse_objects
op_assign
op_star
id|entries
op_assign
id|reuse_objects
suffix:semicolon
op_star
id|up_to
op_assign
id|bitmap_git.reverse_index-&gt;revindex
(braket
id|reuse_objects
)braket
dot
id|offset
suffix:semicolon
op_star
id|packfile
op_assign
id|bitmap_git.pack
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|traverse_bitmap_commit_list
r_void
id|traverse_bitmap_commit_list
c_func
(paren
id|show_reachable_fn
id|show_reachable
)paren
(brace
m_assert
(paren
id|bitmap_git.result
)paren
suffix:semicolon
id|show_objects_for_type
c_func
(paren
id|bitmap_git.result
comma
id|bitmap_git.commits
comma
id|OBJ_COMMIT
comma
id|show_reachable
)paren
suffix:semicolon
id|show_objects_for_type
c_func
(paren
id|bitmap_git.result
comma
id|bitmap_git.trees
comma
id|OBJ_TREE
comma
id|show_reachable
)paren
suffix:semicolon
id|show_objects_for_type
c_func
(paren
id|bitmap_git.result
comma
id|bitmap_git.blobs
comma
id|OBJ_BLOB
comma
id|show_reachable
)paren
suffix:semicolon
id|show_objects_for_type
c_func
(paren
id|bitmap_git.result
comma
id|bitmap_git.tags
comma
id|OBJ_TAG
comma
id|show_reachable
)paren
suffix:semicolon
id|show_extended_objects
c_func
(paren
id|bitmap_git.result
comma
id|show_reachable
)paren
suffix:semicolon
id|bitmap_free
c_func
(paren
id|bitmap_git.result
)paren
suffix:semicolon
id|bitmap_git.result
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|count_object_type
r_static
r_uint32
id|count_object_type
c_func
(paren
r_struct
id|bitmap
op_star
id|objects
comma
r_enum
id|object_type
id|type
)paren
(brace
r_struct
id|eindex
op_star
id|eindex
op_assign
op_amp
id|bitmap_git.ext_index
suffix:semicolon
r_uint32
id|i
op_assign
l_int|0
comma
id|count
op_assign
l_int|0
suffix:semicolon
r_struct
id|ewah_iterator
id|it
suffix:semicolon
id|eword_t
id|filter
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|OBJ_COMMIT
suffix:colon
id|ewah_iterator_init
c_func
(paren
op_amp
id|it
comma
id|bitmap_git.commits
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OBJ_TREE
suffix:colon
id|ewah_iterator_init
c_func
(paren
op_amp
id|it
comma
id|bitmap_git.trees
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OBJ_BLOB
suffix:colon
id|ewah_iterator_init
c_func
(paren
op_amp
id|it
comma
id|bitmap_git.blobs
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OBJ_TAG
suffix:colon
id|ewah_iterator_init
c_func
(paren
op_amp
id|it
comma
id|bitmap_git.tags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
id|i
OL
id|objects-&gt;word_alloc
op_logical_and
id|ewah_iterator_next
c_func
(paren
op_amp
id|filter
comma
op_amp
id|it
)paren
)paren
(brace
id|eword_t
id|word
op_assign
id|objects-&gt;words
(braket
id|i
op_increment
)braket
op_amp
id|filter
suffix:semicolon
id|count
op_add_assign
id|ewah_bit_popcount64
c_func
(paren
id|word
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|eindex-&gt;count
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|eindex-&gt;objects
(braket
id|i
)braket
op_member_access_from_pointer
id|type
op_eq
id|type
op_logical_and
id|bitmap_get
c_func
(paren
id|objects
comma
id|bitmap_git.pack-&gt;num_objects
op_plus
id|i
)paren
)paren
id|count
op_increment
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
DECL|function|count_bitmap_commit_list
r_void
id|count_bitmap_commit_list
c_func
(paren
r_uint32
op_star
id|commits
comma
r_uint32
op_star
id|trees
comma
r_uint32
op_star
id|blobs
comma
r_uint32
op_star
id|tags
)paren
(brace
m_assert
(paren
id|bitmap_git.result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|commits
)paren
op_star
id|commits
op_assign
id|count_object_type
c_func
(paren
id|bitmap_git.result
comma
id|OBJ_COMMIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|trees
)paren
op_star
id|trees
op_assign
id|count_object_type
c_func
(paren
id|bitmap_git.result
comma
id|OBJ_TREE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blobs
)paren
op_star
id|blobs
op_assign
id|count_object_type
c_func
(paren
id|bitmap_git.result
comma
id|OBJ_BLOB
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tags
)paren
op_star
id|tags
op_assign
id|count_object_type
c_func
(paren
id|bitmap_git.result
comma
id|OBJ_TAG
)paren
suffix:semicolon
)brace
DECL|struct|bitmap_test_data
r_struct
id|bitmap_test_data
(brace
DECL|member|base
r_struct
id|bitmap
op_star
id|base
suffix:semicolon
DECL|member|prg
r_struct
id|progress
op_star
id|prg
suffix:semicolon
DECL|member|seen
r_int
id|seen
suffix:semicolon
)brace
suffix:semicolon
DECL|function|test_show_object
r_static
r_void
id|test_show_object
c_func
(paren
r_struct
id|object
op_star
id|object
comma
r_const
r_struct
id|name_path
op_star
id|path
comma
r_const
r_char
op_star
id|last
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|bitmap_test_data
op_star
id|tdata
op_assign
id|data
suffix:semicolon
r_int
id|bitmap_pos
suffix:semicolon
id|bitmap_pos
op_assign
id|bitmap_position
c_func
(paren
id|object-&gt;oid.hash
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bitmap_pos
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;Object not in bitmap: %s&bslash;n&quot;
comma
id|oid_to_hex
c_func
(paren
op_amp
id|object-&gt;oid
)paren
)paren
suffix:semicolon
id|bitmap_set
c_func
(paren
id|tdata-&gt;base
comma
id|bitmap_pos
)paren
suffix:semicolon
id|display_progress
c_func
(paren
id|tdata-&gt;prg
comma
op_increment
id|tdata-&gt;seen
)paren
suffix:semicolon
)brace
DECL|function|test_show_commit
r_static
r_void
id|test_show_commit
c_func
(paren
r_struct
id|commit
op_star
id|commit
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|bitmap_test_data
op_star
id|tdata
op_assign
id|data
suffix:semicolon
r_int
id|bitmap_pos
suffix:semicolon
id|bitmap_pos
op_assign
id|bitmap_position
c_func
(paren
id|commit-&gt;object.oid.hash
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bitmap_pos
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;Object not in bitmap: %s&bslash;n&quot;
comma
id|oid_to_hex
c_func
(paren
op_amp
id|commit-&gt;object.oid
)paren
)paren
suffix:semicolon
id|bitmap_set
c_func
(paren
id|tdata-&gt;base
comma
id|bitmap_pos
)paren
suffix:semicolon
id|display_progress
c_func
(paren
id|tdata-&gt;prg
comma
op_increment
id|tdata-&gt;seen
)paren
suffix:semicolon
)brace
DECL|function|test_bitmap_walk
r_void
id|test_bitmap_walk
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
)paren
(brace
r_struct
id|object
op_star
id|root
suffix:semicolon
r_struct
id|bitmap
op_star
id|result
op_assign
l_int|NULL
suffix:semicolon
id|khiter_t
id|pos
suffix:semicolon
r_int
id|result_popcnt
suffix:semicolon
r_struct
id|bitmap_test_data
id|tdata
suffix:semicolon
r_if
c_cond
(paren
id|prepare_bitmap_git
c_func
(paren
)paren
)paren
id|die
c_func
(paren
l_string|&quot;failed to load bitmap indexes&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;pending.nr
op_ne
l_int|1
)paren
id|die
c_func
(paren
l_string|&quot;you must specify exactly one commit to test&quot;
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Bitmap v%d test (%d entries loaded)&bslash;n&quot;
comma
id|bitmap_git.version
comma
id|bitmap_git.entry_count
)paren
suffix:semicolon
id|root
op_assign
id|revs-&gt;pending.objects
(braket
l_int|0
)braket
dot
id|item
suffix:semicolon
id|pos
op_assign
id|kh_get_sha1
c_func
(paren
id|bitmap_git.bitmaps
comma
id|root-&gt;oid.hash
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
id|kh_end
c_func
(paren
id|bitmap_git.bitmaps
)paren
)paren
(brace
r_struct
id|stored_bitmap
op_star
id|st
op_assign
id|kh_value
c_func
(paren
id|bitmap_git.bitmaps
comma
id|pos
)paren
suffix:semicolon
r_struct
id|ewah_bitmap
op_star
id|bm
op_assign
id|lookup_stored_bitmap
c_func
(paren
id|st
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Found bitmap for %s. %d bits / %08x checksum&bslash;n&quot;
comma
id|oid_to_hex
c_func
(paren
op_amp
id|root-&gt;oid
)paren
comma
(paren
r_int
)paren
id|bm-&gt;bit_size
comma
id|ewah_checksum
c_func
(paren
id|bm
)paren
)paren
suffix:semicolon
id|result
op_assign
id|ewah_to_bitmap
c_func
(paren
id|bm
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
op_eq
l_int|NULL
)paren
id|die
c_func
(paren
l_string|&quot;Commit %s doesn&squot;t have an indexed bitmap&quot;
comma
id|oid_to_hex
c_func
(paren
op_amp
id|root-&gt;oid
)paren
)paren
suffix:semicolon
id|revs-&gt;tag_objects
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;tree_objects
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;blob_objects
op_assign
l_int|1
suffix:semicolon
id|result_popcnt
op_assign
id|bitmap_popcount
c_func
(paren
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prepare_revision_walk
c_func
(paren
id|revs
)paren
)paren
id|die
c_func
(paren
l_string|&quot;revision walk setup failed&quot;
)paren
suffix:semicolon
id|tdata.base
op_assign
id|bitmap_new
c_func
(paren
)paren
suffix:semicolon
id|tdata.prg
op_assign
id|start_progress
c_func
(paren
l_string|&quot;Verifying bitmap entries&quot;
comma
id|result_popcnt
)paren
suffix:semicolon
id|tdata.seen
op_assign
l_int|0
suffix:semicolon
id|traverse_commit_list
c_func
(paren
id|revs
comma
op_amp
id|test_show_commit
comma
op_amp
id|test_show_object
comma
op_amp
id|tdata
)paren
suffix:semicolon
id|stop_progress
c_func
(paren
op_amp
id|tdata.prg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bitmap_equals
c_func
(paren
id|result
comma
id|tdata.base
)paren
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;OK!&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Mismatch!&bslash;n&quot;
)paren
suffix:semicolon
id|bitmap_free
c_func
(paren
id|result
)paren
suffix:semicolon
)brace
DECL|function|rebuild_bitmap
r_static
r_int
id|rebuild_bitmap
c_func
(paren
r_uint32
op_star
id|reposition
comma
r_struct
id|ewah_bitmap
op_star
id|source
comma
r_struct
id|bitmap
op_star
id|dest
)paren
(brace
r_uint32
id|pos
op_assign
l_int|0
suffix:semicolon
r_struct
id|ewah_iterator
id|it
suffix:semicolon
id|eword_t
id|word
suffix:semicolon
id|ewah_iterator_init
c_func
(paren
op_amp
id|it
comma
id|source
)paren
suffix:semicolon
r_while
c_loop
(paren
id|ewah_iterator_next
c_func
(paren
op_amp
id|word
comma
op_amp
id|it
)paren
)paren
(brace
r_uint32
id|offset
comma
id|bit_pos
suffix:semicolon
r_for
c_loop
(paren
id|offset
op_assign
l_int|0
suffix:semicolon
id|offset
OL
id|BITS_IN_EWORD
suffix:semicolon
op_increment
id|offset
)paren
(brace
r_if
c_cond
(paren
(paren
id|word
op_rshift
id|offset
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|offset
op_add_assign
id|ewah_bit_ctz64
c_func
(paren
id|word
op_rshift
id|offset
)paren
suffix:semicolon
id|bit_pos
op_assign
id|reposition
(braket
id|pos
op_plus
id|offset
)braket
suffix:semicolon
r_if
c_cond
(paren
id|bit_pos
OG
l_int|0
)paren
id|bitmap_set
c_func
(paren
id|dest
comma
id|bit_pos
l_int|1
)paren
suffix:semicolon
r_else
multiline_comment|/* can&squot;t reuse, we don&squot;t have the object */
r_return
l_int|1
suffix:semicolon
)brace
id|pos
op_add_assign
id|BITS_IN_EWORD
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|rebuild_existing_bitmaps
r_int
id|rebuild_existing_bitmaps
c_func
(paren
r_struct
id|packing_data
op_star
id|mapping
comma
id|khash_sha1
op_star
id|reused_bitmaps
comma
r_int
id|show_progress
)paren
(brace
r_uint32
id|i
comma
id|num_objects
suffix:semicolon
r_uint32
op_star
id|reposition
suffix:semicolon
r_struct
id|bitmap
op_star
id|rebuild
suffix:semicolon
r_struct
id|stored_bitmap
op_star
id|stored
suffix:semicolon
r_struct
id|progress
op_star
id|progress
op_assign
l_int|NULL
suffix:semicolon
id|khiter_t
id|hash_pos
suffix:semicolon
r_int
id|hash_ret
suffix:semicolon
r_if
c_cond
(paren
id|prepare_bitmap_git
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
id|num_objects
op_assign
id|bitmap_git.pack-&gt;num_objects
suffix:semicolon
id|reposition
op_assign
id|xcalloc
c_func
(paren
id|num_objects
comma
r_sizeof
(paren
r_uint32
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_objects
suffix:semicolon
op_increment
id|i
)paren
(brace
r_const
r_int
r_char
op_star
id|sha1
suffix:semicolon
r_struct
id|revindex_entry
op_star
id|entry
suffix:semicolon
r_struct
id|object_entry
op_star
id|oe
suffix:semicolon
id|entry
op_assign
op_amp
id|bitmap_git.reverse_index-&gt;revindex
(braket
id|i
)braket
suffix:semicolon
id|sha1
op_assign
id|nth_packed_object_sha1
c_func
(paren
id|bitmap_git.pack
comma
id|entry-&gt;nr
)paren
suffix:semicolon
id|oe
op_assign
id|packlist_find
c_func
(paren
id|mapping
comma
id|sha1
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|oe
)paren
id|reposition
(braket
id|i
)braket
op_assign
id|oe-&gt;in_pack_pos
op_plus
l_int|1
suffix:semicolon
)brace
id|rebuild
op_assign
id|bitmap_new
c_func
(paren
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|show_progress
)paren
id|progress
op_assign
id|start_progress
c_func
(paren
l_string|&quot;Reusing bitmaps&quot;
comma
l_int|0
)paren
suffix:semicolon
id|kh_foreach_value
c_func
(paren
id|bitmap_git.bitmaps
comma
id|stored
comma
(brace
r_if
(paren
id|stored-&gt;flags
op_amp
id|BITMAP_FLAG_REUSE
)paren
(brace
r_if
(paren
op_logical_neg
id|rebuild_bitmap
c_func
(paren
id|reposition
comma
id|lookup_stored_bitmap
c_func
(paren
id|stored
)paren
comma
id|rebuild
)paren
)paren
(brace
id|hash_pos
op_assign
id|kh_put_sha1
c_func
(paren
id|reused_bitmaps
comma
id|stored-&gt;sha1
comma
op_amp
id|hash_ret
)paren
suffix:semicolon
id|kh_value
c_func
(paren
id|reused_bitmaps
comma
id|hash_pos
)paren
op_assign
id|bitmap_to_ewah
c_func
(paren
id|rebuild
)paren
suffix:semicolon
)brace
id|bitmap_reset
c_func
(paren
id|rebuild
)paren
suffix:semicolon
id|display_progress
c_func
(paren
id|progress
comma
op_increment
id|i
)paren
suffix:semicolon
)brace
)brace
)paren
suffix:semicolon
id|stop_progress
c_func
(paren
op_amp
id|progress
)paren
suffix:semicolon
id|free
c_func
(paren
id|reposition
)paren
suffix:semicolon
id|bitmap_free
c_func
(paren
id|rebuild
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
