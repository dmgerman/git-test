multiline_comment|/*&n; * Copyright (C) 2011 John Szakmeister &lt;john@szakmeister.net&gt;&n; *               2012 Philipp A. Hartmann &lt;pah@qo.cx&gt;&n; *&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License as published by&n; *  the Free Software Foundation; either version 2 of the License, or&n; *  (at your option) any later version.&n; *&n; *  This program is distributed in the hope that it will be useful,&n; *  but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *  GNU General Public License for more details.&n; *&n; *  You should have received a copy of the GNU General Public License&n; *  along with this program; if not, write to the Free Software&n; *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
multiline_comment|/*&n; * Credits:&n; * - GNOME Keyring API handling originally written by John Szakmeister&n; * - ported to credential helper API by Philipp A. Hartmann&n; */
macro_line|#include &lt;stdio.h&gt;
macro_line|#include &lt;string.h&gt;
macro_line|#include &lt;stdarg.h&gt;
macro_line|#include &lt;stdlib.h&gt;
macro_line|#include &lt;errno.h&gt;
macro_line|#include &lt;gnome-keyring.h&gt;
multiline_comment|/*&n; * This credential struct and API is simplified from git&squot;s credential.{h,c}&n; */
DECL|struct|credential
r_struct
id|credential
(brace
DECL|member|protocol
r_char
op_star
id|protocol
suffix:semicolon
DECL|member|host
r_char
op_star
id|host
suffix:semicolon
DECL|member|port
r_int
r_int
id|port
suffix:semicolon
DECL|member|path
r_char
op_star
id|path
suffix:semicolon
DECL|member|username
r_char
op_star
id|username
suffix:semicolon
DECL|member|password
r_char
op_star
id|password
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|CREDENTIAL_INIT
mdefine_line|#define CREDENTIAL_INIT &bslash;&n;  { NULL,NULL,0,NULL,NULL,NULL }
r_void
id|credential_init
c_func
(paren
r_struct
id|credential
op_star
id|c
)paren
suffix:semicolon
r_void
id|credential_clear
c_func
(paren
r_struct
id|credential
op_star
id|c
)paren
suffix:semicolon
r_int
id|credential_read
c_func
(paren
r_struct
id|credential
op_star
id|c
)paren
suffix:semicolon
r_void
id|credential_write
c_func
(paren
r_const
r_struct
id|credential
op_star
id|c
)paren
suffix:semicolon
DECL|typedef|credential_op_cb
r_typedef
r_int
(paren
op_star
id|credential_op_cb
)paren
(paren
r_struct
id|credential
op_star
)paren
suffix:semicolon
DECL|struct|credential_operation
r_struct
id|credential_operation
(brace
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|member|op
id|credential_op_cb
id|op
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|CREDENTIAL_OP_END
mdefine_line|#define CREDENTIAL_OP_END &bslash;&n;  { NULL,NULL }
multiline_comment|/*&n; * Table with operation callbacks is defined in concrete&n; * credential helper implementation and contains entries&n; * like { &quot;get&quot;, function_to_get_credential } terminated&n; * by CREDENTIAL_OP_END.&n; */
DECL|variable|credential_helper_ops
r_struct
id|credential_operation
r_const
id|credential_helper_ops
(braket
)braket
suffix:semicolon
multiline_comment|/* ---------------- common helper functions ----------------- */
DECL|function|free_password
r_static
r_inline
r_void
id|free_password
c_func
(paren
r_char
op_star
id|password
)paren
(brace
r_char
op_star
id|c
op_assign
id|password
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|password
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
op_star
id|c
)paren
op_star
id|c
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|free
c_func
(paren
id|password
)paren
suffix:semicolon
)brace
DECL|function|warning
r_static
r_inline
r_void
id|warning
c_func
(paren
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
id|va_list
id|ap
suffix:semicolon
id|va_start
c_func
(paren
id|ap
comma
id|fmt
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;warning: &quot;
)paren
suffix:semicolon
id|vfprintf
c_func
(paren
id|stderr
comma
id|fmt
comma
id|ap
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|ap
)paren
suffix:semicolon
)brace
DECL|function|error
r_static
r_inline
r_void
id|error
c_func
(paren
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
id|va_list
id|ap
suffix:semicolon
id|va_start
c_func
(paren
id|ap
comma
id|fmt
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;error: &quot;
)paren
suffix:semicolon
id|vfprintf
c_func
(paren
id|stderr
comma
id|fmt
comma
id|ap
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|ap
)paren
suffix:semicolon
)brace
DECL|function|die
r_static
r_inline
r_void
id|die
c_func
(paren
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
id|va_list
id|ap
suffix:semicolon
id|va_start
c_func
(paren
id|ap
comma
id|fmt
)paren
suffix:semicolon
id|error
c_func
(paren
id|fmt
comma
id|ap
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|ap
)paren
suffix:semicolon
m_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
DECL|function|die_errno
r_static
r_inline
r_void
id|die_errno
c_func
(paren
r_int
id|err
)paren
(brace
id|error
c_func
(paren
l_string|&quot;%s&quot;
comma
id|strerror
c_func
(paren
id|err
)paren
)paren
suffix:semicolon
m_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
DECL|function|xstrdup
r_static
r_inline
r_char
op_star
id|xstrdup
c_func
(paren
r_const
r_char
op_star
id|str
)paren
(brace
r_char
op_star
id|ret
op_assign
id|strdup
c_func
(paren
id|str
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|die_errno
c_func
(paren
id|errno
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* ----------------- GNOME Keyring functions ----------------- */
multiline_comment|/* create a special keyring option string, if path is given */
DECL|function|keyring_object
r_static
r_char
op_star
id|keyring_object
c_func
(paren
r_struct
id|credential
op_star
id|c
)paren
(brace
r_char
op_star
id|object
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;path
)paren
r_return
id|object
suffix:semicolon
id|object
op_assign
(paren
r_char
op_star
)paren
id|malloc
c_func
(paren
id|strlen
c_func
(paren
id|c-&gt;host
)paren
op_plus
id|strlen
c_func
(paren
id|c-&gt;path
)paren
op_plus
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|object
)paren
(brace
id|die_errno
c_func
(paren
id|errno
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c-&gt;port
)paren
(brace
id|sprintf
c_func
(paren
id|object
comma
l_string|&quot;%s:%hd/%s&quot;
comma
id|c-&gt;host
comma
id|c-&gt;port
comma
id|c-&gt;path
)paren
suffix:semicolon
)brace
r_else
id|sprintf
c_func
(paren
id|object
comma
l_string|&quot;%s/%s&quot;
comma
id|c-&gt;host
comma
id|c-&gt;path
)paren
suffix:semicolon
r_return
id|object
suffix:semicolon
)brace
DECL|function|keyring_get
r_int
id|keyring_get
c_func
(paren
r_struct
id|credential
op_star
id|c
)paren
(brace
r_char
op_star
id|object
op_assign
l_int|NULL
suffix:semicolon
id|GList
op_star
id|entries
suffix:semicolon
id|GnomeKeyringNetworkPasswordData
op_star
id|password_data
suffix:semicolon
id|GnomeKeyringResult
id|result
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;protocol
op_logical_or
op_logical_neg
(paren
id|c-&gt;host
op_logical_or
id|c-&gt;path
)paren
)paren
r_return
id|EXIT_FAILURE
suffix:semicolon
id|object
op_assign
id|keyring_object
c_func
(paren
id|c
)paren
suffix:semicolon
id|result
op_assign
id|gnome_keyring_find_network_password_sync
c_func
(paren
id|c-&gt;username
comma
l_int|NULL
multiline_comment|/* domain */
comma
id|c-&gt;host
comma
id|object
comma
id|c-&gt;protocol
comma
l_int|NULL
multiline_comment|/* authtype */
comma
id|c-&gt;port
comma
op_amp
id|entries
)paren
suffix:semicolon
id|free
c_func
(paren
id|object
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
id|GNOME_KEYRING_RESULT_NO_MATCH
)paren
r_return
id|EXIT_SUCCESS
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
id|GNOME_KEYRING_RESULT_CANCELLED
)paren
r_return
id|EXIT_SUCCESS
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|GNOME_KEYRING_RESULT_OK
)paren
(brace
id|error
c_func
(paren
l_string|&quot;%s&quot;
comma
id|gnome_keyring_result_to_message
c_func
(paren
id|result
)paren
)paren
suffix:semicolon
r_return
id|EXIT_FAILURE
suffix:semicolon
)brace
multiline_comment|/* pick the first one from the list */
id|password_data
op_assign
(paren
id|GnomeKeyringNetworkPasswordData
op_star
)paren
id|entries-&gt;data
suffix:semicolon
id|free_password
c_func
(paren
id|c-&gt;password
)paren
suffix:semicolon
id|c-&gt;password
op_assign
id|xstrdup
c_func
(paren
id|password_data-&gt;password
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;username
)paren
id|c-&gt;username
op_assign
id|xstrdup
c_func
(paren
id|password_data-&gt;user
)paren
suffix:semicolon
id|gnome_keyring_network_password_list_free
c_func
(paren
id|entries
)paren
suffix:semicolon
r_return
id|EXIT_SUCCESS
suffix:semicolon
)brace
DECL|function|keyring_store
r_int
id|keyring_store
c_func
(paren
r_struct
id|credential
op_star
id|c
)paren
(brace
id|guint32
id|item_id
suffix:semicolon
r_char
op_star
id|object
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Sanity check that what we are storing is actually sensible.&n;&t; * In particular, we can&squot;t make a URL without a protocol field.&n;&t; * Without either a host or pathname (depending on the scheme),&n;&t; * we have no primary key. And without a username and password,&n;&t; * we are not actually storing a credential.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;protocol
op_logical_or
op_logical_neg
(paren
id|c-&gt;host
op_logical_or
id|c-&gt;path
)paren
op_logical_or
op_logical_neg
id|c-&gt;username
op_logical_or
op_logical_neg
id|c-&gt;password
)paren
r_return
id|EXIT_FAILURE
suffix:semicolon
id|object
op_assign
id|keyring_object
c_func
(paren
id|c
)paren
suffix:semicolon
id|gnome_keyring_set_network_password_sync
c_func
(paren
id|GNOME_KEYRING_DEFAULT
comma
id|c-&gt;username
comma
l_int|NULL
multiline_comment|/* domain */
comma
id|c-&gt;host
comma
id|object
comma
id|c-&gt;protocol
comma
l_int|NULL
multiline_comment|/* authtype */
comma
id|c-&gt;port
comma
id|c-&gt;password
comma
op_amp
id|item_id
)paren
suffix:semicolon
id|free
c_func
(paren
id|object
)paren
suffix:semicolon
r_return
id|EXIT_SUCCESS
suffix:semicolon
)brace
DECL|function|keyring_erase
r_int
id|keyring_erase
c_func
(paren
r_struct
id|credential
op_star
id|c
)paren
(brace
r_char
op_star
id|object
op_assign
l_int|NULL
suffix:semicolon
id|GList
op_star
id|entries
suffix:semicolon
id|GnomeKeyringNetworkPasswordData
op_star
id|password_data
suffix:semicolon
id|GnomeKeyringResult
id|result
suffix:semicolon
multiline_comment|/*&n;&t; * Sanity check that we actually have something to match&n;&t; * against. The input we get is a restrictive pattern,&n;&t; * so technically a blank credential means &quot;erase everything&quot;.&n;&t; * But it is too easy to accidentally send this, since it is equivalent&n;&t; * to empty input. So explicitly disallow it, and require that the&n;&t; * pattern have some actual content to match.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;protocol
op_logical_and
op_logical_neg
id|c-&gt;host
op_logical_and
op_logical_neg
id|c-&gt;path
op_logical_and
op_logical_neg
id|c-&gt;username
)paren
r_return
id|EXIT_FAILURE
suffix:semicolon
id|object
op_assign
id|keyring_object
c_func
(paren
id|c
)paren
suffix:semicolon
id|result
op_assign
id|gnome_keyring_find_network_password_sync
c_func
(paren
id|c-&gt;username
comma
l_int|NULL
multiline_comment|/* domain */
comma
id|c-&gt;host
comma
id|object
comma
id|c-&gt;protocol
comma
l_int|NULL
multiline_comment|/* authtype */
comma
id|c-&gt;port
comma
op_amp
id|entries
)paren
suffix:semicolon
id|free
c_func
(paren
id|object
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
id|GNOME_KEYRING_RESULT_NO_MATCH
)paren
r_return
id|EXIT_SUCCESS
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
id|GNOME_KEYRING_RESULT_CANCELLED
)paren
r_return
id|EXIT_SUCCESS
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|GNOME_KEYRING_RESULT_OK
)paren
(brace
id|error
c_func
(paren
l_string|&quot;%s&quot;
comma
id|gnome_keyring_result_to_message
c_func
(paren
id|result
)paren
)paren
suffix:semicolon
r_return
id|EXIT_FAILURE
suffix:semicolon
)brace
multiline_comment|/* pick the first one from the list (delete all matches?) */
id|password_data
op_assign
(paren
id|GnomeKeyringNetworkPasswordData
op_star
)paren
id|entries-&gt;data
suffix:semicolon
id|result
op_assign
id|gnome_keyring_item_delete_sync
c_func
(paren
id|password_data-&gt;keyring
comma
id|password_data-&gt;item_id
)paren
suffix:semicolon
id|gnome_keyring_network_password_list_free
c_func
(paren
id|entries
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|GNOME_KEYRING_RESULT_OK
)paren
(brace
id|error
c_func
(paren
l_string|&quot;%s&quot;
comma
id|gnome_keyring_result_to_message
c_func
(paren
id|result
)paren
)paren
suffix:semicolon
r_return
id|EXIT_FAILURE
suffix:semicolon
)brace
r_return
id|EXIT_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*&n; * Table with helper operation callbacks, used by generic&n; * credential helper main function.&n; */
DECL|variable|credential_helper_ops
r_struct
id|credential_operation
r_const
id|credential_helper_ops
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;get&quot;
comma
id|keyring_get
)brace
comma
(brace
l_string|&quot;store&quot;
comma
id|keyring_store
)brace
comma
(brace
l_string|&quot;erase&quot;
comma
id|keyring_erase
)brace
comma
id|CREDENTIAL_OP_END
)brace
suffix:semicolon
multiline_comment|/* ------------------ credential functions ------------------ */
DECL|function|credential_init
r_void
id|credential_init
c_func
(paren
r_struct
id|credential
op_star
id|c
)paren
(brace
id|memset
c_func
(paren
id|c
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|c
)paren
)paren
suffix:semicolon
)brace
DECL|function|credential_clear
r_void
id|credential_clear
c_func
(paren
r_struct
id|credential
op_star
id|c
)paren
(brace
id|free
c_func
(paren
id|c-&gt;protocol
)paren
suffix:semicolon
id|free
c_func
(paren
id|c-&gt;host
)paren
suffix:semicolon
id|free
c_func
(paren
id|c-&gt;path
)paren
suffix:semicolon
id|free
c_func
(paren
id|c-&gt;username
)paren
suffix:semicolon
id|free_password
c_func
(paren
id|c-&gt;password
)paren
suffix:semicolon
id|credential_init
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
DECL|function|credential_read
r_int
id|credential_read
c_func
(paren
r_struct
id|credential
op_star
id|c
)paren
(brace
r_char
id|buf
(braket
l_int|1024
)braket
suffix:semicolon
id|ssize_t
id|line_len
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|key
op_assign
id|buf
suffix:semicolon
r_char
op_star
id|value
suffix:semicolon
r_while
c_loop
(paren
id|fgets
c_func
(paren
id|buf
comma
r_sizeof
(paren
id|buf
)paren
comma
id|stdin
)paren
)paren
(brace
id|line_len
op_assign
id|strlen
c_func
(paren
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf
(braket
id|line_len
op_minus
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|buf
(braket
op_decrement
id|line_len
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|line_len
)paren
(brace
r_break
suffix:semicolon
)brace
id|value
op_assign
id|strchr
c_func
(paren
id|buf
comma
l_char|&squot;=&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
(brace
id|warning
c_func
(paren
l_string|&quot;invalid credential line: %s&quot;
comma
id|key
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
op_star
id|value
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|key
comma
l_string|&quot;protocol&quot;
)paren
)paren
(brace
id|free
c_func
(paren
id|c-&gt;protocol
)paren
suffix:semicolon
id|c-&gt;protocol
op_assign
id|xstrdup
c_func
(paren
id|value
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|key
comma
l_string|&quot;host&quot;
)paren
)paren
(brace
id|free
c_func
(paren
id|c-&gt;host
)paren
suffix:semicolon
id|c-&gt;host
op_assign
id|xstrdup
c_func
(paren
id|value
)paren
suffix:semicolon
id|value
op_assign
id|strrchr
c_func
(paren
id|c-&gt;host
comma
l_char|&squot;:&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
)paren
(brace
op_star
id|value
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|c-&gt;port
op_assign
id|atoi
c_func
(paren
id|value
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|key
comma
l_string|&quot;path&quot;
)paren
)paren
(brace
id|free
c_func
(paren
id|c-&gt;path
)paren
suffix:semicolon
id|c-&gt;path
op_assign
id|xstrdup
c_func
(paren
id|value
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|key
comma
l_string|&quot;username&quot;
)paren
)paren
(brace
id|free
c_func
(paren
id|c-&gt;username
)paren
suffix:semicolon
id|c-&gt;username
op_assign
id|xstrdup
c_func
(paren
id|value
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|key
comma
l_string|&quot;password&quot;
)paren
)paren
(brace
id|free_password
c_func
(paren
id|c-&gt;password
)paren
suffix:semicolon
id|c-&gt;password
op_assign
id|xstrdup
c_func
(paren
id|value
)paren
suffix:semicolon
r_while
c_loop
(paren
op_star
id|value
)paren
op_star
id|value
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Ignore other lines; we don&squot;t know what they mean, but&n;&t;&t; * this future-proofs us when later versions of git do&n;&t;&t; * learn new lines, and the helpers are updated to match.&n;&t;&t; */
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|credential_write_item
r_void
id|credential_write_item
c_func
(paren
id|FILE
op_star
id|fp
comma
r_const
r_char
op_star
id|key
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
r_return
suffix:semicolon
id|fprintf
c_func
(paren
id|fp
comma
l_string|&quot;%s=%s&bslash;n&quot;
comma
id|key
comma
id|value
)paren
suffix:semicolon
)brace
DECL|function|credential_write
r_void
id|credential_write
c_func
(paren
r_const
r_struct
id|credential
op_star
id|c
)paren
(brace
multiline_comment|/* only write username/password, if set */
id|credential_write_item
c_func
(paren
id|stdout
comma
l_string|&quot;username&quot;
comma
id|c-&gt;username
)paren
suffix:semicolon
id|credential_write_item
c_func
(paren
id|stdout
comma
l_string|&quot;password&quot;
comma
id|c-&gt;password
)paren
suffix:semicolon
)brace
DECL|function|usage
r_static
r_void
id|usage
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|credential_operation
r_const
op_star
id|try_op
op_assign
id|credential_helper_ops
suffix:semicolon
r_const
r_char
op_star
id|basename
op_assign
id|strrchr
c_func
(paren
id|name
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
id|basename
op_assign
(paren
id|basename
)paren
ques
c_cond
id|basename
op_plus
l_int|1
suffix:colon
id|name
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Usage: %s &lt;&quot;
comma
id|basename
)paren
suffix:semicolon
r_while
c_loop
(paren
id|try_op-&gt;name
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s&quot;
comma
(paren
id|try_op
op_increment
)paren
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|try_op-&gt;name
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;|&quot;
)paren
suffix:semicolon
)brace
)brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;&gt;&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|main
r_int
id|main
c_func
(paren
r_int
id|argc
comma
r_char
op_star
id|argv
(braket
)braket
)paren
(brace
r_int
id|ret
op_assign
id|EXIT_SUCCESS
suffix:semicolon
r_struct
id|credential_operation
r_const
op_star
id|try_op
op_assign
id|credential_helper_ops
suffix:semicolon
r_struct
id|credential
id|cred
op_assign
id|CREDENTIAL_INIT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|argv
(braket
l_int|1
)braket
)paren
(brace
id|usage
c_func
(paren
id|argv
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* lookup operation callback */
r_while
c_loop
(paren
id|try_op-&gt;name
op_logical_and
id|strcmp
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
id|try_op-&gt;name
)paren
)paren
(brace
id|try_op
op_increment
suffix:semicolon
)brace
multiline_comment|/* unsupported operation given -- ignore silently */
r_if
c_cond
(paren
op_logical_neg
id|try_op-&gt;name
op_logical_or
op_logical_neg
id|try_op-&gt;op
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
id|ret
op_assign
id|credential_read
c_func
(paren
op_amp
id|cred
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* perform credential operation */
id|ret
op_assign
(paren
op_star
id|try_op-&gt;op
)paren
(paren
op_amp
id|cred
)paren
suffix:semicolon
id|credential_write
c_func
(paren
op_amp
id|cred
)paren
suffix:semicolon
id|out
suffix:colon
id|credential_clear
c_func
(paren
op_amp
id|cred
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
eof
