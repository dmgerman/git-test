macro_line|#include &quot;git-compat-util.h&quot;
macro_line|#include &quot;urlmatch.h&quot;
DECL|function|main
r_int
id|main
c_func
(paren
r_int
id|argc
comma
r_char
op_star
op_star
id|argv
)paren
(brace
r_const
r_char
id|usage
(braket
)braket
op_assign
l_string|&quot;test-urlmatch-normalization [-p | -l] &lt;url1&gt; | &lt;url1&gt; &lt;url2&gt;&quot;
suffix:semicolon
r_char
op_star
id|url1
comma
op_star
id|url2
suffix:semicolon
r_int
id|opt_p
op_assign
l_int|0
comma
id|opt_l
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * For one url, succeed if url_normalize succeeds on it, fail otherwise.&n;&t; * For two urls, succeed only if url_normalize succeeds on both and&n;&t; * the results compare equal with strcmp.  If -p is given (one url only)&n;&t; * and url_normalize succeeds, print the result followed by &quot;&bslash;n&quot;.  If&n;&t; * -l is given (one url only) and url_normalize succeeds, print the&n;&t; * returned length in decimal followed by &quot;&bslash;n&quot;.&n;&t; */
r_if
c_cond
(paren
id|argc
OG
l_int|1
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
l_string|&quot;-p&quot;
)paren
)paren
(brace
id|opt_p
op_assign
l_int|1
suffix:semicolon
id|argc
op_decrement
suffix:semicolon
id|argv
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|argc
OG
l_int|1
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
l_string|&quot;-l&quot;
)paren
)paren
(brace
id|opt_l
op_assign
l_int|1
suffix:semicolon
id|argc
op_decrement
suffix:semicolon
id|argv
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|argc
template_param
l_int|3
)paren
id|die
c_func
(paren
l_string|&quot;%s&quot;
comma
id|usage
)paren
suffix:semicolon
r_if
c_cond
(paren
id|argc
op_eq
l_int|2
)paren
(brace
r_struct
id|url_info
id|info
suffix:semicolon
id|url1
op_assign
id|url_normalize
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
op_amp
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|url1
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|opt_p
)paren
id|printf
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|url1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opt_l
)paren
id|printf
c_func
(paren
l_string|&quot;%u&bslash;n&quot;
comma
(paren
r_int
)paren
id|info.url_len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|opt_p
op_logical_or
id|opt_l
)paren
id|die
c_func
(paren
l_string|&quot;%s&quot;
comma
id|usage
)paren
suffix:semicolon
id|url1
op_assign
id|url_normalize
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
l_int|NULL
)paren
suffix:semicolon
id|url2
op_assign
id|url_normalize
c_func
(paren
id|argv
(braket
l_int|2
)braket
comma
l_int|NULL
)paren
suffix:semicolon
r_return
(paren
id|url1
op_logical_and
id|url2
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|url1
comma
id|url2
)paren
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
)brace
eof
