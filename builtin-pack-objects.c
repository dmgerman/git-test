macro_line|#include &quot;builtin.h&quot;
macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;attr.h&quot;
macro_line|#include &quot;object.h&quot;
macro_line|#include &quot;blob.h&quot;
macro_line|#include &quot;commit.h&quot;
macro_line|#include &quot;tag.h&quot;
macro_line|#include &quot;tree.h&quot;
macro_line|#include &quot;delta.h&quot;
macro_line|#include &quot;pack.h&quot;
macro_line|#include &quot;csum-file.h&quot;
macro_line|#include &quot;tree-walk.h&quot;
macro_line|#include &quot;diff.h&quot;
macro_line|#include &quot;revision.h&quot;
macro_line|#include &quot;list-objects.h&quot;
macro_line|#include &quot;progress.h&quot;
DECL|variable|pack_usage
r_static
r_const
r_char
id|pack_usage
(braket
)braket
op_assign
l_string|&quot;&bslash;&n;git-pack-objects [{ -q | --progress | --all-progress }] &bslash;n&bslash;&n;&t;[--max-pack-size=N] [--local] [--incremental] &bslash;n&bslash;&n;&t;[--window=N] [--window-memory=N] [--depth=N] &bslash;n&bslash;&n;&t;[--no-reuse-delta] [--no-reuse-object] [--delta-base-offset] &bslash;n&bslash;&n;&t;[--non-empty] [--revs [--unpacked | --all]*] [--reflog] &bslash;n&bslash;&n;&t;[--stdout | base-name] [&lt;ref-list | &lt;object-list]&quot;
suffix:semicolon
DECL|struct|object_entry
r_struct
id|object_entry
(brace
DECL|member|idx
r_struct
id|pack_idx_entry
id|idx
suffix:semicolon
DECL|member|size
r_int
r_int
id|size
suffix:semicolon
multiline_comment|/* uncompressed size */
DECL|member|in_pack
r_struct
id|packed_git
op_star
id|in_pack
suffix:semicolon
multiline_comment|/* already in pack */
DECL|member|in_pack_offset
id|off_t
id|in_pack_offset
suffix:semicolon
DECL|member|delta
r_struct
id|object_entry
op_star
id|delta
suffix:semicolon
multiline_comment|/* delta base object */
DECL|member|delta_child
r_struct
id|object_entry
op_star
id|delta_child
suffix:semicolon
multiline_comment|/* deltified objects who bases me */
DECL|member|delta_sibling
r_struct
id|object_entry
op_star
id|delta_sibling
suffix:semicolon
multiline_comment|/* other deltified objects who&n;&t;&t;&t;&t;&t;     * uses the same base as me&n;&t;&t;&t;&t;&t;     */
DECL|member|delta_data
r_void
op_star
id|delta_data
suffix:semicolon
multiline_comment|/* cached delta (uncompressed) */
DECL|member|delta_size
r_int
r_int
id|delta_size
suffix:semicolon
multiline_comment|/* delta data size (uncompressed) */
DECL|member|hash
r_int
r_int
id|hash
suffix:semicolon
multiline_comment|/* name hint hash */
DECL|member|type
r_enum
id|object_type
id|type
suffix:semicolon
DECL|member|in_pack_type
r_enum
id|object_type
id|in_pack_type
suffix:semicolon
multiline_comment|/* could be delta */
DECL|member|in_pack_header_size
r_int
r_char
id|in_pack_header_size
suffix:semicolon
DECL|member|preferred_base
r_int
r_char
id|preferred_base
suffix:semicolon
multiline_comment|/* we do not pack this, but is available&n;&t;&t;&t;&t;       * to be used as the base object to delta&n;&t;&t;&t;&t;       * objects against.&n;&t;&t;&t;&t;       */
DECL|member|no_try_delta
r_int
r_char
id|no_try_delta
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Objects we are going to pack are collected in objects array (dynamically&n; * expanded).  nr_objects &amp; nr_alloc controls this array.  They are stored&n; * in the order we see -- typically rev-list --objects order that gives us&n; * nice &quot;minimum seek&quot; order.&n; */
DECL|variable|objects
r_static
r_struct
id|object_entry
op_star
id|objects
suffix:semicolon
DECL|variable|written_list
r_static
r_struct
id|object_entry
op_star
op_star
id|written_list
suffix:semicolon
DECL|variable|nr_objects
DECL|variable|nr_alloc
DECL|variable|nr_result
DECL|variable|nr_written
r_static
r_uint32
id|nr_objects
comma
id|nr_alloc
comma
id|nr_result
comma
id|nr_written
suffix:semicolon
DECL|variable|non_empty
r_static
r_int
id|non_empty
suffix:semicolon
DECL|variable|no_reuse_delta
DECL|variable|no_reuse_object
r_static
r_int
id|no_reuse_delta
comma
id|no_reuse_object
suffix:semicolon
DECL|variable|local
r_static
r_int
id|local
suffix:semicolon
DECL|variable|incremental
r_static
r_int
id|incremental
suffix:semicolon
DECL|variable|allow_ofs_delta
r_static
r_int
id|allow_ofs_delta
suffix:semicolon
DECL|variable|pack_tmp_name
DECL|variable|idx_tmp_name
r_static
r_const
r_char
op_star
id|pack_tmp_name
comma
op_star
id|idx_tmp_name
suffix:semicolon
DECL|variable|tmpname
r_static
r_char
id|tmpname
(braket
id|PATH_MAX
)braket
suffix:semicolon
DECL|variable|base_name
r_static
r_const
r_char
op_star
id|base_name
suffix:semicolon
DECL|variable|progress
r_static
r_int
id|progress
op_assign
l_int|1
suffix:semicolon
DECL|variable|window
r_static
r_int
id|window
op_assign
l_int|10
suffix:semicolon
DECL|variable|pack_size_limit
r_static
r_uint32
id|pack_size_limit
suffix:semicolon
DECL|variable|depth
r_static
r_int
id|depth
op_assign
l_int|50
suffix:semicolon
DECL|variable|pack_to_stdout
r_static
r_int
id|pack_to_stdout
suffix:semicolon
DECL|variable|num_preferred_base
r_static
r_int
id|num_preferred_base
suffix:semicolon
DECL|variable|progress_state
r_static
r_struct
id|progress
id|progress_state
suffix:semicolon
DECL|variable|pack_compression_level
r_static
r_int
id|pack_compression_level
op_assign
id|Z_DEFAULT_COMPRESSION
suffix:semicolon
DECL|variable|pack_compression_seen
r_static
r_int
id|pack_compression_seen
suffix:semicolon
DECL|variable|delta_cache_size
r_static
r_int
r_int
id|delta_cache_size
op_assign
l_int|0
suffix:semicolon
DECL|variable|max_delta_cache_size
r_static
r_int
r_int
id|max_delta_cache_size
op_assign
l_int|0
suffix:semicolon
DECL|variable|cache_max_small_delta_size
r_static
r_int
r_int
id|cache_max_small_delta_size
op_assign
l_int|1000
suffix:semicolon
DECL|variable|window_memory_usage
r_static
r_int
r_int
id|window_memory_usage
op_assign
l_int|0
suffix:semicolon
DECL|variable|window_memory_limit
r_static
r_int
r_int
id|window_memory_limit
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * The object names in objects array are hashed with this hashtable,&n; * to help looking up the entry by object name.&n; * This hashtable is built after all the objects are seen.&n; */
DECL|variable|object_ix
r_static
r_int
op_star
id|object_ix
suffix:semicolon
DECL|variable|object_ix_hashsz
r_static
r_int
id|object_ix_hashsz
suffix:semicolon
multiline_comment|/*&n; * Pack index for existing packs give us easy access to the offsets into&n; * corresponding pack file where each object&squot;s data starts, but the entries&n; * do not store the size of the compressed representation (uncompressed&n; * size is easily available by examining the pack entry header).  It is&n; * also rather expensive to find the sha1 for an object given its offset.&n; *&n; * We build a hashtable of existing packs (pack_revindex), and keep reverse&n; * index here -- pack index file is sorted by object name mapping to offset;&n; * this pack_revindex[].revindex array is a list of offset/index_nr pairs&n; * ordered by offset, so if you know the offset of an object, next offset&n; * is where its packed representation ends and the index_nr can be used to&n; * get the object sha1 from the main index.&n; */
DECL|struct|revindex_entry
r_struct
id|revindex_entry
(brace
DECL|member|offset
id|off_t
id|offset
suffix:semicolon
DECL|member|nr
r_int
r_int
id|nr
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|pack_revindex
r_struct
id|pack_revindex
(brace
DECL|member|p
r_struct
id|packed_git
op_star
id|p
suffix:semicolon
DECL|member|revindex
r_struct
id|revindex_entry
op_star
id|revindex
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|pack_revindex
r_static
r_struct
id|pack_revindex
op_star
id|pack_revindex
suffix:semicolon
DECL|variable|pack_revindex_hashsz
r_static
r_int
id|pack_revindex_hashsz
suffix:semicolon
multiline_comment|/*&n; * stats&n; */
DECL|variable|written
DECL|variable|written_delta
r_static
r_uint32
id|written
comma
id|written_delta
suffix:semicolon
DECL|variable|reused
DECL|variable|reused_delta
r_static
r_uint32
id|reused
comma
id|reused_delta
suffix:semicolon
DECL|function|pack_revindex_ix
r_static
r_int
id|pack_revindex_ix
c_func
(paren
r_struct
id|packed_git
op_star
id|p
)paren
(brace
r_int
r_int
id|ui
op_assign
(paren
r_int
r_int
)paren
id|p
suffix:semicolon
r_int
id|i
suffix:semicolon
id|ui
op_assign
id|ui
op_xor
(paren
id|ui
op_rshift
l_int|16
)paren
suffix:semicolon
multiline_comment|/* defeat structure alignment */
id|i
op_assign
(paren
r_int
)paren
(paren
id|ui
op_mod
id|pack_revindex_hashsz
)paren
suffix:semicolon
r_while
c_loop
(paren
id|pack_revindex
(braket
id|i
)braket
dot
id|p
)paren
(brace
r_if
c_cond
(paren
id|pack_revindex
(braket
id|i
)braket
dot
id|p
op_eq
id|p
)paren
r_return
id|i
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|i
op_eq
id|pack_revindex_hashsz
)paren
id|i
op_assign
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
id|i
suffix:semicolon
)brace
DECL|function|prepare_pack_ix
r_static
r_void
id|prepare_pack_ix
c_func
(paren
r_void
)paren
(brace
r_int
id|num
suffix:semicolon
r_struct
id|packed_git
op_star
id|p
suffix:semicolon
r_for
c_loop
(paren
id|num
op_assign
l_int|0
comma
id|p
op_assign
id|packed_git
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
id|num
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|num
)paren
r_return
suffix:semicolon
id|pack_revindex_hashsz
op_assign
id|num
op_star
l_int|11
suffix:semicolon
id|pack_revindex
op_assign
id|xcalloc
c_func
(paren
r_sizeof
(paren
op_star
id|pack_revindex
)paren
comma
id|pack_revindex_hashsz
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|packed_git
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
id|num
op_assign
id|pack_revindex_ix
c_func
(paren
id|p
)paren
suffix:semicolon
id|num
op_assign
l_int|1
id|num
suffix:semicolon
id|pack_revindex
(braket
id|num
)braket
dot
id|p
op_assign
id|p
suffix:semicolon
)brace
multiline_comment|/* revindex elements are lazily initialized */
)brace
DECL|function|cmp_offset
r_static
r_int
id|cmp_offset
c_func
(paren
r_const
r_void
op_star
id|a_
comma
r_const
r_void
op_star
id|b_
)paren
(brace
r_const
r_struct
id|revindex_entry
op_star
id|a
op_assign
id|a_
suffix:semicolon
r_const
r_struct
id|revindex_entry
op_star
id|b
op_assign
id|b_
suffix:semicolon
r_return
(paren
id|a-&gt;offset
OL
id|b-&gt;offset
)paren
ques
c_cond
l_int|1
suffix:colon
(paren
id|a-&gt;offset
OG
id|b-&gt;offset
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Ordered list of offsets of objects in the pack.&n; */
DECL|function|prepare_pack_revindex
r_static
r_void
id|prepare_pack_revindex
c_func
(paren
r_struct
id|pack_revindex
op_star
id|rix
)paren
(brace
r_struct
id|packed_git
op_star
id|p
op_assign
id|rix-&gt;p
suffix:semicolon
r_int
id|num_ent
op_assign
id|p-&gt;num_objects
suffix:semicolon
r_int
id|i
suffix:semicolon
r_const
r_char
op_star
id|index
op_assign
id|p-&gt;index_data
suffix:semicolon
id|rix-&gt;revindex
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|rix-&gt;revindex
)paren
op_star
(paren
id|num_ent
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|index
op_add_assign
l_int|4
op_star
l_int|256
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;index_version
OG
l_int|1
)paren
(brace
r_const
r_uint32
op_star
id|off_32
op_assign
(paren
r_uint32
op_star
)paren
(paren
id|index
op_plus
l_int|8
op_plus
id|p-&gt;num_objects
op_star
(paren
l_int|20
op_plus
l_int|4
)paren
)paren
suffix:semicolon
r_const
r_uint32
op_star
id|off_64
op_assign
id|off_32
op_plus
id|p-&gt;num_objects
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_ent
suffix:semicolon
id|i
op_increment
)paren
(brace
r_uint32
id|off
op_assign
id|ntohl
c_func
(paren
op_star
id|off_32
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|off
op_amp
l_int|0x80000000
)paren
)paren
(brace
id|rix-&gt;revindex
(braket
id|i
)braket
dot
id|offset
op_assign
id|off
suffix:semicolon
)brace
r_else
(brace
id|rix-&gt;revindex
(braket
id|i
)braket
dot
id|offset
op_assign
(paren
(paren
r_uint64
)paren
id|ntohl
c_func
(paren
op_star
id|off_64
op_increment
)paren
)paren
op_lshift
l_int|32
suffix:semicolon
id|rix-&gt;revindex
(braket
id|i
)braket
dot
id|offset
op_or_assign
id|ntohl
c_func
(paren
op_star
id|off_64
op_increment
)paren
suffix:semicolon
)brace
id|rix-&gt;revindex
(braket
id|i
)braket
dot
id|nr
op_assign
id|i
suffix:semicolon
)brace
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_ent
suffix:semicolon
id|i
op_increment
)paren
(brace
r_uint32
id|hl
op_assign
op_star
(paren
(paren
r_uint32
op_star
)paren
(paren
id|index
op_plus
l_int|24
op_star
id|i
)paren
)paren
suffix:semicolon
id|rix-&gt;revindex
(braket
id|i
)braket
dot
id|offset
op_assign
id|ntohl
c_func
(paren
id|hl
)paren
suffix:semicolon
id|rix-&gt;revindex
(braket
id|i
)braket
dot
id|nr
op_assign
id|i
suffix:semicolon
)brace
)brace
multiline_comment|/* This knows the pack format -- the 20-byte trailer&n;&t; * follows immediately after the last object data.&n;&t; */
id|rix-&gt;revindex
(braket
id|num_ent
)braket
dot
id|offset
op_assign
id|p-&gt;pack_size
l_int|20
suffix:semicolon
id|rix-&gt;revindex
(braket
id|num_ent
)braket
dot
id|nr
op_assign
l_int|1
suffix:semicolon
id|qsort
c_func
(paren
id|rix-&gt;revindex
comma
id|num_ent
comma
r_sizeof
(paren
op_star
id|rix-&gt;revindex
)paren
comma
id|cmp_offset
)paren
suffix:semicolon
)brace
DECL|function|find_packed_object
r_static
r_struct
id|revindex_entry
op_star
id|find_packed_object
c_func
(paren
r_struct
id|packed_git
op_star
id|p
comma
id|off_t
id|ofs
)paren
(brace
r_int
id|num
suffix:semicolon
r_int
id|lo
comma
id|hi
suffix:semicolon
r_struct
id|pack_revindex
op_star
id|rix
suffix:semicolon
r_struct
id|revindex_entry
op_star
id|revindex
suffix:semicolon
id|num
op_assign
id|pack_revindex_ix
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|num
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;internal error: pack revindex uninitialized&quot;
)paren
suffix:semicolon
id|rix
op_assign
op_amp
id|pack_revindex
(braket
id|num
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rix-&gt;revindex
)paren
id|prepare_pack_revindex
c_func
(paren
id|rix
)paren
suffix:semicolon
id|revindex
op_assign
id|rix-&gt;revindex
suffix:semicolon
id|lo
op_assign
l_int|0
suffix:semicolon
id|hi
op_assign
id|p-&gt;num_objects
op_plus
l_int|1
suffix:semicolon
r_do
(brace
r_int
id|mi
op_assign
(paren
id|lo
op_plus
id|hi
)paren
op_div
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|revindex
(braket
id|mi
)braket
dot
id|offset
op_eq
id|ofs
)paren
(brace
r_return
id|revindex
op_plus
id|mi
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ofs
OL
id|revindex
(braket
id|mi
)braket
dot
id|offset
)paren
id|hi
op_assign
id|mi
suffix:semicolon
r_else
id|lo
op_assign
id|mi
op_plus
l_int|1
suffix:semicolon
)brace
r_while
c_loop
(paren
id|lo
OL
id|hi
)paren
suffix:semicolon
id|die
c_func
(paren
l_string|&quot;internal error: pack revindex corrupt&quot;
)paren
suffix:semicolon
)brace
DECL|function|find_packed_object_name
r_static
r_const
r_int
r_char
op_star
id|find_packed_object_name
c_func
(paren
r_struct
id|packed_git
op_star
id|p
comma
id|off_t
id|ofs
)paren
(brace
r_struct
id|revindex_entry
op_star
id|entry
op_assign
id|find_packed_object
c_func
(paren
id|p
comma
id|ofs
)paren
suffix:semicolon
r_return
id|nth_packed_object_sha1
c_func
(paren
id|p
comma
id|entry-&gt;nr
)paren
suffix:semicolon
)brace
DECL|function|delta_against
r_static
r_void
op_star
id|delta_against
c_func
(paren
r_void
op_star
id|buf
comma
r_int
r_int
id|size
comma
r_struct
id|object_entry
op_star
id|entry
)paren
(brace
r_int
r_int
id|othersize
comma
id|delta_size
suffix:semicolon
r_enum
id|object_type
id|type
suffix:semicolon
r_void
op_star
id|otherbuf
op_assign
id|read_sha1_file
c_func
(paren
id|entry-&gt;delta-&gt;idx.sha1
comma
op_amp
id|type
comma
op_amp
id|othersize
)paren
suffix:semicolon
r_void
op_star
id|delta_buf
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|otherbuf
)paren
id|die
c_func
(paren
l_string|&quot;unable to read %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|entry-&gt;delta-&gt;idx.sha1
)paren
)paren
suffix:semicolon
id|delta_buf
op_assign
id|diff_delta
c_func
(paren
id|otherbuf
comma
id|othersize
comma
id|buf
comma
id|size
comma
op_amp
id|delta_size
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|delta_buf
op_logical_or
id|delta_size
op_ne
id|entry-&gt;delta_size
)paren
id|die
c_func
(paren
l_string|&quot;delta size changed&quot;
)paren
suffix:semicolon
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
id|free
c_func
(paren
id|otherbuf
)paren
suffix:semicolon
r_return
id|delta_buf
suffix:semicolon
)brace
multiline_comment|/*&n; * The per-object header is a pretty dense thing, which is&n; *  - first byte: low four bits are &quot;size&quot;, then three bits of &quot;type&quot;,&n; *    and the high bit is &quot;size continues&quot;.&n; *  - each byte afterwards: low seven bits are size continuation,&n; *    with the high bit being &quot;size continues&quot;&n; */
DECL|function|encode_header
r_static
r_int
id|encode_header
c_func
(paren
r_enum
id|object_type
id|type
comma
r_int
r_int
id|size
comma
r_int
r_char
op_star
id|hdr
)paren
(brace
r_int
id|n
op_assign
l_int|1
suffix:semicolon
r_int
r_char
id|c
suffix:semicolon
r_if
c_cond
(paren
id|type
template_param
id|OBJ_REF_DELTA
)paren
id|die
c_func
(paren
l_string|&quot;bad type %d&quot;
comma
id|type
)paren
suffix:semicolon
id|c
op_assign
(paren
id|type
op_lshift
l_int|4
)paren
op_or
(paren
id|size
op_amp
l_int|15
)paren
suffix:semicolon
id|size
op_rshift_assign
l_int|4
suffix:semicolon
r_while
c_loop
(paren
id|size
)paren
(brace
op_star
id|hdr
op_increment
op_assign
id|c
op_or
l_int|0x80
suffix:semicolon
id|c
op_assign
id|size
op_amp
l_int|0x7f
suffix:semicolon
id|size
op_rshift_assign
l_int|7
suffix:semicolon
id|n
op_increment
suffix:semicolon
)brace
op_star
id|hdr
op_assign
id|c
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
multiline_comment|/*&n; * we are going to reuse the existing object data as is.  make&n; * sure it is not corrupt.&n; */
DECL|function|check_pack_inflate
r_static
r_int
id|check_pack_inflate
c_func
(paren
r_struct
id|packed_git
op_star
id|p
comma
r_struct
id|pack_window
op_star
op_star
id|w_curs
comma
id|off_t
id|offset
comma
id|off_t
id|len
comma
r_int
r_int
id|expect
)paren
(brace
id|z_stream
id|stream
suffix:semicolon
r_int
r_char
id|fakebuf
(braket
l_int|4096
)braket
comma
op_star
id|in
suffix:semicolon
r_int
id|st
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|stream
comma
l_int|0
comma
r_sizeof
(paren
id|stream
)paren
)paren
suffix:semicolon
id|inflateInit
c_func
(paren
op_amp
id|stream
)paren
suffix:semicolon
r_do
(brace
id|in
op_assign
id|use_pack
c_func
(paren
id|p
comma
id|w_curs
comma
id|offset
comma
op_amp
id|stream.avail_in
)paren
suffix:semicolon
id|stream.next_in
op_assign
id|in
suffix:semicolon
id|stream.next_out
op_assign
id|fakebuf
suffix:semicolon
id|stream.avail_out
op_assign
r_sizeof
(paren
id|fakebuf
)paren
suffix:semicolon
id|st
op_assign
id|inflate
c_func
(paren
op_amp
id|stream
comma
id|Z_FINISH
)paren
suffix:semicolon
id|offset
op_add_assign
id|stream.next_in
id|in
suffix:semicolon
)brace
r_while
c_loop
(paren
id|st
op_eq
id|Z_OK
op_logical_or
id|st
op_eq
id|Z_BUF_ERROR
)paren
suffix:semicolon
id|inflateEnd
c_func
(paren
op_amp
id|stream
)paren
suffix:semicolon
r_return
(paren
id|st
op_eq
id|Z_STREAM_END
op_logical_and
id|stream.total_out
op_eq
id|expect
op_logical_and
id|stream.total_in
op_eq
id|len
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
)brace
DECL|function|check_pack_crc
r_static
r_int
id|check_pack_crc
c_func
(paren
r_struct
id|packed_git
op_star
id|p
comma
r_struct
id|pack_window
op_star
op_star
id|w_curs
comma
id|off_t
id|offset
comma
id|off_t
id|len
comma
r_int
r_int
id|nr
)paren
(brace
r_const
r_uint32
op_star
id|index_crc
suffix:semicolon
r_uint32
id|data_crc
op_assign
id|crc32
c_func
(paren
l_int|0
comma
id|Z_NULL
comma
l_int|0
)paren
suffix:semicolon
r_do
(brace
r_int
r_int
id|avail
suffix:semicolon
r_void
op_star
id|data
op_assign
id|use_pack
c_func
(paren
id|p
comma
id|w_curs
comma
id|offset
comma
op_amp
id|avail
)paren
suffix:semicolon
r_if
c_cond
(paren
id|avail
OG
id|len
)paren
id|avail
op_assign
id|len
suffix:semicolon
id|data_crc
op_assign
id|crc32
c_func
(paren
id|data_crc
comma
id|data
comma
id|avail
)paren
suffix:semicolon
id|offset
op_add_assign
id|avail
suffix:semicolon
id|len
op_sub_assign
id|avail
suffix:semicolon
)brace
r_while
c_loop
(paren
id|len
)paren
suffix:semicolon
id|index_crc
op_assign
id|p-&gt;index_data
suffix:semicolon
id|index_crc
op_add_assign
l_int|2
op_plus
l_int|256
op_plus
id|p-&gt;num_objects
op_star
(paren
l_int|20
op_div
l_int|4
)paren
op_plus
id|nr
suffix:semicolon
r_return
id|data_crc
op_ne
id|ntohl
c_func
(paren
op_star
id|index_crc
)paren
suffix:semicolon
)brace
DECL|function|copy_pack_data
r_static
r_void
id|copy_pack_data
c_func
(paren
r_struct
id|sha1file
op_star
id|f
comma
r_struct
id|packed_git
op_star
id|p
comma
r_struct
id|pack_window
op_star
op_star
id|w_curs
comma
id|off_t
id|offset
comma
id|off_t
id|len
)paren
(brace
r_int
r_char
op_star
id|in
suffix:semicolon
r_int
r_int
id|avail
suffix:semicolon
r_while
c_loop
(paren
id|len
)paren
(brace
id|in
op_assign
id|use_pack
c_func
(paren
id|p
comma
id|w_curs
comma
id|offset
comma
op_amp
id|avail
)paren
suffix:semicolon
r_if
c_cond
(paren
id|avail
OG
id|len
)paren
id|avail
op_assign
(paren
r_int
r_int
)paren
id|len
suffix:semicolon
id|sha1write
c_func
(paren
id|f
comma
id|in
comma
id|avail
)paren
suffix:semicolon
id|offset
op_add_assign
id|avail
suffix:semicolon
id|len
op_sub_assign
id|avail
suffix:semicolon
)brace
)brace
DECL|function|write_object
r_static
r_int
r_int
id|write_object
c_func
(paren
r_struct
id|sha1file
op_star
id|f
comma
r_struct
id|object_entry
op_star
id|entry
comma
id|off_t
id|write_offset
)paren
(brace
r_int
r_int
id|size
suffix:semicolon
r_enum
id|object_type
id|type
suffix:semicolon
r_void
op_star
id|buf
suffix:semicolon
r_int
r_char
id|header
(braket
l_int|10
)braket
suffix:semicolon
r_int
r_char
id|dheader
(braket
l_int|10
)braket
suffix:semicolon
r_int
id|hdrlen
suffix:semicolon
id|off_t
id|datalen
suffix:semicolon
r_enum
id|object_type
id|obj_type
suffix:semicolon
r_int
id|to_reuse
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* write limit if limited packsize and not first object */
r_int
r_int
id|limit
op_assign
id|pack_size_limit
op_logical_and
id|nr_written
ques
c_cond
id|pack_size_limit
id|write_offset
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* no if no delta */
r_int
id|usable_delta
op_assign
op_logical_neg
id|entry-&gt;delta
ques
c_cond
l_int|0
suffix:colon
multiline_comment|/* yes if unlimited packfile */
op_logical_neg
id|pack_size_limit
ques
c_cond
l_int|1
suffix:colon
multiline_comment|/* no if base written to previous pack */
id|entry-&gt;delta-&gt;idx.offset
op_eq
(paren
id|off_t
)paren
op_minus
l_int|1
ques
c_cond
l_int|0
suffix:colon
multiline_comment|/* otherwise double-check written to this&n;&t;&t;&t;&t; * pack,  like we do below&n;&t;&t;&t;&t; */
id|entry-&gt;delta-&gt;idx.offset
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pack_to_stdout
)paren
id|crc32_begin
c_func
(paren
id|f
)paren
suffix:semicolon
id|obj_type
op_assign
id|entry-&gt;type
suffix:semicolon
r_if
c_cond
(paren
id|no_reuse_object
)paren
id|to_reuse
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* explicit */
r_else
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;in_pack
)paren
id|to_reuse
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* can&squot;t reuse what we don&squot;t have */
r_else
r_if
c_cond
(paren
id|obj_type
op_eq
id|OBJ_REF_DELTA
op_logical_or
id|obj_type
op_eq
id|OBJ_OFS_DELTA
)paren
multiline_comment|/* check_object() decided it for us ... */
id|to_reuse
op_assign
id|usable_delta
suffix:semicolon
multiline_comment|/* ... but pack split may override that */
r_else
r_if
c_cond
(paren
id|obj_type
op_ne
id|entry-&gt;in_pack_type
)paren
id|to_reuse
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* pack has delta which is unusable */
r_else
r_if
c_cond
(paren
id|entry-&gt;delta
)paren
id|to_reuse
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* we want to pack afresh */
r_else
id|to_reuse
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* we have it in-pack undeltified,&n;&t;&t;&t;&t; * and we do not need to deltify it.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|to_reuse
)paren
(brace
id|z_stream
id|stream
suffix:semicolon
r_int
r_int
id|maxsize
suffix:semicolon
r_void
op_star
id|out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|usable_delta
)paren
(brace
id|buf
op_assign
id|read_sha1_file
c_func
(paren
id|entry-&gt;idx.sha1
comma
op_amp
id|obj_type
comma
op_amp
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
id|die
c_func
(paren
l_string|&quot;unable to read %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|entry-&gt;idx.sha1
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|entry-&gt;delta_data
)paren
(brace
id|size
op_assign
id|entry-&gt;delta_size
suffix:semicolon
id|buf
op_assign
id|entry-&gt;delta_data
suffix:semicolon
id|entry-&gt;delta_data
op_assign
l_int|NULL
suffix:semicolon
id|obj_type
op_assign
(paren
id|allow_ofs_delta
op_logical_and
id|entry-&gt;delta-&gt;idx.offset
)paren
ques
c_cond
id|OBJ_OFS_DELTA
suffix:colon
id|OBJ_REF_DELTA
suffix:semicolon
)brace
r_else
(brace
id|buf
op_assign
id|read_sha1_file
c_func
(paren
id|entry-&gt;idx.sha1
comma
op_amp
id|type
comma
op_amp
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
id|die
c_func
(paren
l_string|&quot;unable to read %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|entry-&gt;idx.sha1
)paren
)paren
suffix:semicolon
id|buf
op_assign
id|delta_against
c_func
(paren
id|buf
comma
id|size
comma
id|entry
)paren
suffix:semicolon
id|size
op_assign
id|entry-&gt;delta_size
suffix:semicolon
id|obj_type
op_assign
(paren
id|allow_ofs_delta
op_logical_and
id|entry-&gt;delta-&gt;idx.offset
)paren
ques
c_cond
id|OBJ_OFS_DELTA
suffix:colon
id|OBJ_REF_DELTA
suffix:semicolon
)brace
multiline_comment|/* compress the data to store and put compressed length in datalen */
id|memset
c_func
(paren
op_amp
id|stream
comma
l_int|0
comma
r_sizeof
(paren
id|stream
)paren
)paren
suffix:semicolon
id|deflateInit
c_func
(paren
op_amp
id|stream
comma
id|pack_compression_level
)paren
suffix:semicolon
id|maxsize
op_assign
id|deflateBound
c_func
(paren
op_amp
id|stream
comma
id|size
)paren
suffix:semicolon
id|out
op_assign
id|xmalloc
c_func
(paren
id|maxsize
)paren
suffix:semicolon
multiline_comment|/* Compress it */
id|stream.next_in
op_assign
id|buf
suffix:semicolon
id|stream.avail_in
op_assign
id|size
suffix:semicolon
id|stream.next_out
op_assign
id|out
suffix:semicolon
id|stream.avail_out
op_assign
id|maxsize
suffix:semicolon
r_while
c_loop
(paren
id|deflate
c_func
(paren
op_amp
id|stream
comma
id|Z_FINISH
)paren
op_eq
id|Z_OK
)paren
multiline_comment|/* nothing */
suffix:semicolon
id|deflateEnd
c_func
(paren
op_amp
id|stream
)paren
suffix:semicolon
id|datalen
op_assign
id|stream.total_out
suffix:semicolon
id|deflateEnd
c_func
(paren
op_amp
id|stream
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The object header is a byte of &squot;type&squot; followed by zero or&n;&t;&t; * more bytes of length.&n;&t;&t; */
id|hdrlen
op_assign
id|encode_header
c_func
(paren
id|obj_type
comma
id|size
comma
id|header
)paren
suffix:semicolon
r_if
c_cond
(paren
id|obj_type
op_eq
id|OBJ_OFS_DELTA
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Deltas with relative base contain an additional&n;&t;&t;&t; * encoding of the relative offset for the delta&n;&t;&t;&t; * base from this object&squot;s position in the pack.&n;&t;&t;&t; */
id|off_t
id|ofs
op_assign
id|entry-&gt;idx.offset
id|entry-&gt;delta-&gt;idx.offset
suffix:semicolon
r_int
id|pos
op_assign
r_sizeof
(paren
id|dheader
)paren
l_int|1
suffix:semicolon
id|dheader
(braket
id|pos
)braket
op_assign
id|ofs
op_amp
l_int|127
suffix:semicolon
r_while
c_loop
(paren
id|ofs
op_rshift_assign
l_int|7
)paren
id|dheader
(braket
op_decrement
id|pos
)braket
op_assign
l_int|128
op_or
(paren
op_decrement
id|ofs
op_amp
l_int|127
)paren
suffix:semicolon
r_if
c_cond
(paren
id|limit
op_logical_and
id|hdrlen
op_plus
r_sizeof
(paren
id|dheader
)paren
id|pos
op_plus
id|datalen
op_plus
l_int|20
op_ge
id|limit
)paren
(brace
id|free
c_func
(paren
id|out
)paren
suffix:semicolon
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|sha1write
c_func
(paren
id|f
comma
id|header
comma
id|hdrlen
)paren
suffix:semicolon
id|sha1write
c_func
(paren
id|f
comma
id|dheader
op_plus
id|pos
comma
r_sizeof
(paren
id|dheader
)paren
id|pos
)paren
suffix:semicolon
id|hdrlen
op_add_assign
r_sizeof
(paren
id|dheader
)paren
id|pos
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|obj_type
op_eq
id|OBJ_REF_DELTA
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Deltas with a base reference contain&n;&t;&t;&t; * an additional 20 bytes for the base sha1.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|limit
op_logical_and
id|hdrlen
op_plus
l_int|20
op_plus
id|datalen
op_plus
l_int|20
op_ge
id|limit
)paren
(brace
id|free
c_func
(paren
id|out
)paren
suffix:semicolon
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|sha1write
c_func
(paren
id|f
comma
id|header
comma
id|hdrlen
)paren
suffix:semicolon
id|sha1write
c_func
(paren
id|f
comma
id|entry-&gt;delta-&gt;idx.sha1
comma
l_int|20
)paren
suffix:semicolon
id|hdrlen
op_add_assign
l_int|20
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|limit
op_logical_and
id|hdrlen
op_plus
id|datalen
op_plus
l_int|20
op_ge
id|limit
)paren
(brace
id|free
c_func
(paren
id|out
)paren
suffix:semicolon
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|sha1write
c_func
(paren
id|f
comma
id|header
comma
id|hdrlen
)paren
suffix:semicolon
)brace
id|sha1write
c_func
(paren
id|f
comma
id|out
comma
id|datalen
)paren
suffix:semicolon
id|free
c_func
(paren
id|out
)paren
suffix:semicolon
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|packed_git
op_star
id|p
op_assign
id|entry-&gt;in_pack
suffix:semicolon
r_struct
id|pack_window
op_star
id|w_curs
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|revindex_entry
op_star
id|revidx
suffix:semicolon
id|off_t
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;delta
)paren
(brace
id|obj_type
op_assign
(paren
id|allow_ofs_delta
op_logical_and
id|entry-&gt;delta-&gt;idx.offset
)paren
ques
c_cond
id|OBJ_OFS_DELTA
suffix:colon
id|OBJ_REF_DELTA
suffix:semicolon
id|reused_delta
op_increment
suffix:semicolon
)brace
id|hdrlen
op_assign
id|encode_header
c_func
(paren
id|obj_type
comma
id|entry-&gt;size
comma
id|header
)paren
suffix:semicolon
id|offset
op_assign
id|entry-&gt;in_pack_offset
suffix:semicolon
id|revidx
op_assign
id|find_packed_object
c_func
(paren
id|p
comma
id|offset
)paren
suffix:semicolon
id|datalen
op_assign
id|revidx
(braket
l_int|1
)braket
dot
id|offset
id|offset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pack_to_stdout
op_logical_and
id|p-&gt;index_version
OG
l_int|1
op_logical_and
id|check_pack_crc
c_func
(paren
id|p
comma
op_amp
id|w_curs
comma
id|offset
comma
id|datalen
comma
id|revidx-&gt;nr
)paren
)paren
id|die
c_func
(paren
l_string|&quot;bad packed object CRC for %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|entry-&gt;idx.sha1
)paren
)paren
suffix:semicolon
id|offset
op_add_assign
id|entry-&gt;in_pack_header_size
suffix:semicolon
id|datalen
op_sub_assign
id|entry-&gt;in_pack_header_size
suffix:semicolon
r_if
c_cond
(paren
id|obj_type
op_eq
id|OBJ_OFS_DELTA
)paren
(brace
id|off_t
id|ofs
op_assign
id|entry-&gt;idx.offset
id|entry-&gt;delta-&gt;idx.offset
suffix:semicolon
r_int
id|pos
op_assign
r_sizeof
(paren
id|dheader
)paren
l_int|1
suffix:semicolon
id|dheader
(braket
id|pos
)braket
op_assign
id|ofs
op_amp
l_int|127
suffix:semicolon
r_while
c_loop
(paren
id|ofs
op_rshift_assign
l_int|7
)paren
id|dheader
(braket
op_decrement
id|pos
)braket
op_assign
l_int|128
op_or
(paren
op_decrement
id|ofs
op_amp
l_int|127
)paren
suffix:semicolon
r_if
c_cond
(paren
id|limit
op_logical_and
id|hdrlen
op_plus
r_sizeof
(paren
id|dheader
)paren
id|pos
op_plus
id|datalen
op_plus
l_int|20
op_ge
id|limit
)paren
r_return
l_int|0
suffix:semicolon
id|sha1write
c_func
(paren
id|f
comma
id|header
comma
id|hdrlen
)paren
suffix:semicolon
id|sha1write
c_func
(paren
id|f
comma
id|dheader
op_plus
id|pos
comma
r_sizeof
(paren
id|dheader
)paren
id|pos
)paren
suffix:semicolon
id|hdrlen
op_add_assign
r_sizeof
(paren
id|dheader
)paren
id|pos
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|obj_type
op_eq
id|OBJ_REF_DELTA
)paren
(brace
r_if
c_cond
(paren
id|limit
op_logical_and
id|hdrlen
op_plus
l_int|20
op_plus
id|datalen
op_plus
l_int|20
op_ge
id|limit
)paren
r_return
l_int|0
suffix:semicolon
id|sha1write
c_func
(paren
id|f
comma
id|header
comma
id|hdrlen
)paren
suffix:semicolon
id|sha1write
c_func
(paren
id|f
comma
id|entry-&gt;delta-&gt;idx.sha1
comma
l_int|20
)paren
suffix:semicolon
id|hdrlen
op_add_assign
l_int|20
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|limit
op_logical_and
id|hdrlen
op_plus
id|datalen
op_plus
l_int|20
op_ge
id|limit
)paren
r_return
l_int|0
suffix:semicolon
id|sha1write
c_func
(paren
id|f
comma
id|header
comma
id|hdrlen
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|pack_to_stdout
op_logical_and
id|p-&gt;index_version
op_eq
l_int|1
op_logical_and
id|check_pack_inflate
c_func
(paren
id|p
comma
op_amp
id|w_curs
comma
id|offset
comma
id|datalen
comma
id|entry-&gt;size
)paren
)paren
id|die
c_func
(paren
l_string|&quot;corrupt packed object for %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|entry-&gt;idx.sha1
)paren
)paren
suffix:semicolon
id|copy_pack_data
c_func
(paren
id|f
comma
id|p
comma
op_amp
id|w_curs
comma
id|offset
comma
id|datalen
)paren
suffix:semicolon
id|unuse_pack
c_func
(paren
op_amp
id|w_curs
)paren
suffix:semicolon
id|reused
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|usable_delta
)paren
id|written_delta
op_increment
suffix:semicolon
id|written
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pack_to_stdout
)paren
id|entry-&gt;idx.crc32
op_assign
id|crc32_end
c_func
(paren
id|f
)paren
suffix:semicolon
r_return
id|hdrlen
op_plus
id|datalen
suffix:semicolon
)brace
DECL|function|write_one
r_static
id|off_t
id|write_one
c_func
(paren
r_struct
id|sha1file
op_star
id|f
comma
r_struct
id|object_entry
op_star
id|e
comma
id|off_t
id|offset
)paren
(brace
r_int
r_int
id|size
suffix:semicolon
multiline_comment|/* offset is non zero if object is written already. */
r_if
c_cond
(paren
id|e-&gt;idx.offset
op_logical_or
id|e-&gt;preferred_base
)paren
r_return
id|offset
suffix:semicolon
multiline_comment|/* if we are deltified, write out base object first. */
r_if
c_cond
(paren
id|e-&gt;delta
)paren
(brace
id|offset
op_assign
id|write_one
c_func
(paren
id|f
comma
id|e-&gt;delta
comma
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|offset
)paren
r_return
l_int|0
suffix:semicolon
)brace
id|e-&gt;idx.offset
op_assign
id|offset
suffix:semicolon
id|size
op_assign
id|write_object
c_func
(paren
id|f
comma
id|e
comma
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|size
)paren
(brace
id|e-&gt;idx.offset
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|written_list
(braket
id|nr_written
op_increment
)braket
op_assign
id|e
suffix:semicolon
multiline_comment|/* make sure off_t is sufficiently large not to wrap */
r_if
c_cond
(paren
id|offset
OG
id|offset
op_plus
id|size
)paren
id|die
c_func
(paren
l_string|&quot;pack too large for current definition of off_t&quot;
)paren
suffix:semicolon
r_return
id|offset
op_plus
id|size
suffix:semicolon
)brace
DECL|function|open_object_dir_tmp
r_static
r_int
id|open_object_dir_tmp
c_func
(paren
r_const
r_char
op_star
id|path
)paren
(brace
id|snprintf
c_func
(paren
id|tmpname
comma
r_sizeof
(paren
id|tmpname
)paren
comma
l_string|&quot;%s/%s&quot;
comma
id|get_object_directory
c_func
(paren
)paren
comma
id|path
)paren
suffix:semicolon
r_return
id|mkstemp
c_func
(paren
id|tmpname
)paren
suffix:semicolon
)brace
multiline_comment|/* forward declaration for write_pack_file */
r_static
r_int
id|adjust_perm
c_func
(paren
r_const
r_char
op_star
id|path
comma
id|mode_t
id|mode
)paren
suffix:semicolon
DECL|function|write_pack_file
r_static
r_void
id|write_pack_file
c_func
(paren
r_void
)paren
(brace
r_uint32
id|i
op_assign
l_int|0
comma
id|j
suffix:semicolon
r_struct
id|sha1file
op_star
id|f
suffix:semicolon
id|off_t
id|offset
comma
id|offset_one
comma
id|last_obj_offset
op_assign
l_int|0
suffix:semicolon
r_struct
id|pack_header
id|hdr
suffix:semicolon
r_int
id|do_progress
op_assign
id|progress
op_rshift
id|pack_to_stdout
suffix:semicolon
r_uint32
id|nr_remaining
op_assign
id|nr_result
suffix:semicolon
r_if
c_cond
(paren
id|do_progress
)paren
id|start_progress
c_func
(paren
op_amp
id|progress_state
comma
l_string|&quot;Writing %u objects...&quot;
comma
l_string|&quot;&quot;
comma
id|nr_result
)paren
suffix:semicolon
id|written_list
op_assign
id|xmalloc
c_func
(paren
id|nr_objects
op_star
r_sizeof
(paren
r_struct
id|object_entry
op_star
)paren
)paren
suffix:semicolon
r_do
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_if
c_cond
(paren
id|pack_to_stdout
)paren
(brace
id|f
op_assign
id|sha1fd
c_func
(paren
l_int|1
comma
l_string|&quot;&lt;stdout&gt;&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|fd
op_assign
id|open_object_dir_tmp
c_func
(paren
l_string|&quot;tmp_pack_XXXXXX&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;unable to create %s: %s&bslash;n&quot;
comma
id|tmpname
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
id|pack_tmp_name
op_assign
id|xstrdup
c_func
(paren
id|tmpname
)paren
suffix:semicolon
id|f
op_assign
id|sha1fd
c_func
(paren
id|fd
comma
id|pack_tmp_name
)paren
suffix:semicolon
)brace
id|hdr.hdr_signature
op_assign
id|htonl
c_func
(paren
id|PACK_SIGNATURE
)paren
suffix:semicolon
id|hdr.hdr_version
op_assign
id|htonl
c_func
(paren
id|PACK_VERSION
)paren
suffix:semicolon
id|hdr.hdr_entries
op_assign
id|htonl
c_func
(paren
id|nr_remaining
)paren
suffix:semicolon
id|sha1write
c_func
(paren
id|f
comma
op_amp
id|hdr
comma
r_sizeof
(paren
id|hdr
)paren
)paren
suffix:semicolon
id|offset
op_assign
r_sizeof
(paren
id|hdr
)paren
suffix:semicolon
id|nr_written
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
id|nr_objects
suffix:semicolon
id|i
op_increment
)paren
(brace
id|last_obj_offset
op_assign
id|offset
suffix:semicolon
id|offset_one
op_assign
id|write_one
c_func
(paren
id|f
comma
id|objects
op_plus
id|i
comma
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|offset_one
)paren
r_break
suffix:semicolon
id|offset
op_assign
id|offset_one
suffix:semicolon
r_if
c_cond
(paren
id|do_progress
)paren
id|display_progress
c_func
(paren
op_amp
id|progress_state
comma
id|written
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Did we write the wrong # entries in the header?&n;&t;&t; * If so, rewrite it like in fast-import&n;&t;&t; */
r_if
c_cond
(paren
id|pack_to_stdout
op_logical_or
id|nr_written
op_eq
id|nr_remaining
)paren
(brace
id|sha1close
c_func
(paren
id|f
comma
id|sha1
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|sha1close
c_func
(paren
id|f
comma
id|sha1
comma
l_int|0
)paren
suffix:semicolon
id|fixup_pack_header_footer
c_func
(paren
id|f-&gt;fd
comma
id|sha1
comma
id|pack_tmp_name
comma
id|nr_written
)paren
suffix:semicolon
id|close
c_func
(paren
id|f-&gt;fd
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|pack_to_stdout
)paren
(brace
id|mode_t
id|mode
op_assign
id|umask
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|umask
c_func
(paren
id|mode
)paren
suffix:semicolon
id|mode
op_assign
l_int|0444
op_amp
op_complement
id|mode
suffix:semicolon
id|idx_tmp_name
op_assign
id|write_idx_file
c_func
(paren
l_int|NULL
comma
(paren
r_struct
id|pack_idx_entry
op_star
op_star
)paren
id|written_list
comma
id|nr_written
comma
id|sha1
)paren
suffix:semicolon
id|snprintf
c_func
(paren
id|tmpname
comma
r_sizeof
(paren
id|tmpname
)paren
comma
l_string|&quot;%s-%s.pack&quot;
comma
id|base_name
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|adjust_perm
c_func
(paren
id|pack_tmp_name
comma
id|mode
)paren
)paren
id|die
c_func
(paren
l_string|&quot;unable to make temporary pack file readable: %s&quot;
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rename
c_func
(paren
id|pack_tmp_name
comma
id|tmpname
)paren
)paren
id|die
c_func
(paren
l_string|&quot;unable to rename temporary pack file: %s&quot;
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
id|snprintf
c_func
(paren
id|tmpname
comma
r_sizeof
(paren
id|tmpname
)paren
comma
l_string|&quot;%s-%s.idx&quot;
comma
id|base_name
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|adjust_perm
c_func
(paren
id|idx_tmp_name
comma
id|mode
)paren
)paren
id|die
c_func
(paren
l_string|&quot;unable to make temporary index file readable: %s&quot;
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rename
c_func
(paren
id|idx_tmp_name
comma
id|tmpname
)paren
)paren
id|die
c_func
(paren
l_string|&quot;unable to rename temporary index file: %s&quot;
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
id|puts
c_func
(paren
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* mark written objects as written to previous pack */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|nr_written
suffix:semicolon
id|j
op_increment
)paren
(brace
id|written_list
(braket
id|j
)braket
op_member_access_from_pointer
id|idx.offset
op_assign
(paren
id|off_t
)paren
op_minus
l_int|1
suffix:semicolon
)brace
id|nr_remaining
op_sub_assign
id|nr_written
suffix:semicolon
)brace
r_while
c_loop
(paren
id|nr_remaining
op_logical_and
id|i
OL
id|nr_objects
)paren
suffix:semicolon
id|free
c_func
(paren
id|written_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|do_progress
)paren
id|stop_progress
c_func
(paren
op_amp
id|progress_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|written
op_ne
id|nr_result
)paren
id|die
c_func
(paren
l_string|&quot;wrote %u objects while expecting %u&quot;
comma
id|written
comma
id|nr_result
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We have scanned through [0 ... i).  Since we have written&n;&t; * the correct number of objects,  the remaining [i ... nr_objects)&n;&t; * items must be either already written (due to out-of-order delta base)&n;&t; * or a preferred base.  Count those which are neither and complain if any.&n;&t; */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_objects
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|object_entry
op_star
id|e
op_assign
id|objects
op_plus
id|i
suffix:semicolon
id|j
op_add_assign
op_logical_neg
id|e-&gt;idx.offset
op_logical_and
op_logical_neg
id|e-&gt;preferred_base
suffix:semicolon
)brace
r_if
c_cond
(paren
id|j
)paren
id|die
c_func
(paren
l_string|&quot;wrote %u objects as expected but %u unwritten&quot;
comma
id|written
comma
id|j
)paren
suffix:semicolon
)brace
DECL|function|locate_object_entry_hash
r_static
r_int
id|locate_object_entry_hash
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|ui
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|ui
comma
id|sha1
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
id|i
op_assign
id|ui
op_mod
id|object_ix_hashsz
suffix:semicolon
r_while
c_loop
(paren
l_int|0
OL
id|object_ix
(braket
id|i
)braket
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|hashcmp
c_func
(paren
id|sha1
comma
id|objects
(braket
id|object_ix
(braket
id|i
)braket
l_int|1
)braket
dot
id|idx.sha1
)paren
)paren
r_return
id|i
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|i
op_eq
id|object_ix_hashsz
)paren
id|i
op_assign
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
id|i
suffix:semicolon
)brace
DECL|function|locate_object_entry
r_static
r_struct
id|object_entry
op_star
id|locate_object_entry
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|object_ix_hashsz
)paren
r_return
l_int|NULL
suffix:semicolon
id|i
op_assign
id|locate_object_entry_hash
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_le
id|i
)paren
r_return
op_amp
id|objects
(braket
id|object_ix
(braket
id|i
)braket
l_int|1
)braket
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|rehash_objects
r_static
r_void
id|rehash_objects
c_func
(paren
r_void
)paren
(brace
r_uint32
id|i
suffix:semicolon
r_struct
id|object_entry
op_star
id|oe
suffix:semicolon
id|object_ix_hashsz
op_assign
id|nr_objects
op_star
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|object_ix_hashsz
OL
l_int|1024
)paren
id|object_ix_hashsz
op_assign
l_int|1024
suffix:semicolon
id|object_ix
op_assign
id|xrealloc
c_func
(paren
id|object_ix
comma
r_sizeof
(paren
r_int
)paren
op_star
id|object_ix_hashsz
)paren
suffix:semicolon
id|memset
c_func
(paren
id|object_ix
comma
l_int|0
comma
r_sizeof
(paren
r_int
)paren
op_star
id|object_ix_hashsz
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|oe
op_assign
id|objects
suffix:semicolon
id|i
OL
id|nr_objects
suffix:semicolon
id|i
op_increment
comma
id|oe
op_increment
)paren
(brace
r_int
id|ix
op_assign
id|locate_object_entry_hash
c_func
(paren
id|oe-&gt;idx.sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_le
id|ix
)paren
r_continue
suffix:semicolon
id|ix
op_assign
l_int|1
id|ix
suffix:semicolon
id|object_ix
(braket
id|ix
)braket
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
)brace
)brace
DECL|function|name_hash
r_static
r_int
id|name_hash
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_int
r_char
id|c
suffix:semicolon
r_int
id|hash
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * This effectively just creates a sortable number from the&n;&t; * last sixteen non-whitespace characters. Last characters&n;&t; * count &quot;most&quot;, so things that end in &quot;.c&quot; sort together.&n;&t; */
r_while
c_loop
(paren
(paren
id|c
op_assign
op_star
id|name
op_increment
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|isspace
c_func
(paren
id|c
)paren
)paren
r_continue
suffix:semicolon
id|hash
op_assign
(paren
id|hash
op_rshift
l_int|2
)paren
op_plus
(paren
id|c
op_lshift
l_int|24
)paren
suffix:semicolon
)brace
r_return
id|hash
suffix:semicolon
)brace
DECL|function|setup_delta_attr_check
r_static
r_void
id|setup_delta_attr_check
c_func
(paren
r_struct
id|git_attr_check
op_star
id|check
)paren
(brace
r_static
r_struct
id|git_attr
op_star
id|attr_delta
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|attr_delta
)paren
id|attr_delta
op_assign
id|git_attr
c_func
(paren
l_string|&quot;delta&quot;
comma
l_int|5
)paren
suffix:semicolon
id|check
(braket
l_int|0
)braket
dot
id|attr
op_assign
id|attr_delta
suffix:semicolon
)brace
DECL|function|no_try_delta
r_static
r_int
id|no_try_delta
c_func
(paren
r_const
r_char
op_star
id|path
)paren
(brace
r_struct
id|git_attr_check
id|check
(braket
l_int|1
)braket
suffix:semicolon
id|setup_delta_attr_check
c_func
(paren
id|check
)paren
suffix:semicolon
r_if
c_cond
(paren
id|git_checkattr
c_func
(paren
id|path
comma
id|ARRAY_SIZE
c_func
(paren
id|check
)paren
comma
id|check
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ATTR_FALSE
c_func
(paren
id|check-&gt;value
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|add_object_entry
r_static
r_int
id|add_object_entry
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
comma
r_enum
id|object_type
id|type
comma
r_const
r_char
op_star
id|name
comma
r_int
id|exclude
)paren
(brace
r_struct
id|object_entry
op_star
id|entry
suffix:semicolon
r_struct
id|packed_git
op_star
id|p
comma
op_star
id|found_pack
op_assign
l_int|NULL
suffix:semicolon
id|off_t
id|found_offset
op_assign
l_int|0
suffix:semicolon
r_int
id|ix
suffix:semicolon
r_int
id|hash
op_assign
id|name_hash
c_func
(paren
id|name
)paren
suffix:semicolon
id|ix
op_assign
id|nr_objects
ques
c_cond
id|locate_object_entry_hash
c_func
(paren
id|sha1
)paren
suffix:colon
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ix
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|exclude
)paren
(brace
id|entry
op_assign
id|objects
op_plus
id|object_ix
(braket
id|ix
)braket
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;preferred_base
)paren
id|nr_result
op_decrement
suffix:semicolon
id|entry-&gt;preferred_base
op_assign
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|p
op_assign
id|packed_git
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
id|off_t
id|offset
op_assign
id|find_pack_entry_one
c_func
(paren
id|sha1
comma
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|found_pack
)paren
(brace
id|found_offset
op_assign
id|offset
suffix:semicolon
id|found_pack
op_assign
id|p
suffix:semicolon
)brace
r_if
c_cond
(paren
id|exclude
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|incremental
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|local
op_logical_and
op_logical_neg
id|p-&gt;pack_local
)paren
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|nr_objects
op_ge
id|nr_alloc
)paren
(brace
id|nr_alloc
op_assign
(paren
id|nr_alloc
op_plus
l_int|1024
)paren
op_star
l_int|3
op_div
l_int|2
suffix:semicolon
id|objects
op_assign
id|xrealloc
c_func
(paren
id|objects
comma
id|nr_alloc
op_star
r_sizeof
(paren
op_star
id|entry
)paren
)paren
suffix:semicolon
)brace
id|entry
op_assign
id|objects
op_plus
id|nr_objects
op_increment
suffix:semicolon
id|memset
c_func
(paren
id|entry
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|entry
)paren
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|entry-&gt;idx.sha1
comma
id|sha1
)paren
suffix:semicolon
id|entry-&gt;hash
op_assign
id|hash
suffix:semicolon
r_if
c_cond
(paren
id|type
)paren
id|entry-&gt;type
op_assign
id|type
suffix:semicolon
r_if
c_cond
(paren
id|exclude
)paren
id|entry-&gt;preferred_base
op_assign
l_int|1
suffix:semicolon
r_else
id|nr_result
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|found_pack
)paren
(brace
id|entry-&gt;in_pack
op_assign
id|found_pack
suffix:semicolon
id|entry-&gt;in_pack_offset
op_assign
id|found_offset
suffix:semicolon
)brace
r_if
c_cond
(paren
id|object_ix_hashsz
op_star
l_int|3
op_le
id|nr_objects
op_star
l_int|4
)paren
id|rehash_objects
c_func
(paren
)paren
suffix:semicolon
r_else
id|object_ix
(braket
l_int|1
id|ix
)braket
op_assign
id|nr_objects
suffix:semicolon
r_if
c_cond
(paren
id|progress
)paren
id|display_progress
c_func
(paren
op_amp
id|progress_state
comma
id|nr_objects
)paren
suffix:semicolon
r_if
c_cond
(paren
id|name
op_logical_and
id|no_try_delta
c_func
(paren
id|name
)paren
)paren
id|entry-&gt;no_try_delta
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|struct|pbase_tree_cache
r_struct
id|pbase_tree_cache
(brace
DECL|member|sha1
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
DECL|member|ref
r_int
id|ref
suffix:semicolon
DECL|member|temporary
r_int
id|temporary
suffix:semicolon
DECL|member|tree_data
r_void
op_star
id|tree_data
suffix:semicolon
DECL|member|tree_size
r_int
r_int
id|tree_size
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|pbase_tree_cache
r_static
r_struct
id|pbase_tree_cache
op_star
(paren
id|pbase_tree_cache
(braket
l_int|256
)braket
)paren
suffix:semicolon
DECL|function|pbase_tree_cache_ix
r_static
r_int
id|pbase_tree_cache_ix
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_return
id|sha1
(braket
l_int|0
)braket
op_mod
id|ARRAY_SIZE
c_func
(paren
id|pbase_tree_cache
)paren
suffix:semicolon
)brace
DECL|function|pbase_tree_cache_ix_incr
r_static
r_int
id|pbase_tree_cache_ix_incr
c_func
(paren
r_int
id|ix
)paren
(brace
r_return
(paren
id|ix
op_plus
l_int|1
)paren
op_mod
id|ARRAY_SIZE
c_func
(paren
id|pbase_tree_cache
)paren
suffix:semicolon
)brace
DECL|struct|pbase_tree
r_static
r_struct
id|pbase_tree
(brace
DECL|member|next
r_struct
id|pbase_tree
op_star
id|next
suffix:semicolon
multiline_comment|/* This is a phony &quot;cache&quot; entry; we are not&n;&t; * going to evict it nor find it through _get()&n;&t; * mechanism -- this is for the toplevel node that&n;&t; * would almost always change with any commit.&n;&t; */
DECL|member|pcache
r_struct
id|pbase_tree_cache
id|pcache
suffix:semicolon
DECL|variable|pbase_tree
)brace
op_star
id|pbase_tree
suffix:semicolon
DECL|function|pbase_tree_get
r_static
r_struct
id|pbase_tree_cache
op_star
id|pbase_tree_get
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_struct
id|pbase_tree_cache
op_star
id|ent
comma
op_star
id|nent
suffix:semicolon
r_void
op_star
id|data
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_enum
id|object_type
id|type
suffix:semicolon
r_int
id|neigh
suffix:semicolon
r_int
id|my_ix
op_assign
id|pbase_tree_cache_ix
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_int
id|available_ix
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* pbase-tree-cache acts as a limited hashtable.&n;&t; * your object will be found at your index or within a few&n;&t; * slots after that slot if it is cached.&n;&t; */
r_for
c_loop
(paren
id|neigh
op_assign
l_int|0
suffix:semicolon
id|neigh
OL
l_int|8
suffix:semicolon
id|neigh
op_increment
)paren
(brace
id|ent
op_assign
id|pbase_tree_cache
(braket
id|my_ix
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ent
op_logical_and
op_logical_neg
id|hashcmp
c_func
(paren
id|ent-&gt;sha1
comma
id|sha1
)paren
)paren
(brace
id|ent-&gt;ref
op_increment
suffix:semicolon
r_return
id|ent
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
(paren
id|available_ix
OL
l_int|0
)paren
op_logical_and
(paren
op_logical_neg
id|ent
op_logical_or
op_logical_neg
id|ent-&gt;ref
)paren
)paren
op_logical_or
(paren
(paren
l_int|0
op_le
id|available_ix
)paren
op_logical_and
(paren
op_logical_neg
id|ent
op_logical_and
id|pbase_tree_cache
(braket
id|available_ix
)braket
)paren
)paren
)paren
id|available_ix
op_assign
id|my_ix
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ent
)paren
r_break
suffix:semicolon
id|my_ix
op_assign
id|pbase_tree_cache_ix_incr
c_func
(paren
id|my_ix
)paren
suffix:semicolon
)brace
multiline_comment|/* Did not find one.  Either we got a bogus request or&n;&t; * we need to read and perhaps cache.&n;&t; */
id|data
op_assign
id|read_sha1_file
c_func
(paren
id|sha1
comma
op_amp
id|type
comma
op_amp
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
id|OBJ_TREE
)paren
(brace
id|free
c_func
(paren
id|data
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* We need to either cache or return a throwaway copy */
r_if
c_cond
(paren
id|available_ix
OL
l_int|0
)paren
id|ent
op_assign
l_int|NULL
suffix:semicolon
r_else
(brace
id|ent
op_assign
id|pbase_tree_cache
(braket
id|available_ix
)braket
suffix:semicolon
id|my_ix
op_assign
id|available_ix
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ent
)paren
(brace
id|nent
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|nent
)paren
)paren
suffix:semicolon
id|nent-&gt;temporary
op_assign
(paren
id|available_ix
OL
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* evict and reuse */
id|free
c_func
(paren
id|ent-&gt;tree_data
)paren
suffix:semicolon
id|nent
op_assign
id|ent
suffix:semicolon
)brace
id|hashcpy
c_func
(paren
id|nent-&gt;sha1
comma
id|sha1
)paren
suffix:semicolon
id|nent-&gt;tree_data
op_assign
id|data
suffix:semicolon
id|nent-&gt;tree_size
op_assign
id|size
suffix:semicolon
id|nent-&gt;ref
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nent-&gt;temporary
)paren
id|pbase_tree_cache
(braket
id|my_ix
)braket
op_assign
id|nent
suffix:semicolon
r_return
id|nent
suffix:semicolon
)brace
DECL|function|pbase_tree_put
r_static
r_void
id|pbase_tree_put
c_func
(paren
r_struct
id|pbase_tree_cache
op_star
id|cache
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cache-&gt;temporary
)paren
(brace
id|cache-&gt;ref
op_decrement
suffix:semicolon
r_return
suffix:semicolon
)brace
id|free
c_func
(paren
id|cache-&gt;tree_data
)paren
suffix:semicolon
id|free
c_func
(paren
id|cache
)paren
suffix:semicolon
)brace
DECL|function|name_cmp_len
r_static
r_int
id|name_cmp_len
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|name
(braket
id|i
)braket
op_logical_and
id|name
(braket
id|i
)braket
op_ne
l_char|&squot;&bslash;n&squot;
op_logical_and
id|name
(braket
id|i
)braket
op_ne
l_char|&squot;/&squot;
suffix:semicolon
id|i
op_increment
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
DECL|function|add_pbase_object
r_static
r_void
id|add_pbase_object
c_func
(paren
r_struct
id|tree_desc
op_star
id|tree
comma
r_const
r_char
op_star
id|name
comma
r_int
id|cmplen
comma
r_const
r_char
op_star
id|fullname
)paren
(brace
r_struct
id|name_entry
id|entry
suffix:semicolon
r_int
id|cmp
suffix:semicolon
r_while
c_loop
(paren
id|tree_entry
c_func
(paren
id|tree
comma
op_amp
id|entry
)paren
)paren
(brace
id|cmp
op_assign
id|tree_entry_len
c_func
(paren
id|entry.path
comma
id|entry.sha1
)paren
op_ne
id|cmplen
ques
c_cond
l_int|1
suffix:colon
id|memcmp
c_func
(paren
id|name
comma
id|entry.path
comma
id|cmplen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmp
OG
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|cmp
OL
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|name
(braket
id|cmplen
)braket
op_ne
l_char|&squot;/&squot;
)paren
(brace
id|add_object_entry
c_func
(paren
id|entry.sha1
comma
id|S_ISDIR
c_func
(paren
id|entry.mode
)paren
ques
c_cond
id|OBJ_TREE
suffix:colon
id|OBJ_BLOB
comma
id|fullname
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|entry.mode
)paren
)paren
(brace
r_struct
id|tree_desc
id|sub
suffix:semicolon
r_struct
id|pbase_tree_cache
op_star
id|tree
suffix:semicolon
r_const
r_char
op_star
id|down
op_assign
id|name
op_plus
id|cmplen
op_plus
l_int|1
suffix:semicolon
r_int
id|downlen
op_assign
id|name_cmp_len
c_func
(paren
id|down
)paren
suffix:semicolon
id|tree
op_assign
id|pbase_tree_get
c_func
(paren
id|entry.sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tree
)paren
r_return
suffix:semicolon
id|init_tree_desc
c_func
(paren
op_amp
id|sub
comma
id|tree-&gt;tree_data
comma
id|tree-&gt;tree_size
)paren
suffix:semicolon
id|add_pbase_object
c_func
(paren
op_amp
id|sub
comma
id|down
comma
id|downlen
comma
id|fullname
)paren
suffix:semicolon
id|pbase_tree_put
c_func
(paren
id|tree
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|variable|done_pbase_paths
r_static
r_int
op_star
id|done_pbase_paths
suffix:semicolon
DECL|variable|done_pbase_paths_num
r_static
r_int
id|done_pbase_paths_num
suffix:semicolon
DECL|variable|done_pbase_paths_alloc
r_static
r_int
id|done_pbase_paths_alloc
suffix:semicolon
DECL|function|done_pbase_path_pos
r_static
r_int
id|done_pbase_path_pos
c_func
(paren
r_int
id|hash
)paren
(brace
r_int
id|lo
op_assign
l_int|0
suffix:semicolon
r_int
id|hi
op_assign
id|done_pbase_paths_num
suffix:semicolon
r_while
c_loop
(paren
id|lo
OL
id|hi
)paren
(brace
r_int
id|mi
op_assign
(paren
id|hi
op_plus
id|lo
)paren
op_div
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|done_pbase_paths
(braket
id|mi
)braket
op_eq
id|hash
)paren
r_return
id|mi
suffix:semicolon
r_if
c_cond
(paren
id|done_pbase_paths
(braket
id|mi
)braket
OL
id|hash
)paren
id|hi
op_assign
id|mi
suffix:semicolon
r_else
id|lo
op_assign
id|mi
op_plus
l_int|1
suffix:semicolon
)brace
r_return
id|lo
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|check_pbase_path
r_static
r_int
id|check_pbase_path
c_func
(paren
r_int
id|hash
)paren
(brace
r_int
id|pos
op_assign
(paren
op_logical_neg
id|done_pbase_paths
)paren
ques
c_cond
l_int|1
suffix:colon
id|done_pbase_path_pos
c_func
(paren
id|hash
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_le
id|pos
)paren
r_return
l_int|1
suffix:semicolon
id|pos
op_assign
id|pos
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|done_pbase_paths_alloc
op_le
id|done_pbase_paths_num
)paren
(brace
id|done_pbase_paths_alloc
op_assign
id|alloc_nr
c_func
(paren
id|done_pbase_paths_alloc
)paren
suffix:semicolon
id|done_pbase_paths
op_assign
id|xrealloc
c_func
(paren
id|done_pbase_paths
comma
id|done_pbase_paths_alloc
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
)brace
id|done_pbase_paths_num
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
id|done_pbase_paths_num
)paren
id|memmove
c_func
(paren
id|done_pbase_paths
op_plus
id|pos
op_plus
l_int|1
comma
id|done_pbase_paths
op_plus
id|pos
comma
(paren
id|done_pbase_paths_num
id|pos
l_int|1
)paren
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
id|done_pbase_paths
(braket
id|pos
)braket
op_assign
id|hash
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|add_preferred_base_object
r_static
r_void
id|add_preferred_base_object
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|pbase_tree
op_star
id|it
suffix:semicolon
r_int
id|cmplen
suffix:semicolon
r_int
id|hash
op_assign
id|name_hash
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|num_preferred_base
op_logical_or
id|check_pbase_path
c_func
(paren
id|hash
)paren
)paren
r_return
suffix:semicolon
id|cmplen
op_assign
id|name_cmp_len
c_func
(paren
id|name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|it
op_assign
id|pbase_tree
suffix:semicolon
id|it
suffix:semicolon
id|it
op_assign
id|it-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|cmplen
op_eq
l_int|0
)paren
(brace
id|add_object_entry
c_func
(paren
id|it-&gt;pcache.sha1
comma
id|OBJ_TREE
comma
l_int|NULL
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|tree_desc
id|tree
suffix:semicolon
id|init_tree_desc
c_func
(paren
op_amp
id|tree
comma
id|it-&gt;pcache.tree_data
comma
id|it-&gt;pcache.tree_size
)paren
suffix:semicolon
id|add_pbase_object
c_func
(paren
op_amp
id|tree
comma
id|name
comma
id|cmplen
comma
id|name
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|add_preferred_base
r_static
r_void
id|add_preferred_base
c_func
(paren
r_int
r_char
op_star
id|sha1
)paren
(brace
r_struct
id|pbase_tree
op_star
id|it
suffix:semicolon
r_void
op_star
id|data
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_int
r_char
id|tree_sha1
(braket
l_int|20
)braket
suffix:semicolon
r_if
c_cond
(paren
id|window
op_le
id|num_preferred_base
op_increment
)paren
r_return
suffix:semicolon
id|data
op_assign
id|read_object_with_reference
c_func
(paren
id|sha1
comma
id|tree_type
comma
op_amp
id|size
comma
id|tree_sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|it
op_assign
id|pbase_tree
suffix:semicolon
id|it
suffix:semicolon
id|it
op_assign
id|it-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|hashcmp
c_func
(paren
id|it-&gt;pcache.sha1
comma
id|tree_sha1
)paren
)paren
(brace
id|free
c_func
(paren
id|data
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|it
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|it
)paren
)paren
suffix:semicolon
id|it-&gt;next
op_assign
id|pbase_tree
suffix:semicolon
id|pbase_tree
op_assign
id|it
suffix:semicolon
id|hashcpy
c_func
(paren
id|it-&gt;pcache.sha1
comma
id|tree_sha1
)paren
suffix:semicolon
id|it-&gt;pcache.tree_data
op_assign
id|data
suffix:semicolon
id|it-&gt;pcache.tree_size
op_assign
id|size
suffix:semicolon
)brace
DECL|function|check_object
r_static
r_void
id|check_object
c_func
(paren
r_struct
id|object_entry
op_star
id|entry
)paren
(brace
r_if
c_cond
(paren
id|entry-&gt;in_pack
)paren
(brace
r_struct
id|packed_git
op_star
id|p
op_assign
id|entry-&gt;in_pack
suffix:semicolon
r_struct
id|pack_window
op_star
id|w_curs
op_assign
l_int|NULL
suffix:semicolon
r_const
r_int
r_char
op_star
id|base_ref
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|object_entry
op_star
id|base_entry
suffix:semicolon
r_int
r_int
id|used
comma
id|used_0
suffix:semicolon
r_int
r_int
id|avail
suffix:semicolon
id|off_t
id|ofs
suffix:semicolon
r_int
r_char
op_star
id|buf
comma
id|c
suffix:semicolon
id|buf
op_assign
id|use_pack
c_func
(paren
id|p
comma
op_amp
id|w_curs
comma
id|entry-&gt;in_pack_offset
comma
op_amp
id|avail
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We want in_pack_type even if we do not reuse delta&n;&t;&t; * since non-delta representations could still be reused.&n;&t;&t; */
id|used
op_assign
id|unpack_object_header_gently
c_func
(paren
id|buf
comma
id|avail
comma
op_amp
id|entry-&gt;in_pack_type
comma
op_amp
id|entry-&gt;size
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Determine if this is a delta and if so whether we can&n;&t;&t; * reuse it or not.  Otherwise let&squot;s find out as cheaply as&n;&t;&t; * possible what the actual type and size for this object is.&n;&t;&t; */
r_switch
c_cond
(paren
id|entry-&gt;in_pack_type
)paren
(brace
r_default
suffix:colon
multiline_comment|/* Not a delta hence we&squot;ve already got all we need. */
id|entry-&gt;type
op_assign
id|entry-&gt;in_pack_type
suffix:semicolon
id|entry-&gt;in_pack_header_size
op_assign
id|used
suffix:semicolon
id|unuse_pack
c_func
(paren
op_amp
id|w_curs
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|OBJ_REF_DELTA
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|no_reuse_delta
op_logical_and
op_logical_neg
id|entry-&gt;preferred_base
)paren
id|base_ref
op_assign
id|use_pack
c_func
(paren
id|p
comma
op_amp
id|w_curs
comma
id|entry-&gt;in_pack_offset
op_plus
id|used
comma
l_int|NULL
)paren
suffix:semicolon
id|entry-&gt;in_pack_header_size
op_assign
id|used
op_plus
l_int|20
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OBJ_OFS_DELTA
suffix:colon
id|buf
op_assign
id|use_pack
c_func
(paren
id|p
comma
op_amp
id|w_curs
comma
id|entry-&gt;in_pack_offset
op_plus
id|used
comma
l_int|NULL
)paren
suffix:semicolon
id|used_0
op_assign
l_int|0
suffix:semicolon
id|c
op_assign
id|buf
(braket
id|used_0
op_increment
)braket
suffix:semicolon
id|ofs
op_assign
id|c
op_amp
l_int|127
suffix:semicolon
r_while
c_loop
(paren
id|c
op_amp
l_int|128
)paren
(brace
id|ofs
op_add_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ofs
op_logical_or
id|MSB
c_func
(paren
id|ofs
comma
l_int|7
)paren
)paren
id|die
c_func
(paren
l_string|&quot;delta base offset overflow in pack for %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|entry-&gt;idx.sha1
)paren
)paren
suffix:semicolon
id|c
op_assign
id|buf
(braket
id|used_0
op_increment
)braket
suffix:semicolon
id|ofs
op_assign
(paren
id|ofs
op_lshift
l_int|7
)paren
op_plus
(paren
id|c
op_amp
l_int|127
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ofs
op_ge
id|entry-&gt;in_pack_offset
)paren
id|die
c_func
(paren
l_string|&quot;delta base offset out of bound for %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|entry-&gt;idx.sha1
)paren
)paren
suffix:semicolon
id|ofs
op_assign
id|entry-&gt;in_pack_offset
id|ofs
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|no_reuse_delta
op_logical_and
op_logical_neg
id|entry-&gt;preferred_base
)paren
id|base_ref
op_assign
id|find_packed_object_name
c_func
(paren
id|p
comma
id|ofs
)paren
suffix:semicolon
id|entry-&gt;in_pack_header_size
op_assign
id|used
op_plus
id|used_0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|base_ref
op_logical_and
(paren
id|base_entry
op_assign
id|locate_object_entry
c_func
(paren
id|base_ref
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If base_ref was set above that means we wish to&n;&t;&t;&t; * reuse delta data, and we even found that base&n;&t;&t;&t; * in the list of objects we want to pack. Goodie!&n;&t;&t;&t; *&n;&t;&t;&t; * Depth value does not matter - find_deltas() will&n;&t;&t;&t; * never consider reused delta as the base object to&n;&t;&t;&t; * deltify other objects against, in order to avoid&n;&t;&t;&t; * circular deltas.&n;&t;&t;&t; */
id|entry-&gt;type
op_assign
id|entry-&gt;in_pack_type
suffix:semicolon
id|entry-&gt;delta
op_assign
id|base_entry
suffix:semicolon
id|entry-&gt;delta_sibling
op_assign
id|base_entry-&gt;delta_child
suffix:semicolon
id|base_entry-&gt;delta_child
op_assign
id|entry
suffix:semicolon
id|unuse_pack
c_func
(paren
op_amp
id|w_curs
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|entry-&gt;type
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * This must be a delta and we already know what the&n;&t;&t;&t; * final object type is.  Let&squot;s extract the actual&n;&t;&t;&t; * object size from the delta header.&n;&t;&t;&t; */
id|entry-&gt;size
op_assign
id|get_size_from_delta
c_func
(paren
id|p
comma
op_amp
id|w_curs
comma
id|entry-&gt;in_pack_offset
op_plus
id|entry-&gt;in_pack_header_size
)paren
suffix:semicolon
id|unuse_pack
c_func
(paren
op_amp
id|w_curs
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * No choice but to fall back to the recursive delta walk&n;&t;&t; * with sha1_object_info() to find about the object type&n;&t;&t; * at this point...&n;&t;&t; */
id|unuse_pack
c_func
(paren
op_amp
id|w_curs
)paren
suffix:semicolon
)brace
id|entry-&gt;type
op_assign
id|sha1_object_info
c_func
(paren
id|entry-&gt;idx.sha1
comma
op_amp
id|entry-&gt;size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;type
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;unable to get type of object %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|entry-&gt;idx.sha1
)paren
)paren
suffix:semicolon
)brace
DECL|function|pack_offset_sort
r_static
r_int
id|pack_offset_sort
c_func
(paren
r_const
r_void
op_star
id|_a
comma
r_const
r_void
op_star
id|_b
)paren
(brace
r_const
r_struct
id|object_entry
op_star
id|a
op_assign
op_star
(paren
r_struct
id|object_entry
op_star
op_star
)paren
id|_a
suffix:semicolon
r_const
r_struct
id|object_entry
op_star
id|b
op_assign
op_star
(paren
r_struct
id|object_entry
op_star
op_star
)paren
id|_b
suffix:semicolon
multiline_comment|/* avoid filesystem trashing with loose objects */
r_if
c_cond
(paren
op_logical_neg
id|a-&gt;in_pack
op_logical_and
op_logical_neg
id|b-&gt;in_pack
)paren
r_return
id|hashcmp
c_func
(paren
id|a-&gt;idx.sha1
comma
id|b-&gt;idx.sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;in_pack
OL
id|b-&gt;in_pack
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;in_pack
OG
id|b-&gt;in_pack
)paren
r_return
l_int|1
suffix:semicolon
r_return
id|a-&gt;in_pack_offset
OL
id|b-&gt;in_pack_offset
ques
c_cond
l_int|1
suffix:colon
(paren
id|a-&gt;in_pack_offset
OG
id|b-&gt;in_pack_offset
)paren
suffix:semicolon
)brace
DECL|function|get_object_details
r_static
r_void
id|get_object_details
c_func
(paren
r_void
)paren
(brace
r_uint32
id|i
suffix:semicolon
r_struct
id|object_entry
op_star
op_star
id|sorted_by_offset
suffix:semicolon
id|sorted_by_offset
op_assign
id|xcalloc
c_func
(paren
id|nr_objects
comma
r_sizeof
(paren
r_struct
id|object_entry
op_star
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_objects
suffix:semicolon
id|i
op_increment
)paren
id|sorted_by_offset
(braket
id|i
)braket
op_assign
id|objects
op_plus
id|i
suffix:semicolon
id|qsort
c_func
(paren
id|sorted_by_offset
comma
id|nr_objects
comma
r_sizeof
(paren
op_star
id|sorted_by_offset
)paren
comma
id|pack_offset_sort
)paren
suffix:semicolon
id|prepare_pack_ix
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_objects
suffix:semicolon
id|i
op_increment
)paren
id|check_object
c_func
(paren
id|sorted_by_offset
(braket
id|i
)braket
)paren
suffix:semicolon
id|free
c_func
(paren
id|sorted_by_offset
)paren
suffix:semicolon
)brace
DECL|function|type_size_sort
r_static
r_int
id|type_size_sort
c_func
(paren
r_const
r_void
op_star
id|_a
comma
r_const
r_void
op_star
id|_b
)paren
(brace
r_const
r_struct
id|object_entry
op_star
id|a
op_assign
op_star
(paren
r_struct
id|object_entry
op_star
op_star
)paren
id|_a
suffix:semicolon
r_const
r_struct
id|object_entry
op_star
id|b
op_assign
op_star
(paren
r_struct
id|object_entry
op_star
op_star
)paren
id|_b
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;type
OL
id|b-&gt;type
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;type
OG
id|b-&gt;type
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;hash
OL
id|b-&gt;hash
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;hash
OG
id|b-&gt;hash
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;preferred_base
OL
id|b-&gt;preferred_base
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;preferred_base
OG
id|b-&gt;preferred_base
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;size
OL
id|b-&gt;size
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;size
OG
id|b-&gt;size
)paren
r_return
l_int|1
suffix:semicolon
r_return
id|a
OG
id|b
ques
c_cond
l_int|1
suffix:colon
(paren
id|a
OL
id|b
)paren
suffix:semicolon
multiline_comment|/* newest last */
)brace
DECL|struct|unpacked
r_struct
id|unpacked
(brace
DECL|member|entry
r_struct
id|object_entry
op_star
id|entry
suffix:semicolon
DECL|member|data
r_void
op_star
id|data
suffix:semicolon
DECL|member|index
r_struct
id|delta_index
op_star
id|index
suffix:semicolon
DECL|member|depth
r_int
id|depth
suffix:semicolon
)brace
suffix:semicolon
DECL|function|delta_cacheable
r_static
r_int
id|delta_cacheable
c_func
(paren
r_struct
id|unpacked
op_star
id|trg
comma
r_struct
id|unpacked
op_star
id|src
comma
r_int
r_int
id|src_size
comma
r_int
r_int
id|trg_size
comma
r_int
r_int
id|delta_size
)paren
(brace
r_if
c_cond
(paren
id|max_delta_cache_size
op_logical_and
id|delta_cache_size
op_plus
id|delta_size
OG
id|max_delta_cache_size
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|delta_size
OL
id|cache_max_small_delta_size
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* cache delta, if objects are large enough compared to delta size */
r_if
c_cond
(paren
(paren
id|src_size
op_rshift
l_int|20
)paren
op_plus
(paren
id|trg_size
op_rshift
l_int|21
)paren
OG
(paren
id|delta_size
op_rshift
l_int|10
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * We search for deltas _backwards_ in a list sorted by type and&n; * by size, so that we see progressively smaller and smaller files.&n; * That&squot;s because we prefer deltas to be from the bigger file&n; * to the smaller - deletes are potentially cheaper, but perhaps&n; * more importantly, the bigger file is likely the more recent&n; * one.&n; */
DECL|function|try_delta
r_static
r_int
id|try_delta
c_func
(paren
r_struct
id|unpacked
op_star
id|trg
comma
r_struct
id|unpacked
op_star
id|src
comma
r_int
id|max_depth
)paren
(brace
r_struct
id|object_entry
op_star
id|trg_entry
op_assign
id|trg-&gt;entry
suffix:semicolon
r_struct
id|object_entry
op_star
id|src_entry
op_assign
id|src-&gt;entry
suffix:semicolon
r_int
r_int
id|trg_size
comma
id|src_size
comma
id|delta_size
comma
id|sizediff
comma
id|max_size
comma
id|sz
suffix:semicolon
r_int
id|ref_depth
suffix:semicolon
r_enum
id|object_type
id|type
suffix:semicolon
r_void
op_star
id|delta_buf
suffix:semicolon
multiline_comment|/* Don&squot;t bother doing diffs between different types */
r_if
c_cond
(paren
id|trg_entry-&gt;type
op_ne
id|src_entry-&gt;type
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* We do not compute delta to *create* objects we are not&n;&t; * going to pack.&n;&t; */
r_if
c_cond
(paren
id|trg_entry-&gt;preferred_base
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * We do not bother to try a delta that we discarded&n;&t; * on an earlier try, but only when reusing delta data.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|no_reuse_delta
op_logical_and
id|trg_entry-&gt;in_pack
op_logical_and
id|trg_entry-&gt;in_pack
op_eq
id|src_entry-&gt;in_pack
op_logical_and
id|trg_entry-&gt;in_pack_type
op_ne
id|OBJ_REF_DELTA
op_logical_and
id|trg_entry-&gt;in_pack_type
op_ne
id|OBJ_OFS_DELTA
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Let&squot;s not bust the allowed depth. */
r_if
c_cond
(paren
id|src-&gt;depth
op_ge
id|max_depth
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Now some size filtering heuristics. */
id|trg_size
op_assign
id|trg_entry-&gt;size
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|trg_entry-&gt;delta
)paren
(brace
id|max_size
op_assign
id|trg_size
op_div
l_int|2
l_int|20
suffix:semicolon
id|ref_depth
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|max_size
op_assign
id|trg_entry-&gt;delta_size
suffix:semicolon
id|ref_depth
op_assign
id|trg-&gt;depth
suffix:semicolon
)brace
id|max_size
op_assign
id|max_size
op_star
(paren
id|max_depth
id|src-&gt;depth
)paren
op_div
(paren
id|max_depth
id|ref_depth
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|max_size
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|src_size
op_assign
id|src_entry-&gt;size
suffix:semicolon
id|sizediff
op_assign
id|src_size
OL
id|trg_size
ques
c_cond
id|trg_size
id|src_size
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sizediff
op_ge
id|max_size
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|trg_size
OL
id|src_size
op_div
l_int|32
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Load data if not already done */
r_if
c_cond
(paren
op_logical_neg
id|trg-&gt;data
)paren
(brace
id|trg-&gt;data
op_assign
id|read_sha1_file
c_func
(paren
id|trg_entry-&gt;idx.sha1
comma
op_amp
id|type
comma
op_amp
id|sz
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sz
op_ne
id|trg_size
)paren
id|die
c_func
(paren
l_string|&quot;object %s inconsistent object length (%lu vs %lu)&quot;
comma
id|sha1_to_hex
c_func
(paren
id|trg_entry-&gt;idx.sha1
)paren
comma
id|sz
comma
id|trg_size
)paren
suffix:semicolon
id|window_memory_usage
op_add_assign
id|sz
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|src-&gt;data
)paren
(brace
id|src-&gt;data
op_assign
id|read_sha1_file
c_func
(paren
id|src_entry-&gt;idx.sha1
comma
op_amp
id|type
comma
op_amp
id|sz
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sz
op_ne
id|src_size
)paren
id|die
c_func
(paren
l_string|&quot;object %s inconsistent object length (%lu vs %lu)&quot;
comma
id|sha1_to_hex
c_func
(paren
id|src_entry-&gt;idx.sha1
)paren
comma
id|sz
comma
id|src_size
)paren
suffix:semicolon
id|window_memory_usage
op_add_assign
id|sz
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|src-&gt;index
)paren
(brace
id|src-&gt;index
op_assign
id|create_delta_index
c_func
(paren
id|src-&gt;data
comma
id|src_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|src-&gt;index
)paren
(brace
r_static
r_int
id|warned
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|warned
op_increment
)paren
id|warning
c_func
(paren
l_string|&quot;suboptimal pack - out of memory&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|window_memory_usage
op_add_assign
id|sizeof_delta_index
c_func
(paren
id|src-&gt;index
)paren
suffix:semicolon
)brace
id|delta_buf
op_assign
id|create_delta
c_func
(paren
id|src-&gt;index
comma
id|trg-&gt;data
comma
id|trg_size
comma
op_amp
id|delta_size
comma
id|max_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|delta_buf
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|trg_entry-&gt;delta_data
)paren
(brace
multiline_comment|/* Prefer only shallower same-sized deltas. */
r_if
c_cond
(paren
id|delta_size
op_eq
id|trg_entry-&gt;delta_size
op_logical_and
id|src-&gt;depth
op_plus
l_int|1
op_ge
id|trg-&gt;depth
)paren
(brace
id|free
c_func
(paren
id|delta_buf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|delta_cache_size
op_sub_assign
id|trg_entry-&gt;delta_size
suffix:semicolon
id|free
c_func
(paren
id|trg_entry-&gt;delta_data
)paren
suffix:semicolon
id|trg_entry-&gt;delta_data
op_assign
l_int|NULL
suffix:semicolon
)brace
id|trg_entry-&gt;delta
op_assign
id|src_entry
suffix:semicolon
id|trg_entry-&gt;delta_size
op_assign
id|delta_size
suffix:semicolon
id|trg-&gt;depth
op_assign
id|src-&gt;depth
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|delta_cacheable
c_func
(paren
id|src
comma
id|trg
comma
id|src_size
comma
id|trg_size
comma
id|delta_size
)paren
)paren
(brace
id|trg_entry-&gt;delta_data
op_assign
id|xrealloc
c_func
(paren
id|delta_buf
comma
id|delta_size
)paren
suffix:semicolon
id|delta_cache_size
op_add_assign
id|trg_entry-&gt;delta_size
suffix:semicolon
)brace
r_else
id|free
c_func
(paren
id|delta_buf
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|check_delta_limit
r_static
r_int
r_int
id|check_delta_limit
c_func
(paren
r_struct
id|object_entry
op_star
id|me
comma
r_int
r_int
id|n
)paren
(brace
r_struct
id|object_entry
op_star
id|child
op_assign
id|me-&gt;delta_child
suffix:semicolon
r_int
r_int
id|m
op_assign
id|n
suffix:semicolon
r_while
c_loop
(paren
id|child
)paren
(brace
r_int
r_int
id|c
op_assign
id|check_delta_limit
c_func
(paren
id|child
comma
id|n
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
OL
id|c
)paren
id|m
op_assign
id|c
suffix:semicolon
id|child
op_assign
id|child-&gt;delta_sibling
suffix:semicolon
)brace
r_return
id|m
suffix:semicolon
)brace
DECL|function|free_unpacked
r_static
r_void
id|free_unpacked
c_func
(paren
r_struct
id|unpacked
op_star
id|n
)paren
(brace
id|window_memory_usage
op_sub_assign
id|sizeof_delta_index
c_func
(paren
id|n-&gt;index
)paren
suffix:semicolon
id|free_delta_index
c_func
(paren
id|n-&gt;index
)paren
suffix:semicolon
id|n-&gt;index
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|n-&gt;data
)paren
(brace
id|free
c_func
(paren
id|n-&gt;data
)paren
suffix:semicolon
id|n-&gt;data
op_assign
l_int|NULL
suffix:semicolon
id|window_memory_usage
op_sub_assign
id|n-&gt;entry-&gt;size
suffix:semicolon
)brace
id|n-&gt;entry
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|find_deltas
r_static
r_void
id|find_deltas
c_func
(paren
r_struct
id|object_entry
op_star
op_star
id|list
comma
r_int
id|window
comma
r_int
id|depth
)paren
(brace
r_uint32
id|i
op_assign
id|nr_objects
comma
id|idx
op_assign
l_int|0
comma
id|count
op_assign
l_int|0
comma
id|processed
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|array_size
op_assign
id|window
op_star
r_sizeof
(paren
r_struct
id|unpacked
)paren
suffix:semicolon
r_struct
id|unpacked
op_star
id|array
suffix:semicolon
r_int
id|max_depth
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nr_objects
)paren
r_return
suffix:semicolon
id|array
op_assign
id|xmalloc
c_func
(paren
id|array_size
)paren
suffix:semicolon
id|memset
c_func
(paren
id|array
comma
l_int|0
comma
id|array_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|progress
)paren
id|start_progress
c_func
(paren
op_amp
id|progress_state
comma
l_string|&quot;Deltifying %u objects...&quot;
comma
l_string|&quot;&quot;
comma
id|nr_result
)paren
suffix:semicolon
r_do
(brace
r_struct
id|object_entry
op_star
id|entry
op_assign
id|list
(braket
op_decrement
id|i
)braket
suffix:semicolon
r_struct
id|unpacked
op_star
id|n
op_assign
id|array
op_plus
id|idx
suffix:semicolon
r_int
id|j
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;preferred_base
)paren
id|processed
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|progress
)paren
id|display_progress
c_func
(paren
op_amp
id|progress_state
comma
id|processed
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;delta
)paren
multiline_comment|/* This happens if we decided to reuse existing&n;&t;&t;&t; * delta from a pack.  &quot;!no_reuse_delta &amp;&amp;&quot; is implied.&n;&t;&t;&t; */
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;size
OL
l_int|50
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;no_try_delta
)paren
r_continue
suffix:semicolon
id|free_unpacked
c_func
(paren
id|n
)paren
suffix:semicolon
id|n-&gt;entry
op_assign
id|entry
suffix:semicolon
r_while
c_loop
(paren
id|window_memory_limit
op_logical_and
id|window_memory_usage
OG
id|window_memory_limit
op_logical_and
id|count
OG
l_int|1
)paren
(brace
r_uint32
id|tail
op_assign
(paren
id|idx
op_plus
id|window
id|count
)paren
op_mod
id|window
suffix:semicolon
id|free_unpacked
c_func
(paren
id|array
op_plus
id|tail
)paren
suffix:semicolon
id|count
op_decrement
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If the current object is at pack edge, take the depth the&n;&t;&t; * objects that depend on the current object into account&n;&t;&t; * otherwise they would become too deep.&n;&t;&t; */
id|max_depth
op_assign
id|depth
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;delta_child
)paren
(brace
id|max_depth
op_sub_assign
id|check_delta_limit
c_func
(paren
id|entry
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|max_depth
op_le
l_int|0
)paren
r_goto
id|next
suffix:semicolon
)brace
id|j
op_assign
id|window
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|j
OG
l_int|0
)paren
(brace
r_uint32
id|other_idx
op_assign
id|idx
op_plus
id|j
suffix:semicolon
r_struct
id|unpacked
op_star
id|m
suffix:semicolon
r_if
c_cond
(paren
id|other_idx
op_ge
id|window
)paren
id|other_idx
op_sub_assign
id|window
suffix:semicolon
id|m
op_assign
id|array
op_plus
id|other_idx
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|m-&gt;entry
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|try_delta
c_func
(paren
id|n
comma
id|m
comma
id|max_depth
)paren
OL
l_int|0
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* if we made n a delta, and if n is already at max&n;&t;&t; * depth, leaving it in the window is pointless.  we&n;&t;&t; * should evict it first.&n;&t;&t; */
r_if
c_cond
(paren
id|entry-&gt;delta
op_logical_and
id|depth
op_le
id|n-&gt;depth
)paren
r_continue
suffix:semicolon
id|next
suffix:colon
id|idx
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|count
op_plus
l_int|1
OL
id|window
)paren
id|count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|idx
op_ge
id|window
)paren
id|idx
op_assign
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
id|i
OG
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|progress
)paren
id|stop_progress
c_func
(paren
op_amp
id|progress_state
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|window
suffix:semicolon
op_increment
id|i
)paren
(brace
id|free_delta_index
c_func
(paren
id|array
(braket
id|i
)braket
dot
id|index
)paren
suffix:semicolon
id|free
c_func
(paren
id|array
(braket
id|i
)braket
dot
id|data
)paren
suffix:semicolon
)brace
id|free
c_func
(paren
id|array
)paren
suffix:semicolon
)brace
DECL|function|prepare_pack
r_static
r_void
id|prepare_pack
c_func
(paren
r_int
id|window
comma
r_int
id|depth
)paren
(brace
r_struct
id|object_entry
op_star
op_star
id|delta_list
suffix:semicolon
r_uint32
id|i
suffix:semicolon
id|get_object_details
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|window
op_logical_or
op_logical_neg
id|depth
)paren
r_return
suffix:semicolon
id|delta_list
op_assign
id|xmalloc
c_func
(paren
id|nr_objects
op_star
r_sizeof
(paren
op_star
id|delta_list
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_objects
suffix:semicolon
id|i
op_increment
)paren
id|delta_list
(braket
id|i
)braket
op_assign
id|objects
op_plus
id|i
suffix:semicolon
id|qsort
c_func
(paren
id|delta_list
comma
id|nr_objects
comma
r_sizeof
(paren
op_star
id|delta_list
)paren
comma
id|type_size_sort
)paren
suffix:semicolon
id|find_deltas
c_func
(paren
id|delta_list
comma
id|window
op_plus
l_int|1
comma
id|depth
)paren
suffix:semicolon
id|free
c_func
(paren
id|delta_list
)paren
suffix:semicolon
)brace
DECL|function|git_pack_config
r_static
r_int
id|git_pack_config
c_func
(paren
r_const
r_char
op_star
id|k
comma
r_const
r_char
op_star
id|v
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|k
comma
l_string|&quot;pack.window&quot;
)paren
)paren
(brace
id|window
op_assign
id|git_config_int
c_func
(paren
id|k
comma
id|v
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|k
comma
l_string|&quot;pack.windowmemory&quot;
)paren
)paren
(brace
id|window_memory_limit
op_assign
id|git_config_ulong
c_func
(paren
id|k
comma
id|v
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|k
comma
l_string|&quot;pack.depth&quot;
)paren
)paren
(brace
id|depth
op_assign
id|git_config_int
c_func
(paren
id|k
comma
id|v
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|k
comma
l_string|&quot;pack.compression&quot;
)paren
)paren
(brace
r_int
id|level
op_assign
id|git_config_int
c_func
(paren
id|k
comma
id|v
)paren
suffix:semicolon
r_if
c_cond
(paren
id|level
op_eq
l_int|1
)paren
id|level
op_assign
id|Z_DEFAULT_COMPRESSION
suffix:semicolon
r_else
r_if
c_cond
(paren
id|level
template_param
id|Z_BEST_COMPRESSION
)paren
id|die
c_func
(paren
l_string|&quot;bad pack compression level %d&quot;
comma
id|level
)paren
suffix:semicolon
id|pack_compression_level
op_assign
id|level
suffix:semicolon
id|pack_compression_seen
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|k
comma
l_string|&quot;pack.deltacachesize&quot;
)paren
)paren
(brace
id|max_delta_cache_size
op_assign
id|git_config_int
c_func
(paren
id|k
comma
id|v
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|k
comma
l_string|&quot;pack.deltacachelimit&quot;
)paren
)paren
(brace
id|cache_max_small_delta_size
op_assign
id|git_config_int
c_func
(paren
id|k
comma
id|v
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|git_default_config
c_func
(paren
id|k
comma
id|v
)paren
suffix:semicolon
)brace
DECL|function|read_object_list_from_stdin
r_static
r_void
id|read_object_list_from_stdin
c_func
(paren
r_void
)paren
(brace
r_char
id|line
(braket
l_int|40
op_plus
l_int|1
op_plus
id|PATH_MAX
op_plus
l_int|2
)braket
suffix:semicolon
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|fgets
c_func
(paren
id|line
comma
r_sizeof
(paren
id|line
)paren
comma
id|stdin
)paren
)paren
(brace
r_if
c_cond
(paren
id|feof
c_func
(paren
id|stdin
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ferror
c_func
(paren
id|stdin
)paren
)paren
id|die
c_func
(paren
l_string|&quot;fgets returned NULL, not EOF, not error!&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|errno
op_ne
id|EINTR
)paren
id|die
c_func
(paren
l_string|&quot;fgets: %s&quot;
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
id|clearerr
c_func
(paren
id|stdin
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|line
(braket
l_int|0
)braket
op_eq
l_char|&squot;-&squot;
)paren
(brace
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|line
op_plus
l_int|1
comma
id|sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;expected edge sha1, got garbage:&bslash;n %s&quot;
comma
id|line
)paren
suffix:semicolon
id|add_preferred_base
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|line
comma
id|sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;expected sha1, got garbage:&bslash;n %s&quot;
comma
id|line
)paren
suffix:semicolon
id|add_preferred_base_object
c_func
(paren
id|line
op_plus
l_int|41
)paren
suffix:semicolon
id|add_object_entry
c_func
(paren
id|sha1
comma
l_int|0
comma
id|line
op_plus
l_int|41
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
DECL|function|show_commit
r_static
r_void
id|show_commit
c_func
(paren
r_struct
id|commit
op_star
id|commit
)paren
(brace
id|add_object_entry
c_func
(paren
id|commit-&gt;object.sha1
comma
id|OBJ_COMMIT
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|show_object
r_static
r_void
id|show_object
c_func
(paren
r_struct
id|object_array_entry
op_star
id|p
)paren
(brace
id|add_preferred_base_object
c_func
(paren
id|p-&gt;name
)paren
suffix:semicolon
id|add_object_entry
c_func
(paren
id|p-&gt;item-&gt;sha1
comma
id|p-&gt;item-&gt;type
comma
id|p-&gt;name
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|show_edge
r_static
r_void
id|show_edge
c_func
(paren
r_struct
id|commit
op_star
id|commit
)paren
(brace
id|add_preferred_base
c_func
(paren
id|commit-&gt;object.sha1
)paren
suffix:semicolon
)brace
DECL|function|get_object_list
r_static
r_void
id|get_object_list
c_func
(paren
r_int
id|ac
comma
r_const
r_char
op_star
op_star
id|av
)paren
(brace
r_struct
id|rev_info
id|revs
suffix:semicolon
r_char
id|line
(braket
l_int|1000
)braket
suffix:semicolon
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
id|init_revisions
c_func
(paren
op_amp
id|revs
comma
l_int|NULL
)paren
suffix:semicolon
id|save_commit_buffer
op_assign
l_int|0
suffix:semicolon
id|track_object_refs
op_assign
l_int|0
suffix:semicolon
id|setup_revisions
c_func
(paren
id|ac
comma
id|av
comma
op_amp
id|revs
comma
l_int|NULL
)paren
suffix:semicolon
r_while
c_loop
(paren
id|fgets
c_func
(paren
id|line
comma
r_sizeof
(paren
id|line
)paren
comma
id|stdin
)paren
op_ne
l_int|NULL
)paren
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|line
)paren
suffix:semicolon
r_if
c_cond
(paren
id|line
(braket
id|len
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|line
(braket
op_decrement
id|len
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_star
id|line
op_eq
l_char|&squot;-&squot;
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|line
comma
l_string|&quot;--not&quot;
)paren
)paren
(brace
id|flags
op_xor_assign
id|UNINTERESTING
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|die
c_func
(paren
l_string|&quot;not a rev &squot;%s&squot;&quot;
comma
id|line
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|handle_revision_arg
c_func
(paren
id|line
comma
op_amp
id|revs
comma
id|flags
comma
l_int|1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;bad revision &squot;%s&squot;&quot;
comma
id|line
)paren
suffix:semicolon
)brace
id|prepare_revision_walk
c_func
(paren
op_amp
id|revs
)paren
suffix:semicolon
id|mark_edges_uninteresting
c_func
(paren
id|revs.commits
comma
op_amp
id|revs
comma
id|show_edge
)paren
suffix:semicolon
id|traverse_commit_list
c_func
(paren
op_amp
id|revs
comma
id|show_commit
comma
id|show_object
)paren
suffix:semicolon
)brace
DECL|function|adjust_perm
r_static
r_int
id|adjust_perm
c_func
(paren
r_const
r_char
op_star
id|path
comma
id|mode_t
id|mode
)paren
(brace
r_if
c_cond
(paren
id|chmod
c_func
(paren
id|path
comma
id|mode
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
id|adjust_shared_perm
c_func
(paren
id|path
)paren
suffix:semicolon
)brace
DECL|function|cmd_pack_objects
r_int
id|cmd_pack_objects
c_func
(paren
r_int
id|argc
comma
r_const
r_char
op_star
op_star
id|argv
comma
r_const
r_char
op_star
id|prefix
)paren
(brace
r_int
id|use_internal_rev_list
op_assign
l_int|0
suffix:semicolon
r_int
id|thin
op_assign
l_int|0
suffix:semicolon
r_uint32
id|i
suffix:semicolon
r_const
r_char
op_star
op_star
id|rp_av
suffix:semicolon
r_int
id|rp_ac_alloc
op_assign
l_int|64
suffix:semicolon
r_int
id|rp_ac
suffix:semicolon
id|rp_av
op_assign
id|xcalloc
c_func
(paren
id|rp_ac_alloc
comma
r_sizeof
(paren
op_star
id|rp_av
)paren
)paren
suffix:semicolon
id|rp_av
(braket
l_int|0
)braket
op_assign
l_string|&quot;pack-objects&quot;
suffix:semicolon
id|rp_av
(braket
l_int|1
)braket
op_assign
l_string|&quot;--objects&quot;
suffix:semicolon
multiline_comment|/* --thin will make it --objects-edge */
id|rp_ac
op_assign
l_int|2
suffix:semicolon
id|git_config
c_func
(paren
id|git_pack_config
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pack_compression_seen
op_logical_and
id|core_compression_seen
)paren
id|pack_compression_level
op_assign
id|core_compression_level
suffix:semicolon
id|progress
op_assign
id|isatty
c_func
(paren
l_int|2
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|argc
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_char
op_star
id|arg
op_assign
id|argv
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_star
id|arg
op_ne
l_char|&squot;-&squot;
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--non-empty&quot;
comma
id|arg
)paren
)paren
(brace
id|non_empty
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--local&quot;
comma
id|arg
)paren
)paren
(brace
id|local
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--incremental&quot;
comma
id|arg
)paren
)paren
(brace
id|incremental
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;--compression=&quot;
)paren
)paren
(brace
r_char
op_star
id|end
suffix:semicolon
r_int
id|level
op_assign
id|strtoul
c_func
(paren
id|arg
op_plus
l_int|14
comma
op_amp
id|end
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
(braket
l_int|14
)braket
op_logical_or
op_star
id|end
)paren
id|usage
c_func
(paren
id|pack_usage
)paren
suffix:semicolon
r_if
c_cond
(paren
id|level
op_eq
l_int|1
)paren
id|level
op_assign
id|Z_DEFAULT_COMPRESSION
suffix:semicolon
r_else
r_if
c_cond
(paren
id|level
template_param
id|Z_BEST_COMPRESSION
)paren
id|die
c_func
(paren
l_string|&quot;bad pack compression level %d&quot;
comma
id|level
)paren
suffix:semicolon
id|pack_compression_level
op_assign
id|level
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;--max-pack-size=&quot;
)paren
)paren
(brace
r_char
op_star
id|end
suffix:semicolon
id|pack_size_limit
op_assign
id|strtoul
c_func
(paren
id|arg
op_plus
l_int|16
comma
op_amp
id|end
comma
l_int|0
)paren
op_star
l_int|1024
op_star
l_int|1024
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
(braket
l_int|16
)braket
op_logical_or
op_star
id|end
)paren
id|usage
c_func
(paren
id|pack_usage
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;--window=&quot;
)paren
)paren
(brace
r_char
op_star
id|end
suffix:semicolon
id|window
op_assign
id|strtoul
c_func
(paren
id|arg
op_plus
l_int|9
comma
op_amp
id|end
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
(braket
l_int|9
)braket
op_logical_or
op_star
id|end
)paren
id|usage
c_func
(paren
id|pack_usage
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;--window-memory=&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|git_parse_ulong
c_func
(paren
id|arg
op_plus
l_int|16
comma
op_amp
id|window_memory_limit
)paren
)paren
id|usage
c_func
(paren
id|pack_usage
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;--depth=&quot;
)paren
)paren
(brace
r_char
op_star
id|end
suffix:semicolon
id|depth
op_assign
id|strtoul
c_func
(paren
id|arg
op_plus
l_int|8
comma
op_amp
id|end
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
(braket
l_int|8
)braket
op_logical_or
op_star
id|end
)paren
id|usage
c_func
(paren
id|pack_usage
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--progress&quot;
comma
id|arg
)paren
)paren
(brace
id|progress
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--all-progress&quot;
comma
id|arg
)paren
)paren
(brace
id|progress
op_assign
l_int|2
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;-q&quot;
comma
id|arg
)paren
)paren
(brace
id|progress
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--no-reuse-delta&quot;
comma
id|arg
)paren
)paren
(brace
id|no_reuse_delta
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--no-reuse-object&quot;
comma
id|arg
)paren
)paren
(brace
id|no_reuse_object
op_assign
id|no_reuse_delta
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--delta-base-offset&quot;
comma
id|arg
)paren
)paren
(brace
id|allow_ofs_delta
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--stdout&quot;
comma
id|arg
)paren
)paren
(brace
id|pack_to_stdout
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--revs&quot;
comma
id|arg
)paren
)paren
(brace
id|use_internal_rev_list
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--unpacked&quot;
comma
id|arg
)paren
op_logical_or
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;--unpacked=&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--reflog&quot;
comma
id|arg
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--all&quot;
comma
id|arg
)paren
)paren
(brace
id|use_internal_rev_list
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|rp_ac
op_ge
id|rp_ac_alloc
l_int|1
)paren
(brace
id|rp_ac_alloc
op_assign
id|alloc_nr
c_func
(paren
id|rp_ac_alloc
)paren
suffix:semicolon
id|rp_av
op_assign
id|xrealloc
c_func
(paren
id|rp_av
comma
id|rp_ac_alloc
op_star
r_sizeof
(paren
op_star
id|rp_av
)paren
)paren
suffix:semicolon
)brace
id|rp_av
(braket
id|rp_ac
op_increment
)braket
op_assign
id|arg
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--thin&quot;
comma
id|arg
)paren
)paren
(brace
id|use_internal_rev_list
op_assign
l_int|1
suffix:semicolon
id|thin
op_assign
l_int|1
suffix:semicolon
id|rp_av
(braket
l_int|1
)braket
op_assign
l_string|&quot;--objects-edge&quot;
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;--index-version=&quot;
)paren
)paren
(brace
r_char
op_star
id|c
suffix:semicolon
id|pack_idx_default_version
op_assign
id|strtoul
c_func
(paren
id|arg
op_plus
l_int|16
comma
op_amp
id|c
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pack_idx_default_version
OG
l_int|2
)paren
id|die
c_func
(paren
l_string|&quot;bad %s&quot;
comma
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|c
op_eq
l_char|&squot;,&squot;
)paren
id|pack_idx_off32_limit
op_assign
id|strtoul
c_func
(paren
id|c
op_plus
l_int|1
comma
op_amp
id|c
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|c
op_logical_or
id|pack_idx_off32_limit
op_amp
l_int|0x80000000
)paren
id|die
c_func
(paren
l_string|&quot;bad %s&quot;
comma
id|arg
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|usage
c_func
(paren
id|pack_usage
)paren
suffix:semicolon
)brace
multiline_comment|/* Traditionally &quot;pack-objects [options] base extra&quot; failed;&n;&t; * we would however want to take refs parameter that would&n;&t; * have been given to upstream rev-list ourselves, which means&n;&t; * we somehow want to say what the base name is.  So the&n;&t; * syntax would be:&n;&t; *&n;&t; * pack-objects [options] base &lt;refs...&gt;&n;&t; *&n;&t; * in other words, we would treat the first non-option as the&n;&t; * base_name and send everything else to the internal revision&n;&t; * walker.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|pack_to_stdout
)paren
id|base_name
op_assign
id|argv
(braket
id|i
op_increment
)braket
suffix:semicolon
r_if
c_cond
(paren
id|pack_to_stdout
op_ne
op_logical_neg
id|base_name
)paren
id|usage
c_func
(paren
id|pack_usage
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pack_to_stdout
op_logical_and
id|pack_size_limit
)paren
id|die
c_func
(paren
l_string|&quot;--max-pack-size cannot be used to build a pack for transfer.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pack_to_stdout
op_logical_and
id|thin
)paren
id|die
c_func
(paren
l_string|&quot;--thin cannot be used to build an indexable pack.&quot;
)paren
suffix:semicolon
id|prepare_packed_git
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|progress
)paren
id|start_progress
c_func
(paren
op_amp
id|progress_state
comma
l_string|&quot;Generating pack...&quot;
comma
l_string|&quot;Counting objects: &quot;
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|use_internal_rev_list
)paren
id|read_object_list_from_stdin
c_func
(paren
)paren
suffix:semicolon
r_else
(brace
id|rp_av
(braket
id|rp_ac
)braket
op_assign
l_int|NULL
suffix:semicolon
id|get_object_list
c_func
(paren
id|rp_ac
comma
id|rp_av
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|progress
)paren
(brace
id|stop_progress
c_func
(paren
op_amp
id|progress_state
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Done counting %u objects.&bslash;n&quot;
comma
id|nr_objects
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|non_empty
op_logical_and
op_logical_neg
id|nr_result
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|progress
op_logical_and
(paren
id|nr_objects
op_ne
id|nr_result
)paren
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Result has %u objects.&bslash;n&quot;
comma
id|nr_result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr_result
)paren
id|prepare_pack
c_func
(paren
id|window
comma
id|depth
)paren
suffix:semicolon
id|write_pack_file
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|progress
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Total %u (delta %u), reused %u (delta %u)&bslash;n&quot;
comma
id|written
comma
id|written_delta
comma
id|reused
comma
id|reused_delta
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
