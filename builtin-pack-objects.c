macro_line|#include &quot;builtin.h&quot;
macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;object.h&quot;
macro_line|#include &quot;blob.h&quot;
macro_line|#include &quot;commit.h&quot;
macro_line|#include &quot;tag.h&quot;
macro_line|#include &quot;tree.h&quot;
macro_line|#include &quot;delta.h&quot;
macro_line|#include &quot;pack.h&quot;
macro_line|#include &quot;csum-file.h&quot;
macro_line|#include &quot;tree-walk.h&quot;
macro_line|#include &quot;diff.h&quot;
macro_line|#include &quot;revision.h&quot;
macro_line|#include &quot;list-objects.h&quot;
DECL|variable|pack_usage
r_static
r_const
r_char
id|pack_usage
(braket
)braket
op_assign
l_string|&quot;&bslash;&n;git-pack-objects [{ -q | --progress | --all-progress }] &bslash;n&bslash;&n;&t;[--local] [--incremental] [--window=N] [--depth=N] &bslash;n&bslash;&n;&t;[--no-reuse-delta] [--delta-base-offset] [--non-empty] &bslash;n&bslash;&n;&t;[--revs [--unpacked | --all]*] [--reflog] [--stdout | base-name] &bslash;n&bslash;&n;&t;[&lt;ref-list | &lt;object-list]&quot;
suffix:semicolon
DECL|struct|object_entry
r_struct
id|object_entry
(brace
DECL|member|sha1
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
DECL|member|size
r_int
r_int
id|size
suffix:semicolon
multiline_comment|/* uncompressed size */
DECL|member|offset
id|off_t
id|offset
suffix:semicolon
multiline_comment|/* offset into the final pack file;&n;&t;&t;&t;&t; * nonzero if already written.&n;&t;&t;&t;&t; */
DECL|member|depth
r_int
r_int
id|depth
suffix:semicolon
multiline_comment|/* delta depth */
DECL|member|delta_limit
r_int
r_int
id|delta_limit
suffix:semicolon
multiline_comment|/* base adjustment for in-pack delta */
DECL|member|hash
r_int
r_int
id|hash
suffix:semicolon
multiline_comment|/* name hint hash */
DECL|member|type
r_enum
id|object_type
id|type
suffix:semicolon
DECL|member|in_pack_type
r_enum
id|object_type
id|in_pack_type
suffix:semicolon
multiline_comment|/* could be delta */
DECL|member|delta_size
r_int
r_int
id|delta_size
suffix:semicolon
multiline_comment|/* delta data size (uncompressed) */
DECL|macro|in_pack_header_size
mdefine_line|#define in_pack_header_size delta_size&t;/* only when reusing pack data */
DECL|member|delta
r_struct
id|object_entry
op_star
id|delta
suffix:semicolon
multiline_comment|/* delta base object */
DECL|member|in_pack
r_struct
id|packed_git
op_star
id|in_pack
suffix:semicolon
multiline_comment|/* already in pack */
DECL|member|in_pack_offset
id|off_t
id|in_pack_offset
suffix:semicolon
DECL|member|delta_child
r_struct
id|object_entry
op_star
id|delta_child
suffix:semicolon
multiline_comment|/* deltified objects who bases me */
DECL|member|delta_sibling
r_struct
id|object_entry
op_star
id|delta_sibling
suffix:semicolon
multiline_comment|/* other deltified objects who&n;&t;&t;&t;&t;&t;     * uses the same base as me&n;&t;&t;&t;&t;&t;     */
DECL|member|preferred_base
r_int
id|preferred_base
suffix:semicolon
multiline_comment|/* we do not pack this, but is encouraged to&n;&t;&t;&t;&t; * be used as the base objectto delta huge&n;&t;&t;&t;&t; * objects against.&n;&t;&t;&t;&t; */
DECL|member|crc32
r_uint32
id|crc32
suffix:semicolon
multiline_comment|/* crc of raw pack data for this object */
)brace
suffix:semicolon
multiline_comment|/*&n; * Objects we are going to pack are collected in objects array (dynamically&n; * expanded).  nr_objects &amp; nr_alloc controls this array.  They are stored&n; * in the order we see -- typically rev-list --objects order that gives us&n; * nice &quot;minimum seek&quot; order.&n; *&n; * sorted-by-sha ans sorted-by-type are arrays of pointers that point at&n; * elements in the objects array.  The former is used to build the pack&n; * index (lists object names in the ascending order to help offset lookup),&n; * and the latter is used to group similar things together by try_delta()&n; * heuristics.&n; */
DECL|variable|object_list_sha1
r_static
r_int
r_char
id|object_list_sha1
(braket
l_int|20
)braket
suffix:semicolon
DECL|variable|non_empty
r_static
r_int
id|non_empty
suffix:semicolon
DECL|variable|no_reuse_delta
r_static
r_int
id|no_reuse_delta
suffix:semicolon
DECL|variable|local
r_static
r_int
id|local
suffix:semicolon
DECL|variable|incremental
r_static
r_int
id|incremental
suffix:semicolon
DECL|variable|allow_ofs_delta
r_static
r_int
id|allow_ofs_delta
suffix:semicolon
DECL|variable|sorted_by_sha
DECL|variable|sorted_by_type
r_static
r_struct
id|object_entry
op_star
op_star
id|sorted_by_sha
comma
op_star
op_star
id|sorted_by_type
suffix:semicolon
DECL|variable|objects
r_static
r_struct
id|object_entry
op_star
id|objects
suffix:semicolon
DECL|variable|nr_objects
DECL|variable|nr_alloc
DECL|variable|nr_result
r_static
r_uint32
id|nr_objects
comma
id|nr_alloc
comma
id|nr_result
suffix:semicolon
DECL|variable|base_name
r_static
r_const
r_char
op_star
id|base_name
suffix:semicolon
DECL|variable|pack_file_sha1
r_static
r_int
r_char
id|pack_file_sha1
(braket
l_int|20
)braket
suffix:semicolon
DECL|variable|progress
r_static
r_int
id|progress
op_assign
l_int|1
suffix:semicolon
DECL|variable|progress_update
r_static
r_volatile
id|sig_atomic_t
id|progress_update
suffix:semicolon
DECL|variable|window
r_static
r_int
id|window
op_assign
l_int|10
suffix:semicolon
DECL|variable|pack_to_stdout
r_static
r_int
id|pack_to_stdout
suffix:semicolon
DECL|variable|num_preferred_base
r_static
r_int
id|num_preferred_base
suffix:semicolon
multiline_comment|/*&n; * The object names in objects array are hashed with this hashtable,&n; * to help looking up the entry by object name.  Binary search from&n; * sorted_by_sha is also possible but this was easier to code and faster.&n; * This hashtable is built after all the objects are seen.&n; */
DECL|variable|object_ix
r_static
r_int
op_star
id|object_ix
suffix:semicolon
DECL|variable|object_ix_hashsz
r_static
r_int
id|object_ix_hashsz
suffix:semicolon
multiline_comment|/*&n; * Pack index for existing packs give us easy access to the offsets into&n; * corresponding pack file where each object&squot;s data starts, but the entries&n; * do not store the size of the compressed representation (uncompressed&n; * size is easily available by examining the pack entry header).  It is&n; * also rather expensive to find the sha1 for an object given its offset.&n; *&n; * We build a hashtable of existing packs (pack_revindex), and keep reverse&n; * index here -- pack index file is sorted by object name mapping to offset;&n; * this pack_revindex[].revindex array is a list of offset/index_nr pairs&n; * ordered by offset, so if you know the offset of an object, next offset&n; * is where its packed representation ends and the index_nr can be used to&n; * get the object sha1 from the main index.&n; */
DECL|struct|revindex_entry
r_struct
id|revindex_entry
(brace
DECL|member|offset
id|off_t
id|offset
suffix:semicolon
DECL|member|nr
r_int
r_int
id|nr
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|pack_revindex
r_struct
id|pack_revindex
(brace
DECL|member|p
r_struct
id|packed_git
op_star
id|p
suffix:semicolon
DECL|member|revindex
r_struct
id|revindex_entry
op_star
id|revindex
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|pack_revindex
r_static
r_struct
id|pack_revindex
op_star
id|pack_revindex
suffix:semicolon
DECL|variable|pack_revindex_hashsz
r_static
r_int
id|pack_revindex_hashsz
suffix:semicolon
multiline_comment|/*&n; * stats&n; */
DECL|variable|written
DECL|variable|written_delta
r_static
r_uint32
id|written
comma
id|written_delta
suffix:semicolon
DECL|variable|reused
DECL|variable|reused_delta
r_static
r_uint32
id|reused
comma
id|reused_delta
suffix:semicolon
DECL|function|pack_revindex_ix
r_static
r_int
id|pack_revindex_ix
c_func
(paren
r_struct
id|packed_git
op_star
id|p
)paren
(brace
r_int
r_int
id|ui
op_assign
(paren
r_int
r_int
)paren
id|p
suffix:semicolon
r_int
id|i
suffix:semicolon
id|ui
op_assign
id|ui
op_xor
(paren
id|ui
op_rshift
l_int|16
)paren
suffix:semicolon
multiline_comment|/* defeat structure alignment */
id|i
op_assign
(paren
r_int
)paren
(paren
id|ui
op_mod
id|pack_revindex_hashsz
)paren
suffix:semicolon
r_while
c_loop
(paren
id|pack_revindex
(braket
id|i
)braket
dot
id|p
)paren
(brace
r_if
c_cond
(paren
id|pack_revindex
(braket
id|i
)braket
dot
id|p
op_eq
id|p
)paren
r_return
id|i
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|i
op_eq
id|pack_revindex_hashsz
)paren
id|i
op_assign
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
id|i
suffix:semicolon
)brace
DECL|function|prepare_pack_ix
r_static
r_void
id|prepare_pack_ix
c_func
(paren
r_void
)paren
(brace
r_int
id|num
suffix:semicolon
r_struct
id|packed_git
op_star
id|p
suffix:semicolon
r_for
c_loop
(paren
id|num
op_assign
l_int|0
comma
id|p
op_assign
id|packed_git
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
id|num
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|num
)paren
r_return
suffix:semicolon
id|pack_revindex_hashsz
op_assign
id|num
op_star
l_int|11
suffix:semicolon
id|pack_revindex
op_assign
id|xcalloc
c_func
(paren
r_sizeof
(paren
op_star
id|pack_revindex
)paren
comma
id|pack_revindex_hashsz
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|packed_git
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
id|num
op_assign
id|pack_revindex_ix
c_func
(paren
id|p
)paren
suffix:semicolon
id|num
op_assign
l_int|1
id|num
suffix:semicolon
id|pack_revindex
(braket
id|num
)braket
dot
id|p
op_assign
id|p
suffix:semicolon
)brace
multiline_comment|/* revindex elements are lazily initialized */
)brace
DECL|function|cmp_offset
r_static
r_int
id|cmp_offset
c_func
(paren
r_const
r_void
op_star
id|a_
comma
r_const
r_void
op_star
id|b_
)paren
(brace
r_const
r_struct
id|revindex_entry
op_star
id|a
op_assign
id|a_
suffix:semicolon
r_const
r_struct
id|revindex_entry
op_star
id|b
op_assign
id|b_
suffix:semicolon
r_return
(paren
id|a-&gt;offset
OL
id|b-&gt;offset
)paren
ques
c_cond
l_int|1
suffix:colon
(paren
id|a-&gt;offset
OG
id|b-&gt;offset
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Ordered list of offsets of objects in the pack.&n; */
DECL|function|prepare_pack_revindex
r_static
r_void
id|prepare_pack_revindex
c_func
(paren
r_struct
id|pack_revindex
op_star
id|rix
)paren
(brace
r_struct
id|packed_git
op_star
id|p
op_assign
id|rix-&gt;p
suffix:semicolon
r_int
id|num_ent
op_assign
id|p-&gt;num_objects
suffix:semicolon
r_int
id|i
suffix:semicolon
r_const
r_char
op_star
id|index
op_assign
id|p-&gt;index_data
suffix:semicolon
id|rix-&gt;revindex
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|rix-&gt;revindex
)paren
op_star
(paren
id|num_ent
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|index
op_add_assign
l_int|4
op_star
l_int|256
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;index_version
OG
l_int|1
)paren
(brace
r_const
r_uint32
op_star
id|off_32
op_assign
(paren
r_uint32
op_star
)paren
(paren
id|index
op_plus
l_int|8
op_plus
id|p-&gt;num_objects
op_star
(paren
l_int|20
op_plus
l_int|4
)paren
)paren
suffix:semicolon
r_const
r_uint32
op_star
id|off_64
op_assign
id|off_32
op_plus
id|p-&gt;num_objects
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_ent
suffix:semicolon
id|i
op_increment
)paren
(brace
r_uint32
id|off
op_assign
id|ntohl
c_func
(paren
op_star
id|off_32
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|off
op_amp
l_int|0x80000000
)paren
)paren
(brace
id|rix-&gt;revindex
(braket
id|i
)braket
dot
id|offset
op_assign
id|off
suffix:semicolon
)brace
r_else
(brace
id|rix-&gt;revindex
(braket
id|i
)braket
dot
id|offset
op_assign
(paren
(paren
r_uint64
)paren
id|ntohl
c_func
(paren
op_star
id|off_64
op_increment
)paren
)paren
op_lshift
l_int|32
suffix:semicolon
id|rix-&gt;revindex
(braket
id|i
)braket
dot
id|offset
op_or_assign
id|ntohl
c_func
(paren
op_star
id|off_64
op_increment
)paren
suffix:semicolon
)brace
id|rix-&gt;revindex
(braket
id|i
)braket
dot
id|nr
op_assign
id|i
suffix:semicolon
)brace
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_ent
suffix:semicolon
id|i
op_increment
)paren
(brace
r_uint32
id|hl
op_assign
op_star
(paren
(paren
r_uint32
op_star
)paren
(paren
id|index
op_plus
l_int|24
op_star
id|i
)paren
)paren
suffix:semicolon
id|rix-&gt;revindex
(braket
id|i
)braket
dot
id|offset
op_assign
id|ntohl
c_func
(paren
id|hl
)paren
suffix:semicolon
id|rix-&gt;revindex
(braket
id|i
)braket
dot
id|nr
op_assign
id|i
suffix:semicolon
)brace
)brace
multiline_comment|/* This knows the pack format -- the 20-byte trailer&n;&t; * follows immediately after the last object data.&n;&t; */
id|rix-&gt;revindex
(braket
id|num_ent
)braket
dot
id|offset
op_assign
id|p-&gt;pack_size
l_int|20
suffix:semicolon
id|rix-&gt;revindex
(braket
id|num_ent
)braket
dot
id|nr
op_assign
l_int|1
suffix:semicolon
id|qsort
c_func
(paren
id|rix-&gt;revindex
comma
id|num_ent
comma
r_sizeof
(paren
op_star
id|rix-&gt;revindex
)paren
comma
id|cmp_offset
)paren
suffix:semicolon
)brace
DECL|function|find_packed_object
r_static
r_struct
id|revindex_entry
op_star
id|find_packed_object
c_func
(paren
r_struct
id|packed_git
op_star
id|p
comma
id|off_t
id|ofs
)paren
(brace
r_int
id|num
suffix:semicolon
r_int
id|lo
comma
id|hi
suffix:semicolon
r_struct
id|pack_revindex
op_star
id|rix
suffix:semicolon
r_struct
id|revindex_entry
op_star
id|revindex
suffix:semicolon
id|num
op_assign
id|pack_revindex_ix
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|num
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;internal error: pack revindex uninitialized&quot;
)paren
suffix:semicolon
id|rix
op_assign
op_amp
id|pack_revindex
(braket
id|num
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rix-&gt;revindex
)paren
id|prepare_pack_revindex
c_func
(paren
id|rix
)paren
suffix:semicolon
id|revindex
op_assign
id|rix-&gt;revindex
suffix:semicolon
id|lo
op_assign
l_int|0
suffix:semicolon
id|hi
op_assign
id|p-&gt;num_objects
op_plus
l_int|1
suffix:semicolon
r_do
(brace
r_int
id|mi
op_assign
(paren
id|lo
op_plus
id|hi
)paren
op_div
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|revindex
(braket
id|mi
)braket
dot
id|offset
op_eq
id|ofs
)paren
(brace
r_return
id|revindex
op_plus
id|mi
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ofs
OL
id|revindex
(braket
id|mi
)braket
dot
id|offset
)paren
id|hi
op_assign
id|mi
suffix:semicolon
r_else
id|lo
op_assign
id|mi
op_plus
l_int|1
suffix:semicolon
)brace
r_while
c_loop
(paren
id|lo
OL
id|hi
)paren
suffix:semicolon
id|die
c_func
(paren
l_string|&quot;internal error: pack revindex corrupt&quot;
)paren
suffix:semicolon
)brace
DECL|function|find_packed_object_name
r_static
r_const
r_int
r_char
op_star
id|find_packed_object_name
c_func
(paren
r_struct
id|packed_git
op_star
id|p
comma
id|off_t
id|ofs
)paren
(brace
r_struct
id|revindex_entry
op_star
id|entry
op_assign
id|find_packed_object
c_func
(paren
id|p
comma
id|ofs
)paren
suffix:semicolon
r_return
id|nth_packed_object_sha1
c_func
(paren
id|p
comma
id|entry-&gt;nr
)paren
suffix:semicolon
)brace
DECL|function|delta_against
r_static
r_void
op_star
id|delta_against
c_func
(paren
r_void
op_star
id|buf
comma
r_int
r_int
id|size
comma
r_struct
id|object_entry
op_star
id|entry
)paren
(brace
r_int
r_int
id|othersize
comma
id|delta_size
suffix:semicolon
r_enum
id|object_type
id|type
suffix:semicolon
r_void
op_star
id|otherbuf
op_assign
id|read_sha1_file
c_func
(paren
id|entry-&gt;delta-&gt;sha1
comma
op_amp
id|type
comma
op_amp
id|othersize
)paren
suffix:semicolon
r_void
op_star
id|delta_buf
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|otherbuf
)paren
id|die
c_func
(paren
l_string|&quot;unable to read %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|entry-&gt;delta-&gt;sha1
)paren
)paren
suffix:semicolon
id|delta_buf
op_assign
id|diff_delta
c_func
(paren
id|otherbuf
comma
id|othersize
comma
id|buf
comma
id|size
comma
op_amp
id|delta_size
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|delta_buf
op_logical_or
id|delta_size
op_ne
id|entry-&gt;delta_size
)paren
id|die
c_func
(paren
l_string|&quot;delta size changed&quot;
)paren
suffix:semicolon
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
id|free
c_func
(paren
id|otherbuf
)paren
suffix:semicolon
r_return
id|delta_buf
suffix:semicolon
)brace
multiline_comment|/*&n; * The per-object header is a pretty dense thing, which is&n; *  - first byte: low four bits are &quot;size&quot;, then three bits of &quot;type&quot;,&n; *    and the high bit is &quot;size continues&quot;.&n; *  - each byte afterwards: low seven bits are size continuation,&n; *    with the high bit being &quot;size continues&quot;&n; */
DECL|function|encode_header
r_static
r_int
id|encode_header
c_func
(paren
r_enum
id|object_type
id|type
comma
r_int
r_int
id|size
comma
r_int
r_char
op_star
id|hdr
)paren
(brace
r_int
id|n
op_assign
l_int|1
suffix:semicolon
r_int
r_char
id|c
suffix:semicolon
r_if
c_cond
(paren
id|type
template_param
id|OBJ_REF_DELTA
)paren
id|die
c_func
(paren
l_string|&quot;bad type %d&quot;
comma
id|type
)paren
suffix:semicolon
id|c
op_assign
(paren
id|type
op_lshift
l_int|4
)paren
op_or
(paren
id|size
op_amp
l_int|15
)paren
suffix:semicolon
id|size
op_rshift_assign
l_int|4
suffix:semicolon
r_while
c_loop
(paren
id|size
)paren
(brace
op_star
id|hdr
op_increment
op_assign
id|c
op_or
l_int|0x80
suffix:semicolon
id|c
op_assign
id|size
op_amp
l_int|0x7f
suffix:semicolon
id|size
op_rshift_assign
l_int|7
suffix:semicolon
id|n
op_increment
suffix:semicolon
)brace
op_star
id|hdr
op_assign
id|c
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
multiline_comment|/*&n; * we are going to reuse the existing object data as is.  make&n; * sure it is not corrupt.&n; */
DECL|function|check_pack_inflate
r_static
r_int
id|check_pack_inflate
c_func
(paren
r_struct
id|packed_git
op_star
id|p
comma
r_struct
id|pack_window
op_star
op_star
id|w_curs
comma
id|off_t
id|offset
comma
id|off_t
id|len
comma
r_int
r_int
id|expect
)paren
(brace
id|z_stream
id|stream
suffix:semicolon
r_int
r_char
id|fakebuf
(braket
l_int|4096
)braket
comma
op_star
id|in
suffix:semicolon
r_int
id|st
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|stream
comma
l_int|0
comma
r_sizeof
(paren
id|stream
)paren
)paren
suffix:semicolon
id|inflateInit
c_func
(paren
op_amp
id|stream
)paren
suffix:semicolon
r_do
(brace
id|in
op_assign
id|use_pack
c_func
(paren
id|p
comma
id|w_curs
comma
id|offset
comma
op_amp
id|stream.avail_in
)paren
suffix:semicolon
id|stream.next_in
op_assign
id|in
suffix:semicolon
id|stream.next_out
op_assign
id|fakebuf
suffix:semicolon
id|stream.avail_out
op_assign
r_sizeof
(paren
id|fakebuf
)paren
suffix:semicolon
id|st
op_assign
id|inflate
c_func
(paren
op_amp
id|stream
comma
id|Z_FINISH
)paren
suffix:semicolon
id|offset
op_add_assign
id|stream.next_in
id|in
suffix:semicolon
)brace
r_while
c_loop
(paren
id|st
op_eq
id|Z_OK
op_logical_or
id|st
op_eq
id|Z_BUF_ERROR
)paren
suffix:semicolon
id|inflateEnd
c_func
(paren
op_amp
id|stream
)paren
suffix:semicolon
r_return
(paren
id|st
op_eq
id|Z_STREAM_END
op_logical_and
id|stream.total_out
op_eq
id|expect
op_logical_and
id|stream.total_in
op_eq
id|len
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
)brace
DECL|function|check_pack_crc
r_static
r_int
id|check_pack_crc
c_func
(paren
r_struct
id|packed_git
op_star
id|p
comma
r_struct
id|pack_window
op_star
op_star
id|w_curs
comma
id|off_t
id|offset
comma
id|off_t
id|len
comma
r_int
r_int
id|nr
)paren
(brace
r_const
r_uint32
op_star
id|index_crc
suffix:semicolon
r_uint32
id|data_crc
op_assign
id|crc32
c_func
(paren
l_int|0
comma
id|Z_NULL
comma
l_int|0
)paren
suffix:semicolon
r_do
(brace
r_int
r_int
id|avail
suffix:semicolon
r_void
op_star
id|data
op_assign
id|use_pack
c_func
(paren
id|p
comma
id|w_curs
comma
id|offset
comma
op_amp
id|avail
)paren
suffix:semicolon
r_if
c_cond
(paren
id|avail
OG
id|len
)paren
id|avail
op_assign
id|len
suffix:semicolon
id|data_crc
op_assign
id|crc32
c_func
(paren
id|data_crc
comma
id|data
comma
id|avail
)paren
suffix:semicolon
id|offset
op_add_assign
id|avail
suffix:semicolon
id|len
op_sub_assign
id|avail
suffix:semicolon
)brace
r_while
c_loop
(paren
id|len
)paren
suffix:semicolon
id|index_crc
op_assign
id|p-&gt;index_data
suffix:semicolon
id|index_crc
op_add_assign
l_int|2
op_plus
l_int|256
op_plus
id|p-&gt;num_objects
op_star
(paren
l_int|20
op_div
l_int|4
)paren
op_plus
id|nr
suffix:semicolon
r_return
id|data_crc
op_ne
id|ntohl
c_func
(paren
op_star
id|index_crc
)paren
suffix:semicolon
)brace
DECL|function|copy_pack_data
r_static
r_void
id|copy_pack_data
c_func
(paren
r_struct
id|sha1file
op_star
id|f
comma
r_struct
id|packed_git
op_star
id|p
comma
r_struct
id|pack_window
op_star
op_star
id|w_curs
comma
id|off_t
id|offset
comma
id|off_t
id|len
)paren
(brace
r_int
r_char
op_star
id|in
suffix:semicolon
r_int
r_int
id|avail
suffix:semicolon
r_while
c_loop
(paren
id|len
)paren
(brace
id|in
op_assign
id|use_pack
c_func
(paren
id|p
comma
id|w_curs
comma
id|offset
comma
op_amp
id|avail
)paren
suffix:semicolon
r_if
c_cond
(paren
id|avail
OG
id|len
)paren
id|avail
op_assign
(paren
r_int
r_int
)paren
id|len
suffix:semicolon
id|sha1write
c_func
(paren
id|f
comma
id|in
comma
id|avail
)paren
suffix:semicolon
id|offset
op_add_assign
id|avail
suffix:semicolon
id|len
op_sub_assign
id|avail
suffix:semicolon
)brace
)brace
DECL|function|check_loose_inflate
r_static
r_int
id|check_loose_inflate
c_func
(paren
r_int
r_char
op_star
id|data
comma
r_int
r_int
id|len
comma
r_int
r_int
id|expect
)paren
(brace
id|z_stream
id|stream
suffix:semicolon
r_int
r_char
id|fakebuf
(braket
l_int|4096
)braket
suffix:semicolon
r_int
id|st
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|stream
comma
l_int|0
comma
r_sizeof
(paren
id|stream
)paren
)paren
suffix:semicolon
id|stream.next_in
op_assign
id|data
suffix:semicolon
id|stream.avail_in
op_assign
id|len
suffix:semicolon
id|stream.next_out
op_assign
id|fakebuf
suffix:semicolon
id|stream.avail_out
op_assign
r_sizeof
(paren
id|fakebuf
)paren
suffix:semicolon
id|inflateInit
c_func
(paren
op_amp
id|stream
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|st
op_assign
id|inflate
c_func
(paren
op_amp
id|stream
comma
id|Z_FINISH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
op_eq
id|Z_STREAM_END
op_logical_or
id|st
op_eq
id|Z_OK
)paren
(brace
id|st
op_assign
(paren
id|stream.total_out
op_eq
id|expect
op_logical_and
id|stream.total_in
op_eq
id|len
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|st
op_ne
id|Z_BUF_ERROR
)paren
(brace
id|st
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|stream.next_out
op_assign
id|fakebuf
suffix:semicolon
id|stream.avail_out
op_assign
r_sizeof
(paren
id|fakebuf
)paren
suffix:semicolon
)brace
id|inflateEnd
c_func
(paren
op_amp
id|stream
)paren
suffix:semicolon
r_return
id|st
suffix:semicolon
)brace
DECL|function|revalidate_loose_object
r_static
r_int
id|revalidate_loose_object
c_func
(paren
r_struct
id|object_entry
op_star
id|entry
comma
r_int
r_char
op_star
id|map
comma
r_int
r_int
id|mapsize
)paren
(brace
multiline_comment|/* we already know this is a loose object with new type header. */
r_enum
id|object_type
id|type
suffix:semicolon
r_int
r_int
id|size
comma
id|used
suffix:semicolon
r_if
c_cond
(paren
id|pack_to_stdout
)paren
r_return
l_int|0
suffix:semicolon
id|used
op_assign
id|unpack_object_header_gently
c_func
(paren
id|map
comma
id|mapsize
comma
op_amp
id|type
comma
op_amp
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|used
)paren
r_return
l_int|1
suffix:semicolon
id|map
op_add_assign
id|used
suffix:semicolon
id|mapsize
op_sub_assign
id|used
suffix:semicolon
r_return
id|check_loose_inflate
c_func
(paren
id|map
comma
id|mapsize
comma
id|size
)paren
suffix:semicolon
)brace
DECL|function|write_object
r_static
r_int
r_int
id|write_object
c_func
(paren
r_struct
id|sha1file
op_star
id|f
comma
r_struct
id|object_entry
op_star
id|entry
)paren
(brace
r_int
r_int
id|size
suffix:semicolon
r_enum
id|object_type
id|type
suffix:semicolon
r_void
op_star
id|buf
suffix:semicolon
r_int
r_char
id|header
(braket
l_int|10
)braket
suffix:semicolon
r_int
id|hdrlen
suffix:semicolon
id|off_t
id|datalen
suffix:semicolon
r_enum
id|object_type
id|obj_type
suffix:semicolon
r_int
id|to_reuse
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pack_to_stdout
)paren
id|crc32_begin
c_func
(paren
id|f
)paren
suffix:semicolon
id|obj_type
op_assign
id|entry-&gt;type
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;in_pack
)paren
id|to_reuse
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* can&squot;t reuse what we don&squot;t have */
r_else
r_if
c_cond
(paren
id|obj_type
op_eq
id|OBJ_REF_DELTA
op_logical_or
id|obj_type
op_eq
id|OBJ_OFS_DELTA
)paren
id|to_reuse
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* check_object() decided it for us */
r_else
r_if
c_cond
(paren
id|obj_type
op_ne
id|entry-&gt;in_pack_type
)paren
id|to_reuse
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* pack has delta which is unusable */
r_else
r_if
c_cond
(paren
id|entry-&gt;delta
)paren
id|to_reuse
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* we want to pack afresh */
r_else
id|to_reuse
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* we have it in-pack undeltified,&n;&t;&t;&t;&t; * and we do not need to deltify it.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;in_pack
op_logical_and
op_logical_neg
id|entry-&gt;delta
)paren
(brace
r_int
r_char
op_star
id|map
suffix:semicolon
r_int
r_int
id|mapsize
suffix:semicolon
id|map
op_assign
id|map_sha1_file
c_func
(paren
id|entry-&gt;sha1
comma
op_amp
id|mapsize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|map
op_logical_and
op_logical_neg
id|legacy_loose_object
c_func
(paren
id|map
)paren
)paren
(brace
multiline_comment|/* We can copy straight into the pack file */
r_if
c_cond
(paren
id|revalidate_loose_object
c_func
(paren
id|entry
comma
id|map
comma
id|mapsize
)paren
)paren
id|die
c_func
(paren
l_string|&quot;corrupt loose object %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|entry-&gt;sha1
)paren
)paren
suffix:semicolon
id|sha1write
c_func
(paren
id|f
comma
id|map
comma
id|mapsize
)paren
suffix:semicolon
id|munmap
c_func
(paren
id|map
comma
id|mapsize
)paren
suffix:semicolon
id|written
op_increment
suffix:semicolon
id|reused
op_increment
suffix:semicolon
r_return
id|mapsize
suffix:semicolon
)brace
r_if
c_cond
(paren
id|map
)paren
id|munmap
c_func
(paren
id|map
comma
id|mapsize
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|to_reuse
)paren
(brace
id|buf
op_assign
id|read_sha1_file
c_func
(paren
id|entry-&gt;sha1
comma
op_amp
id|type
comma
op_amp
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
id|die
c_func
(paren
l_string|&quot;unable to read %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|entry-&gt;sha1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_ne
id|entry-&gt;size
)paren
id|die
c_func
(paren
l_string|&quot;object %s size inconsistency (%lu vs %lu)&quot;
comma
id|sha1_to_hex
c_func
(paren
id|entry-&gt;sha1
)paren
comma
id|size
comma
id|entry-&gt;size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;delta
)paren
(brace
id|buf
op_assign
id|delta_against
c_func
(paren
id|buf
comma
id|size
comma
id|entry
)paren
suffix:semicolon
id|size
op_assign
id|entry-&gt;delta_size
suffix:semicolon
id|obj_type
op_assign
(paren
id|allow_ofs_delta
op_logical_and
id|entry-&gt;delta-&gt;offset
)paren
ques
c_cond
id|OBJ_OFS_DELTA
suffix:colon
id|OBJ_REF_DELTA
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * The object header is a byte of &squot;type&squot; followed by zero or&n;&t;&t; * more bytes of length.&n;&t;&t; */
id|hdrlen
op_assign
id|encode_header
c_func
(paren
id|obj_type
comma
id|size
comma
id|header
)paren
suffix:semicolon
id|sha1write
c_func
(paren
id|f
comma
id|header
comma
id|hdrlen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|obj_type
op_eq
id|OBJ_OFS_DELTA
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Deltas with relative base contain an additional&n;&t;&t;&t; * encoding of the relative offset for the delta&n;&t;&t;&t; * base from this object&squot;s position in the pack.&n;&t;&t;&t; */
id|off_t
id|ofs
op_assign
id|entry-&gt;offset
id|entry-&gt;delta-&gt;offset
suffix:semicolon
r_int
id|pos
op_assign
r_sizeof
(paren
id|header
)paren
l_int|1
suffix:semicolon
id|header
(braket
id|pos
)braket
op_assign
id|ofs
op_amp
l_int|127
suffix:semicolon
r_while
c_loop
(paren
id|ofs
op_rshift_assign
l_int|7
)paren
id|header
(braket
op_decrement
id|pos
)braket
op_assign
l_int|128
op_or
(paren
op_decrement
id|ofs
op_amp
l_int|127
)paren
suffix:semicolon
id|sha1write
c_func
(paren
id|f
comma
id|header
op_plus
id|pos
comma
r_sizeof
(paren
id|header
)paren
id|pos
)paren
suffix:semicolon
id|hdrlen
op_add_assign
r_sizeof
(paren
id|header
)paren
id|pos
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|obj_type
op_eq
id|OBJ_REF_DELTA
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Deltas with a base reference contain&n;&t;&t;&t; * an additional 20 bytes for the base sha1.&n;&t;&t;&t; */
id|sha1write
c_func
(paren
id|f
comma
id|entry-&gt;delta-&gt;sha1
comma
l_int|20
)paren
suffix:semicolon
id|hdrlen
op_add_assign
l_int|20
suffix:semicolon
)brace
id|datalen
op_assign
id|sha1write_compressed
c_func
(paren
id|f
comma
id|buf
comma
id|size
)paren
suffix:semicolon
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|packed_git
op_star
id|p
op_assign
id|entry-&gt;in_pack
suffix:semicolon
r_struct
id|pack_window
op_star
id|w_curs
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|revindex_entry
op_star
id|revidx
suffix:semicolon
id|off_t
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;delta
)paren
(brace
id|obj_type
op_assign
(paren
id|allow_ofs_delta
op_logical_and
id|entry-&gt;delta-&gt;offset
)paren
ques
c_cond
id|OBJ_OFS_DELTA
suffix:colon
id|OBJ_REF_DELTA
suffix:semicolon
id|reused_delta
op_increment
suffix:semicolon
)brace
id|hdrlen
op_assign
id|encode_header
c_func
(paren
id|obj_type
comma
id|entry-&gt;size
comma
id|header
)paren
suffix:semicolon
id|sha1write
c_func
(paren
id|f
comma
id|header
comma
id|hdrlen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|obj_type
op_eq
id|OBJ_OFS_DELTA
)paren
(brace
id|off_t
id|ofs
op_assign
id|entry-&gt;offset
id|entry-&gt;delta-&gt;offset
suffix:semicolon
r_int
id|pos
op_assign
r_sizeof
(paren
id|header
)paren
l_int|1
suffix:semicolon
id|header
(braket
id|pos
)braket
op_assign
id|ofs
op_amp
l_int|127
suffix:semicolon
r_while
c_loop
(paren
id|ofs
op_rshift_assign
l_int|7
)paren
id|header
(braket
op_decrement
id|pos
)braket
op_assign
l_int|128
op_or
(paren
op_decrement
id|ofs
op_amp
l_int|127
)paren
suffix:semicolon
id|sha1write
c_func
(paren
id|f
comma
id|header
op_plus
id|pos
comma
r_sizeof
(paren
id|header
)paren
id|pos
)paren
suffix:semicolon
id|hdrlen
op_add_assign
r_sizeof
(paren
id|header
)paren
id|pos
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|obj_type
op_eq
id|OBJ_REF_DELTA
)paren
(brace
id|sha1write
c_func
(paren
id|f
comma
id|entry-&gt;delta-&gt;sha1
comma
l_int|20
)paren
suffix:semicolon
id|hdrlen
op_add_assign
l_int|20
suffix:semicolon
)brace
id|offset
op_assign
id|entry-&gt;in_pack_offset
suffix:semicolon
id|revidx
op_assign
id|find_packed_object
c_func
(paren
id|p
comma
id|offset
)paren
suffix:semicolon
id|datalen
op_assign
id|revidx
(braket
l_int|1
)braket
dot
id|offset
id|offset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pack_to_stdout
op_logical_and
id|p-&gt;index_version
OG
l_int|1
op_logical_and
id|check_pack_crc
c_func
(paren
id|p
comma
op_amp
id|w_curs
comma
id|offset
comma
id|datalen
comma
id|revidx-&gt;nr
)paren
)paren
id|die
c_func
(paren
l_string|&quot;bad packed object CRC for %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|entry-&gt;sha1
)paren
)paren
suffix:semicolon
id|offset
op_add_assign
id|entry-&gt;in_pack_header_size
suffix:semicolon
id|datalen
op_sub_assign
id|entry-&gt;in_pack_header_size
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pack_to_stdout
op_logical_and
id|p-&gt;index_version
op_eq
l_int|1
op_logical_and
id|check_pack_inflate
c_func
(paren
id|p
comma
op_amp
id|w_curs
comma
id|offset
comma
id|datalen
comma
id|entry-&gt;size
)paren
)paren
id|die
c_func
(paren
l_string|&quot;corrupt packed object for %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|entry-&gt;sha1
)paren
)paren
suffix:semicolon
id|copy_pack_data
c_func
(paren
id|f
comma
id|p
comma
op_amp
id|w_curs
comma
id|offset
comma
id|datalen
)paren
suffix:semicolon
id|unuse_pack
c_func
(paren
op_amp
id|w_curs
)paren
suffix:semicolon
id|reused
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|entry-&gt;delta
)paren
id|written_delta
op_increment
suffix:semicolon
id|written
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pack_to_stdout
)paren
id|entry-&gt;crc32
op_assign
id|crc32_end
c_func
(paren
id|f
)paren
suffix:semicolon
r_return
id|hdrlen
op_plus
id|datalen
suffix:semicolon
)brace
DECL|function|write_one
r_static
id|off_t
id|write_one
c_func
(paren
r_struct
id|sha1file
op_star
id|f
comma
r_struct
id|object_entry
op_star
id|e
comma
id|off_t
id|offset
)paren
(brace
r_int
r_int
id|size
suffix:semicolon
multiline_comment|/* offset is non zero if object is written already. */
r_if
c_cond
(paren
id|e-&gt;offset
op_logical_or
id|e-&gt;preferred_base
)paren
r_return
id|offset
suffix:semicolon
multiline_comment|/* if we are deltified, write out base object first. */
r_if
c_cond
(paren
id|e-&gt;delta
)paren
id|offset
op_assign
id|write_one
c_func
(paren
id|f
comma
id|e-&gt;delta
comma
id|offset
)paren
suffix:semicolon
id|e-&gt;offset
op_assign
id|offset
suffix:semicolon
id|size
op_assign
id|write_object
c_func
(paren
id|f
comma
id|e
)paren
suffix:semicolon
multiline_comment|/* make sure off_t is sufficiently large not to wrap */
r_if
c_cond
(paren
id|offset
OG
id|offset
op_plus
id|size
)paren
id|die
c_func
(paren
l_string|&quot;pack too large for current definition of off_t&quot;
)paren
suffix:semicolon
r_return
id|offset
op_plus
id|size
suffix:semicolon
)brace
DECL|function|write_pack_file
r_static
id|off_t
id|write_pack_file
c_func
(paren
r_void
)paren
(brace
r_uint32
id|i
suffix:semicolon
r_struct
id|sha1file
op_star
id|f
suffix:semicolon
id|off_t
id|offset
comma
id|last_obj_offset
op_assign
l_int|0
suffix:semicolon
r_struct
id|pack_header
id|hdr
suffix:semicolon
r_int
id|last_percent
op_assign
l_int|999
suffix:semicolon
r_int
id|do_progress
op_assign
id|progress
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|base_name
)paren
(brace
id|f
op_assign
id|sha1fd
c_func
(paren
l_int|1
comma
l_string|&quot;&lt;stdout&gt;&quot;
)paren
suffix:semicolon
id|do_progress
op_rshift_assign
l_int|1
suffix:semicolon
)brace
r_else
id|f
op_assign
id|sha1create
c_func
(paren
l_string|&quot;%s-%s.%s&quot;
comma
id|base_name
comma
id|sha1_to_hex
c_func
(paren
id|object_list_sha1
)paren
comma
l_string|&quot;pack&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|do_progress
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Writing %u objects.&bslash;n&quot;
comma
id|nr_result
)paren
suffix:semicolon
id|hdr.hdr_signature
op_assign
id|htonl
c_func
(paren
id|PACK_SIGNATURE
)paren
suffix:semicolon
id|hdr.hdr_version
op_assign
id|htonl
c_func
(paren
id|PACK_VERSION
)paren
suffix:semicolon
id|hdr.hdr_entries
op_assign
id|htonl
c_func
(paren
id|nr_result
)paren
suffix:semicolon
id|sha1write
c_func
(paren
id|f
comma
op_amp
id|hdr
comma
r_sizeof
(paren
id|hdr
)paren
)paren
suffix:semicolon
id|offset
op_assign
r_sizeof
(paren
id|hdr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nr_result
)paren
r_goto
id|done
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_objects
suffix:semicolon
id|i
op_increment
)paren
(brace
id|last_obj_offset
op_assign
id|offset
suffix:semicolon
id|offset
op_assign
id|write_one
c_func
(paren
id|f
comma
id|objects
op_plus
id|i
comma
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|do_progress
)paren
(brace
r_int
id|percent
op_assign
id|written
op_star
l_int|100
op_div
id|nr_result
suffix:semicolon
r_if
c_cond
(paren
id|progress_update
op_logical_or
id|percent
op_ne
id|last_percent
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%4u%% (%u/%u) done&bslash;r&quot;
comma
id|percent
comma
id|written
comma
id|nr_result
)paren
suffix:semicolon
id|progress_update
op_assign
l_int|0
suffix:semicolon
id|last_percent
op_assign
id|percent
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|do_progress
)paren
id|fputc
c_func
(paren
l_char|&squot;&bslash;n&squot;
comma
id|stderr
)paren
suffix:semicolon
id|done
suffix:colon
r_if
c_cond
(paren
id|written
op_ne
id|nr_result
)paren
id|die
c_func
(paren
l_string|&quot;wrote %u objects while expecting %u&quot;
comma
id|written
comma
id|nr_result
)paren
suffix:semicolon
id|sha1close
c_func
(paren
id|f
comma
id|pack_file_sha1
comma
l_int|1
)paren
suffix:semicolon
r_return
id|last_obj_offset
suffix:semicolon
)brace
DECL|variable|index_default_version
r_static
r_uint32
id|index_default_version
op_assign
l_int|1
suffix:semicolon
DECL|variable|index_off32_limit
r_static
r_uint32
id|index_off32_limit
op_assign
l_int|0x7fffffff
suffix:semicolon
DECL|function|write_index_file
r_static
r_void
id|write_index_file
c_func
(paren
id|off_t
id|last_obj_offset
)paren
(brace
r_uint32
id|i
suffix:semicolon
r_struct
id|sha1file
op_star
id|f
op_assign
id|sha1create
c_func
(paren
l_string|&quot;%s-%s.%s&quot;
comma
id|base_name
comma
id|sha1_to_hex
c_func
(paren
id|object_list_sha1
)paren
comma
l_string|&quot;idx&quot;
)paren
suffix:semicolon
r_struct
id|object_entry
op_star
op_star
id|list
op_assign
id|sorted_by_sha
suffix:semicolon
r_struct
id|object_entry
op_star
op_star
id|last
op_assign
id|list
op_plus
id|nr_result
suffix:semicolon
r_uint32
id|array
(braket
l_int|256
)braket
suffix:semicolon
r_uint32
id|index_version
suffix:semicolon
multiline_comment|/* if last object&squot;s offset is &gt;= 2^31 we should use index V2 */
id|index_version
op_assign
(paren
id|last_obj_offset
op_rshift
l_int|31
)paren
ques
c_cond
l_int|2
suffix:colon
id|index_default_version
suffix:semicolon
multiline_comment|/* index versions 2 and above need a header */
r_if
c_cond
(paren
id|index_version
op_ge
l_int|2
)paren
(brace
r_struct
id|pack_idx_header
id|hdr
suffix:semicolon
id|hdr.idx_signature
op_assign
id|htonl
c_func
(paren
id|PACK_IDX_SIGNATURE
)paren
suffix:semicolon
id|hdr.idx_version
op_assign
id|htonl
c_func
(paren
id|index_version
)paren
suffix:semicolon
id|sha1write
c_func
(paren
id|f
comma
op_amp
id|hdr
comma
r_sizeof
(paren
id|hdr
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Write the first-level table (the list is sorted,&n;&t; * but we use a 256-entry lookup to be able to avoid&n;&t; * having to do eight extra binary search iterations).&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|256
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|object_entry
op_star
op_star
id|next
op_assign
id|list
suffix:semicolon
r_while
c_loop
(paren
id|next
OL
id|last
)paren
(brace
r_struct
id|object_entry
op_star
id|entry
op_assign
op_star
id|next
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;sha1
(braket
l_int|0
)braket
op_ne
id|i
)paren
r_break
suffix:semicolon
id|next
op_increment
suffix:semicolon
)brace
id|array
(braket
id|i
)braket
op_assign
id|htonl
c_func
(paren
id|next
id|sorted_by_sha
)paren
suffix:semicolon
id|list
op_assign
id|next
suffix:semicolon
)brace
id|sha1write
c_func
(paren
id|f
comma
id|array
comma
l_int|256
op_star
l_int|4
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Write the actual SHA1 entries..&n;&t; */
id|list
op_assign
id|sorted_by_sha
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_result
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|object_entry
op_star
id|entry
op_assign
op_star
id|list
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|index_version
OL
l_int|2
)paren
(brace
r_uint32
id|offset
op_assign
id|htonl
c_func
(paren
id|entry-&gt;offset
)paren
suffix:semicolon
id|sha1write
c_func
(paren
id|f
comma
op_amp
id|offset
comma
l_int|4
)paren
suffix:semicolon
)brace
id|sha1write
c_func
(paren
id|f
comma
id|entry-&gt;sha1
comma
l_int|20
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|index_version
op_ge
l_int|2
)paren
(brace
r_int
r_int
id|nr_large_offset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* write the crc32 table */
id|list
op_assign
id|sorted_by_sha
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_objects
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|object_entry
op_star
id|entry
op_assign
op_star
id|list
op_increment
suffix:semicolon
r_uint32
id|crc32_val
op_assign
id|htonl
c_func
(paren
id|entry-&gt;crc32
)paren
suffix:semicolon
id|sha1write
c_func
(paren
id|f
comma
op_amp
id|crc32_val
comma
l_int|4
)paren
suffix:semicolon
)brace
multiline_comment|/* write the 32-bit offset table */
id|list
op_assign
id|sorted_by_sha
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_objects
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|object_entry
op_star
id|entry
op_assign
op_star
id|list
op_increment
suffix:semicolon
r_uint32
id|offset
op_assign
(paren
id|entry-&gt;offset
op_le
id|index_off32_limit
)paren
ques
c_cond
id|entry-&gt;offset
suffix:colon
(paren
l_int|0x80000000
op_or
id|nr_large_offset
op_increment
)paren
suffix:semicolon
id|offset
op_assign
id|htonl
c_func
(paren
id|offset
)paren
suffix:semicolon
id|sha1write
c_func
(paren
id|f
comma
op_amp
id|offset
comma
l_int|4
)paren
suffix:semicolon
)brace
multiline_comment|/* write the large offset table */
id|list
op_assign
id|sorted_by_sha
suffix:semicolon
r_while
c_loop
(paren
id|nr_large_offset
)paren
(brace
r_struct
id|object_entry
op_star
id|entry
op_assign
op_star
id|list
op_increment
suffix:semicolon
r_uint64
id|offset
op_assign
id|entry-&gt;offset
suffix:semicolon
r_if
c_cond
(paren
id|offset
OG
id|index_off32_limit
)paren
(brace
r_uint32
id|split
(braket
l_int|2
)braket
suffix:semicolon
id|split
(braket
l_int|0
)braket
op_assign
id|htonl
c_func
(paren
id|offset
op_rshift
l_int|32
)paren
suffix:semicolon
id|split
(braket
l_int|1
)braket
op_assign
id|htonl
c_func
(paren
id|offset
op_amp
l_int|0xffffffff
)paren
suffix:semicolon
id|sha1write
c_func
(paren
id|f
comma
id|split
comma
l_int|8
)paren
suffix:semicolon
id|nr_large_offset
op_decrement
suffix:semicolon
)brace
)brace
)brace
id|sha1write
c_func
(paren
id|f
comma
id|pack_file_sha1
comma
l_int|20
)paren
suffix:semicolon
id|sha1close
c_func
(paren
id|f
comma
l_int|NULL
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|locate_object_entry_hash
r_static
r_int
id|locate_object_entry_hash
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|ui
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|ui
comma
id|sha1
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
id|i
op_assign
id|ui
op_mod
id|object_ix_hashsz
suffix:semicolon
r_while
c_loop
(paren
l_int|0
OL
id|object_ix
(braket
id|i
)braket
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|hashcmp
c_func
(paren
id|sha1
comma
id|objects
(braket
id|object_ix
(braket
id|i
)braket
l_int|1
)braket
dot
id|sha1
)paren
)paren
r_return
id|i
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|i
op_eq
id|object_ix_hashsz
)paren
id|i
op_assign
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
id|i
suffix:semicolon
)brace
DECL|function|locate_object_entry
r_static
r_struct
id|object_entry
op_star
id|locate_object_entry
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|object_ix_hashsz
)paren
r_return
l_int|NULL
suffix:semicolon
id|i
op_assign
id|locate_object_entry_hash
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_le
id|i
)paren
r_return
op_amp
id|objects
(braket
id|object_ix
(braket
id|i
)braket
l_int|1
)braket
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|rehash_objects
r_static
r_void
id|rehash_objects
c_func
(paren
r_void
)paren
(brace
r_uint32
id|i
suffix:semicolon
r_struct
id|object_entry
op_star
id|oe
suffix:semicolon
id|object_ix_hashsz
op_assign
id|nr_objects
op_star
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|object_ix_hashsz
OL
l_int|1024
)paren
id|object_ix_hashsz
op_assign
l_int|1024
suffix:semicolon
id|object_ix
op_assign
id|xrealloc
c_func
(paren
id|object_ix
comma
r_sizeof
(paren
r_int
)paren
op_star
id|object_ix_hashsz
)paren
suffix:semicolon
id|memset
c_func
(paren
id|object_ix
comma
l_int|0
comma
r_sizeof
(paren
r_int
)paren
op_star
id|object_ix_hashsz
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|oe
op_assign
id|objects
suffix:semicolon
id|i
OL
id|nr_objects
suffix:semicolon
id|i
op_increment
comma
id|oe
op_increment
)paren
(brace
r_int
id|ix
op_assign
id|locate_object_entry_hash
c_func
(paren
id|oe-&gt;sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_le
id|ix
)paren
r_continue
suffix:semicolon
id|ix
op_assign
l_int|1
id|ix
suffix:semicolon
id|object_ix
(braket
id|ix
)braket
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
)brace
)brace
DECL|function|name_hash
r_static
r_int
id|name_hash
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_int
r_char
id|c
suffix:semicolon
r_int
id|hash
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * This effectively just creates a sortable number from the&n;&t; * last sixteen non-whitespace characters. Last characters&n;&t; * count &quot;most&quot;, so things that end in &quot;.c&quot; sort together.&n;&t; */
r_while
c_loop
(paren
(paren
id|c
op_assign
op_star
id|name
op_increment
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|isspace
c_func
(paren
id|c
)paren
)paren
r_continue
suffix:semicolon
id|hash
op_assign
(paren
id|hash
op_rshift
l_int|2
)paren
op_plus
(paren
id|c
op_lshift
l_int|24
)paren
suffix:semicolon
)brace
r_return
id|hash
suffix:semicolon
)brace
DECL|function|add_object_entry
r_static
r_int
id|add_object_entry
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
id|hash
comma
r_int
id|exclude
)paren
(brace
r_struct
id|object_entry
op_star
id|entry
suffix:semicolon
r_struct
id|packed_git
op_star
id|p
comma
op_star
id|found_pack
op_assign
l_int|NULL
suffix:semicolon
id|off_t
id|found_offset
op_assign
l_int|0
suffix:semicolon
r_int
id|ix
suffix:semicolon
id|ix
op_assign
id|nr_objects
ques
c_cond
id|locate_object_entry_hash
c_func
(paren
id|sha1
)paren
suffix:colon
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ix
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|exclude
)paren
(brace
id|entry
op_assign
id|objects
op_plus
id|object_ix
(braket
id|ix
)braket
l_int|1
suffix:semicolon
id|entry-&gt;preferred_base
op_assign
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|exclude
)paren
(brace
r_for
c_loop
(paren
id|p
op_assign
id|packed_git
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
id|off_t
id|offset
op_assign
id|find_pack_entry_one
c_func
(paren
id|sha1
comma
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
)paren
(brace
r_if
c_cond
(paren
id|incremental
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|local
op_logical_and
op_logical_neg
id|p-&gt;pack_local
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|found_pack
)paren
(brace
id|found_offset
op_assign
id|offset
suffix:semicolon
id|found_pack
op_assign
id|p
suffix:semicolon
)brace
)brace
)brace
)brace
r_if
c_cond
(paren
id|nr_objects
op_ge
id|nr_alloc
)paren
(brace
id|nr_alloc
op_assign
(paren
id|nr_alloc
op_plus
l_int|1024
)paren
op_star
l_int|3
op_div
l_int|2
suffix:semicolon
id|objects
op_assign
id|xrealloc
c_func
(paren
id|objects
comma
id|nr_alloc
op_star
r_sizeof
(paren
op_star
id|entry
)paren
)paren
suffix:semicolon
)brace
id|entry
op_assign
id|objects
op_plus
id|nr_objects
op_increment
suffix:semicolon
id|memset
c_func
(paren
id|entry
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|entry
)paren
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|entry-&gt;sha1
comma
id|sha1
)paren
suffix:semicolon
id|entry-&gt;hash
op_assign
id|hash
suffix:semicolon
r_if
c_cond
(paren
id|exclude
)paren
id|entry-&gt;preferred_base
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|found_pack
)paren
(brace
id|entry-&gt;in_pack
op_assign
id|found_pack
suffix:semicolon
id|entry-&gt;in_pack_offset
op_assign
id|found_offset
suffix:semicolon
)brace
r_if
c_cond
(paren
id|object_ix_hashsz
op_star
l_int|3
op_le
id|nr_objects
op_star
l_int|4
)paren
id|rehash_objects
c_func
(paren
)paren
suffix:semicolon
r_else
id|object_ix
(braket
l_int|1
id|ix
)braket
op_assign
id|nr_objects
suffix:semicolon
r_if
c_cond
(paren
id|progress_update
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Counting objects...%u&bslash;r&quot;
comma
id|nr_objects
)paren
suffix:semicolon
id|progress_update
op_assign
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|struct|pbase_tree_cache
r_struct
id|pbase_tree_cache
(brace
DECL|member|sha1
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
DECL|member|ref
r_int
id|ref
suffix:semicolon
DECL|member|temporary
r_int
id|temporary
suffix:semicolon
DECL|member|tree_data
r_void
op_star
id|tree_data
suffix:semicolon
DECL|member|tree_size
r_int
r_int
id|tree_size
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|pbase_tree_cache
r_static
r_struct
id|pbase_tree_cache
op_star
(paren
id|pbase_tree_cache
(braket
l_int|256
)braket
)paren
suffix:semicolon
DECL|function|pbase_tree_cache_ix
r_static
r_int
id|pbase_tree_cache_ix
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_return
id|sha1
(braket
l_int|0
)braket
op_mod
id|ARRAY_SIZE
c_func
(paren
id|pbase_tree_cache
)paren
suffix:semicolon
)brace
DECL|function|pbase_tree_cache_ix_incr
r_static
r_int
id|pbase_tree_cache_ix_incr
c_func
(paren
r_int
id|ix
)paren
(brace
r_return
(paren
id|ix
op_plus
l_int|1
)paren
op_mod
id|ARRAY_SIZE
c_func
(paren
id|pbase_tree_cache
)paren
suffix:semicolon
)brace
DECL|struct|pbase_tree
r_static
r_struct
id|pbase_tree
(brace
DECL|member|next
r_struct
id|pbase_tree
op_star
id|next
suffix:semicolon
multiline_comment|/* This is a phony &quot;cache&quot; entry; we are not&n;&t; * going to evict it nor find it through _get()&n;&t; * mechanism -- this is for the toplevel node that&n;&t; * would almost always change with any commit.&n;&t; */
DECL|member|pcache
r_struct
id|pbase_tree_cache
id|pcache
suffix:semicolon
DECL|variable|pbase_tree
)brace
op_star
id|pbase_tree
suffix:semicolon
DECL|function|pbase_tree_get
r_static
r_struct
id|pbase_tree_cache
op_star
id|pbase_tree_get
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_struct
id|pbase_tree_cache
op_star
id|ent
comma
op_star
id|nent
suffix:semicolon
r_void
op_star
id|data
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_enum
id|object_type
id|type
suffix:semicolon
r_int
id|neigh
suffix:semicolon
r_int
id|my_ix
op_assign
id|pbase_tree_cache_ix
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_int
id|available_ix
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* pbase-tree-cache acts as a limited hashtable.&n;&t; * your object will be found at your index or within a few&n;&t; * slots after that slot if it is cached.&n;&t; */
r_for
c_loop
(paren
id|neigh
op_assign
l_int|0
suffix:semicolon
id|neigh
OL
l_int|8
suffix:semicolon
id|neigh
op_increment
)paren
(brace
id|ent
op_assign
id|pbase_tree_cache
(braket
id|my_ix
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ent
op_logical_and
op_logical_neg
id|hashcmp
c_func
(paren
id|ent-&gt;sha1
comma
id|sha1
)paren
)paren
(brace
id|ent-&gt;ref
op_increment
suffix:semicolon
r_return
id|ent
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
(paren
id|available_ix
OL
l_int|0
)paren
op_logical_and
(paren
op_logical_neg
id|ent
op_logical_or
op_logical_neg
id|ent-&gt;ref
)paren
)paren
op_logical_or
(paren
(paren
l_int|0
op_le
id|available_ix
)paren
op_logical_and
(paren
op_logical_neg
id|ent
op_logical_and
id|pbase_tree_cache
(braket
id|available_ix
)braket
)paren
)paren
)paren
id|available_ix
op_assign
id|my_ix
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ent
)paren
r_break
suffix:semicolon
id|my_ix
op_assign
id|pbase_tree_cache_ix_incr
c_func
(paren
id|my_ix
)paren
suffix:semicolon
)brace
multiline_comment|/* Did not find one.  Either we got a bogus request or&n;&t; * we need to read and perhaps cache.&n;&t; */
id|data
op_assign
id|read_sha1_file
c_func
(paren
id|sha1
comma
op_amp
id|type
comma
op_amp
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
id|OBJ_TREE
)paren
(brace
id|free
c_func
(paren
id|data
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* We need to either cache or return a throwaway copy */
r_if
c_cond
(paren
id|available_ix
OL
l_int|0
)paren
id|ent
op_assign
l_int|NULL
suffix:semicolon
r_else
(brace
id|ent
op_assign
id|pbase_tree_cache
(braket
id|available_ix
)braket
suffix:semicolon
id|my_ix
op_assign
id|available_ix
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ent
)paren
(brace
id|nent
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|nent
)paren
)paren
suffix:semicolon
id|nent-&gt;temporary
op_assign
(paren
id|available_ix
OL
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* evict and reuse */
id|free
c_func
(paren
id|ent-&gt;tree_data
)paren
suffix:semicolon
id|nent
op_assign
id|ent
suffix:semicolon
)brace
id|hashcpy
c_func
(paren
id|nent-&gt;sha1
comma
id|sha1
)paren
suffix:semicolon
id|nent-&gt;tree_data
op_assign
id|data
suffix:semicolon
id|nent-&gt;tree_size
op_assign
id|size
suffix:semicolon
id|nent-&gt;ref
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nent-&gt;temporary
)paren
id|pbase_tree_cache
(braket
id|my_ix
)braket
op_assign
id|nent
suffix:semicolon
r_return
id|nent
suffix:semicolon
)brace
DECL|function|pbase_tree_put
r_static
r_void
id|pbase_tree_put
c_func
(paren
r_struct
id|pbase_tree_cache
op_star
id|cache
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cache-&gt;temporary
)paren
(brace
id|cache-&gt;ref
op_decrement
suffix:semicolon
r_return
suffix:semicolon
)brace
id|free
c_func
(paren
id|cache-&gt;tree_data
)paren
suffix:semicolon
id|free
c_func
(paren
id|cache
)paren
suffix:semicolon
)brace
DECL|function|name_cmp_len
r_static
r_int
id|name_cmp_len
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|name
(braket
id|i
)braket
op_logical_and
id|name
(braket
id|i
)braket
op_ne
l_char|&squot;&bslash;n&squot;
op_logical_and
id|name
(braket
id|i
)braket
op_ne
l_char|&squot;/&squot;
suffix:semicolon
id|i
op_increment
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
DECL|function|add_pbase_object
r_static
r_void
id|add_pbase_object
c_func
(paren
r_struct
id|tree_desc
op_star
id|tree
comma
r_const
r_char
op_star
id|name
comma
r_int
id|cmplen
comma
r_const
r_char
op_star
id|fullname
)paren
(brace
r_struct
id|name_entry
id|entry
suffix:semicolon
r_int
id|cmp
suffix:semicolon
r_while
c_loop
(paren
id|tree_entry
c_func
(paren
id|tree
comma
op_amp
id|entry
)paren
)paren
(brace
id|cmp
op_assign
id|tree_entry_len
c_func
(paren
id|entry.path
comma
id|entry.sha1
)paren
op_ne
id|cmplen
ques
c_cond
l_int|1
suffix:colon
id|memcmp
c_func
(paren
id|name
comma
id|entry.path
comma
id|cmplen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmp
OG
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|cmp
OL
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|name
(braket
id|cmplen
)braket
op_ne
l_char|&squot;/&squot;
)paren
(brace
r_int
id|hash
op_assign
id|name_hash
c_func
(paren
id|fullname
)paren
suffix:semicolon
id|add_object_entry
c_func
(paren
id|entry.sha1
comma
id|hash
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|entry.mode
)paren
)paren
(brace
r_struct
id|tree_desc
id|sub
suffix:semicolon
r_struct
id|pbase_tree_cache
op_star
id|tree
suffix:semicolon
r_const
r_char
op_star
id|down
op_assign
id|name
op_plus
id|cmplen
op_plus
l_int|1
suffix:semicolon
r_int
id|downlen
op_assign
id|name_cmp_len
c_func
(paren
id|down
)paren
suffix:semicolon
id|tree
op_assign
id|pbase_tree_get
c_func
(paren
id|entry.sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tree
)paren
r_return
suffix:semicolon
id|init_tree_desc
c_func
(paren
op_amp
id|sub
comma
id|tree-&gt;tree_data
comma
id|tree-&gt;tree_size
)paren
suffix:semicolon
id|add_pbase_object
c_func
(paren
op_amp
id|sub
comma
id|down
comma
id|downlen
comma
id|fullname
)paren
suffix:semicolon
id|pbase_tree_put
c_func
(paren
id|tree
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|variable|done_pbase_paths
r_static
r_int
op_star
id|done_pbase_paths
suffix:semicolon
DECL|variable|done_pbase_paths_num
r_static
r_int
id|done_pbase_paths_num
suffix:semicolon
DECL|variable|done_pbase_paths_alloc
r_static
r_int
id|done_pbase_paths_alloc
suffix:semicolon
DECL|function|done_pbase_path_pos
r_static
r_int
id|done_pbase_path_pos
c_func
(paren
r_int
id|hash
)paren
(brace
r_int
id|lo
op_assign
l_int|0
suffix:semicolon
r_int
id|hi
op_assign
id|done_pbase_paths_num
suffix:semicolon
r_while
c_loop
(paren
id|lo
OL
id|hi
)paren
(brace
r_int
id|mi
op_assign
(paren
id|hi
op_plus
id|lo
)paren
op_div
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|done_pbase_paths
(braket
id|mi
)braket
op_eq
id|hash
)paren
r_return
id|mi
suffix:semicolon
r_if
c_cond
(paren
id|done_pbase_paths
(braket
id|mi
)braket
OL
id|hash
)paren
id|hi
op_assign
id|mi
suffix:semicolon
r_else
id|lo
op_assign
id|mi
op_plus
l_int|1
suffix:semicolon
)brace
r_return
id|lo
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|check_pbase_path
r_static
r_int
id|check_pbase_path
c_func
(paren
r_int
id|hash
)paren
(brace
r_int
id|pos
op_assign
(paren
op_logical_neg
id|done_pbase_paths
)paren
ques
c_cond
l_int|1
suffix:colon
id|done_pbase_path_pos
c_func
(paren
id|hash
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_le
id|pos
)paren
r_return
l_int|1
suffix:semicolon
id|pos
op_assign
id|pos
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|done_pbase_paths_alloc
op_le
id|done_pbase_paths_num
)paren
(brace
id|done_pbase_paths_alloc
op_assign
id|alloc_nr
c_func
(paren
id|done_pbase_paths_alloc
)paren
suffix:semicolon
id|done_pbase_paths
op_assign
id|xrealloc
c_func
(paren
id|done_pbase_paths
comma
id|done_pbase_paths_alloc
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
)brace
id|done_pbase_paths_num
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
id|done_pbase_paths_num
)paren
id|memmove
c_func
(paren
id|done_pbase_paths
op_plus
id|pos
op_plus
l_int|1
comma
id|done_pbase_paths
op_plus
id|pos
comma
(paren
id|done_pbase_paths_num
id|pos
l_int|1
)paren
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
id|done_pbase_paths
(braket
id|pos
)braket
op_assign
id|hash
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|add_preferred_base_object
r_static
r_void
id|add_preferred_base_object
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_int
id|hash
)paren
(brace
r_struct
id|pbase_tree
op_star
id|it
suffix:semicolon
r_int
id|cmplen
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|num_preferred_base
op_logical_or
id|check_pbase_path
c_func
(paren
id|hash
)paren
)paren
r_return
suffix:semicolon
id|cmplen
op_assign
id|name_cmp_len
c_func
(paren
id|name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|it
op_assign
id|pbase_tree
suffix:semicolon
id|it
suffix:semicolon
id|it
op_assign
id|it-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|cmplen
op_eq
l_int|0
)paren
(brace
id|add_object_entry
c_func
(paren
id|it-&gt;pcache.sha1
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|tree_desc
id|tree
suffix:semicolon
id|init_tree_desc
c_func
(paren
op_amp
id|tree
comma
id|it-&gt;pcache.tree_data
comma
id|it-&gt;pcache.tree_size
)paren
suffix:semicolon
id|add_pbase_object
c_func
(paren
op_amp
id|tree
comma
id|name
comma
id|cmplen
comma
id|name
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|add_preferred_base
r_static
r_void
id|add_preferred_base
c_func
(paren
r_int
r_char
op_star
id|sha1
)paren
(brace
r_struct
id|pbase_tree
op_star
id|it
suffix:semicolon
r_void
op_star
id|data
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_int
r_char
id|tree_sha1
(braket
l_int|20
)braket
suffix:semicolon
r_if
c_cond
(paren
id|window
op_le
id|num_preferred_base
op_increment
)paren
r_return
suffix:semicolon
id|data
op_assign
id|read_object_with_reference
c_func
(paren
id|sha1
comma
id|tree_type
comma
op_amp
id|size
comma
id|tree_sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|it
op_assign
id|pbase_tree
suffix:semicolon
id|it
suffix:semicolon
id|it
op_assign
id|it-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|hashcmp
c_func
(paren
id|it-&gt;pcache.sha1
comma
id|tree_sha1
)paren
)paren
(brace
id|free
c_func
(paren
id|data
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|it
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|it
)paren
)paren
suffix:semicolon
id|it-&gt;next
op_assign
id|pbase_tree
suffix:semicolon
id|pbase_tree
op_assign
id|it
suffix:semicolon
id|hashcpy
c_func
(paren
id|it-&gt;pcache.sha1
comma
id|tree_sha1
)paren
suffix:semicolon
id|it-&gt;pcache.tree_data
op_assign
id|data
suffix:semicolon
id|it-&gt;pcache.tree_size
op_assign
id|size
suffix:semicolon
)brace
DECL|function|check_object
r_static
r_void
id|check_object
c_func
(paren
r_struct
id|object_entry
op_star
id|entry
)paren
(brace
r_if
c_cond
(paren
id|entry-&gt;in_pack
op_logical_and
op_logical_neg
id|entry-&gt;preferred_base
)paren
(brace
r_struct
id|packed_git
op_star
id|p
op_assign
id|entry-&gt;in_pack
suffix:semicolon
r_struct
id|pack_window
op_star
id|w_curs
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|size
comma
id|used
suffix:semicolon
r_int
r_int
id|avail
suffix:semicolon
r_int
r_char
op_star
id|buf
suffix:semicolon
r_struct
id|object_entry
op_star
id|base_entry
op_assign
l_int|NULL
suffix:semicolon
id|buf
op_assign
id|use_pack
c_func
(paren
id|p
comma
op_amp
id|w_curs
comma
id|entry-&gt;in_pack_offset
comma
op_amp
id|avail
)paren
suffix:semicolon
multiline_comment|/* We want in_pack_type even if we do not reuse delta.&n;&t;&t; * There is no point not reusing non-delta representations.&n;&t;&t; */
id|used
op_assign
id|unpack_object_header_gently
c_func
(paren
id|buf
comma
id|avail
comma
op_amp
id|entry-&gt;in_pack_type
comma
op_amp
id|size
)paren
suffix:semicolon
multiline_comment|/* Check if it is delta, and the base is also an object&n;&t;&t; * we are going to pack.  If so we will reuse the existing&n;&t;&t; * delta.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|no_reuse_delta
)paren
(brace
r_int
r_char
id|c
suffix:semicolon
r_const
r_int
r_char
op_star
id|base_name
suffix:semicolon
id|off_t
id|ofs
suffix:semicolon
r_int
r_int
id|used_0
suffix:semicolon
multiline_comment|/* there is at least 20 bytes left in the pack */
r_switch
c_cond
(paren
id|entry-&gt;in_pack_type
)paren
(brace
r_case
id|OBJ_REF_DELTA
suffix:colon
id|base_name
op_assign
id|use_pack
c_func
(paren
id|p
comma
op_amp
id|w_curs
comma
id|entry-&gt;in_pack_offset
op_plus
id|used
comma
l_int|NULL
)paren
suffix:semicolon
id|used
op_add_assign
l_int|20
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OBJ_OFS_DELTA
suffix:colon
id|buf
op_assign
id|use_pack
c_func
(paren
id|p
comma
op_amp
id|w_curs
comma
id|entry-&gt;in_pack_offset
op_plus
id|used
comma
l_int|NULL
)paren
suffix:semicolon
id|used_0
op_assign
l_int|0
suffix:semicolon
id|c
op_assign
id|buf
(braket
id|used_0
op_increment
)braket
suffix:semicolon
id|ofs
op_assign
id|c
op_amp
l_int|127
suffix:semicolon
r_while
c_loop
(paren
id|c
op_amp
l_int|128
)paren
(brace
id|ofs
op_add_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ofs
op_logical_or
id|MSB
c_func
(paren
id|ofs
comma
l_int|7
)paren
)paren
id|die
c_func
(paren
l_string|&quot;delta base offset overflow in pack for %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|entry-&gt;sha1
)paren
)paren
suffix:semicolon
id|c
op_assign
id|buf
(braket
id|used_0
op_increment
)braket
suffix:semicolon
id|ofs
op_assign
(paren
id|ofs
op_lshift
l_int|7
)paren
op_plus
(paren
id|c
op_amp
l_int|127
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ofs
op_ge
id|entry-&gt;in_pack_offset
)paren
id|die
c_func
(paren
l_string|&quot;delta base offset out of bound for %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|entry-&gt;sha1
)paren
)paren
suffix:semicolon
id|ofs
op_assign
id|entry-&gt;in_pack_offset
id|ofs
suffix:semicolon
id|base_name
op_assign
id|find_packed_object_name
c_func
(paren
id|p
comma
id|ofs
)paren
suffix:semicolon
id|used
op_add_assign
id|used_0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|base_name
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|base_name
)paren
id|base_entry
op_assign
id|locate_object_entry
c_func
(paren
id|base_name
)paren
suffix:semicolon
)brace
id|unuse_pack
c_func
(paren
op_amp
id|w_curs
)paren
suffix:semicolon
id|entry-&gt;in_pack_header_size
op_assign
id|used
suffix:semicolon
r_if
c_cond
(paren
id|base_entry
)paren
(brace
multiline_comment|/* Depth value does not matter - find_deltas()&n;&t;&t;&t; * will never consider reused delta as the&n;&t;&t;&t; * base object to deltify other objects&n;&t;&t;&t; * against, in order to avoid circular deltas.&n;&t;&t;&t; */
multiline_comment|/* uncompressed size of the delta data */
id|entry-&gt;size
op_assign
id|size
suffix:semicolon
id|entry-&gt;delta
op_assign
id|base_entry
suffix:semicolon
id|entry-&gt;type
op_assign
id|entry-&gt;in_pack_type
suffix:semicolon
id|entry-&gt;delta_sibling
op_assign
id|base_entry-&gt;delta_child
suffix:semicolon
id|base_entry-&gt;delta_child
op_assign
id|entry
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Otherwise we would do the usual */
)brace
id|entry-&gt;type
op_assign
id|sha1_object_info
c_func
(paren
id|entry-&gt;sha1
comma
op_amp
id|entry-&gt;size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;type
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;unable to get type of object %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|entry-&gt;sha1
)paren
)paren
suffix:semicolon
)brace
DECL|function|check_delta_limit
r_static
r_int
r_int
id|check_delta_limit
c_func
(paren
r_struct
id|object_entry
op_star
id|me
comma
r_int
r_int
id|n
)paren
(brace
r_struct
id|object_entry
op_star
id|child
op_assign
id|me-&gt;delta_child
suffix:semicolon
r_int
r_int
id|m
op_assign
id|n
suffix:semicolon
r_while
c_loop
(paren
id|child
)paren
(brace
r_int
r_int
id|c
op_assign
id|check_delta_limit
c_func
(paren
id|child
comma
id|n
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
OL
id|c
)paren
id|m
op_assign
id|c
suffix:semicolon
id|child
op_assign
id|child-&gt;delta_sibling
suffix:semicolon
)brace
r_return
id|m
suffix:semicolon
)brace
DECL|function|get_object_details
r_static
r_void
id|get_object_details
c_func
(paren
r_void
)paren
(brace
r_uint32
id|i
suffix:semicolon
r_struct
id|object_entry
op_star
id|entry
suffix:semicolon
id|prepare_pack_ix
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|entry
op_assign
id|objects
suffix:semicolon
id|i
OL
id|nr_objects
suffix:semicolon
id|i
op_increment
comma
id|entry
op_increment
)paren
id|check_object
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr_objects
op_eq
id|nr_result
)paren
(brace
multiline_comment|/*&n;&t;&t; * Depth of objects that depend on the entry -- this&n;&t;&t; * is subtracted from depth-max to break too deep&n;&t;&t; * delta chain because of delta data reusing.&n;&t;&t; * However, we loosen this restriction when we know we&n;&t;&t; * are creating a thin pack -- it will have to be&n;&t;&t; * expanded on the other end anyway, so do not&n;&t;&t; * artificially cut the delta chain and let it go as&n;&t;&t; * deep as it wants.&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|entry
op_assign
id|objects
suffix:semicolon
id|i
OL
id|nr_objects
suffix:semicolon
id|i
op_increment
comma
id|entry
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;delta
op_logical_and
id|entry-&gt;delta_child
)paren
id|entry-&gt;delta_limit
op_assign
id|check_delta_limit
c_func
(paren
id|entry
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
DECL|typedef|entry_sort_t
r_typedef
r_int
(paren
op_star
id|entry_sort_t
)paren
(paren
r_const
r_struct
id|object_entry
op_star
comma
r_const
r_struct
id|object_entry
op_star
)paren
suffix:semicolon
DECL|variable|current_sort
r_static
id|entry_sort_t
id|current_sort
suffix:semicolon
DECL|function|sort_comparator
r_static
r_int
id|sort_comparator
c_func
(paren
r_const
r_void
op_star
id|_a
comma
r_const
r_void
op_star
id|_b
)paren
(brace
r_struct
id|object_entry
op_star
id|a
op_assign
op_star
(paren
r_struct
id|object_entry
op_star
op_star
)paren
id|_a
suffix:semicolon
r_struct
id|object_entry
op_star
id|b
op_assign
op_star
(paren
r_struct
id|object_entry
op_star
op_star
)paren
id|_b
suffix:semicolon
r_return
id|current_sort
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
)brace
DECL|function|create_sorted_list
r_static
r_struct
id|object_entry
op_star
op_star
id|create_sorted_list
c_func
(paren
id|entry_sort_t
id|sort
)paren
(brace
r_struct
id|object_entry
op_star
op_star
id|list
op_assign
id|xmalloc
c_func
(paren
id|nr_objects
op_star
r_sizeof
(paren
r_struct
id|object_entry
op_star
)paren
)paren
suffix:semicolon
r_uint32
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_objects
suffix:semicolon
id|i
op_increment
)paren
id|list
(braket
id|i
)braket
op_assign
id|objects
op_plus
id|i
suffix:semicolon
id|current_sort
op_assign
id|sort
suffix:semicolon
id|qsort
c_func
(paren
id|list
comma
id|nr_objects
comma
r_sizeof
(paren
r_struct
id|object_entry
op_star
)paren
comma
id|sort_comparator
)paren
suffix:semicolon
r_return
id|list
suffix:semicolon
)brace
DECL|function|sha1_sort
r_static
r_int
id|sha1_sort
c_func
(paren
r_const
r_struct
id|object_entry
op_star
id|a
comma
r_const
r_struct
id|object_entry
op_star
id|b
)paren
(brace
r_return
id|hashcmp
c_func
(paren
id|a-&gt;sha1
comma
id|b-&gt;sha1
)paren
suffix:semicolon
)brace
DECL|function|create_final_object_list
r_static
r_struct
id|object_entry
op_star
op_star
id|create_final_object_list
c_func
(paren
r_void
)paren
(brace
r_struct
id|object_entry
op_star
op_star
id|list
suffix:semicolon
r_uint32
id|i
comma
id|j
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|nr_result
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_objects
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|objects
(braket
id|i
)braket
dot
id|preferred_base
)paren
id|nr_result
op_increment
suffix:semicolon
id|list
op_assign
id|xmalloc
c_func
(paren
id|nr_result
op_star
r_sizeof
(paren
r_struct
id|object_entry
op_star
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|j
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_objects
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|objects
(braket
id|i
)braket
dot
id|preferred_base
)paren
id|list
(braket
id|j
op_increment
)braket
op_assign
id|objects
op_plus
id|i
suffix:semicolon
)brace
id|current_sort
op_assign
id|sha1_sort
suffix:semicolon
id|qsort
c_func
(paren
id|list
comma
id|nr_result
comma
r_sizeof
(paren
r_struct
id|object_entry
op_star
)paren
comma
id|sort_comparator
)paren
suffix:semicolon
r_return
id|list
suffix:semicolon
)brace
DECL|function|type_size_sort
r_static
r_int
id|type_size_sort
c_func
(paren
r_const
r_struct
id|object_entry
op_star
id|a
comma
r_const
r_struct
id|object_entry
op_star
id|b
)paren
(brace
r_if
c_cond
(paren
id|a-&gt;type
OL
id|b-&gt;type
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;type
OG
id|b-&gt;type
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;hash
OL
id|b-&gt;hash
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;hash
OG
id|b-&gt;hash
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;preferred_base
OL
id|b-&gt;preferred_base
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;preferred_base
OG
id|b-&gt;preferred_base
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;size
OL
id|b-&gt;size
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;size
OG
id|b-&gt;size
)paren
r_return
l_int|1
suffix:semicolon
r_return
id|a
OG
id|b
ques
c_cond
l_int|1
suffix:colon
(paren
id|a
OL
id|b
)paren
suffix:semicolon
multiline_comment|/* newest last */
)brace
DECL|struct|unpacked
r_struct
id|unpacked
(brace
DECL|member|entry
r_struct
id|object_entry
op_star
id|entry
suffix:semicolon
DECL|member|data
r_void
op_star
id|data
suffix:semicolon
DECL|member|index
r_struct
id|delta_index
op_star
id|index
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * We search for deltas _backwards_ in a list sorted by type and&n; * by size, so that we see progressively smaller and smaller files.&n; * That&squot;s because we prefer deltas to be from the bigger file&n; * to the smaller - deletes are potentially cheaper, but perhaps&n; * more importantly, the bigger file is likely the more recent&n; * one.&n; */
DECL|function|try_delta
r_static
r_int
id|try_delta
c_func
(paren
r_struct
id|unpacked
op_star
id|trg
comma
r_struct
id|unpacked
op_star
id|src
comma
r_int
id|max_depth
)paren
(brace
r_struct
id|object_entry
op_star
id|trg_entry
op_assign
id|trg-&gt;entry
suffix:semicolon
r_struct
id|object_entry
op_star
id|src_entry
op_assign
id|src-&gt;entry
suffix:semicolon
r_int
r_int
id|trg_size
comma
id|src_size
comma
id|delta_size
comma
id|sizediff
comma
id|max_size
comma
id|sz
suffix:semicolon
r_enum
id|object_type
id|type
suffix:semicolon
r_void
op_star
id|delta_buf
suffix:semicolon
multiline_comment|/* Don&squot;t bother doing diffs between different types */
r_if
c_cond
(paren
id|trg_entry-&gt;type
op_ne
id|src_entry-&gt;type
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* We do not compute delta to *create* objects we are not&n;&t; * going to pack.&n;&t; */
r_if
c_cond
(paren
id|trg_entry-&gt;preferred_base
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * We do not bother to try a delta that we discarded&n;&t; * on an earlier try, but only when reusing delta data.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|no_reuse_delta
op_logical_and
id|trg_entry-&gt;in_pack
op_logical_and
id|trg_entry-&gt;in_pack
op_eq
id|src_entry-&gt;in_pack
op_logical_and
id|trg_entry-&gt;in_pack_type
op_ne
id|OBJ_REF_DELTA
op_logical_and
id|trg_entry-&gt;in_pack_type
op_ne
id|OBJ_OFS_DELTA
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If the current object is at pack edge, take the depth the&n;&t; * objects that depend on the current object into account --&n;&t; * otherwise they would become too deep.&n;&t; */
r_if
c_cond
(paren
id|trg_entry-&gt;delta_child
)paren
(brace
r_if
c_cond
(paren
id|max_depth
op_le
id|trg_entry-&gt;delta_limit
)paren
r_return
l_int|0
suffix:semicolon
id|max_depth
op_sub_assign
id|trg_entry-&gt;delta_limit
suffix:semicolon
)brace
r_if
c_cond
(paren
id|src_entry-&gt;depth
op_ge
id|max_depth
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Now some size filtering heuristics. */
id|trg_size
op_assign
id|trg_entry-&gt;size
suffix:semicolon
id|max_size
op_assign
id|trg_size
op_div
l_int|2
l_int|20
suffix:semicolon
id|max_size
op_assign
id|max_size
op_star
(paren
id|max_depth
id|src_entry-&gt;depth
)paren
op_div
id|max_depth
suffix:semicolon
r_if
c_cond
(paren
id|max_size
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|trg_entry-&gt;delta
op_logical_and
id|trg_entry-&gt;delta_size
op_le
id|max_size
)paren
id|max_size
op_assign
id|trg_entry-&gt;delta_size
op_minus
l_int|1
suffix:semicolon
id|src_size
op_assign
id|src_entry-&gt;size
suffix:semicolon
id|sizediff
op_assign
id|src_size
OL
id|trg_size
ques
c_cond
id|trg_size
id|src_size
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sizediff
op_ge
id|max_size
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Load data if not already done */
r_if
c_cond
(paren
op_logical_neg
id|trg-&gt;data
)paren
(brace
id|trg-&gt;data
op_assign
id|read_sha1_file
c_func
(paren
id|trg_entry-&gt;sha1
comma
op_amp
id|type
comma
op_amp
id|sz
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sz
op_ne
id|trg_size
)paren
id|die
c_func
(paren
l_string|&quot;object %s inconsistent object length (%lu vs %lu)&quot;
comma
id|sha1_to_hex
c_func
(paren
id|trg_entry-&gt;sha1
)paren
comma
id|sz
comma
id|trg_size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|src-&gt;data
)paren
(brace
id|src-&gt;data
op_assign
id|read_sha1_file
c_func
(paren
id|src_entry-&gt;sha1
comma
op_amp
id|type
comma
op_amp
id|sz
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sz
op_ne
id|src_size
)paren
id|die
c_func
(paren
l_string|&quot;object %s inconsistent object length (%lu vs %lu)&quot;
comma
id|sha1_to_hex
c_func
(paren
id|src_entry-&gt;sha1
)paren
comma
id|sz
comma
id|src_size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|src-&gt;index
)paren
(brace
id|src-&gt;index
op_assign
id|create_delta_index
c_func
(paren
id|src-&gt;data
comma
id|src_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|src-&gt;index
)paren
id|die
c_func
(paren
l_string|&quot;out of memory&quot;
)paren
suffix:semicolon
)brace
id|delta_buf
op_assign
id|create_delta
c_func
(paren
id|src-&gt;index
comma
id|trg-&gt;data
comma
id|trg_size
comma
op_amp
id|delta_size
comma
id|max_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|delta_buf
)paren
r_return
l_int|0
suffix:semicolon
id|trg_entry-&gt;delta
op_assign
id|src_entry
suffix:semicolon
id|trg_entry-&gt;delta_size
op_assign
id|delta_size
suffix:semicolon
id|trg_entry-&gt;depth
op_assign
id|src_entry-&gt;depth
op_plus
l_int|1
suffix:semicolon
id|free
c_func
(paren
id|delta_buf
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|progress_interval
r_static
r_void
id|progress_interval
c_func
(paren
r_int
id|signum
)paren
(brace
id|progress_update
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|find_deltas
r_static
r_void
id|find_deltas
c_func
(paren
r_struct
id|object_entry
op_star
op_star
id|list
comma
r_int
id|window
comma
r_int
id|depth
)paren
(brace
r_uint32
id|i
op_assign
id|nr_objects
comma
id|idx
op_assign
l_int|0
comma
id|processed
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|array_size
op_assign
id|window
op_star
r_sizeof
(paren
r_struct
id|unpacked
)paren
suffix:semicolon
r_struct
id|unpacked
op_star
id|array
suffix:semicolon
r_int
id|last_percent
op_assign
l_int|999
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nr_objects
)paren
r_return
suffix:semicolon
id|array
op_assign
id|xmalloc
c_func
(paren
id|array_size
)paren
suffix:semicolon
id|memset
c_func
(paren
id|array
comma
l_int|0
comma
id|array_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|progress
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Deltifying %u objects.&bslash;n&quot;
comma
id|nr_result
)paren
suffix:semicolon
r_do
(brace
r_struct
id|object_entry
op_star
id|entry
op_assign
id|list
(braket
op_decrement
id|i
)braket
suffix:semicolon
r_struct
id|unpacked
op_star
id|n
op_assign
id|array
op_plus
id|idx
suffix:semicolon
r_int
id|j
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;preferred_base
)paren
id|processed
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|progress
)paren
(brace
r_int
id|percent
op_assign
id|processed
op_star
l_int|100
op_div
id|nr_result
suffix:semicolon
r_if
c_cond
(paren
id|percent
op_ne
id|last_percent
op_logical_or
id|progress_update
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%4u%% (%u/%u) done&bslash;r&quot;
comma
id|percent
comma
id|processed
comma
id|nr_result
)paren
suffix:semicolon
id|progress_update
op_assign
l_int|0
suffix:semicolon
id|last_percent
op_assign
id|percent
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|entry-&gt;delta
)paren
multiline_comment|/* This happens if we decided to reuse existing&n;&t;&t;&t; * delta from a pack.  &quot;!no_reuse_delta &amp;&amp;&quot; is implied.&n;&t;&t;&t; */
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;size
OL
l_int|50
)paren
r_continue
suffix:semicolon
id|free_delta_index
c_func
(paren
id|n-&gt;index
)paren
suffix:semicolon
id|n-&gt;index
op_assign
l_int|NULL
suffix:semicolon
id|free
c_func
(paren
id|n-&gt;data
)paren
suffix:semicolon
id|n-&gt;data
op_assign
l_int|NULL
suffix:semicolon
id|n-&gt;entry
op_assign
id|entry
suffix:semicolon
id|j
op_assign
id|window
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|j
OG
l_int|0
)paren
(brace
r_uint32
id|other_idx
op_assign
id|idx
op_plus
id|j
suffix:semicolon
r_struct
id|unpacked
op_star
id|m
suffix:semicolon
r_if
c_cond
(paren
id|other_idx
op_ge
id|window
)paren
id|other_idx
op_sub_assign
id|window
suffix:semicolon
id|m
op_assign
id|array
op_plus
id|other_idx
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|m-&gt;entry
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|try_delta
c_func
(paren
id|n
comma
id|m
comma
id|depth
)paren
OL
l_int|0
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* if we made n a delta, and if n is already at max&n;&t;&t; * depth, leaving it in the window is pointless.  we&n;&t;&t; * should evict it first.&n;&t;&t; */
r_if
c_cond
(paren
id|entry-&gt;delta
op_logical_and
id|depth
op_le
id|entry-&gt;depth
)paren
r_continue
suffix:semicolon
id|idx
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|idx
op_ge
id|window
)paren
id|idx
op_assign
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
id|i
OG
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|progress
)paren
id|fputc
c_func
(paren
l_char|&squot;&bslash;n&squot;
comma
id|stderr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|window
suffix:semicolon
op_increment
id|i
)paren
(brace
id|free_delta_index
c_func
(paren
id|array
(braket
id|i
)braket
dot
id|index
)paren
suffix:semicolon
id|free
c_func
(paren
id|array
(braket
id|i
)braket
dot
id|data
)paren
suffix:semicolon
)brace
id|free
c_func
(paren
id|array
)paren
suffix:semicolon
)brace
DECL|function|prepare_pack
r_static
r_void
id|prepare_pack
c_func
(paren
r_int
id|window
comma
r_int
id|depth
)paren
(brace
id|get_object_details
c_func
(paren
)paren
suffix:semicolon
id|sorted_by_type
op_assign
id|create_sorted_list
c_func
(paren
id|type_size_sort
)paren
suffix:semicolon
r_if
c_cond
(paren
id|window
op_logical_and
id|depth
)paren
id|find_deltas
c_func
(paren
id|sorted_by_type
comma
id|window
op_plus
l_int|1
comma
id|depth
)paren
suffix:semicolon
)brace
DECL|function|reuse_cached_pack
r_static
r_int
id|reuse_cached_pack
c_func
(paren
r_int
r_char
op_star
id|sha1
)paren
(brace
r_static
r_const
r_char
id|cache
(braket
)braket
op_assign
l_string|&quot;pack-cache/pack-%s.%s&quot;
suffix:semicolon
r_char
op_star
id|cached_pack
comma
op_star
id|cached_idx
suffix:semicolon
r_int
id|ifd
comma
id|ofd
comma
id|ifd_ix
op_assign
l_int|1
suffix:semicolon
id|cached_pack
op_assign
id|git_path
c_func
(paren
id|cache
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
comma
l_string|&quot;pack&quot;
)paren
suffix:semicolon
id|ifd
op_assign
id|open
c_func
(paren
id|cached_pack
comma
id|O_RDONLY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ifd
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pack_to_stdout
)paren
(brace
id|cached_idx
op_assign
id|git_path
c_func
(paren
id|cache
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
comma
l_string|&quot;idx&quot;
)paren
suffix:semicolon
id|ifd_ix
op_assign
id|open
c_func
(paren
id|cached_idx
comma
id|O_RDONLY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ifd_ix
OL
l_int|0
)paren
(brace
id|close
c_func
(paren
id|ifd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|progress
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Reusing %u objects pack %s&bslash;n&quot;
comma
id|nr_objects
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pack_to_stdout
)paren
(brace
r_if
c_cond
(paren
id|copy_fd
c_func
(paren
id|ifd
comma
l_int|1
)paren
)paren
m_exit
(paren
l_int|1
)paren
suffix:semicolon
id|close
c_func
(paren
id|ifd
)paren
suffix:semicolon
)brace
r_else
(brace
r_char
id|name
(braket
id|PATH_MAX
)braket
suffix:semicolon
id|snprintf
c_func
(paren
id|name
comma
r_sizeof
(paren
id|name
)paren
comma
l_string|&quot;%s-%s.%s&quot;
comma
id|base_name
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
comma
l_string|&quot;pack&quot;
)paren
suffix:semicolon
id|ofd
op_assign
id|open
c_func
(paren
id|name
comma
id|O_CREAT
op_or
id|O_EXCL
op_or
id|O_WRONLY
comma
l_int|0666
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ofd
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;unable to open %s (%s)&quot;
comma
id|name
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_fd
c_func
(paren
id|ifd
comma
id|ofd
)paren
)paren
m_exit
(paren
l_int|1
)paren
suffix:semicolon
id|close
c_func
(paren
id|ifd
)paren
suffix:semicolon
id|snprintf
c_func
(paren
id|name
comma
r_sizeof
(paren
id|name
)paren
comma
l_string|&quot;%s-%s.%s&quot;
comma
id|base_name
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
comma
l_string|&quot;idx&quot;
)paren
suffix:semicolon
id|ofd
op_assign
id|open
c_func
(paren
id|name
comma
id|O_CREAT
op_or
id|O_EXCL
op_or
id|O_WRONLY
comma
l_int|0666
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ofd
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;unable to open %s (%s)&quot;
comma
id|name
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_fd
c_func
(paren
id|ifd_ix
comma
id|ofd
)paren
)paren
m_exit
(paren
l_int|1
)paren
suffix:semicolon
id|close
c_func
(paren
id|ifd_ix
)paren
suffix:semicolon
id|puts
c_func
(paren
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|setup_progress_signal
r_static
r_void
id|setup_progress_signal
c_func
(paren
r_void
)paren
(brace
r_struct
id|sigaction
id|sa
suffix:semicolon
r_struct
id|itimerval
id|v
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|sa
comma
l_int|0
comma
r_sizeof
(paren
id|sa
)paren
)paren
suffix:semicolon
id|sa.sa_handler
op_assign
id|progress_interval
suffix:semicolon
id|sigemptyset
c_func
(paren
op_amp
id|sa.sa_mask
)paren
suffix:semicolon
id|sa.sa_flags
op_assign
id|SA_RESTART
suffix:semicolon
id|sigaction
c_func
(paren
id|SIGALRM
comma
op_amp
id|sa
comma
l_int|NULL
)paren
suffix:semicolon
id|v.it_interval.tv_sec
op_assign
l_int|1
suffix:semicolon
id|v.it_interval.tv_usec
op_assign
l_int|0
suffix:semicolon
id|v.it_value
op_assign
id|v.it_interval
suffix:semicolon
id|setitimer
c_func
(paren
id|ITIMER_REAL
comma
op_amp
id|v
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|git_pack_config
r_static
r_int
id|git_pack_config
c_func
(paren
r_const
r_char
op_star
id|k
comma
r_const
r_char
op_star
id|v
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|k
comma
l_string|&quot;pack.window&quot;
)paren
)paren
(brace
id|window
op_assign
id|git_config_int
c_func
(paren
id|k
comma
id|v
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|git_default_config
c_func
(paren
id|k
comma
id|v
)paren
suffix:semicolon
)brace
DECL|function|read_object_list_from_stdin
r_static
r_void
id|read_object_list_from_stdin
c_func
(paren
r_void
)paren
(brace
r_char
id|line
(braket
l_int|40
op_plus
l_int|1
op_plus
id|PATH_MAX
op_plus
l_int|2
)braket
suffix:semicolon
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_int
id|hash
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|fgets
c_func
(paren
id|line
comma
r_sizeof
(paren
id|line
)paren
comma
id|stdin
)paren
)paren
(brace
r_if
c_cond
(paren
id|feof
c_func
(paren
id|stdin
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ferror
c_func
(paren
id|stdin
)paren
)paren
id|die
c_func
(paren
l_string|&quot;fgets returned NULL, not EOF, not error!&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|errno
op_ne
id|EINTR
)paren
id|die
c_func
(paren
l_string|&quot;fgets: %s&quot;
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
id|clearerr
c_func
(paren
id|stdin
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|line
(braket
l_int|0
)braket
op_eq
l_char|&squot;-&squot;
)paren
(brace
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|line
op_plus
l_int|1
comma
id|sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;expected edge sha1, got garbage:&bslash;n %s&quot;
comma
id|line
)paren
suffix:semicolon
id|add_preferred_base
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|line
comma
id|sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;expected sha1, got garbage:&bslash;n %s&quot;
comma
id|line
)paren
suffix:semicolon
id|hash
op_assign
id|name_hash
c_func
(paren
id|line
op_plus
l_int|41
)paren
suffix:semicolon
id|add_preferred_base_object
c_func
(paren
id|line
op_plus
l_int|41
comma
id|hash
)paren
suffix:semicolon
id|add_object_entry
c_func
(paren
id|sha1
comma
id|hash
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
DECL|function|show_commit
r_static
r_void
id|show_commit
c_func
(paren
r_struct
id|commit
op_star
id|commit
)paren
(brace
id|add_object_entry
c_func
(paren
id|commit-&gt;object.sha1
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|show_object
r_static
r_void
id|show_object
c_func
(paren
r_struct
id|object_array_entry
op_star
id|p
)paren
(brace
r_int
id|hash
op_assign
id|name_hash
c_func
(paren
id|p-&gt;name
)paren
suffix:semicolon
id|add_preferred_base_object
c_func
(paren
id|p-&gt;name
comma
id|hash
)paren
suffix:semicolon
id|add_object_entry
c_func
(paren
id|p-&gt;item-&gt;sha1
comma
id|hash
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|show_edge
r_static
r_void
id|show_edge
c_func
(paren
r_struct
id|commit
op_star
id|commit
)paren
(brace
id|add_preferred_base
c_func
(paren
id|commit-&gt;object.sha1
)paren
suffix:semicolon
)brace
DECL|function|get_object_list
r_static
r_void
id|get_object_list
c_func
(paren
r_int
id|ac
comma
r_const
r_char
op_star
op_star
id|av
)paren
(brace
r_struct
id|rev_info
id|revs
suffix:semicolon
r_char
id|line
(braket
l_int|1000
)braket
suffix:semicolon
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
id|init_revisions
c_func
(paren
op_amp
id|revs
comma
l_int|NULL
)paren
suffix:semicolon
id|save_commit_buffer
op_assign
l_int|0
suffix:semicolon
id|track_object_refs
op_assign
l_int|0
suffix:semicolon
id|setup_revisions
c_func
(paren
id|ac
comma
id|av
comma
op_amp
id|revs
comma
l_int|NULL
)paren
suffix:semicolon
r_while
c_loop
(paren
id|fgets
c_func
(paren
id|line
comma
r_sizeof
(paren
id|line
)paren
comma
id|stdin
)paren
op_ne
l_int|NULL
)paren
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|line
)paren
suffix:semicolon
r_if
c_cond
(paren
id|line
(braket
id|len
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|line
(braket
op_decrement
id|len
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_star
id|line
op_eq
l_char|&squot;-&squot;
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|line
comma
l_string|&quot;--not&quot;
)paren
)paren
(brace
id|flags
op_xor_assign
id|UNINTERESTING
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|die
c_func
(paren
l_string|&quot;not a rev &squot;%s&squot;&quot;
comma
id|line
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|handle_revision_arg
c_func
(paren
id|line
comma
op_amp
id|revs
comma
id|flags
comma
l_int|1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;bad revision &squot;%s&squot;&quot;
comma
id|line
)paren
suffix:semicolon
)brace
id|prepare_revision_walk
c_func
(paren
op_amp
id|revs
)paren
suffix:semicolon
id|mark_edges_uninteresting
c_func
(paren
id|revs.commits
comma
op_amp
id|revs
comma
id|show_edge
)paren
suffix:semicolon
id|traverse_commit_list
c_func
(paren
op_amp
id|revs
comma
id|show_commit
comma
id|show_object
)paren
suffix:semicolon
)brace
DECL|function|cmd_pack_objects
r_int
id|cmd_pack_objects
c_func
(paren
r_int
id|argc
comma
r_const
r_char
op_star
op_star
id|argv
comma
r_const
r_char
op_star
id|prefix
)paren
(brace
id|SHA_CTX
id|ctx
suffix:semicolon
r_int
id|depth
op_assign
l_int|10
suffix:semicolon
r_struct
id|object_entry
op_star
op_star
id|list
suffix:semicolon
r_int
id|use_internal_rev_list
op_assign
l_int|0
suffix:semicolon
r_int
id|thin
op_assign
l_int|0
suffix:semicolon
r_uint32
id|i
suffix:semicolon
r_const
r_char
op_star
op_star
id|rp_av
suffix:semicolon
r_int
id|rp_ac_alloc
op_assign
l_int|64
suffix:semicolon
r_int
id|rp_ac
suffix:semicolon
id|rp_av
op_assign
id|xcalloc
c_func
(paren
id|rp_ac_alloc
comma
r_sizeof
(paren
op_star
id|rp_av
)paren
)paren
suffix:semicolon
id|rp_av
(braket
l_int|0
)braket
op_assign
l_string|&quot;pack-objects&quot;
suffix:semicolon
id|rp_av
(braket
l_int|1
)braket
op_assign
l_string|&quot;--objects&quot;
suffix:semicolon
multiline_comment|/* --thin will make it --objects-edge */
id|rp_ac
op_assign
l_int|2
suffix:semicolon
id|git_config
c_func
(paren
id|git_pack_config
)paren
suffix:semicolon
id|progress
op_assign
id|isatty
c_func
(paren
l_int|2
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|argc
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_char
op_star
id|arg
op_assign
id|argv
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_star
id|arg
op_ne
l_char|&squot;-&squot;
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--non-empty&quot;
comma
id|arg
)paren
)paren
(brace
id|non_empty
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--local&quot;
comma
id|arg
)paren
)paren
(brace
id|local
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--incremental&quot;
comma
id|arg
)paren
)paren
(brace
id|incremental
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;--window=&quot;
)paren
)paren
(brace
r_char
op_star
id|end
suffix:semicolon
id|window
op_assign
id|strtoul
c_func
(paren
id|arg
op_plus
l_int|9
comma
op_amp
id|end
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
(braket
l_int|9
)braket
op_logical_or
op_star
id|end
)paren
id|usage
c_func
(paren
id|pack_usage
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;--depth=&quot;
)paren
)paren
(brace
r_char
op_star
id|end
suffix:semicolon
id|depth
op_assign
id|strtoul
c_func
(paren
id|arg
op_plus
l_int|8
comma
op_amp
id|end
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
(braket
l_int|8
)braket
op_logical_or
op_star
id|end
)paren
id|usage
c_func
(paren
id|pack_usage
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--progress&quot;
comma
id|arg
)paren
)paren
(brace
id|progress
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--all-progress&quot;
comma
id|arg
)paren
)paren
(brace
id|progress
op_assign
l_int|2
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;-q&quot;
comma
id|arg
)paren
)paren
(brace
id|progress
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--no-reuse-delta&quot;
comma
id|arg
)paren
)paren
(brace
id|no_reuse_delta
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--delta-base-offset&quot;
comma
id|arg
)paren
)paren
(brace
id|allow_ofs_delta
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--stdout&quot;
comma
id|arg
)paren
)paren
(brace
id|pack_to_stdout
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--revs&quot;
comma
id|arg
)paren
)paren
(brace
id|use_internal_rev_list
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--unpacked&quot;
comma
id|arg
)paren
op_logical_or
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;--unpacked=&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--reflog&quot;
comma
id|arg
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--all&quot;
comma
id|arg
)paren
)paren
(brace
id|use_internal_rev_list
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|rp_ac
op_ge
id|rp_ac_alloc
l_int|1
)paren
(brace
id|rp_ac_alloc
op_assign
id|alloc_nr
c_func
(paren
id|rp_ac_alloc
)paren
suffix:semicolon
id|rp_av
op_assign
id|xrealloc
c_func
(paren
id|rp_av
comma
id|rp_ac_alloc
op_star
r_sizeof
(paren
op_star
id|rp_av
)paren
)paren
suffix:semicolon
)brace
id|rp_av
(braket
id|rp_ac
op_increment
)braket
op_assign
id|arg
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--thin&quot;
comma
id|arg
)paren
)paren
(brace
id|use_internal_rev_list
op_assign
l_int|1
suffix:semicolon
id|thin
op_assign
l_int|1
suffix:semicolon
id|rp_av
(braket
l_int|1
)braket
op_assign
l_string|&quot;--objects-edge&quot;
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;--index-version=&quot;
)paren
)paren
(brace
r_char
op_star
id|c
suffix:semicolon
id|index_default_version
op_assign
id|strtoul
c_func
(paren
id|arg
op_plus
l_int|16
comma
op_amp
id|c
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index_default_version
OG
l_int|2
)paren
id|die
c_func
(paren
l_string|&quot;bad %s&quot;
comma
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|c
op_eq
l_char|&squot;,&squot;
)paren
id|index_off32_limit
op_assign
id|strtoul
c_func
(paren
id|c
op_plus
l_int|1
comma
op_amp
id|c
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|c
op_logical_or
id|index_off32_limit
op_amp
l_int|0x80000000
)paren
id|die
c_func
(paren
l_string|&quot;bad %s&quot;
comma
id|arg
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|usage
c_func
(paren
id|pack_usage
)paren
suffix:semicolon
)brace
multiline_comment|/* Traditionally &quot;pack-objects [options] base extra&quot; failed;&n;&t; * we would however want to take refs parameter that would&n;&t; * have been given to upstream rev-list ourselves, which means&n;&t; * we somehow want to say what the base name is.  So the&n;&t; * syntax would be:&n;&t; *&n;&t; * pack-objects [options] base &lt;refs...&gt;&n;&t; *&n;&t; * in other words, we would treat the first non-option as the&n;&t; * base_name and send everything else to the internal revision&n;&t; * walker.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|pack_to_stdout
)paren
id|base_name
op_assign
id|argv
(braket
id|i
op_increment
)braket
suffix:semicolon
r_if
c_cond
(paren
id|pack_to_stdout
op_ne
op_logical_neg
id|base_name
)paren
id|usage
c_func
(paren
id|pack_usage
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pack_to_stdout
op_logical_and
id|thin
)paren
id|die
c_func
(paren
l_string|&quot;--thin cannot be used to build an indexable pack.&quot;
)paren
suffix:semicolon
id|prepare_packed_git
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|progress
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Generating pack...&bslash;n&quot;
)paren
suffix:semicolon
id|setup_progress_signal
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|use_internal_rev_list
)paren
id|read_object_list_from_stdin
c_func
(paren
)paren
suffix:semicolon
r_else
(brace
id|rp_av
(braket
id|rp_ac
)braket
op_assign
l_int|NULL
suffix:semicolon
id|get_object_list
c_func
(paren
id|rp_ac
comma
id|rp_av
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|progress
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Done counting %u objects.&bslash;n&quot;
comma
id|nr_objects
)paren
suffix:semicolon
id|sorted_by_sha
op_assign
id|create_final_object_list
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|non_empty
op_logical_and
op_logical_neg
id|nr_result
)paren
r_return
l_int|0
suffix:semicolon
id|SHA1_Init
c_func
(paren
op_amp
id|ctx
)paren
suffix:semicolon
id|list
op_assign
id|sorted_by_sha
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_result
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|object_entry
op_star
id|entry
op_assign
op_star
id|list
op_increment
suffix:semicolon
id|SHA1_Update
c_func
(paren
op_amp
id|ctx
comma
id|entry-&gt;sha1
comma
l_int|20
)paren
suffix:semicolon
)brace
id|SHA1_Final
c_func
(paren
id|object_list_sha1
comma
op_amp
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|progress
op_logical_and
(paren
id|nr_objects
op_ne
id|nr_result
)paren
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Result has %u objects.&bslash;n&quot;
comma
id|nr_result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reuse_cached_pack
c_func
(paren
id|object_list_sha1
)paren
)paren
suffix:semicolon
r_else
(brace
id|off_t
id|last_obj_offset
suffix:semicolon
r_if
c_cond
(paren
id|nr_result
)paren
id|prepare_pack
c_func
(paren
id|window
comma
id|depth
)paren
suffix:semicolon
r_if
c_cond
(paren
id|progress
op_eq
l_int|1
op_logical_and
id|pack_to_stdout
)paren
(brace
multiline_comment|/* the other end usually displays progress itself */
r_struct
id|itimerval
id|v
op_assign
(brace
(brace
l_int|0
comma
)brace
comma
)brace
suffix:semicolon
id|setitimer
c_func
(paren
id|ITIMER_REAL
comma
op_amp
id|v
comma
l_int|NULL
)paren
suffix:semicolon
id|signal
c_func
(paren
id|SIGALRM
comma
id|SIG_IGN
)paren
suffix:semicolon
id|progress_update
op_assign
l_int|0
suffix:semicolon
)brace
id|last_obj_offset
op_assign
id|write_pack_file
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pack_to_stdout
)paren
(brace
id|write_index_file
c_func
(paren
id|last_obj_offset
)paren
suffix:semicolon
id|puts
c_func
(paren
id|sha1_to_hex
c_func
(paren
id|object_list_sha1
)paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|progress
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Total %u (delta %u), reused %u (delta %u)&bslash;n&quot;
comma
id|written
comma
id|written_delta
comma
id|reused
comma
id|reused_delta
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
