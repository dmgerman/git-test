macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;remote.h&quot;
macro_line|#include &quot;refs.h&quot;
macro_line|#include &quot;commit.h&quot;
macro_line|#include &quot;diff.h&quot;
macro_line|#include &quot;revision.h&quot;
macro_line|#include &quot;dir.h&quot;
macro_line|#include &quot;tag.h&quot;
macro_line|#include &quot;string-list.h&quot;
macro_line|#include &quot;mergesort.h&quot;
DECL|enum|map_direction
DECL|enumerator|FROM_SRC
DECL|enumerator|FROM_DST
r_enum
id|map_direction
(brace
id|FROM_SRC
comma
id|FROM_DST
)brace
suffix:semicolon
DECL|variable|s_tag_refspec
r_static
r_struct
id|refspec
id|s_tag_refspec
op_assign
(brace
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_string|&quot;refs/tags/*&quot;
comma
l_string|&quot;refs/tags/*&quot;
)brace
suffix:semicolon
DECL|variable|tag_refspec
r_const
r_struct
id|refspec
op_star
id|tag_refspec
op_assign
op_amp
id|s_tag_refspec
suffix:semicolon
DECL|struct|counted_string
r_struct
id|counted_string
(brace
DECL|member|len
r_int
id|len
suffix:semicolon
DECL|member|s
r_const
r_char
op_star
id|s
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|rewrite
r_struct
id|rewrite
(brace
DECL|member|base
r_const
r_char
op_star
id|base
suffix:semicolon
DECL|member|baselen
r_int
id|baselen
suffix:semicolon
DECL|member|instead_of
r_struct
id|counted_string
op_star
id|instead_of
suffix:semicolon
DECL|member|instead_of_nr
r_int
id|instead_of_nr
suffix:semicolon
DECL|member|instead_of_alloc
r_int
id|instead_of_alloc
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|rewrites
r_struct
id|rewrites
(brace
DECL|member|rewrite
r_struct
id|rewrite
op_star
op_star
id|rewrite
suffix:semicolon
DECL|member|rewrite_alloc
r_int
id|rewrite_alloc
suffix:semicolon
DECL|member|rewrite_nr
r_int
id|rewrite_nr
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|remotes
r_static
r_struct
id|remote
op_star
op_star
id|remotes
suffix:semicolon
DECL|variable|remotes_alloc
r_static
r_int
id|remotes_alloc
suffix:semicolon
DECL|variable|remotes_nr
r_static
r_int
id|remotes_nr
suffix:semicolon
DECL|variable|branches
r_static
r_struct
id|branch
op_star
op_star
id|branches
suffix:semicolon
DECL|variable|branches_alloc
r_static
r_int
id|branches_alloc
suffix:semicolon
DECL|variable|branches_nr
r_static
r_int
id|branches_nr
suffix:semicolon
DECL|variable|current_branch
r_static
r_struct
id|branch
op_star
id|current_branch
suffix:semicolon
DECL|variable|default_remote_name
r_static
r_const
r_char
op_star
id|default_remote_name
suffix:semicolon
DECL|variable|explicit_default_remote_name
r_static
r_int
id|explicit_default_remote_name
suffix:semicolon
DECL|variable|rewrites
r_static
r_struct
id|rewrites
id|rewrites
suffix:semicolon
DECL|variable|rewrites_push
r_static
r_struct
id|rewrites
id|rewrites_push
suffix:semicolon
DECL|macro|BUF_SIZE
mdefine_line|#define BUF_SIZE (2048)
DECL|variable|buffer
r_static
r_char
id|buffer
(braket
id|BUF_SIZE
)braket
suffix:semicolon
DECL|function|valid_remote
r_static
r_int
id|valid_remote
c_func
(paren
r_const
r_struct
id|remote
op_star
id|remote
)paren
(brace
r_return
(paren
op_logical_neg
op_logical_neg
id|remote-&gt;url
)paren
op_logical_or
(paren
op_logical_neg
op_logical_neg
id|remote-&gt;foreign_vcs
)paren
suffix:semicolon
)brace
DECL|function|alias_url
r_static
r_const
r_char
op_star
id|alias_url
c_func
(paren
r_const
r_char
op_star
id|url
comma
r_struct
id|rewrites
op_star
id|r
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_char
op_star
id|ret
suffix:semicolon
r_struct
id|counted_string
op_star
id|longest
suffix:semicolon
r_int
id|longest_i
suffix:semicolon
id|longest
op_assign
l_int|NULL
suffix:semicolon
id|longest_i
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|r-&gt;rewrite_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|r-&gt;rewrite
(braket
id|i
)braket
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|r-&gt;rewrite
(braket
id|i
)braket
op_member_access_from_pointer
id|instead_of_nr
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|url
comma
id|r-&gt;rewrite
(braket
id|i
)braket
op_member_access_from_pointer
id|instead_of
(braket
id|j
)braket
dot
id|s
)paren
op_logical_and
(paren
op_logical_neg
id|longest
op_logical_or
id|longest-&gt;len
OL
id|r-&gt;rewrite
(braket
id|i
)braket
op_member_access_from_pointer
id|instead_of
(braket
id|j
)braket
dot
id|len
)paren
)paren
(brace
id|longest
op_assign
op_amp
(paren
id|r-&gt;rewrite
(braket
id|i
)braket
op_member_access_from_pointer
id|instead_of
(braket
id|j
)braket
)paren
suffix:semicolon
id|longest_i
op_assign
id|i
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|longest
)paren
r_return
id|url
suffix:semicolon
id|ret
op_assign
id|xmalloc
c_func
(paren
id|r-&gt;rewrite
(braket
id|longest_i
)braket
op_member_access_from_pointer
id|baselen
op_plus
(paren
id|strlen
c_func
(paren
id|url
)paren
id|longest-&gt;len
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|ret
comma
id|r-&gt;rewrite
(braket
id|longest_i
)braket
op_member_access_from_pointer
id|base
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|ret
op_plus
id|r-&gt;rewrite
(braket
id|longest_i
)braket
op_member_access_from_pointer
id|baselen
comma
id|url
op_plus
id|longest-&gt;len
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|add_push_refspec
r_static
r_void
id|add_push_refspec
c_func
(paren
r_struct
id|remote
op_star
id|remote
comma
r_const
r_char
op_star
id|ref
)paren
(brace
id|ALLOC_GROW
c_func
(paren
id|remote-&gt;push_refspec
comma
id|remote-&gt;push_refspec_nr
op_plus
l_int|1
comma
id|remote-&gt;push_refspec_alloc
)paren
suffix:semicolon
id|remote-&gt;push_refspec
(braket
id|remote-&gt;push_refspec_nr
op_increment
)braket
op_assign
id|ref
suffix:semicolon
)brace
DECL|function|add_fetch_refspec
r_static
r_void
id|add_fetch_refspec
c_func
(paren
r_struct
id|remote
op_star
id|remote
comma
r_const
r_char
op_star
id|ref
)paren
(brace
id|ALLOC_GROW
c_func
(paren
id|remote-&gt;fetch_refspec
comma
id|remote-&gt;fetch_refspec_nr
op_plus
l_int|1
comma
id|remote-&gt;fetch_refspec_alloc
)paren
suffix:semicolon
id|remote-&gt;fetch_refspec
(braket
id|remote-&gt;fetch_refspec_nr
op_increment
)braket
op_assign
id|ref
suffix:semicolon
)brace
DECL|function|add_url
r_static
r_void
id|add_url
c_func
(paren
r_struct
id|remote
op_star
id|remote
comma
r_const
r_char
op_star
id|url
)paren
(brace
id|ALLOC_GROW
c_func
(paren
id|remote-&gt;url
comma
id|remote-&gt;url_nr
op_plus
l_int|1
comma
id|remote-&gt;url_alloc
)paren
suffix:semicolon
id|remote-&gt;url
(braket
id|remote-&gt;url_nr
op_increment
)braket
op_assign
id|url
suffix:semicolon
)brace
DECL|function|add_pushurl
r_static
r_void
id|add_pushurl
c_func
(paren
r_struct
id|remote
op_star
id|remote
comma
r_const
r_char
op_star
id|pushurl
)paren
(brace
id|ALLOC_GROW
c_func
(paren
id|remote-&gt;pushurl
comma
id|remote-&gt;pushurl_nr
op_plus
l_int|1
comma
id|remote-&gt;pushurl_alloc
)paren
suffix:semicolon
id|remote-&gt;pushurl
(braket
id|remote-&gt;pushurl_nr
op_increment
)braket
op_assign
id|pushurl
suffix:semicolon
)brace
DECL|function|add_pushurl_alias
r_static
r_void
id|add_pushurl_alias
c_func
(paren
r_struct
id|remote
op_star
id|remote
comma
r_const
r_char
op_star
id|url
)paren
(brace
r_const
r_char
op_star
id|pushurl
op_assign
id|alias_url
c_func
(paren
id|url
comma
op_amp
id|rewrites_push
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pushurl
op_ne
id|url
)paren
id|add_pushurl
c_func
(paren
id|remote
comma
id|pushurl
)paren
suffix:semicolon
)brace
DECL|function|add_url_alias
r_static
r_void
id|add_url_alias
c_func
(paren
r_struct
id|remote
op_star
id|remote
comma
r_const
r_char
op_star
id|url
)paren
(brace
id|add_url
c_func
(paren
id|remote
comma
id|alias_url
c_func
(paren
id|url
comma
op_amp
id|rewrites
)paren
)paren
suffix:semicolon
id|add_pushurl_alias
c_func
(paren
id|remote
comma
id|url
)paren
suffix:semicolon
)brace
DECL|function|make_remote
r_static
r_struct
id|remote
op_star
id|make_remote
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_int
id|len
)paren
(brace
r_struct
id|remote
op_star
id|ret
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|remotes_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|len
ques
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|name
comma
id|remotes
(braket
id|i
)braket
op_member_access_from_pointer
id|name
comma
id|len
)paren
op_logical_and
op_logical_neg
id|remotes
(braket
id|i
)braket
op_member_access_from_pointer
id|name
(braket
id|len
)braket
)paren
suffix:colon
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
id|remotes
(braket
id|i
)braket
op_member_access_from_pointer
id|name
)paren
)paren
r_return
id|remotes
(braket
id|i
)braket
suffix:semicolon
)brace
id|ret
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|remote
)paren
)paren
suffix:semicolon
id|ALLOC_GROW
c_func
(paren
id|remotes
comma
id|remotes_nr
op_plus
l_int|1
comma
id|remotes_alloc
)paren
suffix:semicolon
id|remotes
(braket
id|remotes_nr
op_increment
)braket
op_assign
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|len
)paren
id|ret-&gt;name
op_assign
id|xstrndup
c_func
(paren
id|name
comma
id|len
)paren
suffix:semicolon
r_else
id|ret-&gt;name
op_assign
id|xstrdup
c_func
(paren
id|name
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|add_merge
r_static
r_void
id|add_merge
c_func
(paren
r_struct
id|branch
op_star
id|branch
comma
r_const
r_char
op_star
id|name
)paren
(brace
id|ALLOC_GROW
c_func
(paren
id|branch-&gt;merge_name
comma
id|branch-&gt;merge_nr
op_plus
l_int|1
comma
id|branch-&gt;merge_alloc
)paren
suffix:semicolon
id|branch-&gt;merge_name
(braket
id|branch-&gt;merge_nr
op_increment
)braket
op_assign
id|name
suffix:semicolon
)brace
DECL|function|make_branch
r_static
r_struct
id|branch
op_star
id|make_branch
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_int
id|len
)paren
(brace
r_struct
id|branch
op_star
id|ret
suffix:semicolon
r_int
id|i
suffix:semicolon
r_char
op_star
id|refname
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|branches_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|len
ques
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|name
comma
id|branches
(braket
id|i
)braket
op_member_access_from_pointer
id|name
comma
id|len
)paren
op_logical_and
op_logical_neg
id|branches
(braket
id|i
)braket
op_member_access_from_pointer
id|name
(braket
id|len
)braket
)paren
suffix:colon
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
id|branches
(braket
id|i
)braket
op_member_access_from_pointer
id|name
)paren
)paren
r_return
id|branches
(braket
id|i
)braket
suffix:semicolon
)brace
id|ALLOC_GROW
c_func
(paren
id|branches
comma
id|branches_nr
op_plus
l_int|1
comma
id|branches_alloc
)paren
suffix:semicolon
id|ret
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|branch
)paren
)paren
suffix:semicolon
id|branches
(braket
id|branches_nr
op_increment
)braket
op_assign
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|len
)paren
id|ret-&gt;name
op_assign
id|xstrndup
c_func
(paren
id|name
comma
id|len
)paren
suffix:semicolon
r_else
id|ret-&gt;name
op_assign
id|xstrdup
c_func
(paren
id|name
)paren
suffix:semicolon
id|refname
op_assign
id|xmalloc
c_func
(paren
id|strlen
c_func
(paren
id|name
)paren
op_plus
id|strlen
c_func
(paren
l_string|&quot;refs/heads/&quot;
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|refname
comma
l_string|&quot;refs/heads/&quot;
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|refname
op_plus
id|strlen
c_func
(paren
l_string|&quot;refs/heads/&quot;
)paren
comma
id|ret-&gt;name
)paren
suffix:semicolon
id|ret-&gt;refname
op_assign
id|refname
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|make_rewrite
r_static
r_struct
id|rewrite
op_star
id|make_rewrite
c_func
(paren
r_struct
id|rewrites
op_star
id|r
comma
r_const
r_char
op_star
id|base
comma
r_int
id|len
)paren
(brace
r_struct
id|rewrite
op_star
id|ret
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|r-&gt;rewrite_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|len
ques
c_cond
(paren
id|len
op_eq
id|r-&gt;rewrite
(braket
id|i
)braket
op_member_access_from_pointer
id|baselen
op_logical_and
op_logical_neg
id|strncmp
c_func
(paren
id|base
comma
id|r-&gt;rewrite
(braket
id|i
)braket
op_member_access_from_pointer
id|base
comma
id|len
)paren
)paren
suffix:colon
op_logical_neg
id|strcmp
c_func
(paren
id|base
comma
id|r-&gt;rewrite
(braket
id|i
)braket
op_member_access_from_pointer
id|base
)paren
)paren
r_return
id|r-&gt;rewrite
(braket
id|i
)braket
suffix:semicolon
)brace
id|ALLOC_GROW
c_func
(paren
id|r-&gt;rewrite
comma
id|r-&gt;rewrite_nr
op_plus
l_int|1
comma
id|r-&gt;rewrite_alloc
)paren
suffix:semicolon
id|ret
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|rewrite
)paren
)paren
suffix:semicolon
id|r-&gt;rewrite
(braket
id|r-&gt;rewrite_nr
op_increment
)braket
op_assign
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|len
)paren
(brace
id|ret-&gt;base
op_assign
id|xstrndup
c_func
(paren
id|base
comma
id|len
)paren
suffix:semicolon
id|ret-&gt;baselen
op_assign
id|len
suffix:semicolon
)brace
r_else
(brace
id|ret-&gt;base
op_assign
id|xstrdup
c_func
(paren
id|base
)paren
suffix:semicolon
id|ret-&gt;baselen
op_assign
id|strlen
c_func
(paren
id|base
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|add_instead_of
r_static
r_void
id|add_instead_of
c_func
(paren
r_struct
id|rewrite
op_star
id|rewrite
comma
r_const
r_char
op_star
id|instead_of
)paren
(brace
id|ALLOC_GROW
c_func
(paren
id|rewrite-&gt;instead_of
comma
id|rewrite-&gt;instead_of_nr
op_plus
l_int|1
comma
id|rewrite-&gt;instead_of_alloc
)paren
suffix:semicolon
id|rewrite-&gt;instead_of
(braket
id|rewrite-&gt;instead_of_nr
)braket
dot
id|s
op_assign
id|instead_of
suffix:semicolon
id|rewrite-&gt;instead_of
(braket
id|rewrite-&gt;instead_of_nr
)braket
dot
id|len
op_assign
id|strlen
c_func
(paren
id|instead_of
)paren
suffix:semicolon
id|rewrite-&gt;instead_of_nr
op_increment
suffix:semicolon
)brace
DECL|function|read_remotes_file
r_static
r_void
id|read_remotes_file
c_func
(paren
r_struct
id|remote
op_star
id|remote
)paren
(brace
id|FILE
op_star
id|f
op_assign
id|fopen
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;remotes/%s&quot;
comma
id|remote-&gt;name
)paren
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|f
)paren
r_return
suffix:semicolon
id|remote-&gt;origin
op_assign
id|REMOTE_REMOTES
suffix:semicolon
r_while
c_loop
(paren
id|fgets
c_func
(paren
id|buffer
comma
id|BUF_SIZE
comma
id|f
)paren
)paren
(brace
r_int
id|value_list
suffix:semicolon
r_char
op_star
id|s
comma
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|buffer
comma
l_string|&quot;URL:&quot;
)paren
)paren
(brace
id|value_list
op_assign
l_int|0
suffix:semicolon
id|s
op_assign
id|buffer
op_plus
l_int|4
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|buffer
comma
l_string|&quot;Push:&quot;
)paren
)paren
(brace
id|value_list
op_assign
l_int|1
suffix:semicolon
id|s
op_assign
id|buffer
op_plus
l_int|5
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|buffer
comma
l_string|&quot;Pull:&quot;
)paren
)paren
(brace
id|value_list
op_assign
l_int|2
suffix:semicolon
id|s
op_assign
id|buffer
op_plus
l_int|5
suffix:semicolon
)brace
r_else
r_continue
suffix:semicolon
r_while
c_loop
(paren
id|isspace
c_func
(paren
op_star
id|s
)paren
)paren
id|s
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|s
)paren
r_continue
suffix:semicolon
id|p
op_assign
id|s
op_plus
id|strlen
c_func
(paren
id|s
)paren
suffix:semicolon
r_while
c_loop
(paren
id|isspace
c_func
(paren
id|p
(braket
l_int|1
)braket
)paren
)paren
op_star
op_decrement
id|p
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|value_list
)paren
(brace
r_case
l_int|0
suffix:colon
id|add_url_alias
c_func
(paren
id|remote
comma
id|xstrdup
c_func
(paren
id|s
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|add_push_refspec
c_func
(paren
id|remote
comma
id|xstrdup
c_func
(paren
id|s
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|add_fetch_refspec
c_func
(paren
id|remote
comma
id|xstrdup
c_func
(paren
id|s
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|fclose
c_func
(paren
id|f
)paren
suffix:semicolon
)brace
DECL|function|read_branches_file
r_static
r_void
id|read_branches_file
c_func
(paren
r_struct
id|remote
op_star
id|remote
)paren
(brace
r_const
r_char
op_star
id|slash
op_assign
id|strchr
c_func
(paren
id|remote-&gt;name
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
r_char
op_star
id|frag
suffix:semicolon
r_struct
id|strbuf
id|branch
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|n
op_assign
id|slash
ques
c_cond
id|slash
id|remote-&gt;name
suffix:colon
l_int|1000
suffix:semicolon
id|FILE
op_star
id|f
op_assign
id|fopen
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;branches/%.*s&quot;
comma
id|n
comma
id|remote-&gt;name
)paren
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_char
op_star
id|s
comma
op_star
id|p
suffix:semicolon
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|f
)paren
r_return
suffix:semicolon
id|s
op_assign
id|fgets
c_func
(paren
id|buffer
comma
id|BUF_SIZE
comma
id|f
)paren
suffix:semicolon
id|fclose
c_func
(paren
id|f
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
id|isspace
c_func
(paren
op_star
id|s
)paren
)paren
id|s
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|s
)paren
r_return
suffix:semicolon
id|remote-&gt;origin
op_assign
id|REMOTE_BRANCHES
suffix:semicolon
id|p
op_assign
id|s
op_plus
id|strlen
c_func
(paren
id|s
)paren
suffix:semicolon
r_while
c_loop
(paren
id|isspace
c_func
(paren
id|p
(braket
l_int|1
)braket
)paren
)paren
op_star
op_decrement
id|p
op_assign
l_int|0
suffix:semicolon
id|len
op_assign
id|p
id|s
suffix:semicolon
r_if
c_cond
(paren
id|slash
)paren
id|len
op_add_assign
id|strlen
c_func
(paren
id|slash
)paren
suffix:semicolon
id|p
op_assign
id|xmalloc
c_func
(paren
id|len
op_plus
l_int|1
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|p
comma
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slash
)paren
id|strcat
c_func
(paren
id|p
comma
id|slash
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * With &quot;slash&quot;, e.g. &quot;git fetch jgarzik/netdev-2.6&quot; when&n;&t; * reading from $GIT_DIR/branches/jgarzik fetches &quot;HEAD&quot; from&n;&t; * the partial URL obtained from the branches file plus&n;&t; * &quot;/netdev-2.6&quot; and does not store it in any tracking ref.&n;&t; * #branch specifier in the file is ignored.&n;&t; *&n;&t; * Otherwise, the branches file would have URL and optionally&n;&t; * #branch specified.  The &quot;master&quot; (or specified) branch is&n;&t; * fetched and stored in the local branch of the same name.&n;&t; */
id|frag
op_assign
id|strchr
c_func
(paren
id|p
comma
l_char|&squot;#&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|frag
)paren
(brace
op_star
(paren
id|frag
op_increment
)paren
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
id|branch
comma
l_string|&quot;refs/heads/%s&quot;
comma
id|frag
)paren
suffix:semicolon
)brace
r_else
id|strbuf_addstr
c_func
(paren
op_amp
id|branch
comma
l_string|&quot;refs/heads/master&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|slash
)paren
(brace
id|strbuf_addf
c_func
(paren
op_amp
id|branch
comma
l_string|&quot;:refs/heads/%s&quot;
comma
id|remote-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
id|strbuf_reset
c_func
(paren
op_amp
id|branch
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|branch
comma
l_string|&quot;HEAD:&quot;
)paren
suffix:semicolon
)brace
id|add_url_alias
c_func
(paren
id|remote
comma
id|p
)paren
suffix:semicolon
id|add_fetch_refspec
c_func
(paren
id|remote
comma
id|strbuf_detach
c_func
(paren
op_amp
id|branch
comma
l_int|NULL
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Cogito compatible push: push current HEAD to remote #branch&n;&t; * (master if missing)&n;&t; */
id|strbuf_init
c_func
(paren
op_amp
id|branch
comma
l_int|0
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|branch
comma
l_string|&quot;HEAD&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|frag
)paren
id|strbuf_addf
c_func
(paren
op_amp
id|branch
comma
l_string|&quot;:refs/heads/%s&quot;
comma
id|frag
)paren
suffix:semicolon
r_else
id|strbuf_addstr
c_func
(paren
op_amp
id|branch
comma
l_string|&quot;:refs/heads/master&quot;
)paren
suffix:semicolon
id|add_push_refspec
c_func
(paren
id|remote
comma
id|strbuf_detach
c_func
(paren
op_amp
id|branch
comma
l_int|NULL
)paren
)paren
suffix:semicolon
id|remote-&gt;fetch_tags
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* always auto-follow */
)brace
DECL|function|handle_config
r_static
r_int
id|handle_config
c_func
(paren
r_const
r_char
op_star
id|key
comma
r_const
r_char
op_star
id|value
comma
r_void
op_star
id|cb
)paren
(brace
r_const
r_char
op_star
id|name
suffix:semicolon
r_const
r_char
op_star
id|subkey
suffix:semicolon
r_struct
id|remote
op_star
id|remote
suffix:semicolon
r_struct
id|branch
op_star
id|branch
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|key
comma
l_string|&quot;branch.&quot;
)paren
)paren
(brace
id|name
op_assign
id|key
op_plus
l_int|7
suffix:semicolon
id|subkey
op_assign
id|strrchr
c_func
(paren
id|name
comma
l_char|&squot;.&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|subkey
)paren
r_return
l_int|0
suffix:semicolon
id|branch
op_assign
id|make_branch
c_func
(paren
id|name
comma
id|subkey
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|subkey
comma
l_string|&quot;.remote&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
r_return
id|config_error_nonbool
c_func
(paren
id|key
)paren
suffix:semicolon
id|branch-&gt;remote_name
op_assign
id|xstrdup
c_func
(paren
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|branch
op_eq
id|current_branch
)paren
(brace
id|default_remote_name
op_assign
id|branch-&gt;remote_name
suffix:semicolon
id|explicit_default_remote_name
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|subkey
comma
l_string|&quot;.merge&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
r_return
id|config_error_nonbool
c_func
(paren
id|key
)paren
suffix:semicolon
id|add_merge
c_func
(paren
id|branch
comma
id|xstrdup
c_func
(paren
id|value
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|key
comma
l_string|&quot;url.&quot;
)paren
)paren
(brace
r_struct
id|rewrite
op_star
id|rewrite
suffix:semicolon
id|name
op_assign
id|key
op_plus
l_int|4
suffix:semicolon
id|subkey
op_assign
id|strrchr
c_func
(paren
id|name
comma
l_char|&squot;.&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|subkey
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|subkey
comma
l_string|&quot;.insteadof&quot;
)paren
)paren
(brace
id|rewrite
op_assign
id|make_rewrite
c_func
(paren
op_amp
id|rewrites
comma
id|name
comma
id|subkey
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
r_return
id|config_error_nonbool
c_func
(paren
id|key
)paren
suffix:semicolon
id|add_instead_of
c_func
(paren
id|rewrite
comma
id|xstrdup
c_func
(paren
id|value
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|subkey
comma
l_string|&quot;.pushinsteadof&quot;
)paren
)paren
(brace
id|rewrite
op_assign
id|make_rewrite
c_func
(paren
op_amp
id|rewrites_push
comma
id|name
comma
id|subkey
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
r_return
id|config_error_nonbool
c_func
(paren
id|key
)paren
suffix:semicolon
id|add_instead_of
c_func
(paren
id|rewrite
comma
id|xstrdup
c_func
(paren
id|value
)paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|prefixcmp
c_func
(paren
id|key
comma
l_string|&quot;remote.&quot;
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|name
op_assign
id|key
op_plus
l_int|7
suffix:semicolon
r_if
c_cond
(paren
op_star
id|name
op_eq
l_char|&squot;/&squot;
)paren
(brace
id|warning
c_func
(paren
l_string|&quot;Config remote shorthand cannot begin with &squot;/&squot;: %s&quot;
comma
id|name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|subkey
op_assign
id|strrchr
c_func
(paren
id|name
comma
l_char|&squot;.&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|subkey
)paren
r_return
l_int|0
suffix:semicolon
id|remote
op_assign
id|make_remote
c_func
(paren
id|name
comma
id|subkey
id|name
)paren
suffix:semicolon
id|remote-&gt;origin
op_assign
id|REMOTE_CONFIG
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|subkey
comma
l_string|&quot;.mirror&quot;
)paren
)paren
id|remote-&gt;mirror
op_assign
id|git_config_bool
c_func
(paren
id|key
comma
id|value
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|subkey
comma
l_string|&quot;.skipdefaultupdate&quot;
)paren
)paren
id|remote-&gt;skip_default_update
op_assign
id|git_config_bool
c_func
(paren
id|key
comma
id|value
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|subkey
comma
l_string|&quot;.skipfetchall&quot;
)paren
)paren
id|remote-&gt;skip_default_update
op_assign
id|git_config_bool
c_func
(paren
id|key
comma
id|value
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|subkey
comma
l_string|&quot;.url&quot;
)paren
)paren
(brace
r_const
r_char
op_star
id|v
suffix:semicolon
r_if
c_cond
(paren
id|git_config_string
c_func
(paren
op_amp
id|v
comma
id|key
comma
id|value
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|add_url
c_func
(paren
id|remote
comma
id|v
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|subkey
comma
l_string|&quot;.pushurl&quot;
)paren
)paren
(brace
r_const
r_char
op_star
id|v
suffix:semicolon
r_if
c_cond
(paren
id|git_config_string
c_func
(paren
op_amp
id|v
comma
id|key
comma
id|value
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|add_pushurl
c_func
(paren
id|remote
comma
id|v
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|subkey
comma
l_string|&quot;.push&quot;
)paren
)paren
(brace
r_const
r_char
op_star
id|v
suffix:semicolon
r_if
c_cond
(paren
id|git_config_string
c_func
(paren
op_amp
id|v
comma
id|key
comma
id|value
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|add_push_refspec
c_func
(paren
id|remote
comma
id|v
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|subkey
comma
l_string|&quot;.fetch&quot;
)paren
)paren
(brace
r_const
r_char
op_star
id|v
suffix:semicolon
r_if
c_cond
(paren
id|git_config_string
c_func
(paren
op_amp
id|v
comma
id|key
comma
id|value
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|add_fetch_refspec
c_func
(paren
id|remote
comma
id|v
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|subkey
comma
l_string|&quot;.receivepack&quot;
)paren
)paren
(brace
r_const
r_char
op_star
id|v
suffix:semicolon
r_if
c_cond
(paren
id|git_config_string
c_func
(paren
op_amp
id|v
comma
id|key
comma
id|value
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|remote-&gt;receivepack
)paren
id|remote-&gt;receivepack
op_assign
id|v
suffix:semicolon
r_else
id|error
c_func
(paren
l_string|&quot;more than one receivepack given, using the first&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|subkey
comma
l_string|&quot;.uploadpack&quot;
)paren
)paren
(brace
r_const
r_char
op_star
id|v
suffix:semicolon
r_if
c_cond
(paren
id|git_config_string
c_func
(paren
op_amp
id|v
comma
id|key
comma
id|value
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|remote-&gt;uploadpack
)paren
id|remote-&gt;uploadpack
op_assign
id|v
suffix:semicolon
r_else
id|error
c_func
(paren
l_string|&quot;more than one uploadpack given, using the first&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|subkey
comma
l_string|&quot;.tagopt&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|value
comma
l_string|&quot;--no-tags&quot;
)paren
)paren
id|remote-&gt;fetch_tags
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|value
comma
l_string|&quot;--tags&quot;
)paren
)paren
id|remote-&gt;fetch_tags
op_assign
l_int|2
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|subkey
comma
l_string|&quot;.proxy&quot;
)paren
)paren
(brace
r_return
id|git_config_string
c_func
(paren
(paren
r_const
r_char
op_star
op_star
)paren
op_amp
id|remote-&gt;http_proxy
comma
id|key
comma
id|value
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|subkey
comma
l_string|&quot;.vcs&quot;
)paren
)paren
(brace
r_return
id|git_config_string
c_func
(paren
op_amp
id|remote-&gt;foreign_vcs
comma
id|key
comma
id|value
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|alias_all_urls
r_static
r_void
id|alias_all_urls
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|remotes_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|add_pushurl_aliases
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|remotes
(braket
id|i
)braket
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|remotes
(braket
id|i
)braket
op_member_access_from_pointer
id|pushurl_nr
suffix:semicolon
id|j
op_increment
)paren
(brace
id|remotes
(braket
id|i
)braket
op_member_access_from_pointer
id|pushurl
(braket
id|j
)braket
op_assign
id|alias_url
c_func
(paren
id|remotes
(braket
id|i
)braket
op_member_access_from_pointer
id|pushurl
(braket
id|j
)braket
comma
op_amp
id|rewrites
)paren
suffix:semicolon
)brace
id|add_pushurl_aliases
op_assign
id|remotes
(braket
id|i
)braket
op_member_access_from_pointer
id|pushurl_nr
op_eq
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|remotes
(braket
id|i
)braket
op_member_access_from_pointer
id|url_nr
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|add_pushurl_aliases
)paren
id|add_pushurl_alias
c_func
(paren
id|remotes
(braket
id|i
)braket
comma
id|remotes
(braket
id|i
)braket
op_member_access_from_pointer
id|url
(braket
id|j
)braket
)paren
suffix:semicolon
id|remotes
(braket
id|i
)braket
op_member_access_from_pointer
id|url
(braket
id|j
)braket
op_assign
id|alias_url
c_func
(paren
id|remotes
(braket
id|i
)braket
op_member_access_from_pointer
id|url
(braket
id|j
)braket
comma
op_amp
id|rewrites
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|read_config
r_static
r_void
id|read_config
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_const
r_char
op_star
id|head_ref
suffix:semicolon
r_int
id|flag
suffix:semicolon
r_if
c_cond
(paren
id|default_remote_name
)paren
multiline_comment|/* did this already */
r_return
suffix:semicolon
id|default_remote_name
op_assign
id|xstrdup
c_func
(paren
l_string|&quot;origin&quot;
)paren
suffix:semicolon
id|current_branch
op_assign
l_int|NULL
suffix:semicolon
id|head_ref
op_assign
id|resolve_ref_unsafe
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|sha1
comma
l_int|0
comma
op_amp
id|flag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|head_ref
op_logical_and
(paren
id|flag
op_amp
id|REF_ISSYMREF
)paren
op_logical_and
op_logical_neg
id|prefixcmp
c_func
(paren
id|head_ref
comma
l_string|&quot;refs/heads/&quot;
)paren
)paren
(brace
id|current_branch
op_assign
id|make_branch
c_func
(paren
id|head_ref
op_plus
id|strlen
c_func
(paren
l_string|&quot;refs/heads/&quot;
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
id|git_config
c_func
(paren
id|handle_config
comma
l_int|NULL
)paren
suffix:semicolon
id|alias_all_urls
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function frees a refspec array.&n; * Warning: code paths should be checked to ensure that the src&n; *          and dst pointers are always freeable pointers as well&n; *          as the refspec pointer itself.&n; */
DECL|function|free_refspecs
r_static
r_void
id|free_refspecs
c_func
(paren
r_struct
id|refspec
op_star
id|refspec
comma
r_int
id|nr_refspec
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|refspec
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_refspec
suffix:semicolon
id|i
op_increment
)paren
(brace
id|free
c_func
(paren
id|refspec
(braket
id|i
)braket
dot
id|src
)paren
suffix:semicolon
id|free
c_func
(paren
id|refspec
(braket
id|i
)braket
dot
id|dst
)paren
suffix:semicolon
)brace
id|free
c_func
(paren
id|refspec
)paren
suffix:semicolon
)brace
DECL|function|parse_refspec_internal
r_static
r_struct
id|refspec
op_star
id|parse_refspec_internal
c_func
(paren
r_int
id|nr_refspec
comma
r_const
r_char
op_star
op_star
id|refspec
comma
r_int
id|fetch
comma
r_int
id|verify
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|refspec
op_star
id|rs
op_assign
id|xcalloc
c_func
(paren
r_sizeof
(paren
op_star
id|rs
)paren
comma
id|nr_refspec
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_refspec
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|llen
suffix:semicolon
r_int
id|is_glob
suffix:semicolon
r_const
r_char
op_star
id|lhs
comma
op_star
id|rhs
suffix:semicolon
r_int
id|flags
suffix:semicolon
id|is_glob
op_assign
l_int|0
suffix:semicolon
id|lhs
op_assign
id|refspec
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_star
id|lhs
op_eq
l_char|&squot;+&squot;
)paren
(brace
id|rs
(braket
id|i
)braket
dot
id|force
op_assign
l_int|1
suffix:semicolon
id|lhs
op_increment
suffix:semicolon
)brace
id|rhs
op_assign
id|strrchr
c_func
(paren
id|lhs
comma
l_char|&squot;:&squot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Before going on, special case &quot;:&quot; (or &quot;+:&quot;) as a refspec&n;&t;&t; * for matching refs.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|fetch
op_logical_and
id|rhs
op_eq
id|lhs
op_logical_and
id|rhs
(braket
l_int|1
)braket
op_eq
l_char|&squot;&bslash;0&squot;
)paren
(brace
id|rs
(braket
id|i
)braket
dot
id|matching
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rhs
)paren
(brace
r_int
id|rlen
op_assign
id|strlen
c_func
(paren
op_increment
id|rhs
)paren
suffix:semicolon
id|is_glob
op_assign
(paren
l_int|1
op_le
id|rlen
op_logical_and
id|strchr
c_func
(paren
id|rhs
comma
l_char|&squot;*&squot;
)paren
)paren
suffix:semicolon
id|rs
(braket
id|i
)braket
dot
id|dst
op_assign
id|xstrndup
c_func
(paren
id|rhs
comma
id|rlen
)paren
suffix:semicolon
)brace
id|llen
op_assign
(paren
id|rhs
ques
c_cond
(paren
id|rhs
id|lhs
l_int|1
)paren
suffix:colon
id|strlen
c_func
(paren
id|lhs
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|1
op_le
id|llen
op_logical_and
id|memchr
c_func
(paren
id|lhs
comma
l_char|&squot;*&squot;
comma
id|llen
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|rhs
op_logical_and
op_logical_neg
id|is_glob
)paren
op_logical_or
(paren
op_logical_neg
id|rhs
op_logical_and
id|fetch
)paren
)paren
r_goto
id|invalid
suffix:semicolon
id|is_glob
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rhs
op_logical_and
id|is_glob
)paren
(brace
r_goto
id|invalid
suffix:semicolon
)brace
id|rs
(braket
id|i
)braket
dot
id|pattern
op_assign
id|is_glob
suffix:semicolon
id|rs
(braket
id|i
)braket
dot
id|src
op_assign
id|xstrndup
c_func
(paren
id|lhs
comma
id|llen
)paren
suffix:semicolon
id|flags
op_assign
id|REFNAME_ALLOW_ONELEVEL
op_or
(paren
id|is_glob
ques
c_cond
id|REFNAME_REFSPEC_PATTERN
suffix:colon
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fetch
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * LHS&n;&t;&t;&t; * - empty is allowed; it means HEAD.&n;&t;&t;&t; * - otherwise it must be a valid looking ref.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
op_star
id|rs
(braket
id|i
)braket
dot
id|src
)paren
suffix:semicolon
multiline_comment|/* empty is ok */
r_else
r_if
c_cond
(paren
id|check_refname_format
c_func
(paren
id|rs
(braket
id|i
)braket
dot
id|src
comma
id|flags
)paren
)paren
r_goto
id|invalid
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * RHS&n;&t;&t;&t; * - missing is ok, and is same as empty.&n;&t;&t;&t; * - empty is ok; it means not to store.&n;&t;&t;&t; * - otherwise it must be a valid looking ref.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|rs
(braket
id|i
)braket
dot
id|dst
)paren
suffix:semicolon
multiline_comment|/* ok */
r_else
r_if
c_cond
(paren
op_logical_neg
op_star
id|rs
(braket
id|i
)braket
dot
id|dst
)paren
suffix:semicolon
multiline_comment|/* ok */
r_else
r_if
c_cond
(paren
id|check_refname_format
c_func
(paren
id|rs
(braket
id|i
)braket
dot
id|dst
comma
id|flags
)paren
)paren
r_goto
id|invalid
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * LHS&n;&t;&t;&t; * - empty is allowed; it means delete.&n;&t;&t;&t; * - when wildcarded, it must be a valid looking ref.&n;&t;&t;&t; * - otherwise, it must be an extended SHA-1, but&n;&t;&t;&t; *   there is no existing way to validate this.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
op_star
id|rs
(braket
id|i
)braket
dot
id|src
)paren
suffix:semicolon
multiline_comment|/* empty is ok */
r_else
r_if
c_cond
(paren
id|is_glob
)paren
(brace
r_if
c_cond
(paren
id|check_refname_format
c_func
(paren
id|rs
(braket
id|i
)braket
dot
id|src
comma
id|flags
)paren
)paren
r_goto
id|invalid
suffix:semicolon
)brace
r_else
suffix:semicolon
multiline_comment|/* anything goes, for now */
multiline_comment|/*&n;&t;&t;&t; * RHS&n;&t;&t;&t; * - missing is allowed, but LHS then must be a&n;&t;&t;&t; *   valid looking ref.&n;&t;&t;&t; * - empty is not allowed.&n;&t;&t;&t; * - otherwise it must be a valid looking ref.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|rs
(braket
id|i
)braket
dot
id|dst
)paren
(brace
r_if
c_cond
(paren
id|check_refname_format
c_func
(paren
id|rs
(braket
id|i
)braket
dot
id|src
comma
id|flags
)paren
)paren
r_goto
id|invalid
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
op_star
id|rs
(braket
id|i
)braket
dot
id|dst
)paren
(brace
r_goto
id|invalid
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|check_refname_format
c_func
(paren
id|rs
(braket
id|i
)braket
dot
id|dst
comma
id|flags
)paren
)paren
r_goto
id|invalid
suffix:semicolon
)brace
)brace
)brace
r_return
id|rs
suffix:semicolon
id|invalid
suffix:colon
r_if
c_cond
(paren
id|verify
)paren
(brace
multiline_comment|/*&n;&t;&t; * nr_refspec must be greater than zero and i must be valid&n;&t;&t; * since it is only possible to reach this point from within&n;&t;&t; * the for loop above.&n;&t;&t; */
id|free_refspecs
c_func
(paren
id|rs
comma
id|i
op_plus
l_int|1
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|die
c_func
(paren
l_string|&quot;Invalid refspec &squot;%s&squot;&quot;
comma
id|refspec
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
DECL|function|valid_fetch_refspec
r_int
id|valid_fetch_refspec
c_func
(paren
r_const
r_char
op_star
id|fetch_refspec_str
)paren
(brace
r_struct
id|refspec
op_star
id|refspec
suffix:semicolon
id|refspec
op_assign
id|parse_refspec_internal
c_func
(paren
l_int|1
comma
op_amp
id|fetch_refspec_str
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
id|free_refspecs
c_func
(paren
id|refspec
comma
l_int|1
)paren
suffix:semicolon
r_return
op_logical_neg
op_logical_neg
id|refspec
suffix:semicolon
)brace
DECL|function|parse_fetch_refspec
r_struct
id|refspec
op_star
id|parse_fetch_refspec
c_func
(paren
r_int
id|nr_refspec
comma
r_const
r_char
op_star
op_star
id|refspec
)paren
(brace
r_return
id|parse_refspec_internal
c_func
(paren
id|nr_refspec
comma
id|refspec
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|parse_push_refspec
r_static
r_struct
id|refspec
op_star
id|parse_push_refspec
c_func
(paren
r_int
id|nr_refspec
comma
r_const
r_char
op_star
op_star
id|refspec
)paren
(brace
r_return
id|parse_refspec_internal
c_func
(paren
id|nr_refspec
comma
id|refspec
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|free_refspec
r_void
id|free_refspec
c_func
(paren
r_int
id|nr_refspec
comma
r_struct
id|refspec
op_star
id|refspec
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_refspec
suffix:semicolon
id|i
op_increment
)paren
(brace
id|free
c_func
(paren
id|refspec
(braket
id|i
)braket
dot
id|src
)paren
suffix:semicolon
id|free
c_func
(paren
id|refspec
(braket
id|i
)braket
dot
id|dst
)paren
suffix:semicolon
)brace
id|free
c_func
(paren
id|refspec
)paren
suffix:semicolon
)brace
DECL|function|valid_remote_nick
r_static
r_int
id|valid_remote_nick
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|name
(braket
l_int|0
)braket
op_logical_or
id|is_dot_or_dotdot
c_func
(paren
id|name
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
op_logical_neg
id|strchr
c_func
(paren
id|name
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
multiline_comment|/* no slash */
)brace
DECL|function|remote_get
r_struct
id|remote
op_star
id|remote_get
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|remote
op_star
id|ret
suffix:semicolon
r_int
id|name_given
op_assign
l_int|0
suffix:semicolon
id|read_config
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|name
)paren
id|name_given
op_assign
l_int|1
suffix:semicolon
r_else
(brace
id|name
op_assign
id|default_remote_name
suffix:semicolon
id|name_given
op_assign
id|explicit_default_remote_name
suffix:semicolon
)brace
id|ret
op_assign
id|make_remote
c_func
(paren
id|name
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|valid_remote_nick
c_func
(paren
id|name
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|valid_remote
c_func
(paren
id|ret
)paren
)paren
id|read_remotes_file
c_func
(paren
id|ret
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|valid_remote
c_func
(paren
id|ret
)paren
)paren
id|read_branches_file
c_func
(paren
id|ret
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|name_given
op_logical_and
op_logical_neg
id|valid_remote
c_func
(paren
id|ret
)paren
)paren
id|add_url_alias
c_func
(paren
id|ret
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|valid_remote
c_func
(paren
id|ret
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|ret-&gt;fetch
op_assign
id|parse_fetch_refspec
c_func
(paren
id|ret-&gt;fetch_refspec_nr
comma
id|ret-&gt;fetch_refspec
)paren
suffix:semicolon
id|ret-&gt;push
op_assign
id|parse_push_refspec
c_func
(paren
id|ret-&gt;push_refspec_nr
comma
id|ret-&gt;push_refspec
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|remote_is_configured
r_int
id|remote_is_configured
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_int
id|i
suffix:semicolon
id|read_config
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|remotes_nr
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
id|remotes
(braket
id|i
)braket
op_member_access_from_pointer
id|name
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|for_each_remote
r_int
id|for_each_remote
c_func
(paren
id|each_remote_fn
id|fn
comma
r_void
op_star
id|priv
)paren
(brace
r_int
id|i
comma
id|result
op_assign
l_int|0
suffix:semicolon
id|read_config
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|remotes_nr
op_logical_and
op_logical_neg
id|result
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|remote
op_star
id|r
op_assign
id|remotes
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|r
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|r-&gt;fetch
)paren
id|r-&gt;fetch
op_assign
id|parse_fetch_refspec
c_func
(paren
id|r-&gt;fetch_refspec_nr
comma
id|r-&gt;fetch_refspec
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|r-&gt;push
)paren
id|r-&gt;push
op_assign
id|parse_push_refspec
c_func
(paren
id|r-&gt;push_refspec_nr
comma
id|r-&gt;push_refspec
)paren
suffix:semicolon
id|result
op_assign
id|fn
c_func
(paren
id|r
comma
id|priv
)paren
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
DECL|function|ref_remove_duplicates
r_void
id|ref_remove_duplicates
c_func
(paren
r_struct
id|ref
op_star
id|ref_map
)paren
(brace
r_struct
id|string_list
id|refs
op_assign
id|STRING_LIST_INIT_NODUP
suffix:semicolon
r_struct
id|string_list_item
op_star
id|item
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|ref
op_star
id|prev
op_assign
l_int|NULL
comma
op_star
id|next
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|ref_map
suffix:semicolon
id|prev
op_assign
id|ref_map
comma
id|ref_map
op_assign
id|next
)paren
(brace
id|next
op_assign
id|ref_map-&gt;next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ref_map-&gt;peer_ref
)paren
r_continue
suffix:semicolon
id|item
op_assign
id|string_list_lookup
c_func
(paren
op_amp
id|refs
comma
id|ref_map-&gt;peer_ref-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|item
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
(paren
(paren
r_struct
id|ref
op_star
)paren
id|item-&gt;util
)paren
op_member_access_from_pointer
id|name
comma
id|ref_map-&gt;name
)paren
)paren
id|die
c_func
(paren
l_string|&quot;%s tracks both %s and %s&quot;
comma
id|ref_map-&gt;peer_ref-&gt;name
comma
(paren
(paren
r_struct
id|ref
op_star
)paren
id|item-&gt;util
)paren
op_member_access_from_pointer
id|name
comma
id|ref_map-&gt;name
)paren
suffix:semicolon
id|prev-&gt;next
op_assign
id|ref_map-&gt;next
suffix:semicolon
id|free
c_func
(paren
id|ref_map-&gt;peer_ref
)paren
suffix:semicolon
id|free
c_func
(paren
id|ref_map
)paren
suffix:semicolon
id|ref_map
op_assign
id|prev
suffix:semicolon
multiline_comment|/* skip this; we freed it */
r_continue
suffix:semicolon
)brace
id|item
op_assign
id|string_list_insert
c_func
(paren
op_amp
id|refs
comma
id|ref_map-&gt;peer_ref-&gt;name
)paren
suffix:semicolon
id|item-&gt;util
op_assign
id|ref_map
suffix:semicolon
)brace
id|string_list_clear
c_func
(paren
op_amp
id|refs
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|remote_has_url
r_int
id|remote_has_url
c_func
(paren
r_struct
id|remote
op_star
id|remote
comma
r_const
r_char
op_star
id|url
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|remote-&gt;url_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|remote-&gt;url
(braket
id|i
)braket
comma
id|url
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|match_name_with_pattern
r_static
r_int
id|match_name_with_pattern
c_func
(paren
r_const
r_char
op_star
id|key
comma
r_const
r_char
op_star
id|name
comma
r_const
r_char
op_star
id|value
comma
r_char
op_star
op_star
id|result
)paren
(brace
r_const
r_char
op_star
id|kstar
op_assign
id|strchr
c_func
(paren
id|key
comma
l_char|&squot;*&squot;
)paren
suffix:semicolon
r_int
id|klen
suffix:semicolon
r_int
id|ksuffixlen
suffix:semicolon
r_int
id|namelen
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kstar
)paren
id|die
c_func
(paren
l_string|&quot;Key &squot;%s&squot; of pattern had no &squot;*&squot;&quot;
comma
id|key
)paren
suffix:semicolon
id|klen
op_assign
id|kstar
id|key
suffix:semicolon
id|ksuffixlen
op_assign
id|strlen
c_func
(paren
id|kstar
op_plus
l_int|1
)paren
suffix:semicolon
id|namelen
op_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
id|ret
op_assign
op_logical_neg
id|strncmp
c_func
(paren
id|name
comma
id|key
comma
id|klen
)paren
op_logical_and
id|namelen
op_ge
id|klen
op_plus
id|ksuffixlen
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|name
op_plus
id|namelen
id|ksuffixlen
comma
id|kstar
op_plus
l_int|1
comma
id|ksuffixlen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_logical_and
id|value
)paren
(brace
r_const
r_char
op_star
id|vstar
op_assign
id|strchr
c_func
(paren
id|value
comma
l_char|&squot;*&squot;
)paren
suffix:semicolon
r_int
id|vlen
suffix:semicolon
r_int
id|vsuffixlen
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vstar
)paren
id|die
c_func
(paren
l_string|&quot;Value &squot;%s&squot; of pattern has no &squot;*&squot;&quot;
comma
id|value
)paren
suffix:semicolon
id|vlen
op_assign
id|vstar
id|value
suffix:semicolon
id|vsuffixlen
op_assign
id|strlen
c_func
(paren
id|vstar
op_plus
l_int|1
)paren
suffix:semicolon
op_star
id|result
op_assign
id|xmalloc
c_func
(paren
id|vlen
op_plus
id|vsuffixlen
op_plus
id|strlen
c_func
(paren
id|name
)paren
id|klen
id|ksuffixlen
op_plus
l_int|1
)paren
suffix:semicolon
id|strncpy
c_func
(paren
op_star
id|result
comma
id|value
comma
id|vlen
)paren
suffix:semicolon
id|strncpy
c_func
(paren
op_star
id|result
op_plus
id|vlen
comma
id|name
op_plus
id|klen
comma
id|namelen
id|klen
id|ksuffixlen
)paren
suffix:semicolon
id|strcpy
c_func
(paren
op_star
id|result
op_plus
id|vlen
op_plus
id|namelen
id|klen
id|ksuffixlen
comma
id|vstar
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|query_refspecs
r_static
r_int
id|query_refspecs
c_func
(paren
r_struct
id|refspec
op_star
id|refs
comma
r_int
id|ref_count
comma
r_struct
id|refspec
op_star
id|query
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|find_src
op_assign
op_logical_neg
id|query-&gt;src
suffix:semicolon
r_if
c_cond
(paren
id|find_src
op_logical_and
op_logical_neg
id|query-&gt;dst
)paren
r_return
id|error
c_func
(paren
l_string|&quot;query_refspecs: need either src or dst&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ref_count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|refspec
op_star
id|refspec
op_assign
op_amp
id|refs
(braket
id|i
)braket
suffix:semicolon
r_const
r_char
op_star
id|key
op_assign
id|find_src
ques
c_cond
id|refspec-&gt;dst
suffix:colon
id|refspec-&gt;src
suffix:semicolon
r_const
r_char
op_star
id|value
op_assign
id|find_src
ques
c_cond
id|refspec-&gt;src
suffix:colon
id|refspec-&gt;dst
suffix:semicolon
r_const
r_char
op_star
id|needle
op_assign
id|find_src
ques
c_cond
id|query-&gt;dst
suffix:colon
id|query-&gt;src
suffix:semicolon
r_char
op_star
op_star
id|result
op_assign
id|find_src
ques
c_cond
op_amp
id|query-&gt;src
suffix:colon
op_amp
id|query-&gt;dst
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|refspec-&gt;dst
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|refspec-&gt;pattern
)paren
(brace
r_if
c_cond
(paren
id|match_name_with_pattern
c_func
(paren
id|key
comma
id|needle
comma
id|value
comma
id|result
)paren
)paren
(brace
id|query-&gt;force
op_assign
id|refspec-&gt;force
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|needle
comma
id|key
)paren
)paren
(brace
op_star
id|result
op_assign
id|xstrdup
c_func
(paren
id|value
)paren
suffix:semicolon
id|query-&gt;force
op_assign
id|refspec-&gt;force
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|apply_refspecs
r_char
op_star
id|apply_refspecs
c_func
(paren
r_struct
id|refspec
op_star
id|refspecs
comma
r_int
id|nr_refspec
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|refspec
id|query
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|query
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|refspec
)paren
)paren
suffix:semicolon
id|query.src
op_assign
(paren
r_char
op_star
)paren
id|name
suffix:semicolon
r_if
c_cond
(paren
id|query_refspecs
c_func
(paren
id|refspecs
comma
id|nr_refspec
comma
op_amp
id|query
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|query.dst
suffix:semicolon
)brace
DECL|function|remote_find_tracking
r_int
id|remote_find_tracking
c_func
(paren
r_struct
id|remote
op_star
id|remote
comma
r_struct
id|refspec
op_star
id|refspec
)paren
(brace
r_return
id|query_refspecs
c_func
(paren
id|remote-&gt;fetch
comma
id|remote-&gt;fetch_refspec_nr
comma
id|refspec
)paren
suffix:semicolon
)brace
DECL|function|alloc_ref_with_prefix
r_static
r_struct
id|ref
op_star
id|alloc_ref_with_prefix
c_func
(paren
r_const
r_char
op_star
id|prefix
comma
r_int
id|prefixlen
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
r_struct
id|ref
op_star
id|ref
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|ref
)paren
op_plus
id|prefixlen
op_plus
id|len
op_plus
l_int|1
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ref-&gt;name
comma
id|prefix
comma
id|prefixlen
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ref-&gt;name
op_plus
id|prefixlen
comma
id|name
comma
id|len
)paren
suffix:semicolon
r_return
id|ref
suffix:semicolon
)brace
DECL|function|alloc_ref
r_struct
id|ref
op_star
id|alloc_ref
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_return
id|alloc_ref_with_prefix
c_func
(paren
l_string|&quot;&quot;
comma
l_int|0
comma
id|name
)paren
suffix:semicolon
)brace
DECL|function|copy_ref
r_struct
id|ref
op_star
id|copy_ref
c_func
(paren
r_const
r_struct
id|ref
op_star
id|ref
)paren
(brace
r_struct
id|ref
op_star
id|cpy
suffix:semicolon
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ref
)paren
r_return
l_int|NULL
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|ref-&gt;name
)paren
suffix:semicolon
id|cpy
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ref
)paren
op_plus
id|len
op_plus
l_int|1
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|cpy
comma
id|ref
comma
r_sizeof
(paren
r_struct
id|ref
)paren
op_plus
id|len
op_plus
l_int|1
)paren
suffix:semicolon
id|cpy-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|cpy-&gt;symref
op_assign
id|ref-&gt;symref
ques
c_cond
id|xstrdup
c_func
(paren
id|ref-&gt;symref
)paren
suffix:colon
l_int|NULL
suffix:semicolon
id|cpy-&gt;remote_status
op_assign
id|ref-&gt;remote_status
ques
c_cond
id|xstrdup
c_func
(paren
id|ref-&gt;remote_status
)paren
suffix:colon
l_int|NULL
suffix:semicolon
id|cpy-&gt;peer_ref
op_assign
id|copy_ref
c_func
(paren
id|ref-&gt;peer_ref
)paren
suffix:semicolon
r_return
id|cpy
suffix:semicolon
)brace
DECL|function|copy_ref_list
r_struct
id|ref
op_star
id|copy_ref_list
c_func
(paren
r_const
r_struct
id|ref
op_star
id|ref
)paren
(brace
r_struct
id|ref
op_star
id|ret
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|ref
op_star
op_star
id|tail
op_assign
op_amp
id|ret
suffix:semicolon
r_while
c_loop
(paren
id|ref
)paren
(brace
op_star
id|tail
op_assign
id|copy_ref
c_func
(paren
id|ref
)paren
suffix:semicolon
id|ref
op_assign
id|ref-&gt;next
suffix:semicolon
id|tail
op_assign
op_amp
(paren
(paren
op_star
id|tail
)paren
op_member_access_from_pointer
id|next
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|free_ref
r_static
r_void
id|free_ref
c_func
(paren
r_struct
id|ref
op_star
id|ref
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ref
)paren
r_return
suffix:semicolon
id|free_ref
c_func
(paren
id|ref-&gt;peer_ref
)paren
suffix:semicolon
id|free
c_func
(paren
id|ref-&gt;remote_status
)paren
suffix:semicolon
id|free
c_func
(paren
id|ref-&gt;symref
)paren
suffix:semicolon
id|free
c_func
(paren
id|ref
)paren
suffix:semicolon
)brace
DECL|function|free_refs
r_void
id|free_refs
c_func
(paren
r_struct
id|ref
op_star
id|ref
)paren
(brace
r_struct
id|ref
op_star
id|next
suffix:semicolon
r_while
c_loop
(paren
id|ref
)paren
(brace
id|next
op_assign
id|ref-&gt;next
suffix:semicolon
id|free_ref
c_func
(paren
id|ref
)paren
suffix:semicolon
id|ref
op_assign
id|next
suffix:semicolon
)brace
)brace
DECL|function|ref_compare_name
r_int
id|ref_compare_name
c_func
(paren
r_const
r_void
op_star
id|va
comma
r_const
r_void
op_star
id|vb
)paren
(brace
r_const
r_struct
id|ref
op_star
id|a
op_assign
id|va
comma
op_star
id|b
op_assign
id|vb
suffix:semicolon
r_return
id|strcmp
c_func
(paren
id|a-&gt;name
comma
id|b-&gt;name
)paren
suffix:semicolon
)brace
DECL|function|ref_list_get_next
r_static
r_void
op_star
id|ref_list_get_next
c_func
(paren
r_const
r_void
op_star
id|a
)paren
(brace
r_return
(paren
(paren
r_const
r_struct
id|ref
op_star
)paren
id|a
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
)brace
DECL|function|ref_list_set_next
r_static
r_void
id|ref_list_set_next
c_func
(paren
r_void
op_star
id|a
comma
r_void
op_star
id|next
)paren
(brace
(paren
(paren
r_struct
id|ref
op_star
)paren
id|a
)paren
op_member_access_from_pointer
id|next
op_assign
id|next
suffix:semicolon
)brace
DECL|function|sort_ref_list
r_void
id|sort_ref_list
c_func
(paren
r_struct
id|ref
op_star
op_star
id|l
comma
r_int
(paren
op_star
id|cmp
)paren
(paren
r_const
r_void
op_star
comma
r_const
r_void
op_star
)paren
)paren
(brace
op_star
id|l
op_assign
id|llist_mergesort
c_func
(paren
op_star
id|l
comma
id|ref_list_get_next
comma
id|ref_list_set_next
comma
id|cmp
)paren
suffix:semicolon
)brace
DECL|function|count_refspec_match
r_static
r_int
id|count_refspec_match
c_func
(paren
r_const
r_char
op_star
id|pattern
comma
r_struct
id|ref
op_star
id|refs
comma
r_struct
id|ref
op_star
op_star
id|matched_ref
)paren
(brace
r_int
id|patlen
op_assign
id|strlen
c_func
(paren
id|pattern
)paren
suffix:semicolon
r_struct
id|ref
op_star
id|matched_weak
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|ref
op_star
id|matched
op_assign
l_int|NULL
suffix:semicolon
r_int
id|weak_match
op_assign
l_int|0
suffix:semicolon
r_int
id|match
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|weak_match
op_assign
id|match
op_assign
l_int|0
suffix:semicolon
id|refs
suffix:semicolon
id|refs
op_assign
id|refs-&gt;next
)paren
(brace
r_char
op_star
id|name
op_assign
id|refs-&gt;name
suffix:semicolon
r_int
id|namelen
op_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|refname_match
c_func
(paren
id|pattern
comma
id|name
comma
id|ref_rev_parse_rules
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* A match is &quot;weak&quot; if it is with refs outside&n;&t;&t; * heads or tags, and did not specify the pattern&n;&t;&t; * in full (e.g. &quot;refs/remotes/origin/master&quot;) or at&n;&t;&t; * least from the toplevel (e.g. &quot;remotes/origin/master&quot;);&n;&t;&t; * otherwise &quot;git push $URL master&quot; would result in&n;&t;&t; * ambiguity between remotes/origin/master and heads/master&n;&t;&t; * at the remote site.&n;&t;&t; */
r_if
c_cond
(paren
id|namelen
op_ne
id|patlen
op_logical_and
id|patlen
op_ne
id|namelen
l_int|5
op_logical_and
id|prefixcmp
c_func
(paren
id|name
comma
l_string|&quot;refs/heads/&quot;
)paren
op_logical_and
id|prefixcmp
c_func
(paren
id|name
comma
l_string|&quot;refs/tags/&quot;
)paren
)paren
(brace
multiline_comment|/* We want to catch the case where only weak&n;&t;&t;&t; * matches are found and there are multiple&n;&t;&t;&t; * matches, and where more than one strong&n;&t;&t;&t; * matches are found, as ambiguous.  One&n;&t;&t;&t; * strong match with zero or more weak matches&n;&t;&t;&t; * are acceptable as a unique match.&n;&t;&t;&t; */
id|matched_weak
op_assign
id|refs
suffix:semicolon
id|weak_match
op_increment
suffix:semicolon
)brace
r_else
(brace
id|matched
op_assign
id|refs
suffix:semicolon
id|match
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|matched
)paren
(brace
op_star
id|matched_ref
op_assign
id|matched_weak
suffix:semicolon
r_return
id|weak_match
suffix:semicolon
)brace
r_else
(brace
op_star
id|matched_ref
op_assign
id|matched
suffix:semicolon
r_return
id|match
suffix:semicolon
)brace
)brace
DECL|function|tail_link_ref
r_static
r_void
id|tail_link_ref
c_func
(paren
r_struct
id|ref
op_star
id|ref
comma
r_struct
id|ref
op_star
op_star
op_star
id|tail
)paren
(brace
op_star
op_star
id|tail
op_assign
id|ref
suffix:semicolon
r_while
c_loop
(paren
id|ref-&gt;next
)paren
id|ref
op_assign
id|ref-&gt;next
suffix:semicolon
op_star
id|tail
op_assign
op_amp
id|ref-&gt;next
suffix:semicolon
)brace
DECL|function|alloc_delete_ref
r_static
r_struct
id|ref
op_star
id|alloc_delete_ref
c_func
(paren
r_void
)paren
(brace
r_struct
id|ref
op_star
id|ref
op_assign
id|alloc_ref
c_func
(paren
l_string|&quot;(delete)&quot;
)paren
suffix:semicolon
id|hashclr
c_func
(paren
id|ref-&gt;new_sha1
)paren
suffix:semicolon
r_return
id|ref
suffix:semicolon
)brace
DECL|function|try_explicit_object_name
r_static
r_struct
id|ref
op_star
id|try_explicit_object_name
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_struct
id|ref
op_star
id|ref
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|name
)paren
r_return
id|alloc_delete_ref
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1
c_func
(paren
id|name
comma
id|sha1
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|ref
op_assign
id|alloc_ref
c_func
(paren
id|name
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|ref-&gt;new_sha1
comma
id|sha1
)paren
suffix:semicolon
r_return
id|ref
suffix:semicolon
)brace
DECL|function|make_linked_ref
r_static
r_struct
id|ref
op_star
id|make_linked_ref
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_struct
id|ref
op_star
op_star
op_star
id|tail
)paren
(brace
r_struct
id|ref
op_star
id|ret
op_assign
id|alloc_ref
c_func
(paren
id|name
)paren
suffix:semicolon
id|tail_link_ref
c_func
(paren
id|ret
comma
id|tail
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|guess_ref
r_static
r_char
op_star
id|guess_ref
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_struct
id|ref
op_star
id|peer
)paren
(brace
r_struct
id|strbuf
id|buf
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_const
r_char
op_star
id|r
op_assign
id|resolve_ref_unsafe
c_func
(paren
id|peer-&gt;name
comma
id|sha1
comma
l_int|1
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|r
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|r
comma
l_string|&quot;refs/heads/&quot;
)paren
)paren
id|strbuf_addstr
c_func
(paren
op_amp
id|buf
comma
l_string|&quot;refs/heads/&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|r
comma
l_string|&quot;refs/tags/&quot;
)paren
)paren
id|strbuf_addstr
c_func
(paren
op_amp
id|buf
comma
l_string|&quot;refs/tags/&quot;
)paren
suffix:semicolon
r_else
r_return
l_int|NULL
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|buf
comma
id|name
)paren
suffix:semicolon
r_return
id|strbuf_detach
c_func
(paren
op_amp
id|buf
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|match_explicit
r_static
r_int
id|match_explicit
c_func
(paren
r_struct
id|ref
op_star
id|src
comma
r_struct
id|ref
op_star
id|dst
comma
r_struct
id|ref
op_star
op_star
op_star
id|dst_tail
comma
r_struct
id|refspec
op_star
id|rs
)paren
(brace
r_struct
id|ref
op_star
id|matched_src
comma
op_star
id|matched_dst
suffix:semicolon
r_int
id|copy_src
suffix:semicolon
r_const
r_char
op_star
id|dst_value
op_assign
id|rs-&gt;dst
suffix:semicolon
r_char
op_star
id|dst_guess
suffix:semicolon
r_if
c_cond
(paren
id|rs-&gt;pattern
op_logical_or
id|rs-&gt;matching
)paren
r_return
l_int|0
suffix:semicolon
id|matched_src
op_assign
id|matched_dst
op_assign
l_int|NULL
suffix:semicolon
r_switch
c_cond
(paren
id|count_refspec_match
c_func
(paren
id|rs-&gt;src
comma
id|src
comma
op_amp
id|matched_src
)paren
)paren
(brace
r_case
l_int|1
suffix:colon
id|copy_src
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
multiline_comment|/* The source could be in the get_sha1() format&n;&t;&t; * not a reference name.  :refs/other is a&n;&t;&t; * way to delete &squot;other&squot; ref at the remote end.&n;&t;&t; */
id|matched_src
op_assign
id|try_explicit_object_name
c_func
(paren
id|rs-&gt;src
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|matched_src
)paren
r_return
id|error
c_func
(paren
l_string|&quot;src refspec %s does not match any.&quot;
comma
id|rs-&gt;src
)paren
suffix:semicolon
id|copy_src
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
id|error
c_func
(paren
l_string|&quot;src refspec %s matches more than one.&quot;
comma
id|rs-&gt;src
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|dst_value
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_int
id|flag
suffix:semicolon
id|dst_value
op_assign
id|resolve_ref_unsafe
c_func
(paren
id|matched_src-&gt;name
comma
id|sha1
comma
l_int|1
comma
op_amp
id|flag
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dst_value
op_logical_or
(paren
(paren
id|flag
op_amp
id|REF_ISSYMREF
)paren
op_logical_and
id|prefixcmp
c_func
(paren
id|dst_value
comma
l_string|&quot;refs/heads/&quot;
)paren
)paren
)paren
id|die
c_func
(paren
l_string|&quot;%s cannot be resolved to branch.&quot;
comma
id|matched_src-&gt;name
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|count_refspec_match
c_func
(paren
id|dst_value
comma
id|dst
comma
op_amp
id|matched_dst
)paren
)paren
(brace
r_case
l_int|1
suffix:colon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|dst_value
comma
l_string|&quot;refs/&quot;
comma
l_int|5
)paren
)paren
id|matched_dst
op_assign
id|make_linked_ref
c_func
(paren
id|dst_value
comma
id|dst_tail
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|is_null_sha1
c_func
(paren
id|matched_src-&gt;new_sha1
)paren
)paren
id|error
c_func
(paren
l_string|&quot;unable to delete &squot;%s&squot;: remote ref does not exist&quot;
comma
id|dst_value
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|dst_guess
op_assign
id|guess_ref
c_func
(paren
id|dst_value
comma
id|matched_src
)paren
)paren
)paren
id|matched_dst
op_assign
id|make_linked_ref
c_func
(paren
id|dst_guess
comma
id|dst_tail
)paren
suffix:semicolon
r_else
id|error
c_func
(paren
l_string|&quot;unable to push to unqualified destination: %s&bslash;n&quot;
l_string|&quot;The destination refspec neither matches an &quot;
l_string|&quot;existing ref on the remote nor&bslash;n&quot;
l_string|&quot;begins with refs/, and we are unable to &quot;
l_string|&quot;guess a prefix based on the source ref.&quot;
comma
id|dst_value
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|matched_dst
op_assign
l_int|NULL
suffix:semicolon
id|error
c_func
(paren
l_string|&quot;dst refspec %s matches more than one.&quot;
comma
id|dst_value
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|matched_dst
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|matched_dst-&gt;peer_ref
)paren
r_return
id|error
c_func
(paren
l_string|&quot;dst ref %s receives from more than one src.&quot;
comma
id|matched_dst-&gt;name
)paren
suffix:semicolon
r_else
(brace
id|matched_dst-&gt;peer_ref
op_assign
id|copy_src
ques
c_cond
id|copy_ref
c_func
(paren
id|matched_src
)paren
suffix:colon
id|matched_src
suffix:semicolon
id|matched_dst-&gt;force
op_assign
id|rs-&gt;force
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|match_explicit_refs
r_static
r_int
id|match_explicit_refs
c_func
(paren
r_struct
id|ref
op_star
id|src
comma
r_struct
id|ref
op_star
id|dst
comma
r_struct
id|ref
op_star
op_star
op_star
id|dst_tail
comma
r_struct
id|refspec
op_star
id|rs
comma
r_int
id|rs_nr
)paren
(brace
r_int
id|i
comma
id|errs
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|errs
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|rs_nr
suffix:semicolon
id|i
op_increment
)paren
id|errs
op_add_assign
id|match_explicit
c_func
(paren
id|src
comma
id|dst
comma
id|dst_tail
comma
op_amp
id|rs
(braket
id|i
)braket
)paren
suffix:semicolon
r_return
id|errs
suffix:semicolon
)brace
DECL|function|get_ref_match
r_static
r_char
op_star
id|get_ref_match
c_func
(paren
r_const
r_struct
id|refspec
op_star
id|rs
comma
r_int
id|rs_nr
comma
r_const
r_struct
id|ref
op_star
id|ref
comma
r_int
id|send_mirror
comma
r_int
id|direction
comma
r_const
r_struct
id|refspec
op_star
op_star
id|ret_pat
)paren
(brace
r_const
r_struct
id|refspec
op_star
id|pat
suffix:semicolon
r_char
op_star
id|name
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|matching_refs
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|rs_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|rs
(braket
id|i
)braket
dot
id|matching
op_logical_and
(paren
id|matching_refs
op_eq
l_int|1
op_logical_or
id|rs
(braket
id|i
)braket
dot
id|force
)paren
)paren
(brace
id|matching_refs
op_assign
id|i
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rs
(braket
id|i
)braket
dot
id|pattern
)paren
(brace
r_const
r_char
op_star
id|dst_side
op_assign
id|rs
(braket
id|i
)braket
dot
id|dst
ques
c_cond
id|rs
(braket
id|i
)braket
dot
id|dst
suffix:colon
id|rs
(braket
id|i
)braket
dot
id|src
suffix:semicolon
r_int
id|match
suffix:semicolon
r_if
c_cond
(paren
id|direction
op_eq
id|FROM_SRC
)paren
id|match
op_assign
id|match_name_with_pattern
c_func
(paren
id|rs
(braket
id|i
)braket
dot
id|src
comma
id|ref-&gt;name
comma
id|dst_side
comma
op_amp
id|name
)paren
suffix:semicolon
r_else
id|match
op_assign
id|match_name_with_pattern
c_func
(paren
id|dst_side
comma
id|ref-&gt;name
comma
id|rs
(braket
id|i
)braket
dot
id|src
comma
op_amp
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|match
)paren
(brace
id|matching_refs
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|matching_refs
op_eq
l_int|1
)paren
r_return
l_int|NULL
suffix:semicolon
id|pat
op_assign
id|rs
op_plus
id|matching_refs
suffix:semicolon
r_if
c_cond
(paren
id|pat-&gt;matching
)paren
(brace
multiline_comment|/*&n;&t;&t; * &quot;matching refs&quot;; traditionally we pushed everything&n;&t;&t; * including refs outside refs/heads/ hierarchy, but&n;&t;&t; * that does not make much sense these days.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|send_mirror
op_logical_and
id|prefixcmp
c_func
(paren
id|ref-&gt;name
comma
l_string|&quot;refs/heads/&quot;
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|name
op_assign
id|xstrdup
c_func
(paren
id|ref-&gt;name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret_pat
)paren
op_star
id|ret_pat
op_assign
id|pat
suffix:semicolon
r_return
id|name
suffix:semicolon
)brace
DECL|function|tail_ref
r_static
r_struct
id|ref
op_star
op_star
id|tail_ref
c_func
(paren
r_struct
id|ref
op_star
op_star
id|head
)paren
(brace
r_struct
id|ref
op_star
op_star
id|tail
op_assign
id|head
suffix:semicolon
r_while
c_loop
(paren
op_star
id|tail
)paren
id|tail
op_assign
op_amp
(paren
(paren
op_star
id|tail
)paren
op_member_access_from_pointer
id|next
)paren
suffix:semicolon
r_return
id|tail
suffix:semicolon
)brace
multiline_comment|/*&n; * Given the set of refs the local repository has, the set of refs the&n; * remote repository has, and the refspec used for push, determine&n; * what remote refs we will update and with what value by setting&n; * peer_ref (which object is being pushed) and force (if the push is&n; * forced) in elements of &quot;dst&quot;. The function may add new elements to&n; * dst (e.g. pushing to a new branch, done in match_explicit_refs).&n; */
DECL|function|match_push_refs
r_int
id|match_push_refs
c_func
(paren
r_struct
id|ref
op_star
id|src
comma
r_struct
id|ref
op_star
op_star
id|dst
comma
r_int
id|nr_refspec
comma
r_const
r_char
op_star
op_star
id|refspec
comma
r_int
id|flags
)paren
(brace
r_struct
id|refspec
op_star
id|rs
suffix:semicolon
r_int
id|send_all
op_assign
id|flags
op_amp
id|MATCH_REFS_ALL
suffix:semicolon
r_int
id|send_mirror
op_assign
id|flags
op_amp
id|MATCH_REFS_MIRROR
suffix:semicolon
r_int
id|send_prune
op_assign
id|flags
op_amp
id|MATCH_REFS_PRUNE
suffix:semicolon
r_int
id|errs
suffix:semicolon
r_static
r_const
r_char
op_star
id|default_refspec
(braket
)braket
op_assign
(brace
l_string|&quot;:&quot;
comma
l_int|NULL
)brace
suffix:semicolon
r_struct
id|ref
op_star
id|ref
comma
op_star
op_star
id|dst_tail
op_assign
id|tail_ref
c_func
(paren
id|dst
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nr_refspec
)paren
(brace
id|nr_refspec
op_assign
l_int|1
suffix:semicolon
id|refspec
op_assign
id|default_refspec
suffix:semicolon
)brace
id|rs
op_assign
id|parse_push_refspec
c_func
(paren
id|nr_refspec
comma
(paren
r_const
r_char
op_star
op_star
)paren
id|refspec
)paren
suffix:semicolon
id|errs
op_assign
id|match_explicit_refs
c_func
(paren
id|src
comma
op_star
id|dst
comma
op_amp
id|dst_tail
comma
id|rs
comma
id|nr_refspec
)paren
suffix:semicolon
multiline_comment|/* pick the remainder */
r_for
c_loop
(paren
id|ref
op_assign
id|src
suffix:semicolon
id|ref
suffix:semicolon
id|ref
op_assign
id|ref-&gt;next
)paren
(brace
r_struct
id|ref
op_star
id|dst_peer
suffix:semicolon
r_const
r_struct
id|refspec
op_star
id|pat
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
id|dst_name
suffix:semicolon
id|dst_name
op_assign
id|get_ref_match
c_func
(paren
id|rs
comma
id|nr_refspec
comma
id|ref
comma
id|send_mirror
comma
id|FROM_SRC
comma
op_amp
id|pat
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dst_name
)paren
r_continue
suffix:semicolon
id|dst_peer
op_assign
id|find_ref_by_name
c_func
(paren
op_star
id|dst
comma
id|dst_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dst_peer
)paren
(brace
r_if
c_cond
(paren
id|dst_peer-&gt;peer_ref
)paren
multiline_comment|/* We&squot;re already sending something to this ref. */
r_goto
id|free_name
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|pat-&gt;matching
op_logical_and
op_logical_neg
(paren
id|send_all
op_logical_or
id|send_mirror
)paren
)paren
multiline_comment|/*&n;&t;&t;&t;&t; * Remote doesn&squot;t have it, and we have no&n;&t;&t;&t;&t; * explicit pattern, and we don&squot;t have&n;&t;&t;&t;&t; * --all nor --mirror.&n;&t;&t;&t;&t; */
r_goto
id|free_name
suffix:semicolon
multiline_comment|/* Create a new one and link it */
id|dst_peer
op_assign
id|make_linked_ref
c_func
(paren
id|dst_name
comma
op_amp
id|dst_tail
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|dst_peer-&gt;new_sha1
comma
id|ref-&gt;new_sha1
)paren
suffix:semicolon
)brace
id|dst_peer-&gt;peer_ref
op_assign
id|copy_ref
c_func
(paren
id|ref
)paren
suffix:semicolon
id|dst_peer-&gt;force
op_assign
id|pat-&gt;force
suffix:semicolon
id|free_name
suffix:colon
id|free
c_func
(paren
id|dst_name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|send_prune
)paren
(brace
multiline_comment|/* check for missing refs on the remote */
r_for
c_loop
(paren
id|ref
op_assign
op_star
id|dst
suffix:semicolon
id|ref
suffix:semicolon
id|ref
op_assign
id|ref-&gt;next
)paren
(brace
r_char
op_star
id|src_name
suffix:semicolon
r_if
c_cond
(paren
id|ref-&gt;peer_ref
)paren
multiline_comment|/* We&squot;re already sending something to this ref. */
r_continue
suffix:semicolon
id|src_name
op_assign
id|get_ref_match
c_func
(paren
id|rs
comma
id|nr_refspec
comma
id|ref
comma
id|send_mirror
comma
id|FROM_DST
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|src_name
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|find_ref_by_name
c_func
(paren
id|src
comma
id|src_name
)paren
)paren
id|ref-&gt;peer_ref
op_assign
id|alloc_delete_ref
c_func
(paren
)paren
suffix:semicolon
id|free
c_func
(paren
id|src_name
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|errs
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|set_ref_status_for_push
r_void
id|set_ref_status_for_push
c_func
(paren
r_struct
id|ref
op_star
id|remote_refs
comma
r_int
id|send_mirror
comma
r_int
id|force_update
)paren
(brace
r_struct
id|ref
op_star
id|ref
suffix:semicolon
r_for
c_loop
(paren
id|ref
op_assign
id|remote_refs
suffix:semicolon
id|ref
suffix:semicolon
id|ref
op_assign
id|ref-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|ref-&gt;peer_ref
)paren
id|hashcpy
c_func
(paren
id|ref-&gt;new_sha1
comma
id|ref-&gt;peer_ref-&gt;new_sha1
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|send_mirror
)paren
r_continue
suffix:semicolon
id|ref-&gt;deletion
op_assign
id|is_null_sha1
c_func
(paren
id|ref-&gt;new_sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ref-&gt;deletion
op_logical_and
op_logical_neg
id|hashcmp
c_func
(paren
id|ref-&gt;old_sha1
comma
id|ref-&gt;new_sha1
)paren
)paren
(brace
id|ref-&gt;status
op_assign
id|REF_STATUS_UPTODATE
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* This part determines what can overwrite what.&n;&t;&t; * The rules are:&n;&t;&t; *&n;&t;&t; * (0) you can always use --force or +A:B notation to&n;&t;&t; *     selectively force individual ref pairs.&n;&t;&t; *&n;&t;&t; * (1) if the old thing does not exist, it is OK.&n;&t;&t; *&n;&t;&t; * (2) if you do not have the old thing, you are not allowed&n;&t;&t; *     to overwrite it; you would not know what you are losing&n;&t;&t; *     otherwise.&n;&t;&t; *&n;&t;&t; * (3) if both new and old are commit-ish, and new is a&n;&t;&t; *     descendant of old, it is OK.&n;&t;&t; *&n;&t;&t; * (4) regardless of all of the above, removing :B is&n;&t;&t; *     always allowed.&n;&t;&t; */
id|ref-&gt;nonfastforward
op_assign
op_logical_neg
id|ref-&gt;deletion
op_logical_and
op_logical_neg
id|is_null_sha1
c_func
(paren
id|ref-&gt;old_sha1
)paren
op_logical_and
(paren
op_logical_neg
id|has_sha1_file
c_func
(paren
id|ref-&gt;old_sha1
)paren
op_logical_or
op_logical_neg
id|ref_newer
c_func
(paren
id|ref-&gt;new_sha1
comma
id|ref-&gt;old_sha1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ref-&gt;nonfastforward
op_logical_and
op_logical_neg
id|ref-&gt;force
op_logical_and
op_logical_neg
id|force_update
)paren
(brace
id|ref-&gt;status
op_assign
id|REF_STATUS_REJECT_NONFASTFORWARD
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
)brace
DECL|function|branch_get
r_struct
id|branch
op_star
id|branch_get
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|branch
op_star
id|ret
suffix:semicolon
id|read_config
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|name
op_logical_or
op_logical_neg
op_star
id|name
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;HEAD&quot;
)paren
)paren
id|ret
op_assign
id|current_branch
suffix:semicolon
r_else
id|ret
op_assign
id|make_branch
c_func
(paren
id|name
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_logical_and
id|ret-&gt;remote_name
)paren
(brace
id|ret-&gt;remote
op_assign
id|remote_get
c_func
(paren
id|ret-&gt;remote_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret-&gt;merge_nr
)paren
(brace
r_int
id|i
suffix:semicolon
id|ret-&gt;merge
op_assign
id|xcalloc
c_func
(paren
r_sizeof
(paren
op_star
id|ret-&gt;merge
)paren
comma
id|ret-&gt;merge_nr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ret-&gt;merge_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ret-&gt;merge
(braket
id|i
)braket
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
op_star
id|ret-&gt;merge
)paren
)paren
suffix:semicolon
id|ret-&gt;merge
(braket
id|i
)braket
op_member_access_from_pointer
id|src
op_assign
id|xstrdup
c_func
(paren
id|ret-&gt;merge_name
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|remote_find_tracking
c_func
(paren
id|ret-&gt;remote
comma
id|ret-&gt;merge
(braket
id|i
)braket
)paren
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|ret-&gt;remote_name
comma
l_string|&quot;.&quot;
)paren
)paren
id|ret-&gt;merge
(braket
id|i
)braket
op_member_access_from_pointer
id|dst
op_assign
id|xstrdup
c_func
(paren
id|ret-&gt;merge_name
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|branch_has_merge_config
r_int
id|branch_has_merge_config
c_func
(paren
r_struct
id|branch
op_star
id|branch
)paren
(brace
r_return
id|branch
op_logical_and
op_logical_neg
op_logical_neg
id|branch-&gt;merge
suffix:semicolon
)brace
DECL|function|branch_merge_matches
r_int
id|branch_merge_matches
c_func
(paren
r_struct
id|branch
op_star
id|branch
comma
r_int
id|i
comma
r_const
r_char
op_star
id|refname
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|branch
op_logical_or
id|i
OL
l_int|0
op_logical_or
id|i
op_ge
id|branch-&gt;merge_nr
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|refname_match
c_func
(paren
id|branch-&gt;merge
(braket
id|i
)braket
op_member_access_from_pointer
id|src
comma
id|refname
comma
id|ref_fetch_rules
)paren
suffix:semicolon
)brace
DECL|function|ignore_symref_update
r_static
r_int
id|ignore_symref_update
c_func
(paren
r_const
r_char
op_star
id|refname
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_int
id|flag
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|resolve_ref_unsafe
c_func
(paren
id|refname
comma
id|sha1
comma
l_int|0
comma
op_amp
id|flag
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* non-existing refs are OK */
r_return
(paren
id|flag
op_amp
id|REF_ISSYMREF
)paren
suffix:semicolon
)brace
DECL|function|get_expanded_map
r_static
r_struct
id|ref
op_star
id|get_expanded_map
c_func
(paren
r_const
r_struct
id|ref
op_star
id|remote_refs
comma
r_const
r_struct
id|refspec
op_star
id|refspec
)paren
(brace
r_const
r_struct
id|ref
op_star
id|ref
suffix:semicolon
r_struct
id|ref
op_star
id|ret
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|ref
op_star
op_star
id|tail
op_assign
op_amp
id|ret
suffix:semicolon
r_char
op_star
id|expn_name
suffix:semicolon
r_for
c_loop
(paren
id|ref
op_assign
id|remote_refs
suffix:semicolon
id|ref
suffix:semicolon
id|ref
op_assign
id|ref-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|strchr
c_func
(paren
id|ref-&gt;name
comma
l_char|&squot;^&squot;
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* a dereference item */
r_if
c_cond
(paren
id|match_name_with_pattern
c_func
(paren
id|refspec-&gt;src
comma
id|ref-&gt;name
comma
id|refspec-&gt;dst
comma
op_amp
id|expn_name
)paren
op_logical_and
op_logical_neg
id|ignore_symref_update
c_func
(paren
id|expn_name
)paren
)paren
(brace
r_struct
id|ref
op_star
id|cpy
op_assign
id|copy_ref
c_func
(paren
id|ref
)paren
suffix:semicolon
id|cpy-&gt;peer_ref
op_assign
id|alloc_ref
c_func
(paren
id|expn_name
)paren
suffix:semicolon
id|free
c_func
(paren
id|expn_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|refspec-&gt;force
)paren
id|cpy-&gt;peer_ref-&gt;force
op_assign
l_int|1
suffix:semicolon
op_star
id|tail
op_assign
id|cpy
suffix:semicolon
id|tail
op_assign
op_amp
id|cpy-&gt;next
suffix:semicolon
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|find_ref_by_name_abbrev
r_static
r_const
r_struct
id|ref
op_star
id|find_ref_by_name_abbrev
c_func
(paren
r_const
r_struct
id|ref
op_star
id|refs
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_const
r_struct
id|ref
op_star
id|ref
suffix:semicolon
r_for
c_loop
(paren
id|ref
op_assign
id|refs
suffix:semicolon
id|ref
suffix:semicolon
id|ref
op_assign
id|ref-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|refname_match
c_func
(paren
id|name
comma
id|ref-&gt;name
comma
id|ref_fetch_rules
)paren
)paren
r_return
id|ref
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|get_remote_ref
r_struct
id|ref
op_star
id|get_remote_ref
c_func
(paren
r_const
r_struct
id|ref
op_star
id|remote_refs
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_const
r_struct
id|ref
op_star
id|ref
op_assign
id|find_ref_by_name_abbrev
c_func
(paren
id|remote_refs
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ref
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|copy_ref
c_func
(paren
id|ref
)paren
suffix:semicolon
)brace
DECL|function|get_local_ref
r_static
r_struct
id|ref
op_star
id|get_local_ref
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|name
op_logical_or
id|name
(braket
l_int|0
)braket
op_eq
l_char|&squot;&bslash;0&squot;
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|name
comma
l_string|&quot;refs/&quot;
)paren
)paren
r_return
id|alloc_ref
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|name
comma
l_string|&quot;heads/&quot;
)paren
op_logical_or
op_logical_neg
id|prefixcmp
c_func
(paren
id|name
comma
l_string|&quot;tags/&quot;
)paren
op_logical_or
op_logical_neg
id|prefixcmp
c_func
(paren
id|name
comma
l_string|&quot;remotes/&quot;
)paren
)paren
r_return
id|alloc_ref_with_prefix
c_func
(paren
l_string|&quot;refs/&quot;
comma
l_int|5
comma
id|name
)paren
suffix:semicolon
r_return
id|alloc_ref_with_prefix
c_func
(paren
l_string|&quot;refs/heads/&quot;
comma
l_int|11
comma
id|name
)paren
suffix:semicolon
)brace
DECL|function|get_fetch_map
r_int
id|get_fetch_map
c_func
(paren
r_const
r_struct
id|ref
op_star
id|remote_refs
comma
r_const
r_struct
id|refspec
op_star
id|refspec
comma
r_struct
id|ref
op_star
op_star
op_star
id|tail
comma
r_int
id|missing_ok
)paren
(brace
r_struct
id|ref
op_star
id|ref_map
comma
op_star
op_star
id|rmp
suffix:semicolon
r_if
c_cond
(paren
id|refspec-&gt;pattern
)paren
(brace
id|ref_map
op_assign
id|get_expanded_map
c_func
(paren
id|remote_refs
comma
id|refspec
)paren
suffix:semicolon
)brace
r_else
(brace
r_const
r_char
op_star
id|name
op_assign
id|refspec-&gt;src
(braket
l_int|0
)braket
ques
c_cond
id|refspec-&gt;src
suffix:colon
l_string|&quot;HEAD&quot;
suffix:semicolon
id|ref_map
op_assign
id|get_remote_ref
c_func
(paren
id|remote_refs
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|missing_ok
op_logical_and
op_logical_neg
id|ref_map
)paren
id|die
c_func
(paren
l_string|&quot;Couldn&squot;t find remote ref %s&quot;
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ref_map
)paren
(brace
id|ref_map-&gt;peer_ref
op_assign
id|get_local_ref
c_func
(paren
id|refspec-&gt;dst
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ref_map-&gt;peer_ref
op_logical_and
id|refspec-&gt;force
)paren
id|ref_map-&gt;peer_ref-&gt;force
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|rmp
op_assign
op_amp
id|ref_map
suffix:semicolon
op_star
id|rmp
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
(paren
op_star
id|rmp
)paren
op_member_access_from_pointer
id|peer_ref
)paren
(brace
r_if
c_cond
(paren
id|prefixcmp
c_func
(paren
(paren
op_star
id|rmp
)paren
op_member_access_from_pointer
id|peer_ref-&gt;name
comma
l_string|&quot;refs/&quot;
)paren
op_logical_or
id|check_refname_format
c_func
(paren
(paren
op_star
id|rmp
)paren
op_member_access_from_pointer
id|peer_ref-&gt;name
comma
l_int|0
)paren
)paren
(brace
r_struct
id|ref
op_star
id|ignore
op_assign
op_star
id|rmp
suffix:semicolon
id|error
c_func
(paren
l_string|&quot;* Ignoring funny ref &squot;%s&squot; locally&quot;
comma
(paren
op_star
id|rmp
)paren
op_member_access_from_pointer
id|peer_ref-&gt;name
)paren
suffix:semicolon
op_star
id|rmp
op_assign
(paren
op_star
id|rmp
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
id|free
c_func
(paren
id|ignore-&gt;peer_ref
)paren
suffix:semicolon
id|free
c_func
(paren
id|ignore
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
id|rmp
op_assign
op_amp
(paren
(paren
op_star
id|rmp
)paren
op_member_access_from_pointer
id|next
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ref_map
)paren
id|tail_link_ref
c_func
(paren
id|ref_map
comma
id|tail
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|resolve_remote_symref
r_int
id|resolve_remote_symref
c_func
(paren
r_struct
id|ref
op_star
id|ref
comma
r_struct
id|ref
op_star
id|list
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ref-&gt;symref
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|list
suffix:semicolon
id|list
op_assign
id|list-&gt;next
)paren
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|ref-&gt;symref
comma
id|list-&gt;name
)paren
)paren
(brace
id|hashcpy
c_func
(paren
id|ref-&gt;old_sha1
comma
id|list-&gt;old_sha1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|unmark_and_free
r_static
r_void
id|unmark_and_free
c_func
(paren
r_struct
id|commit_list
op_star
id|list
comma
r_int
r_int
id|mark
)paren
(brace
r_while
c_loop
(paren
id|list
)paren
(brace
r_struct
id|commit_list
op_star
id|temp
op_assign
id|list
suffix:semicolon
id|temp-&gt;item-&gt;object.flags
op_and_assign
op_complement
id|mark
suffix:semicolon
id|list
op_assign
id|temp-&gt;next
suffix:semicolon
id|free
c_func
(paren
id|temp
)paren
suffix:semicolon
)brace
)brace
DECL|function|ref_newer
r_int
id|ref_newer
c_func
(paren
r_const
r_int
r_char
op_star
id|new_sha1
comma
r_const
r_int
r_char
op_star
id|old_sha1
)paren
(brace
r_struct
id|object
op_star
id|o
suffix:semicolon
r_struct
id|commit
op_star
id|old
comma
op_star
r_new
suffix:semicolon
r_struct
id|commit_list
op_star
id|list
comma
op_star
id|used
suffix:semicolon
r_int
id|found
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Both new and old must be commit-ish and new is descendant of&n;&t; * old.  Otherwise we require --force.&n;&t; */
id|o
op_assign
id|deref_tag
c_func
(paren
id|parse_object
c_func
(paren
id|old_sha1
)paren
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|o
op_logical_or
id|o-&gt;type
op_ne
id|OBJ_COMMIT
)paren
r_return
l_int|0
suffix:semicolon
id|old
op_assign
(paren
r_struct
id|commit
op_star
)paren
id|o
suffix:semicolon
id|o
op_assign
id|deref_tag
c_func
(paren
id|parse_object
c_func
(paren
id|new_sha1
)paren
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|o
op_logical_or
id|o-&gt;type
op_ne
id|OBJ_COMMIT
)paren
r_return
l_int|0
suffix:semicolon
r_new
op_assign
(paren
r_struct
id|commit
op_star
)paren
id|o
suffix:semicolon
r_if
c_cond
(paren
id|parse_commit
c_func
(paren
r_new
)paren
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|used
op_assign
id|list
op_assign
l_int|NULL
suffix:semicolon
id|commit_list_insert
c_func
(paren
r_new
comma
op_amp
id|list
)paren
suffix:semicolon
r_while
c_loop
(paren
id|list
)paren
(brace
r_new
op_assign
id|pop_most_recent_commit
c_func
(paren
op_amp
id|list
comma
id|TMP_MARK
)paren
suffix:semicolon
id|commit_list_insert
c_func
(paren
r_new
comma
op_amp
id|used
)paren
suffix:semicolon
r_if
c_cond
(paren
r_new
op_eq
id|old
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|unmark_and_free
c_func
(paren
id|list
comma
id|TMP_MARK
)paren
suffix:semicolon
id|unmark_and_free
c_func
(paren
id|used
comma
id|TMP_MARK
)paren
suffix:semicolon
r_return
id|found
suffix:semicolon
)brace
multiline_comment|/*&n; * Return true if there is anything to report, otherwise false.&n; */
DECL|function|stat_tracking_info
r_int
id|stat_tracking_info
c_func
(paren
r_struct
id|branch
op_star
id|branch
comma
r_int
op_star
id|num_ours
comma
r_int
op_star
id|num_theirs
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_struct
id|commit
op_star
id|ours
comma
op_star
id|theirs
suffix:semicolon
r_char
id|symmetric
(braket
l_int|84
)braket
suffix:semicolon
r_struct
id|rev_info
id|revs
suffix:semicolon
r_const
r_char
op_star
id|rev_argv
(braket
l_int|10
)braket
comma
op_star
id|base
suffix:semicolon
r_int
id|rev_argc
suffix:semicolon
multiline_comment|/*&n;&t; * Nothing to report unless we are marked to build on top of&n;&t; * somebody else.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|branch
op_logical_or
op_logical_neg
id|branch-&gt;merge
op_logical_or
op_logical_neg
id|branch-&gt;merge
(braket
l_int|0
)braket
op_logical_or
op_logical_neg
id|branch-&gt;merge
(braket
l_int|0
)braket
op_member_access_from_pointer
id|dst
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If what we used to build on no longer exists, there is&n;&t; * nothing to report.&n;&t; */
id|base
op_assign
id|branch-&gt;merge
(braket
l_int|0
)braket
op_member_access_from_pointer
id|dst
suffix:semicolon
r_if
c_cond
(paren
id|read_ref
c_func
(paren
id|base
comma
id|sha1
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|theirs
op_assign
id|lookup_commit_reference
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|theirs
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|read_ref
c_func
(paren
id|branch-&gt;refname
comma
id|sha1
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|ours
op_assign
id|lookup_commit_reference
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ours
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* are we the same? */
r_if
c_cond
(paren
id|theirs
op_eq
id|ours
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Run &quot;rev-list --left-right ours...theirs&quot; internally... */
id|rev_argc
op_assign
l_int|0
suffix:semicolon
id|rev_argv
(braket
id|rev_argc
op_increment
)braket
op_assign
l_int|NULL
suffix:semicolon
id|rev_argv
(braket
id|rev_argc
op_increment
)braket
op_assign
l_string|&quot;--left-right&quot;
suffix:semicolon
id|rev_argv
(braket
id|rev_argc
op_increment
)braket
op_assign
id|symmetric
suffix:semicolon
id|rev_argv
(braket
id|rev_argc
op_increment
)braket
op_assign
l_string|&quot;--&quot;
suffix:semicolon
id|rev_argv
(braket
id|rev_argc
)braket
op_assign
l_int|NULL
suffix:semicolon
id|strcpy
c_func
(paren
id|symmetric
comma
id|sha1_to_hex
c_func
(paren
id|ours-&gt;object.sha1
)paren
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|symmetric
op_plus
l_int|40
comma
l_string|&quot;...&quot;
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|symmetric
op_plus
l_int|43
comma
id|sha1_to_hex
c_func
(paren
id|theirs-&gt;object.sha1
)paren
)paren
suffix:semicolon
id|init_revisions
c_func
(paren
op_amp
id|revs
comma
l_int|NULL
)paren
suffix:semicolon
id|setup_revisions
c_func
(paren
id|rev_argc
comma
id|rev_argv
comma
op_amp
id|revs
comma
l_int|NULL
)paren
suffix:semicolon
id|prepare_revision_walk
c_func
(paren
op_amp
id|revs
)paren
suffix:semicolon
multiline_comment|/* ... and count the commits on each side. */
op_star
id|num_ours
op_assign
l_int|0
suffix:semicolon
op_star
id|num_theirs
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_struct
id|commit
op_star
id|c
op_assign
id|get_revision
c_func
(paren
op_amp
id|revs
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;object.flags
op_amp
id|SYMMETRIC_LEFT
)paren
(paren
op_star
id|num_ours
)paren
op_increment
suffix:semicolon
r_else
(paren
op_star
id|num_theirs
)paren
op_increment
suffix:semicolon
)brace
multiline_comment|/* clear object flags smudged by the above traversal */
id|clear_commit_marks
c_func
(paren
id|ours
comma
id|ALL_REV_FLAGS
)paren
suffix:semicolon
id|clear_commit_marks
c_func
(paren
id|theirs
comma
id|ALL_REV_FLAGS
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Return true when there is anything to report, otherwise false.&n; */
DECL|function|format_tracking_info
r_int
id|format_tracking_info
c_func
(paren
r_struct
id|branch
op_star
id|branch
comma
r_struct
id|strbuf
op_star
id|sb
)paren
(brace
r_int
id|num_ours
comma
id|num_theirs
suffix:semicolon
r_const
r_char
op_star
id|base
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stat_tracking_info
c_func
(paren
id|branch
comma
op_amp
id|num_ours
comma
op_amp
id|num_theirs
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|base
op_assign
id|branch-&gt;merge
(braket
l_int|0
)braket
op_member_access_from_pointer
id|dst
suffix:semicolon
id|base
op_assign
id|shorten_unambiguous_ref
c_func
(paren
id|base
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|num_theirs
)paren
(brace
id|strbuf_addf
c_func
(paren
id|sb
comma
id|Q_
c_func
(paren
l_string|&quot;Your branch is ahead of &squot;%s&squot; by %d commit.&bslash;n&quot;
comma
l_string|&quot;Your branch is ahead of &squot;%s&squot; by %d commits.&bslash;n&quot;
comma
id|num_ours
)paren
comma
id|base
comma
id|num_ours
)paren
suffix:semicolon
r_if
c_cond
(paren
id|advice_status_hints
)paren
id|strbuf_addf
c_func
(paren
id|sb
comma
id|_
c_func
(paren
l_string|&quot;  (use &bslash;&quot;git push&bslash;&quot; to publish your local commits)&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|num_ours
)paren
(brace
id|strbuf_addf
c_func
(paren
id|sb
comma
id|Q_
c_func
(paren
l_string|&quot;Your branch is behind &squot;%s&squot; by %d commit, &quot;
l_string|&quot;and can be fast-forwarded.&bslash;n&quot;
comma
l_string|&quot;Your branch is behind &squot;%s&squot; by %d commits, &quot;
l_string|&quot;and can be fast-forwarded.&bslash;n&quot;
comma
id|num_theirs
)paren
comma
id|base
comma
id|num_theirs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|advice_status_hints
)paren
id|strbuf_addf
c_func
(paren
id|sb
comma
id|_
c_func
(paren
l_string|&quot;  (use &bslash;&quot;git pull&bslash;&quot; to update your local branch)&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|strbuf_addf
c_func
(paren
id|sb
comma
id|Q_
c_func
(paren
l_string|&quot;Your branch and &squot;%s&squot; have diverged,&bslash;n&quot;
l_string|&quot;and have %d and %d different commit each, &quot;
l_string|&quot;respectively.&bslash;n&quot;
comma
l_string|&quot;Your branch and &squot;%s&squot; have diverged,&bslash;n&quot;
l_string|&quot;and have %d and %d different commits each, &quot;
l_string|&quot;respectively.&bslash;n&quot;
comma
id|num_theirs
)paren
comma
id|base
comma
id|num_ours
comma
id|num_theirs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|advice_status_hints
)paren
id|strbuf_addf
c_func
(paren
id|sb
comma
id|_
c_func
(paren
l_string|&quot;  (use &bslash;&quot;git pull&bslash;&quot; to merge the remote branch into yours)&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|one_local_ref
r_static
r_int
id|one_local_ref
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
id|flag
comma
r_void
op_star
id|cb_data
)paren
(brace
r_struct
id|ref
op_star
op_star
op_star
id|local_tail
op_assign
id|cb_data
suffix:semicolon
r_struct
id|ref
op_star
id|ref
suffix:semicolon
r_int
id|len
suffix:semicolon
multiline_comment|/* we already know it starts with refs/ to get here */
r_if
c_cond
(paren
id|check_refname_format
c_func
(paren
id|refname
op_plus
l_int|5
comma
l_int|0
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|refname
)paren
op_plus
l_int|1
suffix:semicolon
id|ref
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|ref
)paren
op_plus
id|len
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|ref-&gt;new_sha1
comma
id|sha1
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ref-&gt;name
comma
id|refname
comma
id|len
)paren
suffix:semicolon
op_star
op_star
id|local_tail
op_assign
id|ref
suffix:semicolon
op_star
id|local_tail
op_assign
op_amp
id|ref-&gt;next
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|get_local_heads
r_struct
id|ref
op_star
id|get_local_heads
c_func
(paren
r_void
)paren
(brace
r_struct
id|ref
op_star
id|local_refs
op_assign
l_int|NULL
comma
op_star
op_star
id|local_tail
op_assign
op_amp
id|local_refs
suffix:semicolon
id|for_each_ref
c_func
(paren
id|one_local_ref
comma
op_amp
id|local_tail
)paren
suffix:semicolon
r_return
id|local_refs
suffix:semicolon
)brace
DECL|function|guess_remote_head
r_struct
id|ref
op_star
id|guess_remote_head
c_func
(paren
r_const
r_struct
id|ref
op_star
id|head
comma
r_const
r_struct
id|ref
op_star
id|refs
comma
r_int
id|all
)paren
(brace
r_const
r_struct
id|ref
op_star
id|r
suffix:semicolon
r_struct
id|ref
op_star
id|list
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|ref
op_star
op_star
id|tail
op_assign
op_amp
id|list
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|head
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Some transports support directly peeking at&n;&t; * where HEAD points; if that is the case, then&n;&t; * we don&squot;t have to guess.&n;&t; */
r_if
c_cond
(paren
id|head-&gt;symref
)paren
r_return
id|copy_ref
c_func
(paren
id|find_ref_by_name
c_func
(paren
id|refs
comma
id|head-&gt;symref
)paren
)paren
suffix:semicolon
multiline_comment|/* If refs/heads/master could be right, it is. */
r_if
c_cond
(paren
op_logical_neg
id|all
)paren
(brace
id|r
op_assign
id|find_ref_by_name
c_func
(paren
id|refs
comma
l_string|&quot;refs/heads/master&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_logical_and
op_logical_neg
id|hashcmp
c_func
(paren
id|r-&gt;old_sha1
comma
id|head-&gt;old_sha1
)paren
)paren
r_return
id|copy_ref
c_func
(paren
id|r
)paren
suffix:semicolon
)brace
multiline_comment|/* Look for another ref that points there */
r_for
c_loop
(paren
id|r
op_assign
id|refs
suffix:semicolon
id|r
suffix:semicolon
id|r
op_assign
id|r-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|r
op_ne
id|head
op_logical_and
op_logical_neg
id|prefixcmp
c_func
(paren
id|r-&gt;name
comma
l_string|&quot;refs/heads/&quot;
)paren
op_logical_and
op_logical_neg
id|hashcmp
c_func
(paren
id|r-&gt;old_sha1
comma
id|head-&gt;old_sha1
)paren
)paren
(brace
op_star
id|tail
op_assign
id|copy_ref
c_func
(paren
id|r
)paren
suffix:semicolon
id|tail
op_assign
op_amp
(paren
(paren
op_star
id|tail
)paren
op_member_access_from_pointer
id|next
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|all
)paren
r_break
suffix:semicolon
)brace
)brace
r_return
id|list
suffix:semicolon
)brace
DECL|struct|stale_heads_info
r_struct
id|stale_heads_info
(brace
DECL|member|ref_names
r_struct
id|string_list
op_star
id|ref_names
suffix:semicolon
DECL|member|stale_refs_tail
r_struct
id|ref
op_star
op_star
id|stale_refs_tail
suffix:semicolon
DECL|member|refs
r_struct
id|refspec
op_star
id|refs
suffix:semicolon
DECL|member|ref_count
r_int
id|ref_count
suffix:semicolon
)brace
suffix:semicolon
DECL|function|get_stale_heads_cb
r_static
r_int
id|get_stale_heads_cb
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
id|flags
comma
r_void
op_star
id|cb_data
)paren
(brace
r_struct
id|stale_heads_info
op_star
id|info
op_assign
id|cb_data
suffix:semicolon
r_struct
id|refspec
id|query
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|query
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|refspec
)paren
)paren
suffix:semicolon
id|query.dst
op_assign
(paren
r_char
op_star
)paren
id|refname
suffix:semicolon
r_if
c_cond
(paren
id|query_refspecs
c_func
(paren
id|info-&gt;refs
comma
id|info-&gt;ref_count
comma
op_amp
id|query
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* No matches */
multiline_comment|/*&n;&t; * If we did find a suitable refspec and it&squot;s not a symref and&n;&t; * it&squot;s not in the list of refs that currently exist in that&n;&t; * remote we consider it to be stale.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|flags
op_amp
id|REF_ISSYMREF
)paren
op_logical_or
id|string_list_has_string
c_func
(paren
id|info-&gt;ref_names
comma
id|query.src
)paren
)paren
)paren
(brace
r_struct
id|ref
op_star
id|ref
op_assign
id|make_linked_ref
c_func
(paren
id|refname
comma
op_amp
id|info-&gt;stale_refs_tail
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|ref-&gt;new_sha1
comma
id|sha1
)paren
suffix:semicolon
)brace
id|free
c_func
(paren
id|query.src
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|get_stale_heads
r_struct
id|ref
op_star
id|get_stale_heads
c_func
(paren
r_struct
id|refspec
op_star
id|refs
comma
r_int
id|ref_count
comma
r_struct
id|ref
op_star
id|fetch_map
)paren
(brace
r_struct
id|ref
op_star
id|ref
comma
op_star
id|stale_refs
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|string_list
id|ref_names
op_assign
id|STRING_LIST_INIT_NODUP
suffix:semicolon
r_struct
id|stale_heads_info
id|info
suffix:semicolon
id|info.ref_names
op_assign
op_amp
id|ref_names
suffix:semicolon
id|info.stale_refs_tail
op_assign
op_amp
id|stale_refs
suffix:semicolon
id|info.refs
op_assign
id|refs
suffix:semicolon
id|info.ref_count
op_assign
id|ref_count
suffix:semicolon
r_for
c_loop
(paren
id|ref
op_assign
id|fetch_map
suffix:semicolon
id|ref
suffix:semicolon
id|ref
op_assign
id|ref-&gt;next
)paren
id|string_list_append
c_func
(paren
op_amp
id|ref_names
comma
id|ref-&gt;name
)paren
suffix:semicolon
id|sort_string_list
c_func
(paren
op_amp
id|ref_names
)paren
suffix:semicolon
id|for_each_ref
c_func
(paren
id|get_stale_heads_cb
comma
op_amp
id|info
)paren
suffix:semicolon
id|string_list_clear
c_func
(paren
op_amp
id|ref_names
comma
l_int|0
)paren
suffix:semicolon
r_return
id|stale_refs
suffix:semicolon
)brace
eof
