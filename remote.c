macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;remote.h&quot;
macro_line|#include &quot;refs.h&quot;
DECL|variable|s_tag_refspec
r_static
r_struct
id|refspec
id|s_tag_refspec
op_assign
(brace
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_string|&quot;refs/tags/&quot;
comma
l_string|&quot;refs/tags/&quot;
)brace
suffix:semicolon
DECL|variable|tag_refspec
r_const
r_struct
id|refspec
op_star
id|tag_refspec
op_assign
op_amp
id|s_tag_refspec
suffix:semicolon
DECL|struct|counted_string
r_struct
id|counted_string
(brace
DECL|member|len
r_int
id|len
suffix:semicolon
DECL|member|s
r_const
r_char
op_star
id|s
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|rewrite
r_struct
id|rewrite
(brace
DECL|member|base
r_const
r_char
op_star
id|base
suffix:semicolon
DECL|member|baselen
r_int
id|baselen
suffix:semicolon
DECL|member|instead_of
r_struct
id|counted_string
op_star
id|instead_of
suffix:semicolon
DECL|member|instead_of_nr
r_int
id|instead_of_nr
suffix:semicolon
DECL|member|instead_of_alloc
r_int
id|instead_of_alloc
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|remotes
r_static
r_struct
id|remote
op_star
op_star
id|remotes
suffix:semicolon
DECL|variable|remotes_alloc
r_static
r_int
id|remotes_alloc
suffix:semicolon
DECL|variable|remotes_nr
r_static
r_int
id|remotes_nr
suffix:semicolon
DECL|variable|branches
r_static
r_struct
id|branch
op_star
op_star
id|branches
suffix:semicolon
DECL|variable|branches_alloc
r_static
r_int
id|branches_alloc
suffix:semicolon
DECL|variable|branches_nr
r_static
r_int
id|branches_nr
suffix:semicolon
DECL|variable|current_branch
r_static
r_struct
id|branch
op_star
id|current_branch
suffix:semicolon
DECL|variable|default_remote_name
r_static
r_const
r_char
op_star
id|default_remote_name
suffix:semicolon
DECL|variable|rewrite
r_static
r_struct
id|rewrite
op_star
op_star
id|rewrite
suffix:semicolon
DECL|variable|rewrite_alloc
r_static
r_int
id|rewrite_alloc
suffix:semicolon
DECL|variable|rewrite_nr
r_static
r_int
id|rewrite_nr
suffix:semicolon
DECL|macro|BUF_SIZE
mdefine_line|#define BUF_SIZE (2048)
DECL|variable|buffer
r_static
r_char
id|buffer
(braket
id|BUF_SIZE
)braket
suffix:semicolon
DECL|function|alias_url
r_static
r_const
r_char
op_star
id|alias_url
c_func
(paren
r_const
r_char
op_star
id|url
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_char
op_star
id|ret
suffix:semicolon
r_struct
id|counted_string
op_star
id|longest
suffix:semicolon
r_int
id|longest_i
suffix:semicolon
id|longest
op_assign
l_int|NULL
suffix:semicolon
id|longest_i
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|rewrite_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|rewrite
(braket
id|i
)braket
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|rewrite
(braket
id|i
)braket
op_member_access_from_pointer
id|instead_of_nr
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|url
comma
id|rewrite
(braket
id|i
)braket
op_member_access_from_pointer
id|instead_of
(braket
id|j
)braket
dot
id|s
)paren
op_logical_and
(paren
op_logical_neg
id|longest
op_logical_or
id|longest-&gt;len
OL
id|rewrite
(braket
id|i
)braket
op_member_access_from_pointer
id|instead_of
(braket
id|j
)braket
dot
id|len
)paren
)paren
(brace
id|longest
op_assign
op_amp
(paren
id|rewrite
(braket
id|i
)braket
op_member_access_from_pointer
id|instead_of
(braket
id|j
)braket
)paren
suffix:semicolon
id|longest_i
op_assign
id|i
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|longest
)paren
r_return
id|url
suffix:semicolon
id|ret
op_assign
id|malloc
c_func
(paren
id|rewrite
(braket
id|longest_i
)braket
op_member_access_from_pointer
id|baselen
op_plus
(paren
id|strlen
c_func
(paren
id|url
)paren
id|longest-&gt;len
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|ret
comma
id|rewrite
(braket
id|longest_i
)braket
op_member_access_from_pointer
id|base
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|ret
op_plus
id|rewrite
(braket
id|longest_i
)braket
op_member_access_from_pointer
id|baselen
comma
id|url
op_plus
id|longest-&gt;len
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|add_push_refspec
r_static
r_void
id|add_push_refspec
c_func
(paren
r_struct
id|remote
op_star
id|remote
comma
r_const
r_char
op_star
id|ref
)paren
(brace
id|ALLOC_GROW
c_func
(paren
id|remote-&gt;push_refspec
comma
id|remote-&gt;push_refspec_nr
op_plus
l_int|1
comma
id|remote-&gt;push_refspec_alloc
)paren
suffix:semicolon
id|remote-&gt;push_refspec
(braket
id|remote-&gt;push_refspec_nr
op_increment
)braket
op_assign
id|ref
suffix:semicolon
)brace
DECL|function|add_fetch_refspec
r_static
r_void
id|add_fetch_refspec
c_func
(paren
r_struct
id|remote
op_star
id|remote
comma
r_const
r_char
op_star
id|ref
)paren
(brace
id|ALLOC_GROW
c_func
(paren
id|remote-&gt;fetch_refspec
comma
id|remote-&gt;fetch_refspec_nr
op_plus
l_int|1
comma
id|remote-&gt;fetch_refspec_alloc
)paren
suffix:semicolon
id|remote-&gt;fetch_refspec
(braket
id|remote-&gt;fetch_refspec_nr
op_increment
)braket
op_assign
id|ref
suffix:semicolon
)brace
DECL|function|add_url
r_static
r_void
id|add_url
c_func
(paren
r_struct
id|remote
op_star
id|remote
comma
r_const
r_char
op_star
id|url
)paren
(brace
id|ALLOC_GROW
c_func
(paren
id|remote-&gt;url
comma
id|remote-&gt;url_nr
op_plus
l_int|1
comma
id|remote-&gt;url_alloc
)paren
suffix:semicolon
id|remote-&gt;url
(braket
id|remote-&gt;url_nr
op_increment
)braket
op_assign
id|url
suffix:semicolon
)brace
DECL|function|add_url_alias
r_static
r_void
id|add_url_alias
c_func
(paren
r_struct
id|remote
op_star
id|remote
comma
r_const
r_char
op_star
id|url
)paren
(brace
id|add_url
c_func
(paren
id|remote
comma
id|alias_url
c_func
(paren
id|url
)paren
)paren
suffix:semicolon
)brace
DECL|function|make_remote
r_static
r_struct
id|remote
op_star
id|make_remote
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_int
id|len
)paren
(brace
r_struct
id|remote
op_star
id|ret
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|remotes_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|len
ques
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|name
comma
id|remotes
(braket
id|i
)braket
op_member_access_from_pointer
id|name
comma
id|len
)paren
op_logical_and
op_logical_neg
id|remotes
(braket
id|i
)braket
op_member_access_from_pointer
id|name
(braket
id|len
)braket
)paren
suffix:colon
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
id|remotes
(braket
id|i
)braket
op_member_access_from_pointer
id|name
)paren
)paren
r_return
id|remotes
(braket
id|i
)braket
suffix:semicolon
)brace
id|ret
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|remote
)paren
)paren
suffix:semicolon
id|ALLOC_GROW
c_func
(paren
id|remotes
comma
id|remotes_nr
op_plus
l_int|1
comma
id|remotes_alloc
)paren
suffix:semicolon
id|remotes
(braket
id|remotes_nr
op_increment
)braket
op_assign
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|len
)paren
id|ret-&gt;name
op_assign
id|xstrndup
c_func
(paren
id|name
comma
id|len
)paren
suffix:semicolon
r_else
id|ret-&gt;name
op_assign
id|xstrdup
c_func
(paren
id|name
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|add_merge
r_static
r_void
id|add_merge
c_func
(paren
r_struct
id|branch
op_star
id|branch
comma
r_const
r_char
op_star
id|name
)paren
(brace
id|ALLOC_GROW
c_func
(paren
id|branch-&gt;merge_name
comma
id|branch-&gt;merge_nr
op_plus
l_int|1
comma
id|branch-&gt;merge_alloc
)paren
suffix:semicolon
id|branch-&gt;merge_name
(braket
id|branch-&gt;merge_nr
op_increment
)braket
op_assign
id|name
suffix:semicolon
)brace
DECL|function|make_branch
r_static
r_struct
id|branch
op_star
id|make_branch
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_int
id|len
)paren
(brace
r_struct
id|branch
op_star
id|ret
suffix:semicolon
r_int
id|i
suffix:semicolon
r_char
op_star
id|refname
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|branches_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|len
ques
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|name
comma
id|branches
(braket
id|i
)braket
op_member_access_from_pointer
id|name
comma
id|len
)paren
op_logical_and
op_logical_neg
id|branches
(braket
id|i
)braket
op_member_access_from_pointer
id|name
(braket
id|len
)braket
)paren
suffix:colon
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
id|branches
(braket
id|i
)braket
op_member_access_from_pointer
id|name
)paren
)paren
r_return
id|branches
(braket
id|i
)braket
suffix:semicolon
)brace
id|ALLOC_GROW
c_func
(paren
id|branches
comma
id|branches_nr
op_plus
l_int|1
comma
id|branches_alloc
)paren
suffix:semicolon
id|ret
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|branch
)paren
)paren
suffix:semicolon
id|branches
(braket
id|branches_nr
op_increment
)braket
op_assign
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|len
)paren
id|ret-&gt;name
op_assign
id|xstrndup
c_func
(paren
id|name
comma
id|len
)paren
suffix:semicolon
r_else
id|ret-&gt;name
op_assign
id|xstrdup
c_func
(paren
id|name
)paren
suffix:semicolon
id|refname
op_assign
id|malloc
c_func
(paren
id|strlen
c_func
(paren
id|name
)paren
op_plus
id|strlen
c_func
(paren
l_string|&quot;refs/heads/&quot;
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|refname
comma
l_string|&quot;refs/heads/&quot;
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|refname
op_plus
id|strlen
c_func
(paren
l_string|&quot;refs/heads/&quot;
)paren
comma
id|ret-&gt;name
)paren
suffix:semicolon
id|ret-&gt;refname
op_assign
id|refname
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|make_rewrite
r_static
r_struct
id|rewrite
op_star
id|make_rewrite
c_func
(paren
r_const
r_char
op_star
id|base
comma
r_int
id|len
)paren
(brace
r_struct
id|rewrite
op_star
id|ret
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|rewrite_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|len
ques
c_cond
(paren
id|len
op_eq
id|rewrite
(braket
id|i
)braket
op_member_access_from_pointer
id|baselen
op_logical_and
op_logical_neg
id|strncmp
c_func
(paren
id|base
comma
id|rewrite
(braket
id|i
)braket
op_member_access_from_pointer
id|base
comma
id|len
)paren
)paren
suffix:colon
op_logical_neg
id|strcmp
c_func
(paren
id|base
comma
id|rewrite
(braket
id|i
)braket
op_member_access_from_pointer
id|base
)paren
)paren
r_return
id|rewrite
(braket
id|i
)braket
suffix:semicolon
)brace
id|ALLOC_GROW
c_func
(paren
id|rewrite
comma
id|rewrite_nr
op_plus
l_int|1
comma
id|rewrite_alloc
)paren
suffix:semicolon
id|ret
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|rewrite
)paren
)paren
suffix:semicolon
id|rewrite
(braket
id|rewrite_nr
op_increment
)braket
op_assign
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|len
)paren
(brace
id|ret-&gt;base
op_assign
id|xstrndup
c_func
(paren
id|base
comma
id|len
)paren
suffix:semicolon
id|ret-&gt;baselen
op_assign
id|len
suffix:semicolon
)brace
r_else
(brace
id|ret-&gt;base
op_assign
id|xstrdup
c_func
(paren
id|base
)paren
suffix:semicolon
id|ret-&gt;baselen
op_assign
id|strlen
c_func
(paren
id|base
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|add_instead_of
r_static
r_void
id|add_instead_of
c_func
(paren
r_struct
id|rewrite
op_star
id|rewrite
comma
r_const
r_char
op_star
id|instead_of
)paren
(brace
id|ALLOC_GROW
c_func
(paren
id|rewrite-&gt;instead_of
comma
id|rewrite-&gt;instead_of_nr
op_plus
l_int|1
comma
id|rewrite-&gt;instead_of_alloc
)paren
suffix:semicolon
id|rewrite-&gt;instead_of
(braket
id|rewrite-&gt;instead_of_nr
)braket
dot
id|s
op_assign
id|instead_of
suffix:semicolon
id|rewrite-&gt;instead_of
(braket
id|rewrite-&gt;instead_of_nr
)braket
dot
id|len
op_assign
id|strlen
c_func
(paren
id|instead_of
)paren
suffix:semicolon
id|rewrite-&gt;instead_of_nr
op_increment
suffix:semicolon
)brace
DECL|function|read_remotes_file
r_static
r_void
id|read_remotes_file
c_func
(paren
r_struct
id|remote
op_star
id|remote
)paren
(brace
id|FILE
op_star
id|f
op_assign
id|fopen
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;remotes/%s&quot;
comma
id|remote-&gt;name
)paren
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|f
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
id|fgets
c_func
(paren
id|buffer
comma
id|BUF_SIZE
comma
id|f
)paren
)paren
(brace
r_int
id|value_list
suffix:semicolon
r_char
op_star
id|s
comma
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|buffer
comma
l_string|&quot;URL:&quot;
)paren
)paren
(brace
id|value_list
op_assign
l_int|0
suffix:semicolon
id|s
op_assign
id|buffer
op_plus
l_int|4
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|buffer
comma
l_string|&quot;Push:&quot;
)paren
)paren
(brace
id|value_list
op_assign
l_int|1
suffix:semicolon
id|s
op_assign
id|buffer
op_plus
l_int|5
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|buffer
comma
l_string|&quot;Pull:&quot;
)paren
)paren
(brace
id|value_list
op_assign
l_int|2
suffix:semicolon
id|s
op_assign
id|buffer
op_plus
l_int|5
suffix:semicolon
)brace
r_else
r_continue
suffix:semicolon
r_while
c_loop
(paren
id|isspace
c_func
(paren
op_star
id|s
)paren
)paren
id|s
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|s
)paren
r_continue
suffix:semicolon
id|p
op_assign
id|s
op_plus
id|strlen
c_func
(paren
id|s
)paren
suffix:semicolon
r_while
c_loop
(paren
id|isspace
c_func
(paren
id|p
(braket
l_int|1
)braket
)paren
)paren
op_star
op_decrement
id|p
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|value_list
)paren
(brace
r_case
l_int|0
suffix:colon
id|add_url_alias
c_func
(paren
id|remote
comma
id|xstrdup
c_func
(paren
id|s
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|add_push_refspec
c_func
(paren
id|remote
comma
id|xstrdup
c_func
(paren
id|s
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|add_fetch_refspec
c_func
(paren
id|remote
comma
id|xstrdup
c_func
(paren
id|s
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|fclose
c_func
(paren
id|f
)paren
suffix:semicolon
)brace
DECL|function|read_branches_file
r_static
r_void
id|read_branches_file
c_func
(paren
r_struct
id|remote
op_star
id|remote
)paren
(brace
r_const
r_char
op_star
id|slash
op_assign
id|strchr
c_func
(paren
id|remote-&gt;name
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
r_char
op_star
id|frag
suffix:semicolon
r_struct
id|strbuf
id|branch
suffix:semicolon
r_int
id|n
op_assign
id|slash
ques
c_cond
id|slash
id|remote-&gt;name
suffix:colon
l_int|1000
suffix:semicolon
id|FILE
op_star
id|f
op_assign
id|fopen
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;branches/%.*s&quot;
comma
id|n
comma
id|remote-&gt;name
)paren
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_char
op_star
id|s
comma
op_star
id|p
suffix:semicolon
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|f
)paren
r_return
suffix:semicolon
id|s
op_assign
id|fgets
c_func
(paren
id|buffer
comma
id|BUF_SIZE
comma
id|f
)paren
suffix:semicolon
id|fclose
c_func
(paren
id|f
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
id|isspace
c_func
(paren
op_star
id|s
)paren
)paren
id|s
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|s
)paren
r_return
suffix:semicolon
id|p
op_assign
id|s
op_plus
id|strlen
c_func
(paren
id|s
)paren
suffix:semicolon
r_while
c_loop
(paren
id|isspace
c_func
(paren
id|p
(braket
l_int|1
)braket
)paren
)paren
op_star
op_decrement
id|p
op_assign
l_int|0
suffix:semicolon
id|len
op_assign
id|p
id|s
suffix:semicolon
r_if
c_cond
(paren
id|slash
)paren
id|len
op_add_assign
id|strlen
c_func
(paren
id|slash
)paren
suffix:semicolon
id|p
op_assign
id|xmalloc
c_func
(paren
id|len
op_plus
l_int|1
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|p
comma
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slash
)paren
id|strcat
c_func
(paren
id|p
comma
id|slash
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * With &quot;slash&quot;, e.g. &quot;git fetch jgarzik/netdev-2.6&quot; when&n;&t; * reading from $GIT_DIR/branches/jgarzik fetches &quot;HEAD&quot; from&n;&t; * the partial URL obtained from the branches file plus&n;&t; * &quot;/netdev-2.6&quot; and does not store it in any tracking ref.&n;&t; * #branch specifier in the file is ignored.&n;&t; *&n;&t; * Otherwise, the branches file would have URL and optionally&n;&t; * #branch specified.  The &quot;master&quot; (or specified) branch is&n;&t; * fetched and stored in the local branch of the same name.&n;&t; */
id|strbuf_init
c_func
(paren
op_amp
id|branch
comma
l_int|0
)paren
suffix:semicolon
id|frag
op_assign
id|strchr
c_func
(paren
id|p
comma
l_char|&squot;#&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|frag
)paren
(brace
op_star
(paren
id|frag
op_increment
)paren
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
id|branch
comma
l_string|&quot;refs/heads/%s&quot;
comma
id|frag
)paren
suffix:semicolon
)brace
r_else
id|strbuf_addstr
c_func
(paren
op_amp
id|branch
comma
l_string|&quot;refs/heads/master&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|slash
)paren
(brace
id|strbuf_addf
c_func
(paren
op_amp
id|branch
comma
l_string|&quot;:refs/heads/%s&quot;
comma
id|remote-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
id|strbuf_reset
c_func
(paren
op_amp
id|branch
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|branch
comma
l_string|&quot;HEAD:&quot;
)paren
suffix:semicolon
)brace
id|add_url_alias
c_func
(paren
id|remote
comma
id|p
)paren
suffix:semicolon
id|add_fetch_refspec
c_func
(paren
id|remote
comma
id|strbuf_detach
c_func
(paren
op_amp
id|branch
comma
l_int|0
)paren
)paren
suffix:semicolon
id|remote-&gt;fetch_tags
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* always auto-follow */
)brace
DECL|function|handle_config
r_static
r_int
id|handle_config
c_func
(paren
r_const
r_char
op_star
id|key
comma
r_const
r_char
op_star
id|value
comma
r_void
op_star
id|cb
)paren
(brace
r_const
r_char
op_star
id|name
suffix:semicolon
r_const
r_char
op_star
id|subkey
suffix:semicolon
r_struct
id|remote
op_star
id|remote
suffix:semicolon
r_struct
id|branch
op_star
id|branch
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|key
comma
l_string|&quot;branch.&quot;
)paren
)paren
(brace
id|name
op_assign
id|key
op_plus
l_int|7
suffix:semicolon
id|subkey
op_assign
id|strrchr
c_func
(paren
id|name
comma
l_char|&squot;.&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|subkey
)paren
r_return
l_int|0
suffix:semicolon
id|branch
op_assign
id|make_branch
c_func
(paren
id|name
comma
id|subkey
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|subkey
comma
l_string|&quot;.remote&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
r_return
id|config_error_nonbool
c_func
(paren
id|key
)paren
suffix:semicolon
id|branch-&gt;remote_name
op_assign
id|xstrdup
c_func
(paren
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|branch
op_eq
id|current_branch
)paren
id|default_remote_name
op_assign
id|branch-&gt;remote_name
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|subkey
comma
l_string|&quot;.merge&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
r_return
id|config_error_nonbool
c_func
(paren
id|key
)paren
suffix:semicolon
id|add_merge
c_func
(paren
id|branch
comma
id|xstrdup
c_func
(paren
id|value
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|key
comma
l_string|&quot;url.&quot;
)paren
)paren
(brace
r_struct
id|rewrite
op_star
id|rewrite
suffix:semicolon
id|name
op_assign
id|key
op_plus
l_int|4
suffix:semicolon
id|subkey
op_assign
id|strrchr
c_func
(paren
id|name
comma
l_char|&squot;.&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|subkey
)paren
r_return
l_int|0
suffix:semicolon
id|rewrite
op_assign
id|make_rewrite
c_func
(paren
id|name
comma
id|subkey
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|subkey
comma
l_string|&quot;.insteadof&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
r_return
id|config_error_nonbool
c_func
(paren
id|key
)paren
suffix:semicolon
id|add_instead_of
c_func
(paren
id|rewrite
comma
id|xstrdup
c_func
(paren
id|value
)paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|prefixcmp
c_func
(paren
id|key
comma
l_string|&quot;remote.&quot;
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|name
op_assign
id|key
op_plus
l_int|7
suffix:semicolon
id|subkey
op_assign
id|strrchr
c_func
(paren
id|name
comma
l_char|&squot;.&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|subkey
)paren
r_return
id|error
c_func
(paren
l_string|&quot;Config with no key for remote %s&quot;
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|subkey
op_eq
l_char|&squot;/&squot;
)paren
(brace
id|warning
c_func
(paren
l_string|&quot;Config remote shorthand cannot begin with &squot;/&squot;: %s&quot;
comma
id|name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|remote
op_assign
id|make_remote
c_func
(paren
id|name
comma
id|subkey
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|subkey
comma
l_string|&quot;.mirror&quot;
)paren
)paren
id|remote-&gt;mirror
op_assign
id|git_config_bool
c_func
(paren
id|key
comma
id|value
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|subkey
comma
l_string|&quot;.skipdefaultupdate&quot;
)paren
)paren
id|remote-&gt;skip_default_update
op_assign
id|git_config_bool
c_func
(paren
id|key
comma
id|value
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|subkey
comma
l_string|&quot;.url&quot;
)paren
)paren
(brace
r_const
r_char
op_star
id|v
suffix:semicolon
r_if
c_cond
(paren
id|git_config_string
c_func
(paren
op_amp
id|v
comma
id|key
comma
id|value
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|add_url
c_func
(paren
id|remote
comma
id|v
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|subkey
comma
l_string|&quot;.push&quot;
)paren
)paren
(brace
r_const
r_char
op_star
id|v
suffix:semicolon
r_if
c_cond
(paren
id|git_config_string
c_func
(paren
op_amp
id|v
comma
id|key
comma
id|value
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|add_push_refspec
c_func
(paren
id|remote
comma
id|v
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|subkey
comma
l_string|&quot;.fetch&quot;
)paren
)paren
(brace
r_const
r_char
op_star
id|v
suffix:semicolon
r_if
c_cond
(paren
id|git_config_string
c_func
(paren
op_amp
id|v
comma
id|key
comma
id|value
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|add_fetch_refspec
c_func
(paren
id|remote
comma
id|v
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|subkey
comma
l_string|&quot;.receivepack&quot;
)paren
)paren
(brace
r_const
r_char
op_star
id|v
suffix:semicolon
r_if
c_cond
(paren
id|git_config_string
c_func
(paren
op_amp
id|v
comma
id|key
comma
id|value
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|remote-&gt;receivepack
)paren
id|remote-&gt;receivepack
op_assign
id|v
suffix:semicolon
r_else
id|error
c_func
(paren
l_string|&quot;more than one receivepack given, using the first&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|subkey
comma
l_string|&quot;.uploadpack&quot;
)paren
)paren
(brace
r_const
r_char
op_star
id|v
suffix:semicolon
r_if
c_cond
(paren
id|git_config_string
c_func
(paren
op_amp
id|v
comma
id|key
comma
id|value
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|remote-&gt;uploadpack
)paren
id|remote-&gt;uploadpack
op_assign
id|v
suffix:semicolon
r_else
id|error
c_func
(paren
l_string|&quot;more than one uploadpack given, using the first&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|subkey
comma
l_string|&quot;.tagopt&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|value
comma
l_string|&quot;--no-tags&quot;
)paren
)paren
id|remote-&gt;fetch_tags
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|subkey
comma
l_string|&quot;.proxy&quot;
)paren
)paren
(brace
r_return
id|git_config_string
c_func
(paren
(paren
r_const
r_char
op_star
op_star
)paren
op_amp
id|remote-&gt;http_proxy
comma
id|key
comma
id|value
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|alias_all_urls
r_static
r_void
id|alias_all_urls
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|remotes_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|remotes
(braket
id|i
)braket
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|remotes
(braket
id|i
)braket
op_member_access_from_pointer
id|url_nr
suffix:semicolon
id|j
op_increment
)paren
(brace
id|remotes
(braket
id|i
)braket
op_member_access_from_pointer
id|url
(braket
id|j
)braket
op_assign
id|alias_url
c_func
(paren
id|remotes
(braket
id|i
)braket
op_member_access_from_pointer
id|url
(braket
id|j
)braket
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|read_config
r_static
r_void
id|read_config
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_const
r_char
op_star
id|head_ref
suffix:semicolon
r_int
id|flag
suffix:semicolon
r_if
c_cond
(paren
id|default_remote_name
)paren
singleline_comment|// did this already
r_return
suffix:semicolon
id|default_remote_name
op_assign
id|xstrdup
c_func
(paren
l_string|&quot;origin&quot;
)paren
suffix:semicolon
id|current_branch
op_assign
l_int|NULL
suffix:semicolon
id|head_ref
op_assign
id|resolve_ref
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|sha1
comma
l_int|0
comma
op_amp
id|flag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|head_ref
op_logical_and
(paren
id|flag
op_amp
id|REF_ISSYMREF
)paren
op_logical_and
op_logical_neg
id|prefixcmp
c_func
(paren
id|head_ref
comma
l_string|&quot;refs/heads/&quot;
)paren
)paren
(brace
id|current_branch
op_assign
id|make_branch
c_func
(paren
id|head_ref
op_plus
id|strlen
c_func
(paren
l_string|&quot;refs/heads/&quot;
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
id|git_config
c_func
(paren
id|handle_config
comma
l_int|NULL
)paren
suffix:semicolon
id|alias_all_urls
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|parse_refspec_internal
r_static
r_struct
id|refspec
op_star
id|parse_refspec_internal
c_func
(paren
r_int
id|nr_refspec
comma
r_const
r_char
op_star
op_star
id|refspec
comma
r_int
id|fetch
comma
r_int
id|verify
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|st
suffix:semicolon
r_struct
id|refspec
op_star
id|rs
op_assign
id|xcalloc
c_func
(paren
r_sizeof
(paren
op_star
id|rs
)paren
comma
id|nr_refspec
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_refspec
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|llen
comma
id|rlen
suffix:semicolon
r_int
id|is_glob
suffix:semicolon
r_const
r_char
op_star
id|lhs
comma
op_star
id|rhs
suffix:semicolon
id|llen
op_assign
id|rlen
op_assign
id|is_glob
op_assign
l_int|0
suffix:semicolon
id|lhs
op_assign
id|refspec
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_star
id|lhs
op_eq
l_char|&squot;+&squot;
)paren
(brace
id|rs
(braket
id|i
)braket
dot
id|force
op_assign
l_int|1
suffix:semicolon
id|lhs
op_increment
suffix:semicolon
)brace
id|rhs
op_assign
id|strrchr
c_func
(paren
id|lhs
comma
l_char|&squot;:&squot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Before going on, special case &quot;:&quot; (or &quot;+:&quot;) as a refspec&n;&t;&t; * for matching refs.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|fetch
op_logical_and
id|rhs
op_eq
id|lhs
op_logical_and
id|rhs
(braket
l_int|1
)braket
op_eq
l_char|&squot;&bslash;0&squot;
)paren
(brace
id|rs
(braket
id|i
)braket
dot
id|matching
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rhs
)paren
(brace
id|rhs
op_increment
suffix:semicolon
id|rlen
op_assign
id|strlen
c_func
(paren
id|rhs
)paren
suffix:semicolon
id|is_glob
op_assign
(paren
l_int|2
op_le
id|rlen
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|rhs
op_plus
id|rlen
l_int|2
comma
l_string|&quot;/*&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_glob
)paren
id|rlen
op_sub_assign
l_int|2
suffix:semicolon
id|rs
(braket
id|i
)braket
dot
id|dst
op_assign
id|xstrndup
c_func
(paren
id|rhs
comma
id|rlen
)paren
suffix:semicolon
)brace
id|llen
op_assign
(paren
id|rhs
ques
c_cond
(paren
id|rhs
id|lhs
l_int|1
)paren
suffix:colon
id|strlen
c_func
(paren
id|lhs
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|2
op_le
id|llen
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|lhs
op_plus
id|llen
l_int|2
comma
l_string|&quot;/*&quot;
comma
l_int|2
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|rhs
op_logical_and
op_logical_neg
id|is_glob
)paren
op_logical_or
(paren
op_logical_neg
id|rhs
op_logical_and
id|fetch
)paren
)paren
r_goto
id|invalid
suffix:semicolon
id|is_glob
op_assign
l_int|1
suffix:semicolon
id|llen
op_sub_assign
l_int|2
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rhs
op_logical_and
id|is_glob
)paren
(brace
r_goto
id|invalid
suffix:semicolon
)brace
id|rs
(braket
id|i
)braket
dot
id|pattern
op_assign
id|is_glob
suffix:semicolon
id|rs
(braket
id|i
)braket
dot
id|src
op_assign
id|xstrndup
c_func
(paren
id|lhs
comma
id|llen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fetch
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * LHS&n;&t;&t;&t; * - empty is allowed; it means HEAD.&n;&t;&t;&t; * - otherwise it must be a valid looking ref.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
op_star
id|rs
(braket
id|i
)braket
dot
id|src
)paren
suffix:semicolon
multiline_comment|/* empty is ok */
r_else
(brace
id|st
op_assign
id|check_ref_format
c_func
(paren
id|rs
(braket
id|i
)braket
dot
id|src
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
op_logical_and
id|st
op_ne
id|CHECK_REF_FORMAT_ONELEVEL
)paren
r_goto
id|invalid
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * RHS&n;&t;&t;&t; * - missing is ok, and is same as empty.&n;&t;&t;&t; * - empty is ok; it means not to store.&n;&t;&t;&t; * - otherwise it must be a valid looking ref.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|rs
(braket
id|i
)braket
dot
id|dst
)paren
(brace
suffix:semicolon
multiline_comment|/* ok */
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
op_star
id|rs
(braket
id|i
)braket
dot
id|dst
)paren
(brace
suffix:semicolon
multiline_comment|/* ok */
)brace
r_else
(brace
id|st
op_assign
id|check_ref_format
c_func
(paren
id|rs
(braket
id|i
)braket
dot
id|dst
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
op_logical_and
id|st
op_ne
id|CHECK_REF_FORMAT_ONELEVEL
)paren
r_goto
id|invalid
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * LHS&n;&t;&t;&t; * - empty is allowed; it means delete.&n;&t;&t;&t; * - when wildcarded, it must be a valid looking ref.&n;&t;&t;&t; * - otherwise, it must be an extended SHA-1, but&n;&t;&t;&t; *   there is no existing way to validate this.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
op_star
id|rs
(braket
id|i
)braket
dot
id|src
)paren
suffix:semicolon
multiline_comment|/* empty is ok */
r_else
r_if
c_cond
(paren
id|is_glob
)paren
(brace
id|st
op_assign
id|check_ref_format
c_func
(paren
id|rs
(braket
id|i
)braket
dot
id|src
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
op_logical_and
id|st
op_ne
id|CHECK_REF_FORMAT_ONELEVEL
)paren
r_goto
id|invalid
suffix:semicolon
)brace
r_else
suffix:semicolon
multiline_comment|/* anything goes, for now */
multiline_comment|/*&n;&t;&t;&t; * RHS&n;&t;&t;&t; * - missing is allowed, but LHS then must be a&n;&t;&t;&t; *   valid looking ref.&n;&t;&t;&t; * - empty is not allowed.&n;&t;&t;&t; * - otherwise it must be a valid looking ref.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|rs
(braket
id|i
)braket
dot
id|dst
)paren
(brace
id|st
op_assign
id|check_ref_format
c_func
(paren
id|rs
(braket
id|i
)braket
dot
id|src
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
op_logical_and
id|st
op_ne
id|CHECK_REF_FORMAT_ONELEVEL
)paren
r_goto
id|invalid
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
op_star
id|rs
(braket
id|i
)braket
dot
id|dst
)paren
(brace
r_goto
id|invalid
suffix:semicolon
)brace
r_else
(brace
id|st
op_assign
id|check_ref_format
c_func
(paren
id|rs
(braket
id|i
)braket
dot
id|dst
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
op_logical_and
id|st
op_ne
id|CHECK_REF_FORMAT_ONELEVEL
)paren
r_goto
id|invalid
suffix:semicolon
)brace
)brace
)brace
r_return
id|rs
suffix:semicolon
id|invalid
suffix:colon
r_if
c_cond
(paren
id|verify
)paren
(brace
id|free
c_func
(paren
id|rs
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|die
c_func
(paren
l_string|&quot;Invalid refspec &squot;%s&squot;&quot;
comma
id|refspec
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
DECL|function|valid_fetch_refspec
r_int
id|valid_fetch_refspec
c_func
(paren
r_const
r_char
op_star
id|fetch_refspec_str
)paren
(brace
r_const
r_char
op_star
id|fetch_refspec
(braket
)braket
op_assign
(brace
id|fetch_refspec_str
)brace
suffix:semicolon
r_struct
id|refspec
op_star
id|refspec
suffix:semicolon
id|refspec
op_assign
id|parse_refspec_internal
c_func
(paren
l_int|1
comma
id|fetch_refspec
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|refspec
)paren
id|free
c_func
(paren
id|refspec
)paren
suffix:semicolon
r_return
op_logical_neg
op_logical_neg
id|refspec
suffix:semicolon
)brace
DECL|function|parse_fetch_refspec
r_struct
id|refspec
op_star
id|parse_fetch_refspec
c_func
(paren
r_int
id|nr_refspec
comma
r_const
r_char
op_star
op_star
id|refspec
)paren
(brace
r_return
id|parse_refspec_internal
c_func
(paren
id|nr_refspec
comma
id|refspec
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|parse_push_refspec
r_struct
id|refspec
op_star
id|parse_push_refspec
c_func
(paren
r_int
id|nr_refspec
comma
r_const
r_char
op_star
op_star
id|refspec
)paren
(brace
r_return
id|parse_refspec_internal
c_func
(paren
id|nr_refspec
comma
id|refspec
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|valid_remote_nick
r_static
r_int
id|valid_remote_nick
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|name
(braket
l_int|0
)braket
op_logical_or
multiline_comment|/* not empty */
(paren
id|name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
op_logical_and
multiline_comment|/* not &quot;.&quot; */
(paren
op_logical_neg
id|name
(braket
l_int|1
)braket
op_logical_or
multiline_comment|/* not &quot;..&quot; */
(paren
id|name
(braket
l_int|1
)braket
op_eq
l_char|&squot;.&squot;
op_logical_and
op_logical_neg
id|name
(braket
l_int|2
)braket
)paren
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
op_logical_neg
id|strchr
c_func
(paren
id|name
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
multiline_comment|/* no slash */
)brace
DECL|function|remote_get
r_struct
id|remote
op_star
id|remote_get
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|remote
op_star
id|ret
suffix:semicolon
id|read_config
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
id|name
op_assign
id|default_remote_name
suffix:semicolon
id|ret
op_assign
id|make_remote
c_func
(paren
id|name
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|valid_remote_nick
c_func
(paren
id|name
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret-&gt;url
)paren
id|read_remotes_file
c_func
(paren
id|ret
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret-&gt;url
)paren
id|read_branches_file
c_func
(paren
id|ret
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ret-&gt;url
)paren
id|add_url_alias
c_func
(paren
id|ret
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret-&gt;url
)paren
r_return
l_int|NULL
suffix:semicolon
id|ret-&gt;fetch
op_assign
id|parse_fetch_refspec
c_func
(paren
id|ret-&gt;fetch_refspec_nr
comma
id|ret-&gt;fetch_refspec
)paren
suffix:semicolon
id|ret-&gt;push
op_assign
id|parse_push_refspec
c_func
(paren
id|ret-&gt;push_refspec_nr
comma
id|ret-&gt;push_refspec
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|for_each_remote
r_int
id|for_each_remote
c_func
(paren
id|each_remote_fn
id|fn
comma
r_void
op_star
id|priv
)paren
(brace
r_int
id|i
comma
id|result
op_assign
l_int|0
suffix:semicolon
id|read_config
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|remotes_nr
op_logical_and
op_logical_neg
id|result
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|remote
op_star
id|r
op_assign
id|remotes
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|r
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|r-&gt;fetch
)paren
id|r-&gt;fetch
op_assign
id|parse_fetch_refspec
c_func
(paren
id|r-&gt;fetch_refspec_nr
comma
id|r-&gt;fetch_refspec
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|r-&gt;push
)paren
id|r-&gt;push
op_assign
id|parse_push_refspec
c_func
(paren
id|r-&gt;push_refspec_nr
comma
id|r-&gt;push_refspec
)paren
suffix:semicolon
id|result
op_assign
id|fn
c_func
(paren
id|r
comma
id|priv
)paren
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
DECL|function|ref_remove_duplicates
r_void
id|ref_remove_duplicates
c_func
(paren
r_struct
id|ref
op_star
id|ref_map
)paren
(brace
r_struct
id|ref
op_star
op_star
id|posn
suffix:semicolon
r_struct
id|ref
op_star
id|next
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|ref_map
suffix:semicolon
id|ref_map
op_assign
id|ref_map-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ref_map-&gt;peer_ref
)paren
r_continue
suffix:semicolon
id|posn
op_assign
op_amp
id|ref_map-&gt;next
suffix:semicolon
r_while
c_loop
(paren
op_star
id|posn
)paren
(brace
r_if
c_cond
(paren
(paren
op_star
id|posn
)paren
op_member_access_from_pointer
id|peer_ref
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
(paren
op_star
id|posn
)paren
op_member_access_from_pointer
id|peer_ref-&gt;name
comma
id|ref_map-&gt;peer_ref-&gt;name
)paren
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
(paren
op_star
id|posn
)paren
op_member_access_from_pointer
id|name
comma
id|ref_map-&gt;name
)paren
)paren
id|die
c_func
(paren
l_string|&quot;%s tracks both %s and %s&quot;
comma
id|ref_map-&gt;peer_ref-&gt;name
comma
(paren
op_star
id|posn
)paren
op_member_access_from_pointer
id|name
comma
id|ref_map-&gt;name
)paren
suffix:semicolon
id|next
op_assign
(paren
op_star
id|posn
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
id|free
c_func
(paren
(paren
op_star
id|posn
)paren
op_member_access_from_pointer
id|peer_ref
)paren
suffix:semicolon
id|free
c_func
(paren
op_star
id|posn
)paren
suffix:semicolon
op_star
id|posn
op_assign
id|next
suffix:semicolon
)brace
r_else
(brace
id|posn
op_assign
op_amp
(paren
op_star
id|posn
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
)brace
)brace
)brace
)brace
DECL|function|remote_has_url
r_int
id|remote_has_url
c_func
(paren
r_struct
id|remote
op_star
id|remote
comma
r_const
r_char
op_star
id|url
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|remote-&gt;url_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|remote-&gt;url
(braket
id|i
)braket
comma
id|url
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|remote_find_tracking
r_int
id|remote_find_tracking
c_func
(paren
r_struct
id|remote
op_star
id|remote
comma
r_struct
id|refspec
op_star
id|refspec
)paren
(brace
r_int
id|find_src
op_assign
id|refspec-&gt;src
op_eq
l_int|NULL
suffix:semicolon
r_char
op_star
id|needle
comma
op_star
op_star
id|result
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|find_src
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|refspec-&gt;dst
)paren
r_return
id|error
c_func
(paren
l_string|&quot;find_tracking: need either src or dst&quot;
)paren
suffix:semicolon
id|needle
op_assign
id|refspec-&gt;dst
suffix:semicolon
id|result
op_assign
op_amp
id|refspec-&gt;src
suffix:semicolon
)brace
r_else
(brace
id|needle
op_assign
id|refspec-&gt;src
suffix:semicolon
id|result
op_assign
op_amp
id|refspec-&gt;dst
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|remote-&gt;fetch_refspec_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|refspec
op_star
id|fetch
op_assign
op_amp
id|remote-&gt;fetch
(braket
id|i
)braket
suffix:semicolon
r_const
r_char
op_star
id|key
op_assign
id|find_src
ques
c_cond
id|fetch-&gt;dst
suffix:colon
id|fetch-&gt;src
suffix:semicolon
r_const
r_char
op_star
id|value
op_assign
id|find_src
ques
c_cond
id|fetch-&gt;src
suffix:colon
id|fetch-&gt;dst
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fetch-&gt;dst
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|fetch-&gt;pattern
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|needle
comma
id|key
)paren
op_logical_and
id|needle
(braket
id|strlen
c_func
(paren
id|key
)paren
)braket
op_eq
l_char|&squot;/&squot;
)paren
(brace
op_star
id|result
op_assign
id|xmalloc
c_func
(paren
id|strlen
c_func
(paren
id|value
)paren
op_plus
id|strlen
c_func
(paren
id|needle
)paren
id|strlen
c_func
(paren
id|key
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|strcpy
c_func
(paren
op_star
id|result
comma
id|value
)paren
suffix:semicolon
id|strcpy
c_func
(paren
op_star
id|result
op_plus
id|strlen
c_func
(paren
id|value
)paren
comma
id|needle
op_plus
id|strlen
c_func
(paren
id|key
)paren
)paren
suffix:semicolon
id|refspec-&gt;force
op_assign
id|fetch-&gt;force
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|needle
comma
id|key
)paren
)paren
(brace
op_star
id|result
op_assign
id|xstrdup
c_func
(paren
id|value
)paren
suffix:semicolon
id|refspec-&gt;force
op_assign
id|fetch-&gt;force
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|alloc_ref
r_struct
id|ref
op_star
id|alloc_ref
c_func
(paren
r_int
id|namelen
)paren
(brace
r_struct
id|ref
op_star
id|ret
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ref
)paren
op_plus
id|namelen
)paren
suffix:semicolon
id|memset
c_func
(paren
id|ret
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ref
)paren
op_plus
id|namelen
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|alloc_ref_from_str
r_struct
id|ref
op_star
id|alloc_ref_from_str
c_func
(paren
r_const
r_char
op_star
id|str
)paren
(brace
r_struct
id|ref
op_star
id|ret
op_assign
id|alloc_ref
c_func
(paren
id|strlen
c_func
(paren
id|str
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|ret-&gt;name
comma
id|str
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|copy_ref
r_static
r_struct
id|ref
op_star
id|copy_ref
c_func
(paren
r_const
r_struct
id|ref
op_star
id|ref
)paren
(brace
r_struct
id|ref
op_star
id|ret
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ref
)paren
op_plus
id|strlen
c_func
(paren
id|ref-&gt;name
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ret
comma
id|ref
comma
r_sizeof
(paren
r_struct
id|ref
)paren
op_plus
id|strlen
c_func
(paren
id|ref-&gt;name
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|ret-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|copy_ref_list
r_struct
id|ref
op_star
id|copy_ref_list
c_func
(paren
r_const
r_struct
id|ref
op_star
id|ref
)paren
(brace
r_struct
id|ref
op_star
id|ret
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|ref
op_star
op_star
id|tail
op_assign
op_amp
id|ret
suffix:semicolon
r_while
c_loop
(paren
id|ref
)paren
(brace
op_star
id|tail
op_assign
id|copy_ref
c_func
(paren
id|ref
)paren
suffix:semicolon
id|ref
op_assign
id|ref-&gt;next
suffix:semicolon
id|tail
op_assign
op_amp
(paren
(paren
op_star
id|tail
)paren
op_member_access_from_pointer
id|next
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|free_ref
r_void
id|free_ref
c_func
(paren
r_struct
id|ref
op_star
id|ref
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ref
)paren
r_return
suffix:semicolon
id|free
c_func
(paren
id|ref-&gt;remote_status
)paren
suffix:semicolon
id|free
c_func
(paren
id|ref-&gt;symref
)paren
suffix:semicolon
id|free
c_func
(paren
id|ref
)paren
suffix:semicolon
)brace
DECL|function|free_refs
r_void
id|free_refs
c_func
(paren
r_struct
id|ref
op_star
id|ref
)paren
(brace
r_struct
id|ref
op_star
id|next
suffix:semicolon
r_while
c_loop
(paren
id|ref
)paren
(brace
id|next
op_assign
id|ref-&gt;next
suffix:semicolon
id|free
c_func
(paren
id|ref-&gt;peer_ref
)paren
suffix:semicolon
id|free_ref
c_func
(paren
id|ref
)paren
suffix:semicolon
id|ref
op_assign
id|next
suffix:semicolon
)brace
)brace
DECL|function|count_refspec_match
r_static
r_int
id|count_refspec_match
c_func
(paren
r_const
r_char
op_star
id|pattern
comma
r_struct
id|ref
op_star
id|refs
comma
r_struct
id|ref
op_star
op_star
id|matched_ref
)paren
(brace
r_int
id|patlen
op_assign
id|strlen
c_func
(paren
id|pattern
)paren
suffix:semicolon
r_struct
id|ref
op_star
id|matched_weak
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|ref
op_star
id|matched
op_assign
l_int|NULL
suffix:semicolon
r_int
id|weak_match
op_assign
l_int|0
suffix:semicolon
r_int
id|match
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|weak_match
op_assign
id|match
op_assign
l_int|0
suffix:semicolon
id|refs
suffix:semicolon
id|refs
op_assign
id|refs-&gt;next
)paren
(brace
r_char
op_star
id|name
op_assign
id|refs-&gt;name
suffix:semicolon
r_int
id|namelen
op_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|refname_match
c_func
(paren
id|pattern
comma
id|name
comma
id|ref_rev_parse_rules
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* A match is &quot;weak&quot; if it is with refs outside&n;&t;&t; * heads or tags, and did not specify the pattern&n;&t;&t; * in full (e.g. &quot;refs/remotes/origin/master&quot;) or at&n;&t;&t; * least from the toplevel (e.g. &quot;remotes/origin/master&quot;);&n;&t;&t; * otherwise &quot;git push $URL master&quot; would result in&n;&t;&t; * ambiguity between remotes/origin/master and heads/master&n;&t;&t; * at the remote site.&n;&t;&t; */
r_if
c_cond
(paren
id|namelen
op_ne
id|patlen
op_logical_and
id|patlen
op_ne
id|namelen
l_int|5
op_logical_and
id|prefixcmp
c_func
(paren
id|name
comma
l_string|&quot;refs/heads/&quot;
)paren
op_logical_and
id|prefixcmp
c_func
(paren
id|name
comma
l_string|&quot;refs/tags/&quot;
)paren
)paren
(brace
multiline_comment|/* We want to catch the case where only weak&n;&t;&t;&t; * matches are found and there are multiple&n;&t;&t;&t; * matches, and where more than one strong&n;&t;&t;&t; * matches are found, as ambiguous.  One&n;&t;&t;&t; * strong match with zero or more weak matches&n;&t;&t;&t; * are acceptable as a unique match.&n;&t;&t;&t; */
id|matched_weak
op_assign
id|refs
suffix:semicolon
id|weak_match
op_increment
suffix:semicolon
)brace
r_else
(brace
id|matched
op_assign
id|refs
suffix:semicolon
id|match
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|matched
)paren
(brace
op_star
id|matched_ref
op_assign
id|matched_weak
suffix:semicolon
r_return
id|weak_match
suffix:semicolon
)brace
r_else
(brace
op_star
id|matched_ref
op_assign
id|matched
suffix:semicolon
r_return
id|match
suffix:semicolon
)brace
)brace
DECL|function|tail_link_ref
r_static
r_void
id|tail_link_ref
c_func
(paren
r_struct
id|ref
op_star
id|ref
comma
r_struct
id|ref
op_star
op_star
op_star
id|tail
)paren
(brace
op_star
op_star
id|tail
op_assign
id|ref
suffix:semicolon
r_while
c_loop
(paren
id|ref-&gt;next
)paren
id|ref
op_assign
id|ref-&gt;next
suffix:semicolon
op_star
id|tail
op_assign
op_amp
id|ref-&gt;next
suffix:semicolon
)brace
DECL|function|try_explicit_object_name
r_static
r_struct
id|ref
op_star
id|try_explicit_object_name
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_struct
id|ref
op_star
id|ref
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|name
)paren
(brace
id|ref
op_assign
id|alloc_ref
c_func
(paren
l_int|20
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|ref-&gt;name
comma
l_string|&quot;(delete)&quot;
)paren
suffix:semicolon
id|hashclr
c_func
(paren
id|ref-&gt;new_sha1
)paren
suffix:semicolon
r_return
id|ref
suffix:semicolon
)brace
r_if
c_cond
(paren
id|get_sha1
c_func
(paren
id|name
comma
id|sha1
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|ref
op_assign
id|alloc_ref_from_str
c_func
(paren
id|name
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|ref-&gt;new_sha1
comma
id|sha1
)paren
suffix:semicolon
r_return
id|ref
suffix:semicolon
)brace
DECL|function|make_linked_ref
r_static
r_struct
id|ref
op_star
id|make_linked_ref
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_struct
id|ref
op_star
op_star
op_star
id|tail
)paren
(brace
r_struct
id|ref
op_star
id|ret
op_assign
id|alloc_ref_from_str
c_func
(paren
id|name
)paren
suffix:semicolon
id|tail_link_ref
c_func
(paren
id|ret
comma
id|tail
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|guess_ref
r_static
r_char
op_star
id|guess_ref
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_struct
id|ref
op_star
id|peer
)paren
(brace
r_struct
id|strbuf
id|buf
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_const
r_char
op_star
id|r
op_assign
id|resolve_ref
c_func
(paren
id|peer-&gt;name
comma
id|sha1
comma
l_int|1
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|r
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|r
comma
l_string|&quot;refs/heads/&quot;
)paren
)paren
id|strbuf_addstr
c_func
(paren
op_amp
id|buf
comma
l_string|&quot;refs/heads/&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|r
comma
l_string|&quot;refs/tags/&quot;
)paren
)paren
id|strbuf_addstr
c_func
(paren
op_amp
id|buf
comma
l_string|&quot;refs/tags/&quot;
)paren
suffix:semicolon
r_else
r_return
l_int|NULL
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|buf
comma
id|name
)paren
suffix:semicolon
r_return
id|strbuf_detach
c_func
(paren
op_amp
id|buf
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|match_explicit
r_static
r_int
id|match_explicit
c_func
(paren
r_struct
id|ref
op_star
id|src
comma
r_struct
id|ref
op_star
id|dst
comma
r_struct
id|ref
op_star
op_star
op_star
id|dst_tail
comma
r_struct
id|refspec
op_star
id|rs
)paren
(brace
r_struct
id|ref
op_star
id|matched_src
comma
op_star
id|matched_dst
suffix:semicolon
r_const
r_char
op_star
id|dst_value
op_assign
id|rs-&gt;dst
suffix:semicolon
r_char
op_star
id|dst_guess
suffix:semicolon
r_if
c_cond
(paren
id|rs-&gt;pattern
op_logical_or
id|rs-&gt;matching
)paren
r_return
l_int|0
suffix:semicolon
id|matched_src
op_assign
id|matched_dst
op_assign
l_int|NULL
suffix:semicolon
r_switch
c_cond
(paren
id|count_refspec_match
c_func
(paren
id|rs-&gt;src
comma
id|src
comma
op_amp
id|matched_src
)paren
)paren
(brace
r_case
l_int|1
suffix:colon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
multiline_comment|/* The source could be in the get_sha1() format&n;&t;&t; * not a reference name.  :refs/other is a&n;&t;&t; * way to delete &squot;other&squot; ref at the remote end.&n;&t;&t; */
id|matched_src
op_assign
id|try_explicit_object_name
c_func
(paren
id|rs-&gt;src
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|matched_src
)paren
r_return
id|error
c_func
(paren
l_string|&quot;src refspec %s does not match any.&quot;
comma
id|rs-&gt;src
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
id|error
c_func
(paren
l_string|&quot;src refspec %s matches more than one.&quot;
comma
id|rs-&gt;src
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|dst_value
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_int
id|flag
suffix:semicolon
id|dst_value
op_assign
id|resolve_ref
c_func
(paren
id|matched_src-&gt;name
comma
id|sha1
comma
l_int|1
comma
op_amp
id|flag
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dst_value
op_logical_or
(paren
(paren
id|flag
op_amp
id|REF_ISSYMREF
)paren
op_logical_and
id|prefixcmp
c_func
(paren
id|dst_value
comma
l_string|&quot;refs/heads/&quot;
)paren
)paren
)paren
id|die
c_func
(paren
l_string|&quot;%s cannot be resolved to branch.&quot;
comma
id|matched_src-&gt;name
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|count_refspec_match
c_func
(paren
id|dst_value
comma
id|dst
comma
op_amp
id|matched_dst
)paren
)paren
(brace
r_case
l_int|1
suffix:colon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|dst_value
comma
l_string|&quot;refs/&quot;
comma
l_int|5
)paren
)paren
id|matched_dst
op_assign
id|make_linked_ref
c_func
(paren
id|dst_value
comma
id|dst_tail
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|dst_guess
op_assign
id|guess_ref
c_func
(paren
id|dst_value
comma
id|matched_src
)paren
)paren
)paren
(brace
id|matched_dst
op_assign
id|make_linked_ref
c_func
(paren
id|dst_guess
comma
id|dst_tail
)paren
suffix:semicolon
)brace
r_else
id|error
c_func
(paren
l_string|&quot;unable to push to unqualified destination: %s&bslash;n&quot;
l_string|&quot;The destination refspec neither matches an &quot;
l_string|&quot;existing ref on the remote nor&bslash;n&quot;
l_string|&quot;begins with refs/, and we are unable to &quot;
l_string|&quot;guess a prefix based on the source ref.&quot;
comma
id|dst_value
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|matched_dst
op_assign
l_int|NULL
suffix:semicolon
id|error
c_func
(paren
l_string|&quot;dst refspec %s matches more than one.&quot;
comma
id|dst_value
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|matched_dst
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|matched_dst-&gt;peer_ref
)paren
r_return
id|error
c_func
(paren
l_string|&quot;dst ref %s receives from more than one src.&quot;
comma
id|matched_dst-&gt;name
)paren
suffix:semicolon
r_else
(brace
id|matched_dst-&gt;peer_ref
op_assign
id|matched_src
suffix:semicolon
id|matched_dst-&gt;force
op_assign
id|rs-&gt;force
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|match_explicit_refs
r_static
r_int
id|match_explicit_refs
c_func
(paren
r_struct
id|ref
op_star
id|src
comma
r_struct
id|ref
op_star
id|dst
comma
r_struct
id|ref
op_star
op_star
op_star
id|dst_tail
comma
r_struct
id|refspec
op_star
id|rs
comma
r_int
id|rs_nr
)paren
(brace
r_int
id|i
comma
id|errs
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|errs
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|rs_nr
suffix:semicolon
id|i
op_increment
)paren
id|errs
op_add_assign
id|match_explicit
c_func
(paren
id|src
comma
id|dst
comma
id|dst_tail
comma
op_amp
id|rs
(braket
id|i
)braket
)paren
suffix:semicolon
r_return
id|errs
suffix:semicolon
)brace
DECL|function|check_pattern_match
r_static
r_const
r_struct
id|refspec
op_star
id|check_pattern_match
c_func
(paren
r_const
r_struct
id|refspec
op_star
id|rs
comma
r_int
id|rs_nr
comma
r_const
r_struct
id|ref
op_star
id|src
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|matching_refs
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|rs_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|rs
(braket
id|i
)braket
dot
id|matching
op_logical_and
(paren
id|matching_refs
op_eq
l_int|1
op_logical_or
id|rs
(braket
id|i
)braket
dot
id|force
)paren
)paren
(brace
id|matching_refs
op_assign
id|i
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rs
(braket
id|i
)braket
dot
id|pattern
op_logical_and
op_logical_neg
id|prefixcmp
c_func
(paren
id|src-&gt;name
comma
id|rs
(braket
id|i
)braket
dot
id|src
)paren
op_logical_and
id|src-&gt;name
(braket
id|strlen
c_func
(paren
id|rs
(braket
id|i
)braket
dot
id|src
)paren
)braket
op_eq
l_char|&squot;/&squot;
)paren
r_return
id|rs
op_plus
id|i
suffix:semicolon
)brace
r_if
c_cond
(paren
id|matching_refs
op_ne
l_int|1
)paren
r_return
id|rs
op_plus
id|matching_refs
suffix:semicolon
r_else
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Note. This is used only by &quot;push&quot;; refspec matching rules for&n; * push and fetch are subtly different, so do not try to reuse it&n; * without thinking.&n; */
DECL|function|match_refs
r_int
id|match_refs
c_func
(paren
r_struct
id|ref
op_star
id|src
comma
r_struct
id|ref
op_star
id|dst
comma
r_struct
id|ref
op_star
op_star
op_star
id|dst_tail
comma
r_int
id|nr_refspec
comma
r_const
r_char
op_star
op_star
id|refspec
comma
r_int
id|flags
)paren
(brace
r_struct
id|refspec
op_star
id|rs
suffix:semicolon
r_int
id|send_all
op_assign
id|flags
op_amp
id|MATCH_REFS_ALL
suffix:semicolon
r_int
id|send_mirror
op_assign
id|flags
op_amp
id|MATCH_REFS_MIRROR
suffix:semicolon
r_static
r_const
r_char
op_star
id|default_refspec
(braket
)braket
op_assign
(brace
l_string|&quot;:&quot;
comma
l_int|0
)brace
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nr_refspec
)paren
(brace
id|nr_refspec
op_assign
l_int|1
suffix:semicolon
id|refspec
op_assign
id|default_refspec
suffix:semicolon
)brace
id|rs
op_assign
id|parse_push_refspec
c_func
(paren
id|nr_refspec
comma
(paren
r_const
r_char
op_star
op_star
)paren
id|refspec
)paren
suffix:semicolon
r_if
c_cond
(paren
id|match_explicit_refs
c_func
(paren
id|src
comma
id|dst
comma
id|dst_tail
comma
id|rs
comma
id|nr_refspec
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* pick the remainder */
r_for
c_loop
(paren
suffix:semicolon
id|src
suffix:semicolon
id|src
op_assign
id|src-&gt;next
)paren
(brace
r_struct
id|ref
op_star
id|dst_peer
suffix:semicolon
r_const
r_struct
id|refspec
op_star
id|pat
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
id|dst_name
suffix:semicolon
r_if
c_cond
(paren
id|src-&gt;peer_ref
)paren
r_continue
suffix:semicolon
id|pat
op_assign
id|check_pattern_match
c_func
(paren
id|rs
comma
id|nr_refspec
comma
id|src
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pat
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|pat-&gt;matching
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * &quot;matching refs&quot;; traditionally we pushed everything&n;&t;&t;&t; * including refs outside refs/heads/ hierarchy, but&n;&t;&t;&t; * that does not make much sense these days.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|send_mirror
op_logical_and
id|prefixcmp
c_func
(paren
id|src-&gt;name
comma
l_string|&quot;refs/heads/&quot;
)paren
)paren
r_continue
suffix:semicolon
id|dst_name
op_assign
id|xstrdup
c_func
(paren
id|src-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
r_const
r_char
op_star
id|dst_side
op_assign
id|pat-&gt;dst
ques
c_cond
id|pat-&gt;dst
suffix:colon
id|pat-&gt;src
suffix:semicolon
id|dst_name
op_assign
id|xmalloc
c_func
(paren
id|strlen
c_func
(paren
id|dst_side
)paren
op_plus
id|strlen
c_func
(paren
id|src-&gt;name
)paren
id|strlen
c_func
(paren
id|pat-&gt;src
)paren
op_plus
l_int|2
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|dst_name
comma
id|dst_side
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|dst_name
comma
id|src-&gt;name
op_plus
id|strlen
c_func
(paren
id|pat-&gt;src
)paren
)paren
suffix:semicolon
)brace
id|dst_peer
op_assign
id|find_ref_by_name
c_func
(paren
id|dst
comma
id|dst_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dst_peer
)paren
(brace
r_if
c_cond
(paren
id|dst_peer-&gt;peer_ref
)paren
multiline_comment|/* We&squot;re already sending something to this ref. */
r_goto
id|free_name
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|pat-&gt;matching
op_logical_and
op_logical_neg
(paren
id|send_all
op_logical_or
id|send_mirror
)paren
)paren
multiline_comment|/*&n;&t;&t;&t;&t; * Remote doesn&squot;t have it, and we have no&n;&t;&t;&t;&t; * explicit pattern, and we don&squot;t have&n;&t;&t;&t;&t; * --all nor --mirror.&n;&t;&t;&t;&t; */
r_goto
id|free_name
suffix:semicolon
multiline_comment|/* Create a new one and link it */
id|dst_peer
op_assign
id|make_linked_ref
c_func
(paren
id|dst_name
comma
id|dst_tail
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|dst_peer-&gt;new_sha1
comma
id|src-&gt;new_sha1
)paren
suffix:semicolon
)brace
id|dst_peer-&gt;peer_ref
op_assign
id|src
suffix:semicolon
id|dst_peer-&gt;force
op_assign
id|pat-&gt;force
suffix:semicolon
id|free_name
suffix:colon
id|free
c_func
(paren
id|dst_name
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|branch_get
r_struct
id|branch
op_star
id|branch_get
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|branch
op_star
id|ret
suffix:semicolon
id|read_config
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|name
op_logical_or
op_logical_neg
op_star
id|name
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;HEAD&quot;
)paren
)paren
id|ret
op_assign
id|current_branch
suffix:semicolon
r_else
id|ret
op_assign
id|make_branch
c_func
(paren
id|name
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_logical_and
id|ret-&gt;remote_name
)paren
(brace
id|ret-&gt;remote
op_assign
id|remote_get
c_func
(paren
id|ret-&gt;remote_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret-&gt;merge_nr
)paren
(brace
r_int
id|i
suffix:semicolon
id|ret-&gt;merge
op_assign
id|xcalloc
c_func
(paren
r_sizeof
(paren
op_star
id|ret-&gt;merge
)paren
comma
id|ret-&gt;merge_nr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ret-&gt;merge_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ret-&gt;merge
(braket
id|i
)braket
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
op_star
id|ret-&gt;merge
)paren
)paren
suffix:semicolon
id|ret-&gt;merge
(braket
id|i
)braket
op_member_access_from_pointer
id|src
op_assign
id|xstrdup
c_func
(paren
id|ret-&gt;merge_name
(braket
id|i
)braket
)paren
suffix:semicolon
id|remote_find_tracking
c_func
(paren
id|ret-&gt;remote
comma
id|ret-&gt;merge
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|branch_has_merge_config
r_int
id|branch_has_merge_config
c_func
(paren
r_struct
id|branch
op_star
id|branch
)paren
(brace
r_return
id|branch
op_logical_and
op_logical_neg
op_logical_neg
id|branch-&gt;merge
suffix:semicolon
)brace
DECL|function|branch_merge_matches
r_int
id|branch_merge_matches
c_func
(paren
r_struct
id|branch
op_star
id|branch
comma
r_int
id|i
comma
r_const
r_char
op_star
id|refname
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|branch
op_logical_or
id|i
OL
l_int|0
op_logical_or
id|i
op_ge
id|branch-&gt;merge_nr
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|refname_match
c_func
(paren
id|branch-&gt;merge
(braket
id|i
)braket
op_member_access_from_pointer
id|src
comma
id|refname
comma
id|ref_fetch_rules
)paren
suffix:semicolon
)brace
DECL|function|get_expanded_map
r_static
r_struct
id|ref
op_star
id|get_expanded_map
c_func
(paren
r_const
r_struct
id|ref
op_star
id|remote_refs
comma
r_const
r_struct
id|refspec
op_star
id|refspec
)paren
(brace
r_const
r_struct
id|ref
op_star
id|ref
suffix:semicolon
r_struct
id|ref
op_star
id|ret
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|ref
op_star
op_star
id|tail
op_assign
op_amp
id|ret
suffix:semicolon
r_int
id|remote_prefix_len
op_assign
id|strlen
c_func
(paren
id|refspec-&gt;src
)paren
suffix:semicolon
r_int
id|local_prefix_len
op_assign
id|strlen
c_func
(paren
id|refspec-&gt;dst
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ref
op_assign
id|remote_refs
suffix:semicolon
id|ref
suffix:semicolon
id|ref
op_assign
id|ref-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|strchr
c_func
(paren
id|ref-&gt;name
comma
l_char|&squot;^&squot;
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* a dereference item */
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|ref-&gt;name
comma
id|refspec-&gt;src
)paren
)paren
(brace
r_const
r_char
op_star
id|match
suffix:semicolon
r_struct
id|ref
op_star
id|cpy
op_assign
id|copy_ref
c_func
(paren
id|ref
)paren
suffix:semicolon
id|match
op_assign
id|ref-&gt;name
op_plus
id|remote_prefix_len
suffix:semicolon
id|cpy-&gt;peer_ref
op_assign
id|alloc_ref
c_func
(paren
id|local_prefix_len
op_plus
id|strlen
c_func
(paren
id|match
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|cpy-&gt;peer_ref-&gt;name
comma
l_string|&quot;%s%s&quot;
comma
id|refspec-&gt;dst
comma
id|match
)paren
suffix:semicolon
r_if
c_cond
(paren
id|refspec-&gt;force
)paren
id|cpy-&gt;peer_ref-&gt;force
op_assign
l_int|1
suffix:semicolon
op_star
id|tail
op_assign
id|cpy
suffix:semicolon
id|tail
op_assign
op_amp
id|cpy-&gt;next
suffix:semicolon
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|find_ref_by_name_abbrev
r_static
r_const
r_struct
id|ref
op_star
id|find_ref_by_name_abbrev
c_func
(paren
r_const
r_struct
id|ref
op_star
id|refs
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_const
r_struct
id|ref
op_star
id|ref
suffix:semicolon
r_for
c_loop
(paren
id|ref
op_assign
id|refs
suffix:semicolon
id|ref
suffix:semicolon
id|ref
op_assign
id|ref-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|refname_match
c_func
(paren
id|name
comma
id|ref-&gt;name
comma
id|ref_fetch_rules
)paren
)paren
r_return
id|ref
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|get_remote_ref
r_struct
id|ref
op_star
id|get_remote_ref
c_func
(paren
r_const
r_struct
id|ref
op_star
id|remote_refs
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_const
r_struct
id|ref
op_star
id|ref
op_assign
id|find_ref_by_name_abbrev
c_func
(paren
id|remote_refs
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ref
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|copy_ref
c_func
(paren
id|ref
)paren
suffix:semicolon
)brace
DECL|function|get_local_ref
r_static
r_struct
id|ref
op_star
id|get_local_ref
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|ref
op_star
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|name
comma
l_string|&quot;refs/&quot;
)paren
)paren
(brace
r_return
id|alloc_ref_from_str
c_func
(paren
id|name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|name
comma
l_string|&quot;heads/&quot;
)paren
op_logical_or
op_logical_neg
id|prefixcmp
c_func
(paren
id|name
comma
l_string|&quot;tags/&quot;
)paren
op_logical_or
op_logical_neg
id|prefixcmp
c_func
(paren
id|name
comma
l_string|&quot;remotes/&quot;
)paren
)paren
(brace
id|ret
op_assign
id|alloc_ref
c_func
(paren
id|strlen
c_func
(paren
id|name
)paren
op_plus
l_int|6
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|ret-&gt;name
comma
l_string|&quot;refs/%s&quot;
comma
id|name
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|ret
op_assign
id|alloc_ref
c_func
(paren
id|strlen
c_func
(paren
id|name
)paren
op_plus
l_int|12
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|ret-&gt;name
comma
l_string|&quot;refs/heads/%s&quot;
comma
id|name
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|get_fetch_map
r_int
id|get_fetch_map
c_func
(paren
r_const
r_struct
id|ref
op_star
id|remote_refs
comma
r_const
r_struct
id|refspec
op_star
id|refspec
comma
r_struct
id|ref
op_star
op_star
op_star
id|tail
comma
r_int
id|missing_ok
)paren
(brace
r_struct
id|ref
op_star
id|ref_map
comma
op_star
op_star
id|rmp
suffix:semicolon
r_if
c_cond
(paren
id|refspec-&gt;pattern
)paren
(brace
id|ref_map
op_assign
id|get_expanded_map
c_func
(paren
id|remote_refs
comma
id|refspec
)paren
suffix:semicolon
)brace
r_else
(brace
r_const
r_char
op_star
id|name
op_assign
id|refspec-&gt;src
(braket
l_int|0
)braket
ques
c_cond
id|refspec-&gt;src
suffix:colon
l_string|&quot;HEAD&quot;
suffix:semicolon
id|ref_map
op_assign
id|get_remote_ref
c_func
(paren
id|remote_refs
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|missing_ok
op_logical_and
op_logical_neg
id|ref_map
)paren
id|die
c_func
(paren
l_string|&quot;Couldn&squot;t find remote ref %s&quot;
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ref_map
)paren
(brace
id|ref_map-&gt;peer_ref
op_assign
id|get_local_ref
c_func
(paren
id|refspec-&gt;dst
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ref_map-&gt;peer_ref
op_logical_and
id|refspec-&gt;force
)paren
id|ref_map-&gt;peer_ref-&gt;force
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|rmp
op_assign
op_amp
id|ref_map
suffix:semicolon
op_star
id|rmp
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
(paren
op_star
id|rmp
)paren
op_member_access_from_pointer
id|peer_ref
)paren
(brace
r_int
id|st
op_assign
id|check_ref_format
c_func
(paren
(paren
op_star
id|rmp
)paren
op_member_access_from_pointer
id|peer_ref-&gt;name
op_plus
l_int|5
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
op_logical_and
id|st
op_ne
id|CHECK_REF_FORMAT_ONELEVEL
)paren
(brace
r_struct
id|ref
op_star
id|ignore
op_assign
op_star
id|rmp
suffix:semicolon
id|error
c_func
(paren
l_string|&quot;* Ignoring funny ref &squot;%s&squot; locally&quot;
comma
(paren
op_star
id|rmp
)paren
op_member_access_from_pointer
id|peer_ref-&gt;name
)paren
suffix:semicolon
op_star
id|rmp
op_assign
(paren
op_star
id|rmp
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
id|free
c_func
(paren
id|ignore-&gt;peer_ref
)paren
suffix:semicolon
id|free
c_func
(paren
id|ignore
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
id|rmp
op_assign
op_amp
(paren
(paren
op_star
id|rmp
)paren
op_member_access_from_pointer
id|next
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ref_map
)paren
id|tail_link_ref
c_func
(paren
id|ref_map
comma
id|tail
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|resolve_remote_symref
r_int
id|resolve_remote_symref
c_func
(paren
r_struct
id|ref
op_star
id|ref
comma
r_struct
id|ref
op_star
id|list
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ref-&gt;symref
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|list
suffix:semicolon
id|list
op_assign
id|list-&gt;next
)paren
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|ref-&gt;symref
comma
id|list-&gt;name
)paren
)paren
(brace
id|hashcpy
c_func
(paren
id|ref-&gt;old_sha1
comma
id|list-&gt;old_sha1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
eof
