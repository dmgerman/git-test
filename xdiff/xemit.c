multiline_comment|/*&n; *  LibXDiff by Davide Libenzi ( File Differential Library )&n; *  Copyright (C) 2003&t;Davide Libenzi&n; *&n; *  This library is free software; you can redistribute it and/or&n; *  modify it under the terms of the GNU Lesser General Public&n; *  License as published by the Free Software Foundation; either&n; *  version 2.1 of the License, or (at your option) any later version.&n; *&n; *  This library is distributed in the hope that it will be useful,&n; *  but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n; *  Lesser General Public License for more details.&n; *&n; *  You should have received a copy of the GNU Lesser General Public&n; *  License along with this library; if not, write to the Free Software&n; *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; *&n; *  Davide Libenzi &lt;davidel@xmailserver.org&gt;&n; *&n; */
macro_line|#include &quot;xinclude.h&quot;
r_static
r_int
id|xdl_get_rec
c_func
(paren
id|xdfile_t
op_star
id|xdf
comma
r_int
id|ri
comma
r_char
r_const
op_star
op_star
id|rec
)paren
suffix:semicolon
r_static
r_int
id|xdl_emit_record
c_func
(paren
id|xdfile_t
op_star
id|xdf
comma
r_int
id|ri
comma
r_char
r_const
op_star
id|pre
comma
id|xdemitcb_t
op_star
id|ecb
)paren
suffix:semicolon
DECL|function|xdl_get_rec
r_static
r_int
id|xdl_get_rec
c_func
(paren
id|xdfile_t
op_star
id|xdf
comma
r_int
id|ri
comma
r_char
r_const
op_star
op_star
id|rec
)paren
(brace
op_star
id|rec
op_assign
id|xdf-&gt;recs
(braket
id|ri
)braket
op_member_access_from_pointer
id|ptr
suffix:semicolon
r_return
id|xdf-&gt;recs
(braket
id|ri
)braket
op_member_access_from_pointer
id|size
suffix:semicolon
)brace
DECL|function|xdl_emit_record
r_static
r_int
id|xdl_emit_record
c_func
(paren
id|xdfile_t
op_star
id|xdf
comma
r_int
id|ri
comma
r_char
r_const
op_star
id|pre
comma
id|xdemitcb_t
op_star
id|ecb
)paren
(brace
r_int
id|size
comma
id|psize
op_assign
id|strlen
c_func
(paren
id|pre
)paren
suffix:semicolon
r_char
r_const
op_star
id|rec
suffix:semicolon
id|size
op_assign
id|xdl_get_rec
c_func
(paren
id|xdf
comma
id|ri
comma
op_amp
id|rec
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xdl_emit_diffrec
c_func
(paren
id|rec
comma
id|size
comma
id|pre
comma
id|psize
comma
id|ecb
)paren
OL
l_int|0
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Starting at the passed change atom, find the latest change atom to be included&n; * inside the differential hunk according to the specified configuration.&n; * Also advance xscr if the first changes must be discarded.&n; */
DECL|function|xdl_get_hunk
id|xdchange_t
op_star
id|xdl_get_hunk
c_func
(paren
id|xdchange_t
op_star
op_star
id|xscr
comma
id|xdemitconf_t
r_const
op_star
id|xecfg
)paren
(brace
id|xdchange_t
op_star
id|xch
comma
op_star
id|xchp
comma
op_star
id|lxch
suffix:semicolon
r_int
id|max_common
op_assign
l_int|2
op_star
id|xecfg-&gt;ctxlen
op_plus
id|xecfg-&gt;interhunkctxlen
suffix:semicolon
r_int
id|max_ignorable
op_assign
id|xecfg-&gt;ctxlen
suffix:semicolon
r_int
r_int
id|ignored
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* number of ignored blank lines */
multiline_comment|/* remove ignorable changes that are too far before other changes */
r_for
c_loop
(paren
id|xchp
op_assign
op_star
id|xscr
suffix:semicolon
id|xchp
op_logical_and
id|xchp-&gt;ignore
suffix:semicolon
id|xchp
op_assign
id|xchp-&gt;next
)paren
(brace
id|xch
op_assign
id|xchp-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|xch
op_eq
l_int|NULL
op_logical_or
id|xch-&gt;i1
(paren
id|xchp-&gt;i1
op_plus
id|xchp-&gt;chg1
)paren
op_ge
id|max_ignorable
)paren
op_star
id|xscr
op_assign
id|xch
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|xscr
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|lxch
op_assign
op_star
id|xscr
suffix:semicolon
r_for
c_loop
(paren
id|xchp
op_assign
op_star
id|xscr
comma
id|xch
op_assign
id|xchp-&gt;next
suffix:semicolon
id|xch
suffix:semicolon
id|xchp
op_assign
id|xch
comma
id|xch
op_assign
id|xch-&gt;next
)paren
(brace
r_int
id|distance
op_assign
id|xch-&gt;i1
(paren
id|xchp-&gt;i1
op_plus
id|xchp-&gt;chg1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|distance
OG
id|max_common
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|distance
OL
id|max_ignorable
op_logical_and
(paren
op_logical_neg
id|xch-&gt;ignore
op_logical_or
id|lxch
op_eq
id|xchp
)paren
)paren
(brace
id|lxch
op_assign
id|xch
suffix:semicolon
id|ignored
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|distance
OL
id|max_ignorable
op_logical_and
id|xch-&gt;ignore
)paren
(brace
id|ignored
op_add_assign
id|xch-&gt;chg2
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lxch
op_ne
id|xchp
op_logical_and
id|xch-&gt;i1
op_plus
id|ignored
(paren
id|lxch-&gt;i1
op_plus
id|lxch-&gt;chg1
)paren
OG
id|max_common
)paren
(brace
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|xch-&gt;ignore
)paren
(brace
id|lxch
op_assign
id|xch
suffix:semicolon
id|ignored
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ignored
op_add_assign
id|xch-&gt;chg2
suffix:semicolon
)brace
)brace
r_return
id|lxch
suffix:semicolon
)brace
DECL|function|def_ff
r_static
r_int
id|def_ff
c_func
(paren
r_const
r_char
op_star
id|rec
comma
r_int
id|len
comma
r_char
op_star
id|buf
comma
r_int
id|sz
comma
r_void
op_star
id|priv
)paren
(brace
r_if
c_cond
(paren
id|len
OG
l_int|0
op_logical_and
(paren
id|isalpha
c_func
(paren
(paren
r_int
r_char
)paren
op_star
id|rec
)paren
op_logical_or
multiline_comment|/* identifier? */
op_star
id|rec
op_eq
l_char|&squot;_&squot;
op_logical_or
multiline_comment|/* also identifier? */
op_star
id|rec
op_eq
l_char|&squot;$&squot;
)paren
)paren
(brace
multiline_comment|/* identifiers from VMS and other esoterico */
r_if
c_cond
(paren
id|len
OG
id|sz
)paren
id|len
op_assign
id|sz
suffix:semicolon
r_while
c_loop
(paren
l_int|0
OL
id|len
op_logical_and
id|isspace
c_func
(paren
(paren
r_int
r_char
)paren
id|rec
(braket
id|len
l_int|1
)braket
)paren
)paren
id|len
op_decrement
suffix:semicolon
id|memcpy
c_func
(paren
id|buf
comma
id|rec
comma
id|len
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|xdl_emit_common
r_static
r_int
id|xdl_emit_common
c_func
(paren
id|xdfenv_t
op_star
id|xe
comma
id|xdchange_t
op_star
id|xscr
comma
id|xdemitcb_t
op_star
id|ecb
comma
id|xdemitconf_t
r_const
op_star
id|xecfg
)paren
(brace
id|xdfile_t
op_star
id|xdf
op_assign
op_amp
id|xe-&gt;xdf2
suffix:semicolon
r_const
r_char
op_star
id|rchg
op_assign
id|xdf-&gt;rchg
suffix:semicolon
r_int
id|ix
suffix:semicolon
r_for
c_loop
(paren
id|ix
op_assign
l_int|0
suffix:semicolon
id|ix
OL
id|xdf-&gt;nrec
suffix:semicolon
id|ix
op_increment
)paren
(brace
r_if
c_cond
(paren
id|rchg
(braket
id|ix
)braket
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|xdl_emit_record
c_func
(paren
id|xdf
comma
id|ix
comma
l_string|&quot;&quot;
comma
id|ecb
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|struct|func_line
r_struct
id|func_line
(brace
DECL|member|len
r_int
id|len
suffix:semicolon
DECL|member|buf
r_char
id|buf
(braket
l_int|80
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|function|get_func_line
r_static
r_int
id|get_func_line
c_func
(paren
id|xdfenv_t
op_star
id|xe
comma
id|xdemitconf_t
r_const
op_star
id|xecfg
comma
r_struct
id|func_line
op_star
id|func_line
comma
r_int
id|start
comma
r_int
id|limit
)paren
(brace
id|find_func_t
id|ff
op_assign
id|xecfg-&gt;find_func
ques
c_cond
id|xecfg-&gt;find_func
suffix:colon
id|def_ff
suffix:semicolon
r_int
id|l
comma
id|size
comma
id|step
op_assign
(paren
id|start
OG
id|limit
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|1
suffix:semicolon
r_char
op_star
id|buf
comma
id|dummy
(braket
l_int|1
)braket
suffix:semicolon
id|buf
op_assign
id|func_line
ques
c_cond
id|func_line-&gt;buf
suffix:colon
id|dummy
suffix:semicolon
id|size
op_assign
id|func_line
ques
c_cond
r_sizeof
(paren
id|func_line-&gt;buf
)paren
suffix:colon
r_sizeof
(paren
id|dummy
)paren
suffix:semicolon
r_for
c_loop
(paren
id|l
op_assign
id|start
suffix:semicolon
id|l
op_ne
id|limit
op_logical_and
l_int|0
op_le
id|l
op_logical_and
id|l
OL
id|xe-&gt;xdf1.nrec
suffix:semicolon
id|l
op_add_assign
id|step
)paren
(brace
r_const
r_char
op_star
id|rec
suffix:semicolon
r_int
id|reclen
op_assign
id|xdl_get_rec
c_func
(paren
op_amp
id|xe-&gt;xdf1
comma
id|l
comma
op_amp
id|rec
)paren
suffix:semicolon
r_int
id|len
op_assign
id|ff
c_func
(paren
id|rec
comma
id|reclen
comma
id|buf
comma
id|size
comma
id|xecfg-&gt;find_func_priv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|func_line
)paren
id|func_line-&gt;len
op_assign
id|len
suffix:semicolon
r_return
id|l
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|xdl_emit_diff
r_int
id|xdl_emit_diff
c_func
(paren
id|xdfenv_t
op_star
id|xe
comma
id|xdchange_t
op_star
id|xscr
comma
id|xdemitcb_t
op_star
id|ecb
comma
id|xdemitconf_t
r_const
op_star
id|xecfg
)paren
(brace
r_int
id|s1
comma
id|s2
comma
id|e1
comma
id|e2
comma
id|lctx
suffix:semicolon
id|xdchange_t
op_star
id|xch
comma
op_star
id|xche
suffix:semicolon
r_int
id|funclineprev
op_assign
l_int|1
suffix:semicolon
r_struct
id|func_line
id|func_line
op_assign
(brace
l_int|0
)brace
suffix:semicolon
r_if
c_cond
(paren
id|xecfg-&gt;flags
op_amp
id|XDL_EMIT_COMMON
)paren
r_return
id|xdl_emit_common
c_func
(paren
id|xe
comma
id|xscr
comma
id|ecb
comma
id|xecfg
)paren
suffix:semicolon
r_for
c_loop
(paren
id|xch
op_assign
id|xscr
suffix:semicolon
id|xch
suffix:semicolon
id|xch
op_assign
id|xche-&gt;next
)paren
(brace
id|xche
op_assign
id|xdl_get_hunk
c_func
(paren
op_amp
id|xch
comma
id|xecfg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xch
)paren
r_break
suffix:semicolon
id|s1
op_assign
id|XDL_MAX
c_func
(paren
id|xch-&gt;i1
id|xecfg-&gt;ctxlen
comma
l_int|0
)paren
suffix:semicolon
id|s2
op_assign
id|XDL_MAX
c_func
(paren
id|xch-&gt;i2
id|xecfg-&gt;ctxlen
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xecfg-&gt;flags
op_amp
id|XDL_EMIT_FUNCCONTEXT
)paren
(brace
r_int
id|fs1
op_assign
id|get_func_line
c_func
(paren
id|xe
comma
id|xecfg
comma
l_int|NULL
comma
id|xch-&gt;i1
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fs1
OL
l_int|0
)paren
id|fs1
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|fs1
OL
id|s1
)paren
(brace
id|s2
op_sub_assign
id|s1
id|fs1
suffix:semicolon
id|s1
op_assign
id|fs1
suffix:semicolon
)brace
)brace
id|again
suffix:colon
id|lctx
op_assign
id|xecfg-&gt;ctxlen
suffix:semicolon
id|lctx
op_assign
id|XDL_MIN
c_func
(paren
id|lctx
comma
id|xe-&gt;xdf1.nrec
(paren
id|xche-&gt;i1
op_plus
id|xche-&gt;chg1
)paren
)paren
suffix:semicolon
id|lctx
op_assign
id|XDL_MIN
c_func
(paren
id|lctx
comma
id|xe-&gt;xdf2.nrec
(paren
id|xche-&gt;i2
op_plus
id|xche-&gt;chg2
)paren
)paren
suffix:semicolon
id|e1
op_assign
id|xche-&gt;i1
op_plus
id|xche-&gt;chg1
op_plus
id|lctx
suffix:semicolon
id|e2
op_assign
id|xche-&gt;i2
op_plus
id|xche-&gt;chg2
op_plus
id|lctx
suffix:semicolon
r_if
c_cond
(paren
id|xecfg-&gt;flags
op_amp
id|XDL_EMIT_FUNCCONTEXT
)paren
(brace
r_int
id|fe1
op_assign
id|get_func_line
c_func
(paren
id|xe
comma
id|xecfg
comma
l_int|NULL
comma
id|xche-&gt;i1
op_plus
id|xche-&gt;chg1
comma
id|xe-&gt;xdf1.nrec
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fe1
OL
l_int|0
)paren
id|fe1
op_assign
id|xe-&gt;xdf1.nrec
suffix:semicolon
r_if
c_cond
(paren
id|fe1
OG
id|e1
)paren
(brace
id|e2
op_add_assign
id|fe1
id|e1
suffix:semicolon
id|e1
op_assign
id|fe1
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Overlap with next change?  Then include it&n;&t;&t;&t; * in the current hunk and start over to find&n;&t;&t;&t; * its new end.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|xche-&gt;next
)paren
(brace
r_int
id|l
op_assign
id|xche-&gt;next-&gt;i1
suffix:semicolon
r_if
c_cond
(paren
id|l
op_le
id|e1
op_logical_or
id|get_func_line
c_func
(paren
id|xe
comma
id|xecfg
comma
l_int|NULL
comma
id|l
comma
id|e1
)paren
OL
l_int|0
)paren
(brace
id|xche
op_assign
id|xche-&gt;next
suffix:semicolon
r_goto
id|again
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t;&t; * Emit current hunk header.&n;&t;&t; */
r_if
c_cond
(paren
id|xecfg-&gt;flags
op_amp
id|XDL_EMIT_FUNCNAMES
)paren
(brace
id|get_func_line
c_func
(paren
id|xe
comma
id|xecfg
comma
op_amp
id|func_line
comma
id|s1
l_int|1
comma
id|funclineprev
)paren
suffix:semicolon
id|funclineprev
op_assign
id|s1
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|xdl_emit_hunk_hdr
c_func
(paren
id|s1
op_plus
l_int|1
comma
id|e1
id|s1
comma
id|s2
op_plus
l_int|1
comma
id|e2
id|s2
comma
id|func_line.buf
comma
id|func_line.len
comma
id|ecb
)paren
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Emit pre-context.&n;&t;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|s2
OL
id|xch-&gt;i2
suffix:semicolon
id|s2
op_increment
)paren
r_if
c_cond
(paren
id|xdl_emit_record
c_func
(paren
op_amp
id|xe-&gt;xdf2
comma
id|s2
comma
l_string|&quot; &quot;
comma
id|ecb
)paren
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|s1
op_assign
id|xch-&gt;i1
comma
id|s2
op_assign
id|xch-&gt;i2
suffix:semicolon
suffix:semicolon
id|xch
op_assign
id|xch-&gt;next
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Merge previous with current change atom.&n;&t;&t;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|s1
OL
id|xch-&gt;i1
op_logical_and
id|s2
OL
id|xch-&gt;i2
suffix:semicolon
id|s1
op_increment
comma
id|s2
op_increment
)paren
r_if
c_cond
(paren
id|xdl_emit_record
c_func
(paren
op_amp
id|xe-&gt;xdf2
comma
id|s2
comma
l_string|&quot; &quot;
comma
id|ecb
)paren
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Removes lines from the first file.&n;&t;&t;&t; */
r_for
c_loop
(paren
id|s1
op_assign
id|xch-&gt;i1
suffix:semicolon
id|s1
OL
id|xch-&gt;i1
op_plus
id|xch-&gt;chg1
suffix:semicolon
id|s1
op_increment
)paren
r_if
c_cond
(paren
id|xdl_emit_record
c_func
(paren
op_amp
id|xe-&gt;xdf1
comma
id|s1
comma
l_string|&quot;-&quot;
comma
id|ecb
)paren
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Adds lines from the second file.&n;&t;&t;&t; */
r_for
c_loop
(paren
id|s2
op_assign
id|xch-&gt;i2
suffix:semicolon
id|s2
OL
id|xch-&gt;i2
op_plus
id|xch-&gt;chg2
suffix:semicolon
id|s2
op_increment
)paren
r_if
c_cond
(paren
id|xdl_emit_record
c_func
(paren
op_amp
id|xe-&gt;xdf2
comma
id|s2
comma
l_string|&quot;+&quot;
comma
id|ecb
)paren
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|xch
op_eq
id|xche
)paren
r_break
suffix:semicolon
id|s1
op_assign
id|xch-&gt;i1
op_plus
id|xch-&gt;chg1
suffix:semicolon
id|s2
op_assign
id|xch-&gt;i2
op_plus
id|xch-&gt;chg2
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Emit post-context.&n;&t;&t; */
r_for
c_loop
(paren
id|s2
op_assign
id|xche-&gt;i2
op_plus
id|xche-&gt;chg2
suffix:semicolon
id|s2
OL
id|e2
suffix:semicolon
id|s2
op_increment
)paren
r_if
c_cond
(paren
id|xdl_emit_record
c_func
(paren
op_amp
id|xe-&gt;xdf2
comma
id|s2
comma
l_string|&quot; &quot;
comma
id|ecb
)paren
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
