multiline_comment|/*&n; *  LibXDiff by Davide Libenzi ( File Differential Library )&n; *  Copyright (C) 2003&t;Davide Libenzi&n; *&n; *  This library is free software; you can redistribute it and/or&n; *  modify it under the terms of the GNU Lesser General Public&n; *  License as published by the Free Software Foundation; either&n; *  version 2.1 of the License, or (at your option) any later version.&n; *&n; *  This library is distributed in the hope that it will be useful,&n; *  but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n; *  Lesser General Public License for more details.&n; *&n; *  You should have received a copy of the GNU Lesser General Public&n; *  License along with this library; if not, write to the Free Software&n; *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; *&n; *  Davide Libenzi &lt;davidel@xmailserver.org&gt;&n; *&n; */
macro_line|#include &quot;xinclude.h&quot;
r_static
r_int
id|xdl_get_rec
c_func
(paren
id|xdfile_t
op_star
id|xdf
comma
r_int
id|ri
comma
r_char
r_const
op_star
op_star
id|rec
)paren
suffix:semicolon
r_static
r_int
id|xdl_emit_record
c_func
(paren
id|xdfile_t
op_star
id|xdf
comma
r_int
id|ri
comma
r_char
r_const
op_star
id|pre
comma
id|xdemitcb_t
op_star
id|ecb
)paren
suffix:semicolon
r_static
id|xdchange_t
op_star
id|xdl_get_hunk
c_func
(paren
id|xdchange_t
op_star
id|xscr
comma
id|xdemitconf_t
r_const
op_star
id|xecfg
)paren
suffix:semicolon
DECL|function|xdl_get_rec
r_static
r_int
id|xdl_get_rec
c_func
(paren
id|xdfile_t
op_star
id|xdf
comma
r_int
id|ri
comma
r_char
r_const
op_star
op_star
id|rec
)paren
(brace
op_star
id|rec
op_assign
id|xdf-&gt;recs
(braket
id|ri
)braket
op_member_access_from_pointer
id|ptr
suffix:semicolon
r_return
id|xdf-&gt;recs
(braket
id|ri
)braket
op_member_access_from_pointer
id|size
suffix:semicolon
)brace
DECL|function|xdl_emit_record
r_static
r_int
id|xdl_emit_record
c_func
(paren
id|xdfile_t
op_star
id|xdf
comma
r_int
id|ri
comma
r_char
r_const
op_star
id|pre
comma
id|xdemitcb_t
op_star
id|ecb
)paren
(brace
r_int
id|size
comma
id|psize
op_assign
id|strlen
c_func
(paren
id|pre
)paren
suffix:semicolon
r_char
r_const
op_star
id|rec
suffix:semicolon
id|size
op_assign
id|xdl_get_rec
c_func
(paren
id|xdf
comma
id|ri
comma
op_amp
id|rec
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xdl_emit_diffrec
c_func
(paren
id|rec
comma
id|size
comma
id|pre
comma
id|psize
comma
id|ecb
)paren
OL
l_int|0
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Starting at the passed change atom, find the latest change atom to be included&n; * inside the differential hunk according to the specified configuration.&n; */
DECL|function|xdl_get_hunk
r_static
id|xdchange_t
op_star
id|xdl_get_hunk
c_func
(paren
id|xdchange_t
op_star
id|xscr
comma
id|xdemitconf_t
r_const
op_star
id|xecfg
)paren
(brace
id|xdchange_t
op_star
id|xch
comma
op_star
id|xchp
suffix:semicolon
r_for
c_loop
(paren
id|xchp
op_assign
id|xscr
comma
id|xch
op_assign
id|xscr-&gt;next
suffix:semicolon
id|xch
suffix:semicolon
id|xchp
op_assign
id|xch
comma
id|xch
op_assign
id|xch-&gt;next
)paren
r_if
c_cond
(paren
id|xch-&gt;i1
(paren
id|xchp-&gt;i1
op_plus
id|xchp-&gt;chg1
)paren
OG
l_int|2
op_star
id|xecfg-&gt;ctxlen
)paren
r_break
suffix:semicolon
r_return
id|xchp
suffix:semicolon
)brace
DECL|function|def_ff
r_static
r_int
id|def_ff
c_func
(paren
r_const
r_char
op_star
id|rec
comma
r_int
id|len
comma
r_char
op_star
id|buf
comma
r_int
id|sz
comma
r_void
op_star
id|priv
)paren
(brace
r_if
c_cond
(paren
id|len
OG
l_int|0
op_logical_and
(paren
id|isalpha
c_func
(paren
(paren
r_int
r_char
)paren
op_star
id|rec
)paren
op_logical_or
multiline_comment|/* identifier? */
op_star
id|rec
op_eq
l_char|&squot;_&squot;
op_logical_or
multiline_comment|/* also identifier? */
op_star
id|rec
op_eq
l_char|&squot;$&squot;
)paren
)paren
(brace
multiline_comment|/* identifiers from VMS and other esoterico */
r_if
c_cond
(paren
id|len
OG
id|sz
)paren
id|len
op_assign
id|sz
suffix:semicolon
r_while
c_loop
(paren
l_int|0
OL
id|len
op_logical_and
id|isspace
c_func
(paren
(paren
r_int
r_char
)paren
id|rec
(braket
id|len
l_int|1
)braket
)paren
)paren
id|len
op_decrement
suffix:semicolon
id|memcpy
c_func
(paren
id|buf
comma
id|rec
comma
id|len
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|xdl_find_func
r_static
r_void
id|xdl_find_func
c_func
(paren
id|xdfile_t
op_star
id|xf
comma
r_int
id|i
comma
r_char
op_star
id|buf
comma
r_int
id|sz
comma
r_int
op_star
id|ll
comma
id|find_func_t
id|ff
comma
r_void
op_star
id|ff_priv
)paren
(brace
multiline_comment|/*&n;&t; * Be quite stupid about this for now.  Find a line in the old file&n;&t; * before the start of the hunk (and context) which starts with a&n;&t; * plausible character.&n;&t; */
r_const
r_char
op_star
id|rec
suffix:semicolon
r_int
id|len
suffix:semicolon
r_while
c_loop
(paren
id|i
op_decrement
OG
l_int|0
)paren
(brace
id|len
op_assign
id|xdl_get_rec
c_func
(paren
id|xf
comma
id|i
comma
op_amp
id|rec
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|ll
op_assign
id|ff
c_func
(paren
id|rec
comma
id|len
comma
id|buf
comma
id|sz
comma
id|ff_priv
)paren
)paren
op_ge
l_int|0
)paren
r_return
suffix:semicolon
)brace
op_star
id|ll
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|xdl_emit_common
r_static
r_int
id|xdl_emit_common
c_func
(paren
id|xdfenv_t
op_star
id|xe
comma
id|xdchange_t
op_star
id|xscr
comma
id|xdemitcb_t
op_star
id|ecb
comma
id|xdemitconf_t
r_const
op_star
id|xecfg
)paren
(brace
id|xdfile_t
op_star
id|xdf
op_assign
op_amp
id|xe-&gt;xdf1
suffix:semicolon
r_const
r_char
op_star
id|rchg
op_assign
id|xdf-&gt;rchg
suffix:semicolon
r_int
id|ix
suffix:semicolon
r_for
c_loop
(paren
id|ix
op_assign
l_int|0
suffix:semicolon
id|ix
OL
id|xdf-&gt;nrec
suffix:semicolon
id|ix
op_increment
)paren
(brace
r_if
c_cond
(paren
id|rchg
(braket
id|ix
)braket
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|xdl_emit_record
c_func
(paren
id|xdf
comma
id|ix
comma
l_string|&quot;&quot;
comma
id|ecb
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|xdl_emit_diff
r_int
id|xdl_emit_diff
c_func
(paren
id|xdfenv_t
op_star
id|xe
comma
id|xdchange_t
op_star
id|xscr
comma
id|xdemitcb_t
op_star
id|ecb
comma
id|xdemitconf_t
r_const
op_star
id|xecfg
)paren
(brace
r_int
id|s1
comma
id|s2
comma
id|e1
comma
id|e2
comma
id|lctx
suffix:semicolon
id|xdchange_t
op_star
id|xch
comma
op_star
id|xche
suffix:semicolon
r_char
id|funcbuf
(braket
l_int|80
)braket
suffix:semicolon
r_int
id|funclen
op_assign
l_int|0
suffix:semicolon
id|find_func_t
id|ff
op_assign
id|xecfg-&gt;find_func
ques
c_cond
id|xecfg-&gt;find_func
suffix:colon
id|def_ff
suffix:semicolon
r_if
c_cond
(paren
id|xecfg-&gt;flags
op_amp
id|XDL_EMIT_COMMON
)paren
r_return
id|xdl_emit_common
c_func
(paren
id|xe
comma
id|xscr
comma
id|ecb
comma
id|xecfg
)paren
suffix:semicolon
r_for
c_loop
(paren
id|xch
op_assign
id|xche
op_assign
id|xscr
suffix:semicolon
id|xch
suffix:semicolon
id|xch
op_assign
id|xche-&gt;next
)paren
(brace
id|xche
op_assign
id|xdl_get_hunk
c_func
(paren
id|xch
comma
id|xecfg
)paren
suffix:semicolon
id|s1
op_assign
id|XDL_MAX
c_func
(paren
id|xch-&gt;i1
id|xecfg-&gt;ctxlen
comma
l_int|0
)paren
suffix:semicolon
id|s2
op_assign
id|XDL_MAX
c_func
(paren
id|xch-&gt;i2
id|xecfg-&gt;ctxlen
comma
l_int|0
)paren
suffix:semicolon
id|lctx
op_assign
id|xecfg-&gt;ctxlen
suffix:semicolon
id|lctx
op_assign
id|XDL_MIN
c_func
(paren
id|lctx
comma
id|xe-&gt;xdf1.nrec
(paren
id|xche-&gt;i1
op_plus
id|xche-&gt;chg1
)paren
)paren
suffix:semicolon
id|lctx
op_assign
id|XDL_MIN
c_func
(paren
id|lctx
comma
id|xe-&gt;xdf2.nrec
(paren
id|xche-&gt;i2
op_plus
id|xche-&gt;chg2
)paren
)paren
suffix:semicolon
id|e1
op_assign
id|xche-&gt;i1
op_plus
id|xche-&gt;chg1
op_plus
id|lctx
suffix:semicolon
id|e2
op_assign
id|xche-&gt;i2
op_plus
id|xche-&gt;chg2
op_plus
id|lctx
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Emit current hunk header.&n;&t;&t; */
r_if
c_cond
(paren
id|xecfg-&gt;flags
op_amp
id|XDL_EMIT_FUNCNAMES
)paren
(brace
id|xdl_find_func
c_func
(paren
op_amp
id|xe-&gt;xdf1
comma
id|s1
comma
id|funcbuf
comma
r_sizeof
(paren
id|funcbuf
)paren
comma
op_amp
id|funclen
comma
id|ff
comma
id|xecfg-&gt;find_func_priv
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|xdl_emit_hunk_hdr
c_func
(paren
id|s1
op_plus
l_int|1
comma
id|e1
id|s1
comma
id|s2
op_plus
l_int|1
comma
id|e2
id|s2
comma
id|funcbuf
comma
id|funclen
comma
id|ecb
)paren
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Emit pre-context.&n;&t;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|s1
OL
id|xch-&gt;i1
suffix:semicolon
id|s1
op_increment
)paren
r_if
c_cond
(paren
id|xdl_emit_record
c_func
(paren
op_amp
id|xe-&gt;xdf1
comma
id|s1
comma
l_string|&quot; &quot;
comma
id|ecb
)paren
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|s1
op_assign
id|xch-&gt;i1
comma
id|s2
op_assign
id|xch-&gt;i2
suffix:semicolon
suffix:semicolon
id|xch
op_assign
id|xch-&gt;next
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Merge previous with current change atom.&n;&t;&t;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|s1
OL
id|xch-&gt;i1
op_logical_and
id|s2
OL
id|xch-&gt;i2
suffix:semicolon
id|s1
op_increment
comma
id|s2
op_increment
)paren
r_if
c_cond
(paren
id|xdl_emit_record
c_func
(paren
op_amp
id|xe-&gt;xdf1
comma
id|s1
comma
l_string|&quot; &quot;
comma
id|ecb
)paren
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Removes lines from the first file.&n;&t;&t;&t; */
r_for
c_loop
(paren
id|s1
op_assign
id|xch-&gt;i1
suffix:semicolon
id|s1
OL
id|xch-&gt;i1
op_plus
id|xch-&gt;chg1
suffix:semicolon
id|s1
op_increment
)paren
r_if
c_cond
(paren
id|xdl_emit_record
c_func
(paren
op_amp
id|xe-&gt;xdf1
comma
id|s1
comma
l_string|&quot;-&quot;
comma
id|ecb
)paren
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Adds lines from the second file.&n;&t;&t;&t; */
r_for
c_loop
(paren
id|s2
op_assign
id|xch-&gt;i2
suffix:semicolon
id|s2
OL
id|xch-&gt;i2
op_plus
id|xch-&gt;chg2
suffix:semicolon
id|s2
op_increment
)paren
r_if
c_cond
(paren
id|xdl_emit_record
c_func
(paren
op_amp
id|xe-&gt;xdf2
comma
id|s2
comma
l_string|&quot;+&quot;
comma
id|ecb
)paren
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|xch
op_eq
id|xche
)paren
r_break
suffix:semicolon
id|s1
op_assign
id|xch-&gt;i1
op_plus
id|xch-&gt;chg1
suffix:semicolon
id|s2
op_assign
id|xch-&gt;i2
op_plus
id|xch-&gt;chg2
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Emit post-context.&n;&t;&t; */
r_for
c_loop
(paren
id|s1
op_assign
id|xche-&gt;i1
op_plus
id|xche-&gt;chg1
suffix:semicolon
id|s1
OL
id|e1
suffix:semicolon
id|s1
op_increment
)paren
r_if
c_cond
(paren
id|xdl_emit_record
c_func
(paren
op_amp
id|xe-&gt;xdf1
comma
id|s1
comma
l_string|&quot; &quot;
comma
id|ecb
)paren
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
