macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;sha1-lookup.h&quot;
DECL|function|take2
r_static
r_uint32
id|take2
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_return
(paren
(paren
id|sha1
(braket
l_int|0
)braket
op_lshift
l_int|8
)paren
op_or
id|sha1
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Conventional binary search loop looks like this:&n; *&n; *      do {&n; *              int mi = (lo + hi) / 2;&n; *              int cmp = &quot;entry pointed at by mi&quot; minus &quot;target&quot;;&n; *              if (!cmp)&n; *                      return (mi is the wanted one)&n; *              if (cmp &gt; 0)&n; *                      hi = mi; &quot;mi is larger than target&quot;&n; *              else&n; *                      lo = mi+1; &quot;mi is smaller than target&quot;&n; *      } while (lo &lt; hi);&n; *&n; * The invariants are:&n; *&n; * - When entering the loop, lo points at a slot that is never&n; *   above the target (it could be at the target), hi points at a&n; *   slot that is guaranteed to be above the target (it can never&n; *   be at the target).&n; *&n; * - We find a point &squot;mi&squot; between lo and hi (mi could be the same&n; *   as lo, but never can be the same as hi), and check if it hits&n; *   the target.  There are three cases:&n; *&n; *    - if it is a hit, we are happy.&n; *&n; *    - if it is strictly higher than the target, we update hi with&n; *      it.&n; *&n; *    - if it is strictly lower than the target, we update lo to be&n; *      one slot after it, because we allow lo to be at the target.&n; *&n; * When choosing &squot;mi&squot;, we do not have to take the &quot;middle&quot; but&n; * anywhere in between lo and hi, as long as lo &lt;= mi &lt; hi is&n; * satisfied.  When we somehow know that the distance between the&n; * target and lo is much shorter than the target and hi, we could&n; * pick mi that is much closer to lo than the midway.&n; */
multiline_comment|/*&n; * The table should contain &quot;nr&quot; elements.&n; * The sha1 of element i (between 0 and nr - 1) should be returned&n; * by &quot;fn(i, table)&quot;.&n; */
DECL|function|sha1_pos
r_int
id|sha1_pos
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
comma
r_void
op_star
id|table
comma
r_int
id|nr
comma
id|sha1_access_fn
id|fn
)paren
(brace
r_int
id|hi
op_assign
id|nr
suffix:semicolon
r_int
id|lo
op_assign
l_int|0
suffix:semicolon
r_int
id|mi
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nr
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|nr
op_ne
l_int|1
)paren
(brace
r_int
id|lov
comma
id|hiv
comma
id|miv
comma
id|ofs
suffix:semicolon
r_for
c_loop
(paren
id|ofs
op_assign
l_int|0
suffix:semicolon
id|ofs
OL
l_int|18
suffix:semicolon
id|ofs
op_add_assign
l_int|2
)paren
(brace
id|lov
op_assign
id|take2
c_func
(paren
id|fn
c_func
(paren
l_int|0
comma
id|table
)paren
op_plus
id|ofs
)paren
suffix:semicolon
id|hiv
op_assign
id|take2
c_func
(paren
id|fn
c_func
(paren
id|nr
l_int|1
comma
id|table
)paren
op_plus
id|ofs
)paren
suffix:semicolon
id|miv
op_assign
id|take2
c_func
(paren
id|sha1
op_plus
id|ofs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|miv
OL
id|lov
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|hiv
OL
id|miv
)paren
r_return
l_int|1
id|nr
suffix:semicolon
r_if
c_cond
(paren
id|lov
op_ne
id|hiv
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * At this point miv could be equal&n;&t;&t;&t;&t; * to hiv (but sha1 could still be higher);&n;&t;&t;&t;&t; * the invariant of (mi &lt; hi) should be&n;&t;&t;&t;&t; * kept.&n;&t;&t;&t;&t; */
id|mi
op_assign
(paren
id|nr
l_int|1
)paren
op_star
(paren
id|miv
id|lov
)paren
op_div
(paren
id|hiv
id|lov
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lo
op_le
id|mi
op_logical_and
id|mi
OL
id|hi
)paren
r_break
suffix:semicolon
id|die
c_func
(paren
l_string|&quot;BUG: assertion failed in binary search&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
r_do
(brace
r_int
id|cmp
suffix:semicolon
id|cmp
op_assign
id|hashcmp
c_func
(paren
id|fn
c_func
(paren
id|mi
comma
id|table
)paren
comma
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmp
)paren
r_return
id|mi
suffix:semicolon
r_if
c_cond
(paren
id|cmp
OG
l_int|0
)paren
id|hi
op_assign
id|mi
suffix:semicolon
r_else
id|lo
op_assign
id|mi
op_plus
l_int|1
suffix:semicolon
id|mi
op_assign
(paren
id|hi
op_plus
id|lo
)paren
op_div
l_int|2
suffix:semicolon
)brace
r_while
c_loop
(paren
id|lo
OL
id|hi
)paren
suffix:semicolon
r_return
id|lo
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Conventional binary search loop looks like this:&n; *&n; *&t;unsigned lo, hi;&n; *      do {&n; *              unsigned mi = (lo + hi) / 2;&n; *              int cmp = &quot;entry pointed at by mi&quot; minus &quot;target&quot;;&n; *              if (!cmp)&n; *                      return (mi is the wanted one)&n; *              if (cmp &gt; 0)&n; *                      hi = mi; &quot;mi is larger than target&quot;&n; *              else&n; *                      lo = mi+1; &quot;mi is smaller than target&quot;&n; *      } while (lo &lt; hi);&n; *&n; * The invariants are:&n; *&n; * - When entering the loop, lo points at a slot that is never&n; *   above the target (it could be at the target), hi points at a&n; *   slot that is guaranteed to be above the target (it can never&n; *   be at the target).&n; *&n; * - We find a point &squot;mi&squot; between lo and hi (mi could be the same&n; *   as lo, but never can be as same as hi), and check if it hits&n; *   the target.  There are three cases:&n; *&n; *    - if it is a hit, we are happy.&n; *&n; *    - if it is strictly higher than the target, we set it to hi,&n; *      and repeat the search.&n; *&n; *    - if it is strictly lower than the target, we update lo to&n; *      one slot after it, because we allow lo to be at the target.&n; *&n; *   If the loop exits, there is no matching entry.&n; *&n; * When choosing &squot;mi&squot;, we do not have to take the &quot;middle&quot; but&n; * anywhere in between lo and hi, as long as lo &lt;= mi &lt; hi is&n; * satisfied.  When we somehow know that the distance between the&n; * target and lo is much shorter than the target and hi, we could&n; * pick mi that is much closer to lo than the midway.&n; *&n; * Now, we can take advantage of the fact that SHA-1 is a good hash&n; * function, and as long as there are enough entries in the table, we&n; * can expect uniform distribution.  An entry that begins with for&n; * example &quot;deadbeef...&quot; is much likely to appear much later than in&n; * the midway of the table.  It can reasonably be expected to be near&n; * 87% (222/256) from the top of the table.&n; *&n; * However, we do not want to pick &quot;mi&quot; too precisely.  If the entry at&n; * the 87% in the above example turns out to be higher than the target&n; * we are looking for, we would end up narrowing the search space down&n; * only by 13%, instead of 50% we would get if we did a simple binary&n; * search.  So we would want to hedge our bets by being less aggressive.&n; *&n; * The table at &quot;table&quot; holds at least &quot;nr&quot; entries of &quot;elem_size&quot;&n; * bytes each.  Each entry has the SHA-1 key at &quot;key_offset&quot;.  The&n; * table is sorted by the SHA-1 key of the entries.  The caller wants&n; * to find the entry with &quot;key&quot;, and knows that the entry at &quot;lo&quot; is&n; * not higher than the entry it is looking for, and that the entry at&n; * &quot;hi&quot; is higher than the entry it is looking for.&n; */
DECL|function|sha1_entry_pos
r_int
id|sha1_entry_pos
c_func
(paren
r_const
r_void
op_star
id|table
comma
r_int
id|elem_size
comma
r_int
id|key_offset
comma
r_int
id|lo
comma
r_int
id|hi
comma
r_int
id|nr
comma
r_const
r_int
r_char
op_star
id|key
)paren
(brace
r_const
r_int
r_char
op_star
id|base
op_assign
id|table
suffix:semicolon
r_const
r_int
r_char
op_star
id|hi_key
comma
op_star
id|lo_key
suffix:semicolon
r_int
id|ofs_0
suffix:semicolon
r_static
r_int
id|debug_lookup
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|debug_lookup
OL
l_int|0
)paren
id|debug_lookup
op_assign
op_logical_neg
op_logical_neg
id|getenv
c_func
(paren
l_string|&quot;GIT_DEBUG_LOOKUP&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nr
op_logical_or
id|lo
op_ge
id|hi
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|nr
op_eq
id|hi
)paren
id|hi_key
op_assign
l_int|NULL
suffix:semicolon
r_else
id|hi_key
op_assign
id|base
op_plus
id|elem_size
op_star
id|hi
op_plus
id|key_offset
suffix:semicolon
id|lo_key
op_assign
id|base
op_plus
id|elem_size
op_star
id|lo
op_plus
id|key_offset
suffix:semicolon
id|ofs_0
op_assign
l_int|0
suffix:semicolon
r_do
(brace
r_int
id|cmp
suffix:semicolon
r_int
id|ofs
comma
id|mi
comma
id|range
suffix:semicolon
r_int
id|lov
comma
id|hiv
comma
id|kyv
suffix:semicolon
r_const
r_int
r_char
op_star
id|mi_key
suffix:semicolon
id|range
op_assign
id|hi
id|lo
suffix:semicolon
r_if
c_cond
(paren
id|hi_key
)paren
(brace
r_for
c_loop
(paren
id|ofs
op_assign
id|ofs_0
suffix:semicolon
id|ofs
OL
l_int|20
suffix:semicolon
id|ofs
op_increment
)paren
r_if
c_cond
(paren
id|lo_key
(braket
id|ofs
)braket
op_ne
id|hi_key
(braket
id|ofs
)braket
)paren
r_break
suffix:semicolon
id|ofs_0
op_assign
id|ofs
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * byte 0 thru (ofs-1) are the same between&n;&t;&t;&t; * lo and hi; ofs is the first byte that is&n;&t;&t;&t; * different.&n;&t;&t;&t; *&n;&t;&t;&t; * If ofs==20, then no bytes are different,&n;&t;&t;&t; * meaning we have entries with duplicate&n;&t;&t;&t; * keys. We know that we are in a solid run&n;&t;&t;&t; * of this entry (because the entries are&n;&t;&t;&t; * sorted, and our lo and hi are the same,&n;&t;&t;&t; * there can be nothing but this single key&n;&t;&t;&t; * in between). So we can stop the search.&n;&t;&t;&t; * Either one of these entries is it (and&n;&t;&t;&t; * we do not care which), or we do not have&n;&t;&t;&t; * it.&n;&t;&t;&t; *&n;&t;&t;&t; * Furthermore, we know that one of our&n;&t;&t;&t; * endpoints must be the edge of the run of&n;&t;&t;&t; * duplicates. For example, given this&n;&t;&t;&t; * sequence:&n;&t;&t;&t; *&n;&t;&t;&t; *     idx 0 1 2 3 4 5&n;&t;&t;&t; *     key A C C C C D&n;&t;&t;&t; *&n;&t;&t;&t; * If we are searching for &quot;B&quot;, we might&n;&t;&t;&t; * hit the duplicate run at lo=1, hi=3&n;&t;&t;&t; * (e.g., by first mi=3, then mi=0). But we&n;&t;&t;&t; * can never have lo &gt; 1, because B &lt; C.&n;&t;&t;&t; * That is, if our key is less than the&n;&t;&t;&t; * run, we know that &quot;lo&quot; is the edge, but&n;&t;&t;&t; * we can say nothing of &quot;hi&quot;. Similarly,&n;&t;&t;&t; * if our key is greater than the run, we&n;&t;&t;&t; * know that &quot;hi&quot; is the edge, but we can&n;&t;&t;&t; * say nothing of &quot;lo&quot;.&n;&t;&t;&t; *&n;&t;&t;&t; * Therefore if we do not find it, we also&n;&t;&t;&t; * know where it would go if it did exist:&n;&t;&t;&t; * just on the far side of the edge that we&n;&t;&t;&t; * know about.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ofs
op_eq
l_int|20
)paren
(brace
id|mi
op_assign
id|lo
suffix:semicolon
id|mi_key
op_assign
id|base
op_plus
id|elem_size
op_star
id|mi
op_plus
id|key_offset
suffix:semicolon
id|cmp
op_assign
id|memcmp
c_func
(paren
id|mi_key
comma
id|key
comma
l_int|20
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmp
)paren
r_return
id|mi
suffix:semicolon
r_if
c_cond
(paren
id|cmp
OL
l_int|0
)paren
r_return
l_int|1
id|hi
suffix:semicolon
r_else
r_return
l_int|1
id|lo
suffix:semicolon
)brace
id|hiv
op_assign
id|hi_key
(braket
id|ofs_0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ofs_0
OL
l_int|19
)paren
id|hiv
op_assign
(paren
id|hiv
op_lshift
l_int|8
)paren
op_or
id|hi_key
(braket
id|ofs_0
op_plus
l_int|1
)braket
suffix:semicolon
)brace
r_else
(brace
id|hiv
op_assign
l_int|256
suffix:semicolon
r_if
c_cond
(paren
id|ofs_0
OL
l_int|19
)paren
id|hiv
op_lshift_assign
l_int|8
suffix:semicolon
)brace
id|lov
op_assign
id|lo_key
(braket
id|ofs_0
)braket
suffix:semicolon
id|kyv
op_assign
id|key
(braket
id|ofs_0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ofs_0
OL
l_int|19
)paren
(brace
id|lov
op_assign
(paren
id|lov
op_lshift
l_int|8
)paren
op_or
id|lo_key
(braket
id|ofs_0
op_plus
l_int|1
)braket
suffix:semicolon
id|kyv
op_assign
(paren
id|kyv
op_lshift
l_int|8
)paren
op_or
id|key
(braket
id|ofs_0
op_plus
l_int|1
)braket
suffix:semicolon
)brace
m_assert
(paren
id|lov
OL
id|hiv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kyv
OL
id|lov
)paren
r_return
l_int|1
id|lo
suffix:semicolon
r_if
c_cond
(paren
id|hiv
OL
id|kyv
)paren
r_return
l_int|1
id|hi
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Even if we know the target is much closer to &squot;hi&squot;&n;&t;&t; * than &squot;lo&squot;, if we pick too precisely and overshoot&n;&t;&t; * (e.g. when we know &squot;mi&squot; is closer to &squot;hi&squot; than to&n;&t;&t; * &squot;lo&squot;, pick &squot;mi&squot; that is higher than the target), we&n;&t;&t; * end up narrowing the search space by a smaller&n;&t;&t; * amount (i.e. the distance between &squot;mi&squot; and &squot;hi&squot;)&n;&t;&t; * than what we would have (i.e. about half of &squot;lo&squot;&n;&t;&t; * and &squot;hi&squot;).  Hedge our bets to pick &squot;mi&squot; less&n;&t;&t; * aggressively, i.e. make &squot;mi&squot; a bit closer to the&n;&t;&t; * middle than we would otherwise pick.&n;&t;&t; */
id|kyv
op_assign
(paren
id|kyv
op_star
l_int|6
op_plus
id|lov
op_plus
id|hiv
)paren
op_div
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|lov
OL
id|hiv
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|kyv
op_eq
id|lov
)paren
id|kyv
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|kyv
op_eq
id|hiv
)paren
id|kyv
op_decrement
suffix:semicolon
)brace
id|mi
op_assign
(paren
id|range
l_int|1
)paren
op_star
(paren
id|kyv
id|lov
)paren
op_div
(paren
id|hiv
id|lov
)paren
op_plus
id|lo
suffix:semicolon
r_if
c_cond
(paren
id|debug_lookup
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;lo %u hi %u rg %u mi %u &quot;
comma
id|lo
comma
id|hi
comma
id|range
comma
id|mi
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;ofs %u lov %x, hiv %x, kyv %x&bslash;n&quot;
comma
id|ofs_0
comma
id|lov
comma
id|hiv
comma
id|kyv
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|lo
op_le
id|mi
op_logical_and
id|mi
OL
id|hi
)paren
)paren
id|die
c_func
(paren
l_string|&quot;assertion failure lo %u mi %u hi %u %s&quot;
comma
id|lo
comma
id|mi
comma
id|hi
comma
id|sha1_to_hex
c_func
(paren
id|key
)paren
)paren
suffix:semicolon
id|mi_key
op_assign
id|base
op_plus
id|elem_size
op_star
id|mi
op_plus
id|key_offset
suffix:semicolon
id|cmp
op_assign
id|memcmp
c_func
(paren
id|mi_key
op_plus
id|ofs_0
comma
id|key
op_plus
id|ofs_0
comma
l_int|20
id|ofs_0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmp
)paren
r_return
id|mi
suffix:semicolon
r_if
c_cond
(paren
id|cmp
OG
l_int|0
)paren
(brace
id|hi
op_assign
id|mi
suffix:semicolon
id|hi_key
op_assign
id|mi_key
suffix:semicolon
)brace
r_else
(brace
id|lo
op_assign
id|mi
op_plus
l_int|1
suffix:semicolon
id|lo_key
op_assign
id|mi_key
op_plus
id|elem_size
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|lo
OL
id|hi
)paren
suffix:semicolon
r_return
id|lo
op_minus
l_int|1
suffix:semicolon
)brace
eof
