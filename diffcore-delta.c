macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;diff.h&quot;
macro_line|#include &quot;diffcore.h&quot;
multiline_comment|/*&n; * Idea here is very simple.&n; *&n; * We have total of (sz-N+1) N-byte overlapping sequences in buf whose&n; * size is sz.  If the same N-byte sequence appears in both source and&n; * destination, we say the byte that starts that sequence is shared&n; * between them (i.e. copied from source to destination).&n; *&n; * For each possible N-byte sequence, if the source buffer has more&n; * instances of it than the destination buffer, that means the&n; * difference are the number of bytes not copied from source to&n; * destination.  If the counts are the same, everything was copied&n; * from source to destination.  If the destination has more,&n; * everything was copied, and destination added more.&n; *&n; * We are doing an approximation so we do not really have to waste&n; * memory by actually storing the sequence.  We just hash them into&n; * somewhere around 2^16 hashbuckets and count the occurrences.&n; *&n; * The length of the sequence is arbitrarily set to 8 for now.&n; */
DECL|macro|HASHBASE
mdefine_line|#define HASHBASE 65537 /* next_prime(2^16) */
DECL|function|hash_chars
r_static
r_void
id|hash_chars
c_func
(paren
r_int
r_char
op_star
id|buf
comma
r_int
r_int
id|sz
comma
r_int
op_star
id|count
)paren
(brace
r_int
r_int
id|accum1
comma
id|accum2
comma
id|i
suffix:semicolon
multiline_comment|/* an 8-byte shift register made of accum1 and accum2.  New&n;&t; * bytes come at LSB of accum2, and shifted up to accum1&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
id|accum1
op_assign
id|accum2
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|7
suffix:semicolon
id|i
op_increment
comma
id|sz
op_decrement
)paren
(brace
id|accum1
op_assign
(paren
id|accum1
op_lshift
l_int|8
)paren
op_or
(paren
id|accum2
op_rshift
l_int|24
)paren
suffix:semicolon
id|accum2
op_assign
(paren
id|accum2
op_lshift
l_int|8
)paren
op_or
op_star
id|buf
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|sz
)paren
(brace
id|accum1
op_assign
(paren
id|accum1
op_lshift
l_int|8
)paren
op_or
(paren
id|accum2
op_rshift
l_int|24
)paren
suffix:semicolon
id|accum2
op_assign
(paren
id|accum2
op_lshift
l_int|8
)paren
op_or
op_star
id|buf
op_increment
suffix:semicolon
multiline_comment|/* We want something that hashes permuted byte&n;&t;&t; * sequences nicely; simpler hash like (accum1 ^&n;&t;&t; * accum2) does not perform as well.&n;&t;&t; */
id|i
op_assign
(paren
id|accum1
op_plus
id|accum2
op_star
l_int|0x61
)paren
op_mod
id|HASHBASE
suffix:semicolon
id|count
(braket
id|i
)braket
op_increment
suffix:semicolon
id|sz
op_decrement
suffix:semicolon
)brace
)brace
DECL|function|diffcore_count_changes
r_int
id|diffcore_count_changes
c_func
(paren
r_void
op_star
id|src
comma
r_int
r_int
id|src_size
comma
r_void
op_star
id|dst
comma
r_int
r_int
id|dst_size
comma
r_int
r_int
id|delta_limit
comma
r_int
r_int
op_star
id|src_copied
comma
r_int
r_int
op_star
id|literal_added
)paren
(brace
r_int
op_star
id|src_count
comma
op_star
id|dst_count
comma
id|i
suffix:semicolon
r_int
r_int
id|sc
comma
id|la
suffix:semicolon
r_if
c_cond
(paren
id|src_size
OL
l_int|8
op_logical_or
id|dst_size
OL
l_int|8
)paren
r_return
l_int|1
suffix:semicolon
id|src_count
op_assign
id|xcalloc
c_func
(paren
id|HASHBASE
op_star
l_int|2
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
id|dst_count
op_assign
id|src_count
op_plus
id|HASHBASE
suffix:semicolon
id|hash_chars
c_func
(paren
id|src
comma
id|src_size
comma
id|src_count
)paren
suffix:semicolon
id|hash_chars
c_func
(paren
id|dst
comma
id|dst_size
comma
id|dst_count
)paren
suffix:semicolon
id|sc
op_assign
id|la
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|HASHBASE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|src_count
(braket
id|i
)braket
OL
id|dst_count
(braket
id|i
)braket
)paren
(brace
id|la
op_add_assign
id|dst_count
(braket
id|i
)braket
id|src_count
(braket
id|i
)braket
suffix:semicolon
id|sc
op_add_assign
id|src_count
(braket
id|i
)braket
suffix:semicolon
)brace
r_else
multiline_comment|/* i.e. if (dst_count[i] &lt;= src_count[i]) */
id|sc
op_add_assign
id|dst_count
(braket
id|i
)braket
suffix:semicolon
)brace
op_star
id|src_copied
op_assign
id|sc
suffix:semicolon
op_star
id|literal_added
op_assign
id|la
suffix:semicolon
id|free
c_func
(paren
id|src_count
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
