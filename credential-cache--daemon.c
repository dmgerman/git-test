macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;credential.h&quot;
macro_line|#include &quot;unix-socket.h&quot;
macro_line|#include &quot;sigchain.h&quot;
DECL|variable|socket_path
r_static
r_const
r_char
op_star
id|socket_path
suffix:semicolon
DECL|function|cleanup_socket
r_static
r_void
id|cleanup_socket
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|socket_path
)paren
id|unlink
c_func
(paren
id|socket_path
)paren
suffix:semicolon
)brace
DECL|function|cleanup_socket_on_signal
r_static
r_void
id|cleanup_socket_on_signal
c_func
(paren
r_int
id|sig
)paren
(brace
id|cleanup_socket
c_func
(paren
)paren
suffix:semicolon
id|sigchain_pop
c_func
(paren
id|sig
)paren
suffix:semicolon
id|raise
c_func
(paren
id|sig
)paren
suffix:semicolon
)brace
DECL|struct|credential_cache_entry
r_struct
id|credential_cache_entry
(brace
DECL|member|item
r_struct
id|credential
id|item
suffix:semicolon
DECL|member|expiration
r_int
r_int
id|expiration
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|entries
r_static
r_struct
id|credential_cache_entry
op_star
id|entries
suffix:semicolon
DECL|variable|entries_nr
r_static
r_int
id|entries_nr
suffix:semicolon
DECL|variable|entries_alloc
r_static
r_int
id|entries_alloc
suffix:semicolon
DECL|function|cache_credential
r_static
r_void
id|cache_credential
c_func
(paren
r_struct
id|credential
op_star
id|c
comma
r_int
id|timeout
)paren
(brace
r_struct
id|credential_cache_entry
op_star
id|e
suffix:semicolon
id|ALLOC_GROW
c_func
(paren
id|entries
comma
id|entries_nr
op_plus
l_int|1
comma
id|entries_alloc
)paren
suffix:semicolon
id|e
op_assign
op_amp
id|entries
(braket
id|entries_nr
op_increment
)braket
suffix:semicolon
multiline_comment|/* take ownership of pointers */
id|memcpy
c_func
(paren
op_amp
id|e-&gt;item
comma
id|c
comma
r_sizeof
(paren
op_star
id|c
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|c
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|c
)paren
)paren
suffix:semicolon
id|e-&gt;expiration
op_assign
id|time
c_func
(paren
l_int|NULL
)paren
op_plus
id|timeout
suffix:semicolon
)brace
DECL|function|lookup_credential
r_static
r_struct
id|credential_cache_entry
op_star
id|lookup_credential
c_func
(paren
r_const
r_struct
id|credential
op_star
id|c
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|entries_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|credential
op_star
id|e
op_assign
op_amp
id|entries
(braket
id|i
)braket
dot
id|item
suffix:semicolon
r_if
c_cond
(paren
id|credential_match
c_func
(paren
id|c
comma
id|e
)paren
)paren
r_return
op_amp
id|entries
(braket
id|i
)braket
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|remove_credential
r_static
r_void
id|remove_credential
c_func
(paren
r_const
r_struct
id|credential
op_star
id|c
)paren
(brace
r_struct
id|credential_cache_entry
op_star
id|e
suffix:semicolon
id|e
op_assign
id|lookup_credential
c_func
(paren
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e
)paren
id|e-&gt;expiration
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|check_expirations
r_static
r_int
id|check_expirations
c_func
(paren
r_void
)paren
(brace
r_static
r_int
r_int
id|wait_for_entry_until
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|now
op_assign
id|time
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
r_int
r_int
id|next
op_assign
(paren
r_int
r_int
)paren
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Initially give the client 30 seconds to actually contact us&n;&t; * and store a credential before we decide there&squot;s no point in&n;&t; * keeping the daemon around.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|wait_for_entry_until
)paren
id|wait_for_entry_until
op_assign
id|now
op_plus
l_int|30
suffix:semicolon
r_while
c_loop
(paren
id|i
OL
id|entries_nr
)paren
(brace
r_if
c_cond
(paren
id|entries
(braket
id|i
)braket
dot
id|expiration
op_le
id|now
)paren
(brace
id|entries_nr
op_decrement
suffix:semicolon
id|credential_clear
c_func
(paren
op_amp
id|entries
(braket
id|i
)braket
dot
id|item
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
id|entries_nr
)paren
id|memcpy
c_func
(paren
op_amp
id|entries
(braket
id|i
)braket
comma
op_amp
id|entries
(braket
id|entries_nr
)braket
comma
r_sizeof
(paren
op_star
id|entries
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Stick around 30 seconds in case a new credential&n;&t;&t;&t; * shows up (e.g., because we just removed a failed&n;&t;&t;&t; * one, and we will soon get the correct one).&n;&t;&t;&t; */
id|wait_for_entry_until
op_assign
id|now
op_plus
l_int|30
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|entries
(braket
id|i
)braket
dot
id|expiration
OL
id|next
)paren
id|next
op_assign
id|entries
(braket
id|i
)braket
dot
id|expiration
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|entries_nr
)paren
(brace
r_if
c_cond
(paren
id|wait_for_entry_until
op_le
id|now
)paren
r_return
l_int|0
suffix:semicolon
id|next
op_assign
id|wait_for_entry_until
suffix:semicolon
)brace
r_return
id|next
id|now
suffix:semicolon
)brace
DECL|function|read_request
r_static
r_int
id|read_request
c_func
(paren
id|FILE
op_star
id|fh
comma
r_struct
id|credential
op_star
id|c
comma
r_struct
id|strbuf
op_star
id|action
comma
r_int
op_star
id|timeout
)paren
(brace
r_static
r_struct
id|strbuf
id|item
op_assign
id|STRBUF_INIT
suffix:semicolon
r_const
r_char
op_star
id|p
suffix:semicolon
id|strbuf_getline
c_func
(paren
op_amp
id|item
comma
id|fh
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skip_prefix
c_func
(paren
id|item.buf
comma
l_string|&quot;action=&quot;
comma
op_amp
id|p
)paren
)paren
r_return
id|error
c_func
(paren
l_string|&quot;client sent bogus action line: %s&quot;
comma
id|item.buf
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
id|action
comma
id|p
)paren
suffix:semicolon
id|strbuf_getline
c_func
(paren
op_amp
id|item
comma
id|fh
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skip_prefix
c_func
(paren
id|item.buf
comma
l_string|&quot;timeout=&quot;
comma
op_amp
id|p
)paren
)paren
r_return
id|error
c_func
(paren
l_string|&quot;client sent bogus timeout line: %s&quot;
comma
id|item.buf
)paren
suffix:semicolon
op_star
id|timeout
op_assign
id|atoi
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|credential_read
c_func
(paren
id|c
comma
id|fh
)paren
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|serve_one_client
r_static
r_void
id|serve_one_client
c_func
(paren
id|FILE
op_star
id|in
comma
id|FILE
op_star
id|out
)paren
(brace
r_struct
id|credential
id|c
op_assign
id|CREDENTIAL_INIT
suffix:semicolon
r_struct
id|strbuf
id|action
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|timeout
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|read_request
c_func
(paren
id|in
comma
op_amp
id|c
comma
op_amp
id|action
comma
op_amp
id|timeout
)paren
OL
l_int|0
)paren
multiline_comment|/* ignore error */
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|action.buf
comma
l_string|&quot;get&quot;
)paren
)paren
(brace
r_struct
id|credential_cache_entry
op_star
id|e
op_assign
id|lookup_credential
c_func
(paren
op_amp
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e
)paren
(brace
id|fprintf
c_func
(paren
id|out
comma
l_string|&quot;username=%s&bslash;n&quot;
comma
id|e-&gt;item.username
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|out
comma
l_string|&quot;password=%s&bslash;n&quot;
comma
id|e-&gt;item.password
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|action.buf
comma
l_string|&quot;exit&quot;
)paren
)paren
m_exit
(paren
l_int|0
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|action.buf
comma
l_string|&quot;erase&quot;
)paren
)paren
id|remove_credential
c_func
(paren
op_amp
id|c
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|action.buf
comma
l_string|&quot;store&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|timeout
OL
l_int|0
)paren
id|warning
c_func
(paren
l_string|&quot;cache client didn&squot;t specify a timeout&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|c.username
op_logical_or
op_logical_neg
id|c.password
)paren
id|warning
c_func
(paren
l_string|&quot;cache client gave us a partial credential&quot;
)paren
suffix:semicolon
r_else
(brace
id|remove_credential
c_func
(paren
op_amp
id|c
)paren
suffix:semicolon
id|cache_credential
c_func
(paren
op_amp
id|c
comma
id|timeout
)paren
suffix:semicolon
)brace
)brace
r_else
id|warning
c_func
(paren
l_string|&quot;cache client sent unknown action: %s&quot;
comma
id|action.buf
)paren
suffix:semicolon
id|credential_clear
c_func
(paren
op_amp
id|c
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|action
)paren
suffix:semicolon
)brace
DECL|function|serve_cache_loop
r_static
r_int
id|serve_cache_loop
c_func
(paren
r_int
id|fd
)paren
(brace
r_struct
id|pollfd
id|pfd
suffix:semicolon
r_int
r_int
id|wakeup
suffix:semicolon
id|wakeup
op_assign
id|check_expirations
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wakeup
)paren
r_return
l_int|0
suffix:semicolon
id|pfd.fd
op_assign
id|fd
suffix:semicolon
id|pfd.events
op_assign
id|POLLIN
suffix:semicolon
r_if
c_cond
(paren
id|poll
c_func
(paren
op_amp
id|pfd
comma
l_int|1
comma
l_int|1000
op_star
id|wakeup
)paren
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|errno
op_ne
id|EINTR
)paren
id|die_errno
c_func
(paren
l_string|&quot;poll failed&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pfd.revents
op_amp
id|POLLIN
)paren
(brace
r_int
id|client
comma
id|client2
suffix:semicolon
id|FILE
op_star
id|in
comma
op_star
id|out
suffix:semicolon
id|client
op_assign
id|accept
c_func
(paren
id|fd
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|client
OL
l_int|0
)paren
(brace
id|warning
c_func
(paren
l_string|&quot;accept failed: %s&quot;
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|client2
op_assign
id|dup
c_func
(paren
id|client
)paren
suffix:semicolon
r_if
c_cond
(paren
id|client2
OL
l_int|0
)paren
(brace
id|warning
c_func
(paren
l_string|&quot;dup failed: %s&quot;
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
id|close
c_func
(paren
id|client
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|in
op_assign
id|xfdopen
c_func
(paren
id|client
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
id|out
op_assign
id|xfdopen
c_func
(paren
id|client2
comma
l_string|&quot;w&quot;
)paren
suffix:semicolon
id|serve_one_client
c_func
(paren
id|in
comma
id|out
)paren
suffix:semicolon
id|fclose
c_func
(paren
id|in
)paren
suffix:semicolon
id|fclose
c_func
(paren
id|out
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|serve_cache
r_static
r_void
id|serve_cache
c_func
(paren
r_const
r_char
op_star
id|socket_path
)paren
(brace
r_int
id|fd
suffix:semicolon
id|fd
op_assign
id|unix_stream_listen
c_func
(paren
id|socket_path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
id|die_errno
c_func
(paren
l_string|&quot;unable to bind to &squot;%s&squot;&quot;
comma
id|socket_path
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;ok&bslash;n&quot;
)paren
suffix:semicolon
id|fclose
c_func
(paren
id|stdout
)paren
suffix:semicolon
r_while
c_loop
(paren
id|serve_cache_loop
c_func
(paren
id|fd
)paren
)paren
suffix:semicolon
multiline_comment|/* nothing */
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
id|unlink
c_func
(paren
id|socket_path
)paren
suffix:semicolon
)brace
DECL|variable|permissions_advice
r_static
r_const
r_char
id|permissions_advice
(braket
)braket
op_assign
l_string|&quot;The permissions on your socket directory are too loose; other&bslash;n&quot;
l_string|&quot;users may be able to read your cached credentials. Consider running:&bslash;n&quot;
l_string|&quot;&bslash;n&quot;
l_string|&quot;&t;chmod 0700 %s&quot;
suffix:semicolon
DECL|function|check_socket_directory
r_static
r_void
id|check_socket_directory
c_func
(paren
r_const
r_char
op_star
id|path
)paren
(brace
r_struct
id|stat
id|st
suffix:semicolon
r_char
op_star
id|path_copy
op_assign
id|xstrdup
c_func
(paren
id|path
)paren
suffix:semicolon
r_char
op_star
id|dir
op_assign
id|dirname
c_func
(paren
id|path_copy
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stat
c_func
(paren
id|dir
comma
op_amp
id|st
)paren
)paren
(brace
r_if
c_cond
(paren
id|st.st_mode
op_amp
l_int|077
)paren
id|die
c_func
(paren
id|permissions_advice
comma
id|dir
)paren
suffix:semicolon
id|free
c_func
(paren
id|path_copy
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We must be sure to create the directory with the correct mode,&n;&t; * not just chmod it after the fact; otherwise, there is a race&n;&t; * condition in which somebody can chdir to it, sleep, then try to open&n;&t; * our protected socket.&n;&t; */
r_if
c_cond
(paren
id|safe_create_leading_directories_const
c_func
(paren
id|dir
)paren
OL
l_int|0
)paren
id|die_errno
c_func
(paren
l_string|&quot;unable to create directories for &squot;%s&squot;&quot;
comma
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mkdir
c_func
(paren
id|dir
comma
l_int|0700
)paren
OL
l_int|0
)paren
id|die_errno
c_func
(paren
l_string|&quot;unable to mkdir &squot;%s&squot;&quot;
comma
id|dir
)paren
suffix:semicolon
id|free
c_func
(paren
id|path_copy
)paren
suffix:semicolon
)brace
DECL|function|main
r_int
id|main
c_func
(paren
r_int
id|argc
comma
r_const
r_char
op_star
op_star
id|argv
)paren
(brace
id|socket_path
op_assign
id|argv
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|socket_path
)paren
id|die
c_func
(paren
l_string|&quot;usage: git-credential-cache--daemon &lt;socket_path&gt;&quot;
)paren
suffix:semicolon
id|check_socket_directory
c_func
(paren
id|socket_path
)paren
suffix:semicolon
id|atexit
c_func
(paren
id|cleanup_socket
)paren
suffix:semicolon
id|sigchain_push_common
c_func
(paren
id|cleanup_socket_on_signal
)paren
suffix:semicolon
id|serve_cache
c_func
(paren
id|socket_path
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
