macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;refs.h&quot;
macro_line|#include &quot;tag.h&quot;
macro_line|#include &quot;commit.h&quot;
macro_line|#include &quot;tree.h&quot;
macro_line|#include &quot;blob.h&quot;
macro_line|#include &quot;epoch.h&quot;
macro_line|#include &quot;diff.h&quot;
DECL|macro|SEEN
mdefine_line|#define SEEN&t;&t;(1u &lt;&lt; 0)
DECL|macro|INTERESTING
mdefine_line|#define INTERESTING&t;(1u &lt;&lt; 1)
DECL|macro|COUNTED
mdefine_line|#define COUNTED&t;&t;(1u &lt;&lt; 2)
DECL|macro|SHOWN
mdefine_line|#define SHOWN&t;&t;(1u &lt;&lt; 3)
DECL|macro|TREECHANGE
mdefine_line|#define TREECHANGE&t;(1u &lt;&lt; 4)
DECL|macro|TMP_MARK
mdefine_line|#define TMP_MARK&t;(1u &lt;&lt; 5) /* for isolated cases; clean after use */
DECL|variable|rev_list_usage
r_static
r_const
r_char
id|rev_list_usage
(braket
)braket
op_assign
l_string|&quot;git-rev-list [OPTION] &lt;commit-id&gt;... [ -- paths... ]&bslash;n&quot;
l_string|&quot;  limiting output:&bslash;n&quot;
l_string|&quot;    --max-count=nr&bslash;n&quot;
l_string|&quot;    --max-age=epoch&bslash;n&quot;
l_string|&quot;    --min-age=epoch&bslash;n&quot;
l_string|&quot;    --sparse&bslash;n&quot;
l_string|&quot;    --no-merges&bslash;n&quot;
l_string|&quot;    --remove-empty&bslash;n&quot;
l_string|&quot;    --all&bslash;n&quot;
l_string|&quot;  ordering output:&bslash;n&quot;
l_string|&quot;    --merge-order [ --show-breaks ]&bslash;n&quot;
l_string|&quot;    --topo-order&bslash;n&quot;
l_string|&quot;  formatting output:&bslash;n&quot;
l_string|&quot;    --parents&bslash;n&quot;
l_string|&quot;    --objects&bslash;n&quot;
l_string|&quot;    --unpacked&bslash;n&quot;
l_string|&quot;    --header | --pretty&bslash;n&quot;
l_string|&quot;  special purpose:&bslash;n&quot;
l_string|&quot;    --bisect&quot;
suffix:semicolon
DECL|variable|dense
r_static
r_int
id|dense
op_assign
l_int|1
suffix:semicolon
DECL|variable|unpacked
r_static
r_int
id|unpacked
op_assign
l_int|0
suffix:semicolon
DECL|variable|bisect_list
r_static
r_int
id|bisect_list
op_assign
l_int|0
suffix:semicolon
DECL|variable|tag_objects
r_static
r_int
id|tag_objects
op_assign
l_int|0
suffix:semicolon
DECL|variable|tree_objects
r_static
r_int
id|tree_objects
op_assign
l_int|0
suffix:semicolon
DECL|variable|blob_objects
r_static
r_int
id|blob_objects
op_assign
l_int|0
suffix:semicolon
DECL|variable|verbose_header
r_static
r_int
id|verbose_header
op_assign
l_int|0
suffix:semicolon
DECL|variable|show_parents
r_static
r_int
id|show_parents
op_assign
l_int|0
suffix:semicolon
DECL|variable|hdr_termination
r_static
r_int
id|hdr_termination
op_assign
l_int|0
suffix:semicolon
DECL|variable|commit_prefix
r_static
r_const
r_char
op_star
id|commit_prefix
op_assign
l_string|&quot;&quot;
suffix:semicolon
DECL|variable|max_age
r_static
r_int
r_int
id|max_age
op_assign
l_int|1
suffix:semicolon
DECL|variable|min_age
r_static
r_int
r_int
id|min_age
op_assign
l_int|1
suffix:semicolon
DECL|variable|max_count
r_static
r_int
id|max_count
op_assign
l_int|1
suffix:semicolon
DECL|variable|commit_format
r_static
r_enum
id|cmit_fmt
id|commit_format
op_assign
id|CMIT_FMT_RAW
suffix:semicolon
DECL|variable|merge_order
r_static
r_int
id|merge_order
op_assign
l_int|0
suffix:semicolon
DECL|variable|show_breaks
r_static
r_int
id|show_breaks
op_assign
l_int|0
suffix:semicolon
DECL|variable|stop_traversal
r_static
r_int
id|stop_traversal
op_assign
l_int|0
suffix:semicolon
DECL|variable|topo_order
r_static
r_int
id|topo_order
op_assign
l_int|0
suffix:semicolon
DECL|variable|no_merges
r_static
r_int
id|no_merges
op_assign
l_int|0
suffix:semicolon
DECL|variable|paths
r_static
r_const
r_char
op_star
op_star
id|paths
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|remove_empty_trees
r_static
r_int
id|remove_empty_trees
op_assign
l_int|0
suffix:semicolon
DECL|function|show_commit
r_static
r_void
id|show_commit
c_func
(paren
r_struct
id|commit
op_star
id|commit
)paren
(brace
id|commit-&gt;object.flags
op_or_assign
id|SHOWN
suffix:semicolon
r_if
c_cond
(paren
id|show_breaks
)paren
(brace
id|commit_prefix
op_assign
l_string|&quot;| &quot;
suffix:semicolon
r_if
c_cond
(paren
id|commit-&gt;object.flags
op_amp
id|DISCONTINUITY
)paren
(brace
id|commit_prefix
op_assign
l_string|&quot;^ &quot;
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|commit-&gt;object.flags
op_amp
id|BOUNDARY
)paren
(brace
id|commit_prefix
op_assign
l_string|&quot;= &quot;
suffix:semicolon
)brace
)brace
id|printf
c_func
(paren
l_string|&quot;%s%s&quot;
comma
id|commit_prefix
comma
id|sha1_to_hex
c_func
(paren
id|commit-&gt;object.sha1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|show_parents
)paren
(brace
r_struct
id|commit_list
op_star
id|parents
op_assign
id|commit-&gt;parents
suffix:semicolon
r_while
c_loop
(paren
id|parents
)paren
(brace
r_struct
id|object
op_star
id|o
op_assign
op_amp
(paren
id|parents-&gt;item-&gt;object
)paren
suffix:semicolon
id|parents
op_assign
id|parents-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|o-&gt;flags
op_amp
id|TMP_MARK
)paren
r_continue
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot; %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|o-&gt;sha1
)paren
)paren
suffix:semicolon
id|o-&gt;flags
op_or_assign
id|TMP_MARK
suffix:semicolon
)brace
multiline_comment|/* TMP_MARK is a general purpose flag that can&n;&t;&t; * be used locally, but the user should clean&n;&t;&t; * things up after it is done with them.&n;&t;&t; */
r_for
c_loop
(paren
id|parents
op_assign
id|commit-&gt;parents
suffix:semicolon
id|parents
suffix:semicolon
id|parents
op_assign
id|parents-&gt;next
)paren
id|parents-&gt;item-&gt;object.flags
op_and_assign
op_complement
id|TMP_MARK
suffix:semicolon
)brace
r_if
c_cond
(paren
id|commit_format
op_eq
id|CMIT_FMT_ONELINE
)paren
id|putchar
c_func
(paren
l_char|&squot; &squot;
)paren
suffix:semicolon
r_else
id|putchar
c_func
(paren
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|verbose_header
)paren
(brace
r_static
r_char
id|pretty_header
(braket
l_int|16384
)braket
suffix:semicolon
id|pretty_print_commit
c_func
(paren
id|commit_format
comma
id|commit
comma
op_complement
l_int|0
comma
id|pretty_header
comma
r_sizeof
(paren
id|pretty_header
)paren
comma
l_int|0
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s%c&quot;
comma
id|pretty_header
comma
id|hdr_termination
)paren
suffix:semicolon
)brace
id|fflush
c_func
(paren
id|stdout
)paren
suffix:semicolon
)brace
DECL|function|rewrite_one
r_static
r_int
id|rewrite_one
c_func
(paren
r_struct
id|commit
op_star
op_star
id|pp
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|commit
op_star
id|p
op_assign
op_star
id|pp
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;object.flags
op_amp
(paren
id|TREECHANGE
op_or
id|UNINTERESTING
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;parents
)paren
r_return
l_int|1
suffix:semicolon
op_star
id|pp
op_assign
id|p-&gt;parents-&gt;item
suffix:semicolon
)brace
)brace
DECL|function|rewrite_parents
r_static
r_void
id|rewrite_parents
c_func
(paren
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_struct
id|commit_list
op_star
op_star
id|pp
op_assign
op_amp
id|commit-&gt;parents
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pp
)paren
(brace
r_struct
id|commit_list
op_star
id|parent
op_assign
op_star
id|pp
suffix:semicolon
r_if
c_cond
(paren
id|rewrite_one
c_func
(paren
op_amp
id|parent-&gt;item
)paren
OL
l_int|0
)paren
(brace
op_star
id|pp
op_assign
id|parent-&gt;next
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|pp
op_assign
op_amp
id|parent-&gt;next
suffix:semicolon
)brace
)brace
DECL|function|filter_commit
r_static
r_int
id|filter_commit
c_func
(paren
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_if
c_cond
(paren
id|stop_traversal
op_logical_and
(paren
id|commit-&gt;object.flags
op_amp
id|BOUNDARY
)paren
)paren
r_return
id|STOP
suffix:semicolon
r_if
c_cond
(paren
id|commit-&gt;object.flags
op_amp
(paren
id|UNINTERESTING
op_or
id|SHOWN
)paren
)paren
r_return
id|CONTINUE
suffix:semicolon
r_if
c_cond
(paren
id|min_age
op_ne
l_int|1
op_logical_and
(paren
id|commit-&gt;date
OG
id|min_age
)paren
)paren
r_return
id|CONTINUE
suffix:semicolon
r_if
c_cond
(paren
id|max_age
op_ne
l_int|1
op_logical_and
(paren
id|commit-&gt;date
OL
id|max_age
)paren
)paren
(brace
id|stop_traversal
op_assign
l_int|1
suffix:semicolon
r_return
id|CONTINUE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|no_merges
op_logical_and
(paren
id|commit-&gt;parents
op_logical_and
id|commit-&gt;parents-&gt;next
)paren
)paren
r_return
id|CONTINUE
suffix:semicolon
r_if
c_cond
(paren
id|paths
op_logical_and
id|dense
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|commit-&gt;object.flags
op_amp
id|TREECHANGE
)paren
)paren
r_return
id|CONTINUE
suffix:semicolon
id|rewrite_parents
c_func
(paren
id|commit
)paren
suffix:semicolon
)brace
r_return
id|DO
suffix:semicolon
)brace
DECL|function|process_commit
r_static
r_int
id|process_commit
c_func
(paren
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_int
id|action
op_assign
id|filter_commit
c_func
(paren
id|commit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|action
op_eq
id|STOP
)paren
(brace
r_return
id|STOP
suffix:semicolon
)brace
r_if
c_cond
(paren
id|action
op_eq
id|CONTINUE
)paren
(brace
r_return
id|CONTINUE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|max_count
op_ne
l_int|1
op_logical_and
op_logical_neg
id|max_count
op_decrement
)paren
r_return
id|STOP
suffix:semicolon
id|show_commit
c_func
(paren
id|commit
)paren
suffix:semicolon
r_return
id|CONTINUE
suffix:semicolon
)brace
DECL|function|add_object
r_static
r_struct
id|object_list
op_star
op_star
id|add_object
c_func
(paren
r_struct
id|object
op_star
id|obj
comma
r_struct
id|object_list
op_star
op_star
id|p
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|object_list
op_star
id|entry
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|entry
)paren
)paren
suffix:semicolon
id|entry-&gt;item
op_assign
id|obj
suffix:semicolon
id|entry-&gt;next
op_assign
op_star
id|p
suffix:semicolon
id|entry-&gt;name
op_assign
id|name
suffix:semicolon
op_star
id|p
op_assign
id|entry
suffix:semicolon
r_return
op_amp
id|entry-&gt;next
suffix:semicolon
)brace
DECL|function|process_blob
r_static
r_struct
id|object_list
op_star
op_star
id|process_blob
c_func
(paren
r_struct
id|blob
op_star
id|blob
comma
r_struct
id|object_list
op_star
op_star
id|p
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|object
op_star
id|obj
op_assign
op_amp
id|blob-&gt;object
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|blob_objects
)paren
r_return
id|p
suffix:semicolon
r_if
c_cond
(paren
id|obj-&gt;flags
op_amp
(paren
id|UNINTERESTING
op_or
id|SEEN
)paren
)paren
r_return
id|p
suffix:semicolon
id|obj-&gt;flags
op_or_assign
id|SEEN
suffix:semicolon
r_return
id|add_object
c_func
(paren
id|obj
comma
id|p
comma
id|name
)paren
suffix:semicolon
)brace
DECL|function|process_tree
r_static
r_struct
id|object_list
op_star
op_star
id|process_tree
c_func
(paren
r_struct
id|tree
op_star
id|tree
comma
r_struct
id|object_list
op_star
op_star
id|p
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|object
op_star
id|obj
op_assign
op_amp
id|tree-&gt;object
suffix:semicolon
r_struct
id|tree_entry_list
op_star
id|entry
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tree_objects
)paren
r_return
id|p
suffix:semicolon
r_if
c_cond
(paren
id|obj-&gt;flags
op_amp
(paren
id|UNINTERESTING
op_or
id|SEEN
)paren
)paren
r_return
id|p
suffix:semicolon
r_if
c_cond
(paren
id|parse_tree
c_func
(paren
id|tree
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;bad tree object %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|obj-&gt;sha1
)paren
)paren
suffix:semicolon
id|obj-&gt;flags
op_or_assign
id|SEEN
suffix:semicolon
id|p
op_assign
id|add_object
c_func
(paren
id|obj
comma
id|p
comma
id|name
)paren
suffix:semicolon
id|entry
op_assign
id|tree-&gt;entries
suffix:semicolon
id|tree-&gt;entries
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|entry
)paren
(brace
r_struct
id|tree_entry_list
op_star
id|next
op_assign
id|entry-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;directory
)paren
id|p
op_assign
id|process_tree
c_func
(paren
id|entry-&gt;item.tree
comma
id|p
comma
id|entry-&gt;name
)paren
suffix:semicolon
r_else
id|p
op_assign
id|process_blob
c_func
(paren
id|entry-&gt;item.blob
comma
id|p
comma
id|entry-&gt;name
)paren
suffix:semicolon
id|free
c_func
(paren
id|entry
)paren
suffix:semicolon
id|entry
op_assign
id|next
suffix:semicolon
)brace
r_return
id|p
suffix:semicolon
)brace
DECL|variable|pending_objects
r_static
r_struct
id|object_list
op_star
id|pending_objects
op_assign
l_int|NULL
suffix:semicolon
DECL|function|show_commit_list
r_static
r_void
id|show_commit_list
c_func
(paren
r_struct
id|commit_list
op_star
id|list
)paren
(brace
r_struct
id|object_list
op_star
id|objects
op_assign
l_int|NULL
comma
op_star
op_star
id|p
op_assign
op_amp
id|objects
comma
op_star
id|pending
suffix:semicolon
r_while
c_loop
(paren
id|list
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
id|pop_most_recent_commit
c_func
(paren
op_amp
id|list
comma
id|SEEN
)paren
suffix:semicolon
id|p
op_assign
id|process_tree
c_func
(paren
id|commit-&gt;tree
comma
id|p
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|process_commit
c_func
(paren
id|commit
)paren
op_eq
id|STOP
)paren
r_break
suffix:semicolon
)brace
r_for
c_loop
(paren
id|pending
op_assign
id|pending_objects
suffix:semicolon
id|pending
suffix:semicolon
id|pending
op_assign
id|pending-&gt;next
)paren
(brace
r_struct
id|object
op_star
id|obj
op_assign
id|pending-&gt;item
suffix:semicolon
r_const
r_char
op_star
id|name
op_assign
id|pending-&gt;name
suffix:semicolon
r_if
c_cond
(paren
id|obj-&gt;flags
op_amp
(paren
id|UNINTERESTING
op_or
id|SEEN
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|obj-&gt;type
op_eq
id|tag_type
)paren
(brace
id|obj-&gt;flags
op_or_assign
id|SEEN
suffix:semicolon
id|p
op_assign
id|add_object
c_func
(paren
id|obj
comma
id|p
comma
id|name
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|obj-&gt;type
op_eq
id|tree_type
)paren
(brace
id|p
op_assign
id|process_tree
c_func
(paren
(paren
r_struct
id|tree
op_star
)paren
id|obj
comma
id|p
comma
id|name
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|obj-&gt;type
op_eq
id|blob_type
)paren
(brace
id|p
op_assign
id|process_blob
c_func
(paren
(paren
r_struct
id|blob
op_star
)paren
id|obj
comma
id|p
comma
id|name
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|die
c_func
(paren
l_string|&quot;unknown pending object %s (%s)&quot;
comma
id|sha1_to_hex
c_func
(paren
id|obj-&gt;sha1
)paren
comma
id|name
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|objects
)paren
(brace
multiline_comment|/* An object with name &quot;foo&bslash;n0000000000000000000000000000000000000000&quot;&n;&t;&t; * can be used confuse downstream git-pack-objects very badly.&n;&t;&t; */
r_const
r_char
op_star
id|ep
op_assign
id|strchr
c_func
(paren
id|objects-&gt;name
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ep
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s %.*s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|objects-&gt;item-&gt;sha1
)paren
comma
(paren
r_int
)paren
(paren
id|ep
id|objects-&gt;name
)paren
comma
id|objects-&gt;name
)paren
suffix:semicolon
)brace
r_else
id|printf
c_func
(paren
l_string|&quot;%s %s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|objects-&gt;item-&gt;sha1
)paren
comma
id|objects-&gt;name
)paren
suffix:semicolon
id|objects
op_assign
id|objects-&gt;next
suffix:semicolon
)brace
)brace
DECL|function|mark_blob_uninteresting
r_static
r_void
id|mark_blob_uninteresting
c_func
(paren
r_struct
id|blob
op_star
id|blob
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|blob_objects
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|blob-&gt;object.flags
op_amp
id|UNINTERESTING
)paren
r_return
suffix:semicolon
id|blob-&gt;object.flags
op_or_assign
id|UNINTERESTING
suffix:semicolon
)brace
DECL|function|mark_tree_uninteresting
r_static
r_void
id|mark_tree_uninteresting
c_func
(paren
r_struct
id|tree
op_star
id|tree
)paren
(brace
r_struct
id|object
op_star
id|obj
op_assign
op_amp
id|tree-&gt;object
suffix:semicolon
r_struct
id|tree_entry_list
op_star
id|entry
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tree_objects
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|obj-&gt;flags
op_amp
id|UNINTERESTING
)paren
r_return
suffix:semicolon
id|obj-&gt;flags
op_or_assign
id|UNINTERESTING
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|has_sha1_file
c_func
(paren
id|obj-&gt;sha1
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|parse_tree
c_func
(paren
id|tree
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;bad tree %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|obj-&gt;sha1
)paren
)paren
suffix:semicolon
id|entry
op_assign
id|tree-&gt;entries
suffix:semicolon
id|tree-&gt;entries
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|entry
)paren
(brace
r_struct
id|tree_entry_list
op_star
id|next
op_assign
id|entry-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;directory
)paren
id|mark_tree_uninteresting
c_func
(paren
id|entry-&gt;item.tree
)paren
suffix:semicolon
r_else
id|mark_blob_uninteresting
c_func
(paren
id|entry-&gt;item.blob
)paren
suffix:semicolon
id|free
c_func
(paren
id|entry
)paren
suffix:semicolon
id|entry
op_assign
id|next
suffix:semicolon
)brace
)brace
DECL|function|mark_parents_uninteresting
r_static
r_void
id|mark_parents_uninteresting
c_func
(paren
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_struct
id|commit_list
op_star
id|parents
op_assign
id|commit-&gt;parents
suffix:semicolon
r_while
c_loop
(paren
id|parents
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
id|parents-&gt;item
suffix:semicolon
id|commit-&gt;object.flags
op_or_assign
id|UNINTERESTING
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Normally we haven&squot;t parsed the parent&n;&t;&t; * yet, so we won&squot;t have a parent of a parent&n;&t;&t; * here. However, it may turn out that we&squot;ve&n;&t;&t; * reached this commit some other way (where it&n;&t;&t; * wasn&squot;t uninteresting), in which case we need&n;&t;&t; * to mark its parents recursively too..&n;&t;&t; */
r_if
c_cond
(paren
id|commit-&gt;parents
)paren
id|mark_parents_uninteresting
c_func
(paren
id|commit
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * A missing commit is ok iff its parent is marked &n;&t;&t; * uninteresting.&n;&t;&t; *&n;&t;&t; * We just mark such a thing parsed, so that when&n;&t;&t; * it is popped next time around, we won&squot;t be trying&n;&t;&t; * to parse it and get an error.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|has_sha1_file
c_func
(paren
id|commit-&gt;object.sha1
)paren
)paren
id|commit-&gt;object.parsed
op_assign
l_int|1
suffix:semicolon
id|parents
op_assign
id|parents-&gt;next
suffix:semicolon
)brace
)brace
DECL|function|everybody_uninteresting
r_static
r_int
id|everybody_uninteresting
c_func
(paren
r_struct
id|commit_list
op_star
id|orig
)paren
(brace
r_struct
id|commit_list
op_star
id|list
op_assign
id|orig
suffix:semicolon
r_while
c_loop
(paren
id|list
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
id|list-&gt;item
suffix:semicolon
id|list
op_assign
id|list-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|commit-&gt;object.flags
op_amp
id|UNINTERESTING
)paren
r_continue
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * This is a truly stupid algorithm, but it&squot;s only&n; * used for bisection, and we just don&squot;t care enough.&n; *&n; * We care just barely enough to avoid recursing for&n; * non-merge entries.&n; */
DECL|function|count_distance
r_static
r_int
id|count_distance
c_func
(paren
r_struct
id|commit_list
op_star
id|entry
)paren
(brace
r_int
id|nr
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|entry
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
id|entry-&gt;item
suffix:semicolon
r_struct
id|commit_list
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|commit-&gt;object.flags
op_amp
(paren
id|UNINTERESTING
op_or
id|COUNTED
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|paths
op_logical_or
(paren
id|commit-&gt;object.flags
op_amp
id|TREECHANGE
)paren
)paren
id|nr
op_increment
suffix:semicolon
id|commit-&gt;object.flags
op_or_assign
id|COUNTED
suffix:semicolon
id|p
op_assign
id|commit-&gt;parents
suffix:semicolon
id|entry
op_assign
id|p
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
(brace
id|p
op_assign
id|p-&gt;next
suffix:semicolon
r_while
c_loop
(paren
id|p
)paren
(brace
id|nr
op_add_assign
id|count_distance
c_func
(paren
id|p
)paren
suffix:semicolon
id|p
op_assign
id|p-&gt;next
suffix:semicolon
)brace
)brace
)brace
r_return
id|nr
suffix:semicolon
)brace
DECL|function|clear_distance
r_static
r_void
id|clear_distance
c_func
(paren
r_struct
id|commit_list
op_star
id|list
)paren
(brace
r_while
c_loop
(paren
id|list
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
id|list-&gt;item
suffix:semicolon
id|commit-&gt;object.flags
op_and_assign
op_complement
id|COUNTED
suffix:semicolon
id|list
op_assign
id|list-&gt;next
suffix:semicolon
)brace
)brace
DECL|function|find_bisection
r_static
r_struct
id|commit_list
op_star
id|find_bisection
c_func
(paren
r_struct
id|commit_list
op_star
id|list
)paren
(brace
r_int
id|nr
comma
id|closest
suffix:semicolon
r_struct
id|commit_list
op_star
id|p
comma
op_star
id|best
suffix:semicolon
id|nr
op_assign
l_int|0
suffix:semicolon
id|p
op_assign
id|list
suffix:semicolon
r_while
c_loop
(paren
id|p
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|paths
op_logical_or
(paren
id|p-&gt;item-&gt;object.flags
op_amp
id|TREECHANGE
)paren
)paren
id|nr
op_increment
suffix:semicolon
id|p
op_assign
id|p-&gt;next
suffix:semicolon
)brace
id|closest
op_assign
l_int|0
suffix:semicolon
id|best
op_assign
id|list
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|list
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_int
id|distance
suffix:semicolon
r_if
c_cond
(paren
id|paths
op_logical_and
op_logical_neg
(paren
id|p-&gt;item-&gt;object.flags
op_amp
id|TREECHANGE
)paren
)paren
r_continue
suffix:semicolon
id|distance
op_assign
id|count_distance
c_func
(paren
id|p
)paren
suffix:semicolon
id|clear_distance
c_func
(paren
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr
id|distance
OL
id|distance
)paren
id|distance
op_assign
id|nr
id|distance
suffix:semicolon
r_if
c_cond
(paren
id|distance
OG
id|closest
)paren
(brace
id|best
op_assign
id|p
suffix:semicolon
id|closest
op_assign
id|distance
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|best
)paren
id|best-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_return
id|best
suffix:semicolon
)brace
DECL|function|mark_edges_uninteresting
r_static
r_void
id|mark_edges_uninteresting
c_func
(paren
r_struct
id|commit_list
op_star
id|list
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|list
suffix:semicolon
id|list
op_assign
id|list-&gt;next
)paren
(brace
r_struct
id|commit_list
op_star
id|parents
op_assign
id|list-&gt;item-&gt;parents
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|parents
suffix:semicolon
id|parents
op_assign
id|parents-&gt;next
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
id|parents-&gt;item
suffix:semicolon
r_if
c_cond
(paren
id|commit-&gt;object.flags
op_amp
id|UNINTERESTING
)paren
id|mark_tree_uninteresting
c_func
(paren
id|commit-&gt;tree
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|macro|TREE_SAME
mdefine_line|#define TREE_SAME&t;0
DECL|macro|TREE_NEW
mdefine_line|#define TREE_NEW&t;1
DECL|macro|TREE_DIFFERENT
mdefine_line|#define TREE_DIFFERENT&t;2
DECL|variable|tree_difference
r_static
r_int
id|tree_difference
op_assign
id|TREE_SAME
suffix:semicolon
DECL|function|file_add_remove
r_static
r_void
id|file_add_remove
c_func
(paren
r_struct
id|diff_options
op_star
id|options
comma
r_int
id|addremove
comma
r_int
id|mode
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_const
r_char
op_star
id|base
comma
r_const
r_char
op_star
id|path
)paren
(brace
r_int
id|diff
op_assign
id|TREE_DIFFERENT
suffix:semicolon
multiline_comment|/*&n;&t; * Is it an add of a new file? It means that&n;&t; * the old tree didn&squot;t have it at all, so we&n;&t; * will turn &quot;TREE_SAME&quot; -&gt; &quot;TREE_NEW&quot;, but&n;&t; * leave any &quot;TREE_DIFFERENT&quot; alone (and if&n;&t; * it already was &quot;TREE_NEW&quot;, we&squot;ll keep it&n;&t; * &quot;TREE_NEW&quot; of course).&n;&t; */
r_if
c_cond
(paren
id|addremove
op_eq
l_char|&squot;+&squot;
)paren
(brace
id|diff
op_assign
id|tree_difference
suffix:semicolon
r_if
c_cond
(paren
id|diff
op_ne
id|TREE_SAME
)paren
r_return
suffix:semicolon
id|diff
op_assign
id|TREE_NEW
suffix:semicolon
)brace
id|tree_difference
op_assign
id|diff
suffix:semicolon
)brace
DECL|function|file_change
r_static
r_void
id|file_change
c_func
(paren
r_struct
id|diff_options
op_star
id|options
comma
r_int
id|old_mode
comma
r_int
id|new_mode
comma
r_const
r_int
r_char
op_star
id|old_sha1
comma
r_const
r_int
r_char
op_star
id|new_sha1
comma
r_const
r_char
op_star
id|base
comma
r_const
r_char
op_star
id|path
)paren
(brace
id|tree_difference
op_assign
id|TREE_DIFFERENT
suffix:semicolon
)brace
DECL|variable|diff_opt
r_static
r_struct
id|diff_options
id|diff_opt
op_assign
(brace
dot
id|recursive
op_assign
l_int|1
comma
dot
id|add_remove
op_assign
id|file_add_remove
comma
dot
id|change
op_assign
id|file_change
comma
)brace
suffix:semicolon
DECL|function|compare_tree
r_static
r_int
id|compare_tree
c_func
(paren
r_struct
id|tree
op_star
id|t1
comma
r_struct
id|tree
op_star
id|t2
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|t1
)paren
r_return
id|TREE_NEW
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|t2
)paren
r_return
id|TREE_DIFFERENT
suffix:semicolon
id|tree_difference
op_assign
id|TREE_SAME
suffix:semicolon
r_if
c_cond
(paren
id|diff_tree_sha1
c_func
(paren
id|t1-&gt;object.sha1
comma
id|t2-&gt;object.sha1
comma
l_string|&quot;&quot;
comma
op_amp
id|diff_opt
)paren
OL
l_int|0
)paren
r_return
id|TREE_DIFFERENT
suffix:semicolon
r_return
id|tree_difference
suffix:semicolon
)brace
DECL|function|same_tree_as_empty
r_static
r_int
id|same_tree_as_empty
c_func
(paren
r_struct
id|tree
op_star
id|t1
)paren
(brace
r_int
id|retval
suffix:semicolon
r_void
op_star
id|tree
suffix:semicolon
r_struct
id|tree_desc
id|empty
comma
id|real
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|t1
)paren
r_return
l_int|0
suffix:semicolon
id|tree
op_assign
id|read_object_with_reference
c_func
(paren
id|t1-&gt;object.sha1
comma
l_string|&quot;tree&quot;
comma
op_amp
id|real.size
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tree
)paren
r_return
l_int|0
suffix:semicolon
id|real.buf
op_assign
id|tree
suffix:semicolon
id|empty.buf
op_assign
l_string|&quot;&quot;
suffix:semicolon
id|empty.size
op_assign
l_int|0
suffix:semicolon
id|tree_difference
op_assign
l_int|0
suffix:semicolon
id|retval
op_assign
id|diff_tree
c_func
(paren
op_amp
id|empty
comma
op_amp
id|real
comma
l_string|&quot;&quot;
comma
op_amp
id|diff_opt
)paren
suffix:semicolon
id|free
c_func
(paren
id|tree
)paren
suffix:semicolon
r_return
id|retval
op_ge
l_int|0
op_logical_and
op_logical_neg
id|tree_difference
suffix:semicolon
)brace
DECL|function|try_to_simplify_commit
r_static
r_void
id|try_to_simplify_commit
c_func
(paren
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_struct
id|commit_list
op_star
op_star
id|pp
comma
op_star
id|parent
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|commit-&gt;tree
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|commit-&gt;parents
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|same_tree_as_empty
c_func
(paren
id|commit-&gt;tree
)paren
)paren
id|commit-&gt;object.flags
op_or_assign
id|TREECHANGE
suffix:semicolon
r_return
suffix:semicolon
)brace
id|pp
op_assign
op_amp
id|commit-&gt;parents
suffix:semicolon
r_while
c_loop
(paren
(paren
id|parent
op_assign
op_star
id|pp
)paren
op_ne
l_int|NULL
)paren
(brace
r_struct
id|commit
op_star
id|p
op_assign
id|parent-&gt;item
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;object.flags
op_amp
id|UNINTERESTING
)paren
(brace
id|pp
op_assign
op_amp
id|parent-&gt;next
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|parse_commit
c_func
(paren
id|p
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|compare_tree
c_func
(paren
id|p-&gt;tree
comma
id|commit-&gt;tree
)paren
)paren
(brace
r_case
id|TREE_SAME
suffix:colon
id|parent-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|commit-&gt;parents
op_assign
id|parent
suffix:semicolon
r_return
suffix:semicolon
r_case
id|TREE_NEW
suffix:colon
r_if
c_cond
(paren
id|remove_empty_trees
op_logical_and
id|same_tree_as_empty
c_func
(paren
id|p-&gt;tree
)paren
)paren
(brace
op_star
id|pp
op_assign
id|parent-&gt;next
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* fallthrough */
r_case
id|TREE_DIFFERENT
suffix:colon
id|pp
op_assign
op_amp
id|parent-&gt;next
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|die
c_func
(paren
l_string|&quot;bad tree compare for commit %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|commit-&gt;object.sha1
)paren
)paren
suffix:semicolon
)brace
id|commit-&gt;object.flags
op_or_assign
id|TREECHANGE
suffix:semicolon
)brace
DECL|function|add_parents_to_list
r_static
r_void
id|add_parents_to_list
c_func
(paren
r_struct
id|commit
op_star
id|commit
comma
r_struct
id|commit_list
op_star
op_star
id|list
)paren
(brace
r_struct
id|commit_list
op_star
id|parent
op_assign
id|commit-&gt;parents
suffix:semicolon
multiline_comment|/*&n;&t; * If the commit is uninteresting, don&squot;t try to&n;&t; * prune parents - we want the maximal uninteresting&n;&t; * set.&n;&t; *&n;&t; * Normally we haven&squot;t parsed the parent&n;&t; * yet, so we won&squot;t have a parent of a parent&n;&t; * here. However, it may turn out that we&squot;ve&n;&t; * reached this commit some other way (where it&n;&t; * wasn&squot;t uninteresting), in which case we need&n;&t; * to mark its parents recursively too..&n;&t; */
r_if
c_cond
(paren
id|commit-&gt;object.flags
op_amp
id|UNINTERESTING
)paren
(brace
r_while
c_loop
(paren
id|parent
)paren
(brace
r_struct
id|commit
op_star
id|p
op_assign
id|parent-&gt;item
suffix:semicolon
id|parent
op_assign
id|parent-&gt;next
suffix:semicolon
id|parse_commit
c_func
(paren
id|p
)paren
suffix:semicolon
id|p-&gt;object.flags
op_or_assign
id|UNINTERESTING
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;parents
)paren
id|mark_parents_uninteresting
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;object.flags
op_amp
id|SEEN
)paren
r_continue
suffix:semicolon
id|p-&gt;object.flags
op_or_assign
id|SEEN
suffix:semicolon
id|insert_by_date
c_func
(paren
id|p
comma
id|list
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Ok, the commit wasn&squot;t uninteresting. Try to&n;&t; * simplify the commit history and find the parent&n;&t; * that has no differences in the path set if one exists.&n;&t; */
r_if
c_cond
(paren
id|paths
)paren
id|try_to_simplify_commit
c_func
(paren
id|commit
)paren
suffix:semicolon
id|parent
op_assign
id|commit-&gt;parents
suffix:semicolon
r_while
c_loop
(paren
id|parent
)paren
(brace
r_struct
id|commit
op_star
id|p
op_assign
id|parent-&gt;item
suffix:semicolon
id|parent
op_assign
id|parent-&gt;next
suffix:semicolon
id|parse_commit
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;object.flags
op_amp
id|SEEN
)paren
r_continue
suffix:semicolon
id|p-&gt;object.flags
op_or_assign
id|SEEN
suffix:semicolon
id|insert_by_date
c_func
(paren
id|p
comma
id|list
)paren
suffix:semicolon
)brace
)brace
DECL|function|limit_list
r_static
r_struct
id|commit_list
op_star
id|limit_list
c_func
(paren
r_struct
id|commit_list
op_star
id|list
)paren
(brace
r_struct
id|commit_list
op_star
id|newlist
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|commit_list
op_star
op_star
id|p
op_assign
op_amp
id|newlist
suffix:semicolon
r_while
c_loop
(paren
id|list
)paren
(brace
r_struct
id|commit_list
op_star
id|entry
op_assign
id|list
suffix:semicolon
r_struct
id|commit
op_star
id|commit
op_assign
id|list-&gt;item
suffix:semicolon
r_struct
id|object
op_star
id|obj
op_assign
op_amp
id|commit-&gt;object
suffix:semicolon
id|list
op_assign
id|list-&gt;next
suffix:semicolon
id|free
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|max_age
op_ne
l_int|1
op_logical_and
(paren
id|commit-&gt;date
OL
id|max_age
)paren
)paren
id|obj-&gt;flags
op_or_assign
id|UNINTERESTING
suffix:semicolon
r_if
c_cond
(paren
id|unpacked
op_logical_and
id|has_sha1_pack
c_func
(paren
id|obj-&gt;sha1
)paren
)paren
id|obj-&gt;flags
op_or_assign
id|UNINTERESTING
suffix:semicolon
id|add_parents_to_list
c_func
(paren
id|commit
comma
op_amp
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|obj-&gt;flags
op_amp
id|UNINTERESTING
)paren
(brace
id|mark_parents_uninteresting
c_func
(paren
id|commit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|everybody_uninteresting
c_func
(paren
id|list
)paren
)paren
r_break
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|min_age
op_ne
l_int|1
op_logical_and
(paren
id|commit-&gt;date
OG
id|min_age
)paren
)paren
r_continue
suffix:semicolon
id|p
op_assign
op_amp
id|commit_list_insert
c_func
(paren
id|commit
comma
id|p
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tree_objects
)paren
id|mark_edges_uninteresting
c_func
(paren
id|newlist
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bisect_list
)paren
id|newlist
op_assign
id|find_bisection
c_func
(paren
id|newlist
)paren
suffix:semicolon
r_return
id|newlist
suffix:semicolon
)brace
DECL|function|add_pending_object
r_static
r_void
id|add_pending_object
c_func
(paren
r_struct
id|object
op_star
id|obj
comma
r_const
r_char
op_star
id|name
)paren
(brace
id|add_object
c_func
(paren
id|obj
comma
op_amp
id|pending_objects
comma
id|name
)paren
suffix:semicolon
)brace
DECL|function|get_commit_reference
r_static
r_struct
id|commit
op_star
id|get_commit_reference
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
r_int
id|flags
)paren
(brace
r_struct
id|object
op_star
id|object
suffix:semicolon
id|object
op_assign
id|parse_object
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|object
)paren
id|die
c_func
(paren
l_string|&quot;bad object %s&quot;
comma
id|name
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Tag object? Look what it points to..&n;&t; */
r_while
c_loop
(paren
id|object-&gt;type
op_eq
id|tag_type
)paren
(brace
r_struct
id|tag
op_star
id|tag
op_assign
(paren
r_struct
id|tag
op_star
)paren
id|object
suffix:semicolon
id|object-&gt;flags
op_or_assign
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|tag_objects
op_logical_and
op_logical_neg
(paren
id|object-&gt;flags
op_amp
id|UNINTERESTING
)paren
)paren
id|add_pending_object
c_func
(paren
id|object
comma
id|tag-&gt;tag
)paren
suffix:semicolon
id|object
op_assign
id|parse_object
c_func
(paren
id|tag-&gt;tagged-&gt;sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|object
)paren
id|die
c_func
(paren
l_string|&quot;bad object %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|tag-&gt;tagged-&gt;sha1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Commit object? Just return it, we&squot;ll do all the complex&n;&t; * reachability crud.&n;&t; */
r_if
c_cond
(paren
id|object-&gt;type
op_eq
id|commit_type
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
(paren
r_struct
id|commit
op_star
)paren
id|object
suffix:semicolon
id|object-&gt;flags
op_or_assign
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|parse_commit
c_func
(paren
id|commit
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;unable to parse commit %s&quot;
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|UNINTERESTING
)paren
id|mark_parents_uninteresting
c_func
(paren
id|commit
)paren
suffix:semicolon
r_return
id|commit
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Tree object? Either mark it uniniteresting, or add it&n;&t; * to the list of objects to look at later..&n;&t; */
r_if
c_cond
(paren
id|object-&gt;type
op_eq
id|tree_type
)paren
(brace
r_struct
id|tree
op_star
id|tree
op_assign
(paren
r_struct
id|tree
op_star
)paren
id|object
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tree_objects
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|UNINTERESTING
)paren
(brace
id|mark_tree_uninteresting
c_func
(paren
id|tree
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|add_pending_object
c_func
(paren
id|object
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Blob object? You know the drill by now..&n;&t; */
r_if
c_cond
(paren
id|object-&gt;type
op_eq
id|blob_type
)paren
(brace
r_struct
id|blob
op_star
id|blob
op_assign
(paren
r_struct
id|blob
op_star
)paren
id|object
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|blob_objects
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|UNINTERESTING
)paren
(brace
id|mark_blob_uninteresting
c_func
(paren
id|blob
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|add_pending_object
c_func
(paren
id|object
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|die
c_func
(paren
l_string|&quot;%s is unknown object&quot;
comma
id|name
)paren
suffix:semicolon
)brace
DECL|function|handle_one_commit
r_static
r_void
id|handle_one_commit
c_func
(paren
r_struct
id|commit
op_star
id|com
comma
r_struct
id|commit_list
op_star
op_star
id|lst
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|com
op_logical_or
id|com-&gt;object.flags
op_amp
id|SEEN
)paren
r_return
suffix:semicolon
id|com-&gt;object.flags
op_or_assign
id|SEEN
suffix:semicolon
id|commit_list_insert
c_func
(paren
id|com
comma
id|lst
)paren
suffix:semicolon
)brace
multiline_comment|/* for_each_ref() callback does not allow user data -- Yuck. */
DECL|variable|global_lst
r_static
r_struct
id|commit_list
op_star
op_star
id|global_lst
suffix:semicolon
DECL|function|include_one_commit
r_static
r_int
id|include_one_commit
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_struct
id|commit
op_star
id|com
op_assign
id|get_commit_reference
c_func
(paren
id|path
comma
id|sha1
comma
l_int|0
)paren
suffix:semicolon
id|handle_one_commit
c_func
(paren
id|com
comma
id|global_lst
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|handle_all
r_static
r_void
id|handle_all
c_func
(paren
r_struct
id|commit_list
op_star
op_star
id|lst
)paren
(brace
id|global_lst
op_assign
id|lst
suffix:semicolon
id|for_each_ref
c_func
(paren
id|include_one_commit
)paren
suffix:semicolon
id|global_lst
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|main
r_int
id|main
c_func
(paren
r_int
id|argc
comma
r_const
r_char
op_star
op_star
id|argv
)paren
(brace
r_const
r_char
op_star
id|prefix
op_assign
id|setup_git_directory
c_func
(paren
)paren
suffix:semicolon
r_struct
id|commit_list
op_star
id|list
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
comma
id|limited
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|argc
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|flags
suffix:semicolon
r_const
r_char
op_star
id|arg
op_assign
id|argv
(braket
id|i
)braket
suffix:semicolon
r_char
op_star
id|dotdot
suffix:semicolon
r_struct
id|commit
op_star
id|commit
suffix:semicolon
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
multiline_comment|/* accept -&lt;digit&gt;, like traditilnal &quot;head&quot; */
r_if
c_cond
(paren
(paren
op_star
id|arg
op_eq
l_char|&squot;-&squot;
)paren
op_logical_and
id|isdigit
c_func
(paren
id|arg
(braket
l_int|1
)braket
)paren
)paren
(brace
id|max_count
op_assign
id|atoi
c_func
(paren
id|arg
op_plus
l_int|1
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;-n&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_increment
id|i
op_ge
id|argc
)paren
id|die
c_func
(paren
l_string|&quot;-n requires an argument&quot;
)paren
suffix:semicolon
id|max_count
op_assign
id|atoi
c_func
(paren
id|argv
(braket
id|i
)braket
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|arg
comma
l_string|&quot;-n&quot;
comma
l_int|2
)paren
)paren
(brace
id|max_count
op_assign
id|atoi
c_func
(paren
id|arg
op_plus
l_int|2
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|arg
comma
l_string|&quot;--max-count=&quot;
comma
l_int|12
)paren
)paren
(brace
id|max_count
op_assign
id|atoi
c_func
(paren
id|arg
op_plus
l_int|12
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|arg
comma
l_string|&quot;--max-age=&quot;
comma
l_int|10
)paren
)paren
(brace
id|max_age
op_assign
id|atoi
c_func
(paren
id|arg
op_plus
l_int|10
)paren
suffix:semicolon
id|limited
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|arg
comma
l_string|&quot;--min-age=&quot;
comma
l_int|10
)paren
)paren
(brace
id|min_age
op_assign
id|atoi
c_func
(paren
id|arg
op_plus
l_int|10
)paren
suffix:semicolon
id|limited
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--header&quot;
)paren
)paren
(brace
id|verbose_header
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|arg
comma
l_string|&quot;--pretty&quot;
comma
l_int|8
)paren
)paren
(brace
id|commit_format
op_assign
id|get_commit_format
c_func
(paren
id|arg
op_plus
l_int|8
)paren
suffix:semicolon
id|verbose_header
op_assign
l_int|1
suffix:semicolon
id|hdr_termination
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
r_if
c_cond
(paren
id|commit_format
op_eq
id|CMIT_FMT_ONELINE
)paren
id|commit_prefix
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_else
id|commit_prefix
op_assign
l_string|&quot;commit &quot;
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|arg
comma
l_string|&quot;--no-merges&quot;
comma
l_int|11
)paren
)paren
(brace
id|no_merges
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--parents&quot;
)paren
)paren
(brace
id|show_parents
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--bisect&quot;
)paren
)paren
(brace
id|bisect_list
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--all&quot;
)paren
)paren
(brace
id|handle_all
c_func
(paren
op_amp
id|list
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--objects&quot;
)paren
)paren
(brace
id|tag_objects
op_assign
l_int|1
suffix:semicolon
id|tree_objects
op_assign
l_int|1
suffix:semicolon
id|blob_objects
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--unpacked&quot;
)paren
)paren
(brace
id|unpacked
op_assign
l_int|1
suffix:semicolon
id|limited
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--merge-order&quot;
)paren
)paren
(brace
id|merge_order
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--show-breaks&quot;
)paren
)paren
(brace
id|show_breaks
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--topo-order&quot;
)paren
)paren
(brace
id|topo_order
op_assign
l_int|1
suffix:semicolon
id|limited
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--dense&quot;
)paren
)paren
(brace
id|dense
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--sparse&quot;
)paren
)paren
(brace
id|dense
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--remove-empty&quot;
)paren
)paren
(brace
id|remove_empty_trees
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--&quot;
)paren
)paren
(brace
id|i
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|show_breaks
op_logical_and
op_logical_neg
id|merge_order
)paren
id|usage
c_func
(paren
id|rev_list_usage
)paren
suffix:semicolon
id|flags
op_assign
l_int|0
suffix:semicolon
id|dotdot
op_assign
id|strstr
c_func
(paren
id|arg
comma
l_string|&quot;..&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dotdot
)paren
(brace
r_int
r_char
id|from_sha1
(braket
l_int|20
)braket
suffix:semicolon
r_char
op_star
id|next
op_assign
id|dotdot
op_plus
l_int|2
suffix:semicolon
op_star
id|dotdot
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|next
)paren
id|next
op_assign
l_string|&quot;HEAD&quot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|get_sha1
c_func
(paren
id|arg
comma
id|from_sha1
)paren
op_logical_and
op_logical_neg
id|get_sha1
c_func
(paren
id|next
comma
id|sha1
)paren
)paren
(brace
r_struct
id|commit
op_star
id|exclude
suffix:semicolon
r_struct
id|commit
op_star
id|include
suffix:semicolon
id|exclude
op_assign
id|get_commit_reference
c_func
(paren
id|arg
comma
id|from_sha1
comma
id|UNINTERESTING
)paren
suffix:semicolon
id|include
op_assign
id|get_commit_reference
c_func
(paren
id|next
comma
id|sha1
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|exclude
op_logical_or
op_logical_neg
id|include
)paren
id|die
c_func
(paren
l_string|&quot;Invalid revision range %s..%s&quot;
comma
id|arg
comma
id|next
)paren
suffix:semicolon
id|limited
op_assign
l_int|1
suffix:semicolon
id|handle_one_commit
c_func
(paren
id|exclude
comma
op_amp
id|list
)paren
suffix:semicolon
id|handle_one_commit
c_func
(paren
id|include
comma
op_amp
id|list
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
op_star
id|dotdot
op_assign
l_char|&squot;.&squot;
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|arg
op_eq
l_char|&squot;^&squot;
)paren
(brace
id|flags
op_assign
id|UNINTERESTING
suffix:semicolon
id|arg
op_increment
suffix:semicolon
id|limited
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|get_sha1
c_func
(paren
id|arg
comma
id|sha1
)paren
OL
l_int|0
)paren
(brace
r_struct
id|stat
id|st
suffix:semicolon
r_if
c_cond
(paren
id|lstat
c_func
(paren
id|arg
comma
op_amp
id|st
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;&squot;%s&squot;: %s&quot;
comma
id|arg
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|commit
op_assign
id|get_commit_reference
c_func
(paren
id|arg
comma
id|sha1
comma
id|flags
)paren
suffix:semicolon
id|handle_one_commit
c_func
(paren
id|commit
comma
op_amp
id|list
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|list
op_logical_and
(paren
op_logical_neg
(paren
id|tag_objects
op_logical_or
id|tree_objects
op_logical_or
id|blob_objects
)paren
op_logical_and
op_logical_neg
id|pending_objects
)paren
)paren
id|usage
c_func
(paren
id|rev_list_usage
)paren
suffix:semicolon
id|paths
op_assign
id|get_pathspec
c_func
(paren
id|prefix
comma
id|argv
op_plus
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|paths
)paren
(brace
id|limited
op_assign
l_int|1
suffix:semicolon
id|diff_tree_setup_paths
c_func
(paren
id|paths
)paren
suffix:semicolon
)brace
id|save_commit_buffer
op_assign
id|verbose_header
suffix:semicolon
id|track_object_refs
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|merge_order
)paren
(brace
id|sort_by_date
c_func
(paren
op_amp
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list
op_logical_and
op_logical_neg
id|limited
op_logical_and
id|max_count
op_eq
l_int|1
op_logical_and
op_logical_neg
id|tag_objects
op_logical_and
op_logical_neg
id|tree_objects
op_logical_and
op_logical_neg
id|blob_objects
)paren
(brace
id|show_commit
c_func
(paren
id|list-&gt;item
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|limited
)paren
id|list
op_assign
id|limit_list
c_func
(paren
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|topo_order
)paren
id|sort_in_topological_order
c_func
(paren
op_amp
id|list
)paren
suffix:semicolon
id|show_commit_list
c_func
(paren
id|list
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifndef NO_OPENSSL
r_if
c_cond
(paren
id|sort_list_in_merge_order
c_func
(paren
id|list
comma
op_amp
id|process_commit
)paren
)paren
(brace
id|die
c_func
(paren
l_string|&quot;merge order sort failed&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#else
id|die
c_func
(paren
l_string|&quot;merge order sort unsupported, OpenSSL not linked&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
