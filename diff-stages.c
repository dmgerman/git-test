multiline_comment|/*&n; * Copyright (c) 2005 Junio C Hamano&n; */
macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;diff.h&quot;
DECL|variable|diff_options
r_static
r_struct
id|diff_options
id|diff_options
suffix:semicolon
DECL|variable|diff_stages_usage
r_static
r_const
r_char
id|diff_stages_usage
(braket
)braket
op_assign
l_string|&quot;git-diff-stages [&lt;common diff options&gt;] &lt;stage1&gt; &lt;stage2&gt; [&lt;path&gt;...]&quot;
id|COMMON_DIFF_OPTIONS_HELP
suffix:semicolon
DECL|function|diff_stages
r_static
r_void
id|diff_stages
c_func
(paren
r_int
id|stage1
comma
r_int
id|stage2
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|i
OL
id|active_nr
)paren
(brace
r_struct
id|cache_entry
op_star
id|ce
comma
op_star
id|stages
(braket
l_int|4
)braket
op_assign
(brace
l_int|NULL
comma
)brace
suffix:semicolon
r_struct
id|cache_entry
op_star
id|one
comma
op_star
id|two
suffix:semicolon
r_const
r_char
op_star
id|name
suffix:semicolon
r_int
id|len
suffix:semicolon
id|ce
op_assign
id|active_cache
(braket
id|i
)braket
suffix:semicolon
id|len
op_assign
id|ce_namelen
c_func
(paren
id|ce
)paren
suffix:semicolon
id|name
op_assign
id|ce-&gt;name
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|stage
op_assign
id|ce_stage
c_func
(paren
id|ce
)paren
suffix:semicolon
id|stages
(braket
id|stage
)braket
op_assign
id|ce
suffix:semicolon
r_if
c_cond
(paren
id|active_nr
op_le
op_increment
id|i
)paren
r_break
suffix:semicolon
id|ce
op_assign
id|active_cache
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ce_namelen
c_func
(paren
id|ce
)paren
op_ne
id|len
op_logical_or
id|memcmp
c_func
(paren
id|name
comma
id|ce-&gt;name
comma
id|len
)paren
)paren
r_break
suffix:semicolon
)brace
id|one
op_assign
id|stages
(braket
id|stage1
)braket
suffix:semicolon
id|two
op_assign
id|stages
(braket
id|stage2
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|one
op_logical_and
op_logical_neg
id|two
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|one
)paren
id|diff_addremove
c_func
(paren
op_amp
id|diff_options
comma
l_char|&squot;+&squot;
comma
id|ntohl
c_func
(paren
id|two-&gt;ce_mode
)paren
comma
id|two-&gt;sha1
comma
id|name
comma
l_int|NULL
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|two
)paren
id|diff_addremove
c_func
(paren
op_amp
id|diff_options
comma
l_char|&squot;-&squot;
comma
id|ntohl
c_func
(paren
id|one-&gt;ce_mode
)paren
comma
id|one-&gt;sha1
comma
id|name
comma
l_int|NULL
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|one-&gt;sha1
comma
id|two-&gt;sha1
comma
l_int|20
)paren
op_logical_or
(paren
id|one-&gt;ce_mode
op_ne
id|two-&gt;ce_mode
)paren
op_logical_or
id|diff_options.find_copies_harder
)paren
id|diff_change
c_func
(paren
op_amp
id|diff_options
comma
id|ntohl
c_func
(paren
id|one-&gt;ce_mode
)paren
comma
id|ntohl
c_func
(paren
id|two-&gt;ce_mode
)paren
comma
id|one-&gt;sha1
comma
id|two-&gt;sha1
comma
id|name
comma
l_int|NULL
)paren
suffix:semicolon
)brace
)brace
DECL|function|main
r_int
id|main
c_func
(paren
r_int
id|ac
comma
r_const
r_char
op_star
op_star
id|av
)paren
(brace
r_int
id|stage1
comma
id|stage2
suffix:semicolon
id|read_cache
c_func
(paren
)paren
suffix:semicolon
id|diff_setup
c_func
(paren
op_amp
id|diff_options
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
OL
id|ac
op_logical_and
id|av
(braket
l_int|1
)braket
(braket
l_int|0
)braket
op_eq
l_char|&squot;-&squot;
)paren
(brace
r_const
r_char
op_star
id|arg
op_assign
id|av
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;-r&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* as usual */
r_else
(brace
r_int
id|diff_opt_cnt
suffix:semicolon
id|diff_opt_cnt
op_assign
id|diff_opt_parse
c_func
(paren
op_amp
id|diff_options
comma
id|av
op_plus
l_int|1
comma
id|ac
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|diff_opt_cnt
OL
l_int|0
)paren
id|usage
c_func
(paren
id|diff_stages_usage
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|diff_opt_cnt
)paren
(brace
id|av
op_add_assign
id|diff_opt_cnt
suffix:semicolon
id|ac
op_sub_assign
id|diff_opt_cnt
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
id|usage
c_func
(paren
id|diff_stages_usage
)paren
suffix:semicolon
)brace
id|ac
op_decrement
suffix:semicolon
id|av
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ac
OL
l_int|3
op_logical_or
id|sscanf
c_func
(paren
id|av
(braket
l_int|1
)braket
comma
l_string|&quot;%d&quot;
comma
op_amp
id|stage1
)paren
op_ne
l_int|1
op_logical_or
op_logical_neg
(paren
l_int|0
op_le
id|stage1
op_logical_and
id|stage1
op_le
l_int|3
)paren
op_logical_or
id|sscanf
c_func
(paren
id|av
(braket
l_int|2
)braket
comma
l_string|&quot;%d&quot;
comma
op_amp
id|stage2
)paren
op_ne
l_int|1
op_logical_or
op_logical_neg
(paren
l_int|0
op_le
id|stage2
op_logical_and
id|stage2
op_le
l_int|3
)paren
)paren
id|usage
c_func
(paren
id|diff_stages_usage
)paren
suffix:semicolon
id|av
op_add_assign
l_int|3
suffix:semicolon
multiline_comment|/* The rest from av[0] are for paths restriction. */
id|diff_options.paths
op_assign
id|av
suffix:semicolon
r_if
c_cond
(paren
id|diff_setup_done
c_func
(paren
op_amp
id|diff_options
)paren
OL
l_int|0
)paren
id|usage
c_func
(paren
id|diff_stages_usage
)paren
suffix:semicolon
id|diff_stages
c_func
(paren
id|stage1
comma
id|stage2
)paren
suffix:semicolon
id|diffcore_std
c_func
(paren
op_amp
id|diff_options
)paren
suffix:semicolon
id|diff_flush
c_func
(paren
op_amp
id|diff_options
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
