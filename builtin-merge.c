multiline_comment|/*&n; * Builtin &quot;git merge&quot;&n; *&n; * Copyright (c) 2008 Miklos Vajna &lt;vmiklos@frugalware.org&gt;&n; *&n; * Based on git-merge.sh by Junio C Hamano.&n; */
macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;parse-options.h&quot;
macro_line|#include &quot;builtin.h&quot;
macro_line|#include &quot;run-command.h&quot;
macro_line|#include &quot;diff.h&quot;
macro_line|#include &quot;refs.h&quot;
macro_line|#include &quot;commit.h&quot;
macro_line|#include &quot;diffcore.h&quot;
macro_line|#include &quot;revision.h&quot;
macro_line|#include &quot;unpack-trees.h&quot;
macro_line|#include &quot;cache-tree.h&quot;
macro_line|#include &quot;dir.h&quot;
macro_line|#include &quot;utf8.h&quot;
macro_line|#include &quot;log-tree.h&quot;
macro_line|#include &quot;color.h&quot;
macro_line|#include &quot;rerere.h&quot;
DECL|macro|DEFAULT_TWOHEAD
mdefine_line|#define DEFAULT_TWOHEAD (1&lt;&lt;0)
DECL|macro|DEFAULT_OCTOPUS
mdefine_line|#define DEFAULT_OCTOPUS (1&lt;&lt;1)
DECL|macro|NO_FAST_FORWARD
mdefine_line|#define NO_FAST_FORWARD (1&lt;&lt;2)
DECL|macro|NO_TRIVIAL
mdefine_line|#define NO_TRIVIAL      (1&lt;&lt;3)
DECL|struct|strategy
r_struct
id|strategy
(brace
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
DECL|member|attr
r_int
id|attr
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|builtin_merge_usage
r_static
r_const
r_char
op_star
r_const
id|builtin_merge_usage
(braket
)braket
op_assign
(brace
l_string|&quot;git-merge [options] &lt;remote&gt;...&quot;
comma
l_string|&quot;git-merge [options] &lt;msg&gt; HEAD &lt;remote&gt;&quot;
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|show_diffstat
DECL|variable|option_log
DECL|variable|squash
r_static
r_int
id|show_diffstat
op_assign
l_int|1
comma
id|option_log
comma
id|squash
suffix:semicolon
DECL|variable|option_commit
DECL|variable|allow_fast_forward
r_static
r_int
id|option_commit
op_assign
l_int|1
comma
id|allow_fast_forward
op_assign
l_int|1
suffix:semicolon
DECL|variable|allow_trivial
DECL|variable|have_message
r_static
r_int
id|allow_trivial
op_assign
l_int|1
comma
id|have_message
suffix:semicolon
DECL|variable|merge_msg
r_static
r_struct
id|strbuf
id|merge_msg
op_assign
id|STRBUF_INIT
suffix:semicolon
DECL|variable|remoteheads
r_static
r_struct
id|commit_list
op_star
id|remoteheads
suffix:semicolon
DECL|variable|head
DECL|variable|stash
r_static
r_int
r_char
id|head
(braket
l_int|20
)braket
comma
id|stash
(braket
l_int|20
)braket
suffix:semicolon
DECL|variable|use_strategies
r_static
r_struct
id|strategy
op_star
op_star
id|use_strategies
suffix:semicolon
DECL|variable|use_strategies_nr
DECL|variable|use_strategies_alloc
r_static
r_int
id|use_strategies_nr
comma
id|use_strategies_alloc
suffix:semicolon
DECL|variable|branch
r_static
r_const
r_char
op_star
id|branch
suffix:semicolon
DECL|variable|all_strategy
r_static
r_struct
id|strategy
id|all_strategy
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;recursive&quot;
comma
id|DEFAULT_TWOHEAD
op_or
id|NO_TRIVIAL
)brace
comma
(brace
l_string|&quot;octopus&quot;
comma
id|DEFAULT_OCTOPUS
)brace
comma
(brace
l_string|&quot;resolve&quot;
comma
l_int|0
)brace
comma
(brace
l_string|&quot;ours&quot;
comma
id|NO_FAST_FORWARD
op_or
id|NO_TRIVIAL
)brace
comma
(brace
l_string|&quot;subtree&quot;
comma
id|NO_FAST_FORWARD
op_or
id|NO_TRIVIAL
)brace
comma
)brace
suffix:semicolon
DECL|variable|pull_twohead
DECL|variable|pull_octopus
r_static
r_const
r_char
op_star
id|pull_twohead
comma
op_star
id|pull_octopus
suffix:semicolon
DECL|function|option_parse_message
r_static
r_int
id|option_parse_message
c_func
(paren
r_const
r_struct
id|option
op_star
id|opt
comma
r_const
r_char
op_star
id|arg
comma
r_int
id|unset
)paren
(brace
r_struct
id|strbuf
op_star
id|buf
op_assign
id|opt-&gt;value
suffix:semicolon
r_if
c_cond
(paren
id|unset
)paren
id|strbuf_setlen
c_func
(paren
id|buf
comma
l_int|0
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|arg
)paren
(brace
id|strbuf_addf
c_func
(paren
id|buf
comma
l_string|&quot;%s&bslash;n&bslash;n&quot;
comma
id|arg
)paren
suffix:semicolon
id|have_message
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_return
id|error
c_func
(paren
l_string|&quot;switch `m&squot; requires a value&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|get_strategy
r_static
r_struct
id|strategy
op_star
id|get_strategy
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|strbuf
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
r_return
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|all_strategy
)paren
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
id|all_strategy
(braket
id|i
)braket
dot
id|name
)paren
)paren
r_return
op_amp
id|all_strategy
(braket
id|i
)braket
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|err
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|all_strategy
)paren
suffix:semicolon
id|i
op_increment
)paren
id|strbuf_addf
c_func
(paren
op_amp
id|err
comma
l_string|&quot; %s&quot;
comma
id|all_strategy
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Could not find merge strategy &squot;%s&squot;.&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Available strategies are:%s.&bslash;n&quot;
comma
id|err.buf
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|append_strategy
r_static
r_void
id|append_strategy
c_func
(paren
r_struct
id|strategy
op_star
id|s
)paren
(brace
id|ALLOC_GROW
c_func
(paren
id|use_strategies
comma
id|use_strategies_nr
op_plus
l_int|1
comma
id|use_strategies_alloc
)paren
suffix:semicolon
id|use_strategies
(braket
id|use_strategies_nr
op_increment
)braket
op_assign
id|s
suffix:semicolon
)brace
DECL|function|option_parse_strategy
r_static
r_int
id|option_parse_strategy
c_func
(paren
r_const
r_struct
id|option
op_star
id|opt
comma
r_const
r_char
op_star
id|name
comma
r_int
id|unset
)paren
(brace
r_if
c_cond
(paren
id|unset
)paren
r_return
l_int|0
suffix:semicolon
id|append_strategy
c_func
(paren
id|get_strategy
c_func
(paren
id|name
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|option_parse_n
r_static
r_int
id|option_parse_n
c_func
(paren
r_const
r_struct
id|option
op_star
id|opt
comma
r_const
r_char
op_star
id|arg
comma
r_int
id|unset
)paren
(brace
id|show_diffstat
op_assign
id|unset
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|builtin_merge_options
r_static
r_struct
id|option
id|builtin_merge_options
(braket
)braket
op_assign
(brace
(brace
id|OPTION_CALLBACK
comma
l_char|&squot;n&squot;
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_string|&quot;do not show a diffstat at the end of the merge&quot;
comma
id|PARSE_OPT_NOARG
comma
id|option_parse_n
)brace
comma
id|OPT_BOOLEAN
c_func
(paren
l_int|0
comma
l_string|&quot;stat&quot;
comma
op_amp
id|show_diffstat
comma
l_string|&quot;show a diffstat at the end of the merge&quot;
)paren
comma
id|OPT_BOOLEAN
c_func
(paren
l_int|0
comma
l_string|&quot;summary&quot;
comma
op_amp
id|show_diffstat
comma
l_string|&quot;(synonym to --stat)&quot;
)paren
comma
id|OPT_BOOLEAN
c_func
(paren
l_int|0
comma
l_string|&quot;log&quot;
comma
op_amp
id|option_log
comma
l_string|&quot;add list of one-line log to merge commit message&quot;
)paren
comma
id|OPT_BOOLEAN
c_func
(paren
l_int|0
comma
l_string|&quot;squash&quot;
comma
op_amp
id|squash
comma
l_string|&quot;create a single commit instead of doing a merge&quot;
)paren
comma
id|OPT_BOOLEAN
c_func
(paren
l_int|0
comma
l_string|&quot;commit&quot;
comma
op_amp
id|option_commit
comma
l_string|&quot;perform a commit if the merge succeeds (default)&quot;
)paren
comma
id|OPT_BOOLEAN
c_func
(paren
l_int|0
comma
l_string|&quot;ff&quot;
comma
op_amp
id|allow_fast_forward
comma
l_string|&quot;allow fast forward (default)&quot;
)paren
comma
id|OPT_CALLBACK
c_func
(paren
l_char|&squot;s&squot;
comma
l_string|&quot;strategy&quot;
comma
op_amp
id|use_strategies
comma
l_string|&quot;strategy&quot;
comma
l_string|&quot;merge strategy to use&quot;
comma
id|option_parse_strategy
)paren
comma
id|OPT_CALLBACK
c_func
(paren
l_char|&squot;m&squot;
comma
l_string|&quot;message&quot;
comma
op_amp
id|merge_msg
comma
l_string|&quot;message&quot;
comma
l_string|&quot;message to be used for the merge commit (if any)&quot;
comma
id|option_parse_message
)paren
comma
id|OPT_END
c_func
(paren
)paren
)brace
suffix:semicolon
multiline_comment|/* Cleans up metadata that is uninteresting after a succeeded merge. */
DECL|function|drop_save
r_static
r_void
id|drop_save
c_func
(paren
r_void
)paren
(brace
id|unlink
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;MERGE_HEAD&quot;
)paren
)paren
suffix:semicolon
id|unlink
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;MERGE_MSG&quot;
)paren
)paren
suffix:semicolon
)brace
DECL|function|save_state
r_static
r_void
id|save_state
c_func
(paren
r_void
)paren
(brace
r_int
id|len
suffix:semicolon
r_struct
id|child_process
id|cp
suffix:semicolon
r_struct
id|strbuf
id|buffer
op_assign
id|STRBUF_INIT
suffix:semicolon
r_const
r_char
op_star
id|argv
(braket
)braket
op_assign
(brace
l_string|&quot;stash&quot;
comma
l_string|&quot;create&quot;
comma
l_int|NULL
)brace
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|cp
comma
l_int|0
comma
r_sizeof
(paren
id|cp
)paren
)paren
suffix:semicolon
id|cp.argv
op_assign
id|argv
suffix:semicolon
id|cp.out
op_assign
l_int|1
suffix:semicolon
id|cp.git_cmd
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|start_command
c_func
(paren
op_amp
id|cp
)paren
)paren
id|die
c_func
(paren
l_string|&quot;could not run stash.&quot;
)paren
suffix:semicolon
id|len
op_assign
id|strbuf_read
c_func
(paren
op_amp
id|buffer
comma
id|cp.out
comma
l_int|1024
)paren
suffix:semicolon
id|close
c_func
(paren
id|cp.out
)paren
suffix:semicolon
r_if
c_cond
(paren
id|finish_command
c_func
(paren
op_amp
id|cp
)paren
op_logical_or
id|len
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;stash failed&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
r_return
suffix:semicolon
id|strbuf_setlen
c_func
(paren
op_amp
id|buffer
comma
id|buffer.len
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1
c_func
(paren
id|buffer.buf
comma
id|stash
)paren
)paren
id|die
c_func
(paren
l_string|&quot;not a valid object: %s&quot;
comma
id|buffer.buf
)paren
suffix:semicolon
)brace
DECL|function|reset_hard
r_static
r_void
id|reset_hard
c_func
(paren
r_int
r_const
r_char
op_star
id|sha1
comma
r_int
id|verbose
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_const
r_char
op_star
id|args
(braket
l_int|6
)braket
suffix:semicolon
id|args
(braket
id|i
op_increment
)braket
op_assign
l_string|&quot;read-tree&quot;
suffix:semicolon
r_if
c_cond
(paren
id|verbose
)paren
id|args
(braket
id|i
op_increment
)braket
op_assign
l_string|&quot;-v&quot;
suffix:semicolon
id|args
(braket
id|i
op_increment
)braket
op_assign
l_string|&quot;--reset&quot;
suffix:semicolon
id|args
(braket
id|i
op_increment
)braket
op_assign
l_string|&quot;-u&quot;
suffix:semicolon
id|args
(braket
id|i
op_increment
)braket
op_assign
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
suffix:semicolon
id|args
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|run_command_v_opt
c_func
(paren
id|args
comma
id|RUN_GIT_CMD
)paren
)paren
id|die
c_func
(paren
l_string|&quot;read-tree failed&quot;
)paren
suffix:semicolon
)brace
DECL|function|restore_state
r_static
r_void
id|restore_state
c_func
(paren
r_void
)paren
(brace
r_struct
id|strbuf
id|sb
suffix:semicolon
r_const
r_char
op_star
id|args
(braket
)braket
op_assign
(brace
l_string|&quot;stash&quot;
comma
l_string|&quot;apply&quot;
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
r_if
c_cond
(paren
id|is_null_sha1
c_func
(paren
id|stash
)paren
)paren
r_return
suffix:semicolon
id|reset_hard
c_func
(paren
id|head
comma
l_int|1
)paren
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|sb
comma
l_int|0
)paren
suffix:semicolon
id|args
(braket
l_int|2
)braket
op_assign
id|sha1_to_hex
c_func
(paren
id|stash
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * It is OK to ignore error here, for example when there was&n;&t; * nothing to restore.&n;&t; */
id|run_command_v_opt
c_func
(paren
id|args
comma
id|RUN_GIT_CMD
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
id|refresh_cache
c_func
(paren
id|REFRESH_QUIET
)paren
suffix:semicolon
)brace
multiline_comment|/* This is called when no merge was necessary. */
DECL|function|finish_up_to_date
r_static
r_void
id|finish_up_to_date
c_func
(paren
r_const
r_char
op_star
id|msg
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s%s&bslash;n&quot;
comma
id|squash
ques
c_cond
l_string|&quot; (nothing to squash)&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|msg
)paren
suffix:semicolon
id|drop_save
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|squash_message
r_static
r_void
id|squash_message
c_func
(paren
r_void
)paren
(brace
r_struct
id|rev_info
id|rev
suffix:semicolon
r_struct
id|commit
op_star
id|commit
suffix:semicolon
r_struct
id|strbuf
id|out
suffix:semicolon
r_struct
id|commit_list
op_star
id|j
suffix:semicolon
r_int
id|fd
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Squash commit -- not updating HEAD&bslash;n&quot;
)paren
suffix:semicolon
id|fd
op_assign
id|open
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;SQUASH_MSG&quot;
)paren
comma
id|O_WRONLY
op_or
id|O_CREAT
comma
l_int|0666
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;Could not write to %s&quot;
comma
id|git_path
c_func
(paren
l_string|&quot;SQUASH_MSG&quot;
)paren
)paren
suffix:semicolon
id|init_revisions
c_func
(paren
op_amp
id|rev
comma
l_int|NULL
)paren
suffix:semicolon
id|rev.ignore_merges
op_assign
l_int|1
suffix:semicolon
id|rev.commit_format
op_assign
id|CMIT_FMT_MEDIUM
suffix:semicolon
id|commit
op_assign
id|lookup_commit
c_func
(paren
id|head
)paren
suffix:semicolon
id|commit-&gt;object.flags
op_or_assign
id|UNINTERESTING
suffix:semicolon
id|add_pending_object
c_func
(paren
op_amp
id|rev
comma
op_amp
id|commit-&gt;object
comma
l_int|NULL
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|remoteheads
suffix:semicolon
id|j
suffix:semicolon
id|j
op_assign
id|j-&gt;next
)paren
id|add_pending_object
c_func
(paren
op_amp
id|rev
comma
op_amp
id|j-&gt;item-&gt;object
comma
l_int|NULL
)paren
suffix:semicolon
id|setup_revisions
c_func
(paren
l_int|0
comma
l_int|NULL
comma
op_amp
id|rev
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prepare_revision_walk
c_func
(paren
op_amp
id|rev
)paren
)paren
id|die
c_func
(paren
l_string|&quot;revision walk setup failed&quot;
)paren
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|out
comma
l_int|0
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|out
comma
l_string|&quot;Squashed commit of the following:&bslash;n&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|commit
op_assign
id|get_revision
c_func
(paren
op_amp
id|rev
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|strbuf_addch
c_func
(paren
op_amp
id|out
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
id|out
comma
l_string|&quot;commit %s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|commit-&gt;object.sha1
)paren
)paren
suffix:semicolon
id|pretty_print_commit
c_func
(paren
id|rev.commit_format
comma
id|commit
comma
op_amp
id|out
comma
id|rev.abbrev
comma
l_int|NULL
comma
l_int|NULL
comma
id|rev.date_mode
comma
l_int|0
)paren
suffix:semicolon
)brace
id|write
c_func
(paren
id|fd
comma
id|out.buf
comma
id|out.len
)paren
suffix:semicolon
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|out
)paren
suffix:semicolon
)brace
DECL|function|run_hook
r_static
r_int
id|run_hook
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|child_process
id|hook
suffix:semicolon
r_const
r_char
op_star
id|argv
(braket
l_int|3
)braket
comma
op_star
id|env
(braket
l_int|2
)braket
suffix:semicolon
r_char
id|index
(braket
id|PATH_MAX
)braket
suffix:semicolon
id|argv
(braket
l_int|0
)braket
op_assign
id|git_path
c_func
(paren
l_string|&quot;hooks/%s&quot;
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|access
c_func
(paren
id|argv
(braket
l_int|0
)braket
comma
id|X_OK
)paren
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|snprintf
c_func
(paren
id|index
comma
r_sizeof
(paren
id|index
)paren
comma
l_string|&quot;GIT_INDEX_FILE=%s&quot;
comma
id|get_index_file
c_func
(paren
)paren
)paren
suffix:semicolon
id|env
(braket
l_int|0
)braket
op_assign
id|index
suffix:semicolon
id|env
(braket
l_int|1
)braket
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|squash
)paren
id|argv
(braket
l_int|1
)braket
op_assign
l_string|&quot;1&quot;
suffix:semicolon
r_else
id|argv
(braket
l_int|1
)braket
op_assign
l_string|&quot;0&quot;
suffix:semicolon
id|argv
(braket
l_int|2
)braket
op_assign
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|hook
comma
l_int|0
comma
r_sizeof
(paren
id|hook
)paren
)paren
suffix:semicolon
id|hook.argv
op_assign
id|argv
suffix:semicolon
id|hook.no_stdin
op_assign
l_int|1
suffix:semicolon
id|hook.stdout_to_stderr
op_assign
l_int|1
suffix:semicolon
id|hook.env
op_assign
id|env
suffix:semicolon
r_return
id|run_command
c_func
(paren
op_amp
id|hook
)paren
suffix:semicolon
)brace
DECL|function|finish
r_static
r_void
id|finish
c_func
(paren
r_const
r_int
r_char
op_star
id|new_head
comma
r_const
r_char
op_star
id|msg
)paren
(brace
r_struct
id|strbuf
id|reflog_message
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|reflog_message
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|msg
)paren
id|strbuf_addstr
c_func
(paren
op_amp
id|reflog_message
comma
id|getenv
c_func
(paren
l_string|&quot;GIT_REFLOG_ACTION&quot;
)paren
)paren
suffix:semicolon
r_else
(brace
id|printf
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|msg
)paren
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
id|reflog_message
comma
l_string|&quot;%s: %s&quot;
comma
id|getenv
c_func
(paren
l_string|&quot;GIT_REFLOG_ACTION&quot;
)paren
comma
id|msg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|squash
)paren
(brace
id|squash_message
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|merge_msg.len
)paren
id|printf
c_func
(paren
l_string|&quot;No merge message -- not updating HEAD&bslash;n&quot;
)paren
suffix:semicolon
r_else
(brace
r_const
r_char
op_star
id|argv_gc_auto
(braket
)braket
op_assign
(brace
l_string|&quot;gc&quot;
comma
l_string|&quot;--auto&quot;
comma
l_int|NULL
)brace
suffix:semicolon
id|update_ref
c_func
(paren
id|reflog_message.buf
comma
l_string|&quot;HEAD&quot;
comma
id|new_head
comma
id|head
comma
l_int|0
comma
id|DIE_ON_ERR
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * We ignore errors in &squot;gc --auto&squot;, since the&n;&t;&t;&t; * user should see them.&n;&t;&t;&t; */
id|run_command_v_opt
c_func
(paren
id|argv_gc_auto
comma
id|RUN_GIT_CMD
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|new_head
op_logical_and
id|show_diffstat
)paren
(brace
r_struct
id|diff_options
id|opts
suffix:semicolon
id|diff_setup
c_func
(paren
op_amp
id|opts
)paren
suffix:semicolon
id|opts.output_format
op_or_assign
id|DIFF_FORMAT_SUMMARY
op_or
id|DIFF_FORMAT_DIFFSTAT
suffix:semicolon
id|opts.detect_rename
op_assign
id|DIFF_DETECT_RENAME
suffix:semicolon
r_if
c_cond
(paren
id|diff_use_color_default
OG
l_int|0
)paren
id|DIFF_OPT_SET
c_func
(paren
op_amp
id|opts
comma
id|COLOR_DIFF
)paren
suffix:semicolon
r_if
c_cond
(paren
id|diff_setup_done
c_func
(paren
op_amp
id|opts
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;diff_setup_done failed&quot;
)paren
suffix:semicolon
id|diff_tree_sha1
c_func
(paren
id|head
comma
id|new_head
comma
l_string|&quot;&quot;
comma
op_amp
id|opts
)paren
suffix:semicolon
id|diffcore_std
c_func
(paren
op_amp
id|opts
)paren
suffix:semicolon
id|diff_flush
c_func
(paren
op_amp
id|opts
)paren
suffix:semicolon
)brace
multiline_comment|/* Run a post-merge hook */
id|run_hook
c_func
(paren
l_string|&quot;post-merge&quot;
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|reflog_message
)paren
suffix:semicolon
)brace
multiline_comment|/* Get the name for the merge commit&squot;s message. */
DECL|function|merge_name
r_static
r_void
id|merge_name
c_func
(paren
r_const
r_char
op_star
id|remote
comma
r_struct
id|strbuf
op_star
id|msg
)paren
(brace
r_struct
id|object
op_star
id|remote_head
suffix:semicolon
r_int
r_char
id|branch_head
(braket
l_int|20
)braket
comma
id|buf_sha
(braket
l_int|20
)braket
suffix:semicolon
r_struct
id|strbuf
id|buf
suffix:semicolon
r_const
r_char
op_star
id|ptr
suffix:semicolon
r_int
id|len
comma
id|early
suffix:semicolon
id|memset
c_func
(paren
id|branch_head
comma
l_int|0
comma
r_sizeof
(paren
id|branch_head
)paren
)paren
suffix:semicolon
id|remote_head
op_assign
id|peel_to_type
c_func
(paren
id|remote
comma
l_int|0
comma
l_int|NULL
comma
id|OBJ_COMMIT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|remote_head
)paren
id|die
c_func
(paren
l_string|&quot;&squot;%s&squot; does not point to a commit&quot;
comma
id|remote
)paren
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|buf
comma
l_int|0
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|buf
comma
l_string|&quot;refs/heads/&quot;
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|buf
comma
id|remote
)paren
suffix:semicolon
id|resolve_ref
c_func
(paren
id|buf.buf
comma
id|branch_head
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hashcmp
c_func
(paren
id|remote_head-&gt;sha1
comma
id|branch_head
)paren
)paren
(brace
id|strbuf_addf
c_func
(paren
id|msg
comma
l_string|&quot;%s&bslash;t&bslash;tbranch &squot;%s&squot; of .&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|branch_head
)paren
comma
id|remote
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* See if remote matches &lt;name&gt;^^^.. or &lt;name&gt;~&lt;number&gt; */
r_for
c_loop
(paren
id|len
op_assign
l_int|0
comma
id|ptr
op_assign
id|remote
op_plus
id|strlen
c_func
(paren
id|remote
)paren
suffix:semicolon
id|remote
OL
id|ptr
op_logical_and
id|ptr
(braket
l_int|1
)braket
op_eq
l_char|&squot;^&squot;
suffix:semicolon
id|ptr
op_decrement
)paren
id|len
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|len
)paren
id|early
op_assign
l_int|1
suffix:semicolon
r_else
(brace
id|early
op_assign
l_int|0
suffix:semicolon
id|ptr
op_assign
id|strrchr
c_func
(paren
id|remote
comma
l_char|&squot;~&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ptr
)paren
(brace
r_int
id|seen_nonzero
op_assign
l_int|0
suffix:semicolon
id|len
op_increment
suffix:semicolon
multiline_comment|/* count ~ */
r_while
c_loop
(paren
op_star
op_increment
id|ptr
op_logical_and
id|isdigit
c_func
(paren
op_star
id|ptr
)paren
)paren
(brace
id|seen_nonzero
op_or_assign
(paren
op_star
id|ptr
op_ne
l_char|&squot;0&squot;
)paren
suffix:semicolon
id|len
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|ptr
)paren
id|len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* not ...~&lt;number&gt; */
r_else
r_if
c_cond
(paren
id|seen_nonzero
)paren
id|early
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|len
op_eq
l_int|1
)paren
id|early
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* &quot;name~&quot; is &quot;name~1&quot;! */
)brace
)brace
r_if
c_cond
(paren
id|len
)paren
(brace
r_struct
id|strbuf
id|truname
op_assign
id|STRBUF_INIT
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|truname
comma
l_string|&quot;refs/heads/&quot;
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|truname
comma
id|remote
)paren
suffix:semicolon
id|strbuf_setlen
c_func
(paren
op_amp
id|truname
comma
id|len
op_plus
l_int|11
)paren
suffix:semicolon
r_if
c_cond
(paren
id|resolve_ref
c_func
(paren
id|truname.buf
comma
id|buf_sha
comma
l_int|0
comma
l_int|0
)paren
)paren
(brace
id|strbuf_addf
c_func
(paren
id|msg
comma
l_string|&quot;%s&bslash;t&bslash;tbranch &squot;%s&squot;%s of .&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|remote_head-&gt;sha1
)paren
comma
id|truname.buf
comma
(paren
id|early
ques
c_cond
l_string|&quot; (early part)&quot;
suffix:colon
l_string|&quot;&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|remote
comma
l_string|&quot;FETCH_HEAD&quot;
)paren
op_logical_and
op_logical_neg
id|access
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;FETCH_HEAD&quot;
)paren
comma
id|R_OK
)paren
)paren
(brace
id|FILE
op_star
id|fp
suffix:semicolon
r_struct
id|strbuf
id|line
suffix:semicolon
r_char
op_star
id|ptr
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|line
comma
l_int|0
)paren
suffix:semicolon
id|fp
op_assign
id|fopen
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;FETCH_HEAD&quot;
)paren
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fp
)paren
id|die
c_func
(paren
l_string|&quot;could not open %s for reading: %s&quot;
comma
id|git_path
c_func
(paren
l_string|&quot;FETCH_HEAD&quot;
)paren
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
id|strbuf_getline
c_func
(paren
op_amp
id|line
comma
id|fp
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|fclose
c_func
(paren
id|fp
)paren
suffix:semicolon
id|ptr
op_assign
id|strstr
c_func
(paren
id|line.buf
comma
l_string|&quot;&bslash;tnot-for-merge&bslash;t&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ptr
)paren
id|strbuf_remove
c_func
(paren
op_amp
id|line
comma
id|ptr
op_minus
id|line.buf
op_plus
l_int|1
comma
l_int|13
)paren
suffix:semicolon
id|strbuf_addbuf
c_func
(paren
id|msg
comma
op_amp
id|line
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|line
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|strbuf_addf
c_func
(paren
id|msg
comma
l_string|&quot;%s&bslash;t&bslash;tcommit &squot;%s&squot;&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|remote_head-&gt;sha1
)paren
comma
id|remote
)paren
suffix:semicolon
)brace
DECL|function|git_merge_config
r_int
id|git_merge_config
c_func
(paren
r_const
r_char
op_star
id|k
comma
r_const
r_char
op_star
id|v
comma
r_void
op_star
id|cb
)paren
(brace
r_if
c_cond
(paren
id|branch
op_logical_and
op_logical_neg
id|prefixcmp
c_func
(paren
id|k
comma
l_string|&quot;branch.&quot;
)paren
op_logical_and
op_logical_neg
id|prefixcmp
c_func
(paren
id|k
op_plus
l_int|7
comma
id|branch
)paren
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|k
op_plus
l_int|7
op_plus
id|strlen
c_func
(paren
id|branch
)paren
comma
l_string|&quot;.mergeoptions&quot;
)paren
)paren
(brace
r_const
r_char
op_star
op_star
id|argv
suffix:semicolon
r_int
id|argc
suffix:semicolon
r_char
op_star
id|buf
suffix:semicolon
id|buf
op_assign
id|xstrdup
c_func
(paren
id|v
)paren
suffix:semicolon
id|argc
op_assign
id|split_cmdline
c_func
(paren
id|buf
comma
op_amp
id|argv
)paren
suffix:semicolon
id|argv
op_assign
id|xrealloc
c_func
(paren
id|argv
comma
r_sizeof
(paren
op_star
id|argv
)paren
op_star
(paren
id|argc
op_plus
l_int|2
)paren
)paren
suffix:semicolon
id|memmove
c_func
(paren
id|argv
op_plus
l_int|1
comma
id|argv
comma
r_sizeof
(paren
op_star
id|argv
)paren
op_star
(paren
id|argc
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|argc
op_increment
suffix:semicolon
id|parse_options
c_func
(paren
id|argc
comma
id|argv
comma
id|builtin_merge_options
comma
id|builtin_merge_usage
comma
l_int|0
)paren
suffix:semicolon
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|k
comma
l_string|&quot;merge.diffstat&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|k
comma
l_string|&quot;merge.stat&quot;
)paren
)paren
id|show_diffstat
op_assign
id|git_config_bool
c_func
(paren
id|k
comma
id|v
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|k
comma
l_string|&quot;pull.twohead&quot;
)paren
)paren
r_return
id|git_config_string
c_func
(paren
op_amp
id|pull_twohead
comma
id|k
comma
id|v
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|k
comma
l_string|&quot;pull.octopus&quot;
)paren
)paren
r_return
id|git_config_string
c_func
(paren
op_amp
id|pull_octopus
comma
id|k
comma
id|v
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|k
comma
l_string|&quot;merge.log&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|k
comma
l_string|&quot;merge.summary&quot;
)paren
)paren
id|option_log
op_assign
id|git_config_bool
c_func
(paren
id|k
comma
id|v
)paren
suffix:semicolon
r_return
id|git_diff_ui_config
c_func
(paren
id|k
comma
id|v
comma
id|cb
)paren
suffix:semicolon
)brace
DECL|function|read_tree_trivial
r_static
r_int
id|read_tree_trivial
c_func
(paren
r_int
r_char
op_star
id|common
comma
r_int
r_char
op_star
id|head
comma
r_int
r_char
op_star
id|one
)paren
(brace
r_int
id|i
comma
id|nr_trees
op_assign
l_int|0
suffix:semicolon
r_struct
id|tree
op_star
id|trees
(braket
id|MAX_UNPACK_TREES
)braket
suffix:semicolon
r_struct
id|tree_desc
id|t
(braket
id|MAX_UNPACK_TREES
)braket
suffix:semicolon
r_struct
id|unpack_trees_options
id|opts
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|opts
comma
l_int|0
comma
r_sizeof
(paren
id|opts
)paren
)paren
suffix:semicolon
id|opts.head_idx
op_assign
l_int|2
suffix:semicolon
id|opts.src_index
op_assign
op_amp
id|the_index
suffix:semicolon
id|opts.dst_index
op_assign
op_amp
id|the_index
suffix:semicolon
id|opts.update
op_assign
l_int|1
suffix:semicolon
id|opts.verbose_update
op_assign
l_int|1
suffix:semicolon
id|opts.trivial_merges_only
op_assign
l_int|1
suffix:semicolon
id|opts.merge
op_assign
l_int|1
suffix:semicolon
id|trees
(braket
id|nr_trees
)braket
op_assign
id|parse_tree_indirect
c_func
(paren
id|common
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|trees
(braket
id|nr_trees
op_increment
)braket
)paren
r_return
l_int|1
suffix:semicolon
id|trees
(braket
id|nr_trees
)braket
op_assign
id|parse_tree_indirect
c_func
(paren
id|head
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|trees
(braket
id|nr_trees
op_increment
)braket
)paren
r_return
l_int|1
suffix:semicolon
id|trees
(braket
id|nr_trees
)braket
op_assign
id|parse_tree_indirect
c_func
(paren
id|one
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|trees
(braket
id|nr_trees
op_increment
)braket
)paren
r_return
l_int|1
suffix:semicolon
id|opts.fn
op_assign
id|threeway_merge
suffix:semicolon
id|cache_tree_free
c_func
(paren
op_amp
id|active_cache_tree
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_trees
suffix:semicolon
id|i
op_increment
)paren
(brace
id|parse_tree
c_func
(paren
id|trees
(braket
id|i
)braket
)paren
suffix:semicolon
id|init_tree_desc
c_func
(paren
id|t
op_plus
id|i
comma
id|trees
(braket
id|i
)braket
op_member_access_from_pointer
id|buffer
comma
id|trees
(braket
id|i
)braket
op_member_access_from_pointer
id|size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unpack_trees
c_func
(paren
id|nr_trees
comma
id|t
comma
op_amp
id|opts
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|write_tree_trivial
r_static
r_void
id|write_tree_trivial
c_func
(paren
r_int
r_char
op_star
id|sha1
)paren
(brace
r_if
c_cond
(paren
id|write_cache_as_tree
c_func
(paren
id|sha1
comma
l_int|0
comma
l_int|NULL
)paren
)paren
id|die
c_func
(paren
l_string|&quot;git write-tree failed to write a tree&quot;
)paren
suffix:semicolon
)brace
DECL|function|try_merge_strategy
r_static
r_int
id|try_merge_strategy
c_func
(paren
r_const
r_char
op_star
id|strategy
comma
r_struct
id|commit_list
op_star
id|common
comma
r_const
r_char
op_star
id|head_arg
)paren
(brace
r_const
r_char
op_star
op_star
id|args
suffix:semicolon
r_int
id|i
op_assign
l_int|0
comma
id|ret
suffix:semicolon
r_struct
id|commit_list
op_star
id|j
suffix:semicolon
r_struct
id|strbuf
id|buf
suffix:semicolon
id|args
op_assign
id|xmalloc
c_func
(paren
(paren
l_int|4
op_plus
id|commit_list_count
c_func
(paren
id|common
)paren
op_plus
id|commit_list_count
c_func
(paren
id|remoteheads
)paren
)paren
op_star
r_sizeof
(paren
r_char
op_star
)paren
)paren
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|buf
comma
l_int|0
)paren
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
id|buf
comma
l_string|&quot;merge-%s&quot;
comma
id|strategy
)paren
suffix:semicolon
id|args
(braket
id|i
op_increment
)braket
op_assign
id|buf.buf
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|common
suffix:semicolon
id|j
suffix:semicolon
id|j
op_assign
id|j-&gt;next
)paren
id|args
(braket
id|i
op_increment
)braket
op_assign
id|xstrdup
c_func
(paren
id|sha1_to_hex
c_func
(paren
id|j-&gt;item-&gt;object.sha1
)paren
)paren
suffix:semicolon
id|args
(braket
id|i
op_increment
)braket
op_assign
l_string|&quot;--&quot;
suffix:semicolon
id|args
(braket
id|i
op_increment
)braket
op_assign
id|head_arg
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|remoteheads
suffix:semicolon
id|j
suffix:semicolon
id|j
op_assign
id|j-&gt;next
)paren
id|args
(braket
id|i
op_increment
)braket
op_assign
id|xstrdup
c_func
(paren
id|sha1_to_hex
c_func
(paren
id|j-&gt;item-&gt;object.sha1
)paren
)paren
suffix:semicolon
id|args
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|ret
op_assign
id|run_command_v_opt
c_func
(paren
id|args
comma
id|RUN_GIT_CMD
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|buf
)paren
suffix:semicolon
id|i
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|common
suffix:semicolon
id|j
suffix:semicolon
id|j
op_assign
id|j-&gt;next
)paren
id|free
c_func
(paren
(paren
r_void
op_star
)paren
id|args
(braket
id|i
op_increment
)braket
)paren
suffix:semicolon
id|i
op_add_assign
l_int|2
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|remoteheads
suffix:semicolon
id|j
suffix:semicolon
id|j
op_assign
id|j-&gt;next
)paren
id|free
c_func
(paren
(paren
r_void
op_star
)paren
id|args
(braket
id|i
op_increment
)braket
)paren
suffix:semicolon
id|free
c_func
(paren
id|args
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|count_diff_files
r_static
r_void
id|count_diff_files
c_func
(paren
r_struct
id|diff_queue_struct
op_star
id|q
comma
r_struct
id|diff_options
op_star
id|opt
comma
r_void
op_star
id|data
)paren
(brace
r_int
op_star
id|count
op_assign
id|data
suffix:semicolon
(paren
op_star
id|count
)paren
op_add_assign
id|q-&gt;nr
suffix:semicolon
)brace
DECL|function|count_unmerged_entries
r_static
r_int
id|count_unmerged_entries
c_func
(paren
r_void
)paren
(brace
r_const
r_struct
id|index_state
op_star
id|state
op_assign
op_amp
id|the_index
suffix:semicolon
r_int
id|i
comma
id|ret
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|state-&gt;cache_nr
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|ce_stage
c_func
(paren
id|state-&gt;cache
(braket
id|i
)braket
)paren
)paren
id|ret
op_increment
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|checkout_fast_forward
r_static
r_int
id|checkout_fast_forward
c_func
(paren
r_int
r_char
op_star
id|head
comma
r_int
r_char
op_star
id|remote
)paren
(brace
r_struct
id|tree
op_star
id|trees
(braket
id|MAX_UNPACK_TREES
)braket
suffix:semicolon
r_struct
id|unpack_trees_options
id|opts
suffix:semicolon
r_struct
id|tree_desc
id|t
(braket
id|MAX_UNPACK_TREES
)braket
suffix:semicolon
r_int
id|i
comma
id|fd
comma
id|nr_trees
op_assign
l_int|0
suffix:semicolon
r_struct
id|dir_struct
id|dir
suffix:semicolon
r_struct
id|lock_file
op_star
id|lock_file
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|lock_file
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_cache_unmerged
c_func
(paren
)paren
)paren
id|die
c_func
(paren
l_string|&quot;you need to resolve your current index first&quot;
)paren
suffix:semicolon
id|fd
op_assign
id|hold_locked_index
c_func
(paren
id|lock_file
comma
l_int|1
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|trees
comma
l_int|0
comma
r_sizeof
(paren
id|trees
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|opts
comma
l_int|0
comma
r_sizeof
(paren
id|opts
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|t
comma
l_int|0
comma
r_sizeof
(paren
id|t
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|dir
comma
l_int|0
comma
r_sizeof
(paren
id|dir
)paren
)paren
suffix:semicolon
id|dir.show_ignored
op_assign
l_int|1
suffix:semicolon
id|dir.exclude_per_dir
op_assign
l_string|&quot;.gitignore&quot;
suffix:semicolon
id|opts.dir
op_assign
op_amp
id|dir
suffix:semicolon
id|opts.head_idx
op_assign
l_int|1
suffix:semicolon
id|opts.src_index
op_assign
op_amp
id|the_index
suffix:semicolon
id|opts.dst_index
op_assign
op_amp
id|the_index
suffix:semicolon
id|opts.update
op_assign
l_int|1
suffix:semicolon
id|opts.verbose_update
op_assign
l_int|1
suffix:semicolon
id|opts.merge
op_assign
l_int|1
suffix:semicolon
id|opts.fn
op_assign
id|twoway_merge
suffix:semicolon
id|trees
(braket
id|nr_trees
)braket
op_assign
id|parse_tree_indirect
c_func
(paren
id|head
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|trees
(braket
id|nr_trees
op_increment
)braket
)paren
r_return
l_int|1
suffix:semicolon
id|trees
(braket
id|nr_trees
)braket
op_assign
id|parse_tree_indirect
c_func
(paren
id|remote
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|trees
(braket
id|nr_trees
op_increment
)braket
)paren
r_return
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_trees
suffix:semicolon
id|i
op_increment
)paren
(brace
id|parse_tree
c_func
(paren
id|trees
(braket
id|i
)braket
)paren
suffix:semicolon
id|init_tree_desc
c_func
(paren
id|t
op_plus
id|i
comma
id|trees
(braket
id|i
)braket
op_member_access_from_pointer
id|buffer
comma
id|trees
(braket
id|i
)braket
op_member_access_from_pointer
id|size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unpack_trees
c_func
(paren
id|nr_trees
comma
id|t
comma
op_amp
id|opts
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|write_cache
c_func
(paren
id|fd
comma
id|active_cache
comma
id|active_nr
)paren
op_logical_or
id|commit_locked_index
c_func
(paren
id|lock_file
)paren
)paren
id|die
c_func
(paren
l_string|&quot;unable to write new index file&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|split_merge_strategies
r_static
r_void
id|split_merge_strategies
c_func
(paren
r_const
r_char
op_star
id|string
comma
r_struct
id|strategy
op_star
op_star
id|list
comma
r_int
op_star
id|nr
comma
r_int
op_star
id|alloc
)paren
(brace
r_char
op_star
id|p
comma
op_star
id|q
comma
op_star
id|buf
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|string
)paren
r_return
suffix:semicolon
id|buf
op_assign
id|xstrdup
c_func
(paren
id|string
)paren
suffix:semicolon
id|q
op_assign
id|buf
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|p
op_assign
id|strchr
c_func
(paren
id|q
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
(brace
id|ALLOC_GROW
c_func
(paren
op_star
id|list
comma
op_star
id|nr
op_plus
l_int|1
comma
op_star
id|alloc
)paren
suffix:semicolon
(paren
op_star
id|list
)paren
(braket
(paren
op_star
id|nr
)paren
op_increment
)braket
dot
id|name
op_assign
id|xstrdup
c_func
(paren
id|q
)paren
suffix:semicolon
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
op_star
id|p
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|ALLOC_GROW
c_func
(paren
op_star
id|list
comma
op_star
id|nr
op_plus
l_int|1
comma
op_star
id|alloc
)paren
suffix:semicolon
(paren
op_star
id|list
)paren
(braket
(paren
op_star
id|nr
)paren
op_increment
)braket
dot
id|name
op_assign
id|xstrdup
c_func
(paren
id|q
)paren
suffix:semicolon
id|q
op_assign
op_increment
id|p
suffix:semicolon
)brace
)brace
)brace
DECL|function|add_strategies
r_static
r_void
id|add_strategies
c_func
(paren
r_const
r_char
op_star
id|string
comma
r_int
id|attr
)paren
(brace
r_struct
id|strategy
op_star
id|list
op_assign
l_int|NULL
suffix:semicolon
r_int
id|list_alloc
op_assign
l_int|0
comma
id|list_nr
op_assign
l_int|0
comma
id|i
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|list
comma
l_int|0
comma
r_sizeof
(paren
id|list
)paren
)paren
suffix:semicolon
id|split_merge_strategies
c_func
(paren
id|string
comma
op_amp
id|list
comma
op_amp
id|list_nr
comma
op_amp
id|list_alloc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|list_nr
suffix:semicolon
id|i
op_increment
)paren
id|append_strategy
c_func
(paren
id|get_strategy
c_func
(paren
id|list
(braket
id|i
)braket
dot
id|name
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|all_strategy
)paren
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|all_strategy
(braket
id|i
)braket
dot
id|attr
op_amp
id|attr
)paren
id|append_strategy
c_func
(paren
op_amp
id|all_strategy
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
DECL|function|merge_trivial
r_static
r_int
id|merge_trivial
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|result_tree
(braket
l_int|20
)braket
comma
id|result_commit
(braket
l_int|20
)braket
suffix:semicolon
r_struct
id|commit_list
id|parent
suffix:semicolon
id|write_tree_trivial
c_func
(paren
id|result_tree
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Wonderful.&bslash;n&quot;
)paren
suffix:semicolon
id|parent.item
op_assign
id|remoteheads-&gt;item
suffix:semicolon
id|parent.next
op_assign
l_int|NULL
suffix:semicolon
id|commit_tree
c_func
(paren
id|merge_msg.buf
comma
id|result_tree
comma
op_amp
id|parent
comma
id|result_commit
)paren
suffix:semicolon
id|finish
c_func
(paren
id|result_commit
comma
l_string|&quot;In-index merge&quot;
)paren
suffix:semicolon
id|drop_save
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|finish_automerge
r_static
r_int
id|finish_automerge
c_func
(paren
r_struct
id|commit_list
op_star
id|common
comma
r_int
r_char
op_star
id|result_tree
comma
r_const
r_char
op_star
id|wt_strategy
)paren
(brace
r_struct
id|commit_list
op_star
id|parents
op_assign
l_int|NULL
comma
op_star
id|j
suffix:semicolon
r_struct
id|strbuf
id|buf
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
r_char
id|result_commit
(braket
l_int|20
)braket
suffix:semicolon
id|free_commit_list
c_func
(paren
id|common
)paren
suffix:semicolon
r_if
c_cond
(paren
id|allow_fast_forward
)paren
(brace
id|parents
op_assign
id|remoteheads
suffix:semicolon
id|commit_list_insert
c_func
(paren
id|lookup_commit
c_func
(paren
id|head
)paren
comma
op_amp
id|parents
)paren
suffix:semicolon
id|parents
op_assign
id|reduce_heads
c_func
(paren
id|parents
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|commit_list
op_star
op_star
id|pptr
op_assign
op_amp
id|parents
suffix:semicolon
id|pptr
op_assign
op_amp
id|commit_list_insert
c_func
(paren
id|lookup_commit
c_func
(paren
id|head
)paren
comma
id|pptr
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|remoteheads
suffix:semicolon
id|j
suffix:semicolon
id|j
op_assign
id|j-&gt;next
)paren
id|pptr
op_assign
op_amp
id|commit_list_insert
c_func
(paren
id|j-&gt;item
comma
id|pptr
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
)brace
id|free_commit_list
c_func
(paren
id|remoteheads
)paren
suffix:semicolon
id|strbuf_addch
c_func
(paren
op_amp
id|merge_msg
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|commit_tree
c_func
(paren
id|merge_msg.buf
comma
id|result_tree
comma
id|parents
comma
id|result_commit
)paren
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
id|buf
comma
l_string|&quot;Merge made by %s.&quot;
comma
id|wt_strategy
)paren
suffix:semicolon
id|finish
c_func
(paren
id|result_commit
comma
id|buf.buf
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|buf
)paren
suffix:semicolon
id|drop_save
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|suggest_conflicts
r_static
r_int
id|suggest_conflicts
c_func
(paren
r_void
)paren
(brace
id|FILE
op_star
id|fp
suffix:semicolon
r_int
id|pos
suffix:semicolon
id|fp
op_assign
id|fopen
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;MERGE_MSG&quot;
)paren
comma
l_string|&quot;a&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fp
)paren
id|die
c_func
(paren
l_string|&quot;Could open %s for writing&quot;
comma
id|git_path
c_func
(paren
l_string|&quot;MERGE_MSG&quot;
)paren
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|fp
comma
l_string|&quot;&bslash;nConflicts:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pos
op_assign
l_int|0
suffix:semicolon
id|pos
OL
id|active_nr
suffix:semicolon
id|pos
op_increment
)paren
(brace
r_struct
id|cache_entry
op_star
id|ce
op_assign
id|active_cache
(braket
id|pos
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ce_stage
c_func
(paren
id|ce
)paren
)paren
(brace
id|fprintf
c_func
(paren
id|fp
comma
l_string|&quot;&bslash;t%s&bslash;n&quot;
comma
id|ce-&gt;name
)paren
suffix:semicolon
r_while
c_loop
(paren
id|pos
op_plus
l_int|1
OL
id|active_nr
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|ce-&gt;name
comma
id|active_cache
(braket
id|pos
op_plus
l_int|1
)braket
op_member_access_from_pointer
id|name
)paren
)paren
id|pos
op_increment
suffix:semicolon
)brace
)brace
id|fclose
c_func
(paren
id|fp
)paren
suffix:semicolon
id|rerere
c_func
(paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Automatic merge failed; &quot;
l_string|&quot;fix conflicts and then commit the result.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|is_old_style_invocation
r_static
r_struct
id|commit
op_star
id|is_old_style_invocation
c_func
(paren
r_int
id|argc
comma
r_const
r_char
op_star
op_star
id|argv
)paren
(brace
r_struct
id|commit
op_star
id|second_token
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|argc
OG
l_int|1
)paren
(brace
r_int
r_char
id|second_sha1
(braket
l_int|20
)braket
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
id|second_sha1
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|second_token
op_assign
id|lookup_commit_reference_gently
c_func
(paren
id|second_sha1
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|second_token
)paren
id|die
c_func
(paren
l_string|&quot;&squot;%s&squot; is not a commit&quot;
comma
id|argv
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hashcmp
c_func
(paren
id|second_token-&gt;object.sha1
comma
id|head
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|second_token
suffix:semicolon
)brace
DECL|function|evaluate_result
r_static
r_int
id|evaluate_result
c_func
(paren
r_void
)paren
(brace
r_int
id|cnt
op_assign
l_int|0
suffix:semicolon
r_struct
id|rev_info
id|rev
suffix:semicolon
r_if
c_cond
(paren
id|read_cache
c_func
(paren
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;failed to read the cache&quot;
)paren
suffix:semicolon
multiline_comment|/* Check how many files differ. */
id|init_revisions
c_func
(paren
op_amp
id|rev
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
id|setup_revisions
c_func
(paren
l_int|0
comma
l_int|NULL
comma
op_amp
id|rev
comma
l_int|NULL
)paren
suffix:semicolon
id|rev.diffopt.output_format
op_or_assign
id|DIFF_FORMAT_CALLBACK
suffix:semicolon
id|rev.diffopt.format_callback
op_assign
id|count_diff_files
suffix:semicolon
id|rev.diffopt.format_callback_data
op_assign
op_amp
id|cnt
suffix:semicolon
id|run_diff_files
c_func
(paren
op_amp
id|rev
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check how many unmerged entries are&n;&t; * there.&n;&t; */
id|cnt
op_add_assign
id|count_unmerged_entries
c_func
(paren
)paren
suffix:semicolon
r_return
id|cnt
suffix:semicolon
)brace
DECL|function|cmd_merge
r_int
id|cmd_merge
c_func
(paren
r_int
id|argc
comma
r_const
r_char
op_star
op_star
id|argv
comma
r_const
r_char
op_star
id|prefix
)paren
(brace
r_int
r_char
id|result_tree
(braket
l_int|20
)braket
suffix:semicolon
r_struct
id|strbuf
id|buf
suffix:semicolon
r_const
r_char
op_star
id|head_arg
suffix:semicolon
r_int
id|flag
comma
id|head_invalid
op_assign
l_int|0
comma
id|i
suffix:semicolon
r_int
id|best_cnt
op_assign
l_int|1
comma
id|merge_was_ok
op_assign
l_int|0
comma
id|automerge_was_ok
op_assign
l_int|0
suffix:semicolon
r_struct
id|commit_list
op_star
id|common
op_assign
l_int|NULL
suffix:semicolon
r_const
r_char
op_star
id|best_strategy
op_assign
l_int|NULL
comma
op_star
id|wt_strategy
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|commit_list
op_star
op_star
id|remotes
op_assign
op_amp
id|remoteheads
suffix:semicolon
id|setup_work_tree
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unmerged_cache
c_func
(paren
)paren
)paren
id|die
c_func
(paren
l_string|&quot;You are in the middle of a conflicted merge.&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check if we are _not_ on a detached HEAD, i.e. if there is a&n;&t; * current branch.&n;&t; */
id|branch
op_assign
id|resolve_ref
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|head
comma
l_int|0
comma
op_amp
id|flag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|branch
op_logical_and
op_logical_neg
id|prefixcmp
c_func
(paren
id|branch
comma
l_string|&quot;refs/heads/&quot;
)paren
)paren
id|branch
op_add_assign
l_int|11
suffix:semicolon
r_if
c_cond
(paren
id|is_null_sha1
c_func
(paren
id|head
)paren
)paren
id|head_invalid
op_assign
l_int|1
suffix:semicolon
id|git_config
c_func
(paren
id|git_merge_config
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* for color.ui */
r_if
c_cond
(paren
id|diff_use_color_default
op_eq
l_int|1
)paren
id|diff_use_color_default
op_assign
id|git_use_color_default
suffix:semicolon
id|argc
op_assign
id|parse_options
c_func
(paren
id|argc
comma
id|argv
comma
id|builtin_merge_options
comma
id|builtin_merge_usage
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|squash
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|allow_fast_forward
)paren
id|die
c_func
(paren
l_string|&quot;You cannot combine --squash with --no-ff.&quot;
)paren
suffix:semicolon
id|option_commit
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|argc
)paren
id|usage_with_options
c_func
(paren
id|builtin_merge_usage
comma
id|builtin_merge_options
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This could be traditional &quot;merge &lt;msg&gt; HEAD &lt;commit&gt;...&quot;  and&n;&t; * the way we can tell it is to see if the second token is HEAD,&n;&t; * but some people might have misused the interface and used a&n;&t; * committish that is the same as HEAD there instead.&n;&t; * Traditional format never would have &quot;-m&quot; so it is an&n;&t; * additional safety measure to check for it.&n;&t; */
id|strbuf_init
c_func
(paren
op_amp
id|buf
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|have_message
op_logical_and
id|is_old_style_invocation
c_func
(paren
id|argc
comma
id|argv
)paren
)paren
(brace
id|strbuf_addstr
c_func
(paren
op_amp
id|merge_msg
comma
id|argv
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|head_arg
op_assign
id|argv
(braket
l_int|1
)braket
suffix:semicolon
id|argv
op_add_assign
l_int|2
suffix:semicolon
id|argc
op_sub_assign
l_int|2
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|head_invalid
)paren
(brace
r_struct
id|object
op_star
id|remote_head
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the merged head is a valid one there is no reason&n;&t;&t; * to forbid &quot;git merge&quot; into a branch yet to be born.&n;&t;&t; * We do the same for &quot;git pull&quot;.&n;&t;&t; */
r_if
c_cond
(paren
id|argc
op_ne
l_int|1
)paren
id|die
c_func
(paren
l_string|&quot;Can merge only exactly one commit into &quot;
l_string|&quot;empty head&quot;
)paren
suffix:semicolon
id|remote_head
op_assign
id|peel_to_type
c_func
(paren
id|argv
(braket
l_int|0
)braket
comma
l_int|0
comma
l_int|NULL
comma
id|OBJ_COMMIT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|remote_head
)paren
id|die
c_func
(paren
l_string|&quot;%s - not something we can merge&quot;
comma
id|argv
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|update_ref
c_func
(paren
l_string|&quot;initial pull&quot;
comma
l_string|&quot;HEAD&quot;
comma
id|remote_head-&gt;sha1
comma
l_int|NULL
comma
l_int|0
comma
id|DIE_ON_ERR
)paren
suffix:semicolon
id|reset_hard
c_func
(paren
id|remote_head-&gt;sha1
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_struct
id|strbuf
id|msg
suffix:semicolon
multiline_comment|/* We are invoked directly as the first-class UI. */
id|head_arg
op_assign
l_string|&quot;HEAD&quot;
suffix:semicolon
multiline_comment|/*&n;&t;&t; * All the rest are the commits being merged;&n;&t;&t; * prepare the standard merge summary message to&n;&t;&t; * be appended to the given message.  If remote&n;&t;&t; * is invalid we will die later in the common&n;&t;&t; * codepath so we discard the error in this&n;&t;&t; * loop.&n;&t;&t; */
id|strbuf_init
c_func
(paren
op_amp
id|msg
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|argc
suffix:semicolon
id|i
op_increment
)paren
id|merge_name
c_func
(paren
id|argv
(braket
id|i
)braket
comma
op_amp
id|msg
)paren
suffix:semicolon
id|fmt_merge_msg
c_func
(paren
id|option_log
comma
op_amp
id|msg
comma
op_amp
id|merge_msg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|merge_msg.len
)paren
id|strbuf_setlen
c_func
(paren
op_amp
id|merge_msg
comma
id|merge_msg.len
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|head_invalid
op_logical_or
op_logical_neg
id|argc
)paren
id|usage_with_options
c_func
(paren
id|builtin_merge_usage
comma
id|builtin_merge_options
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|buf
comma
l_string|&quot;merge&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|argc
suffix:semicolon
id|i
op_increment
)paren
id|strbuf_addf
c_func
(paren
op_amp
id|buf
comma
l_string|&quot; %s&quot;
comma
id|argv
(braket
id|i
)braket
)paren
suffix:semicolon
id|setenv
c_func
(paren
l_string|&quot;GIT_REFLOG_ACTION&quot;
comma
id|buf.buf
comma
l_int|0
)paren
suffix:semicolon
id|strbuf_reset
c_func
(paren
op_amp
id|buf
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|argc
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|object
op_star
id|o
suffix:semicolon
id|o
op_assign
id|peel_to_type
c_func
(paren
id|argv
(braket
id|i
)braket
comma
l_int|0
comma
l_int|NULL
comma
id|OBJ_COMMIT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|o
)paren
id|die
c_func
(paren
l_string|&quot;%s - not something we can merge&quot;
comma
id|argv
(braket
id|i
)braket
)paren
suffix:semicolon
id|remotes
op_assign
op_amp
id|commit_list_insert
c_func
(paren
id|lookup_commit
c_func
(paren
id|o-&gt;sha1
)paren
comma
id|remotes
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
id|buf
comma
l_string|&quot;GITHEAD_%s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|o-&gt;sha1
)paren
)paren
suffix:semicolon
id|setenv
c_func
(paren
id|buf.buf
comma
id|argv
(braket
id|i
)braket
comma
l_int|1
)paren
suffix:semicolon
id|strbuf_reset
c_func
(paren
op_amp
id|buf
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|use_strategies
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|remoteheads-&gt;next
)paren
id|add_strategies
c_func
(paren
id|pull_twohead
comma
id|DEFAULT_TWOHEAD
)paren
suffix:semicolon
r_else
id|add_strategies
c_func
(paren
id|pull_octopus
comma
id|DEFAULT_OCTOPUS
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|use_strategies_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|use_strategies
(braket
id|i
)braket
op_member_access_from_pointer
id|attr
op_amp
id|NO_FAST_FORWARD
)paren
id|allow_fast_forward
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|use_strategies
(braket
id|i
)braket
op_member_access_from_pointer
id|attr
op_amp
id|NO_TRIVIAL
)paren
id|allow_trivial
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|remoteheads-&gt;next
)paren
id|common
op_assign
id|get_merge_bases
c_func
(paren
id|lookup_commit
c_func
(paren
id|head
)paren
comma
id|remoteheads-&gt;item
comma
l_int|1
)paren
suffix:semicolon
r_else
(brace
r_struct
id|commit_list
op_star
id|list
op_assign
id|remoteheads
suffix:semicolon
id|commit_list_insert
c_func
(paren
id|lookup_commit
c_func
(paren
id|head
)paren
comma
op_amp
id|list
)paren
suffix:semicolon
id|common
op_assign
id|get_octopus_merge_bases
c_func
(paren
id|list
)paren
suffix:semicolon
id|free
c_func
(paren
id|list
)paren
suffix:semicolon
)brace
id|update_ref
c_func
(paren
l_string|&quot;updating ORIG_HEAD&quot;
comma
l_string|&quot;ORIG_HEAD&quot;
comma
id|head
comma
l_int|NULL
comma
l_int|0
comma
id|DIE_ON_ERR
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|common
)paren
suffix:semicolon
multiline_comment|/* No common ancestors found. We need a real merge. */
r_else
r_if
c_cond
(paren
op_logical_neg
id|remoteheads-&gt;next
op_logical_and
op_logical_neg
id|common-&gt;next
op_logical_and
id|common-&gt;item
op_eq
id|remoteheads-&gt;item
)paren
(brace
multiline_comment|/*&n;&t;&t; * If head can reach all the merge then we are up to date.&n;&t;&t; * but first the most common case of merging one remote.&n;&t;&t; */
id|finish_up_to_date
c_func
(paren
l_string|&quot;Already up-to-date.&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|allow_fast_forward
op_logical_and
op_logical_neg
id|remoteheads-&gt;next
op_logical_and
op_logical_neg
id|common-&gt;next
op_logical_and
op_logical_neg
id|hashcmp
c_func
(paren
id|common-&gt;item-&gt;object.sha1
comma
id|head
)paren
)paren
(brace
multiline_comment|/* Again the most common case of merging one remote. */
r_struct
id|strbuf
id|msg
suffix:semicolon
r_struct
id|object
op_star
id|o
suffix:semicolon
r_char
id|hex
(braket
l_int|41
)braket
suffix:semicolon
id|strcpy
c_func
(paren
id|hex
comma
id|find_unique_abbrev
c_func
(paren
id|head
comma
id|DEFAULT_ABBREV
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Updating %s..%s&bslash;n&quot;
comma
id|hex
comma
id|find_unique_abbrev
c_func
(paren
id|remoteheads-&gt;item-&gt;object.sha1
comma
id|DEFAULT_ABBREV
)paren
)paren
suffix:semicolon
id|refresh_cache
c_func
(paren
id|REFRESH_QUIET
)paren
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|msg
comma
l_int|0
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|msg
comma
l_string|&quot;Fast forward&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|have_message
)paren
id|strbuf_addstr
c_func
(paren
op_amp
id|msg
comma
l_string|&quot; (no commit created; -m option ignored)&quot;
)paren
suffix:semicolon
id|o
op_assign
id|peel_to_type
c_func
(paren
id|sha1_to_hex
c_func
(paren
id|remoteheads-&gt;item-&gt;object.sha1
)paren
comma
l_int|0
comma
l_int|NULL
comma
id|OBJ_COMMIT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|o
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|checkout_fast_forward
c_func
(paren
id|head
comma
id|remoteheads-&gt;item-&gt;object.sha1
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|finish
c_func
(paren
id|o-&gt;sha1
comma
id|msg.buf
)paren
suffix:semicolon
id|drop_save
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|remoteheads-&gt;next
op_logical_and
id|common-&gt;next
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We are not doing octopus and not fast forward.  Need&n;&t;&t; * a real merge.&n;&t;&t; */
r_else
r_if
c_cond
(paren
op_logical_neg
id|remoteheads-&gt;next
op_logical_and
op_logical_neg
id|common-&gt;next
op_logical_and
id|option_commit
)paren
(brace
multiline_comment|/*&n;&t;&t; * We are not doing octopus, not fast forward, and have&n;&t;&t; * only one common.&n;&t;&t; */
id|refresh_cache
c_func
(paren
id|REFRESH_QUIET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|allow_trivial
)paren
(brace
multiline_comment|/* See if it is really trivial. */
id|git_committer_info
c_func
(paren
id|IDENT_ERROR_ON_NO_NAME
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Trying really trivial in-index merge...&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|read_tree_trivial
c_func
(paren
id|common-&gt;item-&gt;object.sha1
comma
id|head
comma
id|remoteheads-&gt;item-&gt;object.sha1
)paren
)paren
r_return
id|merge_trivial
c_func
(paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Nope.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * An octopus.  If we can reach all the remote we are up&n;&t;&t; * to date.&n;&t;&t; */
r_int
id|up_to_date
op_assign
l_int|1
suffix:semicolon
r_struct
id|commit_list
op_star
id|j
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|remoteheads
suffix:semicolon
id|j
suffix:semicolon
id|j
op_assign
id|j-&gt;next
)paren
(brace
r_struct
id|commit_list
op_star
id|common_one
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Here we *have* to calculate the individual&n;&t;&t;&t; * merge_bases again, otherwise &quot;git merge HEAD^&n;&t;&t;&t; * HEAD^^&quot; would be missed.&n;&t;&t;&t; */
id|common_one
op_assign
id|get_merge_bases
c_func
(paren
id|lookup_commit
c_func
(paren
id|head
)paren
comma
id|j-&gt;item
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hashcmp
c_func
(paren
id|common_one-&gt;item-&gt;object.sha1
comma
id|j-&gt;item-&gt;object.sha1
)paren
)paren
(brace
id|up_to_date
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|up_to_date
)paren
(brace
id|finish_up_to_date
c_func
(paren
l_string|&quot;Already up-to-date. Yeeah!&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* We are going to make a new commit. */
id|git_committer_info
c_func
(paren
id|IDENT_ERROR_ON_NO_NAME
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * At this point, we need a real merge.  No matter what strategy&n;&t; * we use, it would operate on the index, possibly affecting the&n;&t; * working tree, and when resolved cleanly, have the desired&n;&t; * tree in the index -- this means that the index must be in&n;&t; * sync with the head commit.  The strategies are responsible&n;&t; * to ensure this.&n;&t; */
r_if
c_cond
(paren
id|use_strategies_nr
op_ne
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t; * Stash away the local changes so that we can try more&n;&t;&t; * than one.&n;&t;&t; */
id|save_state
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|stash
comma
id|null_sha1
comma
l_int|20
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|use_strategies_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Rewinding the tree to pristine...&bslash;n&quot;
)paren
suffix:semicolon
id|restore_state
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|use_strategies_nr
op_ne
l_int|1
)paren
id|printf
c_func
(paren
l_string|&quot;Trying merge strategy %s...&bslash;n&quot;
comma
id|use_strategies
(braket
id|i
)braket
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Remember which strategy left the state in the working&n;&t;&t; * tree.&n;&t;&t; */
id|wt_strategy
op_assign
id|use_strategies
(braket
id|i
)braket
op_member_access_from_pointer
id|name
suffix:semicolon
id|ret
op_assign
id|try_merge_strategy
c_func
(paren
id|use_strategies
(braket
id|i
)braket
op_member_access_from_pointer
id|name
comma
id|common
comma
id|head_arg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|option_commit
op_logical_and
op_logical_neg
id|ret
)paren
(brace
id|merge_was_ok
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * This is necessary here just to avoid writing&n;&t;&t;&t; * the tree, but later we will *not* exit with&n;&t;&t;&t; * status code 1 because merge_was_ok is set.&n;&t;&t;&t; */
id|ret
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * The backend exits with 1 when conflicts are&n;&t;&t;&t; * left to be resolved, with 2 when it does not&n;&t;&t;&t; * handle the given merge at all.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ret
op_eq
l_int|1
)paren
(brace
r_int
id|cnt
op_assign
id|evaluate_result
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|best_cnt
op_le
l_int|0
op_logical_or
id|cnt
op_le
id|best_cnt
)paren
(brace
id|best_strategy
op_assign
id|use_strategies
(braket
id|i
)braket
op_member_access_from_pointer
id|name
suffix:semicolon
id|best_cnt
op_assign
id|cnt
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|merge_was_ok
)paren
r_break
suffix:semicolon
r_else
r_continue
suffix:semicolon
)brace
multiline_comment|/* Automerge succeeded. */
id|write_tree_trivial
c_func
(paren
id|result_tree
)paren
suffix:semicolon
id|automerge_was_ok
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we have a resulting tree, that means the strategy module&n;&t; * auto resolved the merge cleanly.&n;&t; */
r_if
c_cond
(paren
id|automerge_was_ok
)paren
r_return
id|finish_automerge
c_func
(paren
id|common
comma
id|result_tree
comma
id|wt_strategy
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Pick the result from the best strategy and have the user fix&n;&t; * it up.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|best_strategy
)paren
(brace
id|restore_state
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|use_strategies_nr
OG
l_int|1
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;No merge strategy handled the merge.&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Merge with strategy %s failed.&bslash;n&quot;
comma
id|use_strategies
(braket
l_int|0
)braket
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
r_return
l_int|2
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|best_strategy
op_eq
id|wt_strategy
)paren
suffix:semicolon
multiline_comment|/* We already have its result in the working tree. */
r_else
(brace
id|printf
c_func
(paren
l_string|&quot;Rewinding the tree to pristine...&bslash;n&quot;
)paren
suffix:semicolon
id|restore_state
c_func
(paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Using the %s to prepare resolving by hand.&bslash;n&quot;
comma
id|best_strategy
)paren
suffix:semicolon
id|try_merge_strategy
c_func
(paren
id|best_strategy
comma
id|common
comma
id|head_arg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|squash
)paren
id|finish
c_func
(paren
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_else
(brace
r_int
id|fd
suffix:semicolon
r_struct
id|commit_list
op_star
id|j
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|remoteheads
suffix:semicolon
id|j
suffix:semicolon
id|j
op_assign
id|j-&gt;next
)paren
id|strbuf_addf
c_func
(paren
op_amp
id|buf
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|j-&gt;item-&gt;object.sha1
)paren
)paren
suffix:semicolon
id|fd
op_assign
id|open
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;MERGE_HEAD&quot;
)paren
comma
id|O_WRONLY
op_or
id|O_CREAT
comma
l_int|0666
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;Could open %s for writing&quot;
comma
id|git_path
c_func
(paren
l_string|&quot;MERGE_HEAD&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write_in_full
c_func
(paren
id|fd
comma
id|buf.buf
comma
id|buf.len
)paren
op_ne
id|buf.len
)paren
id|die
c_func
(paren
l_string|&quot;Could not write to %s&quot;
comma
id|git_path
c_func
(paren
l_string|&quot;MERGE_HEAD&quot;
)paren
)paren
suffix:semicolon
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
id|strbuf_addch
c_func
(paren
op_amp
id|merge_msg
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|fd
op_assign
id|open
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;MERGE_MSG&quot;
)paren
comma
id|O_WRONLY
op_or
id|O_CREAT
comma
l_int|0666
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;Could open %s for writing&quot;
comma
id|git_path
c_func
(paren
l_string|&quot;MERGE_MSG&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write_in_full
c_func
(paren
id|fd
comma
id|merge_msg.buf
comma
id|merge_msg.len
)paren
op_ne
id|merge_msg.len
)paren
id|die
c_func
(paren
l_string|&quot;Could not write to %s&quot;
comma
id|git_path
c_func
(paren
l_string|&quot;MERGE_MSG&quot;
)paren
)paren
suffix:semicolon
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|merge_was_ok
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Automatic merge went well; &quot;
l_string|&quot;stopped before committing as requested&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_return
id|suggest_conflicts
c_func
(paren
)paren
suffix:semicolon
)brace
eof
