macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;commit.h&quot;
macro_line|#include &quot;graph.h&quot;
macro_line|#include &quot;diff.h&quot;
macro_line|#include &quot;revision.h&quot;
multiline_comment|/*&n; * TODO:&n; * - Add colors to the graph.&n; *   Pick a color for each column, and print all characters&n; *   in that column with the specified color.&n; *&n; * - Limit the number of columns, similar to the way gitk does.&n; *   If we reach more than a specified number of columns, omit&n; *   sections of some columns.&n; *&n; * - The output during the GRAPH_PRE_COMMIT and GRAPH_COLLAPSING states&n; *   could be made more compact by printing horizontal lines, instead of&n; *   long diagonal lines.  For example, during collapsing, something like&n; *   this:          instead of this:&n; *   | | | | |      | | | | |&n; *   | |_|_|/       | | | |/&n; *   |/| | |        | | |/|&n; *   | | | |        | |/| |&n; *                  |/| | |&n; *                  | | | |&n; *&n; *   If there are several parallel diagonal lines, they will need to be&n; *   replaced with horizontal lines on subsequent rows.&n; */
DECL|struct|column
r_struct
id|column
(brace
multiline_comment|/*&n;&t; * The parent commit of this column.&n;&t; */
DECL|member|commit
r_struct
id|commit
op_star
id|commit
suffix:semicolon
multiline_comment|/*&n;&t; * XXX: Once we add support for colors, struct column could also&n;&t; * contain the color of its branch line.&n;&t; */
)brace
suffix:semicolon
DECL|enum|graph_state
r_enum
id|graph_state
(brace
DECL|enumerator|GRAPH_PADDING
id|GRAPH_PADDING
comma
DECL|enumerator|GRAPH_SKIP
id|GRAPH_SKIP
comma
DECL|enumerator|GRAPH_PRE_COMMIT
id|GRAPH_PRE_COMMIT
comma
DECL|enumerator|GRAPH_COMMIT
id|GRAPH_COMMIT
comma
DECL|enumerator|GRAPH_POST_MERGE
id|GRAPH_POST_MERGE
comma
DECL|enumerator|GRAPH_COLLAPSING
id|GRAPH_COLLAPSING
)brace
suffix:semicolon
DECL|struct|git_graph
r_struct
id|git_graph
(brace
multiline_comment|/*&n;&t; * The commit currently being processed&n;&t; */
DECL|member|commit
r_struct
id|commit
op_star
id|commit
suffix:semicolon
multiline_comment|/* The rev-info used for the current traversal */
DECL|member|revs
r_struct
id|rev_info
op_star
id|revs
suffix:semicolon
multiline_comment|/*&n;&t; * The number of interesting parents that this commit has.&n;&t; *&n;&t; * Note that this is not the same as the actual number of parents.&n;&t; * This count excludes parents that won&squot;t be printed in the graph&n;&t; * output, as determined by graph_is_interesting().&n;&t; */
DECL|member|num_parents
r_int
id|num_parents
suffix:semicolon
multiline_comment|/*&n;&t; * The width of the graph output for this commit.&n;&t; * All rows for this commit are padded to this width, so that&n;&t; * messages printed after the graph output are aligned.&n;&t; */
DECL|member|width
r_int
id|width
suffix:semicolon
multiline_comment|/*&n;&t; * The next expansion row to print&n;&t; * when state is GRAPH_PRE_COMMIT&n;&t; */
DECL|member|expansion_row
r_int
id|expansion_row
suffix:semicolon
multiline_comment|/*&n;&t; * The current output state.&n;&t; * This tells us what kind of line graph_next_line() should output.&n;&t; */
DECL|member|state
r_enum
id|graph_state
id|state
suffix:semicolon
multiline_comment|/*&n;&t; * The output state for the previous line of output.&n;&t; * This is primarily used to determine how the first merge line&n;&t; * should appear, based on the last line of the previous commit.&n;&t; */
DECL|member|prev_state
r_enum
id|graph_state
id|prev_state
suffix:semicolon
multiline_comment|/*&n;&t; * The index of the column that refers to this commit.&n;&t; *&n;&t; * If none of the incoming columns refer to this commit,&n;&t; * this will be equal to num_columns.&n;&t; */
DECL|member|commit_index
r_int
id|commit_index
suffix:semicolon
multiline_comment|/*&n;&t; * The commit_index for the previously displayed commit.&n;&t; *&n;&t; * This is used to determine how the first line of a merge&n;&t; * graph output should appear, based on the last line of the&n;&t; * previous commit.&n;&t; */
DECL|member|prev_commit_index
r_int
id|prev_commit_index
suffix:semicolon
multiline_comment|/*&n;&t; * The maximum number of columns that can be stored in the columns&n;&t; * and new_columns arrays.  This is also half the number of entries&n;&t; * that can be stored in the mapping and new_mapping arrays.&n;&t; */
DECL|member|column_capacity
r_int
id|column_capacity
suffix:semicolon
multiline_comment|/*&n;&t; * The number of columns (also called &quot;branch lines&quot; in some places)&n;&t; */
DECL|member|num_columns
r_int
id|num_columns
suffix:semicolon
multiline_comment|/*&n;&t; * The number of columns in the new_columns array&n;&t; */
DECL|member|num_new_columns
r_int
id|num_new_columns
suffix:semicolon
multiline_comment|/*&n;&t; * The number of entries in the mapping array&n;&t; */
DECL|member|mapping_size
r_int
id|mapping_size
suffix:semicolon
multiline_comment|/*&n;&t; * The column state before we output the current commit.&n;&t; */
DECL|member|columns
r_struct
id|column
op_star
id|columns
suffix:semicolon
multiline_comment|/*&n;&t; * The new column state after we output the current commit.&n;&t; * Only valid when state is GRAPH_COLLAPSING.&n;&t; */
DECL|member|new_columns
r_struct
id|column
op_star
id|new_columns
suffix:semicolon
multiline_comment|/*&n;&t; * An array that tracks the current state of each&n;&t; * character in the output line during state GRAPH_COLLAPSING.&n;&t; * Each entry is -1 if this character is empty, or a non-negative&n;&t; * integer if the character contains a branch line.  The value of&n;&t; * the integer indicates the target position for this branch line.&n;&t; * (I.e., this array maps the current column positions to their&n;&t; * desired positions.)&n;&t; *&n;&t; * The maximum capacity of this array is always&n;&t; * sizeof(int) * 2 * column_capacity.&n;&t; */
DECL|member|mapping
r_int
op_star
id|mapping
suffix:semicolon
multiline_comment|/*&n;&t; * A temporary array for computing the next mapping state&n;&t; * while we are outputting a mapping line.  This is stored as part&n;&t; * of the git_graph simply so we don&squot;t have to allocate a new&n;&t; * temporary array each time we have to output a collapsing line.&n;&t; */
DECL|member|new_mapping
r_int
op_star
id|new_mapping
suffix:semicolon
)brace
suffix:semicolon
DECL|function|graph_init
r_struct
id|git_graph
op_star
id|graph_init
c_func
(paren
r_struct
id|rev_info
op_star
id|opt
)paren
(brace
r_struct
id|git_graph
op_star
id|graph
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|git_graph
)paren
)paren
suffix:semicolon
id|graph-&gt;commit
op_assign
l_int|NULL
suffix:semicolon
id|graph-&gt;revs
op_assign
id|opt
suffix:semicolon
id|graph-&gt;num_parents
op_assign
l_int|0
suffix:semicolon
id|graph-&gt;expansion_row
op_assign
l_int|0
suffix:semicolon
id|graph-&gt;state
op_assign
id|GRAPH_PADDING
suffix:semicolon
id|graph-&gt;prev_state
op_assign
id|GRAPH_PADDING
suffix:semicolon
id|graph-&gt;commit_index
op_assign
l_int|0
suffix:semicolon
id|graph-&gt;prev_commit_index
op_assign
l_int|0
suffix:semicolon
id|graph-&gt;num_columns
op_assign
l_int|0
suffix:semicolon
id|graph-&gt;num_new_columns
op_assign
l_int|0
suffix:semicolon
id|graph-&gt;mapping_size
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate a reasonably large default number of columns&n;&t; * We&squot;ll automatically grow columns later if we need more room.&n;&t; */
id|graph-&gt;column_capacity
op_assign
l_int|30
suffix:semicolon
id|graph-&gt;columns
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|column
)paren
op_star
id|graph-&gt;column_capacity
)paren
suffix:semicolon
id|graph-&gt;new_columns
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|column
)paren
op_star
id|graph-&gt;column_capacity
)paren
suffix:semicolon
id|graph-&gt;mapping
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
r_int
)paren
op_star
l_int|2
op_star
id|graph-&gt;column_capacity
)paren
suffix:semicolon
id|graph-&gt;new_mapping
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
r_int
)paren
op_star
l_int|2
op_star
id|graph-&gt;column_capacity
)paren
suffix:semicolon
r_return
id|graph
suffix:semicolon
)brace
DECL|function|graph_release
r_void
id|graph_release
c_func
(paren
r_struct
id|git_graph
op_star
id|graph
)paren
(brace
id|free
c_func
(paren
id|graph-&gt;columns
)paren
suffix:semicolon
id|free
c_func
(paren
id|graph-&gt;new_columns
)paren
suffix:semicolon
id|free
c_func
(paren
id|graph-&gt;mapping
)paren
suffix:semicolon
id|free
c_func
(paren
id|graph
)paren
suffix:semicolon
)brace
DECL|function|graph_update_state
r_static
r_void
id|graph_update_state
c_func
(paren
r_struct
id|git_graph
op_star
id|graph
comma
r_enum
id|graph_state
id|s
)paren
(brace
id|graph-&gt;prev_state
op_assign
id|graph-&gt;state
suffix:semicolon
id|graph-&gt;state
op_assign
id|s
suffix:semicolon
)brace
DECL|function|graph_ensure_capacity
r_static
r_void
id|graph_ensure_capacity
c_func
(paren
r_struct
id|git_graph
op_star
id|graph
comma
r_int
id|num_columns
)paren
(brace
r_if
c_cond
(paren
id|graph-&gt;column_capacity
op_ge
id|num_columns
)paren
r_return
suffix:semicolon
r_do
(brace
id|graph-&gt;column_capacity
op_mul_assign
l_int|2
suffix:semicolon
)brace
r_while
c_loop
(paren
id|graph-&gt;column_capacity
OL
id|num_columns
)paren
suffix:semicolon
id|graph-&gt;columns
op_assign
id|xrealloc
c_func
(paren
id|graph-&gt;columns
comma
r_sizeof
(paren
r_struct
id|column
)paren
op_star
id|graph-&gt;column_capacity
)paren
suffix:semicolon
id|graph-&gt;new_columns
op_assign
id|xrealloc
c_func
(paren
id|graph-&gt;new_columns
comma
r_sizeof
(paren
r_struct
id|column
)paren
op_star
id|graph-&gt;column_capacity
)paren
suffix:semicolon
id|graph-&gt;mapping
op_assign
id|xrealloc
c_func
(paren
id|graph-&gt;mapping
comma
r_sizeof
(paren
r_int
)paren
op_star
l_int|2
op_star
id|graph-&gt;column_capacity
)paren
suffix:semicolon
id|graph-&gt;new_mapping
op_assign
id|xrealloc
c_func
(paren
id|graph-&gt;new_mapping
comma
r_sizeof
(paren
r_int
)paren
op_star
l_int|2
op_star
id|graph-&gt;column_capacity
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Returns 1 if the commit will be printed in the graph output,&n; * and 0 otherwise.&n; */
DECL|function|graph_is_interesting
r_static
r_int
id|graph_is_interesting
c_func
(paren
r_struct
id|git_graph
op_star
id|graph
comma
r_struct
id|commit
op_star
id|commit
)paren
(brace
multiline_comment|/*&n;&t; * If revs-&gt;boundary is set, commits whose children have&n;&t; * been shown are always interesting, even if they have the&n;&t; * UNINTERESTING or TREESAME flags set.&n;&t; */
r_if
c_cond
(paren
id|graph-&gt;revs
op_logical_and
id|graph-&gt;revs-&gt;boundary
)paren
(brace
r_if
c_cond
(paren
id|commit-&gt;object.flags
op_amp
id|CHILD_SHOWN
)paren
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Uninteresting and pruned commits won&squot;t be printed&n;&t; */
r_return
(paren
id|commit-&gt;object.flags
op_amp
(paren
id|UNINTERESTING
op_or
id|TREESAME
)paren
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
)brace
DECL|function|next_interesting_parent
r_static
r_struct
id|commit_list
op_star
id|next_interesting_parent
c_func
(paren
r_struct
id|git_graph
op_star
id|graph
comma
r_struct
id|commit_list
op_star
id|orig
)paren
(brace
r_struct
id|commit_list
op_star
id|list
suffix:semicolon
multiline_comment|/*&n;&t; * If revs-&gt;first_parent_only is set, only the first&n;&t; * parent is interesting.  None of the others are.&n;&t; */
r_if
c_cond
(paren
id|graph-&gt;revs-&gt;first_parent_only
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Return the next interesting commit after orig&n;&t; */
r_for
c_loop
(paren
id|list
op_assign
id|orig-&gt;next
suffix:semicolon
id|list
suffix:semicolon
id|list
op_assign
id|list-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|graph_is_interesting
c_func
(paren
id|graph
comma
id|list-&gt;item
)paren
)paren
r_return
id|list
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|first_interesting_parent
r_static
r_struct
id|commit_list
op_star
id|first_interesting_parent
c_func
(paren
r_struct
id|git_graph
op_star
id|graph
)paren
(brace
r_struct
id|commit_list
op_star
id|parents
op_assign
id|graph-&gt;commit-&gt;parents
suffix:semicolon
multiline_comment|/*&n;&t; * If this commit has no parents, ignore it&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|parents
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * If the first parent is interesting, return it&n;&t; */
r_if
c_cond
(paren
id|graph_is_interesting
c_func
(paren
id|graph
comma
id|parents-&gt;item
)paren
)paren
r_return
id|parents
suffix:semicolon
multiline_comment|/*&n;&t; * Otherwise, call next_interesting_parent() to get&n;&t; * the next interesting parent&n;&t; */
r_return
id|next_interesting_parent
c_func
(paren
id|graph
comma
id|parents
)paren
suffix:semicolon
)brace
DECL|function|graph_insert_into_new_columns
r_static
r_void
id|graph_insert_into_new_columns
c_func
(paren
r_struct
id|git_graph
op_star
id|graph
comma
r_struct
id|commit
op_star
id|commit
comma
r_int
op_star
id|mapping_index
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * If the commit is already in the new_columns list, we don&squot;t need to&n;&t; * add it.  Just update the mapping correctly.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|graph-&gt;num_new_columns
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|graph-&gt;new_columns
(braket
id|i
)braket
dot
id|commit
op_eq
id|commit
)paren
(brace
id|graph-&gt;mapping
(braket
op_star
id|mapping_index
)braket
op_assign
id|i
suffix:semicolon
op_star
id|mapping_index
op_add_assign
l_int|2
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * This commit isn&squot;t already in new_columns.  Add it.&n;&t; */
id|graph-&gt;new_columns
(braket
id|graph-&gt;num_new_columns
)braket
dot
id|commit
op_assign
id|commit
suffix:semicolon
id|graph-&gt;mapping
(braket
op_star
id|mapping_index
)braket
op_assign
id|graph-&gt;num_new_columns
suffix:semicolon
op_star
id|mapping_index
op_add_assign
l_int|2
suffix:semicolon
id|graph-&gt;num_new_columns
op_increment
suffix:semicolon
)brace
DECL|function|graph_update_width
r_static
r_void
id|graph_update_width
c_func
(paren
r_struct
id|git_graph
op_star
id|graph
comma
r_int
id|is_commit_in_existing_columns
)paren
(brace
multiline_comment|/*&n;&t; * Compute the width needed to display the graph for this commit.&n;&t; * This is the maximum width needed for any row.  All other rows&n;&t; * will be padded to this width.&n;&t; *&n;&t; * Compute the number of columns in the widest row:&n;&t; * Count each existing column (graph-&gt;num_columns), and each new&n;&t; * column added by this commit.&n;&t; */
r_int
id|max_cols
op_assign
id|graph-&gt;num_columns
op_plus
id|graph-&gt;num_parents
suffix:semicolon
multiline_comment|/*&n;&t; * Even if the current commit has no parents to be printed, it&n;&t; * still takes up a column for itself.&n;&t; */
r_if
c_cond
(paren
id|graph-&gt;num_parents
OL
l_int|1
)paren
id|max_cols
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * We added a column for the the current commit as part of&n;&t; * graph-&gt;num_parents.  If the current commit was already in&n;&t; * graph-&gt;columns, then we have double counted it.&n;&t; */
r_if
c_cond
(paren
id|is_commit_in_existing_columns
)paren
id|max_cols
op_decrement
suffix:semicolon
multiline_comment|/*&n;&t; * Each column takes up 2 spaces&n;&t; */
id|graph-&gt;width
op_assign
id|max_cols
op_star
l_int|2
suffix:semicolon
)brace
DECL|function|graph_update_columns
r_static
r_void
id|graph_update_columns
c_func
(paren
r_struct
id|git_graph
op_star
id|graph
)paren
(brace
r_struct
id|commit_list
op_star
id|parent
suffix:semicolon
r_struct
id|column
op_star
id|tmp_columns
suffix:semicolon
r_int
id|max_new_columns
suffix:semicolon
r_int
id|mapping_idx
suffix:semicolon
r_int
id|i
comma
id|seen_this
comma
id|is_commit_in_columns
suffix:semicolon
multiline_comment|/*&n;&t; * Swap graph-&gt;columns with graph-&gt;new_columns&n;&t; * graph-&gt;columns contains the state for the previous commit,&n;&t; * and new_columns now contains the state for our commit.&n;&t; *&n;&t; * We&squot;ll re-use the old columns array as storage to compute the new&n;&t; * columns list for the commit after this one.&n;&t; */
id|tmp_columns
op_assign
id|graph-&gt;columns
suffix:semicolon
id|graph-&gt;columns
op_assign
id|graph-&gt;new_columns
suffix:semicolon
id|graph-&gt;num_columns
op_assign
id|graph-&gt;num_new_columns
suffix:semicolon
id|graph-&gt;new_columns
op_assign
id|tmp_columns
suffix:semicolon
id|graph-&gt;num_new_columns
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Now update new_columns and mapping with the information for the&n;&t; * commit after this one.&n;&t; *&n;&t; * First, make sure we have enough room.  At most, there will&n;&t; * be graph-&gt;num_columns + graph-&gt;num_parents columns for the next&n;&t; * commit.&n;&t; */
id|max_new_columns
op_assign
id|graph-&gt;num_columns
op_plus
id|graph-&gt;num_parents
suffix:semicolon
id|graph_ensure_capacity
c_func
(paren
id|graph
comma
id|max_new_columns
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Clear out graph-&gt;mapping&n;&t; */
id|graph-&gt;mapping_size
op_assign
l_int|2
op_star
id|max_new_columns
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|graph-&gt;mapping_size
suffix:semicolon
id|i
op_increment
)paren
id|graph-&gt;mapping
(braket
id|i
)braket
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Populate graph-&gt;new_columns and graph-&gt;mapping&n;&t; *&n;&t; * Some of the parents of this commit may already be in&n;&t; * graph-&gt;columns.  If so, graph-&gt;new_columns should only contain a&n;&t; * single entry for each such commit.  graph-&gt;mapping should&n;&t; * contain information about where each current branch line is&n;&t; * supposed to end up after the collapsing is performed.&n;&t; */
id|seen_this
op_assign
l_int|0
suffix:semicolon
id|mapping_idx
op_assign
l_int|0
suffix:semicolon
id|is_commit_in_columns
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|graph-&gt;num_columns
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|commit
op_star
id|col_commit
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|graph-&gt;num_columns
)paren
(brace
r_if
c_cond
(paren
id|seen_this
)paren
r_break
suffix:semicolon
id|is_commit_in_columns
op_assign
l_int|0
suffix:semicolon
id|col_commit
op_assign
id|graph-&gt;commit
suffix:semicolon
)brace
r_else
(brace
id|col_commit
op_assign
id|graph-&gt;columns
(braket
id|i
)braket
dot
id|commit
suffix:semicolon
)brace
r_if
c_cond
(paren
id|col_commit
op_eq
id|graph-&gt;commit
)paren
(brace
r_int
id|old_mapping_idx
op_assign
id|mapping_idx
suffix:semicolon
id|seen_this
op_assign
l_int|1
suffix:semicolon
id|graph-&gt;commit_index
op_assign
id|i
suffix:semicolon
r_for
c_loop
(paren
id|parent
op_assign
id|first_interesting_parent
c_func
(paren
id|graph
)paren
suffix:semicolon
id|parent
suffix:semicolon
id|parent
op_assign
id|next_interesting_parent
c_func
(paren
id|graph
comma
id|parent
)paren
)paren
(brace
id|graph_insert_into_new_columns
c_func
(paren
id|graph
comma
id|parent-&gt;item
comma
op_amp
id|mapping_idx
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * We always need to increment mapping_idx by at&n;&t;&t;&t; * least 2, even if it has no interesting parents.&n;&t;&t;&t; * The current commit always takes up at least 2&n;&t;&t;&t; * spaces.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|mapping_idx
op_eq
id|old_mapping_idx
)paren
id|mapping_idx
op_add_assign
l_int|2
suffix:semicolon
)brace
r_else
(brace
id|graph_insert_into_new_columns
c_func
(paren
id|graph
comma
id|col_commit
comma
op_amp
id|mapping_idx
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Shrink mapping_size to be the minimum necessary&n;&t; */
r_while
c_loop
(paren
id|graph-&gt;mapping_size
OG
l_int|1
op_logical_and
id|graph-&gt;mapping
(braket
id|graph-&gt;mapping_size
l_int|1
)braket
OL
l_int|0
)paren
id|graph-&gt;mapping_size
op_decrement
suffix:semicolon
multiline_comment|/*&n;&t; * Compute graph-&gt;width for this commit&n;&t; */
id|graph_update_width
c_func
(paren
id|graph
comma
id|is_commit_in_columns
)paren
suffix:semicolon
)brace
DECL|function|graph_update
r_void
id|graph_update
c_func
(paren
r_struct
id|git_graph
op_star
id|graph
comma
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_struct
id|commit_list
op_star
id|parent
suffix:semicolon
multiline_comment|/*&n;&t; * Set the new commit&n;&t; */
id|graph-&gt;commit
op_assign
id|commit
suffix:semicolon
multiline_comment|/*&n;&t; * Count how many interesting parents this commit has&n;&t; */
id|graph-&gt;num_parents
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|parent
op_assign
id|first_interesting_parent
c_func
(paren
id|graph
)paren
suffix:semicolon
id|parent
suffix:semicolon
id|parent
op_assign
id|next_interesting_parent
c_func
(paren
id|graph
comma
id|parent
)paren
)paren
(brace
id|graph-&gt;num_parents
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Store the old commit_index in prev_commit_index.&n;&t; * graph_update_columns() will update graph-&gt;commit_index for this&n;&t; * commit.&n;&t; */
id|graph-&gt;prev_commit_index
op_assign
id|graph-&gt;commit_index
suffix:semicolon
multiline_comment|/*&n;&t; * Call graph_update_columns() to update&n;&t; * columns, new_columns, and mapping.&n;&t; */
id|graph_update_columns
c_func
(paren
id|graph
)paren
suffix:semicolon
id|graph-&gt;expansion_row
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Update graph-&gt;state.&n;&t; * Note that we don&squot;t call graph_update_state() here, since&n;&t; * we don&squot;t want to update graph-&gt;prev_state.  No line for&n;&t; * graph-&gt;state was ever printed.&n;&t; *&n;&t; * If the previous commit didn&squot;t get to the GRAPH_PADDING state,&n;&t; * it never finished its output.  Goto GRAPH_SKIP, to print out&n;&t; * a line to indicate that portion of the graph is missing.&n;&t; *&n;&t; * If there are 3 or more parents, we may need to print extra rows&n;&t; * before the commit, to expand the branch lines around it and make&n;&t; * room for it.  We need to do this only if there is a branch row&n;&t; * (or more) to the right of this commit.&n;&t; *&n;&t; * If there are less than 3 parents, we can immediately print the&n;&t; * commit line.&n;&t; */
r_if
c_cond
(paren
id|graph-&gt;state
op_ne
id|GRAPH_PADDING
)paren
id|graph-&gt;state
op_assign
id|GRAPH_SKIP
suffix:semicolon
r_else
r_if
c_cond
(paren
id|graph-&gt;num_parents
op_ge
l_int|3
op_logical_and
id|graph-&gt;commit_index
OL
(paren
id|graph-&gt;num_columns
l_int|1
)paren
)paren
id|graph-&gt;state
op_assign
id|GRAPH_PRE_COMMIT
suffix:semicolon
r_else
id|graph-&gt;state
op_assign
id|GRAPH_COMMIT
suffix:semicolon
)brace
DECL|function|graph_is_mapping_correct
r_static
r_int
id|graph_is_mapping_correct
c_func
(paren
r_struct
id|git_graph
op_star
id|graph
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * The mapping is up to date if each entry is at its target,&n;&t; * or is 1 greater than its target.&n;&t; * (If it is 1 greater than the target, &squot;/&squot; will be printed, so it&n;&t; * will look correct on the next row.)&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|graph-&gt;mapping_size
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|target
op_assign
id|graph-&gt;mapping
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|target
OL
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|target
op_eq
(paren
id|i
op_div
l_int|2
)paren
)paren
r_continue
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|graph_pad_horizontally
r_static
r_void
id|graph_pad_horizontally
c_func
(paren
r_struct
id|git_graph
op_star
id|graph
comma
r_struct
id|strbuf
op_star
id|sb
)paren
(brace
multiline_comment|/*&n;&t; * Add additional spaces to the end of the strbuf, so that all&n;&t; * lines for a particular commit have the same width.&n;&t; *&n;&t; * This way, fields printed to the right of the graph will remain&n;&t; * aligned for the entire commit.&n;&t; */
r_int
id|extra
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;len
op_ge
id|graph-&gt;width
)paren
r_return
suffix:semicolon
id|extra
op_assign
id|graph-&gt;width
id|sb-&gt;len
suffix:semicolon
id|strbuf_addf
c_func
(paren
id|sb
comma
l_string|&quot;%*s&quot;
comma
(paren
r_int
)paren
id|extra
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
DECL|function|graph_output_padding_line
r_static
r_void
id|graph_output_padding_line
c_func
(paren
r_struct
id|git_graph
op_star
id|graph
comma
r_struct
id|strbuf
op_star
id|sb
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * We could conceivable be called with a NULL commit&n;&t; * if our caller has a bug, and invokes graph_next_line()&n;&t; * immediately after graph_init(), without first calling&n;&t; * graph_update().  Return without outputting anything in this&n;&t; * case.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|graph-&gt;commit
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * Output a padding row, that leaves all branch lines unchanged&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|graph-&gt;num_new_columns
suffix:semicolon
id|i
op_increment
)paren
(brace
id|strbuf_addstr
c_func
(paren
id|sb
comma
l_string|&quot;| &quot;
)paren
suffix:semicolon
)brace
id|graph_pad_horizontally
c_func
(paren
id|graph
comma
id|sb
)paren
suffix:semicolon
)brace
DECL|function|graph_output_skip_line
r_static
r_void
id|graph_output_skip_line
c_func
(paren
r_struct
id|git_graph
op_star
id|graph
comma
r_struct
id|strbuf
op_star
id|sb
)paren
(brace
multiline_comment|/*&n;&t; * Output an ellipsis to indicate that a portion&n;&t; * of the graph is missing.&n;&t; */
id|strbuf_addstr
c_func
(paren
id|sb
comma
l_string|&quot;...&quot;
)paren
suffix:semicolon
id|graph_pad_horizontally
c_func
(paren
id|graph
comma
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|graph-&gt;num_parents
op_ge
l_int|3
op_logical_and
id|graph-&gt;commit_index
OL
(paren
id|graph-&gt;num_columns
l_int|1
)paren
)paren
id|graph_update_state
c_func
(paren
id|graph
comma
id|GRAPH_PRE_COMMIT
)paren
suffix:semicolon
r_else
id|graph_update_state
c_func
(paren
id|graph
comma
id|GRAPH_COMMIT
)paren
suffix:semicolon
)brace
DECL|function|graph_output_pre_commit_line
r_static
r_void
id|graph_output_pre_commit_line
c_func
(paren
r_struct
id|git_graph
op_star
id|graph
comma
r_struct
id|strbuf
op_star
id|sb
)paren
(brace
r_int
id|num_expansion_rows
suffix:semicolon
r_int
id|i
comma
id|seen_this
suffix:semicolon
multiline_comment|/*&n;&t; * This function formats a row that increases the space around a commit&n;&t; * with multiple parents, to make room for it.  It should only be&n;&t; * called when there are 3 or more parents.&n;&t; *&n;&t; * We need 2 extra rows for every parent over 2.&n;&t; */
m_assert
(paren
id|graph-&gt;num_parents
op_ge
l_int|3
)paren
suffix:semicolon
id|num_expansion_rows
op_assign
(paren
id|graph-&gt;num_parents
l_int|2
)paren
op_star
l_int|2
suffix:semicolon
multiline_comment|/*&n;&t; * graph-&gt;expansion_row tracks the current expansion row we are on.&n;&t; * It should be in the range [0, num_expansion_rows - 1]&n;&t; */
m_assert
(paren
l_int|0
op_le
id|graph-&gt;expansion_row
op_logical_and
id|graph-&gt;expansion_row
OL
id|num_expansion_rows
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Output the row&n;&t; */
id|seen_this
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|graph-&gt;num_columns
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|column
op_star
id|col
op_assign
op_amp
id|graph-&gt;columns
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|col-&gt;commit
op_eq
id|graph-&gt;commit
)paren
(brace
id|seen_this
op_assign
l_int|1
suffix:semicolon
id|strbuf_addf
c_func
(paren
id|sb
comma
l_string|&quot;| %*s&quot;
comma
id|graph-&gt;expansion_row
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|seen_this
op_logical_and
(paren
id|graph-&gt;expansion_row
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * This is the first line of the pre-commit output.&n;&t;&t;&t; * If the previous commit was a merge commit and&n;&t;&t;&t; * ended in the GRAPH_POST_MERGE state, all branch&n;&t;&t;&t; * lines after graph-&gt;prev_commit_index were&n;&t;&t;&t; * printed as &quot;&bslash;&quot; on the previous line.  Continue&n;&t;&t;&t; * to print them as &quot;&bslash;&quot; on this line.  Otherwise,&n;&t;&t;&t; * print the branch lines as &quot;|&quot;.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|graph-&gt;prev_state
op_eq
id|GRAPH_POST_MERGE
op_logical_and
id|graph-&gt;prev_commit_index
OL
id|i
)paren
id|strbuf_addstr
c_func
(paren
id|sb
comma
l_string|&quot;&bslash;&bslash; &quot;
)paren
suffix:semicolon
r_else
id|strbuf_addstr
c_func
(paren
id|sb
comma
l_string|&quot;| &quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|seen_this
op_logical_and
(paren
id|graph-&gt;expansion_row
OG
l_int|0
)paren
)paren
(brace
id|strbuf_addstr
c_func
(paren
id|sb
comma
l_string|&quot;&bslash;&bslash; &quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|strbuf_addstr
c_func
(paren
id|sb
comma
l_string|&quot;| &quot;
)paren
suffix:semicolon
)brace
)brace
id|graph_pad_horizontally
c_func
(paren
id|graph
comma
id|sb
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Increment graph-&gt;expansion_row,&n;&t; * and move to state GRAPH_COMMIT if necessary&n;&t; */
id|graph-&gt;expansion_row
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|graph-&gt;expansion_row
op_ge
id|num_expansion_rows
)paren
id|graph_update_state
c_func
(paren
id|graph
comma
id|GRAPH_COMMIT
)paren
suffix:semicolon
)brace
DECL|function|graph_output_commit_char
r_static
r_void
id|graph_output_commit_char
c_func
(paren
r_struct
id|git_graph
op_star
id|graph
comma
r_struct
id|strbuf
op_star
id|sb
)paren
(brace
multiline_comment|/*&n;&t; * For boundary commits, print &squot;o&squot;&n;&t; * (We should only see boundary commits when revs-&gt;boundary is set.)&n;&t; */
r_if
c_cond
(paren
id|graph-&gt;commit-&gt;object.flags
op_amp
id|BOUNDARY
)paren
(brace
m_assert
(paren
id|graph-&gt;revs-&gt;boundary
)paren
suffix:semicolon
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot;o&squot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If revs-&gt;left_right is set, print &squot;&lt;&squot; for commits that&n;&t; * come from the left side, and &squot;&gt;&squot; for commits from the right&n;&t; * side.&n;&t; */
r_if
c_cond
(paren
id|graph-&gt;revs
op_logical_and
id|graph-&gt;revs-&gt;left_right
)paren
(brace
r_if
c_cond
(paren
id|graph-&gt;commit-&gt;object.flags
op_amp
id|SYMMETRIC_LEFT
)paren
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot;&lt;&squot;
)paren
suffix:semicolon
r_else
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot;&gt;&squot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Print &squot;*&squot; in all other cases&n;&t; */
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot;*&squot;
)paren
suffix:semicolon
)brace
DECL|function|graph_output_commit_line
r_void
id|graph_output_commit_line
c_func
(paren
r_struct
id|git_graph
op_star
id|graph
comma
r_struct
id|strbuf
op_star
id|sb
)paren
(brace
r_int
id|seen_this
op_assign
l_int|0
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
multiline_comment|/*&n;&t; * Output the row containing this commit&n;&t; * Iterate up to and including graph-&gt;num_columns,&n;&t; * since the current commit may not be in any of the existing&n;&t; * columns.  (This happens when the current commit doesn&squot;t have any&n;&t; * children that we have already processed.)&n;&t; */
id|seen_this
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|graph-&gt;num_columns
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|commit
op_star
id|col_commit
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|graph-&gt;num_columns
)paren
(brace
r_if
c_cond
(paren
id|seen_this
)paren
r_break
suffix:semicolon
id|col_commit
op_assign
id|graph-&gt;commit
suffix:semicolon
)brace
r_else
(brace
id|col_commit
op_assign
id|graph-&gt;columns
(braket
id|i
)braket
dot
id|commit
suffix:semicolon
)brace
r_if
c_cond
(paren
id|col_commit
op_eq
id|graph-&gt;commit
)paren
(brace
id|seen_this
op_assign
l_int|1
suffix:semicolon
id|graph_output_commit_char
c_func
(paren
id|graph
comma
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|graph-&gt;num_parents
OL
l_int|3
)paren
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
r_else
(brace
r_int
id|num_dashes
op_assign
(paren
(paren
id|graph-&gt;num_parents
l_int|2
)paren
op_star
l_int|2
)paren
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|num_dashes
suffix:semicolon
id|j
op_increment
)paren
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot;-&squot;
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
id|sb
comma
l_string|&quot;. &quot;
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|seen_this
op_logical_and
(paren
id|graph-&gt;num_parents
OG
l_int|2
)paren
)paren
(brace
id|strbuf_addstr
c_func
(paren
id|sb
comma
l_string|&quot;&bslash;&bslash; &quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|seen_this
op_logical_and
(paren
id|graph-&gt;num_parents
op_eq
l_int|2
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * This is a 2-way merge commit.&n;&t;&t;&t; * There is no GRAPH_PRE_COMMIT stage for 2-way&n;&t;&t;&t; * merges, so this is the first line of output&n;&t;&t;&t; * for this commit.  Check to see what the previous&n;&t;&t;&t; * line of output was.&n;&t;&t;&t; *&n;&t;&t;&t; * If it was GRAPH_POST_MERGE, the branch line&n;&t;&t;&t; * coming into this commit may have been &squot;&bslash;&squot;,&n;&t;&t;&t; * and not &squot;|&squot; or &squot;/&squot;.  If so, output the branch&n;&t;&t;&t; * line as &squot;&bslash;&squot; on this line, instead of &squot;|&squot;.  This&n;&t;&t;&t; * makes the output look nicer.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|graph-&gt;prev_state
op_eq
id|GRAPH_POST_MERGE
op_logical_and
id|graph-&gt;prev_commit_index
OL
id|i
)paren
id|strbuf_addstr
c_func
(paren
id|sb
comma
l_string|&quot;&bslash;&bslash; &quot;
)paren
suffix:semicolon
r_else
id|strbuf_addstr
c_func
(paren
id|sb
comma
l_string|&quot;| &quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|strbuf_addstr
c_func
(paren
id|sb
comma
l_string|&quot;| &quot;
)paren
suffix:semicolon
)brace
)brace
id|graph_pad_horizontally
c_func
(paren
id|graph
comma
id|sb
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Update graph-&gt;state&n;&t; */
r_if
c_cond
(paren
id|graph-&gt;num_parents
OG
l_int|1
)paren
id|graph_update_state
c_func
(paren
id|graph
comma
id|GRAPH_POST_MERGE
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|graph_is_mapping_correct
c_func
(paren
id|graph
)paren
)paren
id|graph_update_state
c_func
(paren
id|graph
comma
id|GRAPH_PADDING
)paren
suffix:semicolon
r_else
id|graph_update_state
c_func
(paren
id|graph
comma
id|GRAPH_COLLAPSING
)paren
suffix:semicolon
)brace
DECL|function|graph_output_post_merge_line
r_void
id|graph_output_post_merge_line
c_func
(paren
r_struct
id|git_graph
op_star
id|graph
comma
r_struct
id|strbuf
op_star
id|sb
)paren
(brace
r_int
id|seen_this
op_assign
l_int|0
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
multiline_comment|/*&n;&t; * Output the post-merge row&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|graph-&gt;num_columns
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|commit
op_star
id|col_commit
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|graph-&gt;num_columns
)paren
(brace
r_if
c_cond
(paren
id|seen_this
)paren
r_break
suffix:semicolon
id|col_commit
op_assign
id|graph-&gt;commit
suffix:semicolon
)brace
r_else
(brace
id|col_commit
op_assign
id|graph-&gt;columns
(braket
id|i
)braket
dot
id|commit
suffix:semicolon
)brace
r_if
c_cond
(paren
id|col_commit
op_eq
id|graph-&gt;commit
)paren
(brace
id|seen_this
op_assign
l_int|1
suffix:semicolon
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot;|&squot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|graph-&gt;num_parents
l_int|1
suffix:semicolon
id|j
op_increment
)paren
id|strbuf_addstr
c_func
(paren
id|sb
comma
l_string|&quot;&bslash;&bslash; &quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|seen_this
)paren
(brace
id|strbuf_addstr
c_func
(paren
id|sb
comma
l_string|&quot;&bslash;&bslash; &quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|strbuf_addstr
c_func
(paren
id|sb
comma
l_string|&quot;| &quot;
)paren
suffix:semicolon
)brace
)brace
id|graph_pad_horizontally
c_func
(paren
id|graph
comma
id|sb
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Update graph-&gt;state&n;&t; */
r_if
c_cond
(paren
id|graph_is_mapping_correct
c_func
(paren
id|graph
)paren
)paren
id|graph_update_state
c_func
(paren
id|graph
comma
id|GRAPH_PADDING
)paren
suffix:semicolon
r_else
id|graph_update_state
c_func
(paren
id|graph
comma
id|GRAPH_COLLAPSING
)paren
suffix:semicolon
)brace
DECL|function|graph_output_collapsing_line
r_void
id|graph_output_collapsing_line
c_func
(paren
r_struct
id|git_graph
op_star
id|graph
comma
r_struct
id|strbuf
op_star
id|sb
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
op_star
id|tmp_mapping
suffix:semicolon
multiline_comment|/*&n;&t; * Clear out the new_mapping array&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|graph-&gt;mapping_size
suffix:semicolon
id|i
op_increment
)paren
id|graph-&gt;new_mapping
(braket
id|i
)braket
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|graph-&gt;mapping_size
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|target
op_assign
id|graph-&gt;mapping
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|target
OL
l_int|0
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Since update_columns() always inserts the leftmost&n;&t;&t; * column first, each branch&squot;s target location should&n;&t;&t; * always be either its current location or to the left of&n;&t;&t; * its current location.&n;&t;&t; *&n;&t;&t; * We never have to move branches to the right.  This makes&n;&t;&t; * the graph much more legible, since whenever branches&n;&t;&t; * cross, only one is moving directions.&n;&t;&t; */
m_assert
(paren
id|target
op_star
l_int|2
op_le
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|target
op_star
l_int|2
op_eq
id|i
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * This column is already in the&n;&t;&t;&t; * correct place&n;&t;&t;&t; */
m_assert
(paren
id|graph-&gt;new_mapping
(braket
id|i
)braket
op_eq
l_int|1
)paren
suffix:semicolon
id|graph-&gt;new_mapping
(braket
id|i
)braket
op_assign
id|target
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|graph-&gt;new_mapping
(braket
id|i
l_int|1
)braket
OL
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Nothing is to the left.&n;&t;&t;&t; * Move to the left by one&n;&t;&t;&t; */
id|graph-&gt;new_mapping
(braket
id|i
l_int|1
)braket
op_assign
id|target
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|graph-&gt;new_mapping
(braket
id|i
l_int|1
)braket
op_eq
id|target
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * There is a branch line to our left&n;&t;&t;&t; * already, and it is our target.  We&n;&t;&t;&t; * combine with this line, since we share&n;&t;&t;&t; * the same parent commit.&n;&t;&t;&t; *&n;&t;&t;&t; * We don&squot;t have to add anything to the&n;&t;&t;&t; * output or new_mapping, since the&n;&t;&t;&t; * existing branch line has already taken&n;&t;&t;&t; * care of it.&n;&t;&t;&t; */
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * There is a branch line to our left,&n;&t;&t;&t; * but it isn&squot;t our target.  We need to&n;&t;&t;&t; * cross over it.&n;&t;&t;&t; *&n;&t;&t;&t; * The space just to the left of this&n;&t;&t;&t; * branch should always be empty.&n;&t;&t;&t; */
m_assert
(paren
id|graph-&gt;new_mapping
(braket
id|i
l_int|1
)braket
OG
id|target
)paren
suffix:semicolon
m_assert
(paren
id|graph-&gt;new_mapping
(braket
id|i
l_int|2
)braket
OL
l_int|0
)paren
suffix:semicolon
id|graph-&gt;new_mapping
(braket
id|i
l_int|2
)braket
op_assign
id|target
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * The new mapping may be 1 smaller than the old mapping&n;&t; */
r_if
c_cond
(paren
id|graph-&gt;new_mapping
(braket
id|graph-&gt;mapping_size
l_int|1
)braket
OL
l_int|0
)paren
id|graph-&gt;mapping_size
op_decrement
suffix:semicolon
multiline_comment|/*&n;&t; * Output out a line based on the new mapping info&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|graph-&gt;mapping_size
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|target
op_assign
id|graph-&gt;new_mapping
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|target
OL
l_int|0
)paren
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|target
op_star
l_int|2
op_eq
id|i
)paren
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot;|&squot;
)paren
suffix:semicolon
r_else
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
)brace
id|graph_pad_horizontally
c_func
(paren
id|graph
comma
id|sb
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Swap mapping and new_mapping&n;&t; */
id|tmp_mapping
op_assign
id|graph-&gt;mapping
suffix:semicolon
id|graph-&gt;mapping
op_assign
id|graph-&gt;new_mapping
suffix:semicolon
id|graph-&gt;new_mapping
op_assign
id|tmp_mapping
suffix:semicolon
multiline_comment|/*&n;&t; * If graph-&gt;mapping indicates that all of the branch lines&n;&t; * are already in the correct positions, we are done.&n;&t; * Otherwise, we need to collapse some branch lines together.&n;&t; */
r_if
c_cond
(paren
id|graph_is_mapping_correct
c_func
(paren
id|graph
)paren
)paren
id|graph_update_state
c_func
(paren
id|graph
comma
id|GRAPH_PADDING
)paren
suffix:semicolon
)brace
DECL|function|graph_next_line
r_int
id|graph_next_line
c_func
(paren
r_struct
id|git_graph
op_star
id|graph
comma
r_struct
id|strbuf
op_star
id|sb
)paren
(brace
r_switch
c_cond
(paren
id|graph-&gt;state
)paren
(brace
r_case
id|GRAPH_PADDING
suffix:colon
id|graph_output_padding_line
c_func
(paren
id|graph
comma
id|sb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|GRAPH_SKIP
suffix:colon
id|graph_output_skip_line
c_func
(paren
id|graph
comma
id|sb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|GRAPH_PRE_COMMIT
suffix:colon
id|graph_output_pre_commit_line
c_func
(paren
id|graph
comma
id|sb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|GRAPH_COMMIT
suffix:colon
id|graph_output_commit_line
c_func
(paren
id|graph
comma
id|sb
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_case
id|GRAPH_POST_MERGE
suffix:colon
id|graph_output_post_merge_line
c_func
(paren
id|graph
comma
id|sb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|GRAPH_COLLAPSING
suffix:colon
id|graph_output_collapsing_line
c_func
(paren
id|graph
comma
id|sb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
m_assert
(paren
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|graph_padding_line
r_void
id|graph_padding_line
c_func
(paren
r_struct
id|git_graph
op_star
id|graph
comma
r_struct
id|strbuf
op_star
id|sb
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_if
c_cond
(paren
id|graph-&gt;state
op_ne
id|GRAPH_COMMIT
)paren
(brace
id|graph_next_line
c_func
(paren
id|graph
comma
id|sb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Output the row containing this commit&n;&t; * Iterate up to and including graph-&gt;num_columns,&n;&t; * since the current commit may not be in any of the existing&n;&t; * columns.  (This happens when the current commit doesn&squot;t have any&n;&t; * children that we have already processed.)&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|graph-&gt;num_columns
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|commit
op_star
id|col_commit
op_assign
id|graph-&gt;columns
(braket
id|i
)braket
dot
id|commit
suffix:semicolon
r_if
c_cond
(paren
id|col_commit
op_eq
id|graph-&gt;commit
)paren
(brace
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot;|&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|graph-&gt;num_parents
OL
l_int|3
)paren
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
r_else
(brace
r_int
id|num_spaces
op_assign
(paren
(paren
id|graph-&gt;num_parents
l_int|2
)paren
op_star
l_int|2
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|num_spaces
suffix:semicolon
id|j
op_increment
)paren
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|strbuf_addstr
c_func
(paren
id|sb
comma
l_string|&quot;| &quot;
)paren
suffix:semicolon
)brace
)brace
id|graph_pad_horizontally
c_func
(paren
id|graph
comma
id|sb
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Update graph-&gt;prev_state since we have output a padding line&n;&t; */
id|graph-&gt;prev_state
op_assign
id|GRAPH_PADDING
suffix:semicolon
)brace
DECL|function|graph_is_commit_finished
r_int
id|graph_is_commit_finished
c_func
(paren
r_struct
id|git_graph
r_const
op_star
id|graph
)paren
(brace
r_return
(paren
id|graph-&gt;state
op_eq
id|GRAPH_PADDING
)paren
suffix:semicolon
)brace
DECL|function|graph_show_commit
r_void
id|graph_show_commit
c_func
(paren
r_struct
id|git_graph
op_star
id|graph
)paren
(brace
r_struct
id|strbuf
id|msgbuf
suffix:semicolon
r_int
id|shown_commit_line
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|graph
)paren
r_return
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|msgbuf
comma
l_int|0
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|shown_commit_line
)paren
(brace
id|shown_commit_line
op_assign
id|graph_next_line
c_func
(paren
id|graph
comma
op_amp
id|msgbuf
)paren
suffix:semicolon
id|fwrite
c_func
(paren
id|msgbuf.buf
comma
r_sizeof
(paren
r_char
)paren
comma
id|msgbuf.len
comma
id|stdout
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|shown_commit_line
)paren
id|putchar
c_func
(paren
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|strbuf_setlen
c_func
(paren
op_amp
id|msgbuf
comma
l_int|0
)paren
suffix:semicolon
)brace
id|strbuf_release
c_func
(paren
op_amp
id|msgbuf
)paren
suffix:semicolon
)brace
DECL|function|graph_show_oneline
r_void
id|graph_show_oneline
c_func
(paren
r_struct
id|git_graph
op_star
id|graph
)paren
(brace
r_struct
id|strbuf
id|msgbuf
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|graph
)paren
r_return
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|msgbuf
comma
l_int|0
)paren
suffix:semicolon
id|graph_next_line
c_func
(paren
id|graph
comma
op_amp
id|msgbuf
)paren
suffix:semicolon
id|fwrite
c_func
(paren
id|msgbuf.buf
comma
r_sizeof
(paren
r_char
)paren
comma
id|msgbuf.len
comma
id|stdout
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|msgbuf
)paren
suffix:semicolon
)brace
DECL|function|graph_show_padding
r_void
id|graph_show_padding
c_func
(paren
r_struct
id|git_graph
op_star
id|graph
)paren
(brace
r_struct
id|strbuf
id|msgbuf
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|graph
)paren
r_return
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|msgbuf
comma
l_int|0
)paren
suffix:semicolon
id|graph_padding_line
c_func
(paren
id|graph
comma
op_amp
id|msgbuf
)paren
suffix:semicolon
id|fwrite
c_func
(paren
id|msgbuf.buf
comma
r_sizeof
(paren
r_char
)paren
comma
id|msgbuf.len
comma
id|stdout
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|msgbuf
)paren
suffix:semicolon
)brace
DECL|function|graph_show_remainder
r_int
id|graph_show_remainder
c_func
(paren
r_struct
id|git_graph
op_star
id|graph
)paren
(brace
r_struct
id|strbuf
id|msgbuf
suffix:semicolon
r_int
id|shown
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|graph
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|graph_is_commit_finished
c_func
(paren
id|graph
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|msgbuf
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|graph_next_line
c_func
(paren
id|graph
comma
op_amp
id|msgbuf
)paren
suffix:semicolon
id|fwrite
c_func
(paren
id|msgbuf.buf
comma
r_sizeof
(paren
r_char
)paren
comma
id|msgbuf.len
comma
id|stdout
)paren
suffix:semicolon
id|strbuf_setlen
c_func
(paren
op_amp
id|msgbuf
comma
l_int|0
)paren
suffix:semicolon
id|shown
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|graph_is_commit_finished
c_func
(paren
id|graph
)paren
)paren
id|putchar
c_func
(paren
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_else
r_break
suffix:semicolon
)brace
id|strbuf_release
c_func
(paren
op_amp
id|msgbuf
)paren
suffix:semicolon
r_return
id|shown
suffix:semicolon
)brace
DECL|function|graph_show_strbuf
r_void
id|graph_show_strbuf
c_func
(paren
r_struct
id|git_graph
op_star
id|graph
comma
r_struct
id|strbuf
r_const
op_star
id|sb
)paren
(brace
r_char
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|graph
)paren
(brace
id|fwrite
c_func
(paren
id|sb-&gt;buf
comma
r_sizeof
(paren
r_char
)paren
comma
id|sb-&gt;len
comma
id|stdout
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Print the strbuf line by line,&n;&t; * and display the graph info before each line but the first.&n;&t; */
id|p
op_assign
id|sb-&gt;buf
suffix:semicolon
r_while
c_loop
(paren
id|p
)paren
(brace
r_int
id|len
suffix:semicolon
r_char
op_star
id|next_p
op_assign
id|strchr
c_func
(paren
id|p
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|next_p
)paren
(brace
id|next_p
op_increment
suffix:semicolon
id|len
op_assign
id|next_p
id|p
suffix:semicolon
)brace
r_else
(brace
id|len
op_assign
(paren
id|sb-&gt;buf
op_plus
id|sb-&gt;len
)paren
id|p
suffix:semicolon
)brace
id|fwrite
c_func
(paren
id|p
comma
r_sizeof
(paren
r_char
)paren
comma
id|len
comma
id|stdout
)paren
suffix:semicolon
r_if
c_cond
(paren
id|next_p
op_logical_and
op_star
id|next_p
op_ne
l_char|&squot;&bslash;0&squot;
)paren
id|graph_show_oneline
c_func
(paren
id|graph
)paren
suffix:semicolon
id|p
op_assign
id|next_p
suffix:semicolon
)brace
)brace
DECL|function|graph_show_commit_msg
r_void
id|graph_show_commit_msg
c_func
(paren
r_struct
id|git_graph
op_star
id|graph
comma
r_struct
id|strbuf
r_const
op_star
id|sb
)paren
(brace
r_int
id|newline_terminated
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|graph
)paren
(brace
multiline_comment|/*&n;&t;&t; * If there&squot;s no graph, just print the message buffer.&n;&t;&t; *&n;&t;&t; * The message buffer for CMIT_FMT_ONELINE and&n;&t;&t; * CMIT_FMT_USERFORMAT are already missing a terminating&n;&t;&t; * newline.  All of the other formats should have it.&n;&t;&t; */
id|fwrite
c_func
(paren
id|sb-&gt;buf
comma
r_sizeof
(paren
r_char
)paren
comma
id|sb-&gt;len
comma
id|stdout
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|newline_terminated
op_assign
(paren
id|sb-&gt;len
op_logical_and
id|sb-&gt;buf
(braket
id|sb-&gt;len
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Show the commit message&n;&t; */
id|graph_show_strbuf
c_func
(paren
id|graph
comma
id|sb
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If there is more output needed for this commit, show it now&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|graph_is_commit_finished
c_func
(paren
id|graph
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * If sb doesn&squot;t have a terminating newline, print one now,&n;&t;&t; * so we can start the remainder of the graph output on a&n;&t;&t; * new line.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|newline_terminated
)paren
id|putchar
c_func
(paren
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|graph_show_remainder
c_func
(paren
id|graph
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If sb ends with a newline, our output should too.&n;&t;&t; */
r_if
c_cond
(paren
id|newline_terminated
)paren
id|putchar
c_func
(paren
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
)brace
eof
