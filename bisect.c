macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;commit.h&quot;
macro_line|#include &quot;diff.h&quot;
macro_line|#include &quot;revision.h&quot;
macro_line|#include &quot;refs.h&quot;
macro_line|#include &quot;list-objects.h&quot;
macro_line|#include &quot;quote.h&quot;
macro_line|#include &quot;sha1-lookup.h&quot;
macro_line|#include &quot;run-command.h&quot;
macro_line|#include &quot;log-tree.h&quot;
macro_line|#include &quot;bisect.h&quot;
macro_line|#include &quot;sha1-array.h&quot;
DECL|variable|good_revs
r_static
r_struct
id|sha1_array
id|good_revs
suffix:semicolon
DECL|variable|skipped_revs
r_static
r_struct
id|sha1_array
id|skipped_revs
suffix:semicolon
DECL|variable|current_bad_sha1
r_static
r_const
r_int
r_char
op_star
id|current_bad_sha1
suffix:semicolon
DECL|struct|argv_array
r_struct
id|argv_array
(brace
DECL|member|argv
r_const
r_char
op_star
op_star
id|argv
suffix:semicolon
DECL|member|argv_nr
r_int
id|argv_nr
suffix:semicolon
DECL|member|argv_alloc
r_int
id|argv_alloc
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|argv_checkout
r_static
r_const
r_char
op_star
id|argv_checkout
(braket
)braket
op_assign
(brace
l_string|&quot;checkout&quot;
comma
l_string|&quot;-q&quot;
comma
l_int|NULL
comma
l_string|&quot;--&quot;
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|argv_show_branch
r_static
r_const
r_char
op_star
id|argv_show_branch
(braket
)braket
op_assign
(brace
l_string|&quot;show-branch&quot;
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|argv_update_ref
r_static
r_const
r_char
op_star
id|argv_update_ref
(braket
)braket
op_assign
(brace
l_string|&quot;update-ref&quot;
comma
l_string|&quot;--no-deref&quot;
comma
l_string|&quot;BISECT_HEAD&quot;
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
multiline_comment|/* bits #0-15 in revision.h */
DECL|macro|COUNTED
mdefine_line|#define COUNTED&t;&t;(1u&lt;&lt;16)
multiline_comment|/*&n; * This is a truly stupid algorithm, but it&squot;s only&n; * used for bisection, and we just don&squot;t care enough.&n; *&n; * We care just barely enough to avoid recursing for&n; * non-merge entries.&n; */
DECL|function|count_distance
r_static
r_int
id|count_distance
c_func
(paren
r_struct
id|commit_list
op_star
id|entry
)paren
(brace
r_int
id|nr
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|entry
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
id|entry-&gt;item
suffix:semicolon
r_struct
id|commit_list
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|commit-&gt;object.flags
op_amp
(paren
id|UNINTERESTING
op_or
id|COUNTED
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|commit-&gt;object.flags
op_amp
id|TREESAME
)paren
)paren
id|nr
op_increment
suffix:semicolon
id|commit-&gt;object.flags
op_or_assign
id|COUNTED
suffix:semicolon
id|p
op_assign
id|commit-&gt;parents
suffix:semicolon
id|entry
op_assign
id|p
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
(brace
id|p
op_assign
id|p-&gt;next
suffix:semicolon
r_while
c_loop
(paren
id|p
)paren
(brace
id|nr
op_add_assign
id|count_distance
c_func
(paren
id|p
)paren
suffix:semicolon
id|p
op_assign
id|p-&gt;next
suffix:semicolon
)brace
)brace
)brace
r_return
id|nr
suffix:semicolon
)brace
DECL|function|clear_distance
r_static
r_void
id|clear_distance
c_func
(paren
r_struct
id|commit_list
op_star
id|list
)paren
(brace
r_while
c_loop
(paren
id|list
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
id|list-&gt;item
suffix:semicolon
id|commit-&gt;object.flags
op_and_assign
op_complement
id|COUNTED
suffix:semicolon
id|list
op_assign
id|list-&gt;next
suffix:semicolon
)brace
)brace
DECL|macro|DEBUG_BISECT
mdefine_line|#define DEBUG_BISECT 0
DECL|function|weight
r_static
r_inline
r_int
id|weight
c_func
(paren
r_struct
id|commit_list
op_star
id|elem
)paren
(brace
r_return
op_star
(paren
(paren
r_int
op_star
)paren
(paren
id|elem-&gt;item-&gt;util
)paren
)paren
suffix:semicolon
)brace
DECL|function|weight_set
r_static
r_inline
r_void
id|weight_set
c_func
(paren
r_struct
id|commit_list
op_star
id|elem
comma
r_int
id|weight
)paren
(brace
op_star
(paren
(paren
r_int
op_star
)paren
(paren
id|elem-&gt;item-&gt;util
)paren
)paren
op_assign
id|weight
suffix:semicolon
)brace
DECL|function|count_interesting_parents
r_static
r_int
id|count_interesting_parents
c_func
(paren
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_struct
id|commit_list
op_star
id|p
suffix:semicolon
r_int
id|count
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|0
comma
id|p
op_assign
id|commit-&gt;parents
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;item-&gt;object.flags
op_amp
id|UNINTERESTING
)paren
r_continue
suffix:semicolon
id|count
op_increment
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
DECL|function|halfway
r_static
r_inline
r_int
id|halfway
c_func
(paren
r_struct
id|commit_list
op_star
id|p
comma
r_int
id|nr
)paren
(brace
multiline_comment|/*&n;&t; * Don&squot;t short-cut something we are not going to return!&n;&t; */
r_if
c_cond
(paren
id|p-&gt;item-&gt;object.flags
op_amp
id|TREESAME
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_BISECT
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * 2 and 3 are halfway of 5.&n;&t; * 3 is halfway of 6 but 2 and 4 are not.&n;&t; */
r_switch
c_cond
(paren
l_int|2
op_star
id|weight
c_func
(paren
id|p
)paren
id|nr
)paren
(brace
r_case
l_int|1
suffix:colon
r_case
l_int|0
suffix:colon
r_case
l_int|1
suffix:colon
r_return
l_int|1
suffix:semicolon
r_default
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#if !DEBUG_BISECT
DECL|macro|show_list
mdefine_line|#define show_list(a,b,c,d) do { ; } while (0)
macro_line|#else
DECL|function|show_list
r_static
r_void
id|show_list
c_func
(paren
r_const
r_char
op_star
id|debug
comma
r_int
id|counted
comma
r_int
id|nr
comma
r_struct
id|commit_list
op_star
id|list
)paren
(brace
r_struct
id|commit_list
op_star
id|p
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s (%d/%d)&bslash;n&quot;
comma
id|debug
comma
id|counted
comma
id|nr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|list
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_struct
id|commit_list
op_star
id|pp
suffix:semicolon
r_struct
id|commit
op_star
id|commit
op_assign
id|p-&gt;item
suffix:semicolon
r_int
id|flags
op_assign
id|commit-&gt;object.flags
suffix:semicolon
r_enum
id|object_type
id|type
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_char
op_star
id|buf
op_assign
id|read_sha1_file
c_func
(paren
id|commit-&gt;object.sha1
comma
op_amp
id|type
comma
op_amp
id|size
)paren
suffix:semicolon
r_const
r_char
op_star
id|subject_start
suffix:semicolon
r_int
id|subject_len
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%c%c%c &quot;
comma
(paren
id|flags
op_amp
id|TREESAME
)paren
ques
c_cond
l_char|&squot; &squot;
suffix:colon
l_char|&squot;T&squot;
comma
(paren
id|flags
op_amp
id|UNINTERESTING
)paren
ques
c_cond
l_char|&squot;U&squot;
suffix:colon
l_char|&squot; &squot;
comma
(paren
id|flags
op_amp
id|COUNTED
)paren
ques
c_cond
l_char|&squot;C&squot;
suffix:colon
l_char|&squot; &squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|commit-&gt;util
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%3d&quot;
comma
id|weight
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
r_else
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;---&quot;
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot; %.*s&quot;
comma
l_int|8
comma
id|sha1_to_hex
c_func
(paren
id|commit-&gt;object.sha1
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pp
op_assign
id|commit-&gt;parents
suffix:semicolon
id|pp
suffix:semicolon
id|pp
op_assign
id|pp-&gt;next
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot; %.*s&quot;
comma
l_int|8
comma
id|sha1_to_hex
c_func
(paren
id|pp-&gt;item-&gt;object.sha1
)paren
)paren
suffix:semicolon
id|subject_len
op_assign
id|find_commit_subject
c_func
(paren
id|buf
comma
op_amp
id|subject_start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|subject_len
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot; %.*s&quot;
comma
id|subject_len
comma
id|subject_start
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* DEBUG_BISECT */
DECL|function|best_bisection
r_static
r_struct
id|commit_list
op_star
id|best_bisection
c_func
(paren
r_struct
id|commit_list
op_star
id|list
comma
r_int
id|nr
)paren
(brace
r_struct
id|commit_list
op_star
id|p
comma
op_star
id|best
suffix:semicolon
r_int
id|best_distance
op_assign
l_int|1
suffix:semicolon
id|best
op_assign
id|list
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|list
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_int
id|distance
suffix:semicolon
r_int
id|flags
op_assign
id|p-&gt;item-&gt;object.flags
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|TREESAME
)paren
r_continue
suffix:semicolon
id|distance
op_assign
id|weight
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr
id|distance
OL
id|distance
)paren
id|distance
op_assign
id|nr
id|distance
suffix:semicolon
r_if
c_cond
(paren
id|distance
OG
id|best_distance
)paren
(brace
id|best
op_assign
id|p
suffix:semicolon
id|best_distance
op_assign
id|distance
suffix:semicolon
)brace
)brace
r_return
id|best
suffix:semicolon
)brace
DECL|struct|commit_dist
r_struct
id|commit_dist
(brace
DECL|member|commit
r_struct
id|commit
op_star
id|commit
suffix:semicolon
DECL|member|distance
r_int
id|distance
suffix:semicolon
)brace
suffix:semicolon
DECL|function|compare_commit_dist
r_static
r_int
id|compare_commit_dist
c_func
(paren
r_const
r_void
op_star
id|a_
comma
r_const
r_void
op_star
id|b_
)paren
(brace
r_struct
id|commit_dist
op_star
id|a
comma
op_star
id|b
suffix:semicolon
id|a
op_assign
(paren
r_struct
id|commit_dist
op_star
)paren
id|a_
suffix:semicolon
id|b
op_assign
(paren
r_struct
id|commit_dist
op_star
)paren
id|b_
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;distance
op_ne
id|b-&gt;distance
)paren
r_return
id|b-&gt;distance
id|a-&gt;distance
suffix:semicolon
multiline_comment|/* desc sort */
r_return
id|hashcmp
c_func
(paren
id|a-&gt;commit-&gt;object.sha1
comma
id|b-&gt;commit-&gt;object.sha1
)paren
suffix:semicolon
)brace
DECL|function|best_bisection_sorted
r_static
r_struct
id|commit_list
op_star
id|best_bisection_sorted
c_func
(paren
r_struct
id|commit_list
op_star
id|list
comma
r_int
id|nr
)paren
(brace
r_struct
id|commit_list
op_star
id|p
suffix:semicolon
r_struct
id|commit_dist
op_star
id|array
op_assign
id|xcalloc
c_func
(paren
id|nr
comma
r_sizeof
(paren
op_star
id|array
)paren
)paren
suffix:semicolon
r_int
id|cnt
comma
id|i
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|list
comma
id|cnt
op_assign
l_int|0
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_int
id|distance
suffix:semicolon
r_int
id|flags
op_assign
id|p-&gt;item-&gt;object.flags
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|TREESAME
)paren
r_continue
suffix:semicolon
id|distance
op_assign
id|weight
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr
id|distance
OL
id|distance
)paren
id|distance
op_assign
id|nr
id|distance
suffix:semicolon
id|array
(braket
id|cnt
)braket
dot
id|commit
op_assign
id|p-&gt;item
suffix:semicolon
id|array
(braket
id|cnt
)braket
dot
id|distance
op_assign
id|distance
suffix:semicolon
id|cnt
op_increment
suffix:semicolon
)brace
id|qsort
c_func
(paren
id|array
comma
id|cnt
comma
r_sizeof
(paren
op_star
id|array
)paren
comma
id|compare_commit_dist
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|list
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|name_decoration
op_star
id|r
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|r
)paren
op_plus
l_int|100
)paren
suffix:semicolon
r_struct
id|object
op_star
id|obj
op_assign
op_amp
(paren
id|array
(braket
id|i
)braket
dot
id|commit-&gt;object
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|r-&gt;name
comma
l_string|&quot;dist=%d&quot;
comma
id|array
(braket
id|i
)braket
dot
id|distance
)paren
suffix:semicolon
id|r-&gt;next
op_assign
id|add_decoration
c_func
(paren
op_amp
id|name_decoration
comma
id|obj
comma
id|r
)paren
suffix:semicolon
id|p-&gt;item
op_assign
id|array
(braket
id|i
)braket
dot
id|commit
suffix:semicolon
id|p
op_assign
id|p-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p
)paren
id|p-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|free
c_func
(paren
id|array
)paren
suffix:semicolon
r_return
id|list
suffix:semicolon
)brace
multiline_comment|/*&n; * zero or positive weight is the number of interesting commits it can&n; * reach, including itself.  Especially, weight = 0 means it does not&n; * reach any tree-changing commits (e.g. just above uninteresting one&n; * but traversal is with pathspec).&n; *&n; * weight = -1 means it has one parent and its distance is yet to&n; * be computed.&n; *&n; * weight = -2 means it has more than one parent and its distance is&n; * unknown.  After running count_distance() first, they will get zero&n; * or positive distance.&n; */
DECL|function|do_find_bisection
r_static
r_struct
id|commit_list
op_star
id|do_find_bisection
c_func
(paren
r_struct
id|commit_list
op_star
id|list
comma
r_int
id|nr
comma
r_int
op_star
id|weights
comma
r_int
id|find_all
)paren
(brace
r_int
id|n
comma
id|counted
suffix:semicolon
r_struct
id|commit_list
op_star
id|p
suffix:semicolon
id|counted
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
comma
id|p
op_assign
id|list
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
id|p-&gt;item
suffix:semicolon
r_int
id|flags
op_assign
id|commit-&gt;object.flags
suffix:semicolon
id|p-&gt;item-&gt;util
op_assign
op_amp
id|weights
(braket
id|n
op_increment
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|count_interesting_parents
c_func
(paren
id|commit
)paren
)paren
(brace
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|TREESAME
)paren
)paren
(brace
id|weight_set
c_func
(paren
id|p
comma
l_int|1
)paren
suffix:semicolon
id|counted
op_increment
suffix:semicolon
id|show_list
c_func
(paren
l_string|&quot;bisection 2 count one&quot;
comma
id|counted
comma
id|nr
comma
id|list
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * otherwise, it is known not to reach any&n;&t;&t;&t; * tree-changing commit and gets weight 0.&n;&t;&t;&t; */
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|weight_set
c_func
(paren
id|p
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|weight_set
c_func
(paren
id|p
comma
l_int|2
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|show_list
c_func
(paren
l_string|&quot;bisection 2 initialize&quot;
comma
id|counted
comma
id|nr
comma
id|list
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If you have only one parent in the resulting set&n;&t; * then you can reach one commit more than that parent&n;&t; * can reach.  So we do not have to run the expensive&n;&t; * count_distance() for single strand of pearls.&n;&t; *&n;&t; * However, if you have more than one parents, you cannot&n;&t; * just add their distance and one for yourself, since&n;&t; * they usually reach the same ancestor and you would&n;&t; * end up counting them twice that way.&n;&t; *&n;&t; * So we will first count distance of merges the usual&n;&t; * way, and then fill the blanks using cheaper algorithm.&n;&t; */
r_for
c_loop
(paren
id|p
op_assign
id|list
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;item-&gt;object.flags
op_amp
id|UNINTERESTING
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|weight
c_func
(paren
id|p
)paren
op_ne
l_int|2
)paren
r_continue
suffix:semicolon
id|weight_set
c_func
(paren
id|p
comma
id|count_distance
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
id|clear_distance
c_func
(paren
id|list
)paren
suffix:semicolon
multiline_comment|/* Does it happen to be at exactly half-way? */
r_if
c_cond
(paren
op_logical_neg
id|find_all
op_logical_and
id|halfway
c_func
(paren
id|p
comma
id|nr
)paren
)paren
r_return
id|p
suffix:semicolon
id|counted
op_increment
suffix:semicolon
)brace
id|show_list
c_func
(paren
l_string|&quot;bisection 2 count_distance&quot;
comma
id|counted
comma
id|nr
comma
id|list
)paren
suffix:semicolon
r_while
c_loop
(paren
id|counted
OL
id|nr
)paren
(brace
r_for
c_loop
(paren
id|p
op_assign
id|list
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_struct
id|commit_list
op_star
id|q
suffix:semicolon
r_int
id|flags
op_assign
id|p-&gt;item-&gt;object.flags
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_le
id|weight
c_func
(paren
id|p
)paren
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|q
op_assign
id|p-&gt;item-&gt;parents
suffix:semicolon
id|q
suffix:semicolon
id|q
op_assign
id|q-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|q-&gt;item-&gt;object.flags
op_amp
id|UNINTERESTING
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_le
id|weight
c_func
(paren
id|q
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|q
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * weight for p is unknown but q is known.&n;&t;&t;&t; * add one for p itself if p is to be counted,&n;&t;&t;&t; * otherwise inherit it from q directly.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|TREESAME
)paren
)paren
(brace
id|weight_set
c_func
(paren
id|p
comma
id|weight
c_func
(paren
id|q
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|counted
op_increment
suffix:semicolon
id|show_list
c_func
(paren
l_string|&quot;bisection 2 count one&quot;
comma
id|counted
comma
id|nr
comma
id|list
)paren
suffix:semicolon
)brace
r_else
id|weight_set
c_func
(paren
id|p
comma
id|weight
c_func
(paren
id|q
)paren
)paren
suffix:semicolon
multiline_comment|/* Does it happen to be at exactly half-way? */
r_if
c_cond
(paren
op_logical_neg
id|find_all
op_logical_and
id|halfway
c_func
(paren
id|p
comma
id|nr
)paren
)paren
r_return
id|p
suffix:semicolon
)brace
)brace
id|show_list
c_func
(paren
l_string|&quot;bisection 2 counted all&quot;
comma
id|counted
comma
id|nr
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|find_all
)paren
r_return
id|best_bisection
c_func
(paren
id|list
comma
id|nr
)paren
suffix:semicolon
r_else
r_return
id|best_bisection_sorted
c_func
(paren
id|list
comma
id|nr
)paren
suffix:semicolon
)brace
DECL|function|find_bisection
r_struct
id|commit_list
op_star
id|find_bisection
c_func
(paren
r_struct
id|commit_list
op_star
id|list
comma
r_int
op_star
id|reaches
comma
r_int
op_star
id|all
comma
r_int
id|find_all
)paren
(brace
r_int
id|nr
comma
id|on_list
suffix:semicolon
r_struct
id|commit_list
op_star
id|p
comma
op_star
id|best
comma
op_star
id|next
comma
op_star
id|last
suffix:semicolon
r_int
op_star
id|weights
suffix:semicolon
id|show_list
c_func
(paren
l_string|&quot;bisection 2 entry&quot;
comma
l_int|0
comma
l_int|0
comma
id|list
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Count the number of total and tree-changing items on the&n;&t; * list, while reversing the list.&n;&t; */
r_for
c_loop
(paren
id|nr
op_assign
id|on_list
op_assign
l_int|0
comma
id|last
op_assign
l_int|NULL
comma
id|p
op_assign
id|list
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|next
)paren
(brace
r_int
id|flags
op_assign
id|p-&gt;item-&gt;object.flags
suffix:semicolon
id|next
op_assign
id|p-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|UNINTERESTING
)paren
r_continue
suffix:semicolon
id|p-&gt;next
op_assign
id|last
suffix:semicolon
id|last
op_assign
id|p
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|TREESAME
)paren
)paren
id|nr
op_increment
suffix:semicolon
id|on_list
op_increment
suffix:semicolon
)brace
id|list
op_assign
id|last
suffix:semicolon
id|show_list
c_func
(paren
l_string|&quot;bisection 2 sorted&quot;
comma
l_int|0
comma
id|nr
comma
id|list
)paren
suffix:semicolon
op_star
id|all
op_assign
id|nr
suffix:semicolon
id|weights
op_assign
id|xcalloc
c_func
(paren
id|on_list
comma
r_sizeof
(paren
op_star
id|weights
)paren
)paren
suffix:semicolon
multiline_comment|/* Do the real work of finding bisection commit. */
id|best
op_assign
id|do_find_bisection
c_func
(paren
id|list
comma
id|nr
comma
id|weights
comma
id|find_all
)paren
suffix:semicolon
r_if
c_cond
(paren
id|best
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|find_all
)paren
id|best-&gt;next
op_assign
l_int|NULL
suffix:semicolon
op_star
id|reaches
op_assign
id|weight
c_func
(paren
id|best
)paren
suffix:semicolon
)brace
id|free
c_func
(paren
id|weights
)paren
suffix:semicolon
r_return
id|best
suffix:semicolon
)brace
DECL|function|argv_array_push
r_static
r_void
id|argv_array_push
c_func
(paren
r_struct
id|argv_array
op_star
id|array
comma
r_const
r_char
op_star
id|string
)paren
(brace
id|ALLOC_GROW
c_func
(paren
id|array-&gt;argv
comma
id|array-&gt;argv_nr
op_plus
l_int|1
comma
id|array-&gt;argv_alloc
)paren
suffix:semicolon
id|array-&gt;argv
(braket
id|array-&gt;argv_nr
op_increment
)braket
op_assign
id|string
suffix:semicolon
)brace
DECL|function|argv_array_push_sha1
r_static
r_void
id|argv_array_push_sha1
c_func
(paren
r_struct
id|argv_array
op_star
id|array
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_const
r_char
op_star
id|format
)paren
(brace
r_struct
id|strbuf
id|buf
op_assign
id|STRBUF_INIT
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
id|buf
comma
id|format
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
id|argv_array_push
c_func
(paren
id|array
comma
id|strbuf_detach
c_func
(paren
op_amp
id|buf
comma
l_int|NULL
)paren
)paren
suffix:semicolon
)brace
DECL|function|register_ref
r_static
r_int
id|register_ref
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
id|flags
comma
r_void
op_star
id|cb_data
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|refname
comma
l_string|&quot;bad&quot;
)paren
)paren
(brace
id|current_bad_sha1
op_assign
id|sha1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|refname
comma
l_string|&quot;good-&quot;
)paren
)paren
(brace
id|sha1_array_append
c_func
(paren
op_amp
id|good_revs
comma
id|sha1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|refname
comma
l_string|&quot;skip-&quot;
)paren
)paren
(brace
id|sha1_array_append
c_func
(paren
op_amp
id|skipped_revs
comma
id|sha1
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|read_bisect_refs
r_static
r_int
id|read_bisect_refs
c_func
(paren
r_void
)paren
(brace
r_return
id|for_each_ref_in
c_func
(paren
l_string|&quot;refs/bisect/&quot;
comma
id|register_ref
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|read_bisect_paths
r_static
r_void
id|read_bisect_paths
c_func
(paren
r_struct
id|argv_array
op_star
id|array
)paren
(brace
r_struct
id|strbuf
id|str
op_assign
id|STRBUF_INIT
suffix:semicolon
r_const
r_char
op_star
id|filename
op_assign
id|git_path
c_func
(paren
l_string|&quot;BISECT_NAMES&quot;
)paren
suffix:semicolon
id|FILE
op_star
id|fp
op_assign
id|fopen
c_func
(paren
id|filename
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fp
)paren
id|die_errno
c_func
(paren
l_string|&quot;Could not open file &squot;%s&squot;&quot;
comma
id|filename
)paren
suffix:semicolon
r_while
c_loop
(paren
id|strbuf_getline
c_func
(paren
op_amp
id|str
comma
id|fp
comma
l_char|&squot;&bslash;n&squot;
)paren
op_ne
id|EOF
)paren
(brace
r_char
op_star
id|quoted
suffix:semicolon
r_int
id|res
suffix:semicolon
id|strbuf_trim
c_func
(paren
op_amp
id|str
)paren
suffix:semicolon
id|quoted
op_assign
id|strbuf_detach
c_func
(paren
op_amp
id|str
comma
l_int|NULL
)paren
suffix:semicolon
id|res
op_assign
id|sq_dequote_to_argv
c_func
(paren
id|quoted
comma
op_amp
id|array-&gt;argv
comma
op_amp
id|array-&gt;argv_nr
comma
op_amp
id|array-&gt;argv_alloc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
id|die
c_func
(paren
l_string|&quot;Badly quoted content in file &squot;%s&squot;: %s&quot;
comma
id|filename
comma
id|quoted
)paren
suffix:semicolon
)brace
id|strbuf_release
c_func
(paren
op_amp
id|str
)paren
suffix:semicolon
id|fclose
c_func
(paren
id|fp
)paren
suffix:semicolon
)brace
DECL|function|join_sha1_array_hex
r_static
r_char
op_star
id|join_sha1_array_hex
c_func
(paren
r_struct
id|sha1_array
op_star
id|array
comma
r_char
id|delim
)paren
(brace
r_struct
id|strbuf
id|joined_hexs
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|array-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
id|strbuf_addstr
c_func
(paren
op_amp
id|joined_hexs
comma
id|sha1_to_hex
c_func
(paren
id|array-&gt;sha1
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_plus
l_int|1
OL
id|array-&gt;nr
)paren
id|strbuf_addch
c_func
(paren
op_amp
id|joined_hexs
comma
id|delim
)paren
suffix:semicolon
)brace
r_return
id|strbuf_detach
c_func
(paren
op_amp
id|joined_hexs
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * In this function, passing a not NULL skipped_first is very special.&n; * It means that we want to know if the first commit in the list is&n; * skipped because we will want to test a commit away from it if it is&n; * indeed skipped.&n; * So if the first commit is skipped, we cannot take the shortcut to&n; * just &quot;return list&quot; when we find the first non skipped commit, we&n; * have to return a fully filtered list.&n; *&n; * We use (*skipped_first == -1) to mean &quot;it has been found that the&n; * first commit is not skipped&quot;. In this case *skipped_first is set back&n; * to 0 just before the function returns.&n; */
DECL|function|filter_skipped
r_struct
id|commit_list
op_star
id|filter_skipped
c_func
(paren
r_struct
id|commit_list
op_star
id|list
comma
r_struct
id|commit_list
op_star
op_star
id|tried
comma
r_int
id|show_all
comma
r_int
op_star
id|count
comma
r_int
op_star
id|skipped_first
)paren
(brace
r_struct
id|commit_list
op_star
id|filtered
op_assign
l_int|NULL
comma
op_star
op_star
id|f
op_assign
op_amp
id|filtered
suffix:semicolon
op_star
id|tried
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|skipped_first
)paren
op_star
id|skipped_first
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|count
)paren
op_star
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skipped_revs.nr
)paren
r_return
id|list
suffix:semicolon
r_while
c_loop
(paren
id|list
)paren
(brace
r_struct
id|commit_list
op_star
id|next
op_assign
id|list-&gt;next
suffix:semicolon
id|list-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_le
id|sha1_array_lookup
c_func
(paren
op_amp
id|skipped_revs
comma
id|list-&gt;item-&gt;object.sha1
)paren
)paren
(brace
r_if
c_cond
(paren
id|skipped_first
op_logical_and
op_logical_neg
op_star
id|skipped_first
)paren
op_star
id|skipped_first
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Move current to tried list */
op_star
id|tried
op_assign
id|list
suffix:semicolon
id|tried
op_assign
op_amp
id|list-&gt;next
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|show_all
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|skipped_first
op_logical_or
op_logical_neg
op_star
id|skipped_first
)paren
r_return
id|list
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|skipped_first
op_logical_and
op_logical_neg
op_star
id|skipped_first
)paren
(brace
multiline_comment|/* This means we know it&squot;s not skipped */
op_star
id|skipped_first
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Move current to filtered list */
op_star
id|f
op_assign
id|list
suffix:semicolon
id|f
op_assign
op_amp
id|list-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|count
)paren
(paren
op_star
id|count
)paren
op_increment
suffix:semicolon
)brace
id|list
op_assign
id|next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skipped_first
op_logical_and
op_star
id|skipped_first
op_eq
l_int|1
)paren
op_star
id|skipped_first
op_assign
l_int|0
suffix:semicolon
r_return
id|filtered
suffix:semicolon
)brace
DECL|macro|PRN_MODULO
mdefine_line|#define PRN_MODULO 32768
multiline_comment|/*&n; * This is a pseudo random number generator based on &quot;man 3 rand&quot;.&n; * It is not used properly because the seed is the argument and it&n; * is increased by one between each call, but that should not matter&n; * for this application.&n; */
DECL|function|get_prn
r_static
r_int
id|get_prn
c_func
(paren
r_int
id|count
)paren
(brace
id|count
op_assign
id|count
op_star
l_int|1103515245
op_plus
l_int|12345
suffix:semicolon
r_return
(paren
(paren
r_int
)paren
(paren
id|count
op_div
l_int|65536
)paren
op_mod
id|PRN_MODULO
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Custom integer square root from&n; * http://en.wikipedia.org/wiki/Integer_square_root&n; */
DECL|function|sqrti
r_static
r_int
id|sqrti
c_func
(paren
r_int
id|val
)paren
(brace
r_float
id|d
comma
id|x
op_assign
id|val
suffix:semicolon
r_if
c_cond
(paren
id|val
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_do
(brace
r_float
id|y
op_assign
(paren
id|x
op_plus
(paren
r_float
)paren
id|val
op_div
id|x
)paren
op_div
l_int|2
suffix:semicolon
id|d
op_assign
(paren
id|y
OG
id|x
)paren
ques
c_cond
id|y
id|x
suffix:colon
id|x
id|y
suffix:semicolon
id|x
op_assign
id|y
suffix:semicolon
)brace
r_while
c_loop
(paren
id|d
op_ge
l_float|0.5
)paren
suffix:semicolon
r_return
(paren
r_int
)paren
id|x
suffix:semicolon
)brace
DECL|function|skip_away
r_static
r_struct
id|commit_list
op_star
id|skip_away
c_func
(paren
r_struct
id|commit_list
op_star
id|list
comma
r_int
id|count
)paren
(brace
r_struct
id|commit_list
op_star
id|cur
comma
op_star
id|previous
suffix:semicolon
r_int
id|prn
comma
id|index
comma
id|i
suffix:semicolon
id|prn
op_assign
id|get_prn
c_func
(paren
id|count
)paren
suffix:semicolon
id|index
op_assign
(paren
id|count
op_star
id|prn
op_div
id|PRN_MODULO
)paren
op_star
id|sqrti
c_func
(paren
id|prn
)paren
op_div
id|sqrti
c_func
(paren
id|PRN_MODULO
)paren
suffix:semicolon
id|cur
op_assign
id|list
suffix:semicolon
id|previous
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|cur
suffix:semicolon
id|cur
op_assign
id|cur-&gt;next
comma
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
id|index
)paren
(brace
r_if
c_cond
(paren
id|hashcmp
c_func
(paren
id|cur-&gt;item-&gt;object.sha1
comma
id|current_bad_sha1
)paren
)paren
r_return
id|cur
suffix:semicolon
r_if
c_cond
(paren
id|previous
)paren
r_return
id|previous
suffix:semicolon
r_return
id|list
suffix:semicolon
)brace
id|previous
op_assign
id|cur
suffix:semicolon
)brace
r_return
id|list
suffix:semicolon
)brace
DECL|function|managed_skipped
r_static
r_struct
id|commit_list
op_star
id|managed_skipped
c_func
(paren
r_struct
id|commit_list
op_star
id|list
comma
r_struct
id|commit_list
op_star
op_star
id|tried
)paren
(brace
r_int
id|count
comma
id|skipped_first
suffix:semicolon
op_star
id|tried
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skipped_revs.nr
)paren
r_return
id|list
suffix:semicolon
id|list
op_assign
id|filter_skipped
c_func
(paren
id|list
comma
id|tried
comma
l_int|0
comma
op_amp
id|count
comma
op_amp
id|skipped_first
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skipped_first
)paren
r_return
id|list
suffix:semicolon
r_return
id|skip_away
c_func
(paren
id|list
comma
id|count
)paren
suffix:semicolon
)brace
DECL|function|bisect_rev_setup
r_static
r_void
id|bisect_rev_setup
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_const
r_char
op_star
id|prefix
comma
r_const
r_char
op_star
id|bad_format
comma
r_const
r_char
op_star
id|good_format
comma
r_int
id|read_paths
)paren
(brace
r_struct
id|argv_array
id|rev_argv
op_assign
(brace
l_int|NULL
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_int
id|i
suffix:semicolon
id|init_revisions
c_func
(paren
id|revs
comma
id|prefix
)paren
suffix:semicolon
id|revs-&gt;abbrev
op_assign
l_int|0
suffix:semicolon
id|revs-&gt;commit_format
op_assign
id|CMIT_FMT_UNSPECIFIED
suffix:semicolon
multiline_comment|/* rev_argv.argv[0] will be ignored by setup_revisions */
id|argv_array_push
c_func
(paren
op_amp
id|rev_argv
comma
id|xstrdup
c_func
(paren
l_string|&quot;bisect_rev_setup&quot;
)paren
)paren
suffix:semicolon
id|argv_array_push_sha1
c_func
(paren
op_amp
id|rev_argv
comma
id|current_bad_sha1
comma
id|bad_format
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|good_revs.nr
suffix:semicolon
id|i
op_increment
)paren
id|argv_array_push_sha1
c_func
(paren
op_amp
id|rev_argv
comma
id|good_revs.sha1
(braket
id|i
)braket
comma
id|good_format
)paren
suffix:semicolon
id|argv_array_push
c_func
(paren
op_amp
id|rev_argv
comma
id|xstrdup
c_func
(paren
l_string|&quot;--&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_paths
)paren
id|read_bisect_paths
c_func
(paren
op_amp
id|rev_argv
)paren
suffix:semicolon
id|argv_array_push
c_func
(paren
op_amp
id|rev_argv
comma
l_int|NULL
)paren
suffix:semicolon
id|setup_revisions
c_func
(paren
id|rev_argv.argv_nr
comma
id|rev_argv.argv
comma
id|revs
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|bisect_common
r_static
r_void
id|bisect_common
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
)paren
(brace
r_if
c_cond
(paren
id|prepare_revision_walk
c_func
(paren
id|revs
)paren
)paren
id|die
c_func
(paren
l_string|&quot;revision walk setup failed&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;tree_objects
)paren
id|mark_edges_uninteresting
c_func
(paren
id|revs-&gt;commits
comma
id|revs
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|exit_if_skipped_commits
r_static
r_void
id|exit_if_skipped_commits
c_func
(paren
r_struct
id|commit_list
op_star
id|tried
comma
r_const
r_int
r_char
op_star
id|bad
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tried
)paren
r_return
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;There are only &squot;skip&squot;ped commits left to test.&bslash;n&quot;
l_string|&quot;The first bad commit could be any of:&bslash;n&quot;
)paren
suffix:semicolon
id|print_commit_list
c_func
(paren
id|tried
comma
l_string|&quot;%s&bslash;n&quot;
comma
l_string|&quot;%s&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bad
)paren
id|printf
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|bad
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;We cannot bisect more!&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|2
)paren
suffix:semicolon
)brace
DECL|function|is_expected_rev
r_static
r_int
id|is_expected_rev
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_const
r_char
op_star
id|filename
op_assign
id|git_path
c_func
(paren
l_string|&quot;BISECT_EXPECTED_REV&quot;
)paren
suffix:semicolon
r_struct
id|stat
id|st
suffix:semicolon
r_struct
id|strbuf
id|str
op_assign
id|STRBUF_INIT
suffix:semicolon
id|FILE
op_star
id|fp
suffix:semicolon
r_int
id|res
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|stat
c_func
(paren
id|filename
comma
op_amp
id|st
)paren
op_logical_or
op_logical_neg
id|S_ISREG
c_func
(paren
id|st.st_mode
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|fp
op_assign
id|fopen
c_func
(paren
id|filename
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fp
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|strbuf_getline
c_func
(paren
op_amp
id|str
comma
id|fp
comma
l_char|&squot;&bslash;n&squot;
)paren
op_ne
id|EOF
)paren
id|res
op_assign
op_logical_neg
id|strcmp
c_func
(paren
id|str.buf
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|str
)paren
suffix:semicolon
id|fclose
c_func
(paren
id|fp
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
DECL|function|mark_expected_rev
r_static
r_void
id|mark_expected_rev
c_func
(paren
r_char
op_star
id|bisect_rev_hex
)paren
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|bisect_rev_hex
)paren
suffix:semicolon
r_const
r_char
op_star
id|filename
op_assign
id|git_path
c_func
(paren
l_string|&quot;BISECT_EXPECTED_REV&quot;
)paren
suffix:semicolon
r_int
id|fd
op_assign
id|open
c_func
(paren
id|filename
comma
id|O_CREAT
op_or
id|O_TRUNC
op_or
id|O_WRONLY
comma
l_int|0600
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
id|die_errno
c_func
(paren
l_string|&quot;could not create file &squot;%s&squot;&quot;
comma
id|filename
)paren
suffix:semicolon
id|bisect_rev_hex
(braket
id|len
)braket
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
id|write_or_die
c_func
(paren
id|fd
comma
id|bisect_rev_hex
comma
id|len
op_plus
l_int|1
)paren
suffix:semicolon
id|bisect_rev_hex
(braket
id|len
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|close
c_func
(paren
id|fd
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;closing file %s: %s&quot;
comma
id|filename
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
)brace
DECL|function|bisect_checkout
r_static
r_int
id|bisect_checkout
c_func
(paren
r_char
op_star
id|bisect_rev_hex
comma
r_int
id|no_checkout
)paren
(brace
r_int
id|res
suffix:semicolon
id|mark_expected_rev
c_func
(paren
id|bisect_rev_hex
)paren
suffix:semicolon
id|argv_checkout
(braket
l_int|2
)braket
op_assign
id|bisect_rev_hex
suffix:semicolon
r_if
c_cond
(paren
id|no_checkout
)paren
(brace
id|argv_update_ref
(braket
l_int|3
)braket
op_assign
id|bisect_rev_hex
suffix:semicolon
r_if
c_cond
(paren
id|run_command_v_opt
c_func
(paren
id|argv_update_ref
comma
id|RUN_GIT_CMD
)paren
)paren
id|die
c_func
(paren
l_string|&quot;update-ref --no-deref HEAD failed on %s&quot;
comma
id|bisect_rev_hex
)paren
suffix:semicolon
)brace
r_else
(brace
id|res
op_assign
id|run_command_v_opt
c_func
(paren
id|argv_checkout
comma
id|RUN_GIT_CMD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
m_exit
(paren
id|res
)paren
suffix:semicolon
)brace
id|argv_show_branch
(braket
l_int|1
)braket
op_assign
id|bisect_rev_hex
suffix:semicolon
r_return
id|run_command_v_opt
c_func
(paren
id|argv_show_branch
comma
id|RUN_GIT_CMD
)paren
suffix:semicolon
)brace
DECL|function|get_commit_reference
r_static
r_struct
id|commit
op_star
id|get_commit_reference
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_struct
id|commit
op_star
id|r
op_assign
id|lookup_commit_reference
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|r
)paren
id|die
c_func
(paren
l_string|&quot;Not a valid commit name %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
DECL|function|get_bad_and_good_commits
r_static
r_struct
id|commit
op_star
op_star
id|get_bad_and_good_commits
c_func
(paren
r_int
op_star
id|rev_nr
)paren
(brace
r_int
id|len
op_assign
l_int|1
op_plus
id|good_revs.nr
suffix:semicolon
r_struct
id|commit
op_star
op_star
id|rev
op_assign
id|xmalloc
c_func
(paren
id|len
op_star
r_sizeof
(paren
op_star
id|rev
)paren
)paren
suffix:semicolon
r_int
id|i
comma
id|n
op_assign
l_int|0
suffix:semicolon
id|rev
(braket
id|n
op_increment
)braket
op_assign
id|get_commit_reference
c_func
(paren
id|current_bad_sha1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|good_revs.nr
suffix:semicolon
id|i
op_increment
)paren
id|rev
(braket
id|n
op_increment
)braket
op_assign
id|get_commit_reference
c_func
(paren
id|good_revs.sha1
(braket
id|i
)braket
)paren
suffix:semicolon
op_star
id|rev_nr
op_assign
id|n
suffix:semicolon
r_return
id|rev
suffix:semicolon
)brace
DECL|function|handle_bad_merge_base
r_static
r_void
id|handle_bad_merge_base
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|is_expected_rev
c_func
(paren
id|current_bad_sha1
)paren
)paren
(brace
r_char
op_star
id|bad_hex
op_assign
id|sha1_to_hex
c_func
(paren
id|current_bad_sha1
)paren
suffix:semicolon
r_char
op_star
id|good_hex
op_assign
id|join_sha1_array_hex
c_func
(paren
op_amp
id|good_revs
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;The merge base %s is bad.&bslash;n&quot;
l_string|&quot;This means the bug has been fixed &quot;
l_string|&quot;between %s and [%s].&bslash;n&quot;
comma
id|bad_hex
comma
id|bad_hex
comma
id|good_hex
)paren
suffix:semicolon
m_exit
(paren
l_int|3
)paren
suffix:semicolon
)brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Some good revs are not ancestor of the bad rev.&bslash;n&quot;
l_string|&quot;git bisect cannot work properly in this case.&bslash;n&quot;
l_string|&quot;Maybe you mistake good and bad revs?&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|handle_skipped_merge_base
r_static
r_void
id|handle_skipped_merge_base
c_func
(paren
r_const
r_int
r_char
op_star
id|mb
)paren
(brace
r_char
op_star
id|mb_hex
op_assign
id|sha1_to_hex
c_func
(paren
id|mb
)paren
suffix:semicolon
r_char
op_star
id|bad_hex
op_assign
id|sha1_to_hex
c_func
(paren
id|current_bad_sha1
)paren
suffix:semicolon
r_char
op_star
id|good_hex
op_assign
id|join_sha1_array_hex
c_func
(paren
op_amp
id|good_revs
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
id|warning
c_func
(paren
l_string|&quot;the merge base between %s and [%s] &quot;
l_string|&quot;must be skipped.&bslash;n&quot;
l_string|&quot;So we cannot be sure the first bad commit is &quot;
l_string|&quot;between %s and %s.&bslash;n&quot;
l_string|&quot;We continue anyway.&quot;
comma
id|bad_hex
comma
id|good_hex
comma
id|mb_hex
comma
id|bad_hex
)paren
suffix:semicolon
id|free
c_func
(paren
id|good_hex
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * &quot;check_merge_bases&quot; checks that merge bases are not &quot;bad&quot;.&n; *&n; * - If one is &quot;bad&quot;, it means the user assumed something wrong&n; * and we must exit with a non 0 error code.&n; * - If one is &quot;good&quot;, that&squot;s good, we have nothing to do.&n; * - If one is &quot;skipped&quot;, we can&squot;t know but we should warn.&n; * - If we don&squot;t know, we should check it out and ask the user to test.&n; */
DECL|function|check_merge_bases
r_static
r_void
id|check_merge_bases
c_func
(paren
r_int
id|no_checkout
)paren
(brace
r_struct
id|commit_list
op_star
id|result
suffix:semicolon
r_int
id|rev_nr
suffix:semicolon
r_struct
id|commit
op_star
op_star
id|rev
op_assign
id|get_bad_and_good_commits
c_func
(paren
op_amp
id|rev_nr
)paren
suffix:semicolon
id|result
op_assign
id|get_merge_bases_many
c_func
(paren
id|rev
(braket
l_int|0
)braket
comma
id|rev_nr
l_int|1
comma
id|rev
op_plus
l_int|1
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|result
suffix:semicolon
id|result
op_assign
id|result-&gt;next
)paren
(brace
r_const
r_int
r_char
op_star
id|mb
op_assign
id|result-&gt;item-&gt;object.sha1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hashcmp
c_func
(paren
id|mb
comma
id|current_bad_sha1
)paren
)paren
(brace
id|handle_bad_merge_base
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
l_int|0
op_le
id|sha1_array_lookup
c_func
(paren
op_amp
id|good_revs
comma
id|mb
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
l_int|0
op_le
id|sha1_array_lookup
c_func
(paren
op_amp
id|skipped_revs
comma
id|mb
)paren
)paren
(brace
id|handle_skipped_merge_base
c_func
(paren
id|mb
)paren
suffix:semicolon
)brace
r_else
(brace
id|printf
c_func
(paren
l_string|&quot;Bisecting: a merge base must be tested&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
id|bisect_checkout
c_func
(paren
id|sha1_to_hex
c_func
(paren
id|mb
)paren
comma
id|no_checkout
)paren
)paren
suffix:semicolon
)brace
)brace
id|free
c_func
(paren
id|rev
)paren
suffix:semicolon
id|free_commit_list
c_func
(paren
id|result
)paren
suffix:semicolon
)brace
DECL|function|check_ancestors
r_static
r_int
id|check_ancestors
c_func
(paren
r_const
r_char
op_star
id|prefix
)paren
(brace
r_struct
id|rev_info
id|revs
suffix:semicolon
r_struct
id|object_array
id|pending_copy
suffix:semicolon
r_int
id|i
comma
id|res
suffix:semicolon
id|bisect_rev_setup
c_func
(paren
op_amp
id|revs
comma
id|prefix
comma
l_string|&quot;^%s&quot;
comma
l_string|&quot;%s&quot;
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Save pending objects, so they can be cleaned up later. */
id|memset
c_func
(paren
op_amp
id|pending_copy
comma
l_int|0
comma
r_sizeof
(paren
id|pending_copy
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|revs.pending.nr
suffix:semicolon
id|i
op_increment
)paren
id|add_object_array
c_func
(paren
id|revs.pending.objects
(braket
id|i
)braket
dot
id|item
comma
id|revs.pending.objects
(braket
id|i
)braket
dot
id|name
comma
op_amp
id|pending_copy
)paren
suffix:semicolon
id|bisect_common
c_func
(paren
op_amp
id|revs
)paren
suffix:semicolon
id|res
op_assign
(paren
id|revs.commits
op_ne
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Clean up objects used, as they will be reused. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pending_copy.nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|object
op_star
id|o
op_assign
id|pending_copy.objects
(braket
id|i
)braket
dot
id|item
suffix:semicolon
id|clear_commit_marks
c_func
(paren
(paren
r_struct
id|commit
op_star
)paren
id|o
comma
id|ALL_REV_FLAGS
)paren
suffix:semicolon
)brace
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/*&n; * &quot;check_good_are_ancestors_of_bad&quot; checks that all &quot;good&quot; revs are&n; * ancestor of the &quot;bad&quot; rev.&n; *&n; * If that&squot;s not the case, we need to check the merge bases.&n; * If a merge base must be tested by the user, its source code will be&n; * checked out to be tested by the user and we will exit.&n; */
DECL|function|check_good_are_ancestors_of_bad
r_static
r_void
id|check_good_are_ancestors_of_bad
c_func
(paren
r_const
r_char
op_star
id|prefix
comma
r_int
id|no_checkout
)paren
(brace
r_const
r_char
op_star
id|filename
op_assign
id|git_path
c_func
(paren
l_string|&quot;BISECT_ANCESTORS_OK&quot;
)paren
suffix:semicolon
r_struct
id|stat
id|st
suffix:semicolon
r_int
id|fd
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|current_bad_sha1
)paren
id|die
c_func
(paren
l_string|&quot;a bad revision is needed&quot;
)paren
suffix:semicolon
multiline_comment|/* Check if file BISECT_ANCESTORS_OK exists. */
r_if
c_cond
(paren
op_logical_neg
id|stat
c_func
(paren
id|filename
comma
op_amp
id|st
)paren
op_logical_and
id|S_ISREG
c_func
(paren
id|st.st_mode
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Bisecting with no good rev is ok. */
r_if
c_cond
(paren
id|good_revs.nr
op_eq
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* Check if all good revs are ancestor of the bad rev. */
r_if
c_cond
(paren
id|check_ancestors
c_func
(paren
id|prefix
)paren
)paren
id|check_merge_bases
c_func
(paren
id|no_checkout
)paren
suffix:semicolon
multiline_comment|/* Create file BISECT_ANCESTORS_OK. */
id|fd
op_assign
id|open
c_func
(paren
id|filename
comma
id|O_CREAT
op_or
id|O_TRUNC
op_or
id|O_WRONLY
comma
l_int|0600
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
id|warning
c_func
(paren
l_string|&quot;could not create file &squot;%s&squot;: %s&quot;
comma
id|filename
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_else
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This does &quot;git diff-tree --pretty COMMIT&quot; without one fork+exec.&n; */
DECL|function|show_diff_tree
r_static
r_void
id|show_diff_tree
c_func
(paren
r_const
r_char
op_star
id|prefix
comma
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_struct
id|rev_info
id|opt
suffix:semicolon
multiline_comment|/* diff-tree init */
id|init_revisions
c_func
(paren
op_amp
id|opt
comma
id|prefix
)paren
suffix:semicolon
id|git_config
c_func
(paren
id|git_diff_basic_config
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* no &quot;diff&quot; UI options */
id|opt.abbrev
op_assign
l_int|0
suffix:semicolon
id|opt.diff
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* This is what &quot;--pretty&quot; does */
id|opt.verbose_header
op_assign
l_int|1
suffix:semicolon
id|opt.use_terminator
op_assign
l_int|0
suffix:semicolon
id|opt.commit_format
op_assign
id|CMIT_FMT_DEFAULT
suffix:semicolon
multiline_comment|/* diff-tree init */
r_if
c_cond
(paren
op_logical_neg
id|opt.diffopt.output_format
)paren
id|opt.diffopt.output_format
op_assign
id|DIFF_FORMAT_RAW
suffix:semicolon
id|log_tree_commit
c_func
(paren
op_amp
id|opt
comma
id|commit
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * We use the convention that exiting with an exit code 10 means that&n; * the bisection process finished successfully.&n; * In this case the calling shell script should exit 0.&n; *&n; * If no_checkout is non-zero, the bisection process does not&n; * checkout the trial commit but instead simply updates BISECT_HEAD.&n; */
DECL|function|bisect_next_all
r_int
id|bisect_next_all
c_func
(paren
r_const
r_char
op_star
id|prefix
comma
r_int
id|no_checkout
)paren
(brace
r_struct
id|rev_info
id|revs
suffix:semicolon
r_struct
id|commit_list
op_star
id|tried
suffix:semicolon
r_int
id|reaches
op_assign
l_int|0
comma
id|all
op_assign
l_int|0
comma
id|nr
comma
id|steps
suffix:semicolon
r_const
r_int
r_char
op_star
id|bisect_rev
suffix:semicolon
r_char
id|bisect_rev_hex
(braket
l_int|41
)braket
suffix:semicolon
r_if
c_cond
(paren
id|read_bisect_refs
c_func
(paren
)paren
)paren
id|die
c_func
(paren
l_string|&quot;reading bisect refs failed&quot;
)paren
suffix:semicolon
id|check_good_are_ancestors_of_bad
c_func
(paren
id|prefix
comma
id|no_checkout
)paren
suffix:semicolon
id|bisect_rev_setup
c_func
(paren
op_amp
id|revs
comma
id|prefix
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;^%s&quot;
comma
l_int|1
)paren
suffix:semicolon
id|revs.limited
op_assign
l_int|1
suffix:semicolon
id|bisect_common
c_func
(paren
op_amp
id|revs
)paren
suffix:semicolon
id|revs.commits
op_assign
id|find_bisection
c_func
(paren
id|revs.commits
comma
op_amp
id|reaches
comma
op_amp
id|all
comma
op_logical_neg
op_logical_neg
id|skipped_revs.nr
)paren
suffix:semicolon
id|revs.commits
op_assign
id|managed_skipped
c_func
(paren
id|revs.commits
comma
op_amp
id|tried
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|revs.commits
)paren
(brace
multiline_comment|/*&n;&t;&t; * We should exit here only if the &quot;bad&quot;&n;&t;&t; * commit is also a &quot;skip&quot; commit.&n;&t;&t; */
id|exit_if_skipped_commits
c_func
(paren
id|tried
comma
l_int|NULL
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s was both good and bad&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|current_bad_sha1
)paren
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|all
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;No testable commit found.&bslash;n&quot;
l_string|&quot;Maybe you started with bad path parameters?&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|4
)paren
suffix:semicolon
)brace
id|bisect_rev
op_assign
id|revs.commits-&gt;item-&gt;object.sha1
suffix:semicolon
id|memcpy
c_func
(paren
id|bisect_rev_hex
comma
id|sha1_to_hex
c_func
(paren
id|bisect_rev
)paren
comma
l_int|41
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hashcmp
c_func
(paren
id|bisect_rev
comma
id|current_bad_sha1
)paren
)paren
(brace
id|exit_if_skipped_commits
c_func
(paren
id|tried
comma
id|current_bad_sha1
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s is the first bad commit&bslash;n&quot;
comma
id|bisect_rev_hex
)paren
suffix:semicolon
id|show_diff_tree
c_func
(paren
id|prefix
comma
id|revs.commits-&gt;item
)paren
suffix:semicolon
multiline_comment|/* This means the bisection process succeeded. */
m_exit
(paren
l_int|10
)paren
suffix:semicolon
)brace
id|nr
op_assign
id|all
id|reaches
l_int|1
suffix:semicolon
id|steps
op_assign
id|estimate_bisect_steps
c_func
(paren
id|all
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Bisecting: %d revision%s left to test after this &quot;
l_string|&quot;(roughly %d step%s)&bslash;n&quot;
comma
id|nr
comma
(paren
id|nr
op_eq
l_int|1
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;s&quot;
)paren
comma
id|steps
comma
(paren
id|steps
op_eq
l_int|1
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;s&quot;
)paren
)paren
suffix:semicolon
r_return
id|bisect_checkout
c_func
(paren
id|bisect_rev_hex
comma
id|no_checkout
)paren
suffix:semicolon
)brace
eof
