macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;commit.h&quot;
macro_line|#include &quot;blob.h&quot;
macro_line|#include &quot;diff.h&quot;
macro_line|#include &quot;diffcore.h&quot;
macro_line|#include &quot;quote.h&quot;
macro_line|#include &quot;xdiff-interface.h&quot;
macro_line|#include &quot;log-tree.h&quot;
DECL|function|uninteresting
r_static
r_int
id|uninteresting
c_func
(paren
r_struct
id|diff_filepair
op_star
id|p
)paren
(brace
r_if
c_cond
(paren
id|diff_unmodified_pair
c_func
(paren
id|p
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|intersect_paths
r_static
r_struct
id|combine_diff_path
op_star
id|intersect_paths
c_func
(paren
r_struct
id|combine_diff_path
op_star
id|curr
comma
r_int
id|n
comma
r_int
id|num_parent
)paren
(brace
r_struct
id|diff_queue_struct
op_star
id|q
op_assign
op_amp
id|diff_queued_diff
suffix:semicolon
r_struct
id|combine_diff_path
op_star
id|p
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n
)paren
(brace
r_struct
id|combine_diff_path
op_star
id|list
op_assign
l_int|NULL
comma
op_star
op_star
id|tail
op_assign
op_amp
id|list
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|q-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|len
suffix:semicolon
r_const
r_char
op_star
id|path
suffix:semicolon
r_if
c_cond
(paren
id|uninteresting
c_func
(paren
id|q-&gt;queue
(braket
id|i
)braket
)paren
)paren
r_continue
suffix:semicolon
id|path
op_assign
id|q-&gt;queue
(braket
id|i
)braket
op_member_access_from_pointer
id|two-&gt;path
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|path
)paren
suffix:semicolon
id|p
op_assign
id|xmalloc
c_func
(paren
id|combine_diff_path_size
c_func
(paren
id|num_parent
comma
id|len
)paren
)paren
suffix:semicolon
id|p-&gt;path
op_assign
(paren
r_char
op_star
)paren
op_amp
(paren
id|p-&gt;parent
(braket
id|num_parent
)braket
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|p-&gt;path
comma
id|path
comma
id|len
)paren
suffix:semicolon
id|p-&gt;path
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
id|p-&gt;len
op_assign
id|len
suffix:semicolon
id|p-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|p-&gt;parent
comma
l_int|0
comma
r_sizeof
(paren
id|p-&gt;parent
(braket
l_int|0
)braket
)paren
op_star
id|num_parent
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|p-&gt;sha1
comma
id|q-&gt;queue
(braket
id|i
)braket
op_member_access_from_pointer
id|two-&gt;sha1
comma
l_int|20
)paren
suffix:semicolon
id|p-&gt;mode
op_assign
id|q-&gt;queue
(braket
id|i
)braket
op_member_access_from_pointer
id|two-&gt;mode
suffix:semicolon
id|memcpy
c_func
(paren
id|p-&gt;parent
(braket
id|n
)braket
dot
id|sha1
comma
id|q-&gt;queue
(braket
id|i
)braket
op_member_access_from_pointer
id|one-&gt;sha1
comma
l_int|20
)paren
suffix:semicolon
id|p-&gt;parent
(braket
id|n
)braket
dot
id|mode
op_assign
id|q-&gt;queue
(braket
id|i
)braket
op_member_access_from_pointer
id|one-&gt;mode
suffix:semicolon
id|p-&gt;parent
(braket
id|n
)braket
dot
id|status
op_assign
id|q-&gt;queue
(braket
id|i
)braket
op_member_access_from_pointer
id|status
suffix:semicolon
op_star
id|tail
op_assign
id|p
suffix:semicolon
id|tail
op_assign
op_amp
id|p-&gt;next
suffix:semicolon
)brace
r_return
id|list
suffix:semicolon
)brace
r_for
c_loop
(paren
id|p
op_assign
id|curr
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_int
id|found
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;len
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|q-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_char
op_star
id|path
suffix:semicolon
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
id|uninteresting
c_func
(paren
id|q-&gt;queue
(braket
id|i
)braket
)paren
)paren
r_continue
suffix:semicolon
id|path
op_assign
id|q-&gt;queue
(braket
id|i
)braket
op_member_access_from_pointer
id|two-&gt;path
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
id|p-&gt;len
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|path
comma
id|p-&gt;path
comma
id|len
)paren
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
id|memcpy
c_func
(paren
id|p-&gt;parent
(braket
id|n
)braket
dot
id|sha1
comma
id|q-&gt;queue
(braket
id|i
)braket
op_member_access_from_pointer
id|one-&gt;sha1
comma
l_int|20
)paren
suffix:semicolon
id|p-&gt;parent
(braket
id|n
)braket
dot
id|mode
op_assign
id|q-&gt;queue
(braket
id|i
)braket
op_member_access_from_pointer
id|one-&gt;mode
suffix:semicolon
id|p-&gt;parent
(braket
id|n
)braket
dot
id|status
op_assign
id|q-&gt;queue
(braket
id|i
)braket
op_member_access_from_pointer
id|status
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
id|p-&gt;len
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|curr
suffix:semicolon
)brace
multiline_comment|/* Lines lost from parent */
DECL|struct|lline
r_struct
id|lline
(brace
DECL|member|next
r_struct
id|lline
op_star
id|next
suffix:semicolon
DECL|member|len
r_int
id|len
suffix:semicolon
DECL|member|parent_map
r_int
r_int
id|parent_map
suffix:semicolon
DECL|member|line
r_char
id|line
(braket
id|FLEX_ARRAY
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Lines surviving in the merge result */
DECL|struct|sline
r_struct
id|sline
(brace
DECL|member|lost_head
DECL|member|lost_tail
r_struct
id|lline
op_star
id|lost_head
comma
op_star
op_star
id|lost_tail
suffix:semicolon
DECL|member|bol
r_char
op_star
id|bol
suffix:semicolon
DECL|member|len
r_int
id|len
suffix:semicolon
multiline_comment|/* bit 0 up to (N-1) are on if the parent has this line (i.e.&n;&t; * we did not change it).&n;&t; * bit N is used for &quot;interesting&quot; lines, including context.&n;&t; */
DECL|member|flag
r_int
r_int
id|flag
suffix:semicolon
DECL|member|p_lno
r_int
r_int
op_star
id|p_lno
suffix:semicolon
)brace
suffix:semicolon
DECL|function|grab_blob
r_static
r_char
op_star
id|grab_blob
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
r_int
op_star
id|size
)paren
(brace
r_char
op_star
id|blob
suffix:semicolon
r_char
id|type
(braket
l_int|20
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|sha1
comma
id|null_sha1
comma
l_int|20
)paren
)paren
(brace
multiline_comment|/* deleted blob */
op_star
id|size
op_assign
l_int|0
suffix:semicolon
r_return
id|xcalloc
c_func
(paren
l_int|1
comma
l_int|1
)paren
suffix:semicolon
)brace
id|blob
op_assign
id|read_sha1_file
c_func
(paren
id|sha1
comma
id|type
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|type
comma
id|blob_type
)paren
)paren
id|die
c_func
(paren
l_string|&quot;object &squot;%s&squot; is not a blob!&quot;
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
r_return
id|blob
suffix:semicolon
)brace
DECL|function|append_lost
r_static
r_void
id|append_lost
c_func
(paren
r_struct
id|sline
op_star
id|sline
comma
r_int
id|n
comma
r_const
r_char
op_star
id|line
comma
r_int
id|len
)paren
(brace
r_struct
id|lline
op_star
id|lline
suffix:semicolon
r_int
r_int
id|this_mask
op_assign
(paren
l_int|1UL
op_lshift
id|n
)paren
suffix:semicolon
r_if
c_cond
(paren
id|line
(braket
id|len
op_minus
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|len
op_decrement
suffix:semicolon
multiline_comment|/* Check to see if we can squash things */
r_if
c_cond
(paren
id|sline-&gt;lost_head
)paren
(brace
r_struct
id|lline
op_star
id|last_one
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* We cannot squash it with earlier one */
r_for
c_loop
(paren
id|lline
op_assign
id|sline-&gt;lost_head
suffix:semicolon
id|lline
suffix:semicolon
id|lline
op_assign
id|lline-&gt;next
)paren
r_if
c_cond
(paren
id|lline-&gt;parent_map
op_amp
id|this_mask
)paren
id|last_one
op_assign
id|lline
suffix:semicolon
id|lline
op_assign
id|last_one
ques
c_cond
id|last_one-&gt;next
suffix:colon
id|sline-&gt;lost_head
suffix:semicolon
r_while
c_loop
(paren
id|lline
)paren
(brace
r_if
c_cond
(paren
id|lline-&gt;len
op_eq
id|len
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|lline-&gt;line
comma
id|line
comma
id|len
)paren
)paren
(brace
id|lline-&gt;parent_map
op_or_assign
id|this_mask
suffix:semicolon
r_return
suffix:semicolon
)brace
id|lline
op_assign
id|lline-&gt;next
suffix:semicolon
)brace
)brace
id|lline
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|lline
)paren
op_plus
id|len
op_plus
l_int|1
)paren
suffix:semicolon
id|lline-&gt;len
op_assign
id|len
suffix:semicolon
id|lline-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|lline-&gt;parent_map
op_assign
id|this_mask
suffix:semicolon
id|memcpy
c_func
(paren
id|lline-&gt;line
comma
id|line
comma
id|len
)paren
suffix:semicolon
id|lline-&gt;line
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
op_star
id|sline-&gt;lost_tail
op_assign
id|lline
suffix:semicolon
id|sline-&gt;lost_tail
op_assign
op_amp
id|lline-&gt;next
suffix:semicolon
)brace
DECL|struct|combine_diff_state
r_struct
id|combine_diff_state
(brace
DECL|member|xm
r_struct
id|xdiff_emit_state
id|xm
suffix:semicolon
DECL|member|lno
r_int
r_int
id|lno
suffix:semicolon
DECL|member|ob
DECL|member|on
DECL|member|nb
DECL|member|nn
r_int
id|ob
comma
id|on
comma
id|nb
comma
id|nn
suffix:semicolon
DECL|member|nmask
r_int
r_int
id|nmask
suffix:semicolon
DECL|member|num_parent
r_int
id|num_parent
suffix:semicolon
DECL|member|n
r_int
id|n
suffix:semicolon
DECL|member|sline
r_struct
id|sline
op_star
id|sline
suffix:semicolon
DECL|member|lost_bucket
r_struct
id|sline
op_star
id|lost_bucket
suffix:semicolon
)brace
suffix:semicolon
DECL|function|consume_line
r_static
r_void
id|consume_line
c_func
(paren
r_void
op_star
id|state_
comma
r_char
op_star
id|line
comma
r_int
r_int
id|len
)paren
(brace
r_struct
id|combine_diff_state
op_star
id|state
op_assign
id|state_
suffix:semicolon
r_if
c_cond
(paren
l_int|5
OL
id|len
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;@@ -&quot;
comma
id|line
comma
l_int|4
)paren
)paren
(brace
r_if
c_cond
(paren
id|parse_hunk_header
c_func
(paren
id|line
comma
id|len
comma
op_amp
id|state-&gt;ob
comma
op_amp
id|state-&gt;on
comma
op_amp
id|state-&gt;nb
comma
op_amp
id|state-&gt;nn
)paren
)paren
r_return
suffix:semicolon
id|state-&gt;lno
op_assign
id|state-&gt;nb
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|state-&gt;nb
)paren
multiline_comment|/* @@ -1,2 +0,0 @@ to remove the&n;&t;&t;&t; * first two lines...&n;&t;&t;&t; */
id|state-&gt;nb
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;nn
op_eq
l_int|0
)paren
multiline_comment|/* @@ -X,Y +N,0 @@ removed Y lines&n;&t;&t;&t; * that would have come *after* line N&n;&t;&t;&t; * in the result.  Our lost buckets hang&n;&t;&t;&t; * to the line after the removed lines,&n;&t;&t;&t; */
id|state-&gt;lost_bucket
op_assign
op_amp
id|state-&gt;sline
(braket
id|state-&gt;nb
)braket
suffix:semicolon
r_else
id|state-&gt;lost_bucket
op_assign
op_amp
id|state-&gt;sline
(braket
id|state-&gt;nb
op_minus
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|state-&gt;sline
(braket
id|state-&gt;nb
op_minus
l_int|1
)braket
dot
id|p_lno
)paren
id|state-&gt;sline
(braket
id|state-&gt;nb
op_minus
l_int|1
)braket
dot
id|p_lno
op_assign
id|xcalloc
c_func
(paren
id|state-&gt;num_parent
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
id|state-&gt;sline
(braket
id|state-&gt;nb
op_minus
l_int|1
)braket
dot
id|p_lno
(braket
id|state-&gt;n
)braket
op_assign
id|state-&gt;ob
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|state-&gt;lost_bucket
)paren
r_return
suffix:semicolon
multiline_comment|/* not in any hunk yet */
r_switch
c_cond
(paren
id|line
(braket
l_int|0
)braket
)paren
(brace
r_case
l_char|&squot;-&squot;
suffix:colon
id|append_lost
c_func
(paren
id|state-&gt;lost_bucket
comma
id|state-&gt;n
comma
id|line
op_plus
l_int|1
comma
id|len
op_minus
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;+&squot;
suffix:colon
id|state-&gt;sline
(braket
id|state-&gt;lno
op_minus
l_int|1
)braket
dot
id|flag
op_or_assign
id|state-&gt;nmask
suffix:semicolon
id|state-&gt;lno
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|function|combine_diff
r_static
r_void
id|combine_diff
c_func
(paren
r_const
r_int
r_char
op_star
id|parent
comma
id|mmfile_t
op_star
id|result_file
comma
r_struct
id|sline
op_star
id|sline
comma
r_int
id|cnt
comma
r_int
id|n
comma
r_int
id|num_parent
)paren
(brace
r_int
r_int
id|p_lno
comma
id|lno
suffix:semicolon
r_int
r_int
id|nmask
op_assign
(paren
l_int|1UL
op_lshift
id|n
)paren
suffix:semicolon
id|xpparam_t
id|xpp
suffix:semicolon
id|xdemitconf_t
id|xecfg
suffix:semicolon
id|mmfile_t
id|parent_file
suffix:semicolon
id|xdemitcb_t
id|ecb
suffix:semicolon
r_struct
id|combine_diff_state
id|state
suffix:semicolon
r_int
r_int
id|sz
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cnt
)paren
r_return
suffix:semicolon
multiline_comment|/* result deleted */
id|parent_file.ptr
op_assign
id|grab_blob
c_func
(paren
id|parent
comma
op_amp
id|sz
)paren
suffix:semicolon
id|parent_file.size
op_assign
id|sz
suffix:semicolon
id|xpp.flags
op_assign
id|XDF_NEED_MINIMAL
suffix:semicolon
id|xecfg.ctxlen
op_assign
l_int|0
suffix:semicolon
id|xecfg.flags
op_assign
l_int|0
suffix:semicolon
id|ecb.outf
op_assign
id|xdiff_outf
suffix:semicolon
id|ecb.priv
op_assign
op_amp
id|state
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|state
comma
l_int|0
comma
r_sizeof
(paren
id|state
)paren
)paren
suffix:semicolon
id|state.xm.consume
op_assign
id|consume_line
suffix:semicolon
id|state.nmask
op_assign
id|nmask
suffix:semicolon
id|state.sline
op_assign
id|sline
suffix:semicolon
id|state.lno
op_assign
l_int|1
suffix:semicolon
id|state.num_parent
op_assign
id|num_parent
suffix:semicolon
id|state.n
op_assign
id|n
suffix:semicolon
id|xdl_diff
c_func
(paren
op_amp
id|parent_file
comma
id|result_file
comma
op_amp
id|xpp
comma
op_amp
id|xecfg
comma
op_amp
id|ecb
)paren
suffix:semicolon
id|free
c_func
(paren
id|parent_file.ptr
)paren
suffix:semicolon
multiline_comment|/* Assign line numbers for this parent.&n;&t; *&n;&t; * sline[lno].p_lno[n] records the first line number&n;&t; * (counting from 1) for parent N if the final hunk display&n;&t; * started by showing sline[lno] (possibly showing the lost&n;&t; * lines attached to it first).&n;&t; */
r_for
c_loop
(paren
id|lno
op_assign
l_int|0
comma
id|p_lno
op_assign
l_int|1
suffix:semicolon
id|lno
op_le
id|cnt
suffix:semicolon
id|lno
op_increment
)paren
(brace
r_struct
id|lline
op_star
id|ll
suffix:semicolon
id|sline
(braket
id|lno
)braket
dot
id|p_lno
(braket
id|n
)braket
op_assign
id|p_lno
suffix:semicolon
multiline_comment|/* How many lines would this sline advance the p_lno? */
id|ll
op_assign
id|sline
(braket
id|lno
)braket
dot
id|lost_head
suffix:semicolon
r_while
c_loop
(paren
id|ll
)paren
(brace
r_if
c_cond
(paren
id|ll-&gt;parent_map
op_amp
id|nmask
)paren
id|p_lno
op_increment
suffix:semicolon
multiline_comment|/* &squot;-&squot; means parent had it */
id|ll
op_assign
id|ll-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lno
OL
id|cnt
op_logical_and
op_logical_neg
(paren
id|sline
(braket
id|lno
)braket
dot
id|flag
op_amp
id|nmask
)paren
)paren
id|p_lno
op_increment
suffix:semicolon
multiline_comment|/* no &squot;+&squot; means parent had it */
)brace
id|sline
(braket
id|lno
)braket
dot
id|p_lno
(braket
id|n
)braket
op_assign
id|p_lno
suffix:semicolon
multiline_comment|/* trailer */
)brace
DECL|variable|context
r_static
r_int
r_int
id|context
op_assign
l_int|3
suffix:semicolon
DECL|variable|combine_marker
r_static
r_char
id|combine_marker
op_assign
l_char|&squot;@&squot;
suffix:semicolon
DECL|function|interesting
r_static
r_int
id|interesting
c_func
(paren
r_struct
id|sline
op_star
id|sline
comma
r_int
r_int
id|all_mask
)paren
(brace
multiline_comment|/* If some parents lost lines here, or if we have added to&n;&t; * some parent, it is interesting.&n;&t; */
r_return
(paren
(paren
id|sline-&gt;flag
op_amp
id|all_mask
)paren
op_logical_or
id|sline-&gt;lost_head
)paren
suffix:semicolon
)brace
DECL|function|adjust_hunk_tail
r_static
r_int
r_int
id|adjust_hunk_tail
c_func
(paren
r_struct
id|sline
op_star
id|sline
comma
r_int
r_int
id|all_mask
comma
r_int
r_int
id|hunk_begin
comma
r_int
r_int
id|i
)paren
(brace
multiline_comment|/* i points at the first uninteresting line.  If the last line&n;&t; * of the hunk was interesting only because it has some&n;&t; * deletion, then it is not all that interesting for the&n;&t; * purpose of giving trailing context lines.  This is because&n;&t; * we output &squot;-&squot; line and then unmodified sline[i-1] itself in&n;&t; * that case which gives us one extra context line.&n;&t; */
r_if
c_cond
(paren
(paren
id|hunk_begin
op_plus
l_int|1
op_le
id|i
)paren
op_logical_and
op_logical_neg
(paren
id|sline
(braket
id|i
op_minus
l_int|1
)braket
dot
id|flag
op_amp
id|all_mask
)paren
)paren
id|i
op_decrement
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
DECL|function|find_next
r_static
r_int
r_int
id|find_next
c_func
(paren
r_struct
id|sline
op_star
id|sline
comma
r_int
r_int
id|mark
comma
r_int
r_int
id|i
comma
r_int
r_int
id|cnt
comma
r_int
id|uninteresting
)paren
(brace
multiline_comment|/* We have examined up to i-1 and are about to look at i.&n;&t; * Find next interesting or uninteresting line.  Here,&n;&t; * &quot;interesting&quot; does not mean interesting(), but marked by&n;&t; * the give_context() function below (i.e. it includes context&n;&t; * lines that are not interesting to interesting() function&n;&t; * that are surrounded by interesting() ones.&n;&t; */
r_while
c_loop
(paren
id|i
op_le
id|cnt
)paren
r_if
c_cond
(paren
id|uninteresting
ques
c_cond
op_logical_neg
(paren
id|sline
(braket
id|i
)braket
dot
id|flag
op_amp
id|mark
)paren
suffix:colon
(paren
id|sline
(braket
id|i
)braket
dot
id|flag
op_amp
id|mark
)paren
)paren
r_return
id|i
suffix:semicolon
r_else
id|i
op_increment
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
DECL|function|give_context
r_static
r_int
id|give_context
c_func
(paren
r_struct
id|sline
op_star
id|sline
comma
r_int
r_int
id|cnt
comma
r_int
id|num_parent
)paren
(brace
r_int
r_int
id|all_mask
op_assign
(paren
l_int|1UL
op_lshift
id|num_parent
)paren
l_int|1
suffix:semicolon
r_int
r_int
id|mark
op_assign
(paren
l_int|1UL
op_lshift
id|num_parent
)paren
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
multiline_comment|/* Two groups of interesting lines may have a short gap of&n;&t; * unintersting lines.  Connect such groups to give them a&n;&t; * bit of context.&n;&t; *&n;&t; * We first start from what the interesting() function says,&n;&t; * and mark them with &quot;mark&quot;, and paint context lines with the&n;&t; * mark.  So interesting() would still say false for such context&n;&t; * lines but they are treated as &quot;interesting&quot; in the end.&n;&t; */
id|i
op_assign
id|find_next
c_func
(paren
id|sline
comma
id|mark
comma
l_int|0
comma
id|cnt
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cnt
OL
id|i
)paren
r_return
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|i
op_le
id|cnt
)paren
(brace
r_int
r_int
id|j
op_assign
(paren
id|context
OL
id|i
)paren
ques
c_cond
(paren
id|i
id|context
)paren
suffix:colon
l_int|0
suffix:semicolon
r_int
r_int
id|k
suffix:semicolon
multiline_comment|/* Paint a few lines before the first interesting line. */
r_while
c_loop
(paren
id|j
OL
id|i
)paren
id|sline
(braket
id|j
op_increment
)braket
dot
id|flag
op_or_assign
id|mark
suffix:semicolon
id|again
suffix:colon
multiline_comment|/* we know up to i is to be included.  where does the&n;&t;&t; * next uninteresting one start?&n;&t;&t; */
id|j
op_assign
id|find_next
c_func
(paren
id|sline
comma
id|mark
comma
id|i
comma
id|cnt
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cnt
OL
id|j
)paren
r_break
suffix:semicolon
multiline_comment|/* the rest are all interesting */
multiline_comment|/* lookahead context lines */
id|k
op_assign
id|find_next
c_func
(paren
id|sline
comma
id|mark
comma
id|j
comma
id|cnt
comma
l_int|0
)paren
suffix:semicolon
id|j
op_assign
id|adjust_hunk_tail
c_func
(paren
id|sline
comma
id|all_mask
comma
id|i
comma
id|j
)paren
suffix:semicolon
r_if
c_cond
(paren
id|k
OL
id|j
op_plus
id|context
)paren
(brace
multiline_comment|/* k is interesting and [j,k) are not, but&n;&t;&t;&t; * paint them interesting because the gap is small.&n;&t;&t;&t; */
r_while
c_loop
(paren
id|j
OL
id|k
)paren
id|sline
(braket
id|j
op_increment
)braket
dot
id|flag
op_or_assign
id|mark
suffix:semicolon
id|i
op_assign
id|k
suffix:semicolon
r_goto
id|again
suffix:semicolon
)brace
multiline_comment|/* j is the first uninteresting line and there is&n;&t;&t; * no overlap beyond it within context lines.  Paint&n;&t;&t; * the trailing edge a bit.&n;&t;&t; */
id|i
op_assign
id|k
suffix:semicolon
id|k
op_assign
(paren
id|j
op_plus
id|context
OL
id|cnt
op_plus
l_int|1
)paren
ques
c_cond
id|j
op_plus
id|context
suffix:colon
id|cnt
op_plus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|j
OL
id|k
)paren
id|sline
(braket
id|j
op_increment
)braket
dot
id|flag
op_or_assign
id|mark
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|make_hunks
r_static
r_int
id|make_hunks
c_func
(paren
r_struct
id|sline
op_star
id|sline
comma
r_int
r_int
id|cnt
comma
r_int
id|num_parent
comma
r_int
id|dense
)paren
(brace
r_int
r_int
id|all_mask
op_assign
(paren
l_int|1UL
op_lshift
id|num_parent
)paren
l_int|1
suffix:semicolon
r_int
r_int
id|mark
op_assign
(paren
l_int|1UL
op_lshift
id|num_parent
)paren
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_int
id|has_interesting
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|interesting
c_func
(paren
op_amp
id|sline
(braket
id|i
)braket
comma
id|all_mask
)paren
)paren
id|sline
(braket
id|i
)braket
dot
id|flag
op_or_assign
id|mark
suffix:semicolon
r_else
id|sline
(braket
id|i
)braket
dot
id|flag
op_and_assign
op_complement
id|mark
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|dense
)paren
r_return
id|give_context
c_func
(paren
id|sline
comma
id|cnt
comma
id|num_parent
)paren
suffix:semicolon
multiline_comment|/* Look at each hunk, and if we have changes from only one&n;&t; * parent, or the changes are the same from all but one&n;&t; * parent, mark that uninteresting.&n;&t; */
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|i
op_le
id|cnt
)paren
(brace
r_int
r_int
id|j
comma
id|hunk_begin
comma
id|hunk_end
suffix:semicolon
r_int
r_int
id|same_diff
suffix:semicolon
r_while
c_loop
(paren
id|i
op_le
id|cnt
op_logical_and
op_logical_neg
(paren
id|sline
(braket
id|i
)braket
dot
id|flag
op_amp
id|mark
)paren
)paren
id|i
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|cnt
OL
id|i
)paren
r_break
suffix:semicolon
multiline_comment|/* No more interesting hunks */
id|hunk_begin
op_assign
id|i
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
id|j
op_le
id|cnt
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|sline
(braket
id|j
)braket
dot
id|flag
op_amp
id|mark
)paren
)paren
(brace
multiline_comment|/* Look beyond the end to see if there&n;&t;&t;&t;&t; * is an interesting line after this&n;&t;&t;&t;&t; * hunk within context span.&n;&t;&t;&t;&t; */
r_int
r_int
id|la
suffix:semicolon
multiline_comment|/* lookahead */
r_int
id|contin
op_assign
l_int|0
suffix:semicolon
id|la
op_assign
id|adjust_hunk_tail
c_func
(paren
id|sline
comma
id|all_mask
comma
id|hunk_begin
comma
id|j
)paren
suffix:semicolon
id|la
op_assign
(paren
id|la
op_plus
id|context
OL
id|cnt
op_plus
l_int|1
)paren
ques
c_cond
(paren
id|la
op_plus
id|context
)paren
suffix:colon
id|cnt
op_plus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|j
op_le
op_decrement
id|la
)paren
(brace
r_if
c_cond
(paren
id|sline
(braket
id|la
)braket
dot
id|flag
op_amp
id|mark
)paren
(brace
id|contin
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|contin
)paren
r_break
suffix:semicolon
id|j
op_assign
id|la
suffix:semicolon
)brace
)brace
id|hunk_end
op_assign
id|j
suffix:semicolon
multiline_comment|/* [i..hunk_end) are interesting.  Now is it really&n;&t;&t; * interesting?  We check if there are only two versions&n;&t;&t; * and the result matches one of them.  That is, we look&n;&t;&t; * at:&n;&t;&t; *   (+) line, which records lines added to which parents;&n;&t;&t; *       this line appears in the result.&n;&t;&t; *   (-) line, which records from what parents the line&n;&t;&t; *       was removed; this line does not appear in the result.&n;&t;&t; * then check the set of parents the result has difference&n;&t;&t; * from, from all lines.  If there are lines that has&n;&t;&t; * different set of parents that the result has differences&n;&t;&t; * from, that means we have more than two versions.&n;&t;&t; *&n;&t;&t; * Even when we have only two versions, if the result does&n;&t;&t; * not match any of the parents, the it should be considered&n;&t;&t; * interesting.  In such a case, we would have all &squot;+&squot; line.&n;&t;&t; * After passing the above &quot;two versions&quot; test, that would&n;&t;&t; * appear as &quot;the same set of parents&quot; to be &quot;all parents&quot;.&n;&t;&t; */
id|same_diff
op_assign
l_int|0
suffix:semicolon
id|has_interesting
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|i
suffix:semicolon
id|j
OL
id|hunk_end
op_logical_and
op_logical_neg
id|has_interesting
suffix:semicolon
id|j
op_increment
)paren
(brace
r_int
r_int
id|this_diff
op_assign
id|sline
(braket
id|j
)braket
dot
id|flag
op_amp
id|all_mask
suffix:semicolon
r_struct
id|lline
op_star
id|ll
op_assign
id|sline
(braket
id|j
)braket
dot
id|lost_head
suffix:semicolon
r_if
c_cond
(paren
id|this_diff
)paren
(brace
multiline_comment|/* This has some changes.  Is it the&n;&t;&t;&t;&t; * same as others?&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|same_diff
)paren
id|same_diff
op_assign
id|this_diff
suffix:semicolon
r_else
r_if
c_cond
(paren
id|same_diff
op_ne
id|this_diff
)paren
(brace
id|has_interesting
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|ll
op_logical_and
op_logical_neg
id|has_interesting
)paren
(brace
multiline_comment|/* Lost this line from these parents;&n;&t;&t;&t;&t; * who are they?  Are they the same?&n;&t;&t;&t;&t; */
id|this_diff
op_assign
id|ll-&gt;parent_map
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|same_diff
)paren
id|same_diff
op_assign
id|this_diff
suffix:semicolon
r_else
r_if
c_cond
(paren
id|same_diff
op_ne
id|this_diff
)paren
(brace
id|has_interesting
op_assign
l_int|1
suffix:semicolon
)brace
id|ll
op_assign
id|ll-&gt;next
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|has_interesting
op_logical_and
id|same_diff
op_ne
id|all_mask
)paren
(brace
multiline_comment|/* This hunk is not that interesting after all */
r_for
c_loop
(paren
id|j
op_assign
id|hunk_begin
suffix:semicolon
id|j
OL
id|hunk_end
suffix:semicolon
id|j
op_increment
)paren
id|sline
(braket
id|j
)braket
dot
id|flag
op_and_assign
op_complement
id|mark
suffix:semicolon
)brace
id|i
op_assign
id|hunk_end
suffix:semicolon
)brace
id|has_interesting
op_assign
id|give_context
c_func
(paren
id|sline
comma
id|cnt
comma
id|num_parent
)paren
suffix:semicolon
r_return
id|has_interesting
suffix:semicolon
)brace
DECL|function|show_parent_lno
r_static
r_void
id|show_parent_lno
c_func
(paren
r_struct
id|sline
op_star
id|sline
comma
r_int
r_int
id|l0
comma
r_int
r_int
id|l1
comma
r_int
r_int
id|cnt
comma
r_int
id|n
)paren
(brace
id|l0
op_assign
id|sline
(braket
id|l0
)braket
dot
id|p_lno
(braket
id|n
)braket
suffix:semicolon
id|l1
op_assign
id|sline
(braket
id|l1
)braket
dot
id|p_lno
(braket
id|n
)braket
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot; -%lu,%lu&quot;
comma
id|l0
comma
id|l1
op_minus
id|l0
)paren
suffix:semicolon
)brace
DECL|function|dump_sline
r_static
r_void
id|dump_sline
c_func
(paren
r_struct
id|sline
op_star
id|sline
comma
r_int
r_int
id|cnt
comma
r_int
id|num_parent
)paren
(brace
r_int
r_int
id|mark
op_assign
(paren
l_int|1UL
op_lshift
id|num_parent
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|lno
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cnt
)paren
r_return
suffix:semicolon
multiline_comment|/* result deleted */
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_struct
id|sline
op_star
id|sl
op_assign
op_amp
id|sline
(braket
id|lno
)braket
suffix:semicolon
r_int
r_int
id|hunk_end
suffix:semicolon
r_int
r_int
id|rlines
suffix:semicolon
r_while
c_loop
(paren
id|lno
op_le
id|cnt
op_logical_and
op_logical_neg
(paren
id|sline
(braket
id|lno
)braket
dot
id|flag
op_amp
id|mark
)paren
)paren
id|lno
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|cnt
OL
id|lno
)paren
r_break
suffix:semicolon
r_else
(brace
r_for
c_loop
(paren
id|hunk_end
op_assign
id|lno
op_plus
l_int|1
suffix:semicolon
id|hunk_end
op_le
id|cnt
suffix:semicolon
id|hunk_end
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
(paren
id|sline
(braket
id|hunk_end
)braket
dot
id|flag
op_amp
id|mark
)paren
)paren
r_break
suffix:semicolon
)brace
id|rlines
op_assign
id|hunk_end
id|lno
suffix:semicolon
r_if
c_cond
(paren
id|cnt
OL
id|hunk_end
)paren
id|rlines
op_decrement
suffix:semicolon
multiline_comment|/* pointing at the last delete hunk */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|num_parent
suffix:semicolon
id|i
op_increment
)paren
id|putchar
c_func
(paren
id|combine_marker
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_parent
suffix:semicolon
id|i
op_increment
)paren
id|show_parent_lno
c_func
(paren
id|sline
comma
id|lno
comma
id|hunk_end
comma
id|cnt
comma
id|i
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot; +%lu,%lu &quot;
comma
id|lno
op_plus
l_int|1
comma
id|rlines
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|num_parent
suffix:semicolon
id|i
op_increment
)paren
id|putchar
c_func
(paren
id|combine_marker
)paren
suffix:semicolon
id|putchar
c_func
(paren
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|lno
OL
id|hunk_end
)paren
(brace
r_struct
id|lline
op_star
id|ll
suffix:semicolon
r_int
id|j
suffix:semicolon
r_int
r_int
id|p_mask
suffix:semicolon
id|sl
op_assign
op_amp
id|sline
(braket
id|lno
op_increment
)braket
suffix:semicolon
id|ll
op_assign
id|sl-&gt;lost_head
suffix:semicolon
r_while
c_loop
(paren
id|ll
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|num_parent
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ll-&gt;parent_map
op_amp
(paren
l_int|1UL
op_lshift
id|j
)paren
)paren
id|putchar
c_func
(paren
l_char|&squot;-&squot;
)paren
suffix:semicolon
r_else
id|putchar
c_func
(paren
l_char|&squot; &squot;
)paren
suffix:semicolon
)brace
id|puts
c_func
(paren
id|ll-&gt;line
)paren
suffix:semicolon
id|ll
op_assign
id|ll-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cnt
OL
id|lno
)paren
r_break
suffix:semicolon
id|p_mask
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|num_parent
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|p_mask
op_amp
id|sl-&gt;flag
)paren
id|putchar
c_func
(paren
l_char|&squot;+&squot;
)paren
suffix:semicolon
r_else
id|putchar
c_func
(paren
l_char|&squot; &squot;
)paren
suffix:semicolon
id|p_mask
op_lshift_assign
l_int|1
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;%.*s&bslash;n&quot;
comma
id|sl-&gt;len
comma
id|sl-&gt;bol
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|reuse_combine_diff
r_static
r_void
id|reuse_combine_diff
c_func
(paren
r_struct
id|sline
op_star
id|sline
comma
r_int
r_int
id|cnt
comma
r_int
id|i
comma
r_int
id|j
)paren
(brace
multiline_comment|/* We have already examined parent j and we know parent i&n;&t; * and parent j are the same, so reuse the combined result&n;&t; * of parent j for parent i.&n;&t; */
r_int
r_int
id|lno
comma
id|imask
comma
id|jmask
suffix:semicolon
id|imask
op_assign
(paren
l_int|1UL
op_lshift
id|i
)paren
suffix:semicolon
id|jmask
op_assign
(paren
l_int|1UL
op_lshift
id|j
)paren
suffix:semicolon
r_for
c_loop
(paren
id|lno
op_assign
l_int|0
suffix:semicolon
id|lno
op_le
id|cnt
suffix:semicolon
id|lno
op_increment
)paren
(brace
r_struct
id|lline
op_star
id|ll
op_assign
id|sline-&gt;lost_head
suffix:semicolon
id|sline-&gt;p_lno
(braket
id|i
)braket
op_assign
id|sline-&gt;p_lno
(braket
id|j
)braket
suffix:semicolon
r_while
c_loop
(paren
id|ll
)paren
(brace
r_if
c_cond
(paren
id|ll-&gt;parent_map
op_amp
id|jmask
)paren
id|ll-&gt;parent_map
op_or_assign
id|imask
suffix:semicolon
id|ll
op_assign
id|ll-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sline-&gt;flag
op_amp
id|jmask
)paren
id|sline-&gt;flag
op_or_assign
id|imask
suffix:semicolon
id|sline
op_increment
suffix:semicolon
)brace
multiline_comment|/* the overall size of the file (sline[cnt]) */
id|sline-&gt;p_lno
(braket
id|i
)braket
op_assign
id|sline-&gt;p_lno
(braket
id|j
)braket
suffix:semicolon
)brace
DECL|function|dump_quoted_path
r_static
r_void
id|dump_quoted_path
c_func
(paren
r_const
r_char
op_star
id|prefix
comma
r_const
r_char
op_star
id|path
)paren
(brace
id|fputs
c_func
(paren
id|prefix
comma
id|stdout
)paren
suffix:semicolon
r_if
c_cond
(paren
id|quote_c_style
c_func
(paren
id|path
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|0
)paren
)paren
id|quote_c_style
c_func
(paren
id|path
comma
l_int|NULL
comma
id|stdout
comma
l_int|0
)paren
suffix:semicolon
r_else
id|printf
c_func
(paren
l_string|&quot;%s&quot;
comma
id|path
)paren
suffix:semicolon
id|putchar
c_func
(paren
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
DECL|function|show_patch_diff
r_static
r_int
id|show_patch_diff
c_func
(paren
r_struct
id|combine_diff_path
op_star
id|elem
comma
r_int
id|num_parent
comma
r_int
id|dense
comma
r_struct
id|rev_info
op_star
id|rev
)paren
(brace
r_struct
id|diff_options
op_star
id|opt
op_assign
op_amp
id|rev-&gt;diffopt
suffix:semicolon
r_int
r_int
id|result_size
comma
id|cnt
comma
id|lno
suffix:semicolon
r_char
op_star
id|result
comma
op_star
id|cp
suffix:semicolon
r_struct
id|sline
op_star
id|sline
suffix:semicolon
multiline_comment|/* survived lines */
r_int
id|mode_differs
op_assign
l_int|0
suffix:semicolon
r_int
id|i
comma
id|show_hunks
comma
id|shown_header
op_assign
l_int|0
suffix:semicolon
r_int
id|working_tree_file
op_assign
op_logical_neg
id|memcmp
c_func
(paren
id|elem-&gt;sha1
comma
id|null_sha1
comma
l_int|20
)paren
suffix:semicolon
r_int
id|abbrev
op_assign
id|opt-&gt;full_index
ques
c_cond
l_int|40
suffix:colon
id|DEFAULT_ABBREV
suffix:semicolon
id|mmfile_t
id|result_file
suffix:semicolon
id|context
op_assign
id|opt-&gt;context
suffix:semicolon
multiline_comment|/* Read the result of merge first */
r_if
c_cond
(paren
op_logical_neg
id|working_tree_file
)paren
id|result
op_assign
id|grab_blob
c_func
(paren
id|elem-&gt;sha1
comma
op_amp
id|result_size
)paren
suffix:semicolon
r_else
(brace
multiline_comment|/* Used by diff-tree to read from the working tree */
r_struct
id|stat
id|st
suffix:semicolon
r_int
id|fd
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_le
(paren
id|fd
op_assign
id|open
c_func
(paren
id|elem-&gt;path
comma
id|O_RDONLY
)paren
)paren
op_logical_and
op_logical_neg
id|fstat
c_func
(paren
id|fd
comma
op_amp
id|st
)paren
)paren
(brace
r_int
id|len
op_assign
id|st.st_size
suffix:semicolon
r_int
id|cnt
op_assign
l_int|0
suffix:semicolon
id|elem-&gt;mode
op_assign
id|canon_mode
c_func
(paren
id|st.st_mode
)paren
suffix:semicolon
id|result_size
op_assign
id|len
suffix:semicolon
id|result
op_assign
id|xmalloc
c_func
(paren
id|len
op_plus
l_int|1
)paren
suffix:semicolon
r_while
c_loop
(paren
id|cnt
OL
id|len
)paren
(brace
r_int
id|done
op_assign
id|xread
c_func
(paren
id|fd
comma
id|result
op_plus
id|cnt
comma
id|len
op_minus
id|cnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|done
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|done
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;read error &squot;%s&squot;&quot;
comma
id|elem-&gt;path
)paren
suffix:semicolon
id|cnt
op_add_assign
id|done
suffix:semicolon
)brace
id|result
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* deleted file */
id|result_size
op_assign
l_int|0
suffix:semicolon
id|elem-&gt;mode
op_assign
l_int|0
suffix:semicolon
id|result
op_assign
id|xmalloc
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|result
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
l_int|0
op_le
id|fd
)paren
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
comma
id|cp
op_assign
id|result
suffix:semicolon
id|cp
id|result
OL
id|result_size
suffix:semicolon
id|cp
op_increment
)paren
(brace
r_if
c_cond
(paren
op_star
id|cp
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|cnt
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result_size
op_logical_and
id|result
(braket
id|result_size
op_minus
l_int|1
)braket
op_ne
l_char|&squot;&bslash;n&squot;
)paren
id|cnt
op_increment
suffix:semicolon
multiline_comment|/* incomplete line */
id|sline
op_assign
id|xcalloc
c_func
(paren
id|cnt
op_plus
l_int|2
comma
r_sizeof
(paren
op_star
id|sline
)paren
)paren
suffix:semicolon
id|sline
(braket
l_int|0
)braket
dot
id|bol
op_assign
id|result
suffix:semicolon
r_for
c_loop
(paren
id|lno
op_assign
l_int|0
suffix:semicolon
id|lno
op_le
id|cnt
op_plus
l_int|1
suffix:semicolon
id|lno
op_increment
)paren
(brace
id|sline
(braket
id|lno
)braket
dot
id|lost_tail
op_assign
op_amp
id|sline
(braket
id|lno
)braket
dot
id|lost_head
suffix:semicolon
id|sline
(braket
id|lno
)braket
dot
id|flag
op_assign
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|lno
op_assign
l_int|0
comma
id|cp
op_assign
id|result
suffix:semicolon
id|cp
id|result
OL
id|result_size
suffix:semicolon
id|cp
op_increment
)paren
(brace
r_if
c_cond
(paren
op_star
id|cp
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|sline
(braket
id|lno
)braket
dot
id|len
op_assign
id|cp
id|sline
(braket
id|lno
)braket
dot
id|bol
suffix:semicolon
id|lno
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|lno
OL
id|cnt
)paren
id|sline
(braket
id|lno
)braket
dot
id|bol
op_assign
id|cp
op_plus
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|result_size
op_logical_and
id|result
(braket
id|result_size
op_minus
l_int|1
)braket
op_ne
l_char|&squot;&bslash;n&squot;
)paren
id|sline
(braket
id|cnt
op_minus
l_int|1
)braket
dot
id|len
op_assign
id|result_size
(paren
id|sline
(braket
id|cnt
op_minus
l_int|1
)braket
dot
id|bol
id|result
)paren
suffix:semicolon
id|result_file.ptr
op_assign
id|result
suffix:semicolon
id|result_file.size
op_assign
id|result_size
suffix:semicolon
multiline_comment|/* Even p_lno[cnt+1] is valid -- that is for the end line number&n;&t; * for deletion hunk at the end.&n;&t; */
id|sline
(braket
l_int|0
)braket
dot
id|p_lno
op_assign
id|xcalloc
c_func
(paren
(paren
id|cnt
op_plus
l_int|2
)paren
op_star
id|num_parent
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|lno
op_assign
l_int|0
suffix:semicolon
id|lno
op_le
id|cnt
suffix:semicolon
id|lno
op_increment
)paren
id|sline
(braket
id|lno
op_plus
l_int|1
)braket
dot
id|p_lno
op_assign
id|sline
(braket
id|lno
)braket
dot
id|p_lno
op_plus
id|num_parent
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_parent
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|j
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|i
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|elem-&gt;parent
(braket
id|i
)braket
dot
id|sha1
comma
id|elem-&gt;parent
(braket
id|j
)braket
dot
id|sha1
comma
l_int|20
)paren
)paren
(brace
id|reuse_combine_diff
c_func
(paren
id|sline
comma
id|cnt
comma
id|i
comma
id|j
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|i
op_le
id|j
)paren
id|combine_diff
c_func
(paren
id|elem-&gt;parent
(braket
id|i
)braket
dot
id|sha1
comma
op_amp
id|result_file
comma
id|sline
comma
id|cnt
comma
id|i
comma
id|num_parent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|elem-&gt;parent
(braket
id|i
)braket
dot
id|mode
op_ne
id|elem-&gt;mode
)paren
id|mode_differs
op_assign
l_int|1
suffix:semicolon
)brace
id|show_hunks
op_assign
id|make_hunks
c_func
(paren
id|sline
comma
id|cnt
comma
id|num_parent
comma
id|dense
)paren
suffix:semicolon
r_if
c_cond
(paren
id|show_hunks
op_logical_or
id|mode_differs
op_logical_or
id|working_tree_file
)paren
(brace
r_const
r_char
op_star
id|abb
suffix:semicolon
r_if
c_cond
(paren
id|rev-&gt;loginfo
)paren
id|show_log
c_func
(paren
id|rev
comma
id|opt-&gt;msg_sep
)paren
suffix:semicolon
id|dump_quoted_path
c_func
(paren
id|dense
ques
c_cond
l_string|&quot;diff --cc &quot;
suffix:colon
l_string|&quot;diff --combined &quot;
comma
id|elem-&gt;path
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;index &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_parent
suffix:semicolon
id|i
op_increment
)paren
(brace
id|abb
op_assign
id|find_unique_abbrev
c_func
(paren
id|elem-&gt;parent
(braket
id|i
)braket
dot
id|sha1
comma
id|abbrev
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s%s&quot;
comma
id|i
ques
c_cond
l_string|&quot;,&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|abb
)paren
suffix:semicolon
)brace
id|abb
op_assign
id|find_unique_abbrev
c_func
(paren
id|elem-&gt;sha1
comma
id|abbrev
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;..%s&bslash;n&quot;
comma
id|abb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mode_differs
)paren
(brace
r_int
id|added
op_assign
op_logical_neg
op_logical_neg
id|elem-&gt;mode
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|added
op_logical_and
id|i
OL
id|num_parent
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|elem-&gt;parent
(braket
id|i
)braket
dot
id|status
op_ne
id|DIFF_STATUS_ADDED
)paren
id|added
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|added
)paren
id|printf
c_func
(paren
l_string|&quot;new file mode %06o&quot;
comma
id|elem-&gt;mode
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|elem-&gt;mode
)paren
id|printf
c_func
(paren
l_string|&quot;deleted file &quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;mode &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_parent
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s%06o&quot;
comma
id|i
ques
c_cond
l_string|&quot;,&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|elem-&gt;parent
(braket
id|i
)braket
dot
id|mode
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|elem-&gt;mode
)paren
id|printf
c_func
(paren
l_string|&quot;..%06o&quot;
comma
id|elem-&gt;mode
)paren
suffix:semicolon
)brace
id|putchar
c_func
(paren
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
id|dump_quoted_path
c_func
(paren
l_string|&quot;--- a/&quot;
comma
id|elem-&gt;path
)paren
suffix:semicolon
id|dump_quoted_path
c_func
(paren
l_string|&quot;+++ b/&quot;
comma
id|elem-&gt;path
)paren
suffix:semicolon
id|dump_sline
c_func
(paren
id|sline
comma
id|cnt
comma
id|num_parent
)paren
suffix:semicolon
)brace
id|free
c_func
(paren
id|result
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|sline
(braket
id|i
)braket
dot
id|lost_head
)paren
(brace
r_struct
id|lline
op_star
id|ll
op_assign
id|sline
(braket
id|i
)braket
dot
id|lost_head
suffix:semicolon
r_while
c_loop
(paren
id|ll
)paren
(brace
r_struct
id|lline
op_star
id|tmp
op_assign
id|ll
suffix:semicolon
id|ll
op_assign
id|ll-&gt;next
suffix:semicolon
id|free
c_func
(paren
id|tmp
)paren
suffix:semicolon
)brace
)brace
)brace
id|free
c_func
(paren
id|sline
(braket
l_int|0
)braket
dot
id|p_lno
)paren
suffix:semicolon
id|free
c_func
(paren
id|sline
)paren
suffix:semicolon
r_return
id|shown_header
suffix:semicolon
)brace
DECL|macro|COLONS
mdefine_line|#define COLONS &quot;::::::::::::::::::::::::::::::::&quot;
DECL|function|show_raw_diff
r_static
r_void
id|show_raw_diff
c_func
(paren
r_struct
id|combine_diff_path
op_star
id|p
comma
r_int
id|num_parent
comma
r_struct
id|rev_info
op_star
id|rev
)paren
(brace
r_struct
id|diff_options
op_star
id|opt
op_assign
op_amp
id|rev-&gt;diffopt
suffix:semicolon
r_int
id|i
comma
id|offset
suffix:semicolon
r_const
r_char
op_star
id|prefix
suffix:semicolon
r_int
id|line_termination
comma
id|inter_name_termination
suffix:semicolon
id|line_termination
op_assign
id|opt-&gt;line_termination
suffix:semicolon
id|inter_name_termination
op_assign
l_char|&squot;&bslash;t&squot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|line_termination
)paren
id|inter_name_termination
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|rev-&gt;loginfo
)paren
id|show_log
c_func
(paren
id|rev
comma
id|opt-&gt;msg_sep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opt-&gt;output_format
op_amp
id|DIFF_FORMAT_RAW
)paren
(brace
id|offset
op_assign
id|strlen
c_func
(paren
id|COLONS
)paren
id|num_parent
suffix:semicolon
r_if
c_cond
(paren
id|offset
OL
l_int|0
)paren
id|offset
op_assign
l_int|0
suffix:semicolon
id|prefix
op_assign
id|COLONS
op_plus
id|offset
suffix:semicolon
multiline_comment|/* Show the modes */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_parent
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s%06o&quot;
comma
id|prefix
comma
id|p-&gt;parent
(braket
id|i
)braket
dot
id|mode
)paren
suffix:semicolon
id|prefix
op_assign
l_string|&quot; &quot;
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;%s%06o&quot;
comma
id|prefix
comma
id|p-&gt;mode
)paren
suffix:semicolon
multiline_comment|/* Show sha1&squot;s */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_parent
suffix:semicolon
id|i
op_increment
)paren
id|printf
c_func
(paren
l_string|&quot; %s&quot;
comma
id|diff_unique_abbrev
c_func
(paren
id|p-&gt;parent
(braket
id|i
)braket
dot
id|sha1
comma
id|opt-&gt;abbrev
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot; %s &quot;
comma
id|diff_unique_abbrev
c_func
(paren
id|p-&gt;sha1
comma
id|opt-&gt;abbrev
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|opt-&gt;output_format
op_amp
(paren
id|DIFF_FORMAT_RAW
op_or
id|DIFF_FORMAT_NAME_STATUS
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_parent
suffix:semicolon
id|i
op_increment
)paren
id|putchar
c_func
(paren
id|p-&gt;parent
(braket
id|i
)braket
dot
id|status
)paren
suffix:semicolon
id|putchar
c_func
(paren
id|inter_name_termination
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|line_termination
)paren
(brace
r_if
c_cond
(paren
id|quote_c_style
c_func
(paren
id|p-&gt;path
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|0
)paren
)paren
id|quote_c_style
c_func
(paren
id|p-&gt;path
comma
l_int|NULL
comma
id|stdout
comma
l_int|0
)paren
suffix:semicolon
r_else
id|printf
c_func
(paren
l_string|&quot;%s&quot;
comma
id|p-&gt;path
)paren
suffix:semicolon
id|putchar
c_func
(paren
id|line_termination
)paren
suffix:semicolon
)brace
r_else
(brace
id|printf
c_func
(paren
l_string|&quot;%s%c&quot;
comma
id|p-&gt;path
comma
id|line_termination
)paren
suffix:semicolon
)brace
)brace
DECL|function|show_combined_diff
r_void
id|show_combined_diff
c_func
(paren
r_struct
id|combine_diff_path
op_star
id|p
comma
r_int
id|num_parent
comma
r_int
id|dense
comma
r_struct
id|rev_info
op_star
id|rev
)paren
(brace
r_struct
id|diff_options
op_star
id|opt
op_assign
op_amp
id|rev-&gt;diffopt
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;len
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|opt-&gt;output_format
op_amp
(paren
id|DIFF_FORMAT_RAW
op_or
id|DIFF_FORMAT_NAME
op_or
id|DIFF_FORMAT_NAME_STATUS
)paren
)paren
(brace
id|show_raw_diff
c_func
(paren
id|p
comma
id|num_parent
comma
id|rev
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|opt-&gt;output_format
op_amp
id|DIFF_FORMAT_PATCH
)paren
(brace
id|show_patch_diff
c_func
(paren
id|p
comma
id|num_parent
comma
id|dense
comma
id|rev
)paren
suffix:semicolon
)brace
)brace
DECL|function|diff_tree_combined
r_void
id|diff_tree_combined
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
comma
r_const
r_int
r_char
id|parent
(braket
)braket
(braket
l_int|20
)braket
comma
r_int
id|num_parent
comma
r_int
id|dense
comma
r_struct
id|rev_info
op_star
id|rev
)paren
(brace
r_struct
id|diff_options
op_star
id|opt
op_assign
op_amp
id|rev-&gt;diffopt
suffix:semicolon
r_struct
id|diff_options
id|diffopts
suffix:semicolon
r_struct
id|combine_diff_path
op_star
id|p
comma
op_star
id|paths
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
comma
id|num_paths
suffix:semicolon
id|diffopts
op_assign
op_star
id|opt
suffix:semicolon
id|diffopts.output_format
op_and_assign
op_complement
(paren
id|DIFF_FORMAT_RAW
op_or
id|DIFF_FORMAT_DIFFSTAT
)paren
suffix:semicolon
id|diffopts.recursive
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* find set of paths that everybody touches */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_parent
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* show stat against the first parent even&n;&t;&t; * when doing combined diff.&n;&t;&t; */
r_if
c_cond
(paren
id|i
op_eq
l_int|0
op_logical_and
id|opt-&gt;output_format
op_amp
id|DIFF_FORMAT_DIFFSTAT
)paren
id|diffopts.output_format
op_or_assign
id|DIFF_FORMAT_DIFFSTAT
suffix:semicolon
r_else
id|diffopts.output_format
op_or_assign
id|DIFF_FORMAT_NO_OUTPUT
suffix:semicolon
id|diff_tree_sha1
c_func
(paren
id|parent
(braket
id|i
)braket
comma
id|sha1
comma
l_string|&quot;&quot;
comma
op_amp
id|diffopts
)paren
suffix:semicolon
id|diffcore_std
c_func
(paren
op_amp
id|diffopts
)paren
suffix:semicolon
id|paths
op_assign
id|intersect_paths
c_func
(paren
id|paths
comma
id|i
comma
id|num_parent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opt-&gt;output_format
op_amp
id|DIFF_FORMAT_DIFFSTAT
op_logical_and
id|rev-&gt;loginfo
)paren
id|show_log
c_func
(paren
id|rev
comma
id|opt-&gt;msg_sep
)paren
suffix:semicolon
id|diff_flush
c_func
(paren
op_amp
id|diffopts
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opt-&gt;output_format
op_amp
id|DIFF_FORMAT_DIFFSTAT
)paren
id|putchar
c_func
(paren
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
multiline_comment|/* find out surviving paths */
r_for
c_loop
(paren
id|num_paths
op_assign
l_int|0
comma
id|p
op_assign
id|paths
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;len
)paren
id|num_paths
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|num_paths
)paren
(brace
r_if
c_cond
(paren
id|opt-&gt;output_format
op_amp
(paren
id|DIFF_FORMAT_RAW
op_or
id|DIFF_FORMAT_NAME
op_or
id|DIFF_FORMAT_NAME_STATUS
)paren
)paren
(brace
r_for
c_loop
(paren
id|p
op_assign
id|paths
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;len
)paren
id|show_raw_diff
c_func
(paren
id|p
comma
id|num_parent
comma
id|rev
)paren
suffix:semicolon
)brace
id|putchar
c_func
(paren
id|opt-&gt;line_termination
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|opt-&gt;output_format
op_amp
id|DIFF_FORMAT_PATCH
)paren
(brace
r_for
c_loop
(paren
id|p
op_assign
id|paths
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;len
)paren
id|show_patch_diff
c_func
(paren
id|p
comma
id|num_parent
comma
id|dense
comma
id|rev
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Clean things up */
r_while
c_loop
(paren
id|paths
)paren
(brace
r_struct
id|combine_diff_path
op_star
id|tmp
op_assign
id|paths
suffix:semicolon
id|paths
op_assign
id|paths-&gt;next
suffix:semicolon
id|free
c_func
(paren
id|tmp
)paren
suffix:semicolon
)brace
)brace
DECL|function|diff_tree_combined_merge
r_void
id|diff_tree_combined_merge
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
id|dense
comma
r_struct
id|rev_info
op_star
id|rev
)paren
(brace
r_int
id|num_parent
suffix:semicolon
r_const
r_int
r_char
(paren
op_star
id|parent
)paren
(braket
l_int|20
)braket
suffix:semicolon
r_struct
id|commit
op_star
id|commit
op_assign
id|lookup_commit
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_struct
id|commit_list
op_star
id|parents
suffix:semicolon
multiline_comment|/* count parents */
r_for
c_loop
(paren
id|parents
op_assign
id|commit-&gt;parents
comma
id|num_parent
op_assign
l_int|0
suffix:semicolon
id|parents
suffix:semicolon
id|parents
op_assign
id|parents-&gt;next
comma
id|num_parent
op_increment
)paren
suffix:semicolon
multiline_comment|/* nothing */
id|parent
op_assign
id|xmalloc
c_func
(paren
id|num_parent
op_star
r_sizeof
(paren
op_star
id|parent
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|parents
op_assign
id|commit-&gt;parents
comma
id|num_parent
op_assign
l_int|0
suffix:semicolon
id|parents
suffix:semicolon
id|parents
op_assign
id|parents-&gt;next
comma
id|num_parent
op_increment
)paren
id|memcpy
c_func
(paren
id|parent
op_plus
id|num_parent
comma
id|parents-&gt;item-&gt;object.sha1
comma
l_int|20
)paren
suffix:semicolon
id|diff_tree_combined
c_func
(paren
id|sha1
comma
id|parent
comma
id|num_parent
comma
id|dense
comma
id|rev
)paren
suffix:semicolon
)brace
eof
