multiline_comment|/*&n; * GIT - The information manager from hell&n; *&n; * Copyright (C) Linus Torvalds, 2005&n; */
macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;blob.h&quot;
macro_line|#include &quot;tree.h&quot;
macro_line|#include &quot;quote.h&quot;
DECL|variable|line_termination
r_static
r_int
id|line_termination
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
DECL|macro|LS_RECURSIVE
mdefine_line|#define LS_RECURSIVE 1
DECL|macro|LS_TREE_ONLY
mdefine_line|#define LS_TREE_ONLY 2
DECL|variable|ls_options
r_static
r_int
id|ls_options
op_assign
l_int|0
suffix:semicolon
DECL|variable|root_entry
r_static
r_struct
id|tree_entry_list
id|root_entry
suffix:semicolon
DECL|function|prepare_root
r_static
r_void
id|prepare_root
c_func
(paren
r_int
r_char
op_star
id|sha1
)paren
(brace
r_int
r_char
id|rsha
(braket
l_int|20
)braket
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_void
op_star
id|buf
suffix:semicolon
r_struct
id|tree
op_star
id|root_tree
suffix:semicolon
id|buf
op_assign
id|read_object_with_reference
c_func
(paren
id|sha1
comma
l_string|&quot;tree&quot;
comma
op_amp
id|size
comma
id|rsha
)paren
suffix:semicolon
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
id|die
c_func
(paren
l_string|&quot;Could not read %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
id|root_tree
op_assign
id|lookup_tree
c_func
(paren
id|rsha
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|root_tree
)paren
id|die
c_func
(paren
l_string|&quot;Could not read %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
multiline_comment|/* Prepare a fake entry */
id|root_entry.directory
op_assign
l_int|1
suffix:semicolon
id|root_entry.executable
op_assign
id|root_entry.symlink
op_assign
l_int|0
suffix:semicolon
id|root_entry.mode
op_assign
id|S_IFDIR
suffix:semicolon
id|root_entry.name
op_assign
l_string|&quot;&quot;
suffix:semicolon
id|root_entry.item.tree
op_assign
id|root_tree
suffix:semicolon
id|root_entry.parent
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|prepare_children
r_static
r_int
id|prepare_children
c_func
(paren
r_struct
id|tree_entry_list
op_star
id|elem
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|elem-&gt;directory
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|elem-&gt;item.tree-&gt;object.parsed
)paren
(brace
r_struct
id|tree_entry_list
op_star
id|e
suffix:semicolon
r_if
c_cond
(paren
id|parse_tree
c_func
(paren
id|elem-&gt;item.tree
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Set up the parent link */
r_for
c_loop
(paren
id|e
op_assign
id|elem-&gt;item.tree-&gt;entries
suffix:semicolon
id|e
suffix:semicolon
id|e
op_assign
id|e-&gt;next
)paren
id|e-&gt;parent
op_assign
id|elem
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|find_entry
r_static
r_struct
id|tree_entry_list
op_star
id|find_entry
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_char
op_star
id|pathbuf
)paren
(brace
r_const
r_char
op_star
id|next
comma
op_star
id|slash
suffix:semicolon
r_int
id|len
suffix:semicolon
r_struct
id|tree_entry_list
op_star
id|elem
op_assign
op_amp
id|root_entry
comma
op_star
id|oldelem
op_assign
l_int|NULL
suffix:semicolon
op_star
(paren
id|pathbuf
)paren
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
multiline_comment|/* Find tree element, descending from root, that&n;&t; * corresponds to the named path, lazily expanding&n;&t; * the tree if possible.&n;&t; */
r_while
c_loop
(paren
id|path
)paren
(brace
multiline_comment|/* The fact we still have path means that the caller&n;&t;&t; * wants us to make sure that elem at this point is a&n;&t;&t; * directory, and possibly descend into it.  Even what&n;&t;&t; * is left is just trailing slashes, we loop back to&n;&t;&t; * here, and this call to prepare_children() will&n;&t;&t; * catch elem not being a tree.  Nice.&n;&t;&t; */
r_if
c_cond
(paren
id|prepare_children
c_func
(paren
id|elem
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|slash
op_assign
id|strchr
c_func
(paren
id|path
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|slash
)paren
(brace
id|len
op_assign
id|strlen
c_func
(paren
id|path
)paren
suffix:semicolon
id|next
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|next
op_assign
id|slash
op_plus
l_int|1
suffix:semicolon
id|len
op_assign
id|slash
id|path
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
)paren
(brace
r_if
c_cond
(paren
id|oldelem
)paren
(brace
id|pathbuf
op_add_assign
id|sprintf
c_func
(paren
id|pathbuf
comma
l_string|&quot;%s/&quot;
comma
id|oldelem-&gt;name
)paren
suffix:semicolon
)brace
multiline_comment|/* (len == 0) if the original path was &quot;drivers/char/&quot;&n;&t;&t;&t; * and we have run already two rounds, having elem&n;&t;&t;&t; * pointing at the drivers/char directory.&n;&t;&t;&t; */
id|elem
op_assign
id|elem-&gt;item.tree-&gt;entries
suffix:semicolon
r_while
c_loop
(paren
id|elem
)paren
(brace
r_if
c_cond
(paren
(paren
id|strlen
c_func
(paren
id|elem-&gt;name
)paren
op_eq
id|len
)paren
op_logical_and
op_logical_neg
id|strncmp
c_func
(paren
id|elem-&gt;name
comma
id|path
comma
id|len
)paren
)paren
(brace
multiline_comment|/* found */
r_break
suffix:semicolon
)brace
id|elem
op_assign
id|elem-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|elem
)paren
r_return
l_int|NULL
suffix:semicolon
id|oldelem
op_assign
id|elem
suffix:semicolon
)brace
id|path
op_assign
id|next
suffix:semicolon
)brace
r_return
id|elem
suffix:semicolon
)brace
DECL|function|entry_type
r_static
r_const
r_char
op_star
id|entry_type
c_func
(paren
r_struct
id|tree_entry_list
op_star
id|e
)paren
(brace
r_return
(paren
id|e-&gt;directory
ques
c_cond
l_string|&quot;tree&quot;
suffix:colon
l_string|&quot;blob&quot;
)paren
suffix:semicolon
)brace
DECL|function|entry_hex
r_static
r_const
r_char
op_star
id|entry_hex
c_func
(paren
r_struct
id|tree_entry_list
op_star
id|e
)paren
(brace
r_return
id|sha1_to_hex
c_func
(paren
id|e-&gt;directory
ques
c_cond
id|e-&gt;item.tree-&gt;object.sha1
suffix:colon
id|e-&gt;item.blob-&gt;object.sha1
)paren
suffix:semicolon
)brace
multiline_comment|/* forward declaration for mutually recursive routines */
r_static
r_int
id|show_entry
c_func
(paren
r_struct
id|tree_entry_list
op_star
comma
r_int
comma
r_char
op_star
id|pathbuf
)paren
suffix:semicolon
DECL|function|show_children
r_static
r_int
id|show_children
c_func
(paren
r_struct
id|tree_entry_list
op_star
id|e
comma
r_int
id|level
comma
r_char
op_star
id|pathbuf
)paren
(brace
r_int
id|oldlen
op_assign
id|strlen
c_func
(paren
id|pathbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e
op_ne
op_amp
id|root_entry
)paren
id|sprintf
c_func
(paren
id|pathbuf
op_plus
id|oldlen
comma
l_string|&quot;%s/&quot;
comma
id|e-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prepare_children
c_func
(paren
id|e
)paren
)paren
id|die
c_func
(paren
l_string|&quot;internal error: ls-tree show_children called with non tree&quot;
)paren
suffix:semicolon
id|e
op_assign
id|e-&gt;item.tree-&gt;entries
suffix:semicolon
r_while
c_loop
(paren
id|e
)paren
(brace
id|show_entry
c_func
(paren
id|e
comma
id|level
comma
id|pathbuf
)paren
suffix:semicolon
id|e
op_assign
id|e-&gt;next
suffix:semicolon
)brace
id|pathbuf
(braket
id|oldlen
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|show_entry
r_static
r_int
id|show_entry
c_func
(paren
r_struct
id|tree_entry_list
op_star
id|e
comma
r_int
id|level
comma
r_char
op_star
id|pathbuf
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|e
op_ne
op_amp
id|root_entry
)paren
(brace
r_int
id|pathlen
op_assign
id|strlen
c_func
(paren
id|pathbuf
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%06o %s %s&t;&quot;
comma
id|e-&gt;mode
comma
id|entry_type
c_func
(paren
id|e
)paren
comma
id|entry_hex
c_func
(paren
id|e
)paren
)paren
suffix:semicolon
id|write_name_quoted
c_func
(paren
id|pathbuf
comma
id|pathlen
comma
id|e-&gt;name
comma
id|line_termination
comma
id|stdout
)paren
suffix:semicolon
id|putchar
c_func
(paren
id|line_termination
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e-&gt;directory
)paren
(brace
multiline_comment|/* If this is a directory, we have the following cases:&n;&t;&t; * (1) This is the top-level request (explicit path from the&n;&t;&t; *     command line, or &quot;root&quot; if there is no command line).&n;&t;&t; *  a. Without any flag.  We show direct children.  We do not &n;&t;&t; *     recurse into them.&n;&t;&t; *  b. With -r.  We do recurse into children.&n;&t;&t; *  c. With -d.  We do not recurse into children.&n;&t;&t; * (2) We came here because our caller is either (1-a) or&n;&t;&t; *     (1-b).&n;&t;&t; *  a. Without any flag.  We do not show our children (which&n;&t;&t; *     are grandchildren for the original request).&n;&t;&t; *  b. With -r.  We continue to recurse into our children.&n;&t;&t; *  c. With -d.  We should not have come here to begin with.&n;&t;&t; */
r_if
c_cond
(paren
id|level
op_eq
l_int|0
op_logical_and
op_logical_neg
(paren
id|ls_options
op_amp
id|LS_TREE_ONLY
)paren
)paren
multiline_comment|/* case (1)-a and (1)-b */
id|err
op_assign
id|err
op_or
id|show_children
c_func
(paren
id|e
comma
id|level
op_plus
l_int|1
comma
id|pathbuf
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|level
op_logical_and
id|ls_options
op_amp
id|LS_RECURSIVE
)paren
multiline_comment|/* case (2)-b */
id|err
op_assign
id|err
op_or
id|show_children
c_func
(paren
id|e
comma
id|level
op_plus
l_int|1
comma
id|pathbuf
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
DECL|function|list_one
r_static
r_int
id|list_one
c_func
(paren
r_const
r_char
op_star
id|path
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_char
id|pathbuf
(braket
id|MAXPATHLEN
op_plus
l_int|1
)braket
suffix:semicolon
r_struct
id|tree_entry_list
op_star
id|e
op_assign
id|find_entry
c_func
(paren
id|path
comma
id|pathbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|e
)paren
(brace
multiline_comment|/* traditionally ls-tree does not complain about&n;&t;&t; * missing path.  We may change this later to match&n;&t;&t; * what &quot;/bin/ls -a&quot; does, which is to complain.&n;&t;&t; */
r_return
id|err
suffix:semicolon
)brace
id|err
op_assign
id|err
op_or
id|show_entry
c_func
(paren
id|e
comma
l_int|0
comma
id|pathbuf
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|list
r_static
r_int
id|list
c_func
(paren
r_const
r_char
op_star
op_star
id|path
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|path
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
id|err
op_assign
id|err
op_or
id|list_one
c_func
(paren
id|path
(braket
id|i
)braket
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|variable|ls_tree_usage
r_static
r_const
r_char
id|ls_tree_usage
(braket
)braket
op_assign
l_string|&quot;git-ls-tree [-d] [-r] [-z] &lt;tree-ish&gt; [path...]&quot;
suffix:semicolon
DECL|function|main
r_int
id|main
c_func
(paren
r_int
id|argc
comma
r_const
r_char
op_star
op_star
id|argv
)paren
(brace
r_static
r_const
r_char
op_star
id|path0
(braket
)braket
op_assign
(brace
l_string|&quot;&quot;
comma
l_int|NULL
)brace
suffix:semicolon
r_const
r_char
op_star
op_star
id|path
suffix:semicolon
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_int
id|nongit
op_assign
l_int|0
suffix:semicolon
r_const
r_char
op_star
id|prefix
op_assign
id|setup_git_directory_gently
c_func
(paren
op_amp
id|nongit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prefix
)paren
id|path0
(braket
l_int|0
)braket
op_assign
id|prefix
suffix:semicolon
r_while
c_loop
(paren
l_int|1
OL
id|argc
op_logical_and
id|argv
(braket
l_int|1
)braket
(braket
l_int|0
)braket
op_eq
l_char|&squot;-&squot;
)paren
(brace
r_switch
c_cond
(paren
id|argv
(braket
l_int|1
)braket
(braket
l_int|1
)braket
)paren
(brace
r_case
l_char|&squot;z&squot;
suffix:colon
id|line_termination
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;r&squot;
suffix:colon
id|ls_options
op_or_assign
id|LS_RECURSIVE
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;d&squot;
suffix:colon
id|ls_options
op_or_assign
id|LS_TREE_ONLY
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|usage
c_func
(paren
id|ls_tree_usage
)paren
suffix:semicolon
)brace
id|argc
op_decrement
suffix:semicolon
id|argv
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|argc
OL
l_int|2
)paren
id|usage
c_func
(paren
id|ls_tree_usage
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
id|sha1
)paren
OL
l_int|0
)paren
id|usage
c_func
(paren
id|ls_tree_usage
)paren
suffix:semicolon
r_if
c_cond
(paren
id|argc
op_eq
l_int|2
)paren
id|path
op_assign
id|path0
suffix:semicolon
r_else
id|path
op_assign
id|get_pathspec
c_func
(paren
id|prefix
comma
id|argv
op_plus
l_int|2
)paren
suffix:semicolon
id|prepare_root
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list
c_func
(paren
id|path
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;list failed&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
