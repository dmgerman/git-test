multiline_comment|/*&n; * GIT - The information manager from hell&n; *&n; * Copyright (C) Linus Torvalds, 2005&n; */
macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;blob.h&quot;
macro_line|#include &quot;tree.h&quot;
DECL|variable|line_termination
r_static
r_int
id|line_termination
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
DECL|macro|LS_RECURSIVE
mdefine_line|#define LS_RECURSIVE 1
DECL|macro|LS_TREE_ONLY
mdefine_line|#define LS_TREE_ONLY 2
DECL|variable|ls_options
r_static
r_int
id|ls_options
op_assign
l_int|0
suffix:semicolon
DECL|variable|root_entry
r_static
r_struct
id|tree_entry_list
id|root_entry
suffix:semicolon
DECL|function|prepare_root
r_static
r_void
id|prepare_root
c_func
(paren
r_int
r_char
op_star
id|sha1
)paren
(brace
r_int
r_char
id|rsha
(braket
l_int|20
)braket
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_void
op_star
id|buf
suffix:semicolon
r_struct
id|tree
op_star
id|root_tree
suffix:semicolon
id|buf
op_assign
id|read_object_with_reference
c_func
(paren
id|sha1
comma
l_string|&quot;tree&quot;
comma
op_amp
id|size
comma
id|rsha
)paren
suffix:semicolon
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
id|die
c_func
(paren
l_string|&quot;Could not read %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
id|root_tree
op_assign
id|lookup_tree
c_func
(paren
id|rsha
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|root_tree
)paren
id|die
c_func
(paren
l_string|&quot;Could not read %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
multiline_comment|/* Prepare a fake entry */
id|root_entry.directory
op_assign
l_int|1
suffix:semicolon
id|root_entry.executable
op_assign
id|root_entry.symlink
op_assign
l_int|0
suffix:semicolon
id|root_entry.mode
op_assign
id|S_IFDIR
suffix:semicolon
id|root_entry.name
op_assign
l_string|&quot;&quot;
suffix:semicolon
id|root_entry.item.tree
op_assign
id|root_tree
suffix:semicolon
id|root_entry.parent
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|prepare_children
r_static
r_int
id|prepare_children
c_func
(paren
r_struct
id|tree_entry_list
op_star
id|elem
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|elem-&gt;directory
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|elem-&gt;item.tree-&gt;object.parsed
)paren
(brace
r_struct
id|tree_entry_list
op_star
id|e
suffix:semicolon
r_if
c_cond
(paren
id|parse_tree
c_func
(paren
id|elem-&gt;item.tree
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Set up the parent link */
r_for
c_loop
(paren
id|e
op_assign
id|elem-&gt;item.tree-&gt;entries
suffix:semicolon
id|e
suffix:semicolon
id|e
op_assign
id|e-&gt;next
)paren
id|e-&gt;parent
op_assign
id|elem
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|find_entry_0
r_static
r_struct
id|tree_entry_list
op_star
id|find_entry_0
c_func
(paren
r_struct
id|tree_entry_list
op_star
id|elem
comma
r_const
r_char
op_star
id|path
comma
r_const
r_char
op_star
id|path_end
)paren
(brace
r_const
r_char
op_star
id|ep
suffix:semicolon
r_int
id|len
suffix:semicolon
r_while
c_loop
(paren
id|path
OL
id|path_end
)paren
(brace
r_if
c_cond
(paren
id|prepare_children
c_func
(paren
id|elem
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* In elem-&gt;tree-&gt;entries, find the one that has name&n;&t;&t; * that matches what is between path and ep.&n;&t;&t; */
id|elem
op_assign
id|elem-&gt;item.tree-&gt;entries
suffix:semicolon
id|ep
op_assign
id|strchr
c_func
(paren
id|path
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ep
op_logical_or
id|path_end
op_le
id|ep
)paren
id|ep
op_assign
id|path_end
suffix:semicolon
id|len
op_assign
id|ep
id|path
suffix:semicolon
r_while
c_loop
(paren
id|elem
)paren
(brace
r_if
c_cond
(paren
(paren
id|strlen
c_func
(paren
id|elem-&gt;name
)paren
op_eq
id|len
)paren
op_logical_and
op_logical_neg
id|strncmp
c_func
(paren
id|elem-&gt;name
comma
id|path
comma
id|len
)paren
)paren
r_break
suffix:semicolon
id|elem
op_assign
id|elem-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|path_end
op_le
id|ep
op_logical_or
op_logical_neg
id|elem
)paren
r_return
id|elem
suffix:semicolon
r_while
c_loop
(paren
op_star
id|ep
op_eq
l_char|&squot;/&squot;
op_logical_and
id|ep
OL
id|path_end
)paren
id|ep
op_increment
suffix:semicolon
id|path
op_assign
id|ep
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|find_entry
r_static
r_struct
id|tree_entry_list
op_star
id|find_entry
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_const
r_char
op_star
id|path_end
)paren
(brace
multiline_comment|/* Find tree element, descending from root, that&n;&t; * corresponds to the named path, lazily expanding&n;&t; * the tree if possible.&n;&t; */
r_if
c_cond
(paren
id|path
op_eq
id|path_end
)paren
(brace
multiline_comment|/* Special.  This is the root level */
r_return
op_amp
id|root_entry
suffix:semicolon
)brace
r_return
id|find_entry_0
c_func
(paren
op_amp
id|root_entry
comma
id|path
comma
id|path_end
)paren
suffix:semicolon
)brace
DECL|function|show_entry_name
r_static
r_void
id|show_entry_name
c_func
(paren
r_struct
id|tree_entry_list
op_star
id|e
)paren
(brace
multiline_comment|/* This is yucky.  The root level is there for&n;&t; * our convenience but we really want to do a&n;&t; * forest.&n;&t; */
r_if
c_cond
(paren
id|e-&gt;parent
op_logical_and
id|e-&gt;parent
op_ne
op_amp
id|root_entry
)paren
(brace
id|show_entry_name
c_func
(paren
id|e-&gt;parent
)paren
suffix:semicolon
id|putchar
c_func
(paren
l_char|&squot;/&squot;
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;%s&quot;
comma
id|e-&gt;name
)paren
suffix:semicolon
)brace
DECL|function|entry_type
r_static
r_const
r_char
op_star
id|entry_type
c_func
(paren
r_struct
id|tree_entry_list
op_star
id|e
)paren
(brace
r_return
(paren
id|e-&gt;directory
ques
c_cond
l_string|&quot;tree&quot;
suffix:colon
l_string|&quot;blob&quot;
)paren
suffix:semicolon
)brace
DECL|function|entry_hex
r_static
r_const
r_char
op_star
id|entry_hex
c_func
(paren
r_struct
id|tree_entry_list
op_star
id|e
)paren
(brace
r_return
id|sha1_to_hex
c_func
(paren
id|e-&gt;directory
ques
c_cond
id|e-&gt;item.tree-&gt;object.sha1
suffix:colon
id|e-&gt;item.blob-&gt;object.sha1
)paren
suffix:semicolon
)brace
multiline_comment|/* forward declaration for mutually recursive routines */
r_static
r_int
id|show_entry
c_func
(paren
r_struct
id|tree_entry_list
op_star
comma
r_int
)paren
suffix:semicolon
DECL|function|show_children
r_static
r_int
id|show_children
c_func
(paren
r_struct
id|tree_entry_list
op_star
id|e
comma
r_int
id|level
)paren
(brace
r_if
c_cond
(paren
id|prepare_children
c_func
(paren
id|e
)paren
)paren
id|die
c_func
(paren
l_string|&quot;internal error: ls-tree show_children called with non tree&quot;
)paren
suffix:semicolon
id|e
op_assign
id|e-&gt;item.tree-&gt;entries
suffix:semicolon
r_while
c_loop
(paren
id|e
)paren
(brace
id|show_entry
c_func
(paren
id|e
comma
id|level
)paren
suffix:semicolon
id|e
op_assign
id|e-&gt;next
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|show_entry
r_static
r_int
id|show_entry
c_func
(paren
r_struct
id|tree_entry_list
op_star
id|e
comma
r_int
id|level
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|e
op_ne
op_amp
id|root_entry
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%06o %s %s&t;&quot;
comma
id|e-&gt;mode
comma
id|entry_type
c_func
(paren
id|e
)paren
comma
id|entry_hex
c_func
(paren
id|e
)paren
)paren
suffix:semicolon
id|show_entry_name
c_func
(paren
id|e
)paren
suffix:semicolon
id|putchar
c_func
(paren
id|line_termination
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e-&gt;directory
)paren
(brace
multiline_comment|/* If this is a directory, we have the following cases:&n;&t;&t; * (1) This is the top-level request (explicit path from the&n;&t;&t; *     command line, or &quot;root&quot; if there is no command line).&n;&t;&t; *  a. Without any flag.  We show direct children.  We do not &n;&t;&t; *     recurse into them.&n;&t;&t; *  b. With -r.  We do recurse into children.&n;&t;&t; *  c. With -d.  We do not recurse into children.&n;&t;&t; * (2) We came here because our caller is either (1-a) or&n;&t;&t; *     (1-b).&n;&t;&t; *  a. Without any flag.  We do not show our children (which&n;&t;&t; *     are grandchildren for the original request).&n;&t;&t; *  b. With -r.  We continue to recurse into our children.&n;&t;&t; *  c. With -d.  We should not have come here to begin with.&n;&t;&t; */
r_if
c_cond
(paren
id|level
op_eq
l_int|0
op_logical_and
op_logical_neg
(paren
id|ls_options
op_amp
id|LS_TREE_ONLY
)paren
)paren
multiline_comment|/* case (1)-a and (1)-b */
id|err
op_assign
id|err
op_or
id|show_children
c_func
(paren
id|e
comma
id|level
op_plus
l_int|1
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|level
op_logical_and
id|ls_options
op_amp
id|LS_RECURSIVE
)paren
multiline_comment|/* case (2)-b */
id|err
op_assign
id|err
op_or
id|show_children
c_func
(paren
id|e
comma
id|level
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
DECL|function|list_one
r_static
r_int
id|list_one
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_const
r_char
op_star
id|path_end
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_struct
id|tree_entry_list
op_star
id|e
op_assign
id|find_entry
c_func
(paren
id|path
comma
id|path_end
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|e
)paren
(brace
multiline_comment|/* traditionally ls-tree does not complain about&n;&t;&t; * missing path.  We may change this later to match&n;&t;&t; * what &quot;/bin/ls -a&quot; does, which is to complain.&n;&t;&t; */
r_return
id|err
suffix:semicolon
)brace
id|err
op_assign
id|err
op_or
id|show_entry
c_func
(paren
id|e
comma
l_int|0
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|list
r_static
r_int
id|list
c_func
(paren
r_char
op_star
op_star
id|path
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|path
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|path
(braket
id|i
)braket
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|0
op_le
id|len
op_logical_and
id|path
(braket
id|i
)braket
(braket
id|len
)braket
op_eq
l_char|&squot;/&squot;
)paren
id|len
op_decrement
suffix:semicolon
id|err
op_assign
id|err
op_or
id|list_one
c_func
(paren
id|path
(braket
id|i
)braket
comma
id|path
(braket
id|i
)braket
op_plus
id|len
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
DECL|variable|ls_tree_usage
r_static
r_const
r_char
op_star
id|ls_tree_usage
op_assign
l_string|&quot;git-ls-tree [-d] [-r] [-z] &lt;tree-ish&gt; [path...]&quot;
suffix:semicolon
DECL|function|main
r_int
id|main
c_func
(paren
r_int
id|argc
comma
r_char
op_star
op_star
id|argv
)paren
(brace
r_static
r_char
op_star
id|path0
(braket
)braket
op_assign
(brace
l_string|&quot;&quot;
comma
l_int|NULL
)brace
suffix:semicolon
r_char
op_star
op_star
id|path
suffix:semicolon
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_while
c_loop
(paren
l_int|1
OL
id|argc
op_logical_and
id|argv
(braket
l_int|1
)braket
(braket
l_int|0
)braket
op_eq
l_char|&squot;-&squot;
)paren
(brace
r_switch
c_cond
(paren
id|argv
(braket
l_int|1
)braket
(braket
l_int|1
)braket
)paren
(brace
r_case
l_char|&squot;z&squot;
suffix:colon
id|line_termination
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;r&squot;
suffix:colon
id|ls_options
op_or_assign
id|LS_RECURSIVE
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;d&squot;
suffix:colon
id|ls_options
op_or_assign
id|LS_TREE_ONLY
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|usage
c_func
(paren
id|ls_tree_usage
)paren
suffix:semicolon
)brace
id|argc
op_decrement
suffix:semicolon
id|argv
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|argc
OL
l_int|2
)paren
id|usage
c_func
(paren
id|ls_tree_usage
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
id|sha1
)paren
OL
l_int|0
)paren
id|usage
c_func
(paren
id|ls_tree_usage
)paren
suffix:semicolon
id|path
op_assign
(paren
id|argc
op_eq
l_int|2
)paren
ques
c_cond
id|path0
suffix:colon
(paren
id|argv
op_plus
l_int|2
)paren
suffix:semicolon
id|prepare_root
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list
c_func
(paren
id|path
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;list failed&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
