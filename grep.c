macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;grep.h&quot;
macro_line|#include &quot;userdiff.h&quot;
macro_line|#include &quot;xdiff-interface.h&quot;
DECL|function|append_header_grep_pattern
r_void
id|append_header_grep_pattern
c_func
(paren
r_struct
id|grep_opt
op_star
id|opt
comma
r_enum
id|grep_header_field
id|field
comma
r_const
r_char
op_star
id|pat
)paren
(brace
r_struct
id|grep_pat
op_star
id|p
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|p
)paren
)paren
suffix:semicolon
id|p-&gt;pattern
op_assign
id|pat
suffix:semicolon
id|p-&gt;patternlen
op_assign
id|strlen
c_func
(paren
id|pat
)paren
suffix:semicolon
id|p-&gt;origin
op_assign
l_string|&quot;header&quot;
suffix:semicolon
id|p-&gt;no
op_assign
l_int|0
suffix:semicolon
id|p-&gt;token
op_assign
id|GREP_PATTERN_HEAD
suffix:semicolon
id|p-&gt;field
op_assign
id|field
suffix:semicolon
op_star
id|opt-&gt;header_tail
op_assign
id|p
suffix:semicolon
id|opt-&gt;header_tail
op_assign
op_amp
id|p-&gt;next
suffix:semicolon
id|p-&gt;next
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|append_grep_pattern
r_void
id|append_grep_pattern
c_func
(paren
r_struct
id|grep_opt
op_star
id|opt
comma
r_const
r_char
op_star
id|pat
comma
r_const
r_char
op_star
id|origin
comma
r_int
id|no
comma
r_enum
id|grep_pat_token
id|t
)paren
(brace
id|append_grep_pat
c_func
(paren
id|opt
comma
id|pat
comma
id|strlen
c_func
(paren
id|pat
)paren
comma
id|origin
comma
id|no
comma
id|t
)paren
suffix:semicolon
)brace
DECL|function|append_grep_pat
r_void
id|append_grep_pat
c_func
(paren
r_struct
id|grep_opt
op_star
id|opt
comma
r_const
r_char
op_star
id|pat
comma
r_int
id|patlen
comma
r_const
r_char
op_star
id|origin
comma
r_int
id|no
comma
r_enum
id|grep_pat_token
id|t
)paren
(brace
r_struct
id|grep_pat
op_star
id|p
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|p
)paren
)paren
suffix:semicolon
id|p-&gt;pattern
op_assign
id|pat
suffix:semicolon
id|p-&gt;patternlen
op_assign
id|patlen
suffix:semicolon
id|p-&gt;origin
op_assign
id|origin
suffix:semicolon
id|p-&gt;no
op_assign
id|no
suffix:semicolon
id|p-&gt;token
op_assign
id|t
suffix:semicolon
op_star
id|opt-&gt;pattern_tail
op_assign
id|p
suffix:semicolon
id|opt-&gt;pattern_tail
op_assign
op_amp
id|p-&gt;next
suffix:semicolon
id|p-&gt;next
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|grep_opt_dup
r_struct
id|grep_opt
op_star
id|grep_opt_dup
c_func
(paren
r_const
r_struct
id|grep_opt
op_star
id|opt
)paren
(brace
r_struct
id|grep_pat
op_star
id|pat
suffix:semicolon
r_struct
id|grep_opt
op_star
id|ret
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|grep_opt
)paren
)paren
suffix:semicolon
op_star
id|ret
op_assign
op_star
id|opt
suffix:semicolon
id|ret-&gt;pattern_list
op_assign
l_int|NULL
suffix:semicolon
id|ret-&gt;pattern_tail
op_assign
op_amp
id|ret-&gt;pattern_list
suffix:semicolon
r_for
c_loop
(paren
id|pat
op_assign
id|opt-&gt;pattern_list
suffix:semicolon
id|pat
op_ne
l_int|NULL
suffix:semicolon
id|pat
op_assign
id|pat-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|pat-&gt;token
op_eq
id|GREP_PATTERN_HEAD
)paren
(brace
id|append_header_grep_pattern
c_func
(paren
id|ret
comma
id|pat-&gt;field
comma
id|pat-&gt;pattern
)paren
suffix:semicolon
)brace
r_else
id|append_grep_pat
c_func
(paren
id|ret
comma
id|pat-&gt;pattern
comma
id|pat-&gt;patternlen
comma
id|pat-&gt;origin
comma
id|pat-&gt;no
comma
id|pat-&gt;token
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|compile_regexp_failed
r_static
id|NORETURN
r_void
id|compile_regexp_failed
c_func
(paren
r_const
r_struct
id|grep_pat
op_star
id|p
comma
r_const
r_char
op_star
id|error
)paren
(brace
r_char
id|where
(braket
l_int|1024
)braket
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;no
)paren
id|sprintf
c_func
(paren
id|where
comma
l_string|&quot;In &squot;%s&squot; at %d, &quot;
comma
id|p-&gt;origin
comma
id|p-&gt;no
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|p-&gt;origin
)paren
id|sprintf
c_func
(paren
id|where
comma
l_string|&quot;%s, &quot;
comma
id|p-&gt;origin
)paren
suffix:semicolon
r_else
id|where
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|die
c_func
(paren
l_string|&quot;%s&squot;%s&squot;: %s&quot;
comma
id|where
comma
id|p-&gt;pattern
comma
id|error
)paren
suffix:semicolon
)brace
macro_line|#ifdef USE_LIBPCRE
DECL|function|compile_pcre_regexp
r_static
r_void
id|compile_pcre_regexp
c_func
(paren
r_struct
id|grep_pat
op_star
id|p
comma
r_const
r_struct
id|grep_opt
op_star
id|opt
)paren
(brace
r_const
r_char
op_star
id|error
suffix:semicolon
r_int
id|erroffset
suffix:semicolon
r_int
id|options
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|opt-&gt;ignore_case
)paren
id|options
op_or_assign
id|PCRE_CASELESS
suffix:semicolon
id|p-&gt;pcre_regexp
op_assign
id|pcre_compile
c_func
(paren
id|p-&gt;pattern
comma
id|options
comma
op_amp
id|error
comma
op_amp
id|erroffset
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;pcre_regexp
)paren
id|compile_regexp_failed
c_func
(paren
id|p
comma
id|error
)paren
suffix:semicolon
id|p-&gt;pcre_extra_info
op_assign
id|pcre_study
c_func
(paren
id|p-&gt;pcre_regexp
comma
l_int|0
comma
op_amp
id|error
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;pcre_extra_info
op_logical_and
id|error
)paren
id|die
c_func
(paren
l_string|&quot;%s&quot;
comma
id|error
)paren
suffix:semicolon
)brace
DECL|function|pcrematch
r_static
r_int
id|pcrematch
c_func
(paren
r_struct
id|grep_pat
op_star
id|p
comma
r_const
r_char
op_star
id|line
comma
r_const
r_char
op_star
id|eol
comma
id|regmatch_t
op_star
id|match
comma
r_int
id|eflags
)paren
(brace
r_int
id|ovector
(braket
l_int|30
)braket
comma
id|ret
comma
id|flags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|eflags
op_amp
id|REG_NOTBOL
)paren
id|flags
op_or_assign
id|PCRE_NOTBOL
suffix:semicolon
id|ret
op_assign
id|pcre_exec
c_func
(paren
id|p-&gt;pcre_regexp
comma
id|p-&gt;pcre_extra_info
comma
id|line
comma
id|eol
id|line
comma
l_int|0
comma
id|flags
comma
id|ovector
comma
id|ARRAY_SIZE
c_func
(paren
id|ovector
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
op_logical_and
id|ret
op_ne
id|PCRE_ERROR_NOMATCH
)paren
id|die
c_func
(paren
l_string|&quot;pcre_exec failed with error code %d&quot;
comma
id|ret
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OG
l_int|0
)paren
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
id|match-&gt;rm_so
op_assign
id|ovector
(braket
l_int|0
)braket
suffix:semicolon
id|match-&gt;rm_eo
op_assign
id|ovector
(braket
l_int|1
)braket
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|free_pcre_regexp
r_static
r_void
id|free_pcre_regexp
c_func
(paren
r_struct
id|grep_pat
op_star
id|p
)paren
(brace
id|pcre_free
c_func
(paren
id|p-&gt;pcre_regexp
)paren
suffix:semicolon
id|pcre_free
c_func
(paren
id|p-&gt;pcre_extra_info
)paren
suffix:semicolon
)brace
macro_line|#else /* !USE_LIBPCRE */
DECL|function|compile_pcre_regexp
r_static
r_void
id|compile_pcre_regexp
c_func
(paren
r_struct
id|grep_pat
op_star
id|p
comma
r_const
r_struct
id|grep_opt
op_star
id|opt
)paren
(brace
id|die
c_func
(paren
l_string|&quot;cannot use Perl-compatible regexes when not compiled with USE_LIBPCRE&quot;
)paren
suffix:semicolon
)brace
DECL|function|pcrematch
r_static
r_int
id|pcrematch
c_func
(paren
r_struct
id|grep_pat
op_star
id|p
comma
r_const
r_char
op_star
id|line
comma
r_const
r_char
op_star
id|eol
comma
id|regmatch_t
op_star
id|match
comma
r_int
id|eflags
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|free_pcre_regexp
r_static
r_void
id|free_pcre_regexp
c_func
(paren
r_struct
id|grep_pat
op_star
id|p
)paren
(brace
)brace
macro_line|#endif /* !USE_LIBPCRE */
DECL|function|is_fixed
r_static
r_int
id|is_fixed
c_func
(paren
r_const
r_char
op_star
id|s
comma
r_int
id|len
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* regcomp cannot accept patterns with NULs so we&n;&t; * consider any pattern containing a NUL fixed.&n;&t; */
r_if
c_cond
(paren
id|memchr
c_func
(paren
id|s
comma
l_int|0
comma
id|len
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|is_regex_special
c_func
(paren
id|s
(braket
id|i
)braket
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|compile_regexp
r_static
r_void
id|compile_regexp
c_func
(paren
r_struct
id|grep_pat
op_star
id|p
comma
r_struct
id|grep_opt
op_star
id|opt
)paren
(brace
r_int
id|err
suffix:semicolon
id|p-&gt;word_regexp
op_assign
id|opt-&gt;word_regexp
suffix:semicolon
id|p-&gt;ignore_case
op_assign
id|opt-&gt;ignore_case
suffix:semicolon
r_if
c_cond
(paren
id|opt-&gt;fixed
op_logical_or
id|is_fixed
c_func
(paren
id|p-&gt;pattern
comma
id|p-&gt;patternlen
)paren
)paren
id|p-&gt;fixed
op_assign
l_int|1
suffix:semicolon
r_else
id|p-&gt;fixed
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;fixed
)paren
(brace
r_if
c_cond
(paren
id|opt-&gt;regflags
op_amp
id|REG_ICASE
op_logical_or
id|p-&gt;ignore_case
)paren
(brace
r_static
r_char
id|trans
(braket
l_int|256
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|256
suffix:semicolon
id|i
op_increment
)paren
id|trans
(braket
id|i
)braket
op_assign
id|tolower
c_func
(paren
id|i
)paren
suffix:semicolon
id|p-&gt;kws
op_assign
id|kwsalloc
c_func
(paren
id|trans
)paren
suffix:semicolon
)brace
r_else
(brace
id|p-&gt;kws
op_assign
id|kwsalloc
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
id|kwsincr
c_func
(paren
id|p-&gt;kws
comma
id|p-&gt;pattern
comma
id|p-&gt;patternlen
)paren
suffix:semicolon
id|kwsprep
c_func
(paren
id|p-&gt;kws
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|opt-&gt;pcre
)paren
(brace
id|compile_pcre_regexp
c_func
(paren
id|p
comma
id|opt
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|err
op_assign
id|regcomp
c_func
(paren
op_amp
id|p-&gt;regexp
comma
id|p-&gt;pattern
comma
id|opt-&gt;regflags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_char
id|errbuf
(braket
l_int|1024
)braket
suffix:semicolon
id|regerror
c_func
(paren
id|err
comma
op_amp
id|p-&gt;regexp
comma
id|errbuf
comma
l_int|1024
)paren
suffix:semicolon
id|regfree
c_func
(paren
op_amp
id|p-&gt;regexp
)paren
suffix:semicolon
id|compile_regexp_failed
c_func
(paren
id|p
comma
id|errbuf
)paren
suffix:semicolon
)brace
)brace
r_static
r_struct
id|grep_expr
op_star
id|compile_pattern_or
c_func
(paren
r_struct
id|grep_pat
op_star
op_star
)paren
suffix:semicolon
DECL|function|compile_pattern_atom
r_static
r_struct
id|grep_expr
op_star
id|compile_pattern_atom
c_func
(paren
r_struct
id|grep_pat
op_star
op_star
id|list
)paren
(brace
r_struct
id|grep_pat
op_star
id|p
suffix:semicolon
r_struct
id|grep_expr
op_star
id|x
suffix:semicolon
id|p
op_assign
op_star
id|list
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_return
l_int|NULL
suffix:semicolon
r_switch
c_cond
(paren
id|p-&gt;token
)paren
(brace
r_case
id|GREP_PATTERN
suffix:colon
multiline_comment|/* atom */
r_case
id|GREP_PATTERN_HEAD
suffix:colon
r_case
id|GREP_PATTERN_BODY
suffix:colon
id|x
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|grep_expr
)paren
)paren
suffix:semicolon
id|x-&gt;node
op_assign
id|GREP_NODE_ATOM
suffix:semicolon
id|x-&gt;u.atom
op_assign
id|p
suffix:semicolon
op_star
id|list
op_assign
id|p-&gt;next
suffix:semicolon
r_return
id|x
suffix:semicolon
r_case
id|GREP_OPEN_PAREN
suffix:colon
op_star
id|list
op_assign
id|p-&gt;next
suffix:semicolon
id|x
op_assign
id|compile_pattern_or
c_func
(paren
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|list
op_logical_or
(paren
op_star
id|list
)paren
op_member_access_from_pointer
id|token
op_ne
id|GREP_CLOSE_PAREN
)paren
id|die
c_func
(paren
l_string|&quot;unmatched parenthesis&quot;
)paren
suffix:semicolon
op_star
id|list
op_assign
(paren
op_star
id|list
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
r_return
id|x
suffix:semicolon
r_default
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
DECL|function|compile_pattern_not
r_static
r_struct
id|grep_expr
op_star
id|compile_pattern_not
c_func
(paren
r_struct
id|grep_pat
op_star
op_star
id|list
)paren
(brace
r_struct
id|grep_pat
op_star
id|p
suffix:semicolon
r_struct
id|grep_expr
op_star
id|x
suffix:semicolon
id|p
op_assign
op_star
id|list
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_return
l_int|NULL
suffix:semicolon
r_switch
c_cond
(paren
id|p-&gt;token
)paren
(brace
r_case
id|GREP_NOT
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;next
)paren
id|die
c_func
(paren
l_string|&quot;--not not followed by pattern expression&quot;
)paren
suffix:semicolon
op_star
id|list
op_assign
id|p-&gt;next
suffix:semicolon
id|x
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|grep_expr
)paren
)paren
suffix:semicolon
id|x-&gt;node
op_assign
id|GREP_NODE_NOT
suffix:semicolon
id|x-&gt;u.unary
op_assign
id|compile_pattern_not
c_func
(paren
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|x-&gt;u.unary
)paren
id|die
c_func
(paren
l_string|&quot;--not followed by non pattern expression&quot;
)paren
suffix:semicolon
r_return
id|x
suffix:semicolon
r_default
suffix:colon
r_return
id|compile_pattern_atom
c_func
(paren
id|list
)paren
suffix:semicolon
)brace
)brace
DECL|function|compile_pattern_and
r_static
r_struct
id|grep_expr
op_star
id|compile_pattern_and
c_func
(paren
r_struct
id|grep_pat
op_star
op_star
id|list
)paren
(brace
r_struct
id|grep_pat
op_star
id|p
suffix:semicolon
r_struct
id|grep_expr
op_star
id|x
comma
op_star
id|y
comma
op_star
id|z
suffix:semicolon
id|x
op_assign
id|compile_pattern_not
c_func
(paren
id|list
)paren
suffix:semicolon
id|p
op_assign
op_star
id|list
suffix:semicolon
r_if
c_cond
(paren
id|p
op_logical_and
id|p-&gt;token
op_eq
id|GREP_AND
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;next
)paren
id|die
c_func
(paren
l_string|&quot;--and not followed by pattern expression&quot;
)paren
suffix:semicolon
op_star
id|list
op_assign
id|p-&gt;next
suffix:semicolon
id|y
op_assign
id|compile_pattern_and
c_func
(paren
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|y
)paren
id|die
c_func
(paren
l_string|&quot;--and not followed by pattern expression&quot;
)paren
suffix:semicolon
id|z
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|grep_expr
)paren
)paren
suffix:semicolon
id|z-&gt;node
op_assign
id|GREP_NODE_AND
suffix:semicolon
id|z-&gt;u.binary.left
op_assign
id|x
suffix:semicolon
id|z-&gt;u.binary.right
op_assign
id|y
suffix:semicolon
r_return
id|z
suffix:semicolon
)brace
r_return
id|x
suffix:semicolon
)brace
DECL|function|compile_pattern_or
r_static
r_struct
id|grep_expr
op_star
id|compile_pattern_or
c_func
(paren
r_struct
id|grep_pat
op_star
op_star
id|list
)paren
(brace
r_struct
id|grep_pat
op_star
id|p
suffix:semicolon
r_struct
id|grep_expr
op_star
id|x
comma
op_star
id|y
comma
op_star
id|z
suffix:semicolon
id|x
op_assign
id|compile_pattern_and
c_func
(paren
id|list
)paren
suffix:semicolon
id|p
op_assign
op_star
id|list
suffix:semicolon
r_if
c_cond
(paren
id|x
op_logical_and
id|p
op_logical_and
id|p-&gt;token
op_ne
id|GREP_CLOSE_PAREN
)paren
(brace
id|y
op_assign
id|compile_pattern_or
c_func
(paren
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|y
)paren
id|die
c_func
(paren
l_string|&quot;not a pattern expression %s&quot;
comma
id|p-&gt;pattern
)paren
suffix:semicolon
id|z
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|grep_expr
)paren
)paren
suffix:semicolon
id|z-&gt;node
op_assign
id|GREP_NODE_OR
suffix:semicolon
id|z-&gt;u.binary.left
op_assign
id|x
suffix:semicolon
id|z-&gt;u.binary.right
op_assign
id|y
suffix:semicolon
r_return
id|z
suffix:semicolon
)brace
r_return
id|x
suffix:semicolon
)brace
DECL|function|compile_pattern_expr
r_static
r_struct
id|grep_expr
op_star
id|compile_pattern_expr
c_func
(paren
r_struct
id|grep_pat
op_star
op_star
id|list
)paren
(brace
r_return
id|compile_pattern_or
c_func
(paren
id|list
)paren
suffix:semicolon
)brace
DECL|function|grep_true_expr
r_static
r_struct
id|grep_expr
op_star
id|grep_true_expr
c_func
(paren
r_void
)paren
(brace
r_struct
id|grep_expr
op_star
id|z
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|z
)paren
)paren
suffix:semicolon
id|z-&gt;node
op_assign
id|GREP_NODE_TRUE
suffix:semicolon
r_return
id|z
suffix:semicolon
)brace
DECL|function|grep_or_expr
r_static
r_struct
id|grep_expr
op_star
id|grep_or_expr
c_func
(paren
r_struct
id|grep_expr
op_star
id|left
comma
r_struct
id|grep_expr
op_star
id|right
)paren
(brace
r_struct
id|grep_expr
op_star
id|z
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|z
)paren
)paren
suffix:semicolon
id|z-&gt;node
op_assign
id|GREP_NODE_OR
suffix:semicolon
id|z-&gt;u.binary.left
op_assign
id|left
suffix:semicolon
id|z-&gt;u.binary.right
op_assign
id|right
suffix:semicolon
r_return
id|z
suffix:semicolon
)brace
DECL|function|prep_header_patterns
r_static
r_struct
id|grep_expr
op_star
id|prep_header_patterns
c_func
(paren
r_struct
id|grep_opt
op_star
id|opt
)paren
(brace
r_struct
id|grep_pat
op_star
id|p
suffix:semicolon
r_struct
id|grep_expr
op_star
id|header_expr
suffix:semicolon
r_struct
id|grep_expr
op_star
(paren
id|header_group
(braket
id|GREP_HEADER_FIELD_MAX
)braket
)paren
suffix:semicolon
r_enum
id|grep_header_field
id|fld
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|opt-&gt;header_list
)paren
r_return
l_int|NULL
suffix:semicolon
id|p
op_assign
id|opt-&gt;header_list
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|opt-&gt;header_list
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;token
op_ne
id|GREP_PATTERN_HEAD
)paren
id|die
c_func
(paren
l_string|&quot;bug: a non-header pattern in grep header list.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;field
OL
l_int|0
op_logical_or
id|GREP_HEADER_FIELD_MAX
op_le
id|p-&gt;field
)paren
id|die
c_func
(paren
l_string|&quot;bug: unknown header field %d&quot;
comma
id|p-&gt;field
)paren
suffix:semicolon
id|compile_regexp
c_func
(paren
id|p
comma
id|opt
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|fld
op_assign
l_int|0
suffix:semicolon
id|fld
OL
id|GREP_HEADER_FIELD_MAX
suffix:semicolon
id|fld
op_increment
)paren
id|header_group
(braket
id|fld
)braket
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|opt-&gt;header_list
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_struct
id|grep_expr
op_star
id|h
suffix:semicolon
r_struct
id|grep_pat
op_star
id|pp
op_assign
id|p
suffix:semicolon
id|h
op_assign
id|compile_pattern_atom
c_func
(paren
op_amp
id|pp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|h
op_logical_or
id|pp
op_ne
id|p-&gt;next
)paren
id|die
c_func
(paren
l_string|&quot;bug: malformed header expr&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|header_group
(braket
id|p-&gt;field
)braket
)paren
(brace
id|header_group
(braket
id|p-&gt;field
)braket
op_assign
id|h
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|header_group
(braket
id|p-&gt;field
)braket
op_assign
id|grep_or_expr
c_func
(paren
id|h
comma
id|header_group
(braket
id|p-&gt;field
)braket
)paren
suffix:semicolon
)brace
id|header_expr
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|fld
op_assign
l_int|0
suffix:semicolon
id|fld
OL
id|GREP_HEADER_FIELD_MAX
suffix:semicolon
id|fld
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|header_group
(braket
id|fld
)braket
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|header_expr
)paren
id|header_expr
op_assign
id|grep_true_expr
c_func
(paren
)paren
suffix:semicolon
id|header_expr
op_assign
id|grep_or_expr
c_func
(paren
id|header_group
(braket
id|fld
)braket
comma
id|header_expr
)paren
suffix:semicolon
)brace
r_return
id|header_expr
suffix:semicolon
)brace
DECL|function|compile_grep_patterns
r_void
id|compile_grep_patterns
c_func
(paren
r_struct
id|grep_opt
op_star
id|opt
)paren
(brace
r_struct
id|grep_pat
op_star
id|p
suffix:semicolon
r_struct
id|grep_expr
op_star
id|header_expr
op_assign
id|prep_header_patterns
c_func
(paren
id|opt
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|opt-&gt;pattern_list
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_switch
c_cond
(paren
id|p-&gt;token
)paren
(brace
r_case
id|GREP_PATTERN
suffix:colon
multiline_comment|/* atom */
r_case
id|GREP_PATTERN_HEAD
suffix:colon
r_case
id|GREP_PATTERN_BODY
suffix:colon
id|compile_regexp
c_func
(paren
id|p
comma
id|opt
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|opt-&gt;extended
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|opt-&gt;all_match
op_logical_or
id|header_expr
)paren
id|opt-&gt;extended
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|opt-&gt;extended
)paren
r_return
suffix:semicolon
id|p
op_assign
id|opt-&gt;pattern_list
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
id|opt-&gt;pattern_expression
op_assign
id|compile_pattern_expr
c_func
(paren
op_amp
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
id|die
c_func
(paren
l_string|&quot;incomplete pattern expression: %s&quot;
comma
id|p-&gt;pattern
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|header_expr
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|opt-&gt;pattern_expression
)paren
id|opt-&gt;pattern_expression
op_assign
id|header_expr
suffix:semicolon
r_else
id|opt-&gt;pattern_expression
op_assign
id|grep_or_expr
c_func
(paren
id|opt-&gt;pattern_expression
comma
id|header_expr
)paren
suffix:semicolon
id|opt-&gt;all_match
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|free_pattern_expr
r_static
r_void
id|free_pattern_expr
c_func
(paren
r_struct
id|grep_expr
op_star
id|x
)paren
(brace
r_switch
c_cond
(paren
id|x-&gt;node
)paren
(brace
r_case
id|GREP_NODE_TRUE
suffix:colon
r_case
id|GREP_NODE_ATOM
suffix:colon
r_break
suffix:semicolon
r_case
id|GREP_NODE_NOT
suffix:colon
id|free_pattern_expr
c_func
(paren
id|x-&gt;u.unary
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GREP_NODE_AND
suffix:colon
r_case
id|GREP_NODE_OR
suffix:colon
id|free_pattern_expr
c_func
(paren
id|x-&gt;u.binary.left
)paren
suffix:semicolon
id|free_pattern_expr
c_func
(paren
id|x-&gt;u.binary.right
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|free
c_func
(paren
id|x
)paren
suffix:semicolon
)brace
DECL|function|free_grep_patterns
r_void
id|free_grep_patterns
c_func
(paren
r_struct
id|grep_opt
op_star
id|opt
)paren
(brace
r_struct
id|grep_pat
op_star
id|p
comma
op_star
id|n
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|opt-&gt;pattern_list
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|n
)paren
(brace
id|n
op_assign
id|p-&gt;next
suffix:semicolon
r_switch
c_cond
(paren
id|p-&gt;token
)paren
(brace
r_case
id|GREP_PATTERN
suffix:colon
multiline_comment|/* atom */
r_case
id|GREP_PATTERN_HEAD
suffix:colon
r_case
id|GREP_PATTERN_BODY
suffix:colon
r_if
c_cond
(paren
id|p-&gt;kws
)paren
id|kwsfree
c_func
(paren
id|p-&gt;kws
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|p-&gt;pcre_regexp
)paren
id|free_pcre_regexp
c_func
(paren
id|p
)paren
suffix:semicolon
r_else
id|regfree
c_func
(paren
op_amp
id|p-&gt;regexp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
id|free
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|opt-&gt;extended
)paren
r_return
suffix:semicolon
id|free_pattern_expr
c_func
(paren
id|opt-&gt;pattern_expression
)paren
suffix:semicolon
)brace
DECL|function|end_of_line
r_static
r_char
op_star
id|end_of_line
c_func
(paren
r_char
op_star
id|cp
comma
r_int
r_int
op_star
id|left
)paren
(brace
r_int
r_int
id|l
op_assign
op_star
id|left
suffix:semicolon
r_while
c_loop
(paren
id|l
op_logical_and
op_star
id|cp
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|l
op_decrement
suffix:semicolon
id|cp
op_increment
suffix:semicolon
)brace
op_star
id|left
op_assign
id|l
suffix:semicolon
r_return
id|cp
suffix:semicolon
)brace
DECL|function|word_char
r_static
r_int
id|word_char
c_func
(paren
r_char
id|ch
)paren
(brace
r_return
id|isalnum
c_func
(paren
id|ch
)paren
op_logical_or
id|ch
op_eq
l_char|&squot;_&squot;
suffix:semicolon
)brace
DECL|function|output_color
r_static
r_void
id|output_color
c_func
(paren
r_struct
id|grep_opt
op_star
id|opt
comma
r_const
r_void
op_star
id|data
comma
r_int
id|size
comma
r_const
r_char
op_star
id|color
)paren
(brace
r_if
c_cond
(paren
id|want_color
c_func
(paren
id|opt-&gt;color
)paren
op_logical_and
id|color
op_logical_and
id|color
(braket
l_int|0
)braket
)paren
(brace
id|opt
op_member_access_from_pointer
id|output
c_func
(paren
id|opt
comma
id|color
comma
id|strlen
c_func
(paren
id|color
)paren
)paren
suffix:semicolon
id|opt
op_member_access_from_pointer
id|output
c_func
(paren
id|opt
comma
id|data
comma
id|size
)paren
suffix:semicolon
id|opt
op_member_access_from_pointer
id|output
c_func
(paren
id|opt
comma
id|GIT_COLOR_RESET
comma
id|strlen
c_func
(paren
id|GIT_COLOR_RESET
)paren
)paren
suffix:semicolon
)brace
r_else
id|opt
op_member_access_from_pointer
id|output
c_func
(paren
id|opt
comma
id|data
comma
id|size
)paren
suffix:semicolon
)brace
DECL|function|output_sep
r_static
r_void
id|output_sep
c_func
(paren
r_struct
id|grep_opt
op_star
id|opt
comma
r_char
id|sign
)paren
(brace
r_if
c_cond
(paren
id|opt-&gt;null_following_name
)paren
id|opt
op_member_access_from_pointer
id|output
c_func
(paren
id|opt
comma
l_string|&quot;&bslash;0&quot;
comma
l_int|1
)paren
suffix:semicolon
r_else
id|output_color
c_func
(paren
id|opt
comma
op_amp
id|sign
comma
l_int|1
comma
id|opt-&gt;color_sep
)paren
suffix:semicolon
)brace
DECL|function|show_name
r_static
r_void
id|show_name
c_func
(paren
r_struct
id|grep_opt
op_star
id|opt
comma
r_const
r_char
op_star
id|name
)paren
(brace
id|output_color
c_func
(paren
id|opt
comma
id|name
comma
id|strlen
c_func
(paren
id|name
)paren
comma
id|opt-&gt;color_filename
)paren
suffix:semicolon
id|opt
op_member_access_from_pointer
id|output
c_func
(paren
id|opt
comma
id|opt-&gt;null_following_name
ques
c_cond
l_string|&quot;&bslash;0&quot;
suffix:colon
l_string|&quot;&bslash;n&quot;
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|fixmatch
r_static
r_int
id|fixmatch
c_func
(paren
r_struct
id|grep_pat
op_star
id|p
comma
r_char
op_star
id|line
comma
r_char
op_star
id|eol
comma
id|regmatch_t
op_star
id|match
)paren
(brace
r_struct
id|kwsmatch
id|kwsm
suffix:semicolon
r_int
id|offset
op_assign
id|kwsexec
c_func
(paren
id|p-&gt;kws
comma
id|line
comma
id|eol
id|line
comma
op_amp
id|kwsm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_eq
l_int|1
)paren
(brace
id|match-&gt;rm_so
op_assign
id|match-&gt;rm_eo
op_assign
l_int|1
suffix:semicolon
r_return
id|REG_NOMATCH
suffix:semicolon
)brace
r_else
(brace
id|match-&gt;rm_so
op_assign
id|offset
suffix:semicolon
id|match-&gt;rm_eo
op_assign
id|match-&gt;rm_so
op_plus
id|kwsm.size
(braket
l_int|0
)braket
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|regmatch
r_static
r_int
id|regmatch
c_func
(paren
r_const
id|regex_t
op_star
id|preg
comma
r_char
op_star
id|line
comma
r_char
op_star
id|eol
comma
id|regmatch_t
op_star
id|match
comma
r_int
id|eflags
)paren
(brace
macro_line|#ifdef REG_STARTEND
id|match-&gt;rm_so
op_assign
l_int|0
suffix:semicolon
id|match-&gt;rm_eo
op_assign
id|eol
id|line
suffix:semicolon
id|eflags
op_or_assign
id|REG_STARTEND
suffix:semicolon
macro_line|#endif
r_return
id|regexec
c_func
(paren
id|preg
comma
id|line
comma
l_int|1
comma
id|match
comma
id|eflags
)paren
suffix:semicolon
)brace
DECL|function|patmatch
r_static
r_int
id|patmatch
c_func
(paren
r_struct
id|grep_pat
op_star
id|p
comma
r_char
op_star
id|line
comma
r_char
op_star
id|eol
comma
id|regmatch_t
op_star
id|match
comma
r_int
id|eflags
)paren
(brace
r_int
id|hit
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;fixed
)paren
id|hit
op_assign
op_logical_neg
id|fixmatch
c_func
(paren
id|p
comma
id|line
comma
id|eol
comma
id|match
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|p-&gt;pcre_regexp
)paren
id|hit
op_assign
op_logical_neg
id|pcrematch
c_func
(paren
id|p
comma
id|line
comma
id|eol
comma
id|match
comma
id|eflags
)paren
suffix:semicolon
r_else
id|hit
op_assign
op_logical_neg
id|regmatch
c_func
(paren
op_amp
id|p-&gt;regexp
comma
id|line
comma
id|eol
comma
id|match
comma
id|eflags
)paren
suffix:semicolon
r_return
id|hit
suffix:semicolon
)brace
DECL|function|strip_timestamp
r_static
r_int
id|strip_timestamp
c_func
(paren
r_char
op_star
id|bol
comma
r_char
op_star
op_star
id|eol_p
)paren
(brace
r_char
op_star
id|eol
op_assign
op_star
id|eol_p
suffix:semicolon
r_int
id|ch
suffix:semicolon
r_while
c_loop
(paren
id|bol
OL
op_decrement
id|eol
)paren
(brace
r_if
c_cond
(paren
op_star
id|eol
op_ne
l_char|&squot;&gt;&squot;
)paren
r_continue
suffix:semicolon
op_star
id|eol_p
op_assign
op_increment
id|eol
suffix:semicolon
id|ch
op_assign
op_star
id|eol
suffix:semicolon
op_star
id|eol
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_return
id|ch
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_struct
(brace
DECL|member|field
r_const
r_char
op_star
id|field
suffix:semicolon
DECL|member|len
r_int
id|len
suffix:semicolon
DECL|variable|header_field
)brace
id|header_field
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;author &quot;
comma
l_int|7
)brace
comma
(brace
l_string|&quot;committer &quot;
comma
l_int|10
)brace
comma
)brace
suffix:semicolon
DECL|function|match_one_pattern
r_static
r_int
id|match_one_pattern
c_func
(paren
r_struct
id|grep_pat
op_star
id|p
comma
r_char
op_star
id|bol
comma
r_char
op_star
id|eol
comma
r_enum
id|grep_context
id|ctx
comma
id|regmatch_t
op_star
id|pmatch
comma
r_int
id|eflags
)paren
(brace
r_int
id|hit
op_assign
l_int|0
suffix:semicolon
r_int
id|saved_ch
op_assign
l_int|0
suffix:semicolon
r_const
r_char
op_star
id|start
op_assign
id|bol
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;token
op_ne
id|GREP_PATTERN
)paren
op_logical_and
(paren
(paren
id|p-&gt;token
op_eq
id|GREP_PATTERN_HEAD
)paren
op_ne
(paren
id|ctx
op_eq
id|GREP_CONTEXT_HEAD
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;token
op_eq
id|GREP_PATTERN_HEAD
)paren
(brace
r_const
r_char
op_star
id|field
suffix:semicolon
r_int
id|len
suffix:semicolon
m_assert
(paren
id|p-&gt;field
OL
id|ARRAY_SIZE
c_func
(paren
id|header_field
)paren
)paren
suffix:semicolon
id|field
op_assign
id|header_field
(braket
id|p-&gt;field
)braket
dot
id|field
suffix:semicolon
id|len
op_assign
id|header_field
(braket
id|p-&gt;field
)braket
dot
id|len
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|bol
comma
id|field
comma
id|len
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|bol
op_add_assign
id|len
suffix:semicolon
id|saved_ch
op_assign
id|strip_timestamp
c_func
(paren
id|bol
comma
op_amp
id|eol
)paren
suffix:semicolon
)brace
id|again
suffix:colon
id|hit
op_assign
id|patmatch
c_func
(paren
id|p
comma
id|bol
comma
id|eol
comma
id|pmatch
comma
id|eflags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hit
op_logical_and
id|p-&gt;word_regexp
)paren
(brace
r_if
c_cond
(paren
(paren
id|pmatch
(braket
l_int|0
)braket
dot
id|rm_so
OL
l_int|0
)paren
op_logical_or
(paren
id|eol
id|bol
)paren
OL
id|pmatch
(braket
l_int|0
)braket
dot
id|rm_so
op_logical_or
(paren
id|pmatch
(braket
l_int|0
)braket
dot
id|rm_eo
OL
l_int|0
)paren
op_logical_or
(paren
id|eol
id|bol
)paren
OL
id|pmatch
(braket
l_int|0
)braket
dot
id|rm_eo
)paren
id|die
c_func
(paren
l_string|&quot;regexp returned nonsense&quot;
)paren
suffix:semicolon
multiline_comment|/* Match beginning must be either beginning of the&n;&t;&t; * line, or at word boundary (i.e. the last char must&n;&t;&t; * not be a word char).  Similarly, match end must be&n;&t;&t; * either end of the line, or at word boundary&n;&t;&t; * (i.e. the next char must not be a word char).&n;&t;&t; */
r_if
c_cond
(paren
(paren
(paren
id|pmatch
(braket
l_int|0
)braket
dot
id|rm_so
op_eq
l_int|0
)paren
op_logical_or
op_logical_neg
id|word_char
c_func
(paren
id|bol
(braket
id|pmatch
(braket
l_int|0
)braket
dot
id|rm_so
op_minus
l_int|1
)braket
)paren
)paren
op_logical_and
(paren
(paren
id|pmatch
(braket
l_int|0
)braket
dot
id|rm_eo
op_eq
(paren
id|eol
op_minus
id|bol
)paren
)paren
op_logical_or
op_logical_neg
id|word_char
c_func
(paren
id|bol
(braket
id|pmatch
(braket
l_int|0
)braket
dot
id|rm_eo
)braket
)paren
)paren
)paren
suffix:semicolon
r_else
id|hit
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Words consist of at least one character. */
r_if
c_cond
(paren
id|pmatch-&gt;rm_so
op_eq
id|pmatch-&gt;rm_eo
)paren
id|hit
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hit
op_logical_and
id|pmatch
(braket
l_int|0
)braket
dot
id|rm_so
op_plus
id|bol
op_plus
l_int|1
OL
id|eol
)paren
(brace
multiline_comment|/* There could be more than one match on the&n;&t;&t;&t; * line, and the first match might not be&n;&t;&t;&t; * strict word match.  But later ones could be!&n;&t;&t;&t; * Forward to the next possible start, i.e. the&n;&t;&t;&t; * next position following a non-word char.&n;&t;&t;&t; */
id|bol
op_assign
id|pmatch
(braket
l_int|0
)braket
dot
id|rm_so
op_plus
id|bol
op_plus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|word_char
c_func
(paren
id|bol
(braket
l_int|1
)braket
)paren
op_logical_and
id|bol
OL
id|eol
)paren
id|bol
op_increment
suffix:semicolon
id|eflags
op_or_assign
id|REG_NOTBOL
suffix:semicolon
r_if
c_cond
(paren
id|bol
OL
id|eol
)paren
r_goto
id|again
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|p-&gt;token
op_eq
id|GREP_PATTERN_HEAD
op_logical_and
id|saved_ch
)paren
op_star
id|eol
op_assign
id|saved_ch
suffix:semicolon
r_if
c_cond
(paren
id|hit
)paren
(brace
id|pmatch
(braket
l_int|0
)braket
dot
id|rm_so
op_add_assign
id|bol
id|start
suffix:semicolon
id|pmatch
(braket
l_int|0
)braket
dot
id|rm_eo
op_add_assign
id|bol
id|start
suffix:semicolon
)brace
r_return
id|hit
suffix:semicolon
)brace
DECL|function|match_expr_eval
r_static
r_int
id|match_expr_eval
c_func
(paren
r_struct
id|grep_expr
op_star
id|x
comma
r_char
op_star
id|bol
comma
r_char
op_star
id|eol
comma
r_enum
id|grep_context
id|ctx
comma
r_int
id|collect_hits
)paren
(brace
r_int
id|h
op_assign
l_int|0
suffix:semicolon
id|regmatch_t
id|match
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|x
)paren
id|die
c_func
(paren
l_string|&quot;Not a valid grep expression&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|x-&gt;node
)paren
(brace
r_case
id|GREP_NODE_TRUE
suffix:colon
id|h
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GREP_NODE_ATOM
suffix:colon
id|h
op_assign
id|match_one_pattern
c_func
(paren
id|x-&gt;u.atom
comma
id|bol
comma
id|eol
comma
id|ctx
comma
op_amp
id|match
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GREP_NODE_NOT
suffix:colon
id|h
op_assign
op_logical_neg
id|match_expr_eval
c_func
(paren
id|x-&gt;u.unary
comma
id|bol
comma
id|eol
comma
id|ctx
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GREP_NODE_AND
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|match_expr_eval
c_func
(paren
id|x-&gt;u.binary.left
comma
id|bol
comma
id|eol
comma
id|ctx
comma
l_int|0
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|h
op_assign
id|match_expr_eval
c_func
(paren
id|x-&gt;u.binary.right
comma
id|bol
comma
id|eol
comma
id|ctx
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GREP_NODE_OR
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|collect_hits
)paren
r_return
(paren
id|match_expr_eval
c_func
(paren
id|x-&gt;u.binary.left
comma
id|bol
comma
id|eol
comma
id|ctx
comma
l_int|0
)paren
op_logical_or
id|match_expr_eval
c_func
(paren
id|x-&gt;u.binary.right
comma
id|bol
comma
id|eol
comma
id|ctx
comma
l_int|0
)paren
)paren
suffix:semicolon
id|h
op_assign
id|match_expr_eval
c_func
(paren
id|x-&gt;u.binary.left
comma
id|bol
comma
id|eol
comma
id|ctx
comma
l_int|0
)paren
suffix:semicolon
id|x-&gt;u.binary.left-&gt;hit
op_or_assign
id|h
suffix:semicolon
id|h
op_or_assign
id|match_expr_eval
c_func
(paren
id|x-&gt;u.binary.right
comma
id|bol
comma
id|eol
comma
id|ctx
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|die
c_func
(paren
l_string|&quot;Unexpected node type (internal error) %d&quot;
comma
id|x-&gt;node
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|collect_hits
)paren
id|x-&gt;hit
op_or_assign
id|h
suffix:semicolon
r_return
id|h
suffix:semicolon
)brace
DECL|function|match_expr
r_static
r_int
id|match_expr
c_func
(paren
r_struct
id|grep_opt
op_star
id|opt
comma
r_char
op_star
id|bol
comma
r_char
op_star
id|eol
comma
r_enum
id|grep_context
id|ctx
comma
r_int
id|collect_hits
)paren
(brace
r_struct
id|grep_expr
op_star
id|x
op_assign
id|opt-&gt;pattern_expression
suffix:semicolon
r_return
id|match_expr_eval
c_func
(paren
id|x
comma
id|bol
comma
id|eol
comma
id|ctx
comma
id|collect_hits
)paren
suffix:semicolon
)brace
DECL|function|match_line
r_static
r_int
id|match_line
c_func
(paren
r_struct
id|grep_opt
op_star
id|opt
comma
r_char
op_star
id|bol
comma
r_char
op_star
id|eol
comma
r_enum
id|grep_context
id|ctx
comma
r_int
id|collect_hits
)paren
(brace
r_struct
id|grep_pat
op_star
id|p
suffix:semicolon
id|regmatch_t
id|match
suffix:semicolon
r_if
c_cond
(paren
id|opt-&gt;extended
)paren
r_return
id|match_expr
c_func
(paren
id|opt
comma
id|bol
comma
id|eol
comma
id|ctx
comma
id|collect_hits
)paren
suffix:semicolon
multiline_comment|/* we do not call with collect_hits without being extended */
r_for
c_loop
(paren
id|p
op_assign
id|opt-&gt;pattern_list
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|match_one_pattern
c_func
(paren
id|p
comma
id|bol
comma
id|eol
comma
id|ctx
comma
op_amp
id|match
comma
l_int|0
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|match_next_pattern
r_static
r_int
id|match_next_pattern
c_func
(paren
r_struct
id|grep_pat
op_star
id|p
comma
r_char
op_star
id|bol
comma
r_char
op_star
id|eol
comma
r_enum
id|grep_context
id|ctx
comma
id|regmatch_t
op_star
id|pmatch
comma
r_int
id|eflags
)paren
(brace
id|regmatch_t
id|match
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|match_one_pattern
c_func
(paren
id|p
comma
id|bol
comma
id|eol
comma
id|ctx
comma
op_amp
id|match
comma
id|eflags
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|match.rm_so
OL
l_int|0
op_logical_or
id|match.rm_eo
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pmatch-&gt;rm_so
op_ge
l_int|0
op_logical_and
id|pmatch-&gt;rm_eo
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|match.rm_so
OG
id|pmatch-&gt;rm_so
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|match.rm_so
op_eq
id|pmatch-&gt;rm_so
op_logical_and
id|match.rm_eo
OL
id|pmatch-&gt;rm_eo
)paren
r_return
l_int|1
suffix:semicolon
)brace
id|pmatch-&gt;rm_so
op_assign
id|match.rm_so
suffix:semicolon
id|pmatch-&gt;rm_eo
op_assign
id|match.rm_eo
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|next_match
r_static
r_int
id|next_match
c_func
(paren
r_struct
id|grep_opt
op_star
id|opt
comma
r_char
op_star
id|bol
comma
r_char
op_star
id|eol
comma
r_enum
id|grep_context
id|ctx
comma
id|regmatch_t
op_star
id|pmatch
comma
r_int
id|eflags
)paren
(brace
r_struct
id|grep_pat
op_star
id|p
suffix:semicolon
r_int
id|hit
op_assign
l_int|0
suffix:semicolon
id|pmatch-&gt;rm_so
op_assign
id|pmatch-&gt;rm_eo
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|bol
OL
id|eol
)paren
(brace
r_for
c_loop
(paren
id|p
op_assign
id|opt-&gt;pattern_list
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_switch
c_cond
(paren
id|p-&gt;token
)paren
(brace
r_case
id|GREP_PATTERN
suffix:colon
multiline_comment|/* atom */
r_case
id|GREP_PATTERN_HEAD
suffix:colon
r_case
id|GREP_PATTERN_BODY
suffix:colon
id|hit
op_or_assign
id|match_next_pattern
c_func
(paren
id|p
comma
id|bol
comma
id|eol
comma
id|ctx
comma
id|pmatch
comma
id|eflags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
)brace
r_return
id|hit
suffix:semicolon
)brace
DECL|function|show_line
r_static
r_void
id|show_line
c_func
(paren
r_struct
id|grep_opt
op_star
id|opt
comma
r_char
op_star
id|bol
comma
r_char
op_star
id|eol
comma
r_const
r_char
op_star
id|name
comma
r_int
id|lno
comma
r_char
id|sign
)paren
(brace
r_int
id|rest
op_assign
id|eol
id|bol
suffix:semicolon
r_char
op_star
id|line_color
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|opt-&gt;file_break
op_logical_and
id|opt-&gt;last_shown
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|opt-&gt;show_hunk_mark
)paren
id|opt
op_member_access_from_pointer
id|output
c_func
(paren
id|opt
comma
l_string|&quot;&bslash;n&quot;
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|opt-&gt;pre_context
op_logical_or
id|opt-&gt;post_context
op_logical_or
id|opt-&gt;funcbody
)paren
(brace
r_if
c_cond
(paren
id|opt-&gt;last_shown
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|opt-&gt;show_hunk_mark
)paren
(brace
id|output_color
c_func
(paren
id|opt
comma
l_string|&quot;--&quot;
comma
l_int|2
comma
id|opt-&gt;color_sep
)paren
suffix:semicolon
id|opt
op_member_access_from_pointer
id|output
c_func
(paren
id|opt
comma
l_string|&quot;&bslash;n&quot;
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|lno
OG
id|opt-&gt;last_shown
op_plus
l_int|1
)paren
(brace
id|output_color
c_func
(paren
id|opt
comma
l_string|&quot;--&quot;
comma
l_int|2
comma
id|opt-&gt;color_sep
)paren
suffix:semicolon
id|opt
op_member_access_from_pointer
id|output
c_func
(paren
id|opt
comma
l_string|&quot;&bslash;n&quot;
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|opt-&gt;heading
op_logical_and
id|opt-&gt;last_shown
op_eq
l_int|0
)paren
(brace
id|output_color
c_func
(paren
id|opt
comma
id|name
comma
id|strlen
c_func
(paren
id|name
)paren
comma
id|opt-&gt;color_filename
)paren
suffix:semicolon
id|opt
op_member_access_from_pointer
id|output
c_func
(paren
id|opt
comma
l_string|&quot;&bslash;n&quot;
comma
l_int|1
)paren
suffix:semicolon
)brace
id|opt-&gt;last_shown
op_assign
id|lno
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|opt-&gt;heading
op_logical_and
id|opt-&gt;pathname
)paren
(brace
id|output_color
c_func
(paren
id|opt
comma
id|name
comma
id|strlen
c_func
(paren
id|name
)paren
comma
id|opt-&gt;color_filename
)paren
suffix:semicolon
id|output_sep
c_func
(paren
id|opt
comma
id|sign
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|opt-&gt;linenum
)paren
(brace
r_char
id|buf
(braket
l_int|32
)braket
suffix:semicolon
id|snprintf
c_func
(paren
id|buf
comma
r_sizeof
(paren
id|buf
)paren
comma
l_string|&quot;%d&quot;
comma
id|lno
)paren
suffix:semicolon
id|output_color
c_func
(paren
id|opt
comma
id|buf
comma
id|strlen
c_func
(paren
id|buf
)paren
comma
id|opt-&gt;color_lineno
)paren
suffix:semicolon
id|output_sep
c_func
(paren
id|opt
comma
id|sign
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|opt-&gt;color
)paren
(brace
id|regmatch_t
id|match
suffix:semicolon
r_enum
id|grep_context
id|ctx
op_assign
id|GREP_CONTEXT_BODY
suffix:semicolon
r_int
id|ch
op_assign
op_star
id|eol
suffix:semicolon
r_int
id|eflags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sign
op_eq
l_char|&squot;:&squot;
)paren
id|line_color
op_assign
id|opt-&gt;color_selected
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sign
op_eq
l_char|&squot;-&squot;
)paren
id|line_color
op_assign
id|opt-&gt;color_context
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sign
op_eq
l_char|&squot;=&squot;
)paren
id|line_color
op_assign
id|opt-&gt;color_function
suffix:semicolon
op_star
id|eol
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_while
c_loop
(paren
id|next_match
c_func
(paren
id|opt
comma
id|bol
comma
id|eol
comma
id|ctx
comma
op_amp
id|match
comma
id|eflags
)paren
)paren
(brace
r_if
c_cond
(paren
id|match.rm_so
op_eq
id|match.rm_eo
)paren
r_break
suffix:semicolon
id|output_color
c_func
(paren
id|opt
comma
id|bol
comma
id|match.rm_so
comma
id|line_color
)paren
suffix:semicolon
id|output_color
c_func
(paren
id|opt
comma
id|bol
op_plus
id|match.rm_so
comma
id|match.rm_eo
id|match.rm_so
comma
id|opt-&gt;color_match
)paren
suffix:semicolon
id|bol
op_add_assign
id|match.rm_eo
suffix:semicolon
id|rest
op_sub_assign
id|match.rm_eo
suffix:semicolon
id|eflags
op_assign
id|REG_NOTBOL
suffix:semicolon
)brace
op_star
id|eol
op_assign
id|ch
suffix:semicolon
)brace
id|output_color
c_func
(paren
id|opt
comma
id|bol
comma
id|rest
comma
id|line_color
)paren
suffix:semicolon
id|opt
op_member_access_from_pointer
id|output
c_func
(paren
id|opt
comma
l_string|&quot;&bslash;n&quot;
comma
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#ifndef NO_PTHREADS
DECL|variable|grep_use_locks
r_int
id|grep_use_locks
suffix:semicolon
multiline_comment|/*&n; * This lock protects access to the gitattributes machinery, which is&n; * not thread-safe.&n; */
DECL|variable|grep_attr_mutex
id|pthread_mutex_t
id|grep_attr_mutex
suffix:semicolon
DECL|function|grep_attr_lock
r_static
r_inline
r_void
id|grep_attr_lock
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|grep_use_locks
)paren
id|pthread_mutex_lock
c_func
(paren
op_amp
id|grep_attr_mutex
)paren
suffix:semicolon
)brace
DECL|function|grep_attr_unlock
r_static
r_inline
r_void
id|grep_attr_unlock
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|grep_use_locks
)paren
id|pthread_mutex_unlock
c_func
(paren
op_amp
id|grep_attr_mutex
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|macro|grep_attr_lock
mdefine_line|#define grep_attr_lock()
DECL|macro|grep_attr_unlock
mdefine_line|#define grep_attr_unlock()
macro_line|#endif
DECL|function|match_funcname
r_static
r_int
id|match_funcname
c_func
(paren
r_struct
id|grep_opt
op_star
id|opt
comma
r_const
r_char
op_star
id|name
comma
r_char
op_star
id|bol
comma
r_char
op_star
id|eol
)paren
(brace
id|xdemitconf_t
op_star
id|xecfg
op_assign
id|opt-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|xecfg
op_logical_and
op_logical_neg
id|xecfg-&gt;find_func
)paren
(brace
r_struct
id|userdiff_driver
op_star
id|drv
suffix:semicolon
id|grep_attr_lock
c_func
(paren
)paren
suffix:semicolon
id|drv
op_assign
id|userdiff_find_by_path
c_func
(paren
id|name
)paren
suffix:semicolon
id|grep_attr_unlock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv
op_logical_and
id|drv-&gt;funcname.pattern
)paren
(brace
r_const
r_struct
id|userdiff_funcname
op_star
id|pe
op_assign
op_amp
id|drv-&gt;funcname
suffix:semicolon
id|xdiff_set_find_func
c_func
(paren
id|xecfg
comma
id|pe-&gt;pattern
comma
id|pe-&gt;cflags
)paren
suffix:semicolon
)brace
r_else
(brace
id|xecfg
op_assign
id|opt-&gt;priv
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|xecfg
)paren
(brace
r_char
id|buf
(braket
l_int|1
)braket
suffix:semicolon
r_return
id|xecfg
op_member_access_from_pointer
id|find_func
c_func
(paren
id|bol
comma
id|eol
id|bol
comma
id|buf
comma
l_int|1
comma
id|xecfg-&gt;find_func_priv
)paren
op_ge
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bol
op_eq
id|eol
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|isalpha
c_func
(paren
op_star
id|bol
)paren
op_logical_or
op_star
id|bol
op_eq
l_char|&squot;_&squot;
op_logical_or
op_star
id|bol
op_eq
l_char|&squot;$&squot;
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|show_funcname_line
r_static
r_void
id|show_funcname_line
c_func
(paren
r_struct
id|grep_opt
op_star
id|opt
comma
r_const
r_char
op_star
id|name
comma
r_char
op_star
id|buf
comma
r_char
op_star
id|bol
comma
r_int
id|lno
)paren
(brace
r_while
c_loop
(paren
id|bol
OG
id|buf
)paren
(brace
r_char
op_star
id|eol
op_assign
op_decrement
id|bol
suffix:semicolon
r_while
c_loop
(paren
id|bol
OG
id|buf
op_logical_and
id|bol
(braket
l_int|1
)braket
op_ne
l_char|&squot;&bslash;n&squot;
)paren
id|bol
op_decrement
suffix:semicolon
id|lno
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|lno
op_le
id|opt-&gt;last_shown
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|match_funcname
c_func
(paren
id|opt
comma
id|name
comma
id|bol
comma
id|eol
)paren
)paren
(brace
id|show_line
c_func
(paren
id|opt
comma
id|bol
comma
id|eol
comma
id|name
comma
id|lno
comma
l_char|&squot;=&squot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
DECL|function|show_pre_context
r_static
r_void
id|show_pre_context
c_func
(paren
r_struct
id|grep_opt
op_star
id|opt
comma
r_const
r_char
op_star
id|name
comma
r_char
op_star
id|buf
comma
r_char
op_star
id|bol
comma
r_char
op_star
id|end
comma
r_int
id|lno
)paren
(brace
r_int
id|cur
op_assign
id|lno
comma
id|from
op_assign
l_int|1
comma
id|funcname_lno
op_assign
l_int|0
suffix:semicolon
r_int
id|funcname_needed
op_assign
op_logical_neg
op_logical_neg
id|opt-&gt;funcname
suffix:semicolon
r_if
c_cond
(paren
id|opt-&gt;funcbody
op_logical_and
op_logical_neg
id|match_funcname
c_func
(paren
id|opt
comma
id|name
comma
id|bol
comma
id|end
)paren
)paren
id|funcname_needed
op_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|opt-&gt;pre_context
OL
id|lno
)paren
id|from
op_assign
id|lno
id|opt-&gt;pre_context
suffix:semicolon
r_if
c_cond
(paren
id|from
op_le
id|opt-&gt;last_shown
)paren
id|from
op_assign
id|opt-&gt;last_shown
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Rewind. */
r_while
c_loop
(paren
id|bol
OG
id|buf
op_logical_and
id|cur
OG
(paren
id|funcname_needed
op_eq
l_int|2
ques
c_cond
id|opt-&gt;last_shown
op_plus
l_int|1
suffix:colon
id|from
)paren
)paren
(brace
r_char
op_star
id|eol
op_assign
op_decrement
id|bol
suffix:semicolon
r_while
c_loop
(paren
id|bol
OG
id|buf
op_logical_and
id|bol
(braket
l_int|1
)braket
op_ne
l_char|&squot;&bslash;n&squot;
)paren
id|bol
op_decrement
suffix:semicolon
id|cur
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|funcname_needed
op_logical_and
id|match_funcname
c_func
(paren
id|opt
comma
id|name
comma
id|bol
comma
id|eol
)paren
)paren
(brace
id|funcname_lno
op_assign
id|cur
suffix:semicolon
id|funcname_needed
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* We need to look even further back to find a function signature. */
r_if
c_cond
(paren
id|opt-&gt;funcname
op_logical_and
id|funcname_needed
)paren
id|show_funcname_line
c_func
(paren
id|opt
comma
id|name
comma
id|buf
comma
id|bol
comma
id|cur
)paren
suffix:semicolon
multiline_comment|/* Back forward. */
r_while
c_loop
(paren
id|cur
OL
id|lno
)paren
(brace
r_char
op_star
id|eol
op_assign
id|bol
comma
id|sign
op_assign
(paren
id|cur
op_eq
id|funcname_lno
)paren
ques
c_cond
l_char|&squot;=&squot;
suffix:colon
l_char|&squot;-&squot;
suffix:semicolon
r_while
c_loop
(paren
op_star
id|eol
op_ne
l_char|&squot;&bslash;n&squot;
)paren
id|eol
op_increment
suffix:semicolon
id|show_line
c_func
(paren
id|opt
comma
id|bol
comma
id|eol
comma
id|name
comma
id|cur
comma
id|sign
)paren
suffix:semicolon
id|bol
op_assign
id|eol
op_plus
l_int|1
suffix:semicolon
id|cur
op_increment
suffix:semicolon
)brace
)brace
DECL|function|should_lookahead
r_static
r_int
id|should_lookahead
c_func
(paren
r_struct
id|grep_opt
op_star
id|opt
)paren
(brace
r_struct
id|grep_pat
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|opt-&gt;extended
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* punt for too complex stuff */
r_if
c_cond
(paren
id|opt-&gt;invert
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|opt-&gt;pattern_list
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;token
op_ne
id|GREP_PATTERN
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* punt for &quot;header only&quot; and stuff */
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|look_ahead
r_static
r_int
id|look_ahead
c_func
(paren
r_struct
id|grep_opt
op_star
id|opt
comma
r_int
r_int
op_star
id|left_p
comma
r_int
op_star
id|lno_p
comma
r_char
op_star
op_star
id|bol_p
)paren
(brace
r_int
id|lno
op_assign
op_star
id|lno_p
suffix:semicolon
r_char
op_star
id|bol
op_assign
op_star
id|bol_p
suffix:semicolon
r_struct
id|grep_pat
op_star
id|p
suffix:semicolon
r_char
op_star
id|sp
comma
op_star
id|last_bol
suffix:semicolon
id|regoff_t
id|earliest
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|opt-&gt;pattern_list
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_int
id|hit
suffix:semicolon
id|regmatch_t
id|m
suffix:semicolon
id|hit
op_assign
id|patmatch
c_func
(paren
id|p
comma
id|bol
comma
id|bol
op_plus
op_star
id|left_p
comma
op_amp
id|m
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hit
op_logical_or
id|m.rm_so
OL
l_int|0
op_logical_or
id|m.rm_eo
OL
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|earliest
OL
l_int|0
op_logical_or
id|m.rm_so
OL
id|earliest
)paren
id|earliest
op_assign
id|m.rm_so
suffix:semicolon
)brace
r_if
c_cond
(paren
id|earliest
OL
l_int|0
)paren
(brace
op_star
id|bol_p
op_assign
id|bol
op_plus
op_star
id|left_p
suffix:semicolon
op_star
id|left_p
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|sp
op_assign
id|bol
op_plus
id|earliest
suffix:semicolon
id|bol
OL
id|sp
op_logical_and
id|sp
(braket
l_int|1
)braket
op_ne
l_char|&squot;&bslash;n&squot;
suffix:semicolon
id|sp
op_decrement
)paren
suffix:semicolon
multiline_comment|/* find the beginning of the line */
id|last_bol
op_assign
id|sp
suffix:semicolon
r_for
c_loop
(paren
id|sp
op_assign
id|bol
suffix:semicolon
id|sp
OL
id|last_bol
suffix:semicolon
id|sp
op_increment
)paren
(brace
r_if
c_cond
(paren
op_star
id|sp
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|lno
op_increment
suffix:semicolon
)brace
op_star
id|left_p
op_sub_assign
id|last_bol
id|bol
suffix:semicolon
op_star
id|bol_p
op_assign
id|last_bol
suffix:semicolon
op_star
id|lno_p
op_assign
id|lno
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|std_output
r_static
r_void
id|std_output
c_func
(paren
r_struct
id|grep_opt
op_star
id|opt
comma
r_const
r_void
op_star
id|buf
comma
r_int
id|size
)paren
(brace
id|fwrite
c_func
(paren
id|buf
comma
id|size
comma
l_int|1
comma
id|stdout
)paren
suffix:semicolon
)brace
DECL|function|grep_buffer_1
r_static
r_int
id|grep_buffer_1
c_func
(paren
r_struct
id|grep_opt
op_star
id|opt
comma
r_const
r_char
op_star
id|name
comma
r_char
op_star
id|buf
comma
r_int
r_int
id|size
comma
r_int
id|collect_hits
)paren
(brace
r_char
op_star
id|bol
op_assign
id|buf
suffix:semicolon
r_int
r_int
id|left
op_assign
id|size
suffix:semicolon
r_int
id|lno
op_assign
l_int|1
suffix:semicolon
r_int
id|last_hit
op_assign
l_int|0
suffix:semicolon
r_int
id|binary_match_only
op_assign
l_int|0
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_int
id|try_lookahead
op_assign
l_int|0
suffix:semicolon
r_int
id|show_function
op_assign
l_int|0
suffix:semicolon
r_enum
id|grep_context
id|ctx
op_assign
id|GREP_CONTEXT_HEAD
suffix:semicolon
id|xdemitconf_t
id|xecfg
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|opt-&gt;output
)paren
id|opt-&gt;output
op_assign
id|std_output
suffix:semicolon
r_if
c_cond
(paren
id|opt-&gt;pre_context
op_logical_or
id|opt-&gt;post_context
op_logical_or
id|opt-&gt;file_break
op_logical_or
id|opt-&gt;funcbody
)paren
(brace
multiline_comment|/* Show hunk marks, except for the first file. */
r_if
c_cond
(paren
id|opt-&gt;last_shown
)paren
id|opt-&gt;show_hunk_mark
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we&squot;re using threads then we can&squot;t easily identify&n;&t;&t; * the first file.  Always put hunk marks in that case&n;&t;&t; * and skip the very first one later in work_done().&n;&t;&t; */
r_if
c_cond
(paren
id|opt-&gt;output
op_ne
id|std_output
)paren
id|opt-&gt;show_hunk_mark
op_assign
l_int|1
suffix:semicolon
)brace
id|opt-&gt;last_shown
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|opt-&gt;binary
)paren
(brace
r_case
id|GREP_BINARY_DEFAULT
suffix:colon
r_if
c_cond
(paren
id|buffer_is_binary
c_func
(paren
id|buf
comma
id|size
)paren
)paren
id|binary_match_only
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GREP_BINARY_NOMATCH
suffix:colon
r_if
c_cond
(paren
id|buffer_is_binary
c_func
(paren
id|buf
comma
id|size
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Assume unmatch */
r_break
suffix:semicolon
r_case
id|GREP_BINARY_TEXT
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|die
c_func
(paren
l_string|&quot;bug: unknown binary handling mode&quot;
)paren
suffix:semicolon
)brace
id|memset
c_func
(paren
op_amp
id|xecfg
comma
l_int|0
comma
r_sizeof
(paren
id|xecfg
)paren
)paren
suffix:semicolon
id|opt-&gt;priv
op_assign
op_amp
id|xecfg
suffix:semicolon
id|try_lookahead
op_assign
id|should_lookahead
c_func
(paren
id|opt
)paren
suffix:semicolon
r_while
c_loop
(paren
id|left
)paren
(brace
r_char
op_star
id|eol
comma
id|ch
suffix:semicolon
r_int
id|hit
suffix:semicolon
multiline_comment|/*&n;&t;&t; * look_ahead() skips quickly to the line that possibly&n;&t;&t; * has the next hit; don&squot;t call it if we need to do&n;&t;&t; * something more than just skipping the current line&n;&t;&t; * in response to an unmatch for the current line.  E.g.&n;&t;&t; * inside a post-context window, we will show the current&n;&t;&t; * line as a context around the previous hit when it&n;&t;&t; * doesn&squot;t hit.&n;&t;&t; */
r_if
c_cond
(paren
id|try_lookahead
op_logical_and
op_logical_neg
(paren
id|last_hit
op_logical_and
(paren
id|show_function
op_logical_or
id|lno
op_le
id|last_hit
op_plus
id|opt-&gt;post_context
)paren
)paren
op_logical_and
id|look_ahead
c_func
(paren
id|opt
comma
op_amp
id|left
comma
op_amp
id|lno
comma
op_amp
id|bol
)paren
)paren
r_break
suffix:semicolon
id|eol
op_assign
id|end_of_line
c_func
(paren
id|bol
comma
op_amp
id|left
)paren
suffix:semicolon
id|ch
op_assign
op_star
id|eol
suffix:semicolon
op_star
id|eol
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ctx
op_eq
id|GREP_CONTEXT_HEAD
)paren
op_logical_and
(paren
id|eol
op_eq
id|bol
)paren
)paren
id|ctx
op_assign
id|GREP_CONTEXT_BODY
suffix:semicolon
id|hit
op_assign
id|match_line
c_func
(paren
id|opt
comma
id|bol
comma
id|eol
comma
id|ctx
comma
id|collect_hits
)paren
suffix:semicolon
op_star
id|eol
op_assign
id|ch
suffix:semicolon
r_if
c_cond
(paren
id|collect_hits
)paren
r_goto
id|next_line
suffix:semicolon
multiline_comment|/* &quot;grep -v -e foo -e bla&quot; should list lines&n;&t;&t; * that do not have either, so inversion should&n;&t;&t; * be done outside.&n;&t;&t; */
r_if
c_cond
(paren
id|opt-&gt;invert
)paren
id|hit
op_assign
op_logical_neg
id|hit
suffix:semicolon
r_if
c_cond
(paren
id|opt-&gt;unmatch_name_only
)paren
(brace
r_if
c_cond
(paren
id|hit
)paren
r_return
l_int|0
suffix:semicolon
r_goto
id|next_line
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hit
)paren
(brace
id|count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|opt-&gt;status_only
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|opt-&gt;name_only
)paren
(brace
id|show_name
c_func
(paren
id|opt
comma
id|name
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|opt-&gt;count
)paren
r_goto
id|next_line
suffix:semicolon
r_if
c_cond
(paren
id|binary_match_only
)paren
(brace
id|opt
op_member_access_from_pointer
id|output
c_func
(paren
id|opt
comma
l_string|&quot;Binary file &quot;
comma
l_int|12
)paren
suffix:semicolon
id|output_color
c_func
(paren
id|opt
comma
id|name
comma
id|strlen
c_func
(paren
id|name
)paren
comma
id|opt-&gt;color_filename
)paren
suffix:semicolon
id|opt
op_member_access_from_pointer
id|output
c_func
(paren
id|opt
comma
l_string|&quot; matches&bslash;n&quot;
comma
l_int|9
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Hit at this line.  If we haven&squot;t shown the&n;&t;&t;&t; * pre-context lines, we would need to show them.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|opt-&gt;pre_context
op_logical_or
id|opt-&gt;funcbody
)paren
id|show_pre_context
c_func
(paren
id|opt
comma
id|name
comma
id|buf
comma
id|bol
comma
id|eol
comma
id|lno
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|opt-&gt;funcname
)paren
id|show_funcname_line
c_func
(paren
id|opt
comma
id|name
comma
id|buf
comma
id|bol
comma
id|lno
)paren
suffix:semicolon
id|show_line
c_func
(paren
id|opt
comma
id|bol
comma
id|eol
comma
id|name
comma
id|lno
comma
l_char|&squot;:&squot;
)paren
suffix:semicolon
id|last_hit
op_assign
id|lno
suffix:semicolon
r_if
c_cond
(paren
id|opt-&gt;funcbody
)paren
id|show_function
op_assign
l_int|1
suffix:semicolon
r_goto
id|next_line
suffix:semicolon
)brace
r_if
c_cond
(paren
id|show_function
op_logical_and
id|match_funcname
c_func
(paren
id|opt
comma
id|name
comma
id|bol
comma
id|eol
)paren
)paren
id|show_function
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|show_function
op_logical_or
(paren
id|last_hit
op_logical_and
id|lno
op_le
id|last_hit
op_plus
id|opt-&gt;post_context
)paren
)paren
(brace
multiline_comment|/* If the last hit is within the post context,&n;&t;&t;&t; * we need to show this line.&n;&t;&t;&t; */
id|show_line
c_func
(paren
id|opt
comma
id|bol
comma
id|eol
comma
id|name
comma
id|lno
comma
l_char|&squot;-&squot;
)paren
suffix:semicolon
)brace
id|next_line
suffix:colon
id|bol
op_assign
id|eol
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|left
)paren
r_break
suffix:semicolon
id|left
op_decrement
suffix:semicolon
id|lno
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|collect_hits
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|opt-&gt;status_only
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|opt-&gt;unmatch_name_only
)paren
(brace
multiline_comment|/* We did not see any hit, so we want to show this */
id|show_name
c_func
(paren
id|opt
comma
id|name
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|xdiff_clear_find_func
c_func
(paren
op_amp
id|xecfg
)paren
suffix:semicolon
id|opt-&gt;priv
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* NEEDSWORK:&n;&t; * The real &quot;grep -c foo *.c&quot; gives many &quot;bar.c:0&quot; lines,&n;&t; * which feels mostly useless but sometimes useful.  Maybe&n;&t; * make it another option?  For now suppress them.&n;&t; */
r_if
c_cond
(paren
id|opt-&gt;count
op_logical_and
id|count
)paren
(brace
r_char
id|buf
(braket
l_int|32
)braket
suffix:semicolon
id|output_color
c_func
(paren
id|opt
comma
id|name
comma
id|strlen
c_func
(paren
id|name
)paren
comma
id|opt-&gt;color_filename
)paren
suffix:semicolon
id|output_sep
c_func
(paren
id|opt
comma
l_char|&squot;:&squot;
)paren
suffix:semicolon
id|snprintf
c_func
(paren
id|buf
comma
r_sizeof
(paren
id|buf
)paren
comma
l_string|&quot;%u&bslash;n&quot;
comma
id|count
)paren
suffix:semicolon
id|opt
op_member_access_from_pointer
id|output
c_func
(paren
id|opt
comma
id|buf
comma
id|strlen
c_func
(paren
id|buf
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
op_logical_neg
op_logical_neg
id|last_hit
suffix:semicolon
)brace
DECL|function|clr_hit_marker
r_static
r_void
id|clr_hit_marker
c_func
(paren
r_struct
id|grep_expr
op_star
id|x
)paren
(brace
multiline_comment|/* All-hit markers are meaningful only at the very top level&n;&t; * OR node.&n;&t; */
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|x-&gt;hit
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|x-&gt;node
op_ne
id|GREP_NODE_OR
)paren
r_return
suffix:semicolon
id|x-&gt;u.binary.left-&gt;hit
op_assign
l_int|0
suffix:semicolon
id|x
op_assign
id|x-&gt;u.binary.right
suffix:semicolon
)brace
)brace
DECL|function|chk_hit_marker
r_static
r_int
id|chk_hit_marker
c_func
(paren
r_struct
id|grep_expr
op_star
id|x
)paren
(brace
multiline_comment|/* Top level nodes have hit markers.  See if they all are hits */
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|x-&gt;node
op_ne
id|GREP_NODE_OR
)paren
r_return
id|x-&gt;hit
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|x-&gt;u.binary.left-&gt;hit
)paren
r_return
l_int|0
suffix:semicolon
id|x
op_assign
id|x-&gt;u.binary.right
suffix:semicolon
)brace
)brace
DECL|function|grep_buffer
r_int
id|grep_buffer
c_func
(paren
r_struct
id|grep_opt
op_star
id|opt
comma
r_const
r_char
op_star
id|name
comma
r_char
op_star
id|buf
comma
r_int
r_int
id|size
)paren
(brace
multiline_comment|/*&n;&t; * we do not have to do the two-pass grep when we do not check&n;&t; * buffer-wide &quot;all-match&quot;.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|opt-&gt;all_match
)paren
r_return
id|grep_buffer_1
c_func
(paren
id|opt
comma
id|name
comma
id|buf
comma
id|size
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Otherwise the toplevel &quot;or&quot; terms hit a bit differently.&n;&t; * We first clear hit markers from them.&n;&t; */
id|clr_hit_marker
c_func
(paren
id|opt-&gt;pattern_expression
)paren
suffix:semicolon
id|grep_buffer_1
c_func
(paren
id|opt
comma
id|name
comma
id|buf
comma
id|size
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chk_hit_marker
c_func
(paren
id|opt-&gt;pattern_expression
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|grep_buffer_1
c_func
(paren
id|opt
comma
id|name
comma
id|buf
comma
id|size
comma
l_int|0
)paren
suffix:semicolon
)brace
eof
