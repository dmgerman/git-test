multiline_comment|/*&n; * apply.c&n; *&n; * Copyright (C) Linus Torvalds, 2005&n; *&n; * This applies patches on top of some (arbitrary) version of the SCM.&n; *&n; */
macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;cache-tree.h&quot;
macro_line|#include &quot;quote.h&quot;
macro_line|#include &quot;blob.h&quot;
macro_line|#include &quot;delta.h&quot;
macro_line|#include &quot;builtin.h&quot;
macro_line|#include &quot;string-list.h&quot;
macro_line|#include &quot;dir.h&quot;
macro_line|#include &quot;diff.h&quot;
macro_line|#include &quot;parse-options.h&quot;
macro_line|#include &quot;xdiff-interface.h&quot;
macro_line|#include &quot;ll-merge.h&quot;
macro_line|#include &quot;rerere.h&quot;
multiline_comment|/*&n; *  --check turns on checking that the working tree matches the&n; *    files that are being modified, but doesn&squot;t apply the patch&n; *  --stat does just a diffstat, and doesn&squot;t actually apply&n; *  --numstat does numeric diffstat, and doesn&squot;t actually apply&n; *  --index-info shows the old and new index info for paths if available.&n; *  --index updates the cache as well.&n; *  --cached updates only the cache without ever touching the working tree.&n; */
DECL|variable|prefix
r_static
r_const
r_char
op_star
id|prefix
suffix:semicolon
DECL|variable|prefix_length
r_static
r_int
id|prefix_length
op_assign
l_int|1
suffix:semicolon
DECL|variable|newfd
r_static
r_int
id|newfd
op_assign
l_int|1
suffix:semicolon
DECL|variable|unidiff_zero
r_static
r_int
id|unidiff_zero
suffix:semicolon
DECL|variable|p_value
r_static
r_int
id|p_value
op_assign
l_int|1
suffix:semicolon
DECL|variable|p_value_known
r_static
r_int
id|p_value_known
suffix:semicolon
DECL|variable|check_index
r_static
r_int
id|check_index
suffix:semicolon
DECL|variable|update_index
r_static
r_int
id|update_index
suffix:semicolon
DECL|variable|cached
r_static
r_int
id|cached
suffix:semicolon
DECL|variable|diffstat
r_static
r_int
id|diffstat
suffix:semicolon
DECL|variable|numstat
r_static
r_int
id|numstat
suffix:semicolon
DECL|variable|summary
r_static
r_int
id|summary
suffix:semicolon
DECL|variable|check
r_static
r_int
id|check
suffix:semicolon
DECL|variable|apply
r_static
r_int
id|apply
op_assign
l_int|1
suffix:semicolon
DECL|variable|apply_in_reverse
r_static
r_int
id|apply_in_reverse
suffix:semicolon
DECL|variable|apply_with_reject
r_static
r_int
id|apply_with_reject
suffix:semicolon
DECL|variable|apply_verbosely
r_static
r_int
id|apply_verbosely
suffix:semicolon
DECL|variable|allow_overlap
r_static
r_int
id|allow_overlap
suffix:semicolon
DECL|variable|no_add
r_static
r_int
id|no_add
suffix:semicolon
DECL|variable|threeway
r_static
r_int
id|threeway
suffix:semicolon
DECL|variable|fake_ancestor
r_static
r_const
r_char
op_star
id|fake_ancestor
suffix:semicolon
DECL|variable|line_termination
r_static
r_int
id|line_termination
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
DECL|variable|p_context
r_static
r_int
r_int
id|p_context
op_assign
id|UINT_MAX
suffix:semicolon
DECL|variable|apply_usage
r_static
r_const
r_char
op_star
r_const
id|apply_usage
(braket
)braket
op_assign
(brace
id|N_
c_func
(paren
l_string|&quot;git apply [options] [&lt;patch&gt;...]&quot;
)paren
comma
l_int|NULL
)brace
suffix:semicolon
DECL|enum|ws_error_action
r_static
r_enum
id|ws_error_action
(brace
DECL|enumerator|nowarn_ws_error
id|nowarn_ws_error
comma
DECL|enumerator|warn_on_ws_error
id|warn_on_ws_error
comma
DECL|enumerator|die_on_ws_error
id|die_on_ws_error
comma
DECL|enumerator|correct_ws_error
id|correct_ws_error
DECL|variable|ws_error_action
)brace
id|ws_error_action
op_assign
id|warn_on_ws_error
suffix:semicolon
DECL|variable|whitespace_error
r_static
r_int
id|whitespace_error
suffix:semicolon
DECL|variable|squelch_whitespace_errors
r_static
r_int
id|squelch_whitespace_errors
op_assign
l_int|5
suffix:semicolon
DECL|variable|applied_after_fixing_ws
r_static
r_int
id|applied_after_fixing_ws
suffix:semicolon
DECL|enum|ws_ignore
r_static
r_enum
id|ws_ignore
(brace
DECL|enumerator|ignore_ws_none
id|ignore_ws_none
comma
DECL|enumerator|ignore_ws_change
id|ignore_ws_change
DECL|variable|ws_ignore_action
)brace
id|ws_ignore_action
op_assign
id|ignore_ws_none
suffix:semicolon
DECL|variable|patch_input_file
r_static
r_const
r_char
op_star
id|patch_input_file
suffix:semicolon
DECL|variable|root
r_static
r_const
r_char
op_star
id|root
suffix:semicolon
DECL|variable|root_len
r_static
r_int
id|root_len
suffix:semicolon
DECL|variable|read_stdin
r_static
r_int
id|read_stdin
op_assign
l_int|1
suffix:semicolon
DECL|variable|options
r_static
r_int
id|options
suffix:semicolon
DECL|function|parse_whitespace_option
r_static
r_void
id|parse_whitespace_option
c_func
(paren
r_const
r_char
op_star
id|option
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|option
)paren
(brace
id|ws_error_action
op_assign
id|warn_on_ws_error
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|option
comma
l_string|&quot;warn&quot;
)paren
)paren
(brace
id|ws_error_action
op_assign
id|warn_on_ws_error
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|option
comma
l_string|&quot;nowarn&quot;
)paren
)paren
(brace
id|ws_error_action
op_assign
id|nowarn_ws_error
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|option
comma
l_string|&quot;error&quot;
)paren
)paren
(brace
id|ws_error_action
op_assign
id|die_on_ws_error
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|option
comma
l_string|&quot;error-all&quot;
)paren
)paren
(brace
id|ws_error_action
op_assign
id|die_on_ws_error
suffix:semicolon
id|squelch_whitespace_errors
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|option
comma
l_string|&quot;strip&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|option
comma
l_string|&quot;fix&quot;
)paren
)paren
(brace
id|ws_error_action
op_assign
id|correct_ws_error
suffix:semicolon
r_return
suffix:semicolon
)brace
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;unrecognized whitespace option &squot;%s&squot;&quot;
)paren
comma
id|option
)paren
suffix:semicolon
)brace
DECL|function|parse_ignorewhitespace_option
r_static
r_void
id|parse_ignorewhitespace_option
c_func
(paren
r_const
r_char
op_star
id|option
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|option
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|option
comma
l_string|&quot;no&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|option
comma
l_string|&quot;false&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|option
comma
l_string|&quot;never&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|option
comma
l_string|&quot;none&quot;
)paren
)paren
(brace
id|ws_ignore_action
op_assign
id|ignore_ws_none
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|option
comma
l_string|&quot;change&quot;
)paren
)paren
(brace
id|ws_ignore_action
op_assign
id|ignore_ws_change
suffix:semicolon
r_return
suffix:semicolon
)brace
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;unrecognized whitespace ignore option &squot;%s&squot;&quot;
)paren
comma
id|option
)paren
suffix:semicolon
)brace
DECL|function|set_default_whitespace_mode
r_static
r_void
id|set_default_whitespace_mode
c_func
(paren
r_const
r_char
op_star
id|whitespace_option
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|whitespace_option
op_logical_and
op_logical_neg
id|apply_default_whitespace
)paren
id|ws_error_action
op_assign
(paren
id|apply
ques
c_cond
id|warn_on_ws_error
suffix:colon
id|nowarn_ws_error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * For &quot;diff-stat&quot; like behaviour, we keep track of the biggest change&n; * we&squot;ve seen, and the longest filename. That allows us to do simple&n; * scaling.&n; */
DECL|variable|max_change
DECL|variable|max_len
r_static
r_int
id|max_change
comma
id|max_len
suffix:semicolon
multiline_comment|/*&n; * Various &quot;current state&quot;, notably line numbers and what&n; * file (and how) we&squot;re patching right now.. The &quot;is_xxxx&quot;&n; * things are flags, where -1 means &quot;don&squot;t know yet&quot;.&n; */
DECL|variable|linenr
r_static
r_int
id|linenr
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n; * This represents one &quot;hunk&quot; from a patch, starting with&n; * &quot;@@ -oldpos,oldlines +newpos,newlines @@&quot; marker.  The&n; * patch text is pointed at by patch, and its byte length&n; * is stored in size.  leading and trailing are the number&n; * of context lines.&n; */
DECL|struct|fragment
r_struct
id|fragment
(brace
DECL|member|leading
DECL|member|trailing
r_int
r_int
id|leading
comma
id|trailing
suffix:semicolon
DECL|member|oldpos
DECL|member|oldlines
r_int
r_int
id|oldpos
comma
id|oldlines
suffix:semicolon
DECL|member|newpos
DECL|member|newlines
r_int
r_int
id|newpos
comma
id|newlines
suffix:semicolon
multiline_comment|/*&n;&t; * &squot;patch&squot; is usually borrowed from buf in apply_patch(),&n;&t; * but some codepaths store an allocated buffer.&n;&t; */
DECL|member|patch
r_const
r_char
op_star
id|patch
suffix:semicolon
DECL|member|free_patch
r_int
id|free_patch
suffix:colon
l_int|1
comma
DECL|member|rejected
id|rejected
suffix:colon
l_int|1
suffix:semicolon
DECL|member|size
r_int
id|size
suffix:semicolon
DECL|member|linenr
r_int
id|linenr
suffix:semicolon
DECL|member|next
r_struct
id|fragment
op_star
id|next
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * When dealing with a binary patch, we reuse &quot;leading&quot; field&n; * to store the type of the binary hunk, either deflated &quot;delta&quot;&n; * or deflated &quot;literal&quot;.&n; */
DECL|macro|binary_patch_method
mdefine_line|#define binary_patch_method leading
DECL|macro|BINARY_DELTA_DEFLATED
mdefine_line|#define BINARY_DELTA_DEFLATED&t;1
DECL|macro|BINARY_LITERAL_DEFLATED
mdefine_line|#define BINARY_LITERAL_DEFLATED 2
multiline_comment|/*&n; * This represents a &quot;patch&quot; to a file, both metainfo changes&n; * such as creation/deletion, filemode and content changes represented&n; * as a series of fragments.&n; */
DECL|struct|patch
r_struct
id|patch
(brace
DECL|member|new_name
DECL|member|old_name
DECL|member|def_name
r_char
op_star
id|new_name
comma
op_star
id|old_name
comma
op_star
id|def_name
suffix:semicolon
DECL|member|old_mode
DECL|member|new_mode
r_int
r_int
id|old_mode
comma
id|new_mode
suffix:semicolon
DECL|member|is_new
DECL|member|is_delete
r_int
id|is_new
comma
id|is_delete
suffix:semicolon
multiline_comment|/* -1 = unknown, 0 = false, 1 = true */
DECL|member|rejected
r_int
id|rejected
suffix:semicolon
DECL|member|ws_rule
r_int
id|ws_rule
suffix:semicolon
DECL|member|lines_added
DECL|member|lines_deleted
r_int
id|lines_added
comma
id|lines_deleted
suffix:semicolon
DECL|member|score
r_int
id|score
suffix:semicolon
DECL|member|is_toplevel_relative
r_int
r_int
id|is_toplevel_relative
suffix:colon
l_int|1
suffix:semicolon
DECL|member|inaccurate_eof
r_int
r_int
id|inaccurate_eof
suffix:colon
l_int|1
suffix:semicolon
DECL|member|is_binary
r_int
r_int
id|is_binary
suffix:colon
l_int|1
suffix:semicolon
DECL|member|is_copy
r_int
r_int
id|is_copy
suffix:colon
l_int|1
suffix:semicolon
DECL|member|is_rename
r_int
r_int
id|is_rename
suffix:colon
l_int|1
suffix:semicolon
DECL|member|recount
r_int
r_int
id|recount
suffix:colon
l_int|1
suffix:semicolon
DECL|member|conflicted_threeway
r_int
r_int
id|conflicted_threeway
suffix:colon
l_int|1
suffix:semicolon
DECL|member|direct_to_threeway
r_int
r_int
id|direct_to_threeway
suffix:colon
l_int|1
suffix:semicolon
DECL|member|fragments
r_struct
id|fragment
op_star
id|fragments
suffix:semicolon
DECL|member|result
r_char
op_star
id|result
suffix:semicolon
DECL|member|resultsize
r_int
id|resultsize
suffix:semicolon
DECL|member|old_sha1_prefix
r_char
id|old_sha1_prefix
(braket
l_int|41
)braket
suffix:semicolon
DECL|member|new_sha1_prefix
r_char
id|new_sha1_prefix
(braket
l_int|41
)braket
suffix:semicolon
DECL|member|next
r_struct
id|patch
op_star
id|next
suffix:semicolon
multiline_comment|/* three-way fallback result */
DECL|member|threeway_stage
r_int
r_char
id|threeway_stage
(braket
l_int|3
)braket
(braket
l_int|20
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|function|free_fragment_list
r_static
r_void
id|free_fragment_list
c_func
(paren
r_struct
id|fragment
op_star
id|list
)paren
(brace
r_while
c_loop
(paren
id|list
)paren
(brace
r_struct
id|fragment
op_star
id|next
op_assign
id|list-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|list-&gt;free_patch
)paren
id|free
c_func
(paren
(paren
r_char
op_star
)paren
id|list-&gt;patch
)paren
suffix:semicolon
id|free
c_func
(paren
id|list
)paren
suffix:semicolon
id|list
op_assign
id|next
suffix:semicolon
)brace
)brace
DECL|function|free_patch
r_static
r_void
id|free_patch
c_func
(paren
r_struct
id|patch
op_star
id|patch
)paren
(brace
id|free_fragment_list
c_func
(paren
id|patch-&gt;fragments
)paren
suffix:semicolon
id|free
c_func
(paren
id|patch-&gt;def_name
)paren
suffix:semicolon
id|free
c_func
(paren
id|patch-&gt;old_name
)paren
suffix:semicolon
id|free
c_func
(paren
id|patch-&gt;new_name
)paren
suffix:semicolon
id|free
c_func
(paren
id|patch-&gt;result
)paren
suffix:semicolon
id|free
c_func
(paren
id|patch
)paren
suffix:semicolon
)brace
DECL|function|free_patch_list
r_static
r_void
id|free_patch_list
c_func
(paren
r_struct
id|patch
op_star
id|list
)paren
(brace
r_while
c_loop
(paren
id|list
)paren
(brace
r_struct
id|patch
op_star
id|next
op_assign
id|list-&gt;next
suffix:semicolon
id|free_patch
c_func
(paren
id|list
)paren
suffix:semicolon
id|list
op_assign
id|next
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * A line in a file, len-bytes long (includes the terminating LF,&n; * except for an incomplete line at the end if the file ends with&n; * one), and its contents hashes to &squot;hash&squot;.&n; */
DECL|struct|line
r_struct
id|line
(brace
DECL|member|len
r_int
id|len
suffix:semicolon
DECL|member|hash
r_int
id|hash
suffix:colon
l_int|24
suffix:semicolon
DECL|member|flag
r_int
id|flag
suffix:colon
l_int|8
suffix:semicolon
DECL|macro|LINE_COMMON
mdefine_line|#define LINE_COMMON     1
DECL|macro|LINE_PATCHED
mdefine_line|#define LINE_PATCHED&t;2
)brace
suffix:semicolon
multiline_comment|/*&n; * This represents a &quot;file&quot;, which is an array of &quot;lines&quot;.&n; */
DECL|struct|image
r_struct
id|image
(brace
DECL|member|buf
r_char
op_star
id|buf
suffix:semicolon
DECL|member|len
r_int
id|len
suffix:semicolon
DECL|member|nr
r_int
id|nr
suffix:semicolon
DECL|member|alloc
r_int
id|alloc
suffix:semicolon
DECL|member|line_allocated
r_struct
id|line
op_star
id|line_allocated
suffix:semicolon
DECL|member|line
r_struct
id|line
op_star
id|line
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Records filenames that have been touched, in order to handle&n; * the case where more than one patches touch the same file.&n; */
DECL|variable|fn_table
r_static
r_struct
id|string_list
id|fn_table
suffix:semicolon
DECL|function|hash_line
r_static
r_uint32
id|hash_line
c_func
(paren
r_const
r_char
op_star
id|cp
comma
r_int
id|len
)paren
(brace
r_int
id|i
suffix:semicolon
r_uint32
id|h
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|h
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|isspace
c_func
(paren
id|cp
(braket
id|i
)braket
)paren
)paren
(brace
id|h
op_assign
id|h
op_star
l_int|3
op_plus
(paren
id|cp
(braket
id|i
)braket
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
)brace
r_return
id|h
suffix:semicolon
)brace
multiline_comment|/*&n; * Compare lines s1 of length n1 and s2 of length n2, ignoring&n; * whitespace difference. Returns 1 if they match, 0 otherwise&n; */
DECL|function|fuzzy_matchlines
r_static
r_int
id|fuzzy_matchlines
c_func
(paren
r_const
r_char
op_star
id|s1
comma
r_int
id|n1
comma
r_const
r_char
op_star
id|s2
comma
r_int
id|n2
)paren
(brace
r_const
r_char
op_star
id|last1
op_assign
id|s1
op_plus
id|n1
l_int|1
suffix:semicolon
r_const
r_char
op_star
id|last2
op_assign
id|s2
op_plus
id|n2
l_int|1
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* ignore line endings */
r_while
c_loop
(paren
(paren
op_star
id|last1
op_eq
l_char|&squot;&bslash;r&squot;
)paren
op_logical_or
(paren
op_star
id|last1
op_eq
l_char|&squot;&bslash;n&squot;
)paren
)paren
id|last1
op_decrement
suffix:semicolon
r_while
c_loop
(paren
(paren
op_star
id|last2
op_eq
l_char|&squot;&bslash;r&squot;
)paren
op_logical_or
(paren
op_star
id|last2
op_eq
l_char|&squot;&bslash;n&squot;
)paren
)paren
id|last2
op_decrement
suffix:semicolon
multiline_comment|/* skip leading whitespace */
r_while
c_loop
(paren
id|isspace
c_func
(paren
op_star
id|s1
)paren
op_logical_and
(paren
id|s1
op_le
id|last1
)paren
)paren
id|s1
op_increment
suffix:semicolon
r_while
c_loop
(paren
id|isspace
c_func
(paren
op_star
id|s2
)paren
op_logical_and
(paren
id|s2
op_le
id|last2
)paren
)paren
id|s2
op_increment
suffix:semicolon
multiline_comment|/* early return if both lines are empty */
r_if
c_cond
(paren
(paren
id|s1
OG
id|last1
)paren
op_logical_and
(paren
id|s2
OG
id|last2
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|result
)paren
(brace
id|result
op_assign
op_star
id|s1
op_increment
op_star
id|s2
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Skip whitespace inside. We check for whitespace on&n;&t;&t; * both buffers because we don&squot;t want &quot;a b&quot; to match&n;&t;&t; * &quot;ab&quot;&n;&t;&t; */
r_if
c_cond
(paren
id|isspace
c_func
(paren
op_star
id|s1
)paren
op_logical_and
id|isspace
c_func
(paren
op_star
id|s2
)paren
)paren
(brace
r_while
c_loop
(paren
id|isspace
c_func
(paren
op_star
id|s1
)paren
op_logical_and
id|s1
op_le
id|last1
)paren
id|s1
op_increment
suffix:semicolon
r_while
c_loop
(paren
id|isspace
c_func
(paren
op_star
id|s2
)paren
op_logical_and
id|s2
op_le
id|last2
)paren
id|s2
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If we reached the end on one side only,&n;&t;&t; * lines don&squot;t match&n;&t;&t; */
r_if
c_cond
(paren
(paren
(paren
id|s2
OG
id|last2
)paren
op_logical_and
(paren
id|s1
op_le
id|last1
)paren
)paren
op_logical_or
(paren
(paren
id|s1
OG
id|last1
)paren
op_logical_and
(paren
id|s2
op_le
id|last2
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|s1
OG
id|last1
)paren
op_logical_and
(paren
id|s2
OG
id|last2
)paren
)paren
r_break
suffix:semicolon
)brace
r_return
op_logical_neg
id|result
suffix:semicolon
)brace
DECL|function|add_line_info
r_static
r_void
id|add_line_info
c_func
(paren
r_struct
id|image
op_star
id|img
comma
r_const
r_char
op_star
id|bol
comma
r_int
id|len
comma
r_int
id|flag
)paren
(brace
id|ALLOC_GROW
c_func
(paren
id|img-&gt;line_allocated
comma
id|img-&gt;nr
op_plus
l_int|1
comma
id|img-&gt;alloc
)paren
suffix:semicolon
id|img-&gt;line_allocated
(braket
id|img-&gt;nr
)braket
dot
id|len
op_assign
id|len
suffix:semicolon
id|img-&gt;line_allocated
(braket
id|img-&gt;nr
)braket
dot
id|hash
op_assign
id|hash_line
c_func
(paren
id|bol
comma
id|len
)paren
suffix:semicolon
id|img-&gt;line_allocated
(braket
id|img-&gt;nr
)braket
dot
id|flag
op_assign
id|flag
suffix:semicolon
id|img-&gt;nr
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; * &quot;buf&quot; has the file contents to be patched (read from various sources).&n; * attach it to &quot;image&quot; and add line-based index to it.&n; * &quot;image&quot; now owns the &quot;buf&quot;.&n; */
DECL|function|prepare_image
r_static
r_void
id|prepare_image
c_func
(paren
r_struct
id|image
op_star
id|image
comma
r_char
op_star
id|buf
comma
r_int
id|len
comma
r_int
id|prepare_linetable
)paren
(brace
r_const
r_char
op_star
id|cp
comma
op_star
id|ep
suffix:semicolon
id|memset
c_func
(paren
id|image
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|image
)paren
)paren
suffix:semicolon
id|image-&gt;buf
op_assign
id|buf
suffix:semicolon
id|image-&gt;len
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prepare_linetable
)paren
r_return
suffix:semicolon
id|ep
op_assign
id|image-&gt;buf
op_plus
id|image-&gt;len
suffix:semicolon
id|cp
op_assign
id|image-&gt;buf
suffix:semicolon
r_while
c_loop
(paren
id|cp
OL
id|ep
)paren
(brace
r_const
r_char
op_star
id|next
suffix:semicolon
r_for
c_loop
(paren
id|next
op_assign
id|cp
suffix:semicolon
id|next
OL
id|ep
op_logical_and
op_star
id|next
op_ne
l_char|&squot;&bslash;n&squot;
suffix:semicolon
id|next
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|next
OL
id|ep
)paren
id|next
op_increment
suffix:semicolon
id|add_line_info
c_func
(paren
id|image
comma
id|cp
comma
id|next
id|cp
comma
l_int|0
)paren
suffix:semicolon
id|cp
op_assign
id|next
suffix:semicolon
)brace
id|image-&gt;line
op_assign
id|image-&gt;line_allocated
suffix:semicolon
)brace
DECL|function|clear_image
r_static
r_void
id|clear_image
c_func
(paren
r_struct
id|image
op_star
id|image
)paren
(brace
id|free
c_func
(paren
id|image-&gt;buf
)paren
suffix:semicolon
id|free
c_func
(paren
id|image-&gt;line_allocated
)paren
suffix:semicolon
id|memset
c_func
(paren
id|image
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|image
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* fmt must contain _one_ %s and no other substitution */
DECL|function|say_patch_name
r_static
r_void
id|say_patch_name
c_func
(paren
id|FILE
op_star
id|output
comma
r_const
r_char
op_star
id|fmt
comma
r_struct
id|patch
op_star
id|patch
)paren
(brace
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
r_if
c_cond
(paren
id|patch-&gt;old_name
op_logical_and
id|patch-&gt;new_name
op_logical_and
id|strcmp
c_func
(paren
id|patch-&gt;old_name
comma
id|patch-&gt;new_name
)paren
)paren
(brace
id|quote_c_style
c_func
(paren
id|patch-&gt;old_name
comma
op_amp
id|sb
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|sb
comma
l_string|&quot; =&gt; &quot;
)paren
suffix:semicolon
id|quote_c_style
c_func
(paren
id|patch-&gt;new_name
comma
op_amp
id|sb
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
r_const
r_char
op_star
id|n
op_assign
id|patch-&gt;new_name
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n
)paren
id|n
op_assign
id|patch-&gt;old_name
suffix:semicolon
id|quote_c_style
c_func
(paren
id|n
comma
op_amp
id|sb
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
id|fprintf
c_func
(paren
id|output
comma
id|fmt
comma
id|sb.buf
)paren
suffix:semicolon
id|fputc
c_func
(paren
l_char|&squot;&bslash;n&squot;
comma
id|output
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
)brace
DECL|macro|SLOP
mdefine_line|#define SLOP (16)
DECL|function|read_patch_file
r_static
r_void
id|read_patch_file
c_func
(paren
r_struct
id|strbuf
op_star
id|sb
comma
r_int
id|fd
)paren
(brace
r_if
c_cond
(paren
id|strbuf_read
c_func
(paren
id|sb
comma
id|fd
comma
l_int|0
)paren
OL
l_int|0
)paren
id|die_errno
c_func
(paren
l_string|&quot;git apply: failed to read&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Make sure that we have some slop in the buffer&n;&t; * so that we can do speculative &quot;memcmp&quot; etc, and&n;&t; * see to it that it is NUL-filled.&n;&t; */
id|strbuf_grow
c_func
(paren
id|sb
comma
id|SLOP
)paren
suffix:semicolon
id|memset
c_func
(paren
id|sb-&gt;buf
op_plus
id|sb-&gt;len
comma
l_int|0
comma
id|SLOP
)paren
suffix:semicolon
)brace
DECL|function|linelen
r_static
r_int
r_int
id|linelen
c_func
(paren
r_const
r_char
op_star
id|buffer
comma
r_int
r_int
id|size
)paren
(brace
r_int
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|size
op_decrement
)paren
(brace
id|len
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|buffer
op_increment
op_eq
l_char|&squot;&bslash;n&squot;
)paren
r_break
suffix:semicolon
)brace
r_return
id|len
suffix:semicolon
)brace
DECL|function|is_dev_null
r_static
r_int
id|is_dev_null
c_func
(paren
r_const
r_char
op_star
id|str
)paren
(brace
r_return
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;/dev/null&quot;
comma
id|str
comma
l_int|9
)paren
op_logical_and
id|isspace
c_func
(paren
id|str
(braket
l_int|9
)braket
)paren
suffix:semicolon
)brace
DECL|macro|TERM_SPACE
mdefine_line|#define TERM_SPACE&t;1
DECL|macro|TERM_TAB
mdefine_line|#define TERM_TAB&t;2
DECL|function|name_terminate
r_static
r_int
id|name_terminate
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_int
id|namelen
comma
r_int
id|c
comma
r_int
id|terminate
)paren
(brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot; &squot;
op_logical_and
op_logical_neg
(paren
id|terminate
op_amp
id|TERM_SPACE
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;t&squot;
op_logical_and
op_logical_neg
(paren
id|terminate
op_amp
id|TERM_TAB
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* remove double slashes to make --index work with such filenames */
DECL|function|squash_slash
r_static
r_char
op_star
id|squash_slash
c_func
(paren
r_char
op_star
id|name
)paren
(brace
r_int
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
r_return
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|name
(braket
id|i
)braket
)paren
(brace
r_if
c_cond
(paren
(paren
id|name
(braket
id|j
op_increment
)braket
op_assign
id|name
(braket
id|i
op_increment
)braket
)paren
op_eq
l_char|&squot;/&squot;
)paren
r_while
c_loop
(paren
id|name
(braket
id|i
)braket
op_eq
l_char|&squot;/&squot;
)paren
id|i
op_increment
suffix:semicolon
)brace
id|name
(braket
id|j
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_return
id|name
suffix:semicolon
)brace
DECL|function|find_name_gnu
r_static
r_char
op_star
id|find_name_gnu
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_const
r_char
op_star
id|def
comma
r_int
id|p_value
)paren
(brace
r_struct
id|strbuf
id|name
op_assign
id|STRBUF_INIT
suffix:semicolon
r_char
op_star
id|cp
suffix:semicolon
multiline_comment|/*&n;&t; * Proposed &quot;new-style&quot; GNU patch/diff format; see&n;&t; * http://marc.info/?l=git&amp;m=112927316408690&amp;w=2&n;&t; */
r_if
c_cond
(paren
id|unquote_c_style
c_func
(paren
op_amp
id|name
comma
id|line
comma
l_int|NULL
)paren
)paren
(brace
id|strbuf_release
c_func
(paren
op_amp
id|name
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_for
c_loop
(paren
id|cp
op_assign
id|name.buf
suffix:semicolon
id|p_value
suffix:semicolon
id|p_value
op_decrement
)paren
(brace
id|cp
op_assign
id|strchr
c_func
(paren
id|cp
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
(brace
id|strbuf_release
c_func
(paren
op_amp
id|name
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|cp
op_increment
suffix:semicolon
)brace
id|strbuf_remove
c_func
(paren
op_amp
id|name
comma
l_int|0
comma
id|cp
id|name.buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|root
)paren
id|strbuf_insert
c_func
(paren
op_amp
id|name
comma
l_int|0
comma
id|root
comma
id|root_len
)paren
suffix:semicolon
r_return
id|squash_slash
c_func
(paren
id|strbuf_detach
c_func
(paren
op_amp
id|name
comma
l_int|NULL
)paren
)paren
suffix:semicolon
)brace
DECL|function|sane_tz_len
r_static
r_int
id|sane_tz_len
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_int
id|len
)paren
(brace
r_const
r_char
op_star
id|tz
comma
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
id|strlen
c_func
(paren
l_string|&quot; +0500&quot;
)paren
op_logical_or
id|line
(braket
id|len
op_minus
id|strlen
c_func
(paren
l_string|&quot; +0500&quot;
)paren
)braket
op_ne
l_char|&squot; &squot;
)paren
r_return
l_int|0
suffix:semicolon
id|tz
op_assign
id|line
op_plus
id|len
id|strlen
c_func
(paren
l_string|&quot; +0500&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tz
(braket
l_int|1
)braket
op_ne
l_char|&squot;+&squot;
op_logical_and
id|tz
(braket
l_int|1
)braket
op_ne
l_char|&squot;-&squot;
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|tz
op_plus
l_int|2
suffix:semicolon
id|p
op_ne
id|line
op_plus
id|len
suffix:semicolon
id|p
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|isdigit
c_func
(paren
op_star
id|p
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|line
op_plus
id|len
id|tz
suffix:semicolon
)brace
DECL|function|tz_with_colon_len
r_static
r_int
id|tz_with_colon_len
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_int
id|len
)paren
(brace
r_const
r_char
op_star
id|tz
comma
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
id|strlen
c_func
(paren
l_string|&quot; +08:00&quot;
)paren
op_logical_or
id|line
(braket
id|len
id|strlen
c_func
(paren
l_string|&quot;:00&quot;
)paren
)braket
op_ne
l_char|&squot;:&squot;
)paren
r_return
l_int|0
suffix:semicolon
id|tz
op_assign
id|line
op_plus
id|len
id|strlen
c_func
(paren
l_string|&quot; +08:00&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tz
(braket
l_int|0
)braket
op_ne
l_char|&squot; &squot;
op_logical_or
(paren
id|tz
(braket
l_int|1
)braket
op_ne
l_char|&squot;+&squot;
op_logical_and
id|tz
(braket
l_int|1
)braket
op_ne
l_char|&squot;-&squot;
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|p
op_assign
id|tz
op_plus
l_int|2
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|isdigit
c_func
(paren
op_star
id|p
op_increment
)paren
op_logical_or
op_logical_neg
id|isdigit
c_func
(paren
op_star
id|p
op_increment
)paren
op_logical_or
op_star
id|p
op_increment
op_ne
l_char|&squot;:&squot;
op_logical_or
op_logical_neg
id|isdigit
c_func
(paren
op_star
id|p
op_increment
)paren
op_logical_or
op_logical_neg
id|isdigit
c_func
(paren
op_star
id|p
op_increment
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|line
op_plus
id|len
id|tz
suffix:semicolon
)brace
DECL|function|date_len
r_static
r_int
id|date_len
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_int
id|len
)paren
(brace
r_const
r_char
op_star
id|date
comma
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
id|strlen
c_func
(paren
l_string|&quot;72-02-05&quot;
)paren
op_logical_or
id|line
(braket
id|len
op_minus
id|strlen
c_func
(paren
l_string|&quot;-05&quot;
)paren
)braket
op_ne
l_char|&squot;-&squot;
)paren
r_return
l_int|0
suffix:semicolon
id|p
op_assign
id|date
op_assign
id|line
op_plus
id|len
id|strlen
c_func
(paren
l_string|&quot;72-02-05&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|isdigit
c_func
(paren
op_star
id|p
op_increment
)paren
op_logical_or
op_logical_neg
id|isdigit
c_func
(paren
op_star
id|p
op_increment
)paren
op_logical_or
op_star
id|p
op_increment
op_ne
l_char|&squot;-&squot;
op_logical_or
op_logical_neg
id|isdigit
c_func
(paren
op_star
id|p
op_increment
)paren
op_logical_or
op_logical_neg
id|isdigit
c_func
(paren
op_star
id|p
op_increment
)paren
op_logical_or
op_star
id|p
op_increment
op_ne
l_char|&squot;-&squot;
op_logical_or
op_logical_neg
id|isdigit
c_func
(paren
op_star
id|p
op_increment
)paren
op_logical_or
op_logical_neg
id|isdigit
c_func
(paren
op_star
id|p
op_increment
)paren
)paren
multiline_comment|/* Not a date. */
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|date
id|line
op_ge
id|strlen
c_func
(paren
l_string|&quot;19&quot;
)paren
op_logical_and
id|isdigit
c_func
(paren
id|date
(braket
l_int|1
)braket
)paren
op_logical_and
id|isdigit
c_func
(paren
id|date
(braket
l_int|2
)braket
)paren
)paren
multiline_comment|/* 4-digit year */
id|date
op_sub_assign
id|strlen
c_func
(paren
l_string|&quot;19&quot;
)paren
suffix:semicolon
r_return
id|line
op_plus
id|len
id|date
suffix:semicolon
)brace
DECL|function|short_time_len
r_static
r_int
id|short_time_len
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_int
id|len
)paren
(brace
r_const
r_char
op_star
id|time
comma
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
id|strlen
c_func
(paren
l_string|&quot; 07:01:32&quot;
)paren
op_logical_or
id|line
(braket
id|len
op_minus
id|strlen
c_func
(paren
l_string|&quot;:32&quot;
)paren
)braket
op_ne
l_char|&squot;:&squot;
)paren
r_return
l_int|0
suffix:semicolon
id|p
op_assign
id|time
op_assign
id|line
op_plus
id|len
id|strlen
c_func
(paren
l_string|&quot; 07:01:32&quot;
)paren
suffix:semicolon
multiline_comment|/* Permit 1-digit hours? */
r_if
c_cond
(paren
op_star
id|p
op_increment
op_ne
l_char|&squot; &squot;
op_logical_or
op_logical_neg
id|isdigit
c_func
(paren
op_star
id|p
op_increment
)paren
op_logical_or
op_logical_neg
id|isdigit
c_func
(paren
op_star
id|p
op_increment
)paren
op_logical_or
op_star
id|p
op_increment
op_ne
l_char|&squot;:&squot;
op_logical_or
op_logical_neg
id|isdigit
c_func
(paren
op_star
id|p
op_increment
)paren
op_logical_or
op_logical_neg
id|isdigit
c_func
(paren
op_star
id|p
op_increment
)paren
op_logical_or
op_star
id|p
op_increment
op_ne
l_char|&squot;:&squot;
op_logical_or
op_logical_neg
id|isdigit
c_func
(paren
op_star
id|p
op_increment
)paren
op_logical_or
op_logical_neg
id|isdigit
c_func
(paren
op_star
id|p
op_increment
)paren
)paren
multiline_comment|/* Not a time. */
r_return
l_int|0
suffix:semicolon
r_return
id|line
op_plus
id|len
id|time
suffix:semicolon
)brace
DECL|function|fractional_time_len
r_static
r_int
id|fractional_time_len
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_int
id|len
)paren
(brace
r_const
r_char
op_star
id|p
suffix:semicolon
r_int
id|n
suffix:semicolon
multiline_comment|/* Expected format: 19:41:17.620000023 */
r_if
c_cond
(paren
op_logical_neg
id|len
op_logical_or
op_logical_neg
id|isdigit
c_func
(paren
id|line
(braket
id|len
l_int|1
)braket
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|p
op_assign
id|line
op_plus
id|len
l_int|1
suffix:semicolon
multiline_comment|/* Fractional seconds. */
r_while
c_loop
(paren
id|p
OG
id|line
op_logical_and
id|isdigit
c_func
(paren
op_star
id|p
)paren
)paren
id|p
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p
op_ne
l_char|&squot;.&squot;
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Hours, minutes, and whole seconds. */
id|n
op_assign
id|short_time_len
c_func
(paren
id|line
comma
id|p
id|line
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|line
op_plus
id|len
id|p
op_plus
id|n
suffix:semicolon
)brace
DECL|function|trailing_spaces_len
r_static
r_int
id|trailing_spaces_len
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_int
id|len
)paren
(brace
r_const
r_char
op_star
id|p
suffix:semicolon
multiline_comment|/* Expected format: &squot; &squot; x (1 or more)  */
r_if
c_cond
(paren
op_logical_neg
id|len
op_logical_or
id|line
(braket
id|len
l_int|1
)braket
op_ne
l_char|&squot; &squot;
)paren
r_return
l_int|0
suffix:semicolon
id|p
op_assign
id|line
op_plus
id|len
suffix:semicolon
r_while
c_loop
(paren
id|p
op_ne
id|line
)paren
(brace
id|p
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p
op_ne
l_char|&squot; &squot;
)paren
r_return
id|line
op_plus
id|len
(paren
id|p
op_plus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* All spaces! */
r_return
id|len
suffix:semicolon
)brace
DECL|function|diff_timestamp_len
r_static
r_int
id|diff_timestamp_len
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_int
id|len
)paren
(brace
r_const
r_char
op_star
id|end
op_assign
id|line
op_plus
id|len
suffix:semicolon
r_int
id|n
suffix:semicolon
multiline_comment|/*&n;&t; * Posix: 2010-07-05 19:41:17&n;&t; * GNU: 2010-07-05 19:41:17.620000023 -0500&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|isdigit
c_func
(paren
id|end
(braket
l_int|1
)braket
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|n
op_assign
id|sane_tz_len
c_func
(paren
id|line
comma
id|end
id|line
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n
)paren
id|n
op_assign
id|tz_with_colon_len
c_func
(paren
id|line
comma
id|end
id|line
)paren
suffix:semicolon
id|end
op_sub_assign
id|n
suffix:semicolon
id|n
op_assign
id|short_time_len
c_func
(paren
id|line
comma
id|end
id|line
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n
)paren
id|n
op_assign
id|fractional_time_len
c_func
(paren
id|line
comma
id|end
id|line
)paren
suffix:semicolon
id|end
op_sub_assign
id|n
suffix:semicolon
id|n
op_assign
id|date_len
c_func
(paren
id|line
comma
id|end
id|line
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n
)paren
multiline_comment|/* No date.  Too bad. */
r_return
l_int|0
suffix:semicolon
id|end
op_sub_assign
id|n
suffix:semicolon
r_if
c_cond
(paren
id|end
op_eq
id|line
)paren
multiline_comment|/* No space before date. */
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|end
(braket
l_int|1
)braket
op_eq
l_char|&squot;&bslash;t&squot;
)paren
(brace
multiline_comment|/* Success! */
id|end
op_decrement
suffix:semicolon
r_return
id|line
op_plus
id|len
id|end
suffix:semicolon
)brace
r_if
c_cond
(paren
id|end
(braket
l_int|1
)braket
op_ne
l_char|&squot; &squot;
)paren
multiline_comment|/* No space before date. */
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Whitespace damage. */
id|end
op_sub_assign
id|trailing_spaces_len
c_func
(paren
id|line
comma
id|end
id|line
)paren
suffix:semicolon
r_return
id|line
op_plus
id|len
id|end
suffix:semicolon
)brace
DECL|function|null_strdup
r_static
r_char
op_star
id|null_strdup
c_func
(paren
r_const
r_char
op_star
id|s
)paren
(brace
r_return
id|s
ques
c_cond
id|xstrdup
c_func
(paren
id|s
)paren
suffix:colon
l_int|NULL
suffix:semicolon
)brace
DECL|function|find_name_common
r_static
r_char
op_star
id|find_name_common
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_const
r_char
op_star
id|def
comma
r_int
id|p_value
comma
r_const
r_char
op_star
id|end
comma
r_int
id|terminate
)paren
(brace
r_int
id|len
suffix:semicolon
r_const
r_char
op_star
id|start
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|p_value
op_eq
l_int|0
)paren
id|start
op_assign
id|line
suffix:semicolon
r_while
c_loop
(paren
id|line
op_ne
id|end
)paren
(brace
r_char
id|c
op_assign
op_star
id|line
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|end
op_logical_and
id|isspace
c_func
(paren
id|c
)paren
)paren
(brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|name_terminate
c_func
(paren
id|start
comma
id|line
op_minus
id|start
comma
id|c
comma
id|terminate
)paren
)paren
r_break
suffix:semicolon
)brace
id|line
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;/&squot;
op_logical_and
op_logical_neg
op_decrement
id|p_value
)paren
id|start
op_assign
id|line
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|start
)paren
r_return
id|squash_slash
c_func
(paren
id|null_strdup
c_func
(paren
id|def
)paren
)paren
suffix:semicolon
id|len
op_assign
id|line
id|start
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
r_return
id|squash_slash
c_func
(paren
id|null_strdup
c_func
(paren
id|def
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Generally we prefer the shorter name, especially&n;&t; * if the other one is just a variation of that with&n;&t; * something else tacked on to the end (ie &quot;file.orig&quot;&n;&t; * or &quot;file~&quot;).&n;&t; */
r_if
c_cond
(paren
id|def
)paren
(brace
r_int
id|deflen
op_assign
id|strlen
c_func
(paren
id|def
)paren
suffix:semicolon
r_if
c_cond
(paren
id|deflen
OL
id|len
op_logical_and
op_logical_neg
id|strncmp
c_func
(paren
id|start
comma
id|def
comma
id|deflen
)paren
)paren
r_return
id|squash_slash
c_func
(paren
id|xstrdup
c_func
(paren
id|def
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|root
)paren
(brace
r_char
op_star
id|ret
op_assign
id|xmalloc
c_func
(paren
id|root_len
op_plus
id|len
op_plus
l_int|1
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|ret
comma
id|root
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ret
op_plus
id|root_len
comma
id|start
comma
id|len
)paren
suffix:semicolon
id|ret
(braket
id|root_len
op_plus
id|len
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_return
id|squash_slash
c_func
(paren
id|ret
)paren
suffix:semicolon
)brace
r_return
id|squash_slash
c_func
(paren
id|xmemdupz
c_func
(paren
id|start
comma
id|len
)paren
)paren
suffix:semicolon
)brace
DECL|function|find_name
r_static
r_char
op_star
id|find_name
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_char
op_star
id|def
comma
r_int
id|p_value
comma
r_int
id|terminate
)paren
(brace
r_if
c_cond
(paren
op_star
id|line
op_eq
l_char|&squot;&quot;&squot;
)paren
(brace
r_char
op_star
id|name
op_assign
id|find_name_gnu
c_func
(paren
id|line
comma
id|def
comma
id|p_value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|name
)paren
r_return
id|name
suffix:semicolon
)brace
r_return
id|find_name_common
c_func
(paren
id|line
comma
id|def
comma
id|p_value
comma
l_int|NULL
comma
id|terminate
)paren
suffix:semicolon
)brace
DECL|function|find_name_traditional
r_static
r_char
op_star
id|find_name_traditional
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_char
op_star
id|def
comma
r_int
id|p_value
)paren
(brace
r_int
id|len
suffix:semicolon
r_int
id|date_len
suffix:semicolon
r_if
c_cond
(paren
op_star
id|line
op_eq
l_char|&squot;&quot;&squot;
)paren
(brace
r_char
op_star
id|name
op_assign
id|find_name_gnu
c_func
(paren
id|line
comma
id|def
comma
id|p_value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|name
)paren
r_return
id|name
suffix:semicolon
)brace
id|len
op_assign
id|strchrnul
c_func
(paren
id|line
comma
l_char|&squot;&bslash;n&squot;
)paren
id|line
suffix:semicolon
id|date_len
op_assign
id|diff_timestamp_len
c_func
(paren
id|line
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|date_len
)paren
r_return
id|find_name_common
c_func
(paren
id|line
comma
id|def
comma
id|p_value
comma
l_int|NULL
comma
id|TERM_TAB
)paren
suffix:semicolon
id|len
op_sub_assign
id|date_len
suffix:semicolon
r_return
id|find_name_common
c_func
(paren
id|line
comma
id|def
comma
id|p_value
comma
id|line
op_plus
id|len
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|count_slashes
r_static
r_int
id|count_slashes
c_func
(paren
r_const
r_char
op_star
id|cp
)paren
(brace
r_int
id|cnt
op_assign
l_int|0
suffix:semicolon
r_char
id|ch
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ch
op_assign
op_star
id|cp
op_increment
)paren
)paren
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;/&squot;
)paren
id|cnt
op_increment
suffix:semicolon
r_return
id|cnt
suffix:semicolon
)brace
multiline_comment|/*&n; * Given the string after &quot;--- &quot; or &quot;+++ &quot;, guess the appropriate&n; * p_value for the given patch.&n; */
DECL|function|guess_p_value
r_static
r_int
id|guess_p_value
c_func
(paren
r_const
r_char
op_star
id|nameline
)paren
(brace
r_char
op_star
id|name
comma
op_star
id|cp
suffix:semicolon
r_int
id|val
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|is_dev_null
c_func
(paren
id|nameline
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|name
op_assign
id|find_name_traditional
c_func
(paren
id|nameline
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
r_return
l_int|1
suffix:semicolon
id|cp
op_assign
id|strchr
c_func
(paren
id|name
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
id|val
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|prefix
)paren
(brace
multiline_comment|/*&n;&t;&t; * Does it begin with &quot;a/$our-prefix&quot; and such?  Then this is&n;&t;&t; * very likely to apply to our directory.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|name
comma
id|prefix
comma
id|prefix_length
)paren
)paren
id|val
op_assign
id|count_slashes
c_func
(paren
id|prefix
)paren
suffix:semicolon
r_else
(brace
id|cp
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|cp
comma
id|prefix
comma
id|prefix_length
)paren
)paren
id|val
op_assign
id|count_slashes
c_func
(paren
id|prefix
)paren
op_plus
l_int|1
suffix:semicolon
)brace
)brace
id|free
c_func
(paren
id|name
)paren
suffix:semicolon
r_return
id|val
suffix:semicolon
)brace
multiline_comment|/*&n; * Does the ---/+++ line has the POSIX timestamp after the last HT?&n; * GNU diff puts epoch there to signal a creation/deletion event.  Is&n; * this such a timestamp?&n; */
DECL|function|has_epoch_timestamp
r_static
r_int
id|has_epoch_timestamp
c_func
(paren
r_const
r_char
op_star
id|nameline
)paren
(brace
multiline_comment|/*&n;&t; * We are only interested in epoch timestamp; any non-zero&n;&t; * fraction cannot be one, hence &quot;(&bslash;.0+)?&quot; in the regexp below.&n;&t; * For the same reason, the date must be either 1969-12-31 or&n;&t; * 1970-01-01, and the seconds part must be &quot;00&quot;.&n;&t; */
r_const
r_char
id|stamp_regexp
(braket
)braket
op_assign
l_string|&quot;^(1969-12-31|1970-01-01)&quot;
l_string|&quot; &quot;
l_string|&quot;[0-2][0-9]:[0-5][0-9]:00(&bslash;&bslash;.0+)?&quot;
l_string|&quot; &quot;
l_string|&quot;([-+][0-2][0-9]:?[0-5][0-9])&bslash;n&quot;
suffix:semicolon
r_const
r_char
op_star
id|timestamp
op_assign
l_int|NULL
comma
op_star
id|cp
comma
op_star
id|colon
suffix:semicolon
r_static
id|regex_t
op_star
id|stamp
suffix:semicolon
id|regmatch_t
id|m
(braket
l_int|10
)braket
suffix:semicolon
r_int
id|zoneoffset
suffix:semicolon
r_int
id|hourminute
suffix:semicolon
r_int
id|status
suffix:semicolon
r_for
c_loop
(paren
id|cp
op_assign
id|nameline
suffix:semicolon
op_star
id|cp
op_ne
l_char|&squot;&bslash;n&squot;
suffix:semicolon
id|cp
op_increment
)paren
(brace
r_if
c_cond
(paren
op_star
id|cp
op_eq
l_char|&squot;&bslash;t&squot;
)paren
id|timestamp
op_assign
id|cp
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|timestamp
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stamp
)paren
(brace
id|stamp
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|stamp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|regcomp
c_func
(paren
id|stamp
comma
id|stamp_regexp
comma
id|REG_EXTENDED
)paren
)paren
(brace
id|warning
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Cannot prepare timestamp regexp %s&quot;
)paren
comma
id|stamp_regexp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|status
op_assign
id|regexec
c_func
(paren
id|stamp
comma
id|timestamp
comma
id|ARRAY_SIZE
c_func
(paren
id|m
)paren
comma
id|m
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
(brace
r_if
c_cond
(paren
id|status
op_ne
id|REG_NOMATCH
)paren
id|warning
c_func
(paren
id|_
c_func
(paren
l_string|&quot;regexec returned %d for input: %s&quot;
)paren
comma
id|status
comma
id|timestamp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|zoneoffset
op_assign
id|strtol
c_func
(paren
id|timestamp
op_plus
id|m
(braket
l_int|3
)braket
dot
id|rm_so
op_plus
l_int|1
comma
(paren
r_char
op_star
op_star
)paren
op_amp
id|colon
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|colon
op_eq
l_char|&squot;:&squot;
)paren
id|zoneoffset
op_assign
id|zoneoffset
op_star
l_int|60
op_plus
id|strtol
c_func
(paren
id|colon
op_plus
l_int|1
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_else
id|zoneoffset
op_assign
(paren
id|zoneoffset
op_div
l_int|100
)paren
op_star
l_int|60
op_plus
(paren
id|zoneoffset
op_mod
l_int|100
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timestamp
(braket
id|m
(braket
l_int|3
)braket
dot
id|rm_so
)braket
op_eq
l_char|&squot;-&squot;
)paren
id|zoneoffset
op_assign
id|zoneoffset
suffix:semicolon
multiline_comment|/*&n;&t; * YYYY-MM-DD hh:mm:ss must be from either 1969-12-31&n;&t; * (west of GMT) or 1970-01-01 (east of GMT)&n;&t; */
r_if
c_cond
(paren
(paren
id|zoneoffset
OL
l_int|0
op_logical_and
id|memcmp
c_func
(paren
id|timestamp
comma
l_string|&quot;1969-12-31&quot;
comma
l_int|10
)paren
)paren
op_logical_or
(paren
l_int|0
op_le
id|zoneoffset
op_logical_and
id|memcmp
c_func
(paren
id|timestamp
comma
l_string|&quot;1970-01-01&quot;
comma
l_int|10
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|hourminute
op_assign
(paren
id|strtol
c_func
(paren
id|timestamp
op_plus
l_int|11
comma
l_int|NULL
comma
l_int|10
)paren
op_star
l_int|60
op_plus
id|strtol
c_func
(paren
id|timestamp
op_plus
l_int|14
comma
l_int|NULL
comma
l_int|10
)paren
id|zoneoffset
)paren
suffix:semicolon
r_return
(paren
(paren
id|zoneoffset
OL
l_int|0
op_logical_and
id|hourminute
op_eq
l_int|1440
)paren
op_logical_or
(paren
l_int|0
op_le
id|zoneoffset
op_logical_and
op_logical_neg
id|hourminute
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Get the name etc info from the ---/+++ lines of a traditional patch header&n; *&n; * FIXME! The end-of-filename heuristics are kind of screwy. For existing&n; * files, we can happily check the index for a match, but for creating a&n; * new file we should try to match whatever &quot;patch&quot; does. I have no idea.&n; */
DECL|function|parse_traditional_patch
r_static
r_void
id|parse_traditional_patch
c_func
(paren
r_const
r_char
op_star
id|first
comma
r_const
r_char
op_star
id|second
comma
r_struct
id|patch
op_star
id|patch
)paren
(brace
r_char
op_star
id|name
suffix:semicolon
id|first
op_add_assign
l_int|4
suffix:semicolon
multiline_comment|/* skip &quot;--- &quot; */
id|second
op_add_assign
l_int|4
suffix:semicolon
multiline_comment|/* skip &quot;+++ &quot; */
r_if
c_cond
(paren
op_logical_neg
id|p_value_known
)paren
(brace
r_int
id|p
comma
id|q
suffix:semicolon
id|p
op_assign
id|guess_p_value
c_func
(paren
id|first
)paren
suffix:semicolon
id|q
op_assign
id|guess_p_value
c_func
(paren
id|second
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
OL
l_int|0
)paren
id|p
op_assign
id|q
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_le
id|p
op_logical_and
id|p
op_eq
id|q
)paren
(brace
id|p_value
op_assign
id|p
suffix:semicolon
id|p_value_known
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|is_dev_null
c_func
(paren
id|first
)paren
)paren
(brace
id|patch-&gt;is_new
op_assign
l_int|1
suffix:semicolon
id|patch-&gt;is_delete
op_assign
l_int|0
suffix:semicolon
id|name
op_assign
id|find_name_traditional
c_func
(paren
id|second
comma
l_int|NULL
comma
id|p_value
)paren
suffix:semicolon
id|patch-&gt;new_name
op_assign
id|name
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|is_dev_null
c_func
(paren
id|second
)paren
)paren
(brace
id|patch-&gt;is_new
op_assign
l_int|0
suffix:semicolon
id|patch-&gt;is_delete
op_assign
l_int|1
suffix:semicolon
id|name
op_assign
id|find_name_traditional
c_func
(paren
id|first
comma
l_int|NULL
comma
id|p_value
)paren
suffix:semicolon
id|patch-&gt;old_name
op_assign
id|name
suffix:semicolon
)brace
r_else
(brace
r_char
op_star
id|first_name
suffix:semicolon
id|first_name
op_assign
id|find_name_traditional
c_func
(paren
id|first
comma
l_int|NULL
comma
id|p_value
)paren
suffix:semicolon
id|name
op_assign
id|find_name_traditional
c_func
(paren
id|second
comma
id|first_name
comma
id|p_value
)paren
suffix:semicolon
id|free
c_func
(paren
id|first_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|has_epoch_timestamp
c_func
(paren
id|first
)paren
)paren
(brace
id|patch-&gt;is_new
op_assign
l_int|1
suffix:semicolon
id|patch-&gt;is_delete
op_assign
l_int|0
suffix:semicolon
id|patch-&gt;new_name
op_assign
id|name
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|has_epoch_timestamp
c_func
(paren
id|second
)paren
)paren
(brace
id|patch-&gt;is_new
op_assign
l_int|0
suffix:semicolon
id|patch-&gt;is_delete
op_assign
l_int|1
suffix:semicolon
id|patch-&gt;old_name
op_assign
id|name
suffix:semicolon
)brace
r_else
(brace
id|patch-&gt;old_name
op_assign
id|name
suffix:semicolon
id|patch-&gt;new_name
op_assign
id|null_strdup
c_func
(paren
id|name
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;unable to find filename in patch at line %d&quot;
)paren
comma
id|linenr
)paren
suffix:semicolon
)brace
DECL|function|gitdiff_hdrend
r_static
r_int
id|gitdiff_hdrend
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_struct
id|patch
op_star
id|patch
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * We&squot;re anal about diff header consistency, to make&n; * sure that we don&squot;t end up having strange ambiguous&n; * patches floating around.&n; *&n; * As a result, gitdiff_{old|new}name() will check&n; * their names against any previous information, just&n; * to make sure..&n; */
DECL|macro|DIFF_OLD_NAME
mdefine_line|#define DIFF_OLD_NAME 0
DECL|macro|DIFF_NEW_NAME
mdefine_line|#define DIFF_NEW_NAME 1
DECL|function|gitdiff_verify_name
r_static
r_char
op_star
id|gitdiff_verify_name
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_int
id|isnull
comma
r_char
op_star
id|orig_name
comma
r_int
id|side
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|orig_name
op_logical_and
op_logical_neg
id|isnull
)paren
r_return
id|find_name
c_func
(paren
id|line
comma
l_int|NULL
comma
id|p_value
comma
id|TERM_TAB
)paren
suffix:semicolon
r_if
c_cond
(paren
id|orig_name
)paren
(brace
r_int
id|len
suffix:semicolon
r_const
r_char
op_star
id|name
suffix:semicolon
r_char
op_star
id|another
suffix:semicolon
id|name
op_assign
id|orig_name
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|isnull
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;git apply: bad git-diff - expected /dev/null, got %s on line %d&quot;
)paren
comma
id|name
comma
id|linenr
)paren
suffix:semicolon
id|another
op_assign
id|find_name
c_func
(paren
id|line
comma
l_int|NULL
comma
id|p_value
comma
id|TERM_TAB
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|another
op_logical_or
id|memcmp
c_func
(paren
id|another
comma
id|name
comma
id|len
op_plus
l_int|1
)paren
)paren
id|die
c_func
(paren
(paren
id|side
op_eq
id|DIFF_NEW_NAME
)paren
ques
c_cond
id|_
c_func
(paren
l_string|&quot;git apply: bad git-diff - inconsistent new filename on line %d&quot;
)paren
suffix:colon
id|_
c_func
(paren
l_string|&quot;git apply: bad git-diff - inconsistent old filename on line %d&quot;
)paren
comma
id|linenr
)paren
suffix:semicolon
id|free
c_func
(paren
id|another
)paren
suffix:semicolon
r_return
id|orig_name
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* expect &quot;/dev/null&quot; */
r_if
c_cond
(paren
id|memcmp
c_func
(paren
l_string|&quot;/dev/null&quot;
comma
id|line
comma
l_int|9
)paren
op_logical_or
id|line
(braket
l_int|9
)braket
op_ne
l_char|&squot;&bslash;n&squot;
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;git apply: bad git-diff - expected /dev/null on line %d&quot;
)paren
comma
id|linenr
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
DECL|function|gitdiff_oldname
r_static
r_int
id|gitdiff_oldname
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_struct
id|patch
op_star
id|patch
)paren
(brace
r_char
op_star
id|orig
op_assign
id|patch-&gt;old_name
suffix:semicolon
id|patch-&gt;old_name
op_assign
id|gitdiff_verify_name
c_func
(paren
id|line
comma
id|patch-&gt;is_new
comma
id|patch-&gt;old_name
comma
id|DIFF_OLD_NAME
)paren
suffix:semicolon
r_if
c_cond
(paren
id|orig
op_ne
id|patch-&gt;old_name
)paren
id|free
c_func
(paren
id|orig
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|gitdiff_newname
r_static
r_int
id|gitdiff_newname
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_struct
id|patch
op_star
id|patch
)paren
(brace
r_char
op_star
id|orig
op_assign
id|patch-&gt;new_name
suffix:semicolon
id|patch-&gt;new_name
op_assign
id|gitdiff_verify_name
c_func
(paren
id|line
comma
id|patch-&gt;is_delete
comma
id|patch-&gt;new_name
comma
id|DIFF_NEW_NAME
)paren
suffix:semicolon
r_if
c_cond
(paren
id|orig
op_ne
id|patch-&gt;new_name
)paren
id|free
c_func
(paren
id|orig
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|gitdiff_oldmode
r_static
r_int
id|gitdiff_oldmode
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_struct
id|patch
op_star
id|patch
)paren
(brace
id|patch-&gt;old_mode
op_assign
id|strtoul
c_func
(paren
id|line
comma
l_int|NULL
comma
l_int|8
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|gitdiff_newmode
r_static
r_int
id|gitdiff_newmode
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_struct
id|patch
op_star
id|patch
)paren
(brace
id|patch-&gt;new_mode
op_assign
id|strtoul
c_func
(paren
id|line
comma
l_int|NULL
comma
l_int|8
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|gitdiff_delete
r_static
r_int
id|gitdiff_delete
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_struct
id|patch
op_star
id|patch
)paren
(brace
id|patch-&gt;is_delete
op_assign
l_int|1
suffix:semicolon
id|free
c_func
(paren
id|patch-&gt;old_name
)paren
suffix:semicolon
id|patch-&gt;old_name
op_assign
id|null_strdup
c_func
(paren
id|patch-&gt;def_name
)paren
suffix:semicolon
r_return
id|gitdiff_oldmode
c_func
(paren
id|line
comma
id|patch
)paren
suffix:semicolon
)brace
DECL|function|gitdiff_newfile
r_static
r_int
id|gitdiff_newfile
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_struct
id|patch
op_star
id|patch
)paren
(brace
id|patch-&gt;is_new
op_assign
l_int|1
suffix:semicolon
id|free
c_func
(paren
id|patch-&gt;new_name
)paren
suffix:semicolon
id|patch-&gt;new_name
op_assign
id|null_strdup
c_func
(paren
id|patch-&gt;def_name
)paren
suffix:semicolon
r_return
id|gitdiff_newmode
c_func
(paren
id|line
comma
id|patch
)paren
suffix:semicolon
)brace
DECL|function|gitdiff_copysrc
r_static
r_int
id|gitdiff_copysrc
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_struct
id|patch
op_star
id|patch
)paren
(brace
id|patch-&gt;is_copy
op_assign
l_int|1
suffix:semicolon
id|free
c_func
(paren
id|patch-&gt;old_name
)paren
suffix:semicolon
id|patch-&gt;old_name
op_assign
id|find_name
c_func
(paren
id|line
comma
l_int|NULL
comma
id|p_value
ques
c_cond
id|p_value
l_int|1
suffix:colon
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|gitdiff_copydst
r_static
r_int
id|gitdiff_copydst
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_struct
id|patch
op_star
id|patch
)paren
(brace
id|patch-&gt;is_copy
op_assign
l_int|1
suffix:semicolon
id|free
c_func
(paren
id|patch-&gt;new_name
)paren
suffix:semicolon
id|patch-&gt;new_name
op_assign
id|find_name
c_func
(paren
id|line
comma
l_int|NULL
comma
id|p_value
ques
c_cond
id|p_value
l_int|1
suffix:colon
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|gitdiff_renamesrc
r_static
r_int
id|gitdiff_renamesrc
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_struct
id|patch
op_star
id|patch
)paren
(brace
id|patch-&gt;is_rename
op_assign
l_int|1
suffix:semicolon
id|free
c_func
(paren
id|patch-&gt;old_name
)paren
suffix:semicolon
id|patch-&gt;old_name
op_assign
id|find_name
c_func
(paren
id|line
comma
l_int|NULL
comma
id|p_value
ques
c_cond
id|p_value
l_int|1
suffix:colon
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|gitdiff_renamedst
r_static
r_int
id|gitdiff_renamedst
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_struct
id|patch
op_star
id|patch
)paren
(brace
id|patch-&gt;is_rename
op_assign
l_int|1
suffix:semicolon
id|free
c_func
(paren
id|patch-&gt;new_name
)paren
suffix:semicolon
id|patch-&gt;new_name
op_assign
id|find_name
c_func
(paren
id|line
comma
l_int|NULL
comma
id|p_value
ques
c_cond
id|p_value
l_int|1
suffix:colon
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|gitdiff_similarity
r_static
r_int
id|gitdiff_similarity
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_struct
id|patch
op_star
id|patch
)paren
(brace
r_int
r_int
id|val
op_assign
id|strtoul
c_func
(paren
id|line
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val
op_le
l_int|100
)paren
id|patch-&gt;score
op_assign
id|val
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|gitdiff_dissimilarity
r_static
r_int
id|gitdiff_dissimilarity
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_struct
id|patch
op_star
id|patch
)paren
(brace
r_int
r_int
id|val
op_assign
id|strtoul
c_func
(paren
id|line
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val
op_le
l_int|100
)paren
id|patch-&gt;score
op_assign
id|val
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|gitdiff_index
r_static
r_int
id|gitdiff_index
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_struct
id|patch
op_star
id|patch
)paren
(brace
multiline_comment|/*&n;&t; * index line is N hexadecimal, &quot;..&quot;, N hexadecimal,&n;&t; * and optional space with octal mode.&n;&t; */
r_const
r_char
op_star
id|ptr
comma
op_star
id|eol
suffix:semicolon
r_int
id|len
suffix:semicolon
id|ptr
op_assign
id|strchr
c_func
(paren
id|line
comma
l_char|&squot;.&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ptr
op_logical_or
id|ptr
(braket
l_int|1
)braket
op_ne
l_char|&squot;.&squot;
op_logical_or
l_int|40
OL
id|ptr
id|line
)paren
r_return
l_int|0
suffix:semicolon
id|len
op_assign
id|ptr
id|line
suffix:semicolon
id|memcpy
c_func
(paren
id|patch-&gt;old_sha1_prefix
comma
id|line
comma
id|len
)paren
suffix:semicolon
id|patch-&gt;old_sha1_prefix
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
id|line
op_assign
id|ptr
op_plus
l_int|2
suffix:semicolon
id|ptr
op_assign
id|strchr
c_func
(paren
id|line
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
id|eol
op_assign
id|strchr
c_func
(paren
id|line
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ptr
op_logical_or
id|eol
OL
id|ptr
)paren
id|ptr
op_assign
id|eol
suffix:semicolon
id|len
op_assign
id|ptr
id|line
suffix:semicolon
r_if
c_cond
(paren
l_int|40
OL
id|len
)paren
r_return
l_int|0
suffix:semicolon
id|memcpy
c_func
(paren
id|patch-&gt;new_sha1_prefix
comma
id|line
comma
id|len
)paren
suffix:semicolon
id|patch-&gt;new_sha1_prefix
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_star
id|ptr
op_eq
l_char|&squot; &squot;
)paren
id|patch-&gt;old_mode
op_assign
id|strtoul
c_func
(paren
id|ptr
op_plus
l_int|1
comma
l_int|NULL
comma
l_int|8
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This is normal for a diff that doesn&squot;t change anything: we&squot;ll fall through&n; * into the next diff. Tell the parser to break out.&n; */
DECL|function|gitdiff_unrecognized
r_static
r_int
id|gitdiff_unrecognized
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_struct
id|patch
op_star
id|patch
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Skip p_value leading components from &quot;line&quot;; as we do not accept&n; * absolute paths, return NULL in that case.&n; */
DECL|function|skip_tree_prefix
r_static
r_const
r_char
op_star
id|skip_tree_prefix
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_int
id|llen
)paren
(brace
r_int
id|nslash
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p_value
)paren
r_return
(paren
id|llen
op_logical_and
id|line
(braket
l_int|0
)braket
op_eq
l_char|&squot;/&squot;
)paren
ques
c_cond
l_int|NULL
suffix:colon
id|line
suffix:semicolon
id|nslash
op_assign
id|p_value
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|llen
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|ch
op_assign
id|line
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;/&squot;
op_logical_and
op_decrement
id|nslash
op_le
l_int|0
)paren
r_return
(paren
id|i
op_eq
l_int|0
)paren
ques
c_cond
l_int|NULL
suffix:colon
op_amp
id|line
(braket
id|i
op_plus
l_int|1
)braket
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * This is to extract the same name that appears on &quot;diff --git&quot;&n; * line.  We do not find and return anything if it is a rename&n; * patch, and it is OK because we will find the name elsewhere.&n; * We need to reliably find name only when it is mode-change only,&n; * creation or deletion of an empty file.  In any of these cases,&n; * both sides are the same name under a/ and b/ respectively.&n; */
DECL|function|git_header_name
r_static
r_char
op_star
id|git_header_name
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_int
id|llen
)paren
(brace
r_const
r_char
op_star
id|name
suffix:semicolon
r_const
r_char
op_star
id|second
op_assign
l_int|NULL
suffix:semicolon
r_int
id|len
comma
id|line_len
suffix:semicolon
id|line
op_add_assign
id|strlen
c_func
(paren
l_string|&quot;diff --git &quot;
)paren
suffix:semicolon
id|llen
op_sub_assign
id|strlen
c_func
(paren
l_string|&quot;diff --git &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|line
op_eq
l_char|&squot;&quot;&squot;
)paren
(brace
r_const
r_char
op_star
id|cp
suffix:semicolon
r_struct
id|strbuf
id|first
op_assign
id|STRBUF_INIT
suffix:semicolon
r_struct
id|strbuf
id|sp
op_assign
id|STRBUF_INIT
suffix:semicolon
r_if
c_cond
(paren
id|unquote_c_style
c_func
(paren
op_amp
id|first
comma
id|line
comma
op_amp
id|second
)paren
)paren
r_goto
id|free_and_fail1
suffix:semicolon
multiline_comment|/* strip the a/b prefix including trailing slash */
id|cp
op_assign
id|skip_tree_prefix
c_func
(paren
id|first.buf
comma
id|first.len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_goto
id|free_and_fail1
suffix:semicolon
id|strbuf_remove
c_func
(paren
op_amp
id|first
comma
l_int|0
comma
id|cp
id|first.buf
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * second points at one past closing dq of name.&n;&t;&t; * find the second name.&n;&t;&t; */
r_while
c_loop
(paren
(paren
id|second
OL
id|line
op_plus
id|llen
)paren
op_logical_and
id|isspace
c_func
(paren
op_star
id|second
)paren
)paren
id|second
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|line
op_plus
id|llen
op_le
id|second
)paren
r_goto
id|free_and_fail1
suffix:semicolon
r_if
c_cond
(paren
op_star
id|second
op_eq
l_char|&squot;&quot;&squot;
)paren
(brace
r_if
c_cond
(paren
id|unquote_c_style
c_func
(paren
op_amp
id|sp
comma
id|second
comma
l_int|NULL
)paren
)paren
r_goto
id|free_and_fail1
suffix:semicolon
id|cp
op_assign
id|skip_tree_prefix
c_func
(paren
id|sp.buf
comma
id|sp.len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_goto
id|free_and_fail1
suffix:semicolon
multiline_comment|/* They must match, otherwise ignore */
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|cp
comma
id|first.buf
)paren
)paren
r_goto
id|free_and_fail1
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sp
)paren
suffix:semicolon
r_return
id|strbuf_detach
c_func
(paren
op_amp
id|first
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/* unquoted second */
id|cp
op_assign
id|skip_tree_prefix
c_func
(paren
id|second
comma
id|line
op_plus
id|llen
id|second
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_goto
id|free_and_fail1
suffix:semicolon
r_if
c_cond
(paren
id|line
op_plus
id|llen
id|cp
op_ne
id|first.len
op_logical_or
id|memcmp
c_func
(paren
id|first.buf
comma
id|cp
comma
id|first.len
)paren
)paren
r_goto
id|free_and_fail1
suffix:semicolon
r_return
id|strbuf_detach
c_func
(paren
op_amp
id|first
comma
l_int|NULL
)paren
suffix:semicolon
id|free_and_fail1
suffix:colon
id|strbuf_release
c_func
(paren
op_amp
id|first
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sp
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* unquoted first name */
id|name
op_assign
id|skip_tree_prefix
c_func
(paren
id|line
comma
id|llen
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * since the first name is unquoted, a dq if exists must be&n;&t; * the beginning of the second name.&n;&t; */
r_for
c_loop
(paren
id|second
op_assign
id|name
suffix:semicolon
id|second
OL
id|line
op_plus
id|llen
suffix:semicolon
id|second
op_increment
)paren
(brace
r_if
c_cond
(paren
op_star
id|second
op_eq
l_char|&squot;&quot;&squot;
)paren
(brace
r_struct
id|strbuf
id|sp
op_assign
id|STRBUF_INIT
suffix:semicolon
r_const
r_char
op_star
id|np
suffix:semicolon
r_if
c_cond
(paren
id|unquote_c_style
c_func
(paren
op_amp
id|sp
comma
id|second
comma
l_int|NULL
)paren
)paren
r_goto
id|free_and_fail2
suffix:semicolon
id|np
op_assign
id|skip_tree_prefix
c_func
(paren
id|sp.buf
comma
id|sp.len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np
)paren
r_goto
id|free_and_fail2
suffix:semicolon
id|len
op_assign
id|sp.buf
op_plus
id|sp.len
id|np
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
id|second
id|name
op_logical_and
op_logical_neg
id|strncmp
c_func
(paren
id|np
comma
id|name
comma
id|len
)paren
op_logical_and
id|isspace
c_func
(paren
id|name
(braket
id|len
)braket
)paren
)paren
(brace
multiline_comment|/* Good */
id|strbuf_remove
c_func
(paren
op_amp
id|sp
comma
l_int|0
comma
id|np
id|sp.buf
)paren
suffix:semicolon
r_return
id|strbuf_detach
c_func
(paren
op_amp
id|sp
comma
l_int|NULL
)paren
suffix:semicolon
)brace
id|free_and_fail2
suffix:colon
id|strbuf_release
c_func
(paren
op_amp
id|sp
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Accept a name only if it shows up twice, exactly the same&n;&t; * form.&n;&t; */
id|second
op_assign
id|strchr
c_func
(paren
id|name
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|second
)paren
r_return
l_int|NULL
suffix:semicolon
id|line_len
op_assign
id|second
id|name
suffix:semicolon
r_for
c_loop
(paren
id|len
op_assign
l_int|0
suffix:semicolon
suffix:semicolon
id|len
op_increment
)paren
(brace
r_switch
c_cond
(paren
id|name
(braket
id|len
)braket
)paren
(brace
r_default
suffix:colon
r_continue
suffix:semicolon
r_case
l_char|&squot;&bslash;n&squot;
suffix:colon
r_return
l_int|NULL
suffix:semicolon
r_case
l_char|&squot;&bslash;t&squot;
suffix:colon
r_case
l_char|&squot; &squot;
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * Is this the separator between the preimage&n;&t;&t;&t; * and the postimage pathname?  Again, we are&n;&t;&t;&t; * only interested in the case where there is&n;&t;&t;&t; * no rename, as this is only to set def_name&n;&t;&t;&t; * and a rename patch has the names elsewhere&n;&t;&t;&t; * in an unambiguous form.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|name
(braket
id|len
op_plus
l_int|1
)braket
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* no postimage name */
id|second
op_assign
id|skip_tree_prefix
c_func
(paren
id|name
op_plus
id|len
op_plus
l_int|1
comma
id|line_len
(paren
id|len
op_plus
l_int|1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|second
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Does len bytes starting at &quot;name&quot; and &quot;second&quot;&n;&t;&t;&t; * (that are separated by one HT or SP we just&n;&t;&t;&t; * found) exactly match?&n;&t;&t;&t; */
r_if
c_cond
(paren
id|second
(braket
id|len
)braket
op_eq
l_char|&squot;&bslash;n&squot;
op_logical_and
op_logical_neg
id|strncmp
c_func
(paren
id|name
comma
id|second
comma
id|len
)paren
)paren
r_return
id|xmemdupz
c_func
(paren
id|name
comma
id|len
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Verify that we recognize the lines following a git header */
DECL|function|parse_git_header
r_static
r_int
id|parse_git_header
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_int
id|len
comma
r_int
r_int
id|size
comma
r_struct
id|patch
op_star
id|patch
)paren
(brace
r_int
r_int
id|offset
suffix:semicolon
multiline_comment|/* A git diff has explicit new/delete information, so we don&squot;t guess */
id|patch-&gt;is_new
op_assign
l_int|0
suffix:semicolon
id|patch-&gt;is_delete
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Some things may not have the old name in the&n;&t; * rest of the headers anywhere (pure mode changes,&n;&t; * or removing or adding empty files), so we get&n;&t; * the default name from the header.&n;&t; */
id|patch-&gt;def_name
op_assign
id|git_header_name
c_func
(paren
id|line
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|patch-&gt;def_name
op_logical_and
id|root
)paren
(brace
r_char
op_star
id|s
op_assign
id|xmalloc
c_func
(paren
id|root_len
op_plus
id|strlen
c_func
(paren
id|patch-&gt;def_name
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|s
comma
id|root
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|s
op_plus
id|root_len
comma
id|patch-&gt;def_name
)paren
suffix:semicolon
id|free
c_func
(paren
id|patch-&gt;def_name
)paren
suffix:semicolon
id|patch-&gt;def_name
op_assign
id|s
suffix:semicolon
)brace
id|line
op_add_assign
id|len
suffix:semicolon
id|size
op_sub_assign
id|len
suffix:semicolon
id|linenr
op_increment
suffix:semicolon
r_for
c_loop
(paren
id|offset
op_assign
id|len
suffix:semicolon
id|size
OG
l_int|0
suffix:semicolon
id|offset
op_add_assign
id|len
comma
id|size
op_sub_assign
id|len
comma
id|line
op_add_assign
id|len
comma
id|linenr
op_increment
)paren
(brace
r_static
r_const
r_struct
id|opentry
(brace
r_const
r_char
op_star
id|str
suffix:semicolon
r_int
(paren
op_star
id|fn
)paren
(paren
r_const
r_char
op_star
comma
r_struct
id|patch
op_star
)paren
suffix:semicolon
)brace
id|optable
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;@@ -&quot;
comma
id|gitdiff_hdrend
)brace
comma
(brace
l_string|&quot;--- &quot;
comma
id|gitdiff_oldname
)brace
comma
(brace
l_string|&quot;+++ &quot;
comma
id|gitdiff_newname
)brace
comma
(brace
l_string|&quot;old mode &quot;
comma
id|gitdiff_oldmode
)brace
comma
(brace
l_string|&quot;new mode &quot;
comma
id|gitdiff_newmode
)brace
comma
(brace
l_string|&quot;deleted file mode &quot;
comma
id|gitdiff_delete
)brace
comma
(brace
l_string|&quot;new file mode &quot;
comma
id|gitdiff_newfile
)brace
comma
(brace
l_string|&quot;copy from &quot;
comma
id|gitdiff_copysrc
)brace
comma
(brace
l_string|&quot;copy to &quot;
comma
id|gitdiff_copydst
)brace
comma
(brace
l_string|&quot;rename old &quot;
comma
id|gitdiff_renamesrc
)brace
comma
(brace
l_string|&quot;rename new &quot;
comma
id|gitdiff_renamedst
)brace
comma
(brace
l_string|&quot;rename from &quot;
comma
id|gitdiff_renamesrc
)brace
comma
(brace
l_string|&quot;rename to &quot;
comma
id|gitdiff_renamedst
)brace
comma
(brace
l_string|&quot;similarity index &quot;
comma
id|gitdiff_similarity
)brace
comma
(brace
l_string|&quot;dissimilarity index &quot;
comma
id|gitdiff_dissimilarity
)brace
comma
(brace
l_string|&quot;index &quot;
comma
id|gitdiff_index
)brace
comma
(brace
l_string|&quot;&quot;
comma
id|gitdiff_unrecognized
)brace
comma
)brace
suffix:semicolon
r_int
id|i
suffix:semicolon
id|len
op_assign
id|linelen
c_func
(paren
id|line
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
op_logical_or
id|line
(braket
id|len
op_minus
l_int|1
)braket
op_ne
l_char|&squot;&bslash;n&squot;
)paren
r_break
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|optable
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_struct
id|opentry
op_star
id|p
op_assign
id|optable
op_plus
id|i
suffix:semicolon
r_int
id|oplen
op_assign
id|strlen
c_func
(paren
id|p-&gt;str
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
id|oplen
op_logical_or
id|memcmp
c_func
(paren
id|p-&gt;str
comma
id|line
comma
id|oplen
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|p
op_member_access_from_pointer
id|fn
c_func
(paren
id|line
op_plus
id|oplen
comma
id|patch
)paren
OL
l_int|0
)paren
r_return
id|offset
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
id|offset
suffix:semicolon
)brace
DECL|function|parse_num
r_static
r_int
id|parse_num
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_int
r_int
op_star
id|p
)paren
(brace
r_char
op_star
id|ptr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|isdigit
c_func
(paren
op_star
id|line
)paren
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|p
op_assign
id|strtoul
c_func
(paren
id|line
comma
op_amp
id|ptr
comma
l_int|10
)paren
suffix:semicolon
r_return
id|ptr
id|line
suffix:semicolon
)brace
DECL|function|parse_range
r_static
r_int
id|parse_range
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_int
id|len
comma
r_int
id|offset
comma
r_const
r_char
op_star
id|expect
comma
r_int
r_int
op_star
id|p1
comma
r_int
r_int
op_star
id|p2
)paren
(brace
r_int
id|digits
comma
id|ex
suffix:semicolon
r_if
c_cond
(paren
id|offset
OL
l_int|0
op_logical_or
id|offset
op_ge
id|len
)paren
r_return
l_int|1
suffix:semicolon
id|line
op_add_assign
id|offset
suffix:semicolon
id|len
op_sub_assign
id|offset
suffix:semicolon
id|digits
op_assign
id|parse_num
c_func
(paren
id|line
comma
id|p1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|digits
)paren
r_return
l_int|1
suffix:semicolon
id|offset
op_add_assign
id|digits
suffix:semicolon
id|line
op_add_assign
id|digits
suffix:semicolon
id|len
op_sub_assign
id|digits
suffix:semicolon
op_star
id|p2
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_star
id|line
op_eq
l_char|&squot;,&squot;
)paren
(brace
id|digits
op_assign
id|parse_num
c_func
(paren
id|line
op_plus
l_int|1
comma
id|p2
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|digits
)paren
r_return
l_int|1
suffix:semicolon
id|offset
op_add_assign
id|digits
op_plus
l_int|1
suffix:semicolon
id|line
op_add_assign
id|digits
op_plus
l_int|1
suffix:semicolon
id|len
op_sub_assign
id|digits
op_plus
l_int|1
suffix:semicolon
)brace
id|ex
op_assign
id|strlen
c_func
(paren
id|expect
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ex
OG
id|len
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|line
comma
id|expect
comma
id|ex
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
id|offset
op_plus
id|ex
suffix:semicolon
)brace
DECL|function|recount_diff
r_static
r_void
id|recount_diff
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_int
id|size
comma
r_struct
id|fragment
op_star
id|fragment
)paren
(brace
r_int
id|oldlines
op_assign
l_int|0
comma
id|newlines
op_assign
l_int|0
comma
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|size
OL
l_int|1
)paren
(brace
id|warning
c_func
(paren
l_string|&quot;recount: ignore empty hunk&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|len
op_assign
id|linelen
c_func
(paren
id|line
comma
id|size
)paren
suffix:semicolon
id|size
op_sub_assign
id|len
suffix:semicolon
id|line
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|size
OL
l_int|1
)paren
r_break
suffix:semicolon
r_switch
c_cond
(paren
op_star
id|line
)paren
(brace
r_case
l_char|&squot; &squot;
suffix:colon
r_case
l_char|&squot;&bslash;n&squot;
suffix:colon
id|newlines
op_increment
suffix:semicolon
multiline_comment|/* fall through */
r_case
l_char|&squot;-&squot;
suffix:colon
id|oldlines
op_increment
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;+&squot;
suffix:colon
id|newlines
op_increment
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;&bslash;&bslash;&squot;
suffix:colon
r_continue
suffix:semicolon
r_case
l_char|&squot;@&squot;
suffix:colon
id|ret
op_assign
id|size
OL
l_int|3
op_logical_or
op_logical_neg
id|starts_with
c_func
(paren
id|line
comma
l_string|&quot;@@ &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;d&squot;
suffix:colon
id|ret
op_assign
id|size
OL
l_int|5
op_logical_or
op_logical_neg
id|starts_with
c_func
(paren
id|line
comma
l_string|&quot;diff &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ret
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
)paren
(brace
id|warning
c_func
(paren
id|_
c_func
(paren
l_string|&quot;recount: unexpected line: %.*s&quot;
)paren
comma
(paren
r_int
)paren
id|linelen
c_func
(paren
id|line
comma
id|size
)paren
comma
id|line
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
id|fragment-&gt;oldlines
op_assign
id|oldlines
suffix:semicolon
id|fragment-&gt;newlines
op_assign
id|newlines
suffix:semicolon
)brace
multiline_comment|/*&n; * Parse a unified diff fragment header of the&n; * form &quot;@@ -a,b +c,d @@&quot;&n; */
DECL|function|parse_fragment_header
r_static
r_int
id|parse_fragment_header
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_int
id|len
comma
r_struct
id|fragment
op_star
id|fragment
)paren
(brace
r_int
id|offset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
op_logical_or
id|line
(braket
id|len
op_minus
l_int|1
)braket
op_ne
l_char|&squot;&bslash;n&squot;
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Figure out the number of lines in a fragment */
id|offset
op_assign
id|parse_range
c_func
(paren
id|line
comma
id|len
comma
l_int|4
comma
l_string|&quot; +&quot;
comma
op_amp
id|fragment-&gt;oldpos
comma
op_amp
id|fragment-&gt;oldlines
)paren
suffix:semicolon
id|offset
op_assign
id|parse_range
c_func
(paren
id|line
comma
id|len
comma
id|offset
comma
l_string|&quot; @@&quot;
comma
op_amp
id|fragment-&gt;newpos
comma
op_amp
id|fragment-&gt;newlines
)paren
suffix:semicolon
r_return
id|offset
suffix:semicolon
)brace
DECL|function|find_header
r_static
r_int
id|find_header
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_int
r_int
id|size
comma
r_int
op_star
id|hdrsize
comma
r_struct
id|patch
op_star
id|patch
)paren
(brace
r_int
r_int
id|offset
comma
id|len
suffix:semicolon
id|patch-&gt;is_toplevel_relative
op_assign
l_int|0
suffix:semicolon
id|patch-&gt;is_rename
op_assign
id|patch-&gt;is_copy
op_assign
l_int|0
suffix:semicolon
id|patch-&gt;is_new
op_assign
id|patch-&gt;is_delete
op_assign
l_int|1
suffix:semicolon
id|patch-&gt;old_mode
op_assign
id|patch-&gt;new_mode
op_assign
l_int|0
suffix:semicolon
id|patch-&gt;old_name
op_assign
id|patch-&gt;new_name
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|offset
op_assign
l_int|0
suffix:semicolon
id|size
OG
l_int|0
suffix:semicolon
id|offset
op_add_assign
id|len
comma
id|size
op_sub_assign
id|len
comma
id|line
op_add_assign
id|len
comma
id|linenr
op_increment
)paren
(brace
r_int
r_int
id|nextlen
suffix:semicolon
id|len
op_assign
id|linelen
c_func
(paren
id|line
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
r_break
suffix:semicolon
multiline_comment|/* Testing this early allows us to take a few shortcuts.. */
r_if
c_cond
(paren
id|len
OL
l_int|6
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Make sure we don&squot;t find any unconnected patch fragments.&n;&t;&t; * That&squot;s a sign that we didn&squot;t find a header, and that a&n;&t;&t; * patch has become corrupted/broken up.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;@@ -&quot;
comma
id|line
comma
l_int|4
)paren
)paren
(brace
r_struct
id|fragment
id|dummy
suffix:semicolon
r_if
c_cond
(paren
id|parse_fragment_header
c_func
(paren
id|line
comma
id|len
comma
op_amp
id|dummy
)paren
OL
l_int|0
)paren
r_continue
suffix:semicolon
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;patch fragment without header at line %d: %.*s&quot;
)paren
comma
id|linenr
comma
(paren
r_int
)paren
id|len
op_minus
l_int|1
comma
id|line
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|size
OL
id|len
op_plus
l_int|6
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Git patch? It might not have a real patch, just a rename&n;&t;&t; * or mode change, so we handle that specially&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;diff --git &quot;
comma
id|line
comma
l_int|11
)paren
)paren
(brace
r_int
id|git_hdr_len
op_assign
id|parse_git_header
c_func
(paren
id|line
comma
id|len
comma
id|size
comma
id|patch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|git_hdr_len
op_le
id|len
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|patch-&gt;old_name
op_logical_and
op_logical_neg
id|patch-&gt;new_name
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|patch-&gt;def_name
)paren
id|die
c_func
(paren
id|Q_
c_func
(paren
l_string|&quot;git diff header lacks filename information when removing &quot;
l_string|&quot;%d leading pathname component (line %d)&quot;
comma
l_string|&quot;git diff header lacks filename information when removing &quot;
l_string|&quot;%d leading pathname components (line %d)&quot;
comma
id|p_value
)paren
comma
id|p_value
comma
id|linenr
)paren
suffix:semicolon
id|patch-&gt;old_name
op_assign
id|xstrdup
c_func
(paren
id|patch-&gt;def_name
)paren
suffix:semicolon
id|patch-&gt;new_name
op_assign
id|xstrdup
c_func
(paren
id|patch-&gt;def_name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|patch-&gt;is_delete
op_logical_and
op_logical_neg
id|patch-&gt;new_name
)paren
id|die
c_func
(paren
l_string|&quot;git diff header lacks filename information &quot;
l_string|&quot;(line %d)&quot;
comma
id|linenr
)paren
suffix:semicolon
id|patch-&gt;is_toplevel_relative
op_assign
l_int|1
suffix:semicolon
op_star
id|hdrsize
op_assign
id|git_hdr_len
suffix:semicolon
r_return
id|offset
suffix:semicolon
)brace
multiline_comment|/* --- followed by +++ ? */
r_if
c_cond
(paren
id|memcmp
c_func
(paren
l_string|&quot;--- &quot;
comma
id|line
comma
l_int|4
)paren
op_logical_or
id|memcmp
c_func
(paren
l_string|&quot;+++ &quot;
comma
id|line
op_plus
id|len
comma
l_int|4
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We only accept unified patches, so we want it to&n;&t;&t; * at least have &quot;@@ -a,b +c,d @@&bslash;n&quot;, which is 14 chars&n;&t;&t; * minimum (&quot;@@ -0,0 +1 @@&bslash;n&quot; is the shortest).&n;&t;&t; */
id|nextlen
op_assign
id|linelen
c_func
(paren
id|line
op_plus
id|len
comma
id|size
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
OL
id|nextlen
op_plus
l_int|14
op_logical_or
id|memcmp
c_func
(paren
l_string|&quot;@@ -&quot;
comma
id|line
op_plus
id|len
op_plus
id|nextlen
comma
l_int|4
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* Ok, we&squot;ll consider it a patch */
id|parse_traditional_patch
c_func
(paren
id|line
comma
id|line
op_plus
id|len
comma
id|patch
)paren
suffix:semicolon
op_star
id|hdrsize
op_assign
id|len
op_plus
id|nextlen
suffix:semicolon
id|linenr
op_add_assign
l_int|2
suffix:semicolon
r_return
id|offset
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|record_ws_error
r_static
r_void
id|record_ws_error
c_func
(paren
r_int
id|result
comma
r_const
r_char
op_star
id|line
comma
r_int
id|len
comma
r_int
id|linenr
)paren
(brace
r_char
op_star
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result
)paren
r_return
suffix:semicolon
id|whitespace_error
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|squelch_whitespace_errors
op_logical_and
id|squelch_whitespace_errors
OL
id|whitespace_error
)paren
r_return
suffix:semicolon
id|err
op_assign
id|whitespace_error_string
c_func
(paren
id|result
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s:%d: %s.&bslash;n%.*s&bslash;n&quot;
comma
id|patch_input_file
comma
id|linenr
comma
id|err
comma
id|len
comma
id|line
)paren
suffix:semicolon
id|free
c_func
(paren
id|err
)paren
suffix:semicolon
)brace
DECL|function|check_whitespace
r_static
r_void
id|check_whitespace
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_int
id|len
comma
r_int
id|ws_rule
)paren
(brace
r_int
id|result
op_assign
id|ws_check
c_func
(paren
id|line
op_plus
l_int|1
comma
id|len
l_int|1
comma
id|ws_rule
)paren
suffix:semicolon
id|record_ws_error
c_func
(paren
id|result
comma
id|line
op_plus
l_int|1
comma
id|len
l_int|2
comma
id|linenr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Parse a unified diff. Note that this really needs to parse each&n; * fragment separately, since the only way to know the difference&n; * between a &quot;---&quot; that is part of a patch, and a &quot;---&quot; that starts&n; * the next patch is to look at the line counts..&n; */
DECL|function|parse_fragment
r_static
r_int
id|parse_fragment
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_int
r_int
id|size
comma
r_struct
id|patch
op_star
id|patch
comma
r_struct
id|fragment
op_star
id|fragment
)paren
(brace
r_int
id|added
comma
id|deleted
suffix:semicolon
r_int
id|len
op_assign
id|linelen
c_func
(paren
id|line
comma
id|size
)paren
comma
id|offset
suffix:semicolon
r_int
r_int
id|oldlines
comma
id|newlines
suffix:semicolon
r_int
r_int
id|leading
comma
id|trailing
suffix:semicolon
id|offset
op_assign
id|parse_fragment_header
c_func
(paren
id|line
comma
id|len
comma
id|fragment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|offset
OG
l_int|0
op_logical_and
id|patch-&gt;recount
)paren
id|recount_diff
c_func
(paren
id|line
op_plus
id|offset
comma
id|size
id|offset
comma
id|fragment
)paren
suffix:semicolon
id|oldlines
op_assign
id|fragment-&gt;oldlines
suffix:semicolon
id|newlines
op_assign
id|fragment-&gt;newlines
suffix:semicolon
id|leading
op_assign
l_int|0
suffix:semicolon
id|trailing
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Parse the thing.. */
id|line
op_add_assign
id|len
suffix:semicolon
id|size
op_sub_assign
id|len
suffix:semicolon
id|linenr
op_increment
suffix:semicolon
id|added
op_assign
id|deleted
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|offset
op_assign
id|len
suffix:semicolon
l_int|0
OL
id|size
suffix:semicolon
id|offset
op_add_assign
id|len
comma
id|size
op_sub_assign
id|len
comma
id|line
op_add_assign
id|len
comma
id|linenr
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|oldlines
op_logical_and
op_logical_neg
id|newlines
)paren
r_break
suffix:semicolon
id|len
op_assign
id|linelen
c_func
(paren
id|line
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
op_logical_or
id|line
(braket
id|len
op_minus
l_int|1
)braket
op_ne
l_char|&squot;&bslash;n&squot;
)paren
r_return
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
op_star
id|line
)paren
(brace
r_default
suffix:colon
r_return
l_int|1
suffix:semicolon
r_case
l_char|&squot;&bslash;n&squot;
suffix:colon
multiline_comment|/* newer GNU diff, an empty context line */
r_case
l_char|&squot; &squot;
suffix:colon
id|oldlines
op_decrement
suffix:semicolon
id|newlines
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|deleted
op_logical_and
op_logical_neg
id|added
)paren
id|leading
op_increment
suffix:semicolon
id|trailing
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;-&squot;
suffix:colon
r_if
c_cond
(paren
id|apply_in_reverse
op_logical_and
id|ws_error_action
op_ne
id|nowarn_ws_error
)paren
id|check_whitespace
c_func
(paren
id|line
comma
id|len
comma
id|patch-&gt;ws_rule
)paren
suffix:semicolon
id|deleted
op_increment
suffix:semicolon
id|oldlines
op_decrement
suffix:semicolon
id|trailing
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;+&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|apply_in_reverse
op_logical_and
id|ws_error_action
op_ne
id|nowarn_ws_error
)paren
id|check_whitespace
c_func
(paren
id|line
comma
id|len
comma
id|patch-&gt;ws_rule
)paren
suffix:semicolon
id|added
op_increment
suffix:semicolon
id|newlines
op_decrement
suffix:semicolon
id|trailing
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We allow &quot;&bslash; No newline at end of file&quot;. Depending&n;                 * on locale settings when the patch was produced we&n;                 * don&squot;t know what this line looks like. The only&n;                 * thing we do know is that it begins with &quot;&bslash; &quot;.&n;&t;&t; * Checking for 12 is just for sanity check -- any&n;&t;&t; * l10n of &quot;&bslash; No newline...&quot; is at least that long.&n;&t;&t; */
r_case
l_char|&squot;&bslash;&bslash;&squot;
suffix:colon
r_if
c_cond
(paren
id|len
OL
l_int|12
op_logical_or
id|memcmp
c_func
(paren
id|line
comma
l_string|&quot;&bslash;&bslash; &quot;
comma
l_int|2
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|oldlines
op_logical_or
id|newlines
)paren
r_return
l_int|1
suffix:semicolon
id|fragment-&gt;leading
op_assign
id|leading
suffix:semicolon
id|fragment-&gt;trailing
op_assign
id|trailing
suffix:semicolon
multiline_comment|/*&n;&t; * If a fragment ends with an incomplete line, we failed to include&n;&t; * it in the above loop because we hit oldlines == newlines == 0&n;&t; * before seeing it.&n;&t; */
r_if
c_cond
(paren
l_int|12
OL
id|size
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|line
comma
l_string|&quot;&bslash;&bslash; &quot;
comma
l_int|2
)paren
)paren
id|offset
op_add_assign
id|linelen
c_func
(paren
id|line
comma
id|size
)paren
suffix:semicolon
id|patch-&gt;lines_added
op_add_assign
id|added
suffix:semicolon
id|patch-&gt;lines_deleted
op_add_assign
id|deleted
suffix:semicolon
r_if
c_cond
(paren
l_int|0
OL
id|patch-&gt;is_new
op_logical_and
id|oldlines
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;new file depends on old contents&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
OL
id|patch-&gt;is_delete
op_logical_and
id|newlines
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;deleted file still has contents&quot;
)paren
)paren
suffix:semicolon
r_return
id|offset
suffix:semicolon
)brace
multiline_comment|/*&n; * We have seen &quot;diff --git a/... b/...&quot; header (or a traditional patch&n; * header).  Read hunks that belong to this patch into fragments and hang&n; * them to the given patch structure.&n; *&n; * The (fragment-&gt;patch, fragment-&gt;size) pair points into the memory given&n; * by the caller, not a copy, when we return.&n; */
DECL|function|parse_single_patch
r_static
r_int
id|parse_single_patch
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_int
r_int
id|size
comma
r_struct
id|patch
op_star
id|patch
)paren
(brace
r_int
r_int
id|offset
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|oldlines
op_assign
l_int|0
comma
id|newlines
op_assign
l_int|0
comma
id|context
op_assign
l_int|0
suffix:semicolon
r_struct
id|fragment
op_star
op_star
id|fragp
op_assign
op_amp
id|patch-&gt;fragments
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
l_int|4
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|line
comma
l_string|&quot;@@ -&quot;
comma
l_int|4
)paren
)paren
(brace
r_struct
id|fragment
op_star
id|fragment
suffix:semicolon
r_int
id|len
suffix:semicolon
id|fragment
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|fragment
)paren
)paren
suffix:semicolon
id|fragment-&gt;linenr
op_assign
id|linenr
suffix:semicolon
id|len
op_assign
id|parse_fragment
c_func
(paren
id|line
comma
id|size
comma
id|patch
comma
id|fragment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
l_int|0
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;corrupt patch at line %d&quot;
)paren
comma
id|linenr
)paren
suffix:semicolon
id|fragment-&gt;patch
op_assign
id|line
suffix:semicolon
id|fragment-&gt;size
op_assign
id|len
suffix:semicolon
id|oldlines
op_add_assign
id|fragment-&gt;oldlines
suffix:semicolon
id|newlines
op_add_assign
id|fragment-&gt;newlines
suffix:semicolon
id|context
op_add_assign
id|fragment-&gt;leading
op_plus
id|fragment-&gt;trailing
suffix:semicolon
op_star
id|fragp
op_assign
id|fragment
suffix:semicolon
id|fragp
op_assign
op_amp
id|fragment-&gt;next
suffix:semicolon
id|offset
op_add_assign
id|len
suffix:semicolon
id|line
op_add_assign
id|len
suffix:semicolon
id|size
op_sub_assign
id|len
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If something was removed (i.e. we have old-lines) it cannot&n;&t; * be creation, and if something was added it cannot be&n;&t; * deletion.  However, the reverse is not true; --unified=0&n;&t; * patches that only add are not necessarily creation even&n;&t; * though they do not have any old lines, and ones that only&n;&t; * delete are not necessarily deletion.&n;&t; *&n;&t; * Unfortunately, a real creation/deletion patch do _not_ have&n;&t; * any context line by definition, so we cannot safely tell it&n;&t; * apart with --unified=0 insanity.  At least if the patch has&n;&t; * more than one hunk it is not creation or deletion.&n;&t; */
r_if
c_cond
(paren
id|patch-&gt;is_new
OL
l_int|0
op_logical_and
(paren
id|oldlines
op_logical_or
(paren
id|patch-&gt;fragments
op_logical_and
id|patch-&gt;fragments-&gt;next
)paren
)paren
)paren
id|patch-&gt;is_new
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|patch-&gt;is_delete
OL
l_int|0
op_logical_and
(paren
id|newlines
op_logical_or
(paren
id|patch-&gt;fragments
op_logical_and
id|patch-&gt;fragments-&gt;next
)paren
)paren
)paren
id|patch-&gt;is_delete
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
l_int|0
OL
id|patch-&gt;is_new
op_logical_and
id|oldlines
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;new file %s depends on old contents&quot;
)paren
comma
id|patch-&gt;new_name
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
OL
id|patch-&gt;is_delete
op_logical_and
id|newlines
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;deleted file %s still has contents&quot;
)paren
comma
id|patch-&gt;old_name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|patch-&gt;is_delete
op_logical_and
op_logical_neg
id|newlines
op_logical_and
id|context
)paren
id|fprintf_ln
c_func
(paren
id|stderr
comma
id|_
c_func
(paren
l_string|&quot;** warning: &quot;
l_string|&quot;file %s becomes empty but is not deleted&quot;
)paren
comma
id|patch-&gt;new_name
)paren
suffix:semicolon
r_return
id|offset
suffix:semicolon
)brace
DECL|function|metadata_changes
r_static
r_inline
r_int
id|metadata_changes
c_func
(paren
r_struct
id|patch
op_star
id|patch
)paren
(brace
r_return
id|patch-&gt;is_rename
OG
l_int|0
op_logical_or
id|patch-&gt;is_copy
OG
l_int|0
op_logical_or
id|patch-&gt;is_new
OG
l_int|0
op_logical_or
id|patch-&gt;is_delete
op_logical_or
(paren
id|patch-&gt;old_mode
op_logical_and
id|patch-&gt;new_mode
op_logical_and
id|patch-&gt;old_mode
op_ne
id|patch-&gt;new_mode
)paren
suffix:semicolon
)brace
DECL|function|inflate_it
r_static
r_char
op_star
id|inflate_it
c_func
(paren
r_const
r_void
op_star
id|data
comma
r_int
r_int
id|size
comma
r_int
r_int
id|inflated_size
)paren
(brace
id|git_zstream
id|stream
suffix:semicolon
r_void
op_star
id|out
suffix:semicolon
r_int
id|st
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|stream
comma
l_int|0
comma
r_sizeof
(paren
id|stream
)paren
)paren
suffix:semicolon
id|stream.next_in
op_assign
(paren
r_int
r_char
op_star
)paren
id|data
suffix:semicolon
id|stream.avail_in
op_assign
id|size
suffix:semicolon
id|stream.next_out
op_assign
id|out
op_assign
id|xmalloc
c_func
(paren
id|inflated_size
)paren
suffix:semicolon
id|stream.avail_out
op_assign
id|inflated_size
suffix:semicolon
id|git_inflate_init
c_func
(paren
op_amp
id|stream
)paren
suffix:semicolon
id|st
op_assign
id|git_inflate
c_func
(paren
op_amp
id|stream
comma
id|Z_FINISH
)paren
suffix:semicolon
id|git_inflate_end
c_func
(paren
op_amp
id|stream
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st
op_ne
id|Z_STREAM_END
)paren
op_logical_or
id|stream.total_out
op_ne
id|inflated_size
)paren
(brace
id|free
c_func
(paren
id|out
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; * Read a binary hunk and return a new fragment; fragment-&gt;patch&n; * points at an allocated memory that the caller must free, so&n; * it is marked as &quot;-&gt;free_patch = 1&quot;.&n; */
DECL|function|parse_binary_hunk
r_static
r_struct
id|fragment
op_star
id|parse_binary_hunk
c_func
(paren
r_char
op_star
op_star
id|buf_p
comma
r_int
r_int
op_star
id|sz_p
comma
r_int
op_star
id|status_p
comma
r_int
op_star
id|used_p
)paren
(brace
multiline_comment|/*&n;&t; * Expect a line that begins with binary patch method (&quot;literal&quot;&n;&t; * or &quot;delta&quot;), followed by the length of data before deflating.&n;&t; * a sequence of &squot;length-byte&squot; followed by base-85 encoded data&n;&t; * should follow, terminated by a newline.&n;&t; *&n;&t; * Each 5-byte sequence of base-85 encodes up to 4 bytes,&n;&t; * and we would limit the patch line to 66 characters,&n;&t; * so one line can fit up to 13 groups that would decode&n;&t; * to 52 bytes max.  The length byte &squot;A&squot;-&squot;Z&squot; corresponds&n;&t; * to 1-26 bytes, and &squot;a&squot;-&squot;z&squot; corresponds to 27-52 bytes.&n;&t; */
r_int
id|llen
comma
id|used
suffix:semicolon
r_int
r_int
id|size
op_assign
op_star
id|sz_p
suffix:semicolon
r_char
op_star
id|buffer
op_assign
op_star
id|buf_p
suffix:semicolon
r_int
id|patch_method
suffix:semicolon
r_int
r_int
id|origlen
suffix:semicolon
r_char
op_star
id|data
op_assign
l_int|NULL
suffix:semicolon
r_int
id|hunk_size
op_assign
l_int|0
suffix:semicolon
r_struct
id|fragment
op_star
id|frag
suffix:semicolon
id|llen
op_assign
id|linelen
c_func
(paren
id|buffer
comma
id|size
)paren
suffix:semicolon
id|used
op_assign
id|llen
suffix:semicolon
op_star
id|status_p
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|buffer
comma
l_string|&quot;delta &quot;
)paren
)paren
(brace
id|patch_method
op_assign
id|BINARY_DELTA_DEFLATED
suffix:semicolon
id|origlen
op_assign
id|strtoul
c_func
(paren
id|buffer
op_plus
l_int|6
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|buffer
comma
l_string|&quot;literal &quot;
)paren
)paren
(brace
id|patch_method
op_assign
id|BINARY_LITERAL_DEFLATED
suffix:semicolon
id|origlen
op_assign
id|strtoul
c_func
(paren
id|buffer
op_plus
l_int|8
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
)brace
r_else
r_return
l_int|NULL
suffix:semicolon
id|linenr
op_increment
suffix:semicolon
id|buffer
op_add_assign
id|llen
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_int
id|byte_length
comma
id|max_byte_length
comma
id|newsize
suffix:semicolon
id|llen
op_assign
id|linelen
c_func
(paren
id|buffer
comma
id|size
)paren
suffix:semicolon
id|used
op_add_assign
id|llen
suffix:semicolon
id|linenr
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|llen
op_eq
l_int|1
)paren
(brace
multiline_comment|/* consume the blank line */
id|buffer
op_increment
suffix:semicolon
id|size
op_decrement
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Minimum line is &quot;A00000&bslash;n&quot; which is 7-byte long,&n;&t;&t; * and the line length must be multiple of 5 plus 2.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|llen
OL
l_int|7
)paren
op_logical_or
(paren
id|llen
op_minus
l_int|2
)paren
op_mod
l_int|5
)paren
r_goto
id|corrupt
suffix:semicolon
id|max_byte_length
op_assign
(paren
id|llen
l_int|2
)paren
op_div
l_int|5
op_star
l_int|4
suffix:semicolon
id|byte_length
op_assign
op_star
id|buffer
suffix:semicolon
r_if
c_cond
(paren
l_char|&squot;A&squot;
op_le
id|byte_length
op_logical_and
id|byte_length
op_le
l_char|&squot;Z&squot;
)paren
id|byte_length
op_assign
id|byte_length
l_char|&squot;A&squot;
op_plus
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
l_char|&squot;a&squot;
op_le
id|byte_length
op_logical_and
id|byte_length
op_le
l_char|&squot;z&squot;
)paren
id|byte_length
op_assign
id|byte_length
l_char|&squot;a&squot;
op_plus
l_int|27
suffix:semicolon
r_else
r_goto
id|corrupt
suffix:semicolon
multiline_comment|/* if the input length was not multiple of 4, we would&n;&t;&t; * have filler at the end but the filler should never&n;&t;&t; * exceed 3 bytes&n;&t;&t; */
r_if
c_cond
(paren
id|max_byte_length
OL
id|byte_length
op_logical_or
id|byte_length
op_le
id|max_byte_length
l_int|4
)paren
r_goto
id|corrupt
suffix:semicolon
id|newsize
op_assign
id|hunk_size
op_plus
id|byte_length
suffix:semicolon
id|data
op_assign
id|xrealloc
c_func
(paren
id|data
comma
id|newsize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|decode_85
c_func
(paren
id|data
op_plus
id|hunk_size
comma
id|buffer
op_plus
l_int|1
comma
id|byte_length
)paren
)paren
r_goto
id|corrupt
suffix:semicolon
id|hunk_size
op_assign
id|newsize
suffix:semicolon
id|buffer
op_add_assign
id|llen
suffix:semicolon
id|size
op_sub_assign
id|llen
suffix:semicolon
)brace
id|frag
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|frag
)paren
)paren
suffix:semicolon
id|frag-&gt;patch
op_assign
id|inflate_it
c_func
(paren
id|data
comma
id|hunk_size
comma
id|origlen
)paren
suffix:semicolon
id|frag-&gt;free_patch
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|frag-&gt;patch
)paren
r_goto
id|corrupt
suffix:semicolon
id|free
c_func
(paren
id|data
)paren
suffix:semicolon
id|frag-&gt;size
op_assign
id|origlen
suffix:semicolon
op_star
id|buf_p
op_assign
id|buffer
suffix:semicolon
op_star
id|sz_p
op_assign
id|size
suffix:semicolon
op_star
id|used_p
op_assign
id|used
suffix:semicolon
id|frag-&gt;binary_patch_method
op_assign
id|patch_method
suffix:semicolon
r_return
id|frag
suffix:semicolon
id|corrupt
suffix:colon
id|free
c_func
(paren
id|data
)paren
suffix:semicolon
op_star
id|status_p
op_assign
l_int|1
suffix:semicolon
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;corrupt binary patch at line %d: %.*s&quot;
)paren
comma
id|linenr
op_minus
l_int|1
comma
id|llen
op_minus
l_int|1
comma
id|buffer
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|parse_binary
r_static
r_int
id|parse_binary
c_func
(paren
r_char
op_star
id|buffer
comma
r_int
r_int
id|size
comma
r_struct
id|patch
op_star
id|patch
)paren
(brace
multiline_comment|/*&n;&t; * We have read &quot;GIT binary patch&bslash;n&quot;; what follows is a line&n;&t; * that says the patch method (currently, either &quot;literal&quot; or&n;&t; * &quot;delta&quot;) and the length of data before deflating; a&n;&t; * sequence of &squot;length-byte&squot; followed by base-85 encoded data&n;&t; * follows.&n;&t; *&n;&t; * When a binary patch is reversible, there is another binary&n;&t; * hunk in the same format, starting with patch method (either&n;&t; * &quot;literal&quot; or &quot;delta&quot;) with the length of data, and a sequence&n;&t; * of length-byte + base-85 encoded data, terminated with another&n;&t; * empty line.  This data, when applied to the postimage, produces&n;&t; * the preimage.&n;&t; */
r_struct
id|fragment
op_star
id|forward
suffix:semicolon
r_struct
id|fragment
op_star
id|reverse
suffix:semicolon
r_int
id|status
suffix:semicolon
r_int
id|used
comma
id|used_1
suffix:semicolon
id|forward
op_assign
id|parse_binary_hunk
c_func
(paren
op_amp
id|buffer
comma
op_amp
id|size
comma
op_amp
id|status
comma
op_amp
id|used
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|forward
op_logical_and
op_logical_neg
id|status
)paren
multiline_comment|/* there has to be one hunk (forward hunk) */
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;unrecognized binary patch at line %d&quot;
)paren
comma
id|linenr
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
multiline_comment|/* otherwise we already gave an error message */
r_return
id|status
suffix:semicolon
id|reverse
op_assign
id|parse_binary_hunk
c_func
(paren
op_amp
id|buffer
comma
op_amp
id|size
comma
op_amp
id|status
comma
op_amp
id|used_1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reverse
)paren
id|used
op_add_assign
id|used_1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|status
)paren
(brace
multiline_comment|/*&n;&t;&t; * Not having reverse hunk is not an error, but having&n;&t;&t; * a corrupt reverse hunk is.&n;&t;&t; */
id|free
c_func
(paren
(paren
r_void
op_star
)paren
id|forward-&gt;patch
)paren
suffix:semicolon
id|free
c_func
(paren
id|forward
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
id|forward-&gt;next
op_assign
id|reverse
suffix:semicolon
id|patch-&gt;fragments
op_assign
id|forward
suffix:semicolon
id|patch-&gt;is_binary
op_assign
l_int|1
suffix:semicolon
r_return
id|used
suffix:semicolon
)brace
DECL|function|prefix_one
r_static
r_void
id|prefix_one
c_func
(paren
r_char
op_star
op_star
id|name
)paren
(brace
r_char
op_star
id|old_name
op_assign
op_star
id|name
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|old_name
)paren
r_return
suffix:semicolon
op_star
id|name
op_assign
id|xstrdup
c_func
(paren
id|prefix_filename
c_func
(paren
id|prefix
comma
id|prefix_length
comma
op_star
id|name
)paren
)paren
suffix:semicolon
id|free
c_func
(paren
id|old_name
)paren
suffix:semicolon
)brace
DECL|function|prefix_patch
r_static
r_void
id|prefix_patch
c_func
(paren
r_struct
id|patch
op_star
id|p
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|prefix
op_logical_or
id|p-&gt;is_toplevel_relative
)paren
r_return
suffix:semicolon
id|prefix_one
c_func
(paren
op_amp
id|p-&gt;new_name
)paren
suffix:semicolon
id|prefix_one
c_func
(paren
op_amp
id|p-&gt;old_name
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Read the patch text in &quot;buffer&quot; that extends for &quot;size&quot; bytes; stop&n; * reading after seeing a single patch (i.e. changes to a single file).&n; * Create fragments (i.e. patch hunks) and hang them to the given patch.&n; * Return the number of bytes consumed, so that the caller can call us&n; * again for the next patch.&n; */
DECL|function|parse_chunk
r_static
r_int
id|parse_chunk
c_func
(paren
r_char
op_star
id|buffer
comma
r_int
r_int
id|size
comma
r_struct
id|patch
op_star
id|patch
)paren
(brace
r_int
id|hdrsize
comma
id|patchsize
suffix:semicolon
r_int
id|offset
op_assign
id|find_header
c_func
(paren
id|buffer
comma
id|size
comma
op_amp
id|hdrsize
comma
id|patch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
OL
l_int|0
)paren
r_return
id|offset
suffix:semicolon
id|prefix_patch
c_func
(paren
id|patch
)paren
suffix:semicolon
id|patch-&gt;ws_rule
op_assign
id|whitespace_rule
c_func
(paren
id|patch-&gt;new_name
ques
c_cond
id|patch-&gt;new_name
suffix:colon
id|patch-&gt;old_name
)paren
suffix:semicolon
id|patchsize
op_assign
id|parse_single_patch
c_func
(paren
id|buffer
op_plus
id|offset
op_plus
id|hdrsize
comma
id|size
id|offset
id|hdrsize
comma
id|patch
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|patchsize
)paren
(brace
r_static
r_const
r_char
op_star
id|binhdr
(braket
)braket
op_assign
(brace
l_string|&quot;Binary files &quot;
comma
l_string|&quot;Files &quot;
comma
l_int|NULL
comma
)brace
suffix:semicolon
r_static
r_const
r_char
id|git_binary
(braket
)braket
op_assign
l_string|&quot;GIT binary patch&bslash;n&quot;
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|hd
op_assign
id|hdrsize
op_plus
id|offset
suffix:semicolon
r_int
r_int
id|llen
op_assign
id|linelen
c_func
(paren
id|buffer
op_plus
id|hd
comma
id|size
id|hd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|llen
op_eq
r_sizeof
(paren
id|git_binary
)paren
l_int|1
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|git_binary
comma
id|buffer
op_plus
id|hd
comma
id|llen
)paren
)paren
(brace
r_int
id|used
suffix:semicolon
id|linenr
op_increment
suffix:semicolon
id|used
op_assign
id|parse_binary
c_func
(paren
id|buffer
op_plus
id|hd
op_plus
id|llen
comma
id|size
id|hd
id|llen
comma
id|patch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|used
)paren
id|patchsize
op_assign
id|used
op_plus
id|llen
suffix:semicolon
r_else
id|patchsize
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot; differ&bslash;n&quot;
comma
id|buffer
op_plus
id|hd
op_plus
id|llen
l_int|8
comma
l_int|8
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|binhdr
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|binhdr
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
id|size
id|hd
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|binhdr
(braket
id|i
)braket
comma
id|buffer
op_plus
id|hd
comma
id|len
)paren
)paren
(brace
id|linenr
op_increment
suffix:semicolon
id|patch-&gt;is_binary
op_assign
l_int|1
suffix:semicolon
id|patchsize
op_assign
id|llen
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Empty patch cannot be applied if it is a text patch&n;&t;&t; * without metadata change.  A binary patch appears&n;&t;&t; * empty to us here.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|apply
op_logical_or
id|check
)paren
op_logical_and
(paren
op_logical_neg
id|patch-&gt;is_binary
op_logical_and
op_logical_neg
id|metadata_changes
c_func
(paren
id|patch
)paren
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;patch with only garbage at line %d&quot;
)paren
comma
id|linenr
)paren
suffix:semicolon
)brace
r_return
id|offset
op_plus
id|hdrsize
op_plus
id|patchsize
suffix:semicolon
)brace
DECL|macro|swap
mdefine_line|#define swap(a,b) myswap((a),(b),sizeof(a))
DECL|macro|myswap
mdefine_line|#define myswap(a, b, size) do {&t;&t;&bslash;&n;&t;unsigned char mytmp[size];&t;&bslash;&n;&t;memcpy(mytmp, &amp;a, size);&t;&t;&bslash;&n;&t;memcpy(&amp;a, &amp;b, size);&t;&t;&bslash;&n;&t;memcpy(&amp;b, mytmp, size);&t;&t;&bslash;&n;} while (0)
DECL|function|reverse_patches
r_static
r_void
id|reverse_patches
c_func
(paren
r_struct
id|patch
op_star
id|p
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_struct
id|fragment
op_star
id|frag
op_assign
id|p-&gt;fragments
suffix:semicolon
id|swap
c_func
(paren
id|p-&gt;new_name
comma
id|p-&gt;old_name
)paren
suffix:semicolon
id|swap
c_func
(paren
id|p-&gt;new_mode
comma
id|p-&gt;old_mode
)paren
suffix:semicolon
id|swap
c_func
(paren
id|p-&gt;is_new
comma
id|p-&gt;is_delete
)paren
suffix:semicolon
id|swap
c_func
(paren
id|p-&gt;lines_added
comma
id|p-&gt;lines_deleted
)paren
suffix:semicolon
id|swap
c_func
(paren
id|p-&gt;old_sha1_prefix
comma
id|p-&gt;new_sha1_prefix
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|frag
suffix:semicolon
id|frag
op_assign
id|frag-&gt;next
)paren
(brace
id|swap
c_func
(paren
id|frag-&gt;newpos
comma
id|frag-&gt;oldpos
)paren
suffix:semicolon
id|swap
c_func
(paren
id|frag-&gt;newlines
comma
id|frag-&gt;oldlines
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|variable|pluses
r_static
r_const
r_char
id|pluses
(braket
)braket
op_assign
l_string|&quot;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++&quot;
suffix:semicolon
DECL|variable|minuses
r_static
r_const
r_char
id|minuses
(braket
)braket
op_assign
l_string|&quot;----------------------------------------------------------------------&quot;
suffix:semicolon
DECL|function|show_stats
r_static
r_void
id|show_stats
c_func
(paren
r_struct
id|patch
op_star
id|patch
)paren
(brace
r_struct
id|strbuf
id|qname
op_assign
id|STRBUF_INIT
suffix:semicolon
r_char
op_star
id|cp
op_assign
id|patch-&gt;new_name
ques
c_cond
id|patch-&gt;new_name
suffix:colon
id|patch-&gt;old_name
suffix:semicolon
r_int
id|max
comma
id|add
comma
id|del
suffix:semicolon
id|quote_c_style
c_func
(paren
id|cp
comma
op_amp
id|qname
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * &quot;scale&quot; the filename&n;&t; */
id|max
op_assign
id|max_len
suffix:semicolon
r_if
c_cond
(paren
id|max
OG
l_int|50
)paren
id|max
op_assign
l_int|50
suffix:semicolon
r_if
c_cond
(paren
id|qname.len
OG
id|max
)paren
(brace
id|cp
op_assign
id|strchr
c_func
(paren
id|qname.buf
op_plus
id|qname.len
op_plus
l_int|3
id|max
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
id|cp
op_assign
id|qname.buf
op_plus
id|qname.len
op_plus
l_int|3
id|max
suffix:semicolon
id|strbuf_splice
c_func
(paren
op_amp
id|qname
comma
l_int|0
comma
id|cp
id|qname.buf
comma
l_string|&quot;...&quot;
comma
l_int|3
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|patch-&gt;is_binary
)paren
(brace
id|printf
c_func
(paren
l_string|&quot; %-*s |  Bin&bslash;n&quot;
comma
id|max
comma
id|qname.buf
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|qname
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot; %-*s |&quot;
comma
id|max
comma
id|qname.buf
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|qname
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * scale the add/delete&n;&t; */
id|max
op_assign
id|max
op_plus
id|max_change
OG
l_int|70
ques
c_cond
l_int|70
id|max
suffix:colon
id|max_change
suffix:semicolon
id|add
op_assign
id|patch-&gt;lines_added
suffix:semicolon
id|del
op_assign
id|patch-&gt;lines_deleted
suffix:semicolon
r_if
c_cond
(paren
id|max_change
OG
l_int|0
)paren
(brace
r_int
id|total
op_assign
(paren
(paren
id|add
op_plus
id|del
)paren
op_star
id|max
op_plus
id|max_change
op_div
l_int|2
)paren
op_div
id|max_change
suffix:semicolon
id|add
op_assign
(paren
id|add
op_star
id|max
op_plus
id|max_change
op_div
l_int|2
)paren
op_div
id|max_change
suffix:semicolon
id|del
op_assign
id|total
id|add
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;%5d %.*s%.*s&bslash;n&quot;
comma
id|patch-&gt;lines_added
op_plus
id|patch-&gt;lines_deleted
comma
id|add
comma
id|pluses
comma
id|del
comma
id|minuses
)paren
suffix:semicolon
)brace
DECL|function|read_old_data
r_static
r_int
id|read_old_data
c_func
(paren
r_struct
id|stat
op_star
id|st
comma
r_const
r_char
op_star
id|path
comma
r_struct
id|strbuf
op_star
id|buf
)paren
(brace
r_switch
c_cond
(paren
id|st-&gt;st_mode
op_amp
id|S_IFMT
)paren
(brace
r_case
id|S_IFLNK
suffix:colon
r_if
c_cond
(paren
id|strbuf_readlink
c_func
(paren
id|buf
comma
id|path
comma
id|st-&gt;st_size
)paren
OL
l_int|0
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;unable to read symlink %s&quot;
)paren
comma
id|path
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|S_IFREG
suffix:colon
r_if
c_cond
(paren
id|strbuf_read_file
c_func
(paren
id|buf
comma
id|path
comma
id|st-&gt;st_size
)paren
op_ne
id|st-&gt;st_size
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;unable to open or read %s&quot;
)paren
comma
id|path
)paren
suffix:semicolon
id|convert_to_git
c_func
(paren
id|path
comma
id|buf-&gt;buf
comma
id|buf-&gt;len
comma
id|buf
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
r_return
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Update the preimage, and the common lines in postimage,&n; * from buffer buf of length len. If postlen is 0 the postimage&n; * is updated in place, otherwise it&squot;s updated on a new buffer&n; * of length postlen&n; */
DECL|function|update_pre_post_images
r_static
r_void
id|update_pre_post_images
c_func
(paren
r_struct
id|image
op_star
id|preimage
comma
r_struct
id|image
op_star
id|postimage
comma
r_char
op_star
id|buf
comma
r_int
id|len
comma
r_int
id|postlen
)paren
(brace
r_int
id|i
comma
id|ctx
comma
id|reduced
suffix:semicolon
r_char
op_star
r_new
comma
op_star
id|old
comma
op_star
id|fixed
suffix:semicolon
r_struct
id|image
id|fixed_preimage
suffix:semicolon
multiline_comment|/*&n;&t; * Update the preimage with whitespace fixes.  Note that we&n;&t; * are not losing preimage-&gt;buf -- apply_one_fragment() will&n;&t; * free &quot;oldlines&quot;.&n;&t; */
id|prepare_image
c_func
(paren
op_amp
id|fixed_preimage
comma
id|buf
comma
id|len
comma
l_int|1
)paren
suffix:semicolon
m_assert
(paren
id|postlen
ques
c_cond
id|fixed_preimage.nr
op_eq
id|preimage-&gt;nr
suffix:colon
id|fixed_preimage.nr
op_le
id|preimage-&gt;nr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|fixed_preimage.nr
suffix:semicolon
id|i
op_increment
)paren
id|fixed_preimage.line
(braket
id|i
)braket
dot
id|flag
op_assign
id|preimage-&gt;line
(braket
id|i
)braket
dot
id|flag
suffix:semicolon
id|free
c_func
(paren
id|preimage-&gt;line_allocated
)paren
suffix:semicolon
op_star
id|preimage
op_assign
id|fixed_preimage
suffix:semicolon
multiline_comment|/*&n;&t; * Adjust the common context lines in postimage. This can be&n;&t; * done in-place when we are shrinking it with whitespace&n;&t; * fixing, but needs a new buffer when ignoring whitespace or&n;&t; * expanding leading tabs to spaces.&n;&t; *&n;&t; * We trust the caller to tell us if the update can be done&n;&t; * in place (postlen==0) or not.&n;&t; */
id|old
op_assign
id|postimage-&gt;buf
suffix:semicolon
r_if
c_cond
(paren
id|postlen
)paren
r_new
op_assign
id|postimage-&gt;buf
op_assign
id|xmalloc
c_func
(paren
id|postlen
)paren
suffix:semicolon
r_else
r_new
op_assign
id|old
suffix:semicolon
id|fixed
op_assign
id|preimage-&gt;buf
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|reduced
op_assign
id|ctx
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|postimage-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|len
op_assign
id|postimage-&gt;line
(braket
id|i
)braket
dot
id|len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|postimage-&gt;line
(braket
id|i
)braket
dot
id|flag
op_amp
id|LINE_COMMON
)paren
)paren
(brace
multiline_comment|/* an added line -- no counterparts in preimage */
id|memmove
c_func
(paren
r_new
comma
id|old
comma
id|len
)paren
suffix:semicolon
id|old
op_add_assign
id|len
suffix:semicolon
r_new
op_add_assign
id|len
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* a common context -- skip it in the original postimage */
id|old
op_add_assign
id|len
suffix:semicolon
multiline_comment|/* and find the corresponding one in the fixed preimage */
r_while
c_loop
(paren
id|ctx
OL
id|preimage-&gt;nr
op_logical_and
op_logical_neg
(paren
id|preimage-&gt;line
(braket
id|ctx
)braket
dot
id|flag
op_amp
id|LINE_COMMON
)paren
)paren
(brace
id|fixed
op_add_assign
id|preimage-&gt;line
(braket
id|ctx
)braket
dot
id|len
suffix:semicolon
id|ctx
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * preimage is expected to run out, if the caller&n;&t;&t; * fixed addition of trailing blank lines.&n;&t;&t; */
r_if
c_cond
(paren
id|preimage-&gt;nr
op_le
id|ctx
)paren
(brace
id|reduced
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* and copy it in, while fixing the line length */
id|len
op_assign
id|preimage-&gt;line
(braket
id|ctx
)braket
dot
id|len
suffix:semicolon
id|memcpy
c_func
(paren
r_new
comma
id|fixed
comma
id|len
)paren
suffix:semicolon
r_new
op_add_assign
id|len
suffix:semicolon
id|fixed
op_add_assign
id|len
suffix:semicolon
id|postimage-&gt;line
(braket
id|i
)braket
dot
id|len
op_assign
id|len
suffix:semicolon
id|ctx
op_increment
suffix:semicolon
)brace
multiline_comment|/* Fix the length of the whole thing */
id|postimage-&gt;len
op_assign
r_new
id|postimage-&gt;buf
suffix:semicolon
id|postimage-&gt;nr
op_sub_assign
id|reduced
suffix:semicolon
)brace
DECL|function|match_fragment
r_static
r_int
id|match_fragment
c_func
(paren
r_struct
id|image
op_star
id|img
comma
r_struct
id|image
op_star
id|preimage
comma
r_struct
id|image
op_star
id|postimage
comma
r_int
r_int
r_try
comma
r_int
id|try_lno
comma
r_int
id|ws_rule
comma
r_int
id|match_beginning
comma
r_int
id|match_end
)paren
(brace
r_int
id|i
suffix:semicolon
r_char
op_star
id|fixed_buf
comma
op_star
id|buf
comma
op_star
id|orig
comma
op_star
id|target
suffix:semicolon
r_struct
id|strbuf
id|fixed
suffix:semicolon
r_int
id|fixed_len
comma
id|postlen
suffix:semicolon
r_int
id|preimage_limit
suffix:semicolon
r_if
c_cond
(paren
id|preimage-&gt;nr
op_plus
id|try_lno
op_le
id|img-&gt;nr
)paren
(brace
multiline_comment|/*&n;&t;&t; * The hunk falls within the boundaries of img.&n;&t;&t; */
id|preimage_limit
op_assign
id|preimage-&gt;nr
suffix:semicolon
r_if
c_cond
(paren
id|match_end
op_logical_and
(paren
id|preimage-&gt;nr
op_plus
id|try_lno
op_ne
id|img-&gt;nr
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ws_error_action
op_eq
id|correct_ws_error
op_logical_and
(paren
id|ws_rule
op_amp
id|WS_BLANK_AT_EOF
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * This hunk extends beyond the end of img, and we are&n;&t;&t; * removing blank lines at the end of the file.  This&n;&t;&t; * many lines from the beginning of the preimage must&n;&t;&t; * match with img, and the remainder of the preimage&n;&t;&t; * must be blank.&n;&t;&t; */
id|preimage_limit
op_assign
id|img-&gt;nr
id|try_lno
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * The hunk extends beyond the end of the img and&n;&t;&t; * we are not removing blanks at the end, so we&n;&t;&t; * should reject the hunk at this position.&n;&t;&t; */
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|match_beginning
op_logical_and
id|try_lno
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Quick hash check */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|preimage_limit
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
(paren
id|img-&gt;line
(braket
id|try_lno
op_plus
id|i
)braket
dot
id|flag
op_amp
id|LINE_PATCHED
)paren
op_logical_or
(paren
id|preimage-&gt;line
(braket
id|i
)braket
dot
id|hash
op_ne
id|img-&gt;line
(braket
id|try_lno
op_plus
id|i
)braket
dot
id|hash
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|preimage_limit
op_eq
id|preimage-&gt;nr
)paren
(brace
multiline_comment|/*&n;&t;&t; * Do we have an exact match?  If we were told to match&n;&t;&t; * at the end, size must be exactly at try+fragsize,&n;&t;&t; * otherwise try+fragsize must be still within the preimage,&n;&t;&t; * and either case, the old piece should match the preimage&n;&t;&t; * exactly.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|match_end
ques
c_cond
(paren
r_try
op_plus
id|preimage-&gt;len
op_eq
id|img-&gt;len
)paren
suffix:colon
(paren
r_try
op_plus
id|preimage-&gt;len
op_le
id|img-&gt;len
)paren
)paren
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|img-&gt;buf
op_plus
r_try
comma
id|preimage-&gt;buf
comma
id|preimage-&gt;len
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * The preimage extends beyond the end of img, so&n;&t;&t; * there cannot be an exact match.&n;&t;&t; *&n;&t;&t; * There must be one non-blank context line that match&n;&t;&t; * a line before the end of img.&n;&t;&t; */
r_char
op_star
id|buf_end
suffix:semicolon
id|buf
op_assign
id|preimage-&gt;buf
suffix:semicolon
id|buf_end
op_assign
id|buf
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|preimage_limit
suffix:semicolon
id|i
op_increment
)paren
id|buf_end
op_add_assign
id|preimage-&gt;line
(braket
id|i
)braket
dot
id|len
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|buf
OL
id|buf_end
suffix:semicolon
id|buf
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|isspace
c_func
(paren
op_star
id|buf
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|buf
op_eq
id|buf_end
)paren
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * No exact match. If we are ignoring whitespace, run a line-by-line&n;&t; * fuzzy matching. We collect all the line length information because&n;&t; * we need it to adjust whitespace if we match.&n;&t; */
r_if
c_cond
(paren
id|ws_ignore_action
op_eq
id|ignore_ws_change
)paren
(brace
r_int
id|imgoff
op_assign
l_int|0
suffix:semicolon
r_int
id|preoff
op_assign
l_int|0
suffix:semicolon
r_int
id|postlen
op_assign
id|postimage-&gt;len
suffix:semicolon
r_int
id|extra_chars
suffix:semicolon
r_char
op_star
id|preimage_eof
suffix:semicolon
r_char
op_star
id|preimage_end
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|preimage_limit
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|prelen
op_assign
id|preimage-&gt;line
(braket
id|i
)braket
dot
id|len
suffix:semicolon
r_int
id|imglen
op_assign
id|img-&gt;line
(braket
id|try_lno
op_plus
id|i
)braket
dot
id|len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fuzzy_matchlines
c_func
(paren
id|img-&gt;buf
op_plus
r_try
op_plus
id|imgoff
comma
id|imglen
comma
id|preimage-&gt;buf
op_plus
id|preoff
comma
id|prelen
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|preimage-&gt;line
(braket
id|i
)braket
dot
id|flag
op_amp
id|LINE_COMMON
)paren
id|postlen
op_add_assign
id|imglen
id|prelen
suffix:semicolon
id|imgoff
op_add_assign
id|imglen
suffix:semicolon
id|preoff
op_add_assign
id|prelen
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Ok, the preimage matches with whitespace fuzz.&n;&t;&t; *&n;&t;&t; * imgoff now holds the true length of the target that&n;&t;&t; * matches the preimage before the end of the file.&n;&t;&t; *&n;&t;&t; * Count the number of characters in the preimage that fall&n;&t;&t; * beyond the end of the file and make sure that all of them&n;&t;&t; * are whitespace characters. (This can only happen if&n;&t;&t; * we are removing blank lines at the end of the file.)&n;&t;&t; */
id|buf
op_assign
id|preimage_eof
op_assign
id|preimage-&gt;buf
op_plus
id|preoff
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
id|preimage-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
id|preoff
op_add_assign
id|preimage-&gt;line
(braket
id|i
)braket
dot
id|len
suffix:semicolon
id|preimage_end
op_assign
id|preimage-&gt;buf
op_plus
id|preoff
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|buf
OL
id|preimage_end
suffix:semicolon
id|buf
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|isspace
c_func
(paren
op_star
id|buf
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Update the preimage and the common postimage context&n;&t;&t; * lines to use the same whitespace as the target.&n;&t;&t; * If whitespace is missing in the target (i.e.&n;&t;&t; * if the preimage extends beyond the end of the file),&n;&t;&t; * use the whitespace from the preimage.&n;&t;&t; */
id|extra_chars
op_assign
id|preimage_end
id|preimage_eof
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|fixed
comma
id|imgoff
op_plus
id|extra_chars
)paren
suffix:semicolon
id|strbuf_add
c_func
(paren
op_amp
id|fixed
comma
id|img-&gt;buf
op_plus
r_try
comma
id|imgoff
)paren
suffix:semicolon
id|strbuf_add
c_func
(paren
op_amp
id|fixed
comma
id|preimage_eof
comma
id|extra_chars
)paren
suffix:semicolon
id|fixed_buf
op_assign
id|strbuf_detach
c_func
(paren
op_amp
id|fixed
comma
op_amp
id|fixed_len
)paren
suffix:semicolon
id|update_pre_post_images
c_func
(paren
id|preimage
comma
id|postimage
comma
id|fixed_buf
comma
id|fixed_len
comma
id|postlen
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ws_error_action
op_ne
id|correct_ws_error
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * The hunk does not apply byte-by-byte, but the hash says&n;&t; * it might with whitespace fuzz. We haven&squot;t been asked to&n;&t; * ignore whitespace, we were asked to correct whitespace&n;&t; * errors, so let&squot;s try matching after whitespace correction.&n;&t; *&n;&t; * The preimage may extend beyond the end of the file,&n;&t; * but in this loop we will only handle the part of the&n;&t; * preimage that falls within the file.&n;&t; */
id|strbuf_init
c_func
(paren
op_amp
id|fixed
comma
id|preimage-&gt;len
op_plus
l_int|1
)paren
suffix:semicolon
id|orig
op_assign
id|preimage-&gt;buf
suffix:semicolon
id|target
op_assign
id|img-&gt;buf
op_plus
r_try
suffix:semicolon
id|postlen
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|preimage_limit
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|oldlen
op_assign
id|preimage-&gt;line
(braket
id|i
)braket
dot
id|len
suffix:semicolon
r_int
id|tgtlen
op_assign
id|img-&gt;line
(braket
id|try_lno
op_plus
id|i
)braket
dot
id|len
suffix:semicolon
r_int
id|fixstart
op_assign
id|fixed.len
suffix:semicolon
r_struct
id|strbuf
id|tgtfix
suffix:semicolon
r_int
id|match
suffix:semicolon
multiline_comment|/* Try fixing the line in the preimage */
id|ws_fix_copy
c_func
(paren
op_amp
id|fixed
comma
id|orig
comma
id|oldlen
comma
id|ws_rule
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Try fixing the line in the target */
id|strbuf_init
c_func
(paren
op_amp
id|tgtfix
comma
id|tgtlen
)paren
suffix:semicolon
id|ws_fix_copy
c_func
(paren
op_amp
id|tgtfix
comma
id|target
comma
id|tgtlen
comma
id|ws_rule
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If they match, either the preimage was based on&n;&t;&t; * a version before our tree fixed whitespace breakage,&n;&t;&t; * or we are lacking a whitespace-fix patch the tree&n;&t;&t; * the preimage was based on already had (i.e. target&n;&t;&t; * has whitespace breakage, the preimage doesn&squot;t).&n;&t;&t; * In either case, we are fixing the whitespace breakages&n;&t;&t; * so we might as well take the fix together with their&n;&t;&t; * real change.&n;&t;&t; */
id|match
op_assign
(paren
id|tgtfix.len
op_eq
id|fixed.len
id|fixstart
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|tgtfix.buf
comma
id|fixed.buf
op_plus
id|fixstart
comma
id|fixed.len
id|fixstart
)paren
)paren
suffix:semicolon
id|postlen
op_add_assign
id|tgtfix.len
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|tgtfix
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|match
)paren
r_goto
id|unmatch_exit
suffix:semicolon
id|orig
op_add_assign
id|oldlen
suffix:semicolon
id|target
op_add_assign
id|tgtlen
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now handle the lines in the preimage that falls beyond the&n;&t; * end of the file (if any). They will only match if they are&n;&t; * empty or only contain whitespace (if WS_BLANK_AT_EOL is&n;&t; * false).&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
id|preimage-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|fixstart
op_assign
id|fixed.len
suffix:semicolon
multiline_comment|/* start of the fixed preimage */
r_int
id|oldlen
op_assign
id|preimage-&gt;line
(braket
id|i
)braket
dot
id|len
suffix:semicolon
r_int
id|j
suffix:semicolon
multiline_comment|/* Try fixing the line in the preimage */
id|ws_fix_copy
c_func
(paren
op_amp
id|fixed
comma
id|orig
comma
id|oldlen
comma
id|ws_rule
comma
l_int|NULL
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|fixstart
suffix:semicolon
id|j
OL
id|fixed.len
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|isspace
c_func
(paren
id|fixed.buf
(braket
id|j
)braket
)paren
)paren
r_goto
id|unmatch_exit
suffix:semicolon
id|orig
op_add_assign
id|oldlen
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Yes, the preimage is based on an older version that still&n;&t; * has whitespace breakages unfixed, and fixing them makes the&n;&t; * hunk match.  Update the context lines in the postimage.&n;&t; */
id|fixed_buf
op_assign
id|strbuf_detach
c_func
(paren
op_amp
id|fixed
comma
op_amp
id|fixed_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|postlen
OL
id|postimage-&gt;len
)paren
id|postlen
op_assign
l_int|0
suffix:semicolon
id|update_pre_post_images
c_func
(paren
id|preimage
comma
id|postimage
comma
id|fixed_buf
comma
id|fixed_len
comma
id|postlen
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
id|unmatch_exit
suffix:colon
id|strbuf_release
c_func
(paren
op_amp
id|fixed
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|find_pos
r_static
r_int
id|find_pos
c_func
(paren
r_struct
id|image
op_star
id|img
comma
r_struct
id|image
op_star
id|preimage
comma
r_struct
id|image
op_star
id|postimage
comma
r_int
id|line
comma
r_int
id|ws_rule
comma
r_int
id|match_beginning
comma
r_int
id|match_end
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|backwards
comma
id|forwards
comma
r_try
suffix:semicolon
r_int
id|backwards_lno
comma
id|forwards_lno
comma
id|try_lno
suffix:semicolon
multiline_comment|/*&n;&t; * If match_beginning or match_end is specified, there is no&n;&t; * point starting from a wrong line that will never match and&n;&t; * wander around and wait for a match at the specified end.&n;&t; */
r_if
c_cond
(paren
id|match_beginning
)paren
id|line
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|match_end
)paren
id|line
op_assign
id|img-&gt;nr
id|preimage-&gt;nr
suffix:semicolon
multiline_comment|/*&n;&t; * Because the comparison is unsigned, the following test&n;&t; * will also take care of a negative line number that can&n;&t; * result when match_end and preimage is larger than the target.&n;&t; */
r_if
c_cond
(paren
(paren
r_int
)paren
id|line
OG
id|img-&gt;nr
)paren
id|line
op_assign
id|img-&gt;nr
suffix:semicolon
r_try
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|line
suffix:semicolon
id|i
op_increment
)paren
r_try
op_add_assign
id|img-&gt;line
(braket
id|i
)braket
dot
id|len
suffix:semicolon
multiline_comment|/*&n;&t; * There&squot;s probably some smart way to do this, but I&squot;ll leave&n;&t; * that to the smart and beautiful people. I&squot;m simple and stupid.&n;&t; */
id|backwards
op_assign
r_try
suffix:semicolon
id|backwards_lno
op_assign
id|line
suffix:semicolon
id|forwards
op_assign
r_try
suffix:semicolon
id|forwards_lno
op_assign
id|line
suffix:semicolon
id|try_lno
op_assign
id|line
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|match_fragment
c_func
(paren
id|img
comma
id|preimage
comma
id|postimage
comma
r_try
comma
id|try_lno
comma
id|ws_rule
comma
id|match_beginning
comma
id|match_end
)paren
)paren
r_return
id|try_lno
suffix:semicolon
id|again
suffix:colon
r_if
c_cond
(paren
id|backwards_lno
op_eq
l_int|0
op_logical_and
id|forwards_lno
op_eq
id|img-&gt;nr
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_amp
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|backwards_lno
op_eq
l_int|0
)paren
(brace
id|i
op_increment
suffix:semicolon
r_goto
id|again
suffix:semicolon
)brace
id|backwards_lno
op_decrement
suffix:semicolon
id|backwards
op_sub_assign
id|img-&gt;line
(braket
id|backwards_lno
)braket
dot
id|len
suffix:semicolon
r_try
op_assign
id|backwards
suffix:semicolon
id|try_lno
op_assign
id|backwards_lno
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|forwards_lno
op_eq
id|img-&gt;nr
)paren
(brace
id|i
op_increment
suffix:semicolon
r_goto
id|again
suffix:semicolon
)brace
id|forwards
op_add_assign
id|img-&gt;line
(braket
id|forwards_lno
)braket
dot
id|len
suffix:semicolon
id|forwards_lno
op_increment
suffix:semicolon
r_try
op_assign
id|forwards
suffix:semicolon
id|try_lno
op_assign
id|forwards_lno
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|remove_first_line
r_static
r_void
id|remove_first_line
c_func
(paren
r_struct
id|image
op_star
id|img
)paren
(brace
id|img-&gt;buf
op_add_assign
id|img-&gt;line
(braket
l_int|0
)braket
dot
id|len
suffix:semicolon
id|img-&gt;len
op_sub_assign
id|img-&gt;line
(braket
l_int|0
)braket
dot
id|len
suffix:semicolon
id|img-&gt;line
op_increment
suffix:semicolon
id|img-&gt;nr
op_decrement
suffix:semicolon
)brace
DECL|function|remove_last_line
r_static
r_void
id|remove_last_line
c_func
(paren
r_struct
id|image
op_star
id|img
)paren
(brace
id|img-&gt;len
op_sub_assign
id|img-&gt;line
(braket
op_decrement
id|img-&gt;nr
)braket
dot
id|len
suffix:semicolon
)brace
multiline_comment|/*&n; * The change from &quot;preimage&quot; and &quot;postimage&quot; has been found to&n; * apply at applied_pos (counts in line numbers) in &quot;img&quot;.&n; * Update &quot;img&quot; to remove &quot;preimage&quot; and replace it with &quot;postimage&quot;.&n; */
DECL|function|update_image
r_static
r_void
id|update_image
c_func
(paren
r_struct
id|image
op_star
id|img
comma
r_int
id|applied_pos
comma
r_struct
id|image
op_star
id|preimage
comma
r_struct
id|image
op_star
id|postimage
)paren
(brace
multiline_comment|/*&n;&t; * remove the copy of preimage at offset in img&n;&t; * and replace it with postimage&n;&t; */
r_int
id|i
comma
id|nr
suffix:semicolon
r_int
id|remove_count
comma
id|insert_count
comma
id|applied_at
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|result
suffix:semicolon
r_int
id|preimage_limit
suffix:semicolon
multiline_comment|/*&n;&t; * If we are removing blank lines at the end of img,&n;&t; * the preimage may extend beyond the end.&n;&t; * If that is the case, we must be careful only to&n;&t; * remove the part of the preimage that falls within&n;&t; * the boundaries of img. Initialize preimage_limit&n;&t; * to the number of lines in the preimage that falls&n;&t; * within the boundaries.&n;&t; */
id|preimage_limit
op_assign
id|preimage-&gt;nr
suffix:semicolon
r_if
c_cond
(paren
id|preimage_limit
OG
id|img-&gt;nr
id|applied_pos
)paren
id|preimage_limit
op_assign
id|img-&gt;nr
id|applied_pos
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|applied_pos
suffix:semicolon
id|i
op_increment
)paren
id|applied_at
op_add_assign
id|img-&gt;line
(braket
id|i
)braket
dot
id|len
suffix:semicolon
id|remove_count
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|preimage_limit
suffix:semicolon
id|i
op_increment
)paren
id|remove_count
op_add_assign
id|img-&gt;line
(braket
id|applied_pos
op_plus
id|i
)braket
dot
id|len
suffix:semicolon
id|insert_count
op_assign
id|postimage-&gt;len
suffix:semicolon
multiline_comment|/* Adjust the contents */
id|result
op_assign
id|xmalloc
c_func
(paren
id|img-&gt;len
op_plus
id|insert_count
id|remove_count
op_plus
l_int|1
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|result
comma
id|img-&gt;buf
comma
id|applied_at
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|result
op_plus
id|applied_at
comma
id|postimage-&gt;buf
comma
id|postimage-&gt;len
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|result
op_plus
id|applied_at
op_plus
id|postimage-&gt;len
comma
id|img-&gt;buf
op_plus
(paren
id|applied_at
op_plus
id|remove_count
)paren
comma
id|img-&gt;len
(paren
id|applied_at
op_plus
id|remove_count
)paren
)paren
suffix:semicolon
id|free
c_func
(paren
id|img-&gt;buf
)paren
suffix:semicolon
id|img-&gt;buf
op_assign
id|result
suffix:semicolon
id|img-&gt;len
op_add_assign
id|insert_count
id|remove_count
suffix:semicolon
id|result
(braket
id|img-&gt;len
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
multiline_comment|/* Adjust the line table */
id|nr
op_assign
id|img-&gt;nr
op_plus
id|postimage-&gt;nr
id|preimage_limit
suffix:semicolon
r_if
c_cond
(paren
id|preimage_limit
OL
id|postimage-&gt;nr
)paren
(brace
multiline_comment|/*&n;&t;&t; * NOTE: this knows that we never call remove_first_line()&n;&t;&t; * on anything other than pre/post image.&n;&t;&t; */
id|img-&gt;line
op_assign
id|xrealloc
c_func
(paren
id|img-&gt;line
comma
id|nr
op_star
r_sizeof
(paren
op_star
id|img-&gt;line
)paren
)paren
suffix:semicolon
id|img-&gt;line_allocated
op_assign
id|img-&gt;line
suffix:semicolon
)brace
r_if
c_cond
(paren
id|preimage_limit
op_ne
id|postimage-&gt;nr
)paren
id|memmove
c_func
(paren
id|img-&gt;line
op_plus
id|applied_pos
op_plus
id|postimage-&gt;nr
comma
id|img-&gt;line
op_plus
id|applied_pos
op_plus
id|preimage_limit
comma
(paren
id|img-&gt;nr
(paren
id|applied_pos
op_plus
id|preimage_limit
)paren
)paren
op_star
r_sizeof
(paren
op_star
id|img-&gt;line
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|img-&gt;line
op_plus
id|applied_pos
comma
id|postimage-&gt;line
comma
id|postimage-&gt;nr
op_star
r_sizeof
(paren
op_star
id|img-&gt;line
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|allow_overlap
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|postimage-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
id|img-&gt;line
(braket
id|applied_pos
op_plus
id|i
)braket
dot
id|flag
op_or_assign
id|LINE_PATCHED
suffix:semicolon
id|img-&gt;nr
op_assign
id|nr
suffix:semicolon
)brace
multiline_comment|/*&n; * Use the patch-hunk text in &quot;frag&quot; to prepare two images (preimage and&n; * postimage) for the hunk.  Find lines that match &quot;preimage&quot; in &quot;img&quot; and&n; * replace the part of &quot;img&quot; with &quot;postimage&quot; text.&n; */
DECL|function|apply_one_fragment
r_static
r_int
id|apply_one_fragment
c_func
(paren
r_struct
id|image
op_star
id|img
comma
r_struct
id|fragment
op_star
id|frag
comma
r_int
id|inaccurate_eof
comma
r_int
id|ws_rule
comma
r_int
id|nth_fragment
)paren
(brace
r_int
id|match_beginning
comma
id|match_end
suffix:semicolon
r_const
r_char
op_star
id|patch
op_assign
id|frag-&gt;patch
suffix:semicolon
r_int
id|size
op_assign
id|frag-&gt;size
suffix:semicolon
r_char
op_star
id|old
comma
op_star
id|oldlines
suffix:semicolon
r_struct
id|strbuf
id|newlines
suffix:semicolon
r_int
id|new_blank_lines_at_end
op_assign
l_int|0
suffix:semicolon
r_int
id|found_new_blank_lines_at_end
op_assign
l_int|0
suffix:semicolon
r_int
id|hunk_linenr
op_assign
id|frag-&gt;linenr
suffix:semicolon
r_int
r_int
id|leading
comma
id|trailing
suffix:semicolon
r_int
id|pos
comma
id|applied_pos
suffix:semicolon
r_struct
id|image
id|preimage
suffix:semicolon
r_struct
id|image
id|postimage
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|preimage
comma
l_int|0
comma
r_sizeof
(paren
id|preimage
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|postimage
comma
l_int|0
comma
r_sizeof
(paren
id|postimage
)paren
)paren
suffix:semicolon
id|oldlines
op_assign
id|xmalloc
c_func
(paren
id|size
)paren
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|newlines
comma
id|size
)paren
suffix:semicolon
id|old
op_assign
id|oldlines
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
r_char
id|first
suffix:semicolon
r_int
id|len
op_assign
id|linelen
c_func
(paren
id|patch
comma
id|size
)paren
suffix:semicolon
r_int
id|plen
suffix:semicolon
r_int
id|added_blank_line
op_assign
l_int|0
suffix:semicolon
r_int
id|is_blank_context
op_assign
l_int|0
suffix:semicolon
r_int
id|start
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * &quot;plen&quot; is how much of the line we should use for&n;&t;&t; * the actual patch data. Normally we just remove the&n;&t;&t; * first character on the line, but if the line is&n;&t;&t; * followed by &quot;&bslash; No newline&quot;, then we also remove the&n;&t;&t; * last one (which is the newline, of course).&n;&t;&t; */
id|plen
op_assign
id|len
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
id|size
op_logical_and
id|patch
(braket
id|len
)braket
op_eq
l_char|&squot;&bslash;&bslash;&squot;
)paren
id|plen
op_decrement
suffix:semicolon
id|first
op_assign
op_star
id|patch
suffix:semicolon
r_if
c_cond
(paren
id|apply_in_reverse
)paren
(brace
r_if
c_cond
(paren
id|first
op_eq
l_char|&squot;-&squot;
)paren
id|first
op_assign
l_char|&squot;+&squot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|first
op_eq
l_char|&squot;+&squot;
)paren
id|first
op_assign
l_char|&squot;-&squot;
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|first
)paren
(brace
r_case
l_char|&squot;&bslash;n&squot;
suffix:colon
multiline_comment|/* Newer GNU diff, empty context line */
r_if
c_cond
(paren
id|plen
OL
l_int|0
)paren
multiline_comment|/* ... followed by &squot;&bslash;No newline&squot;; nothing */
r_break
suffix:semicolon
op_star
id|old
op_increment
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
id|strbuf_addch
c_func
(paren
op_amp
id|newlines
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|add_line_info
c_func
(paren
op_amp
id|preimage
comma
l_string|&quot;&bslash;n&quot;
comma
l_int|1
comma
id|LINE_COMMON
)paren
suffix:semicolon
id|add_line_info
c_func
(paren
op_amp
id|postimage
comma
l_string|&quot;&bslash;n&quot;
comma
l_int|1
comma
id|LINE_COMMON
)paren
suffix:semicolon
id|is_blank_context
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot; &squot;
suffix:colon
r_if
c_cond
(paren
id|plen
op_logical_and
(paren
id|ws_rule
op_amp
id|WS_BLANK_AT_EOF
)paren
op_logical_and
id|ws_blank_line
c_func
(paren
id|patch
op_plus
l_int|1
comma
id|plen
comma
id|ws_rule
)paren
)paren
id|is_blank_context
op_assign
l_int|1
suffix:semicolon
r_case
l_char|&squot;-&squot;
suffix:colon
id|memcpy
c_func
(paren
id|old
comma
id|patch
op_plus
l_int|1
comma
id|plen
)paren
suffix:semicolon
id|add_line_info
c_func
(paren
op_amp
id|preimage
comma
id|old
comma
id|plen
comma
(paren
id|first
op_eq
l_char|&squot; &squot;
ques
c_cond
id|LINE_COMMON
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
id|old
op_add_assign
id|plen
suffix:semicolon
r_if
c_cond
(paren
id|first
op_eq
l_char|&squot;-&squot;
)paren
r_break
suffix:semicolon
multiline_comment|/* Fall-through for &squot; &squot; */
r_case
l_char|&squot;+&squot;
suffix:colon
multiline_comment|/* --no-add does not add new lines */
r_if
c_cond
(paren
id|first
op_eq
l_char|&squot;+&squot;
op_logical_and
id|no_add
)paren
r_break
suffix:semicolon
id|start
op_assign
id|newlines.len
suffix:semicolon
r_if
c_cond
(paren
id|first
op_ne
l_char|&squot;+&squot;
op_logical_or
op_logical_neg
id|whitespace_error
op_logical_or
id|ws_error_action
op_ne
id|correct_ws_error
)paren
(brace
id|strbuf_add
c_func
(paren
op_amp
id|newlines
comma
id|patch
op_plus
l_int|1
comma
id|plen
)paren
suffix:semicolon
)brace
r_else
(brace
id|ws_fix_copy
c_func
(paren
op_amp
id|newlines
comma
id|patch
op_plus
l_int|1
comma
id|plen
comma
id|ws_rule
comma
op_amp
id|applied_after_fixing_ws
)paren
suffix:semicolon
)brace
id|add_line_info
c_func
(paren
op_amp
id|postimage
comma
id|newlines.buf
op_plus
id|start
comma
id|newlines.len
id|start
comma
(paren
id|first
op_eq
l_char|&squot;+&squot;
ques
c_cond
l_int|0
suffix:colon
id|LINE_COMMON
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|first
op_eq
l_char|&squot;+&squot;
op_logical_and
(paren
id|ws_rule
op_amp
id|WS_BLANK_AT_EOF
)paren
op_logical_and
id|ws_blank_line
c_func
(paren
id|patch
op_plus
l_int|1
comma
id|plen
comma
id|ws_rule
)paren
)paren
id|added_blank_line
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;@&squot;
suffix:colon
r_case
l_char|&squot;&bslash;&bslash;&squot;
suffix:colon
multiline_comment|/* Ignore it, we already handled it */
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|apply_verbosely
)paren
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;invalid start of line: &squot;%c&squot;&quot;
)paren
comma
id|first
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|added_blank_line
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|new_blank_lines_at_end
)paren
id|found_new_blank_lines_at_end
op_assign
id|hunk_linenr
suffix:semicolon
id|new_blank_lines_at_end
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|is_blank_context
)paren
suffix:semicolon
r_else
id|new_blank_lines_at_end
op_assign
l_int|0
suffix:semicolon
id|patch
op_add_assign
id|len
suffix:semicolon
id|size
op_sub_assign
id|len
suffix:semicolon
id|hunk_linenr
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|inaccurate_eof
op_logical_and
id|old
OG
id|oldlines
op_logical_and
id|old
(braket
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
op_logical_and
id|newlines.len
OG
l_int|0
op_logical_and
id|newlines.buf
(braket
id|newlines.len
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|old
op_decrement
suffix:semicolon
id|strbuf_setlen
c_func
(paren
op_amp
id|newlines
comma
id|newlines.len
l_int|1
)paren
suffix:semicolon
)brace
id|leading
op_assign
id|frag-&gt;leading
suffix:semicolon
id|trailing
op_assign
id|frag-&gt;trailing
suffix:semicolon
multiline_comment|/*&n;&t; * A hunk to change lines at the beginning would begin with&n;&t; * @@ -1,L +N,M @@&n;&t; * but we need to be careful.  -U0 that inserts before the second&n;&t; * line also has this pattern.&n;&t; *&n;&t; * And a hunk to add to an empty file would begin with&n;&t; * @@ -0,0 +N,M @@&n;&t; *&n;&t; * In other words, a hunk that is (frag-&gt;oldpos &lt;= 1) with or&n;&t; * without leading context must match at the beginning.&n;&t; */
id|match_beginning
op_assign
(paren
op_logical_neg
id|frag-&gt;oldpos
op_logical_or
(paren
id|frag-&gt;oldpos
op_eq
l_int|1
op_logical_and
op_logical_neg
id|unidiff_zero
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * A hunk without trailing lines must match at the end.&n;&t; * However, we simply cannot tell if a hunk must match end&n;&t; * from the lack of trailing lines if the patch was generated&n;&t; * with unidiff without any context.&n;&t; */
id|match_end
op_assign
op_logical_neg
id|unidiff_zero
op_logical_and
op_logical_neg
id|trailing
suffix:semicolon
id|pos
op_assign
id|frag-&gt;newpos
ques
c_cond
(paren
id|frag-&gt;newpos
l_int|1
)paren
suffix:colon
l_int|0
suffix:semicolon
id|preimage.buf
op_assign
id|oldlines
suffix:semicolon
id|preimage.len
op_assign
id|old
id|oldlines
suffix:semicolon
id|postimage.buf
op_assign
id|newlines.buf
suffix:semicolon
id|postimage.len
op_assign
id|newlines.len
suffix:semicolon
id|preimage.line
op_assign
id|preimage.line_allocated
suffix:semicolon
id|postimage.line
op_assign
id|postimage.line_allocated
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|applied_pos
op_assign
id|find_pos
c_func
(paren
id|img
comma
op_amp
id|preimage
comma
op_amp
id|postimage
comma
id|pos
comma
id|ws_rule
comma
id|match_beginning
comma
id|match_end
)paren
suffix:semicolon
r_if
c_cond
(paren
id|applied_pos
op_ge
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* Am I at my context limits? */
r_if
c_cond
(paren
(paren
id|leading
op_le
id|p_context
)paren
op_logical_and
(paren
id|trailing
op_le
id|p_context
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|match_beginning
op_logical_or
id|match_end
)paren
(brace
id|match_beginning
op_assign
id|match_end
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Reduce the number of context lines; reduce both&n;&t;&t; * leading and trailing if they are equal otherwise&n;&t;&t; * just reduce the larger context.&n;&t;&t; */
r_if
c_cond
(paren
id|leading
op_ge
id|trailing
)paren
(brace
id|remove_first_line
c_func
(paren
op_amp
id|preimage
)paren
suffix:semicolon
id|remove_first_line
c_func
(paren
op_amp
id|postimage
)paren
suffix:semicolon
id|pos
op_decrement
suffix:semicolon
id|leading
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|trailing
OG
id|leading
)paren
(brace
id|remove_last_line
c_func
(paren
op_amp
id|preimage
)paren
suffix:semicolon
id|remove_last_line
c_func
(paren
op_amp
id|postimage
)paren
suffix:semicolon
id|trailing
op_decrement
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|applied_pos
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|new_blank_lines_at_end
op_logical_and
id|preimage.nr
op_plus
id|applied_pos
op_ge
id|img-&gt;nr
op_logical_and
(paren
id|ws_rule
op_amp
id|WS_BLANK_AT_EOF
)paren
op_logical_and
id|ws_error_action
op_ne
id|nowarn_ws_error
)paren
(brace
id|record_ws_error
c_func
(paren
id|WS_BLANK_AT_EOF
comma
l_string|&quot;+&quot;
comma
l_int|1
comma
id|found_new_blank_lines_at_end
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ws_error_action
op_eq
id|correct_ws_error
)paren
(brace
r_while
c_loop
(paren
id|new_blank_lines_at_end
op_decrement
)paren
id|remove_last_line
c_func
(paren
op_amp
id|postimage
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * We would want to prevent write_out_results()&n;&t;&t;&t; * from taking place in apply_patch() that follows&n;&t;&t;&t; * the callchain led us here, which is:&n;&t;&t;&t; * apply_patch-&gt;check_patch_list-&gt;check_patch-&gt;&n;&t;&t;&t; * apply_data-&gt;apply_fragments-&gt;apply_one_fragment&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ws_error_action
op_eq
id|die_on_ws_error
)paren
id|apply
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|apply_verbosely
op_logical_and
id|applied_pos
op_ne
id|pos
)paren
(brace
r_int
id|offset
op_assign
id|applied_pos
id|pos
suffix:semicolon
r_if
c_cond
(paren
id|apply_in_reverse
)paren
id|offset
op_assign
l_int|0
id|offset
suffix:semicolon
id|fprintf_ln
c_func
(paren
id|stderr
comma
id|Q_
c_func
(paren
l_string|&quot;Hunk #%d succeeded at %d (offset %d line).&quot;
comma
l_string|&quot;Hunk #%d succeeded at %d (offset %d lines).&quot;
comma
id|offset
)paren
comma
id|nth_fragment
comma
id|applied_pos
op_plus
l_int|1
comma
id|offset
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Warn if it was necessary to reduce the number&n;&t;&t; * of context lines.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|leading
op_ne
id|frag-&gt;leading
)paren
op_logical_or
(paren
id|trailing
op_ne
id|frag-&gt;trailing
)paren
)paren
id|fprintf_ln
c_func
(paren
id|stderr
comma
id|_
c_func
(paren
l_string|&quot;Context reduced to (%ld/%ld)&quot;
l_string|&quot; to apply fragment at %d&quot;
)paren
comma
id|leading
comma
id|trailing
comma
id|applied_pos
op_plus
l_int|1
)paren
suffix:semicolon
id|update_image
c_func
(paren
id|img
comma
id|applied_pos
comma
op_amp
id|preimage
comma
op_amp
id|postimage
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|apply_verbosely
)paren
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;while searching for:&bslash;n%.*s&quot;
)paren
comma
(paren
r_int
)paren
(paren
id|old
id|oldlines
)paren
comma
id|oldlines
)paren
suffix:semicolon
)brace
id|free
c_func
(paren
id|oldlines
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|newlines
)paren
suffix:semicolon
id|free
c_func
(paren
id|preimage.line_allocated
)paren
suffix:semicolon
id|free
c_func
(paren
id|postimage.line_allocated
)paren
suffix:semicolon
r_return
(paren
id|applied_pos
OL
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|apply_binary_fragment
r_static
r_int
id|apply_binary_fragment
c_func
(paren
r_struct
id|image
op_star
id|img
comma
r_struct
id|patch
op_star
id|patch
)paren
(brace
r_struct
id|fragment
op_star
id|fragment
op_assign
id|patch-&gt;fragments
suffix:semicolon
r_int
r_int
id|len
suffix:semicolon
r_void
op_star
id|dst
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fragment
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;missing binary patch data for &squot;%s&squot;&quot;
)paren
comma
id|patch-&gt;new_name
ques
c_cond
id|patch-&gt;new_name
suffix:colon
id|patch-&gt;old_name
)paren
suffix:semicolon
multiline_comment|/* Binary patch is irreversible without the optional second hunk */
r_if
c_cond
(paren
id|apply_in_reverse
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|fragment-&gt;next
)paren
r_return
id|error
c_func
(paren
l_string|&quot;cannot reverse-apply a binary patch &quot;
l_string|&quot;without the reverse hunk to &squot;%s&squot;&quot;
comma
id|patch-&gt;new_name
ques
c_cond
id|patch-&gt;new_name
suffix:colon
id|patch-&gt;old_name
)paren
suffix:semicolon
id|fragment
op_assign
id|fragment-&gt;next
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|fragment-&gt;binary_patch_method
)paren
(brace
r_case
id|BINARY_DELTA_DEFLATED
suffix:colon
id|dst
op_assign
id|patch_delta
c_func
(paren
id|img-&gt;buf
comma
id|img-&gt;len
comma
id|fragment-&gt;patch
comma
id|fragment-&gt;size
comma
op_amp
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dst
)paren
r_return
l_int|1
suffix:semicolon
id|clear_image
c_func
(paren
id|img
)paren
suffix:semicolon
id|img-&gt;buf
op_assign
id|dst
suffix:semicolon
id|img-&gt;len
op_assign
id|len
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|BINARY_LITERAL_DEFLATED
suffix:colon
id|clear_image
c_func
(paren
id|img
)paren
suffix:semicolon
id|img-&gt;len
op_assign
id|fragment-&gt;size
suffix:semicolon
id|img-&gt;buf
op_assign
id|xmalloc
c_func
(paren
id|img-&gt;len
op_plus
l_int|1
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|img-&gt;buf
comma
id|fragment-&gt;patch
comma
id|img-&gt;len
)paren
suffix:semicolon
id|img-&gt;buf
(braket
id|img-&gt;len
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Replace &quot;img&quot; with the result of applying the binary patch.&n; * The binary patch data itself in patch-&gt;fragment is still kept&n; * but the preimage prepared by the caller in &quot;img&quot; is freed here&n; * or in the helper function apply_binary_fragment() this calls.&n; */
DECL|function|apply_binary
r_static
r_int
id|apply_binary
c_func
(paren
r_struct
id|image
op_star
id|img
comma
r_struct
id|patch
op_star
id|patch
)paren
(brace
r_const
r_char
op_star
id|name
op_assign
id|patch-&gt;old_name
ques
c_cond
id|patch-&gt;old_name
suffix:colon
id|patch-&gt;new_name
suffix:semicolon
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * For safety, we require patch index line to contain&n;&t; * full 40-byte textual SHA1 for old and new, at least for now.&n;&t; */
r_if
c_cond
(paren
id|strlen
c_func
(paren
id|patch-&gt;old_sha1_prefix
)paren
op_ne
l_int|40
op_logical_or
id|strlen
c_func
(paren
id|patch-&gt;new_sha1_prefix
)paren
op_ne
l_int|40
op_logical_or
id|get_sha1_hex
c_func
(paren
id|patch-&gt;old_sha1_prefix
comma
id|sha1
)paren
op_logical_or
id|get_sha1_hex
c_func
(paren
id|patch-&gt;new_sha1_prefix
comma
id|sha1
)paren
)paren
r_return
id|error
c_func
(paren
l_string|&quot;cannot apply binary patch to &squot;%s&squot; &quot;
l_string|&quot;without full index line&quot;
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|patch-&gt;old_name
)paren
(brace
multiline_comment|/*&n;&t;&t; * See if the old one matches what the patch&n;&t;&t; * applies to.&n;&t;&t; */
id|hash_sha1_file
c_func
(paren
id|img-&gt;buf
comma
id|img-&gt;len
comma
id|blob_type
comma
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
comma
id|patch-&gt;old_sha1_prefix
)paren
)paren
r_return
id|error
c_func
(paren
l_string|&quot;the patch applies to &squot;%s&squot; (%s), &quot;
l_string|&quot;which does not match the &quot;
l_string|&quot;current contents.&quot;
comma
id|name
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Otherwise, the old one must be empty. */
r_if
c_cond
(paren
id|img-&gt;len
)paren
r_return
id|error
c_func
(paren
l_string|&quot;the patch applies to an empty &quot;
l_string|&quot;&squot;%s&squot; but it is not empty&quot;
comma
id|name
)paren
suffix:semicolon
)brace
id|get_sha1_hex
c_func
(paren
id|patch-&gt;new_sha1_prefix
comma
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_null_sha1
c_func
(paren
id|sha1
)paren
)paren
(brace
id|clear_image
c_func
(paren
id|img
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* deletion patch */
)brace
r_if
c_cond
(paren
id|has_sha1_file
c_func
(paren
id|sha1
)paren
)paren
(brace
multiline_comment|/* We already have the postimage */
r_enum
id|object_type
id|type
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_char
op_star
id|result
suffix:semicolon
id|result
op_assign
id|read_sha1_file
c_func
(paren
id|sha1
comma
op_amp
id|type
comma
op_amp
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result
)paren
r_return
id|error
c_func
(paren
l_string|&quot;the necessary postimage %s for &quot;
l_string|&quot;&squot;%s&squot; cannot be read&quot;
comma
id|patch-&gt;new_sha1_prefix
comma
id|name
)paren
suffix:semicolon
id|clear_image
c_func
(paren
id|img
)paren
suffix:semicolon
id|img-&gt;buf
op_assign
id|result
suffix:semicolon
id|img-&gt;len
op_assign
id|size
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * We have verified buf matches the preimage;&n;&t;&t; * apply the patch data to it, which is stored&n;&t;&t; * in the patch-&gt;fragments-&gt;{patch,size}.&n;&t;&t; */
r_if
c_cond
(paren
id|apply_binary_fragment
c_func
(paren
id|img
comma
id|patch
)paren
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;binary patch does not apply to &squot;%s&squot;&quot;
)paren
comma
id|name
)paren
suffix:semicolon
multiline_comment|/* verify that the result matches */
id|hash_sha1_file
c_func
(paren
id|img-&gt;buf
comma
id|img-&gt;len
comma
id|blob_type
comma
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
comma
id|patch-&gt;new_sha1_prefix
)paren
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;binary patch to &squot;%s&squot; creates incorrect result (expecting %s, got %s)&quot;
)paren
comma
id|name
comma
id|patch-&gt;new_sha1_prefix
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|apply_fragments
r_static
r_int
id|apply_fragments
c_func
(paren
r_struct
id|image
op_star
id|img
comma
r_struct
id|patch
op_star
id|patch
)paren
(brace
r_struct
id|fragment
op_star
id|frag
op_assign
id|patch-&gt;fragments
suffix:semicolon
r_const
r_char
op_star
id|name
op_assign
id|patch-&gt;old_name
ques
c_cond
id|patch-&gt;old_name
suffix:colon
id|patch-&gt;new_name
suffix:semicolon
r_int
id|ws_rule
op_assign
id|patch-&gt;ws_rule
suffix:semicolon
r_int
id|inaccurate_eof
op_assign
id|patch-&gt;inaccurate_eof
suffix:semicolon
r_int
id|nth
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|patch-&gt;is_binary
)paren
r_return
id|apply_binary
c_func
(paren
id|img
comma
id|patch
)paren
suffix:semicolon
r_while
c_loop
(paren
id|frag
)paren
(brace
id|nth
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|apply_one_fragment
c_func
(paren
id|img
comma
id|frag
comma
id|inaccurate_eof
comma
id|ws_rule
comma
id|nth
)paren
)paren
(brace
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;patch failed: %s:%ld&quot;
)paren
comma
id|name
comma
id|frag-&gt;oldpos
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|apply_with_reject
)paren
r_return
l_int|1
suffix:semicolon
id|frag-&gt;rejected
op_assign
l_int|1
suffix:semicolon
)brace
id|frag
op_assign
id|frag-&gt;next
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|read_blob_object
r_static
r_int
id|read_blob_object
c_func
(paren
r_struct
id|strbuf
op_star
id|buf
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
id|mode
)paren
(brace
r_if
c_cond
(paren
id|S_ISGITLINK
c_func
(paren
id|mode
)paren
)paren
(brace
id|strbuf_grow
c_func
(paren
id|buf
comma
l_int|100
)paren
suffix:semicolon
id|strbuf_addf
c_func
(paren
id|buf
comma
l_string|&quot;Subproject commit %s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_enum
id|object_type
id|type
suffix:semicolon
r_int
r_int
id|sz
suffix:semicolon
r_char
op_star
id|result
suffix:semicolon
id|result
op_assign
id|read_sha1_file
c_func
(paren
id|sha1
comma
op_amp
id|type
comma
op_amp
id|sz
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* XXX read_sha1_file NUL-terminates */
id|strbuf_attach
c_func
(paren
id|buf
comma
id|result
comma
id|sz
comma
id|sz
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|read_file_or_gitlink
r_static
r_int
id|read_file_or_gitlink
c_func
(paren
r_const
r_struct
id|cache_entry
op_star
id|ce
comma
r_struct
id|strbuf
op_star
id|buf
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ce
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|read_blob_object
c_func
(paren
id|buf
comma
id|ce-&gt;sha1
comma
id|ce-&gt;ce_mode
)paren
suffix:semicolon
)brace
DECL|function|in_fn_table
r_static
r_struct
id|patch
op_star
id|in_fn_table
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|string_list_item
op_star
id|item
suffix:semicolon
r_if
c_cond
(paren
id|name
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|item
op_assign
id|string_list_lookup
c_func
(paren
op_amp
id|fn_table
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|item
op_ne
l_int|NULL
)paren
r_return
(paren
r_struct
id|patch
op_star
)paren
id|item-&gt;util
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * item-&gt;util in the filename table records the status of the path.&n; * Usually it points at a patch (whose result records the contents&n; * of it after applying it), but it could be PATH_WAS_DELETED for a&n; * path that a previously applied patch has already removed, or&n; * PATH_TO_BE_DELETED for a path that a later patch would remove.&n; *&n; * The latter is needed to deal with a case where two paths A and B&n; * are swapped by first renaming A to B and then renaming B to A;&n; * moving A to B should not be prevented due to presence of B as we&n; * will remove it in a later patch.&n; */
DECL|macro|PATH_TO_BE_DELETED
mdefine_line|#define PATH_TO_BE_DELETED ((struct patch *) -2)
DECL|macro|PATH_WAS_DELETED
mdefine_line|#define PATH_WAS_DELETED ((struct patch *) -1)
DECL|function|to_be_deleted
r_static
r_int
id|to_be_deleted
c_func
(paren
r_struct
id|patch
op_star
id|patch
)paren
(brace
r_return
id|patch
op_eq
id|PATH_TO_BE_DELETED
suffix:semicolon
)brace
DECL|function|was_deleted
r_static
r_int
id|was_deleted
c_func
(paren
r_struct
id|patch
op_star
id|patch
)paren
(brace
r_return
id|patch
op_eq
id|PATH_WAS_DELETED
suffix:semicolon
)brace
DECL|function|add_to_fn_table
r_static
r_void
id|add_to_fn_table
c_func
(paren
r_struct
id|patch
op_star
id|patch
)paren
(brace
r_struct
id|string_list_item
op_star
id|item
suffix:semicolon
multiline_comment|/*&n;&t; * Always add new_name unless patch is a deletion&n;&t; * This should cover the cases for normal diffs,&n;&t; * file creations and copies&n;&t; */
r_if
c_cond
(paren
id|patch-&gt;new_name
op_ne
l_int|NULL
)paren
(brace
id|item
op_assign
id|string_list_insert
c_func
(paren
op_amp
id|fn_table
comma
id|patch-&gt;new_name
)paren
suffix:semicolon
id|item-&gt;util
op_assign
id|patch
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * store a failure on rename/deletion cases because&n;&t; * later chunks shouldn&squot;t patch old names&n;&t; */
r_if
c_cond
(paren
(paren
id|patch-&gt;new_name
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|patch-&gt;is_rename
)paren
)paren
(brace
id|item
op_assign
id|string_list_insert
c_func
(paren
op_amp
id|fn_table
comma
id|patch-&gt;old_name
)paren
suffix:semicolon
id|item-&gt;util
op_assign
id|PATH_WAS_DELETED
suffix:semicolon
)brace
)brace
DECL|function|prepare_fn_table
r_static
r_void
id|prepare_fn_table
c_func
(paren
r_struct
id|patch
op_star
id|patch
)paren
(brace
multiline_comment|/*&n;&t; * store information about incoming file deletion&n;&t; */
r_while
c_loop
(paren
id|patch
)paren
(brace
r_if
c_cond
(paren
(paren
id|patch-&gt;new_name
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|patch-&gt;is_rename
)paren
)paren
(brace
r_struct
id|string_list_item
op_star
id|item
suffix:semicolon
id|item
op_assign
id|string_list_insert
c_func
(paren
op_amp
id|fn_table
comma
id|patch-&gt;old_name
)paren
suffix:semicolon
id|item-&gt;util
op_assign
id|PATH_TO_BE_DELETED
suffix:semicolon
)brace
id|patch
op_assign
id|patch-&gt;next
suffix:semicolon
)brace
)brace
DECL|function|checkout_target
r_static
r_int
id|checkout_target
c_func
(paren
r_struct
id|cache_entry
op_star
id|ce
comma
r_struct
id|stat
op_star
id|st
)paren
(brace
r_struct
id|checkout
id|costate
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|costate
comma
l_int|0
comma
r_sizeof
(paren
id|costate
)paren
)paren
suffix:semicolon
id|costate.base_dir
op_assign
l_string|&quot;&quot;
suffix:semicolon
id|costate.refresh_cache
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|checkout_entry
c_func
(paren
id|ce
comma
op_amp
id|costate
comma
l_int|NULL
)paren
op_logical_or
id|lstat
c_func
(paren
id|ce-&gt;name
comma
id|st
)paren
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;cannot checkout %s&quot;
)paren
comma
id|ce-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|previous_patch
r_static
r_struct
id|patch
op_star
id|previous_patch
c_func
(paren
r_struct
id|patch
op_star
id|patch
comma
r_int
op_star
id|gone
)paren
(brace
r_struct
id|patch
op_star
id|previous
suffix:semicolon
op_star
id|gone
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|patch-&gt;is_copy
op_logical_or
id|patch-&gt;is_rename
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* &quot;git&quot; patches do not depend on the order */
id|previous
op_assign
id|in_fn_table
c_func
(paren
id|patch-&gt;old_name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|previous
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|to_be_deleted
c_func
(paren
id|previous
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* the deletion hasn&squot;t happened yet */
r_if
c_cond
(paren
id|was_deleted
c_func
(paren
id|previous
)paren
)paren
op_star
id|gone
op_assign
l_int|1
suffix:semicolon
r_return
id|previous
suffix:semicolon
)brace
DECL|function|verify_index_match
r_static
r_int
id|verify_index_match
c_func
(paren
r_const
r_struct
id|cache_entry
op_star
id|ce
comma
r_struct
id|stat
op_star
id|st
)paren
(brace
r_if
c_cond
(paren
id|S_ISGITLINK
c_func
(paren
id|ce-&gt;ce_mode
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|S_ISDIR
c_func
(paren
id|st-&gt;st_mode
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|ce_match_stat
c_func
(paren
id|ce
comma
id|st
comma
id|CE_MATCH_IGNORE_VALID
op_or
id|CE_MATCH_IGNORE_SKIP_WORKTREE
)paren
suffix:semicolon
)brace
DECL|macro|SUBMODULE_PATCH_WITHOUT_INDEX
mdefine_line|#define SUBMODULE_PATCH_WITHOUT_INDEX 1
DECL|function|load_patch_target
r_static
r_int
id|load_patch_target
c_func
(paren
r_struct
id|strbuf
op_star
id|buf
comma
r_const
r_struct
id|cache_entry
op_star
id|ce
comma
r_struct
id|stat
op_star
id|st
comma
r_const
r_char
op_star
id|name
comma
r_int
id|expected_mode
)paren
(brace
r_if
c_cond
(paren
id|cached
)paren
(brace
r_if
c_cond
(paren
id|read_file_or_gitlink
c_func
(paren
id|ce
comma
id|buf
)paren
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;read of %s failed&quot;
)paren
comma
id|name
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|name
)paren
(brace
r_if
c_cond
(paren
id|S_ISGITLINK
c_func
(paren
id|expected_mode
)paren
)paren
(brace
r_if
c_cond
(paren
id|ce
)paren
r_return
id|read_file_or_gitlink
c_func
(paren
id|ce
comma
id|buf
)paren
suffix:semicolon
r_else
r_return
id|SUBMODULE_PATCH_WITHOUT_INDEX
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|read_old_data
c_func
(paren
id|st
comma
id|name
comma
id|buf
)paren
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;read of %s failed&quot;
)paren
comma
id|name
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * We are about to apply &quot;patch&quot;; populate the &quot;image&quot; with the&n; * current version we have, from the working tree or from the index,&n; * depending on the situation e.g. --cached/--index.  If we are&n; * applying a non-git patch that incrementally updates the tree,&n; * we read from the result of a previous diff.&n; */
DECL|function|load_preimage
r_static
r_int
id|load_preimage
c_func
(paren
r_struct
id|image
op_star
id|image
comma
r_struct
id|patch
op_star
id|patch
comma
r_struct
id|stat
op_star
id|st
comma
r_const
r_struct
id|cache_entry
op_star
id|ce
)paren
(brace
r_struct
id|strbuf
id|buf
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|len
suffix:semicolon
r_char
op_star
id|img
suffix:semicolon
r_struct
id|patch
op_star
id|previous
suffix:semicolon
r_int
id|status
suffix:semicolon
id|previous
op_assign
id|previous_patch
c_func
(paren
id|patch
comma
op_amp
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;path %s has been renamed/deleted&quot;
)paren
comma
id|patch-&gt;old_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|previous
)paren
(brace
multiline_comment|/* We have a patched copy in memory; use that. */
id|strbuf_add
c_func
(paren
op_amp
id|buf
comma
id|previous-&gt;result
comma
id|previous-&gt;resultsize
)paren
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
id|load_patch_target
c_func
(paren
op_amp
id|buf
comma
id|ce
comma
id|st
comma
id|patch-&gt;old_name
comma
id|patch-&gt;old_mode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
r_return
id|status
suffix:semicolon
r_else
r_if
c_cond
(paren
id|status
op_eq
id|SUBMODULE_PATCH_WITHOUT_INDEX
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * There is no way to apply subproject&n;&t;&t;&t; * patch without looking at the index.&n;&t;&t;&t; * NEEDSWORK: shouldn&squot;t this be flagged&n;&t;&t;&t; * as an error???&n;&t;&t;&t; */
id|free_fragment_list
c_func
(paren
id|patch-&gt;fragments
)paren
suffix:semicolon
id|patch-&gt;fragments
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|status
)paren
(brace
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;read of %s failed&quot;
)paren
comma
id|patch-&gt;old_name
)paren
suffix:semicolon
)brace
)brace
id|img
op_assign
id|strbuf_detach
c_func
(paren
op_amp
id|buf
comma
op_amp
id|len
)paren
suffix:semicolon
id|prepare_image
c_func
(paren
id|image
comma
id|img
comma
id|len
comma
op_logical_neg
id|patch-&gt;is_binary
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|three_way_merge
r_static
r_int
id|three_way_merge
c_func
(paren
r_struct
id|image
op_star
id|image
comma
r_char
op_star
id|path
comma
r_const
r_int
r_char
op_star
id|base
comma
r_const
r_int
r_char
op_star
id|ours
comma
r_const
r_int
r_char
op_star
id|theirs
)paren
(brace
id|mmfile_t
id|base_file
comma
id|our_file
comma
id|their_file
suffix:semicolon
id|mmbuffer_t
id|result
op_assign
(brace
l_int|NULL
)brace
suffix:semicolon
r_int
id|status
suffix:semicolon
id|read_mmblob
c_func
(paren
op_amp
id|base_file
comma
id|base
)paren
suffix:semicolon
id|read_mmblob
c_func
(paren
op_amp
id|our_file
comma
id|ours
)paren
suffix:semicolon
id|read_mmblob
c_func
(paren
op_amp
id|their_file
comma
id|theirs
)paren
suffix:semicolon
id|status
op_assign
id|ll_merge
c_func
(paren
op_amp
id|result
comma
id|path
comma
op_amp
id|base_file
comma
l_string|&quot;base&quot;
comma
op_amp
id|our_file
comma
l_string|&quot;ours&quot;
comma
op_amp
id|their_file
comma
l_string|&quot;theirs&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|free
c_func
(paren
id|base_file.ptr
)paren
suffix:semicolon
id|free
c_func
(paren
id|our_file.ptr
)paren
suffix:semicolon
id|free
c_func
(paren
id|their_file.ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
op_logical_or
op_logical_neg
id|result.ptr
)paren
(brace
id|free
c_func
(paren
id|result.ptr
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|clear_image
c_func
(paren
id|image
)paren
suffix:semicolon
id|image-&gt;buf
op_assign
id|result.ptr
suffix:semicolon
id|image-&gt;len
op_assign
id|result.size
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n; * When directly falling back to add/add three-way merge, we read from&n; * the current contents of the new_name.  In no cases other than that&n; * this function will be called.&n; */
DECL|function|load_current
r_static
r_int
id|load_current
c_func
(paren
r_struct
id|image
op_star
id|image
comma
r_struct
id|patch
op_star
id|patch
)paren
(brace
r_struct
id|strbuf
id|buf
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|status
comma
id|pos
suffix:semicolon
r_int
id|len
suffix:semicolon
r_char
op_star
id|img
suffix:semicolon
r_struct
id|stat
id|st
suffix:semicolon
r_struct
id|cache_entry
op_star
id|ce
suffix:semicolon
r_char
op_star
id|name
op_assign
id|patch-&gt;new_name
suffix:semicolon
r_int
id|mode
op_assign
id|patch-&gt;new_mode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|patch-&gt;is_new
)paren
id|die
c_func
(paren
l_string|&quot;BUG: patch to %s is not a creation&quot;
comma
id|patch-&gt;old_name
)paren
suffix:semicolon
id|pos
op_assign
id|cache_name_pos
c_func
(paren
id|name
comma
id|strlen
c_func
(paren
id|name
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
l_int|0
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;%s: does not exist in index&quot;
)paren
comma
id|name
)paren
suffix:semicolon
id|ce
op_assign
id|active_cache
(braket
id|pos
)braket
suffix:semicolon
r_if
c_cond
(paren
id|lstat
c_func
(paren
id|name
comma
op_amp
id|st
)paren
)paren
(brace
r_if
c_cond
(paren
id|errno
op_ne
id|ENOENT
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;%s: %s&quot;
)paren
comma
id|name
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|checkout_target
c_func
(paren
id|ce
comma
op_amp
id|st
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|verify_index_match
c_func
(paren
id|ce
comma
op_amp
id|st
)paren
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;%s: does not match index&quot;
)paren
comma
id|name
)paren
suffix:semicolon
id|status
op_assign
id|load_patch_target
c_func
(paren
op_amp
id|buf
comma
id|ce
comma
op_amp
id|st
comma
id|name
comma
id|mode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
r_return
id|status
suffix:semicolon
r_else
r_if
c_cond
(paren
id|status
)paren
r_return
l_int|1
suffix:semicolon
id|img
op_assign
id|strbuf_detach
c_func
(paren
op_amp
id|buf
comma
op_amp
id|len
)paren
suffix:semicolon
id|prepare_image
c_func
(paren
id|image
comma
id|img
comma
id|len
comma
op_logical_neg
id|patch-&gt;is_binary
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|try_threeway
r_static
r_int
id|try_threeway
c_func
(paren
r_struct
id|image
op_star
id|image
comma
r_struct
id|patch
op_star
id|patch
comma
r_struct
id|stat
op_star
id|st
comma
r_const
r_struct
id|cache_entry
op_star
id|ce
)paren
(brace
r_int
r_char
id|pre_sha1
(braket
l_int|20
)braket
comma
id|post_sha1
(braket
l_int|20
)braket
comma
id|our_sha1
(braket
l_int|20
)braket
suffix:semicolon
r_struct
id|strbuf
id|buf
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|len
suffix:semicolon
r_int
id|status
suffix:semicolon
r_char
op_star
id|img
suffix:semicolon
r_struct
id|image
id|tmp_image
suffix:semicolon
multiline_comment|/* No point falling back to 3-way merge in these cases */
r_if
c_cond
(paren
id|patch-&gt;is_delete
op_logical_or
id|S_ISGITLINK
c_func
(paren
id|patch-&gt;old_mode
)paren
op_logical_or
id|S_ISGITLINK
c_func
(paren
id|patch-&gt;new_mode
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Preimage the patch was prepared for */
r_if
c_cond
(paren
id|patch-&gt;is_new
)paren
id|write_sha1_file
c_func
(paren
l_string|&quot;&quot;
comma
l_int|0
comma
id|blob_type
comma
id|pre_sha1
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|get_sha1
c_func
(paren
id|patch-&gt;old_sha1_prefix
comma
id|pre_sha1
)paren
op_logical_or
id|read_blob_object
c_func
(paren
op_amp
id|buf
comma
id|pre_sha1
comma
id|patch-&gt;old_mode
)paren
)paren
r_return
id|error
c_func
(paren
l_string|&quot;repository lacks the necessary blob to fall back on 3-way merge.&quot;
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Falling back to three-way merge...&bslash;n&quot;
)paren
suffix:semicolon
id|img
op_assign
id|strbuf_detach
c_func
(paren
op_amp
id|buf
comma
op_amp
id|len
)paren
suffix:semicolon
id|prepare_image
c_func
(paren
op_amp
id|tmp_image
comma
id|img
comma
id|len
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Apply the patch to get the post image */
r_if
c_cond
(paren
id|apply_fragments
c_func
(paren
op_amp
id|tmp_image
comma
id|patch
)paren
OL
l_int|0
)paren
(brace
id|clear_image
c_func
(paren
op_amp
id|tmp_image
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* post_sha1[] is theirs */
id|write_sha1_file
c_func
(paren
id|tmp_image.buf
comma
id|tmp_image.len
comma
id|blob_type
comma
id|post_sha1
)paren
suffix:semicolon
id|clear_image
c_func
(paren
op_amp
id|tmp_image
)paren
suffix:semicolon
multiline_comment|/* our_sha1[] is ours */
r_if
c_cond
(paren
id|patch-&gt;is_new
)paren
(brace
r_if
c_cond
(paren
id|load_current
c_func
(paren
op_amp
id|tmp_image
comma
id|patch
)paren
)paren
r_return
id|error
c_func
(paren
l_string|&quot;cannot read the current contents of &squot;%s&squot;&quot;
comma
id|patch-&gt;new_name
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|load_preimage
c_func
(paren
op_amp
id|tmp_image
comma
id|patch
comma
id|st
comma
id|ce
)paren
)paren
r_return
id|error
c_func
(paren
l_string|&quot;cannot read the current contents of &squot;%s&squot;&quot;
comma
id|patch-&gt;old_name
)paren
suffix:semicolon
)brace
id|write_sha1_file
c_func
(paren
id|tmp_image.buf
comma
id|tmp_image.len
comma
id|blob_type
comma
id|our_sha1
)paren
suffix:semicolon
id|clear_image
c_func
(paren
op_amp
id|tmp_image
)paren
suffix:semicolon
multiline_comment|/* in-core three-way merge between post and our using pre as base */
id|status
op_assign
id|three_way_merge
c_func
(paren
id|image
comma
id|patch-&gt;new_name
comma
id|pre_sha1
comma
id|our_sha1
comma
id|post_sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Failed to fall back on three-way merge...&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
)paren
(brace
id|patch-&gt;conflicted_threeway
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|patch-&gt;is_new
)paren
id|hashclr
c_func
(paren
id|patch-&gt;threeway_stage
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_else
id|hashcpy
c_func
(paren
id|patch-&gt;threeway_stage
(braket
l_int|0
)braket
comma
id|pre_sha1
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|patch-&gt;threeway_stage
(braket
l_int|1
)braket
comma
id|our_sha1
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|patch-&gt;threeway_stage
(braket
l_int|2
)braket
comma
id|post_sha1
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Applied patch to &squot;%s&squot; with conflicts.&bslash;n&quot;
comma
id|patch-&gt;new_name
)paren
suffix:semicolon
)brace
r_else
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Applied patch to &squot;%s&squot; cleanly.&bslash;n&quot;
comma
id|patch-&gt;new_name
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|apply_data
r_static
r_int
id|apply_data
c_func
(paren
r_struct
id|patch
op_star
id|patch
comma
r_struct
id|stat
op_star
id|st
comma
r_const
r_struct
id|cache_entry
op_star
id|ce
)paren
(brace
r_struct
id|image
id|image
suffix:semicolon
r_if
c_cond
(paren
id|load_preimage
c_func
(paren
op_amp
id|image
comma
id|patch
comma
id|st
comma
id|ce
)paren
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|patch-&gt;direct_to_threeway
op_logical_or
id|apply_fragments
c_func
(paren
op_amp
id|image
comma
id|patch
)paren
OL
l_int|0
)paren
(brace
multiline_comment|/* Note: with --reject, apply_fragments() returns 0 */
r_if
c_cond
(paren
op_logical_neg
id|threeway
op_logical_or
id|try_threeway
c_func
(paren
op_amp
id|image
comma
id|patch
comma
id|st
comma
id|ce
)paren
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
)brace
id|patch-&gt;result
op_assign
id|image.buf
suffix:semicolon
id|patch-&gt;resultsize
op_assign
id|image.len
suffix:semicolon
id|add_to_fn_table
c_func
(paren
id|patch
)paren
suffix:semicolon
id|free
c_func
(paren
id|image.line_allocated
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
OL
id|patch-&gt;is_delete
op_logical_and
id|patch-&gt;resultsize
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;removal patch leaves file contents&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * If &quot;patch&quot; that we are looking at modifies or deletes what we have,&n; * we would want it not to lose any local modification we have, either&n; * in the working tree or in the index.&n; *&n; * This also decides if a non-git patch is a creation patch or a&n; * modification to an existing empty file.  We do not check the state&n; * of the current tree for a creation patch in this function; the caller&n; * check_patch() separately makes sure (and errors out otherwise) that&n; * the path the patch creates does not exist in the current tree.&n; */
DECL|function|check_preimage
r_static
r_int
id|check_preimage
c_func
(paren
r_struct
id|patch
op_star
id|patch
comma
r_struct
id|cache_entry
op_star
op_star
id|ce
comma
r_struct
id|stat
op_star
id|st
)paren
(brace
r_const
r_char
op_star
id|old_name
op_assign
id|patch-&gt;old_name
suffix:semicolon
r_struct
id|patch
op_star
id|previous
op_assign
l_int|NULL
suffix:semicolon
r_int
id|stat_ret
op_assign
l_int|0
comma
id|status
suffix:semicolon
r_int
id|st_mode
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|old_name
)paren
r_return
l_int|0
suffix:semicolon
m_assert
(paren
id|patch-&gt;is_new
op_le
l_int|0
)paren
suffix:semicolon
id|previous
op_assign
id|previous_patch
c_func
(paren
id|patch
comma
op_amp
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;path %s has been renamed/deleted&quot;
)paren
comma
id|old_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|previous
)paren
(brace
id|st_mode
op_assign
id|previous-&gt;new_mode
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|cached
)paren
(brace
id|stat_ret
op_assign
id|lstat
c_func
(paren
id|old_name
comma
id|st
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat_ret
op_logical_and
id|errno
op_ne
id|ENOENT
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;%s: %s&quot;
)paren
comma
id|old_name
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|check_index
op_logical_and
op_logical_neg
id|previous
)paren
(brace
r_int
id|pos
op_assign
id|cache_name_pos
c_func
(paren
id|old_name
comma
id|strlen
c_func
(paren
id|old_name
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|patch-&gt;is_new
OL
l_int|0
)paren
r_goto
id|is_new
suffix:semicolon
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;%s: does not exist in index&quot;
)paren
comma
id|old_name
)paren
suffix:semicolon
)brace
op_star
id|ce
op_assign
id|active_cache
(braket
id|pos
)braket
suffix:semicolon
r_if
c_cond
(paren
id|stat_ret
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|checkout_target
c_func
(paren
op_star
id|ce
comma
id|st
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|cached
op_logical_and
id|verify_index_match
c_func
(paren
op_star
id|ce
comma
id|st
)paren
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;%s: does not match index&quot;
)paren
comma
id|old_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cached
)paren
id|st_mode
op_assign
(paren
op_star
id|ce
)paren
op_member_access_from_pointer
id|ce_mode
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|stat_ret
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|patch-&gt;is_new
OL
l_int|0
)paren
r_goto
id|is_new
suffix:semicolon
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;%s: %s&quot;
)paren
comma
id|old_name
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|cached
op_logical_and
op_logical_neg
id|previous
)paren
id|st_mode
op_assign
id|ce_mode_from_stat
c_func
(paren
op_star
id|ce
comma
id|st-&gt;st_mode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|patch-&gt;is_new
OL
l_int|0
)paren
id|patch-&gt;is_new
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|patch-&gt;old_mode
)paren
id|patch-&gt;old_mode
op_assign
id|st_mode
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st_mode
op_xor
id|patch-&gt;old_mode
)paren
op_amp
id|S_IFMT
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;%s: wrong type&quot;
)paren
comma
id|old_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st_mode
op_ne
id|patch-&gt;old_mode
)paren
id|warning
c_func
(paren
id|_
c_func
(paren
l_string|&quot;%s has type %o, expected %o&quot;
)paren
comma
id|old_name
comma
id|st_mode
comma
id|patch-&gt;old_mode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|patch-&gt;new_mode
op_logical_and
op_logical_neg
id|patch-&gt;is_delete
)paren
id|patch-&gt;new_mode
op_assign
id|st_mode
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|is_new
suffix:colon
id|patch-&gt;is_new
op_assign
l_int|1
suffix:semicolon
id|patch-&gt;is_delete
op_assign
l_int|0
suffix:semicolon
id|free
c_func
(paren
id|patch-&gt;old_name
)paren
suffix:semicolon
id|patch-&gt;old_name
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|EXISTS_IN_INDEX
mdefine_line|#define EXISTS_IN_INDEX 1
DECL|macro|EXISTS_IN_WORKTREE
mdefine_line|#define EXISTS_IN_WORKTREE 2
DECL|function|check_to_create
r_static
r_int
id|check_to_create
c_func
(paren
r_const
r_char
op_star
id|new_name
comma
r_int
id|ok_if_exists
)paren
(brace
r_struct
id|stat
id|nst
suffix:semicolon
r_if
c_cond
(paren
id|check_index
op_logical_and
id|cache_name_pos
c_func
(paren
id|new_name
comma
id|strlen
c_func
(paren
id|new_name
)paren
)paren
op_ge
l_int|0
op_logical_and
op_logical_neg
id|ok_if_exists
)paren
r_return
id|EXISTS_IN_INDEX
suffix:semicolon
r_if
c_cond
(paren
id|cached
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lstat
c_func
(paren
id|new_name
comma
op_amp
id|nst
)paren
)paren
(brace
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|nst.st_mode
)paren
op_logical_or
id|ok_if_exists
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * A leading component of new_name might be a symlink&n;&t;&t; * that is going to be removed with this patch, but&n;&t;&t; * still pointing at somewhere that has the path.&n;&t;&t; * In such a case, path &quot;new_name&quot; does not exist as&n;&t;&t; * far as git is concerned.&n;&t;&t; */
r_if
c_cond
(paren
id|has_symlink_leading_path
c_func
(paren
id|new_name
comma
id|strlen
c_func
(paren
id|new_name
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|EXISTS_IN_WORKTREE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|errno
op_ne
id|ENOENT
)paren
op_logical_and
(paren
id|errno
op_ne
id|ENOTDIR
)paren
)paren
(brace
r_return
id|error
c_func
(paren
l_string|&quot;%s: %s&quot;
comma
id|new_name
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Check and apply the patch in-core; leave the result in patch-&gt;result&n; * for the caller to write it out to the final destination.&n; */
DECL|function|check_patch
r_static
r_int
id|check_patch
c_func
(paren
r_struct
id|patch
op_star
id|patch
)paren
(brace
r_struct
id|stat
id|st
suffix:semicolon
r_const
r_char
op_star
id|old_name
op_assign
id|patch-&gt;old_name
suffix:semicolon
r_const
r_char
op_star
id|new_name
op_assign
id|patch-&gt;new_name
suffix:semicolon
r_const
r_char
op_star
id|name
op_assign
id|old_name
ques
c_cond
id|old_name
suffix:colon
id|new_name
suffix:semicolon
r_struct
id|cache_entry
op_star
id|ce
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|patch
op_star
id|tpatch
suffix:semicolon
r_int
id|ok_if_exists
suffix:semicolon
r_int
id|status
suffix:semicolon
id|patch-&gt;rejected
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* we will drop this after we succeed */
id|status
op_assign
id|check_preimage
c_func
(paren
id|patch
comma
op_amp
id|ce
comma
op_amp
id|st
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
r_return
id|status
suffix:semicolon
id|old_name
op_assign
id|patch-&gt;old_name
suffix:semicolon
multiline_comment|/*&n;&t; * A type-change diff is always split into a patch to delete&n;&t; * old, immediately followed by a patch to create new (see&n;&t; * diff.c::run_diff()); in such a case it is Ok that the entry&n;&t; * to be deleted by the previous patch is still in the working&n;&t; * tree and in the index.&n;&t; *&n;&t; * A patch to swap-rename between A and B would first rename A&n;&t; * to B and then rename B to A.  While applying the first one,&n;&t; * the presence of B should not stop A from getting renamed to&n;&t; * B; ask to_be_deleted() about the later rename.  Removal of&n;&t; * B and rename from A to B is handled the same way by asking&n;&t; * was_deleted().&n;&t; */
r_if
c_cond
(paren
(paren
id|tpatch
op_assign
id|in_fn_table
c_func
(paren
id|new_name
)paren
)paren
op_logical_and
(paren
id|was_deleted
c_func
(paren
id|tpatch
)paren
op_logical_or
id|to_be_deleted
c_func
(paren
id|tpatch
)paren
)paren
)paren
id|ok_if_exists
op_assign
l_int|1
suffix:semicolon
r_else
id|ok_if_exists
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|new_name
op_logical_and
(paren
(paren
l_int|0
OL
id|patch-&gt;is_new
)paren
op_logical_or
id|patch-&gt;is_rename
op_logical_or
id|patch-&gt;is_copy
)paren
)paren
(brace
r_int
id|err
op_assign
id|check_to_create
c_func
(paren
id|new_name
comma
id|ok_if_exists
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_logical_and
id|threeway
)paren
(brace
id|patch-&gt;direct_to_threeway
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_switch
c_cond
(paren
id|err
)paren
(brace
r_case
l_int|0
suffix:colon
r_break
suffix:semicolon
multiline_comment|/* happy */
r_case
id|EXISTS_IN_INDEX
suffix:colon
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;%s: already exists in index&quot;
)paren
comma
id|new_name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EXISTS_IN_WORKTREE
suffix:colon
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;%s: already exists in working directory&quot;
)paren
comma
id|new_name
)paren
suffix:semicolon
r_default
suffix:colon
r_return
id|err
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|patch-&gt;new_mode
)paren
(brace
r_if
c_cond
(paren
l_int|0
OL
id|patch-&gt;is_new
)paren
id|patch-&gt;new_mode
op_assign
id|S_IFREG
op_or
l_int|0644
suffix:semicolon
r_else
id|patch-&gt;new_mode
op_assign
id|patch-&gt;old_mode
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|new_name
op_logical_and
id|old_name
)paren
(brace
r_int
id|same
op_assign
op_logical_neg
id|strcmp
c_func
(paren
id|old_name
comma
id|new_name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|patch-&gt;new_mode
)paren
id|patch-&gt;new_mode
op_assign
id|patch-&gt;old_mode
suffix:semicolon
r_if
c_cond
(paren
(paren
id|patch-&gt;old_mode
op_xor
id|patch-&gt;new_mode
)paren
op_amp
id|S_IFMT
)paren
(brace
r_if
c_cond
(paren
id|same
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;new mode (%o) of %s does not &quot;
l_string|&quot;match old mode (%o)&quot;
)paren
comma
id|patch-&gt;new_mode
comma
id|new_name
comma
id|patch-&gt;old_mode
)paren
suffix:semicolon
r_else
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;new mode (%o) of %s does not &quot;
l_string|&quot;match old mode (%o) of %s&quot;
)paren
comma
id|patch-&gt;new_mode
comma
id|new_name
comma
id|patch-&gt;old_mode
comma
id|old_name
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|apply_data
c_func
(paren
id|patch
comma
op_amp
id|st
comma
id|ce
)paren
OL
l_int|0
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;%s: patch does not apply&quot;
)paren
comma
id|name
)paren
suffix:semicolon
id|patch-&gt;rejected
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|check_patch_list
r_static
r_int
id|check_patch_list
c_func
(paren
r_struct
id|patch
op_star
id|patch
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|prepare_fn_table
c_func
(paren
id|patch
)paren
suffix:semicolon
r_while
c_loop
(paren
id|patch
)paren
(brace
r_if
c_cond
(paren
id|apply_verbosely
)paren
id|say_patch_name
c_func
(paren
id|stderr
comma
id|_
c_func
(paren
l_string|&quot;Checking patch %s...&quot;
)paren
comma
id|patch
)paren
suffix:semicolon
id|err
op_or_assign
id|check_patch
c_func
(paren
id|patch
)paren
suffix:semicolon
id|patch
op_assign
id|patch-&gt;next
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* This function tries to read the sha1 from the current index */
DECL|function|get_current_sha1
r_static
r_int
id|get_current_sha1
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_int
r_char
op_star
id|sha1
)paren
(brace
r_int
id|pos
suffix:semicolon
r_if
c_cond
(paren
id|read_cache
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
id|pos
op_assign
id|cache_name_pos
c_func
(paren
id|path
comma
id|strlen
c_func
(paren
id|path
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
id|hashcpy
c_func
(paren
id|sha1
comma
id|active_cache
(braket
id|pos
)braket
op_member_access_from_pointer
id|sha1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|preimage_sha1_in_gitlink_patch
r_static
r_int
id|preimage_sha1_in_gitlink_patch
c_func
(paren
r_struct
id|patch
op_star
id|p
comma
r_int
r_char
id|sha1
(braket
l_int|20
)braket
)paren
(brace
multiline_comment|/*&n;&t; * A usable gitlink patch has only one fragment (hunk) that looks like:&n;&t; * @@ -1 +1 @@&n;&t; * -Subproject commit &lt;old sha1&gt;&n;&t; * +Subproject commit &lt;new sha1&gt;&n;&t; * or&n;&t; * @@ -1 +0,0 @@&n;&t; * -Subproject commit &lt;old sha1&gt;&n;&t; * for a removal patch.&n;&t; */
r_struct
id|fragment
op_star
id|hunk
op_assign
id|p-&gt;fragments
suffix:semicolon
r_static
r_const
r_char
id|heading
(braket
)braket
op_assign
l_string|&quot;-Subproject commit &quot;
suffix:semicolon
r_char
op_star
id|preimage
suffix:semicolon
r_if
c_cond
(paren
multiline_comment|/* does the patch have only one hunk? */
id|hunk
op_logical_and
op_logical_neg
id|hunk-&gt;next
op_logical_and
multiline_comment|/* is its preimage one line? */
id|hunk-&gt;oldpos
op_eq
l_int|1
op_logical_and
id|hunk-&gt;oldlines
op_eq
l_int|1
op_logical_and
multiline_comment|/* does preimage begin with the heading? */
(paren
id|preimage
op_assign
id|memchr
c_func
(paren
id|hunk-&gt;patch
comma
l_char|&squot;&bslash;n&squot;
comma
id|hunk-&gt;size
)paren
)paren
op_ne
l_int|NULL
op_logical_and
id|starts_with
c_func
(paren
op_increment
id|preimage
comma
id|heading
)paren
op_logical_and
multiline_comment|/* does it record full SHA-1? */
op_logical_neg
id|get_sha1_hex
c_func
(paren
id|preimage
op_plus
r_sizeof
(paren
id|heading
)paren
l_int|1
comma
id|sha1
)paren
op_logical_and
id|preimage
(braket
r_sizeof
(paren
id|heading
)paren
op_plus
l_int|40
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
op_logical_and
multiline_comment|/* does the abbreviated name on the index line agree with it? */
id|starts_with
c_func
(paren
id|preimage
op_plus
r_sizeof
(paren
id|heading
)paren
l_int|1
comma
id|p-&gt;old_sha1_prefix
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* it all looks fine */
multiline_comment|/* we may have full object name on the index line */
r_return
id|get_sha1_hex
c_func
(paren
id|p-&gt;old_sha1_prefix
comma
id|sha1
)paren
suffix:semicolon
)brace
multiline_comment|/* Build an index that contains the just the files needed for a 3way merge */
DECL|function|build_fake_ancestor
r_static
r_void
id|build_fake_ancestor
c_func
(paren
r_struct
id|patch
op_star
id|list
comma
r_const
r_char
op_star
id|filename
)paren
(brace
r_struct
id|patch
op_star
id|patch
suffix:semicolon
r_struct
id|index_state
id|result
op_assign
(brace
l_int|NULL
)brace
suffix:semicolon
r_int
id|fd
suffix:semicolon
multiline_comment|/* Once we start supporting the reverse patch, it may be&n;&t; * worth showing the new sha1 prefix, but until then...&n;&t; */
r_for
c_loop
(paren
id|patch
op_assign
id|list
suffix:semicolon
id|patch
suffix:semicolon
id|patch
op_assign
id|patch-&gt;next
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_struct
id|cache_entry
op_star
id|ce
suffix:semicolon
r_const
r_char
op_star
id|name
suffix:semicolon
id|name
op_assign
id|patch-&gt;old_name
ques
c_cond
id|patch-&gt;old_name
suffix:colon
id|patch-&gt;new_name
suffix:semicolon
r_if
c_cond
(paren
l_int|0
OL
id|patch-&gt;is_new
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|S_ISGITLINK
c_func
(paren
id|patch-&gt;old_mode
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|preimage_sha1_in_gitlink_patch
c_func
(paren
id|patch
comma
id|sha1
)paren
)paren
suffix:semicolon
multiline_comment|/* ok, the textual part looks sane */
r_else
id|die
c_func
(paren
l_string|&quot;sha1 information is lacking or useless for submoule %s&quot;
comma
id|name
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|get_sha1_blob
c_func
(paren
id|patch-&gt;old_sha1_prefix
comma
id|sha1
)paren
)paren
(brace
suffix:semicolon
multiline_comment|/* ok */
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|patch-&gt;lines_added
op_logical_and
op_logical_neg
id|patch-&gt;lines_deleted
)paren
(brace
multiline_comment|/* mode-only change: update the current */
r_if
c_cond
(paren
id|get_current_sha1
c_func
(paren
id|patch-&gt;old_name
comma
id|sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;mode change for %s, which is not &quot;
l_string|&quot;in current HEAD&quot;
comma
id|name
)paren
suffix:semicolon
)brace
r_else
id|die
c_func
(paren
l_string|&quot;sha1 information is lacking or useless &quot;
l_string|&quot;(%s).&quot;
comma
id|name
)paren
suffix:semicolon
id|ce
op_assign
id|make_cache_entry
c_func
(paren
id|patch-&gt;old_mode
comma
id|sha1
comma
id|name
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ce
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;make_cache_entry failed for path &squot;%s&squot;&quot;
)paren
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|add_index_entry
c_func
(paren
op_amp
id|result
comma
id|ce
comma
id|ADD_CACHE_OK_TO_ADD
)paren
)paren
id|die
(paren
l_string|&quot;Could not add %s to temporary index&quot;
comma
id|name
)paren
suffix:semicolon
)brace
id|fd
op_assign
id|open
c_func
(paren
id|filename
comma
id|O_WRONLY
op_or
id|O_CREAT
comma
l_int|0666
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
op_logical_or
id|write_index
c_func
(paren
op_amp
id|result
comma
id|fd
)paren
op_logical_or
id|close
c_func
(paren
id|fd
)paren
)paren
id|die
(paren
l_string|&quot;Could not write temporary index to %s&quot;
comma
id|filename
)paren
suffix:semicolon
id|discard_index
c_func
(paren
op_amp
id|result
)paren
suffix:semicolon
)brace
DECL|function|stat_patch_list
r_static
r_void
id|stat_patch_list
c_func
(paren
r_struct
id|patch
op_star
id|patch
)paren
(brace
r_int
id|files
comma
id|adds
comma
id|dels
suffix:semicolon
r_for
c_loop
(paren
id|files
op_assign
id|adds
op_assign
id|dels
op_assign
l_int|0
suffix:semicolon
id|patch
suffix:semicolon
id|patch
op_assign
id|patch-&gt;next
)paren
(brace
id|files
op_increment
suffix:semicolon
id|adds
op_add_assign
id|patch-&gt;lines_added
suffix:semicolon
id|dels
op_add_assign
id|patch-&gt;lines_deleted
suffix:semicolon
id|show_stats
c_func
(paren
id|patch
)paren
suffix:semicolon
)brace
id|print_stat_summary
c_func
(paren
id|stdout
comma
id|files
comma
id|adds
comma
id|dels
)paren
suffix:semicolon
)brace
DECL|function|numstat_patch_list
r_static
r_void
id|numstat_patch_list
c_func
(paren
r_struct
id|patch
op_star
id|patch
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|patch
suffix:semicolon
id|patch
op_assign
id|patch-&gt;next
)paren
(brace
r_const
r_char
op_star
id|name
suffix:semicolon
id|name
op_assign
id|patch-&gt;new_name
ques
c_cond
id|patch-&gt;new_name
suffix:colon
id|patch-&gt;old_name
suffix:semicolon
r_if
c_cond
(paren
id|patch-&gt;is_binary
)paren
id|printf
c_func
(paren
l_string|&quot;-&bslash;t-&bslash;t&quot;
)paren
suffix:semicolon
r_else
id|printf
c_func
(paren
l_string|&quot;%d&bslash;t%d&bslash;t&quot;
comma
id|patch-&gt;lines_added
comma
id|patch-&gt;lines_deleted
)paren
suffix:semicolon
id|write_name_quoted
c_func
(paren
id|name
comma
id|stdout
comma
id|line_termination
)paren
suffix:semicolon
)brace
)brace
DECL|function|show_file_mode_name
r_static
r_void
id|show_file_mode_name
c_func
(paren
r_const
r_char
op_star
id|newdelete
comma
r_int
r_int
id|mode
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_if
c_cond
(paren
id|mode
)paren
id|printf
c_func
(paren
l_string|&quot; %s mode %06o %s&bslash;n&quot;
comma
id|newdelete
comma
id|mode
comma
id|name
)paren
suffix:semicolon
r_else
id|printf
c_func
(paren
l_string|&quot; %s %s&bslash;n&quot;
comma
id|newdelete
comma
id|name
)paren
suffix:semicolon
)brace
DECL|function|show_mode_change
r_static
r_void
id|show_mode_change
c_func
(paren
r_struct
id|patch
op_star
id|p
comma
r_int
id|show_name
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;old_mode
op_logical_and
id|p-&gt;new_mode
op_logical_and
id|p-&gt;old_mode
op_ne
id|p-&gt;new_mode
)paren
(brace
r_if
c_cond
(paren
id|show_name
)paren
id|printf
c_func
(paren
l_string|&quot; mode change %06o =&gt; %06o %s&bslash;n&quot;
comma
id|p-&gt;old_mode
comma
id|p-&gt;new_mode
comma
id|p-&gt;new_name
)paren
suffix:semicolon
r_else
id|printf
c_func
(paren
l_string|&quot; mode change %06o =&gt; %06o&bslash;n&quot;
comma
id|p-&gt;old_mode
comma
id|p-&gt;new_mode
)paren
suffix:semicolon
)brace
)brace
DECL|function|show_rename_copy
r_static
r_void
id|show_rename_copy
c_func
(paren
r_struct
id|patch
op_star
id|p
)paren
(brace
r_const
r_char
op_star
id|renamecopy
op_assign
id|p-&gt;is_rename
ques
c_cond
l_string|&quot;rename&quot;
suffix:colon
l_string|&quot;copy&quot;
suffix:semicolon
r_const
r_char
op_star
id|old
comma
op_star
r_new
suffix:semicolon
multiline_comment|/* Find common prefix */
id|old
op_assign
id|p-&gt;old_name
suffix:semicolon
r_new
op_assign
id|p-&gt;new_name
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_const
r_char
op_star
id|slash_old
comma
op_star
id|slash_new
suffix:semicolon
id|slash_old
op_assign
id|strchr
c_func
(paren
id|old
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
id|slash_new
op_assign
id|strchr
c_func
(paren
r_new
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|slash_old
op_logical_or
op_logical_neg
id|slash_new
op_logical_or
id|slash_old
id|old
op_ne
id|slash_new
r_new
op_logical_or
id|memcmp
c_func
(paren
id|old
comma
r_new
comma
id|slash_new
r_new
)paren
)paren
r_break
suffix:semicolon
id|old
op_assign
id|slash_old
op_plus
l_int|1
suffix:semicolon
r_new
op_assign
id|slash_new
op_plus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* p-&gt;old_name thru old is the common prefix, and old and new&n;&t; * through the end of names are renames&n;&t; */
r_if
c_cond
(paren
id|old
op_ne
id|p-&gt;old_name
)paren
id|printf
c_func
(paren
l_string|&quot; %s %.*s{%s =&gt; %s} (%d%%)&bslash;n&quot;
comma
id|renamecopy
comma
(paren
r_int
)paren
(paren
id|old
id|p-&gt;old_name
)paren
comma
id|p-&gt;old_name
comma
id|old
comma
r_new
comma
id|p-&gt;score
)paren
suffix:semicolon
r_else
id|printf
c_func
(paren
l_string|&quot; %s %s =&gt; %s (%d%%)&bslash;n&quot;
comma
id|renamecopy
comma
id|p-&gt;old_name
comma
id|p-&gt;new_name
comma
id|p-&gt;score
)paren
suffix:semicolon
id|show_mode_change
c_func
(paren
id|p
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|summary_patch_list
r_static
r_void
id|summary_patch_list
c_func
(paren
r_struct
id|patch
op_star
id|patch
)paren
(brace
r_struct
id|patch
op_star
id|p
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|patch
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;is_new
)paren
id|show_file_mode_name
c_func
(paren
l_string|&quot;create&quot;
comma
id|p-&gt;new_mode
comma
id|p-&gt;new_name
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|p-&gt;is_delete
)paren
id|show_file_mode_name
c_func
(paren
l_string|&quot;delete&quot;
comma
id|p-&gt;old_mode
comma
id|p-&gt;old_name
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|p-&gt;is_rename
op_logical_or
id|p-&gt;is_copy
)paren
id|show_rename_copy
c_func
(paren
id|p
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|p-&gt;score
)paren
(brace
id|printf
c_func
(paren
l_string|&quot; rewrite %s (%d%%)&bslash;n&quot;
comma
id|p-&gt;new_name
comma
id|p-&gt;score
)paren
suffix:semicolon
id|show_mode_change
c_func
(paren
id|p
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
id|show_mode_change
c_func
(paren
id|p
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
DECL|function|patch_stats
r_static
r_void
id|patch_stats
c_func
(paren
r_struct
id|patch
op_star
id|patch
)paren
(brace
r_int
id|lines
op_assign
id|patch-&gt;lines_added
op_plus
id|patch-&gt;lines_deleted
suffix:semicolon
r_if
c_cond
(paren
id|lines
OG
id|max_change
)paren
id|max_change
op_assign
id|lines
suffix:semicolon
r_if
c_cond
(paren
id|patch-&gt;old_name
)paren
(brace
r_int
id|len
op_assign
id|quote_c_style
c_func
(paren
id|patch-&gt;old_name
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
id|len
op_assign
id|strlen
c_func
(paren
id|patch-&gt;old_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|max_len
)paren
id|max_len
op_assign
id|len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|patch-&gt;new_name
)paren
(brace
r_int
id|len
op_assign
id|quote_c_style
c_func
(paren
id|patch-&gt;new_name
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
id|len
op_assign
id|strlen
c_func
(paren
id|patch-&gt;new_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|max_len
)paren
id|max_len
op_assign
id|len
suffix:semicolon
)brace
)brace
DECL|function|remove_file
r_static
r_void
id|remove_file
c_func
(paren
r_struct
id|patch
op_star
id|patch
comma
r_int
id|rmdir_empty
)paren
(brace
r_if
c_cond
(paren
id|update_index
)paren
(brace
r_if
c_cond
(paren
id|remove_file_from_cache
c_func
(paren
id|patch-&gt;old_name
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;unable to remove %s from index&quot;
)paren
comma
id|patch-&gt;old_name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|cached
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|remove_or_warn
c_func
(paren
id|patch-&gt;old_mode
comma
id|patch-&gt;old_name
)paren
op_logical_and
id|rmdir_empty
)paren
(brace
id|remove_path
c_func
(paren
id|patch-&gt;old_name
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|add_index_file
r_static
r_void
id|add_index_file
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_int
id|mode
comma
r_void
op_star
id|buf
comma
r_int
r_int
id|size
)paren
(brace
r_struct
id|stat
id|st
suffix:semicolon
r_struct
id|cache_entry
op_star
id|ce
suffix:semicolon
r_int
id|namelen
op_assign
id|strlen
c_func
(paren
id|path
)paren
suffix:semicolon
r_int
id|ce_size
op_assign
id|cache_entry_size
c_func
(paren
id|namelen
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|update_index
)paren
r_return
suffix:semicolon
id|ce
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
id|ce_size
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ce-&gt;name
comma
id|path
comma
id|namelen
)paren
suffix:semicolon
id|ce-&gt;ce_mode
op_assign
id|create_ce_mode
c_func
(paren
id|mode
)paren
suffix:semicolon
id|ce-&gt;ce_flags
op_assign
id|create_ce_flags
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|ce-&gt;ce_namelen
op_assign
id|namelen
suffix:semicolon
r_if
c_cond
(paren
id|S_ISGITLINK
c_func
(paren
id|mode
)paren
)paren
(brace
r_const
r_char
op_star
id|s
op_assign
id|buf
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|s
op_plus
id|strlen
c_func
(paren
l_string|&quot;Subproject commit &quot;
)paren
comma
id|ce-&gt;sha1
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;corrupt patch for submodule %s&quot;
)paren
comma
id|path
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|cached
)paren
(brace
r_if
c_cond
(paren
id|lstat
c_func
(paren
id|path
comma
op_amp
id|st
)paren
OL
l_int|0
)paren
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;unable to stat newly created file &squot;%s&squot;&quot;
)paren
comma
id|path
)paren
suffix:semicolon
id|fill_stat_cache_info
c_func
(paren
id|ce
comma
op_amp
id|st
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|write_sha1_file
c_func
(paren
id|buf
comma
id|size
comma
id|blob_type
comma
id|ce-&gt;sha1
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;unable to create backing store for newly created file %s&quot;
)paren
comma
id|path
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|add_cache_entry
c_func
(paren
id|ce
comma
id|ADD_CACHE_OK_TO_ADD
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;unable to add cache entry for %s&quot;
)paren
comma
id|path
)paren
suffix:semicolon
)brace
DECL|function|try_create_file
r_static
r_int
id|try_create_file
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_int
r_int
id|mode
comma
r_const
r_char
op_star
id|buf
comma
r_int
r_int
id|size
)paren
(brace
r_int
id|fd
suffix:semicolon
r_struct
id|strbuf
id|nbuf
op_assign
id|STRBUF_INIT
suffix:semicolon
r_if
c_cond
(paren
id|S_ISGITLINK
c_func
(paren
id|mode
)paren
)paren
(brace
r_struct
id|stat
id|st
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lstat
c_func
(paren
id|path
comma
op_amp
id|st
)paren
op_logical_and
id|S_ISDIR
c_func
(paren
id|st.st_mode
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|mkdir
c_func
(paren
id|path
comma
l_int|0777
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|has_symlinks
op_logical_and
id|S_ISLNK
c_func
(paren
id|mode
)paren
)paren
multiline_comment|/* Although buf:size is counted string, it also is NUL&n;&t;&t; * terminated.&n;&t;&t; */
r_return
id|symlink
c_func
(paren
id|buf
comma
id|path
)paren
suffix:semicolon
id|fd
op_assign
id|open
c_func
(paren
id|path
comma
id|O_CREAT
op_or
id|O_EXCL
op_or
id|O_WRONLY
comma
(paren
id|mode
op_amp
l_int|0100
)paren
ques
c_cond
l_int|0777
suffix:colon
l_int|0666
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|convert_to_working_tree
c_func
(paren
id|path
comma
id|buf
comma
id|size
comma
op_amp
id|nbuf
)paren
)paren
(brace
id|size
op_assign
id|nbuf.len
suffix:semicolon
id|buf
op_assign
id|nbuf.buf
suffix:semicolon
)brace
id|write_or_die
c_func
(paren
id|fd
comma
id|buf
comma
id|size
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|nbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|close
c_func
(paren
id|fd
)paren
OL
l_int|0
)paren
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;closing file &squot;%s&squot;&quot;
)paren
comma
id|path
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * We optimistically assume that the directories exist,&n; * which is true 99% of the time anyway. If they don&squot;t,&n; * we create them and try again.&n; */
DECL|function|create_one_file
r_static
r_void
id|create_one_file
c_func
(paren
r_char
op_star
id|path
comma
r_int
id|mode
comma
r_const
r_char
op_star
id|buf
comma
r_int
r_int
id|size
)paren
(brace
r_if
c_cond
(paren
id|cached
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|try_create_file
c_func
(paren
id|path
comma
id|mode
comma
id|buf
comma
id|size
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|errno
op_eq
id|ENOENT
)paren
(brace
r_if
c_cond
(paren
id|safe_create_leading_directories
c_func
(paren
id|path
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|try_create_file
c_func
(paren
id|path
comma
id|mode
comma
id|buf
comma
id|size
)paren
)paren
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|errno
op_eq
id|EEXIST
op_logical_or
id|errno
op_eq
id|EACCES
)paren
(brace
multiline_comment|/* We may be trying to create a file where a directory&n;&t;&t; * used to be.&n;&t;&t; */
r_struct
id|stat
id|st
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lstat
c_func
(paren
id|path
comma
op_amp
id|st
)paren
op_logical_and
(paren
op_logical_neg
id|S_ISDIR
c_func
(paren
id|st.st_mode
)paren
op_logical_or
op_logical_neg
id|rmdir
c_func
(paren
id|path
)paren
)paren
)paren
id|errno
op_assign
id|EEXIST
suffix:semicolon
)brace
r_if
c_cond
(paren
id|errno
op_eq
id|EEXIST
)paren
(brace
r_int
r_int
id|nr
op_assign
id|getpid
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_char
id|newpath
(braket
id|PATH_MAX
)braket
suffix:semicolon
id|mksnpath
c_func
(paren
id|newpath
comma
r_sizeof
(paren
id|newpath
)paren
comma
l_string|&quot;%s~%u&quot;
comma
id|path
comma
id|nr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|try_create_file
c_func
(paren
id|newpath
comma
id|mode
comma
id|buf
comma
id|size
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|rename
c_func
(paren
id|newpath
comma
id|path
)paren
)paren
r_return
suffix:semicolon
id|unlink_or_warn
c_func
(paren
id|newpath
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|errno
op_ne
id|EEXIST
)paren
r_break
suffix:semicolon
op_increment
id|nr
suffix:semicolon
)brace
)brace
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;unable to write file &squot;%s&squot; mode %o&quot;
)paren
comma
id|path
comma
id|mode
)paren
suffix:semicolon
)brace
DECL|function|add_conflicted_stages_file
r_static
r_void
id|add_conflicted_stages_file
c_func
(paren
r_struct
id|patch
op_star
id|patch
)paren
(brace
r_int
id|stage
comma
id|namelen
suffix:semicolon
r_int
id|ce_size
comma
id|mode
suffix:semicolon
r_struct
id|cache_entry
op_star
id|ce
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|update_index
)paren
r_return
suffix:semicolon
id|namelen
op_assign
id|strlen
c_func
(paren
id|patch-&gt;new_name
)paren
suffix:semicolon
id|ce_size
op_assign
id|cache_entry_size
c_func
(paren
id|namelen
)paren
suffix:semicolon
id|mode
op_assign
id|patch-&gt;new_mode
ques
c_cond
id|patch-&gt;new_mode
suffix:colon
(paren
id|S_IFREG
op_or
l_int|0644
)paren
suffix:semicolon
id|remove_file_from_cache
c_func
(paren
id|patch-&gt;new_name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|stage
op_assign
l_int|1
suffix:semicolon
id|stage
OL
l_int|4
suffix:semicolon
id|stage
op_increment
)paren
(brace
r_if
c_cond
(paren
id|is_null_sha1
c_func
(paren
id|patch-&gt;threeway_stage
(braket
id|stage
l_int|1
)braket
)paren
)paren
r_continue
suffix:semicolon
id|ce
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
id|ce_size
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ce-&gt;name
comma
id|patch-&gt;new_name
comma
id|namelen
)paren
suffix:semicolon
id|ce-&gt;ce_mode
op_assign
id|create_ce_mode
c_func
(paren
id|mode
)paren
suffix:semicolon
id|ce-&gt;ce_flags
op_assign
id|create_ce_flags
c_func
(paren
id|stage
)paren
suffix:semicolon
id|ce-&gt;ce_namelen
op_assign
id|namelen
suffix:semicolon
id|hashcpy
c_func
(paren
id|ce-&gt;sha1
comma
id|patch-&gt;threeway_stage
(braket
id|stage
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|add_cache_entry
c_func
(paren
id|ce
comma
id|ADD_CACHE_OK_TO_ADD
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;unable to add cache entry for %s&quot;
)paren
comma
id|patch-&gt;new_name
)paren
suffix:semicolon
)brace
)brace
DECL|function|create_file
r_static
r_void
id|create_file
c_func
(paren
r_struct
id|patch
op_star
id|patch
)paren
(brace
r_char
op_star
id|path
op_assign
id|patch-&gt;new_name
suffix:semicolon
r_int
id|mode
op_assign
id|patch-&gt;new_mode
suffix:semicolon
r_int
r_int
id|size
op_assign
id|patch-&gt;resultsize
suffix:semicolon
r_char
op_star
id|buf
op_assign
id|patch-&gt;result
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mode
)paren
id|mode
op_assign
id|S_IFREG
op_or
l_int|0644
suffix:semicolon
id|create_one_file
c_func
(paren
id|path
comma
id|mode
comma
id|buf
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|patch-&gt;conflicted_threeway
)paren
id|add_conflicted_stages_file
c_func
(paren
id|patch
)paren
suffix:semicolon
r_else
id|add_index_file
c_func
(paren
id|path
comma
id|mode
comma
id|buf
comma
id|size
)paren
suffix:semicolon
)brace
multiline_comment|/* phase zero is to remove, phase one is to create */
DECL|function|write_out_one_result
r_static
r_void
id|write_out_one_result
c_func
(paren
r_struct
id|patch
op_star
id|patch
comma
r_int
id|phase
)paren
(brace
r_if
c_cond
(paren
id|patch-&gt;is_delete
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|phase
op_eq
l_int|0
)paren
id|remove_file
c_func
(paren
id|patch
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|patch-&gt;is_new
OG
l_int|0
op_logical_or
id|patch-&gt;is_copy
)paren
(brace
r_if
c_cond
(paren
id|phase
op_eq
l_int|1
)paren
id|create_file
c_func
(paren
id|patch
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Rename or modification boils down to the same&n;&t; * thing: remove the old, write the new&n;&t; */
r_if
c_cond
(paren
id|phase
op_eq
l_int|0
)paren
id|remove_file
c_func
(paren
id|patch
comma
id|patch-&gt;is_rename
)paren
suffix:semicolon
r_if
c_cond
(paren
id|phase
op_eq
l_int|1
)paren
id|create_file
c_func
(paren
id|patch
)paren
suffix:semicolon
)brace
DECL|function|write_out_one_reject
r_static
r_int
id|write_out_one_reject
c_func
(paren
r_struct
id|patch
op_star
id|patch
)paren
(brace
id|FILE
op_star
id|rej
suffix:semicolon
r_char
id|namebuf
(braket
id|PATH_MAX
)braket
suffix:semicolon
r_struct
id|fragment
op_star
id|frag
suffix:semicolon
r_int
id|cnt
op_assign
l_int|0
suffix:semicolon
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
comma
id|frag
op_assign
id|patch-&gt;fragments
suffix:semicolon
id|frag
suffix:semicolon
id|frag
op_assign
id|frag-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|frag-&gt;rejected
)paren
r_continue
suffix:semicolon
id|cnt
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|cnt
)paren
(brace
r_if
c_cond
(paren
id|apply_verbosely
)paren
id|say_patch_name
c_func
(paren
id|stderr
comma
id|_
c_func
(paren
l_string|&quot;Applied patch %s cleanly.&quot;
)paren
comma
id|patch
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This should not happen, because a removal patch that leaves&n;&t; * contents are marked &quot;rejected&quot; at the patch level.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|patch-&gt;new_name
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;internal error&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* Say this even without --verbose */
id|strbuf_addf
c_func
(paren
op_amp
id|sb
comma
id|Q_
c_func
(paren
l_string|&quot;Applying patch %%s with %d reject...&quot;
comma
l_string|&quot;Applying patch %%s with %d rejects...&quot;
comma
id|cnt
)paren
comma
id|cnt
)paren
suffix:semicolon
id|say_patch_name
c_func
(paren
id|stderr
comma
id|sb.buf
comma
id|patch
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
id|cnt
op_assign
id|strlen
c_func
(paren
id|patch-&gt;new_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ARRAY_SIZE
c_func
(paren
id|namebuf
)paren
op_le
id|cnt
op_plus
l_int|5
)paren
(brace
id|cnt
op_assign
id|ARRAY_SIZE
c_func
(paren
id|namebuf
)paren
l_int|5
suffix:semicolon
id|warning
c_func
(paren
id|_
c_func
(paren
l_string|&quot;truncating .rej filename to %.*s.rej&quot;
)paren
comma
id|cnt
l_int|1
comma
id|patch-&gt;new_name
)paren
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|namebuf
comma
id|patch-&gt;new_name
comma
id|cnt
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|namebuf
op_plus
id|cnt
comma
l_string|&quot;.rej&quot;
comma
l_int|5
)paren
suffix:semicolon
id|rej
op_assign
id|fopen
c_func
(paren
id|namebuf
comma
l_string|&quot;w&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rej
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;cannot open %s: %s&quot;
)paren
comma
id|namebuf
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
multiline_comment|/* Normal git tools never deal with .rej, so do not pretend&n;&t; * this is a git patch by saying --git or giving extended&n;&t; * headers.  While at it, maybe please &quot;kompare&quot; that wants&n;&t; * the trailing TAB and some garbage at the end of line ;-).&n;&t; */
id|fprintf
c_func
(paren
id|rej
comma
l_string|&quot;diff a/%s b/%s&bslash;t(rejected hunks)&bslash;n&quot;
comma
id|patch-&gt;new_name
comma
id|patch-&gt;new_name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|1
comma
id|frag
op_assign
id|patch-&gt;fragments
suffix:semicolon
id|frag
suffix:semicolon
id|cnt
op_increment
comma
id|frag
op_assign
id|frag-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|frag-&gt;rejected
)paren
(brace
id|fprintf_ln
c_func
(paren
id|stderr
comma
id|_
c_func
(paren
l_string|&quot;Hunk #%d applied cleanly.&quot;
)paren
comma
id|cnt
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|fprintf_ln
c_func
(paren
id|stderr
comma
id|_
c_func
(paren
l_string|&quot;Rejected hunk #%d.&quot;
)paren
comma
id|cnt
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|rej
comma
l_string|&quot;%.*s&quot;
comma
id|frag-&gt;size
comma
id|frag-&gt;patch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|frag-&gt;patch
(braket
id|frag-&gt;size
op_minus
l_int|1
)braket
op_ne
l_char|&squot;&bslash;n&squot;
)paren
id|fputc
c_func
(paren
l_char|&squot;&bslash;n&squot;
comma
id|rej
)paren
suffix:semicolon
)brace
id|fclose
c_func
(paren
id|rej
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|write_out_results
r_static
r_int
id|write_out_results
c_func
(paren
r_struct
id|patch
op_star
id|list
)paren
(brace
r_int
id|phase
suffix:semicolon
r_int
id|errs
op_assign
l_int|0
suffix:semicolon
r_struct
id|patch
op_star
id|l
suffix:semicolon
r_struct
id|string_list
id|cpath
op_assign
id|STRING_LIST_INIT_DUP
suffix:semicolon
r_for
c_loop
(paren
id|phase
op_assign
l_int|0
suffix:semicolon
id|phase
OL
l_int|2
suffix:semicolon
id|phase
op_increment
)paren
(brace
id|l
op_assign
id|list
suffix:semicolon
r_while
c_loop
(paren
id|l
)paren
(brace
r_if
c_cond
(paren
id|l-&gt;rejected
)paren
id|errs
op_assign
l_int|1
suffix:semicolon
r_else
(brace
id|write_out_one_result
c_func
(paren
id|l
comma
id|phase
)paren
suffix:semicolon
r_if
c_cond
(paren
id|phase
op_eq
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|write_out_one_reject
c_func
(paren
id|l
)paren
)paren
id|errs
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|l-&gt;conflicted_threeway
)paren
(brace
id|string_list_append
c_func
(paren
op_amp
id|cpath
comma
id|l-&gt;new_name
)paren
suffix:semicolon
id|errs
op_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
id|l
op_assign
id|l-&gt;next
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|cpath.nr
)paren
(brace
r_struct
id|string_list_item
op_star
id|item
suffix:semicolon
id|sort_string_list
c_func
(paren
op_amp
id|cpath
)paren
suffix:semicolon
id|for_each_string_list_item
c_func
(paren
id|item
comma
op_amp
id|cpath
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;U %s&bslash;n&quot;
comma
id|item-&gt;string
)paren
suffix:semicolon
id|string_list_clear
c_func
(paren
op_amp
id|cpath
comma
l_int|0
)paren
suffix:semicolon
id|rerere
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|errs
suffix:semicolon
)brace
DECL|variable|lock_file
r_static
r_struct
id|lock_file
id|lock_file
suffix:semicolon
DECL|variable|limit_by_name
r_static
r_struct
id|string_list
id|limit_by_name
suffix:semicolon
DECL|variable|has_include
r_static
r_int
id|has_include
suffix:semicolon
DECL|function|add_name_limit
r_static
r_void
id|add_name_limit
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_int
id|exclude
)paren
(brace
r_struct
id|string_list_item
op_star
id|it
suffix:semicolon
id|it
op_assign
id|string_list_append
c_func
(paren
op_amp
id|limit_by_name
comma
id|name
)paren
suffix:semicolon
id|it-&gt;util
op_assign
id|exclude
ques
c_cond
l_int|NULL
suffix:colon
(paren
r_void
op_star
)paren
l_int|1
suffix:semicolon
)brace
DECL|function|use_patch
r_static
r_int
id|use_patch
c_func
(paren
r_struct
id|patch
op_star
id|p
)paren
(brace
r_const
r_char
op_star
id|pathname
op_assign
id|p-&gt;new_name
ques
c_cond
id|p-&gt;new_name
suffix:colon
id|p-&gt;old_name
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Paths outside are not touched regardless of &quot;--include&quot; */
r_if
c_cond
(paren
l_int|0
OL
id|prefix_length
)paren
(brace
r_int
id|pathlen
op_assign
id|strlen
c_func
(paren
id|pathname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pathlen
op_le
id|prefix_length
op_logical_or
id|memcmp
c_func
(paren
id|prefix
comma
id|pathname
comma
id|prefix_length
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* See if it matches any of exclude/include rule */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|limit_by_name.nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|string_list_item
op_star
id|it
op_assign
op_amp
id|limit_by_name.items
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fnmatch
c_func
(paren
id|it-&gt;string
comma
id|pathname
comma
l_int|0
)paren
)paren
r_return
(paren
id|it-&gt;util
op_ne
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we had any include, a path that does not match any rule is&n;&t; * not used.  Otherwise, we saw bunch of exclude rules (or none)&n;&t; * and such a path is used.&n;&t; */
r_return
op_logical_neg
id|has_include
suffix:semicolon
)brace
DECL|macro|INACCURATE_EOF
mdefine_line|#define INACCURATE_EOF&t;(1&lt;&lt;0)
DECL|macro|RECOUNT
mdefine_line|#define RECOUNT&t;&t;(1&lt;&lt;1)
DECL|function|apply_patch
r_static
r_int
id|apply_patch
c_func
(paren
r_int
id|fd
comma
r_const
r_char
op_star
id|filename
comma
r_int
id|options
)paren
(brace
r_int
id|offset
suffix:semicolon
r_struct
id|strbuf
id|buf
op_assign
id|STRBUF_INIT
suffix:semicolon
multiline_comment|/* owns the patch text */
r_struct
id|patch
op_star
id|list
op_assign
l_int|NULL
comma
op_star
op_star
id|listp
op_assign
op_amp
id|list
suffix:semicolon
r_int
id|skipped_patch
op_assign
l_int|0
suffix:semicolon
id|patch_input_file
op_assign
id|filename
suffix:semicolon
id|read_patch_file
c_func
(paren
op_amp
id|buf
comma
id|fd
)paren
suffix:semicolon
id|offset
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|offset
OL
id|buf.len
)paren
(brace
r_struct
id|patch
op_star
id|patch
suffix:semicolon
r_int
id|nr
suffix:semicolon
id|patch
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|patch
)paren
)paren
suffix:semicolon
id|patch-&gt;inaccurate_eof
op_assign
op_logical_neg
op_logical_neg
(paren
id|options
op_amp
id|INACCURATE_EOF
)paren
suffix:semicolon
id|patch-&gt;recount
op_assign
op_logical_neg
op_logical_neg
(paren
id|options
op_amp
id|RECOUNT
)paren
suffix:semicolon
id|nr
op_assign
id|parse_chunk
c_func
(paren
id|buf.buf
op_plus
id|offset
comma
id|buf.len
id|offset
comma
id|patch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr
OL
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|apply_in_reverse
)paren
id|reverse_patches
c_func
(paren
id|patch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|use_patch
c_func
(paren
id|patch
)paren
)paren
(brace
id|patch_stats
c_func
(paren
id|patch
)paren
suffix:semicolon
op_star
id|listp
op_assign
id|patch
suffix:semicolon
id|listp
op_assign
op_amp
id|patch-&gt;next
suffix:semicolon
)brace
r_else
(brace
id|free_patch
c_func
(paren
id|patch
)paren
suffix:semicolon
id|skipped_patch
op_increment
suffix:semicolon
)brace
id|offset
op_add_assign
id|nr
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|list
op_logical_and
op_logical_neg
id|skipped_patch
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;unrecognized input&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|whitespace_error
op_logical_and
(paren
id|ws_error_action
op_eq
id|die_on_ws_error
)paren
)paren
id|apply
op_assign
l_int|0
suffix:semicolon
id|update_index
op_assign
id|check_index
op_logical_and
id|apply
suffix:semicolon
r_if
c_cond
(paren
id|update_index
op_logical_and
id|newfd
OL
l_int|0
)paren
id|newfd
op_assign
id|hold_locked_index
c_func
(paren
op_amp
id|lock_file
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|check_index
)paren
(brace
r_if
c_cond
(paren
id|read_cache
c_func
(paren
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;unable to read index file&quot;
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|check
op_logical_or
id|apply
)paren
op_logical_and
id|check_patch_list
c_func
(paren
id|list
)paren
OL
l_int|0
op_logical_and
op_logical_neg
id|apply_with_reject
)paren
m_exit
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|apply
op_logical_and
id|write_out_results
c_func
(paren
id|list
)paren
)paren
(brace
r_if
c_cond
(paren
id|apply_with_reject
)paren
m_exit
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* with --3way, we still need to write the index out */
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fake_ancestor
)paren
id|build_fake_ancestor
c_func
(paren
id|list
comma
id|fake_ancestor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|diffstat
)paren
id|stat_patch_list
c_func
(paren
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|numstat
)paren
id|numstat_patch_list
c_func
(paren
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|summary
)paren
id|summary_patch_list
c_func
(paren
id|list
)paren
suffix:semicolon
id|free_patch_list
c_func
(paren
id|list
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|buf
)paren
suffix:semicolon
id|string_list_clear
c_func
(paren
op_amp
id|fn_table
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|git_apply_config
r_static
r_int
id|git_apply_config
c_func
(paren
r_const
r_char
op_star
id|var
comma
r_const
r_char
op_star
id|value
comma
r_void
op_star
id|cb
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;apply.whitespace&quot;
)paren
)paren
r_return
id|git_config_string
c_func
(paren
op_amp
id|apply_default_whitespace
comma
id|var
comma
id|value
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;apply.ignorewhitespace&quot;
)paren
)paren
r_return
id|git_config_string
c_func
(paren
op_amp
id|apply_default_ignorewhitespace
comma
id|var
comma
id|value
)paren
suffix:semicolon
r_return
id|git_default_config
c_func
(paren
id|var
comma
id|value
comma
id|cb
)paren
suffix:semicolon
)brace
DECL|function|option_parse_exclude
r_static
r_int
id|option_parse_exclude
c_func
(paren
r_const
r_struct
id|option
op_star
id|opt
comma
r_const
r_char
op_star
id|arg
comma
r_int
id|unset
)paren
(brace
id|add_name_limit
c_func
(paren
id|arg
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|option_parse_include
r_static
r_int
id|option_parse_include
c_func
(paren
r_const
r_struct
id|option
op_star
id|opt
comma
r_const
r_char
op_star
id|arg
comma
r_int
id|unset
)paren
(brace
id|add_name_limit
c_func
(paren
id|arg
comma
l_int|0
)paren
suffix:semicolon
id|has_include
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|option_parse_p
r_static
r_int
id|option_parse_p
c_func
(paren
r_const
r_struct
id|option
op_star
id|opt
comma
r_const
r_char
op_star
id|arg
comma
r_int
id|unset
)paren
(brace
id|p_value
op_assign
id|atoi
c_func
(paren
id|arg
)paren
suffix:semicolon
id|p_value_known
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|option_parse_z
r_static
r_int
id|option_parse_z
c_func
(paren
r_const
r_struct
id|option
op_star
id|opt
comma
r_const
r_char
op_star
id|arg
comma
r_int
id|unset
)paren
(brace
r_if
c_cond
(paren
id|unset
)paren
id|line_termination
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
r_else
id|line_termination
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|option_parse_space_change
r_static
r_int
id|option_parse_space_change
c_func
(paren
r_const
r_struct
id|option
op_star
id|opt
comma
r_const
r_char
op_star
id|arg
comma
r_int
id|unset
)paren
(brace
r_if
c_cond
(paren
id|unset
)paren
id|ws_ignore_action
op_assign
id|ignore_ws_none
suffix:semicolon
r_else
id|ws_ignore_action
op_assign
id|ignore_ws_change
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|option_parse_whitespace
r_static
r_int
id|option_parse_whitespace
c_func
(paren
r_const
r_struct
id|option
op_star
id|opt
comma
r_const
r_char
op_star
id|arg
comma
r_int
id|unset
)paren
(brace
r_const
r_char
op_star
op_star
id|whitespace_option
op_assign
id|opt-&gt;value
suffix:semicolon
op_star
id|whitespace_option
op_assign
id|arg
suffix:semicolon
id|parse_whitespace_option
c_func
(paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|option_parse_directory
r_static
r_int
id|option_parse_directory
c_func
(paren
r_const
r_struct
id|option
op_star
id|opt
comma
r_const
r_char
op_star
id|arg
comma
r_int
id|unset
)paren
(brace
id|root_len
op_assign
id|strlen
c_func
(paren
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|root_len
op_logical_and
id|arg
(braket
id|root_len
l_int|1
)braket
op_ne
l_char|&squot;/&squot;
)paren
(brace
r_char
op_star
id|new_root
suffix:semicolon
id|root
op_assign
id|new_root
op_assign
id|xmalloc
c_func
(paren
id|root_len
op_plus
l_int|2
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|new_root
comma
id|arg
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|new_root
op_plus
id|root_len
op_increment
comma
l_string|&quot;/&quot;
)paren
suffix:semicolon
)brace
r_else
id|root
op_assign
id|arg
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cmd_apply
r_int
id|cmd_apply
c_func
(paren
r_int
id|argc
comma
r_const
r_char
op_star
op_star
id|argv
comma
r_const
r_char
op_star
id|prefix_
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|errs
op_assign
l_int|0
suffix:semicolon
r_int
id|is_not_gitdir
op_assign
op_logical_neg
id|startup_info-&gt;have_repository
suffix:semicolon
r_int
id|force_apply
op_assign
l_int|0
suffix:semicolon
r_const
r_char
op_star
id|whitespace_option
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|option
id|builtin_apply_options
(braket
)braket
op_assign
(brace
(brace
id|OPTION_CALLBACK
comma
l_int|0
comma
l_string|&quot;exclude&quot;
comma
l_int|NULL
comma
id|N_
c_func
(paren
l_string|&quot;path&quot;
)paren
comma
id|N_
c_func
(paren
l_string|&quot;don&squot;t apply changes matching the given path&quot;
)paren
comma
l_int|0
comma
id|option_parse_exclude
)brace
comma
(brace
id|OPTION_CALLBACK
comma
l_int|0
comma
l_string|&quot;include&quot;
comma
l_int|NULL
comma
id|N_
c_func
(paren
l_string|&quot;path&quot;
)paren
comma
id|N_
c_func
(paren
l_string|&quot;apply changes matching the given path&quot;
)paren
comma
l_int|0
comma
id|option_parse_include
)brace
comma
(brace
id|OPTION_CALLBACK
comma
l_char|&squot;p&squot;
comma
l_int|NULL
comma
l_int|NULL
comma
id|N_
c_func
(paren
l_string|&quot;num&quot;
)paren
comma
id|N_
c_func
(paren
l_string|&quot;remove &lt;num&gt; leading slashes from traditional diff paths&quot;
)paren
comma
l_int|0
comma
id|option_parse_p
)brace
comma
id|OPT_BOOL
c_func
(paren
l_int|0
comma
l_string|&quot;no-add&quot;
comma
op_amp
id|no_add
comma
id|N_
c_func
(paren
l_string|&quot;ignore additions made by the patch&quot;
)paren
)paren
comma
id|OPT_BOOL
c_func
(paren
l_int|0
comma
l_string|&quot;stat&quot;
comma
op_amp
id|diffstat
comma
id|N_
c_func
(paren
l_string|&quot;instead of applying the patch, output diffstat for the input&quot;
)paren
)paren
comma
id|OPT_NOOP_NOARG
c_func
(paren
l_int|0
comma
l_string|&quot;allow-binary-replacement&quot;
)paren
comma
id|OPT_NOOP_NOARG
c_func
(paren
l_int|0
comma
l_string|&quot;binary&quot;
)paren
comma
id|OPT_BOOL
c_func
(paren
l_int|0
comma
l_string|&quot;numstat&quot;
comma
op_amp
id|numstat
comma
id|N_
c_func
(paren
l_string|&quot;show number of added and deleted lines in decimal notation&quot;
)paren
)paren
comma
id|OPT_BOOL
c_func
(paren
l_int|0
comma
l_string|&quot;summary&quot;
comma
op_amp
id|summary
comma
id|N_
c_func
(paren
l_string|&quot;instead of applying the patch, output a summary for the input&quot;
)paren
)paren
comma
id|OPT_BOOL
c_func
(paren
l_int|0
comma
l_string|&quot;check&quot;
comma
op_amp
id|check
comma
id|N_
c_func
(paren
l_string|&quot;instead of applying the patch, see if the patch is applicable&quot;
)paren
)paren
comma
id|OPT_BOOL
c_func
(paren
l_int|0
comma
l_string|&quot;index&quot;
comma
op_amp
id|check_index
comma
id|N_
c_func
(paren
l_string|&quot;make sure the patch is applicable to the current index&quot;
)paren
)paren
comma
id|OPT_BOOL
c_func
(paren
l_int|0
comma
l_string|&quot;cached&quot;
comma
op_amp
id|cached
comma
id|N_
c_func
(paren
l_string|&quot;apply a patch without touching the working tree&quot;
)paren
)paren
comma
id|OPT_BOOL
c_func
(paren
l_int|0
comma
l_string|&quot;apply&quot;
comma
op_amp
id|force_apply
comma
id|N_
c_func
(paren
l_string|&quot;also apply the patch (use with --stat/--summary/--check)&quot;
)paren
)paren
comma
id|OPT_BOOL
c_func
(paren
l_char|&squot;3&squot;
comma
l_string|&quot;3way&quot;
comma
op_amp
id|threeway
comma
id|N_
c_func
(paren
l_string|&quot;attempt three-way merge if a patch does not apply&quot;
)paren
)paren
comma
id|OPT_FILENAME
c_func
(paren
l_int|0
comma
l_string|&quot;build-fake-ancestor&quot;
comma
op_amp
id|fake_ancestor
comma
id|N_
c_func
(paren
l_string|&quot;build a temporary index based on embedded index information&quot;
)paren
)paren
comma
(brace
id|OPTION_CALLBACK
comma
l_char|&squot;z&squot;
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
id|N_
c_func
(paren
l_string|&quot;paths are separated with NUL character&quot;
)paren
comma
id|PARSE_OPT_NOARG
comma
id|option_parse_z
)brace
comma
id|OPT_INTEGER
c_func
(paren
l_char|&squot;C&squot;
comma
l_int|NULL
comma
op_amp
id|p_context
comma
id|N_
c_func
(paren
l_string|&quot;ensure at least &lt;n&gt; lines of context match&quot;
)paren
)paren
comma
(brace
id|OPTION_CALLBACK
comma
l_int|0
comma
l_string|&quot;whitespace&quot;
comma
op_amp
id|whitespace_option
comma
id|N_
c_func
(paren
l_string|&quot;action&quot;
)paren
comma
id|N_
c_func
(paren
l_string|&quot;detect new or modified lines that have whitespace errors&quot;
)paren
comma
l_int|0
comma
id|option_parse_whitespace
)brace
comma
(brace
id|OPTION_CALLBACK
comma
l_int|0
comma
l_string|&quot;ignore-space-change&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
id|N_
c_func
(paren
l_string|&quot;ignore changes in whitespace when finding context&quot;
)paren
comma
id|PARSE_OPT_NOARG
comma
id|option_parse_space_change
)brace
comma
(brace
id|OPTION_CALLBACK
comma
l_int|0
comma
l_string|&quot;ignore-whitespace&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
id|N_
c_func
(paren
l_string|&quot;ignore changes in whitespace when finding context&quot;
)paren
comma
id|PARSE_OPT_NOARG
comma
id|option_parse_space_change
)brace
comma
id|OPT_BOOL
c_func
(paren
l_char|&squot;R&squot;
comma
l_string|&quot;reverse&quot;
comma
op_amp
id|apply_in_reverse
comma
id|N_
c_func
(paren
l_string|&quot;apply the patch in reverse&quot;
)paren
)paren
comma
id|OPT_BOOL
c_func
(paren
l_int|0
comma
l_string|&quot;unidiff-zero&quot;
comma
op_amp
id|unidiff_zero
comma
id|N_
c_func
(paren
l_string|&quot;don&squot;t expect at least one line of context&quot;
)paren
)paren
comma
id|OPT_BOOL
c_func
(paren
l_int|0
comma
l_string|&quot;reject&quot;
comma
op_amp
id|apply_with_reject
comma
id|N_
c_func
(paren
l_string|&quot;leave the rejected hunks in corresponding *.rej files&quot;
)paren
)paren
comma
id|OPT_BOOL
c_func
(paren
l_int|0
comma
l_string|&quot;allow-overlap&quot;
comma
op_amp
id|allow_overlap
comma
id|N_
c_func
(paren
l_string|&quot;allow overlapping hunks&quot;
)paren
)paren
comma
id|OPT__VERBOSE
c_func
(paren
op_amp
id|apply_verbosely
comma
id|N_
c_func
(paren
l_string|&quot;be verbose&quot;
)paren
)paren
comma
id|OPT_BIT
c_func
(paren
l_int|0
comma
l_string|&quot;inaccurate-eof&quot;
comma
op_amp
id|options
comma
id|N_
c_func
(paren
l_string|&quot;tolerate incorrectly detected missing new-line at the end of file&quot;
)paren
comma
id|INACCURATE_EOF
)paren
comma
id|OPT_BIT
c_func
(paren
l_int|0
comma
l_string|&quot;recount&quot;
comma
op_amp
id|options
comma
id|N_
c_func
(paren
l_string|&quot;do not trust the line counts in the hunk headers&quot;
)paren
comma
id|RECOUNT
)paren
comma
(brace
id|OPTION_CALLBACK
comma
l_int|0
comma
l_string|&quot;directory&quot;
comma
l_int|NULL
comma
id|N_
c_func
(paren
l_string|&quot;root&quot;
)paren
comma
id|N_
c_func
(paren
l_string|&quot;prepend &lt;root&gt; to all filenames&quot;
)paren
comma
l_int|0
comma
id|option_parse_directory
)brace
comma
id|OPT_END
c_func
(paren
)paren
)brace
suffix:semicolon
id|prefix
op_assign
id|prefix_
suffix:semicolon
id|prefix_length
op_assign
id|prefix
ques
c_cond
id|strlen
c_func
(paren
id|prefix
)paren
suffix:colon
l_int|0
suffix:semicolon
id|git_config
c_func
(paren
id|git_apply_config
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|apply_default_whitespace
)paren
id|parse_whitespace_option
c_func
(paren
id|apply_default_whitespace
)paren
suffix:semicolon
r_if
c_cond
(paren
id|apply_default_ignorewhitespace
)paren
id|parse_ignorewhitespace_option
c_func
(paren
id|apply_default_ignorewhitespace
)paren
suffix:semicolon
id|argc
op_assign
id|parse_options
c_func
(paren
id|argc
comma
id|argv
comma
id|prefix
comma
id|builtin_apply_options
comma
id|apply_usage
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|apply_with_reject
op_logical_and
id|threeway
)paren
id|die
c_func
(paren
l_string|&quot;--reject and --3way cannot be used together.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cached
op_logical_and
id|threeway
)paren
id|die
c_func
(paren
l_string|&quot;--cached and --3way cannot be used together.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|threeway
)paren
(brace
r_if
c_cond
(paren
id|is_not_gitdir
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;--3way outside a repository&quot;
)paren
)paren
suffix:semicolon
id|check_index
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|apply_with_reject
)paren
id|apply
op_assign
id|apply_verbosely
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|force_apply
op_logical_and
(paren
id|diffstat
op_logical_or
id|numstat
op_logical_or
id|summary
op_logical_or
id|check
op_logical_or
id|fake_ancestor
)paren
)paren
id|apply
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|check_index
op_logical_and
id|is_not_gitdir
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;--index outside a repository&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cached
)paren
(brace
r_if
c_cond
(paren
id|is_not_gitdir
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;--cached outside a repository&quot;
)paren
)paren
suffix:semicolon
id|check_index
op_assign
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|argc
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_char
op_star
id|arg
op_assign
id|argv
(braket
id|i
)braket
suffix:semicolon
r_int
id|fd
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;-&quot;
)paren
)paren
(brace
id|errs
op_or_assign
id|apply_patch
c_func
(paren
l_int|0
comma
l_string|&quot;&lt;stdin&gt;&quot;
comma
id|options
)paren
suffix:semicolon
id|read_stdin
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
l_int|0
OL
id|prefix_length
)paren
id|arg
op_assign
id|prefix_filename
c_func
(paren
id|prefix
comma
id|prefix_length
comma
id|arg
)paren
suffix:semicolon
id|fd
op_assign
id|open
c_func
(paren
id|arg
comma
id|O_RDONLY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;can&squot;t open patch &squot;%s&squot;&quot;
)paren
comma
id|arg
)paren
suffix:semicolon
id|read_stdin
op_assign
l_int|0
suffix:semicolon
id|set_default_whitespace_mode
c_func
(paren
id|whitespace_option
)paren
suffix:semicolon
id|errs
op_or_assign
id|apply_patch
c_func
(paren
id|fd
comma
id|arg
comma
id|options
)paren
suffix:semicolon
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
)brace
id|set_default_whitespace_mode
c_func
(paren
id|whitespace_option
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_stdin
)paren
id|errs
op_or_assign
id|apply_patch
c_func
(paren
l_int|0
comma
l_string|&quot;&lt;stdin&gt;&quot;
comma
id|options
)paren
suffix:semicolon
r_if
c_cond
(paren
id|whitespace_error
)paren
(brace
r_if
c_cond
(paren
id|squelch_whitespace_errors
op_logical_and
id|squelch_whitespace_errors
OL
id|whitespace_error
)paren
(brace
r_int
id|squelched
op_assign
id|whitespace_error
id|squelch_whitespace_errors
suffix:semicolon
id|warning
c_func
(paren
id|Q_
c_func
(paren
l_string|&quot;squelched %d whitespace error&quot;
comma
l_string|&quot;squelched %d whitespace errors&quot;
comma
id|squelched
)paren
comma
id|squelched
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ws_error_action
op_eq
id|die_on_ws_error
)paren
id|die
c_func
(paren
id|Q_
c_func
(paren
l_string|&quot;%d line adds whitespace errors.&quot;
comma
l_string|&quot;%d lines add whitespace errors.&quot;
comma
id|whitespace_error
)paren
comma
id|whitespace_error
)paren
suffix:semicolon
r_if
c_cond
(paren
id|applied_after_fixing_ws
op_logical_and
id|apply
)paren
id|warning
c_func
(paren
l_string|&quot;%d line%s applied after&quot;
l_string|&quot; fixing whitespace errors.&quot;
comma
id|applied_after_fixing_ws
comma
id|applied_after_fixing_ws
op_eq
l_int|1
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;s&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|whitespace_error
)paren
id|warning
c_func
(paren
id|Q_
c_func
(paren
l_string|&quot;%d line adds whitespace errors.&quot;
comma
l_string|&quot;%d lines add whitespace errors.&quot;
comma
id|whitespace_error
)paren
comma
id|whitespace_error
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|update_index
)paren
(brace
r_if
c_cond
(paren
id|write_cache
c_func
(paren
id|newfd
comma
id|active_cache
comma
id|active_nr
)paren
op_logical_or
id|commit_locked_index
c_func
(paren
op_amp
id|lock_file
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Unable to write new index file&quot;
)paren
)paren
suffix:semicolon
)brace
r_return
op_logical_neg
op_logical_neg
id|errs
suffix:semicolon
)brace
eof
