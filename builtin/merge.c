multiline_comment|/*&n; * Builtin &quot;git merge&quot;&n; *&n; * Copyright (c) 2008 Miklos Vajna &lt;vmiklos@frugalware.org&gt;&n; *&n; * Based on git-merge.sh by Junio C Hamano.&n; */
macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;parse-options.h&quot;
macro_line|#include &quot;builtin.h&quot;
macro_line|#include &quot;run-command.h&quot;
macro_line|#include &quot;diff.h&quot;
macro_line|#include &quot;refs.h&quot;
macro_line|#include &quot;commit.h&quot;
macro_line|#include &quot;diffcore.h&quot;
macro_line|#include &quot;revision.h&quot;
macro_line|#include &quot;unpack-trees.h&quot;
macro_line|#include &quot;cache-tree.h&quot;
macro_line|#include &quot;dir.h&quot;
macro_line|#include &quot;utf8.h&quot;
macro_line|#include &quot;log-tree.h&quot;
macro_line|#include &quot;color.h&quot;
macro_line|#include &quot;rerere.h&quot;
macro_line|#include &quot;help.h&quot;
macro_line|#include &quot;merge-recursive.h&quot;
macro_line|#include &quot;resolve-undo.h&quot;
macro_line|#include &quot;remote.h&quot;
macro_line|#include &quot;fmt-merge-msg.h&quot;
macro_line|#include &quot;gpg-interface.h&quot;
DECL|macro|DEFAULT_TWOHEAD
mdefine_line|#define DEFAULT_TWOHEAD (1&lt;&lt;0)
DECL|macro|DEFAULT_OCTOPUS
mdefine_line|#define DEFAULT_OCTOPUS (1&lt;&lt;1)
DECL|macro|NO_FAST_FORWARD
mdefine_line|#define NO_FAST_FORWARD (1&lt;&lt;2)
DECL|macro|NO_TRIVIAL
mdefine_line|#define NO_TRIVIAL      (1&lt;&lt;3)
DECL|struct|strategy
r_struct
id|strategy
(brace
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
DECL|member|attr
r_int
id|attr
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|builtin_merge_usage
r_static
r_const
r_char
op_star
r_const
id|builtin_merge_usage
(braket
)braket
op_assign
(brace
l_string|&quot;git merge [options] [&lt;commit&gt;...]&quot;
comma
l_string|&quot;git merge [options] &lt;msg&gt; HEAD &lt;commit&gt;&quot;
comma
l_string|&quot;git merge --abort&quot;
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|show_diffstat
DECL|variable|shortlog_len
DECL|variable|squash
r_static
r_int
id|show_diffstat
op_assign
l_int|1
comma
id|shortlog_len
op_assign
l_int|1
comma
id|squash
suffix:semicolon
DECL|variable|option_commit
DECL|variable|allow_fast_forward
r_static
r_int
id|option_commit
op_assign
l_int|1
comma
id|allow_fast_forward
op_assign
l_int|1
suffix:semicolon
DECL|variable|fast_forward_only
DECL|variable|option_edit
r_static
r_int
id|fast_forward_only
comma
id|option_edit
suffix:semicolon
DECL|variable|allow_trivial
DECL|variable|have_message
r_static
r_int
id|allow_trivial
op_assign
l_int|1
comma
id|have_message
suffix:semicolon
DECL|variable|overwrite_ignore
r_static
r_int
id|overwrite_ignore
op_assign
l_int|1
suffix:semicolon
DECL|variable|merge_msg
r_static
r_struct
id|strbuf
id|merge_msg
op_assign
id|STRBUF_INIT
suffix:semicolon
DECL|variable|remoteheads
r_static
r_struct
id|commit_list
op_star
id|remoteheads
suffix:semicolon
DECL|variable|use_strategies
r_static
r_struct
id|strategy
op_star
op_star
id|use_strategies
suffix:semicolon
DECL|variable|use_strategies_nr
DECL|variable|use_strategies_alloc
r_static
r_int
id|use_strategies_nr
comma
id|use_strategies_alloc
suffix:semicolon
DECL|variable|xopts
r_static
r_const
r_char
op_star
op_star
id|xopts
suffix:semicolon
DECL|variable|xopts_nr
DECL|variable|xopts_alloc
r_static
r_int
id|xopts_nr
comma
id|xopts_alloc
suffix:semicolon
DECL|variable|branch
r_static
r_const
r_char
op_star
id|branch
suffix:semicolon
DECL|variable|branch_mergeoptions
r_static
r_char
op_star
id|branch_mergeoptions
suffix:semicolon
DECL|variable|option_renormalize
r_static
r_int
id|option_renormalize
suffix:semicolon
DECL|variable|verbosity
r_static
r_int
id|verbosity
suffix:semicolon
DECL|variable|allow_rerere_auto
r_static
r_int
id|allow_rerere_auto
suffix:semicolon
DECL|variable|abort_current_merge
r_static
r_int
id|abort_current_merge
suffix:semicolon
DECL|variable|show_progress
r_static
r_int
id|show_progress
op_assign
l_int|1
suffix:semicolon
DECL|variable|default_to_upstream
r_static
r_int
id|default_to_upstream
suffix:semicolon
DECL|variable|sign_commit
r_static
r_const
r_char
op_star
id|sign_commit
suffix:semicolon
DECL|variable|all_strategy
r_static
r_struct
id|strategy
id|all_strategy
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;recursive&quot;
comma
id|DEFAULT_TWOHEAD
op_or
id|NO_TRIVIAL
)brace
comma
(brace
l_string|&quot;octopus&quot;
comma
id|DEFAULT_OCTOPUS
)brace
comma
(brace
l_string|&quot;resolve&quot;
comma
l_int|0
)brace
comma
(brace
l_string|&quot;ours&quot;
comma
id|NO_FAST_FORWARD
op_or
id|NO_TRIVIAL
)brace
comma
(brace
l_string|&quot;subtree&quot;
comma
id|NO_FAST_FORWARD
op_or
id|NO_TRIVIAL
)brace
comma
)brace
suffix:semicolon
DECL|variable|pull_twohead
DECL|variable|pull_octopus
r_static
r_const
r_char
op_star
id|pull_twohead
comma
op_star
id|pull_octopus
suffix:semicolon
DECL|function|option_parse_message
r_static
r_int
id|option_parse_message
c_func
(paren
r_const
r_struct
id|option
op_star
id|opt
comma
r_const
r_char
op_star
id|arg
comma
r_int
id|unset
)paren
(brace
r_struct
id|strbuf
op_star
id|buf
op_assign
id|opt-&gt;value
suffix:semicolon
r_if
c_cond
(paren
id|unset
)paren
id|strbuf_setlen
c_func
(paren
id|buf
comma
l_int|0
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|arg
)paren
(brace
id|strbuf_addf
c_func
(paren
id|buf
comma
l_string|&quot;%s%s&quot;
comma
id|buf-&gt;len
ques
c_cond
l_string|&quot;&bslash;n&bslash;n&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|arg
)paren
suffix:semicolon
id|have_message
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;switch `m&squot; requires a value&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|get_strategy
r_static
r_struct
id|strategy
op_star
id|get_strategy
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|strategy
op_star
id|ret
suffix:semicolon
r_static
r_struct
id|cmdnames
id|main_cmds
comma
id|other_cmds
suffix:semicolon
r_static
r_int
id|loaded
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
r_return
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|all_strategy
)paren
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
id|all_strategy
(braket
id|i
)braket
dot
id|name
)paren
)paren
r_return
op_amp
id|all_strategy
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|loaded
)paren
(brace
r_struct
id|cmdnames
id|not_strategies
suffix:semicolon
id|loaded
op_assign
l_int|1
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|not_strategies
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|cmdnames
)paren
)paren
suffix:semicolon
id|load_command_list
c_func
(paren
l_string|&quot;git-merge-&quot;
comma
op_amp
id|main_cmds
comma
op_amp
id|other_cmds
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|main_cmds.cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|j
comma
id|found
op_assign
l_int|0
suffix:semicolon
r_struct
id|cmdname
op_star
id|ent
op_assign
id|main_cmds.names
(braket
id|i
)braket
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|ARRAY_SIZE
c_func
(paren
id|all_strategy
)paren
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|ent-&gt;name
comma
id|all_strategy
(braket
id|j
)braket
dot
id|name
comma
id|ent-&gt;len
)paren
op_logical_and
op_logical_neg
id|all_strategy
(braket
id|j
)braket
dot
id|name
(braket
id|ent-&gt;len
)braket
)paren
id|found
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
id|add_cmdname
c_func
(paren
op_amp
id|not_strategies
comma
id|ent-&gt;name
comma
id|ent-&gt;len
)paren
suffix:semicolon
)brace
id|exclude_cmds
c_func
(paren
op_amp
id|main_cmds
comma
op_amp
id|not_strategies
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|is_in_cmdlist
c_func
(paren
op_amp
id|main_cmds
comma
id|name
)paren
op_logical_and
op_logical_neg
id|is_in_cmdlist
c_func
(paren
op_amp
id|other_cmds
comma
id|name
)paren
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
id|_
c_func
(paren
l_string|&quot;Could not find merge strategy &squot;%s&squot;.&bslash;n&quot;
)paren
comma
id|name
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
id|_
c_func
(paren
l_string|&quot;Available strategies are:&quot;
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|main_cmds.cnt
suffix:semicolon
id|i
op_increment
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot; %s&quot;
comma
id|main_cmds.names
(braket
id|i
)braket
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|other_cmds.cnt
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
id|_
c_func
(paren
l_string|&quot;Available custom strategies are:&quot;
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|other_cmds.cnt
suffix:semicolon
id|i
op_increment
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot; %s&quot;
comma
id|other_cmds.names
(braket
id|i
)braket
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|ret
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|strategy
)paren
)paren
suffix:semicolon
id|ret-&gt;name
op_assign
id|xstrdup
c_func
(paren
id|name
)paren
suffix:semicolon
id|ret-&gt;attr
op_assign
id|NO_TRIVIAL
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|append_strategy
r_static
r_void
id|append_strategy
c_func
(paren
r_struct
id|strategy
op_star
id|s
)paren
(brace
id|ALLOC_GROW
c_func
(paren
id|use_strategies
comma
id|use_strategies_nr
op_plus
l_int|1
comma
id|use_strategies_alloc
)paren
suffix:semicolon
id|use_strategies
(braket
id|use_strategies_nr
op_increment
)braket
op_assign
id|s
suffix:semicolon
)brace
DECL|function|option_parse_strategy
r_static
r_int
id|option_parse_strategy
c_func
(paren
r_const
r_struct
id|option
op_star
id|opt
comma
r_const
r_char
op_star
id|name
comma
r_int
id|unset
)paren
(brace
r_if
c_cond
(paren
id|unset
)paren
r_return
l_int|0
suffix:semicolon
id|append_strategy
c_func
(paren
id|get_strategy
c_func
(paren
id|name
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|option_parse_x
r_static
r_int
id|option_parse_x
c_func
(paren
r_const
r_struct
id|option
op_star
id|opt
comma
r_const
r_char
op_star
id|arg
comma
r_int
id|unset
)paren
(brace
r_if
c_cond
(paren
id|unset
)paren
r_return
l_int|0
suffix:semicolon
id|ALLOC_GROW
c_func
(paren
id|xopts
comma
id|xopts_nr
op_plus
l_int|1
comma
id|xopts_alloc
)paren
suffix:semicolon
id|xopts
(braket
id|xopts_nr
op_increment
)braket
op_assign
id|xstrdup
c_func
(paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|option_parse_n
r_static
r_int
id|option_parse_n
c_func
(paren
r_const
r_struct
id|option
op_star
id|opt
comma
r_const
r_char
op_star
id|arg
comma
r_int
id|unset
)paren
(brace
id|show_diffstat
op_assign
id|unset
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|builtin_merge_options
r_static
r_struct
id|option
id|builtin_merge_options
(braket
)braket
op_assign
(brace
(brace
id|OPTION_CALLBACK
comma
l_char|&squot;n&squot;
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_string|&quot;do not show a diffstat at the end of the merge&quot;
comma
id|PARSE_OPT_NOARG
comma
id|option_parse_n
)brace
comma
id|OPT_BOOLEAN
c_func
(paren
l_int|0
comma
l_string|&quot;stat&quot;
comma
op_amp
id|show_diffstat
comma
l_string|&quot;show a diffstat at the end of the merge&quot;
)paren
comma
id|OPT_BOOLEAN
c_func
(paren
l_int|0
comma
l_string|&quot;summary&quot;
comma
op_amp
id|show_diffstat
comma
l_string|&quot;(synonym to --stat)&quot;
)paren
comma
(brace
id|OPTION_INTEGER
comma
l_int|0
comma
l_string|&quot;log&quot;
comma
op_amp
id|shortlog_len
comma
l_string|&quot;n&quot;
comma
l_string|&quot;add (at most &lt;n&gt;) entries from shortlog to merge commit message&quot;
comma
id|PARSE_OPT_OPTARG
comma
l_int|NULL
comma
id|DEFAULT_MERGE_LOG_LEN
)brace
comma
id|OPT_BOOLEAN
c_func
(paren
l_int|0
comma
l_string|&quot;squash&quot;
comma
op_amp
id|squash
comma
l_string|&quot;create a single commit instead of doing a merge&quot;
)paren
comma
id|OPT_BOOLEAN
c_func
(paren
l_int|0
comma
l_string|&quot;commit&quot;
comma
op_amp
id|option_commit
comma
l_string|&quot;perform a commit if the merge succeeds (default)&quot;
)paren
comma
id|OPT_BOOLEAN
c_func
(paren
l_char|&squot;e&squot;
comma
l_string|&quot;edit&quot;
comma
op_amp
id|option_edit
comma
l_string|&quot;edit message before committing&quot;
)paren
comma
id|OPT_BOOLEAN
c_func
(paren
l_int|0
comma
l_string|&quot;ff&quot;
comma
op_amp
id|allow_fast_forward
comma
l_string|&quot;allow fast-forward (default)&quot;
)paren
comma
id|OPT_BOOLEAN
c_func
(paren
l_int|0
comma
l_string|&quot;ff-only&quot;
comma
op_amp
id|fast_forward_only
comma
l_string|&quot;abort if fast-forward is not possible&quot;
)paren
comma
id|OPT_RERERE_AUTOUPDATE
c_func
(paren
op_amp
id|allow_rerere_auto
)paren
comma
id|OPT_CALLBACK
c_func
(paren
l_char|&squot;s&squot;
comma
l_string|&quot;strategy&quot;
comma
op_amp
id|use_strategies
comma
l_string|&quot;strategy&quot;
comma
l_string|&quot;merge strategy to use&quot;
comma
id|option_parse_strategy
)paren
comma
id|OPT_CALLBACK
c_func
(paren
l_char|&squot;X&squot;
comma
l_string|&quot;strategy-option&quot;
comma
op_amp
id|xopts
comma
l_string|&quot;option=value&quot;
comma
l_string|&quot;option for selected merge strategy&quot;
comma
id|option_parse_x
)paren
comma
id|OPT_CALLBACK
c_func
(paren
l_char|&squot;m&squot;
comma
l_string|&quot;message&quot;
comma
op_amp
id|merge_msg
comma
l_string|&quot;message&quot;
comma
l_string|&quot;merge commit message (for a non-fast-forward merge)&quot;
comma
id|option_parse_message
)paren
comma
id|OPT__VERBOSITY
c_func
(paren
op_amp
id|verbosity
)paren
comma
id|OPT_BOOLEAN
c_func
(paren
l_int|0
comma
l_string|&quot;abort&quot;
comma
op_amp
id|abort_current_merge
comma
l_string|&quot;abort the current in-progress merge&quot;
)paren
comma
id|OPT_SET_INT
c_func
(paren
l_int|0
comma
l_string|&quot;progress&quot;
comma
op_amp
id|show_progress
comma
l_string|&quot;force progress reporting&quot;
comma
l_int|1
)paren
comma
(brace
id|OPTION_STRING
comma
l_char|&squot;S&squot;
comma
l_string|&quot;gpg-sign&quot;
comma
op_amp
id|sign_commit
comma
l_string|&quot;key id&quot;
comma
l_string|&quot;GPG sign commit&quot;
comma
id|PARSE_OPT_OPTARG
comma
l_int|NULL
comma
(paren
r_intptr
)paren
l_string|&quot;&quot;
)brace
comma
id|OPT_BOOLEAN
c_func
(paren
l_int|0
comma
l_string|&quot;overwrite-ignore&quot;
comma
op_amp
id|overwrite_ignore
comma
l_string|&quot;update ignored files (default)&quot;
)paren
comma
id|OPT_END
c_func
(paren
)paren
)brace
suffix:semicolon
multiline_comment|/* Cleans up metadata that is uninteresting after a succeeded merge. */
DECL|function|drop_save
r_static
r_void
id|drop_save
c_func
(paren
r_void
)paren
(brace
id|unlink
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;MERGE_HEAD&quot;
)paren
)paren
suffix:semicolon
id|unlink
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;MERGE_MSG&quot;
)paren
)paren
suffix:semicolon
id|unlink
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;MERGE_MODE&quot;
)paren
)paren
suffix:semicolon
)brace
DECL|function|save_state
r_static
r_int
id|save_state
c_func
(paren
r_int
r_char
op_star
id|stash
)paren
(brace
r_int
id|len
suffix:semicolon
r_struct
id|child_process
id|cp
suffix:semicolon
r_struct
id|strbuf
id|buffer
op_assign
id|STRBUF_INIT
suffix:semicolon
r_const
r_char
op_star
id|argv
(braket
)braket
op_assign
(brace
l_string|&quot;stash&quot;
comma
l_string|&quot;create&quot;
comma
l_int|NULL
)brace
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|cp
comma
l_int|0
comma
r_sizeof
(paren
id|cp
)paren
)paren
suffix:semicolon
id|cp.argv
op_assign
id|argv
suffix:semicolon
id|cp.out
op_assign
l_int|1
suffix:semicolon
id|cp.git_cmd
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|start_command
c_func
(paren
op_amp
id|cp
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;could not run stash.&quot;
)paren
)paren
suffix:semicolon
id|len
op_assign
id|strbuf_read
c_func
(paren
op_amp
id|buffer
comma
id|cp.out
comma
l_int|1024
)paren
suffix:semicolon
id|close
c_func
(paren
id|cp.out
)paren
suffix:semicolon
r_if
c_cond
(paren
id|finish_command
c_func
(paren
op_amp
id|cp
)paren
op_logical_or
id|len
OL
l_int|0
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;stash failed&quot;
)paren
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
multiline_comment|/* no changes */
r_return
l_int|1
suffix:semicolon
id|strbuf_setlen
c_func
(paren
op_amp
id|buffer
comma
id|buffer.len
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1
c_func
(paren
id|buffer.buf
comma
id|stash
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;not a valid object: %s&quot;
)paren
comma
id|buffer.buf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|read_empty
r_static
r_void
id|read_empty
c_func
(paren
r_int
r_const
r_char
op_star
id|sha1
comma
r_int
id|verbose
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_const
r_char
op_star
id|args
(braket
l_int|7
)braket
suffix:semicolon
id|args
(braket
id|i
op_increment
)braket
op_assign
l_string|&quot;read-tree&quot;
suffix:semicolon
r_if
c_cond
(paren
id|verbose
)paren
id|args
(braket
id|i
op_increment
)braket
op_assign
l_string|&quot;-v&quot;
suffix:semicolon
id|args
(braket
id|i
op_increment
)braket
op_assign
l_string|&quot;-m&quot;
suffix:semicolon
id|args
(braket
id|i
op_increment
)braket
op_assign
l_string|&quot;-u&quot;
suffix:semicolon
id|args
(braket
id|i
op_increment
)braket
op_assign
id|EMPTY_TREE_SHA1_HEX
suffix:semicolon
id|args
(braket
id|i
op_increment
)braket
op_assign
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
suffix:semicolon
id|args
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|run_command_v_opt
c_func
(paren
id|args
comma
id|RUN_GIT_CMD
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;read-tree failed&quot;
)paren
)paren
suffix:semicolon
)brace
DECL|function|reset_hard
r_static
r_void
id|reset_hard
c_func
(paren
r_int
r_const
r_char
op_star
id|sha1
comma
r_int
id|verbose
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_const
r_char
op_star
id|args
(braket
l_int|6
)braket
suffix:semicolon
id|args
(braket
id|i
op_increment
)braket
op_assign
l_string|&quot;read-tree&quot;
suffix:semicolon
r_if
c_cond
(paren
id|verbose
)paren
id|args
(braket
id|i
op_increment
)braket
op_assign
l_string|&quot;-v&quot;
suffix:semicolon
id|args
(braket
id|i
op_increment
)braket
op_assign
l_string|&quot;--reset&quot;
suffix:semicolon
id|args
(braket
id|i
op_increment
)braket
op_assign
l_string|&quot;-u&quot;
suffix:semicolon
id|args
(braket
id|i
op_increment
)braket
op_assign
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
suffix:semicolon
id|args
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|run_command_v_opt
c_func
(paren
id|args
comma
id|RUN_GIT_CMD
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;read-tree failed&quot;
)paren
)paren
suffix:semicolon
)brace
DECL|function|restore_state
r_static
r_void
id|restore_state
c_func
(paren
r_const
r_int
r_char
op_star
id|head
comma
r_const
r_int
r_char
op_star
id|stash
)paren
(brace
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
r_const
r_char
op_star
id|args
(braket
)braket
op_assign
(brace
l_string|&quot;stash&quot;
comma
l_string|&quot;apply&quot;
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
r_if
c_cond
(paren
id|is_null_sha1
c_func
(paren
id|stash
)paren
)paren
r_return
suffix:semicolon
id|reset_hard
c_func
(paren
id|head
comma
l_int|1
)paren
suffix:semicolon
id|args
(braket
l_int|2
)braket
op_assign
id|sha1_to_hex
c_func
(paren
id|stash
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * It is OK to ignore error here, for example when there was&n;&t; * nothing to restore.&n;&t; */
id|run_command_v_opt
c_func
(paren
id|args
comma
id|RUN_GIT_CMD
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
id|refresh_cache
c_func
(paren
id|REFRESH_QUIET
)paren
suffix:semicolon
)brace
multiline_comment|/* This is called when no merge was necessary. */
DECL|function|finish_up_to_date
r_static
r_void
id|finish_up_to_date
c_func
(paren
r_const
r_char
op_star
id|msg
)paren
(brace
r_if
c_cond
(paren
id|verbosity
op_ge
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;%s%s&bslash;n&quot;
comma
id|squash
ques
c_cond
id|_
c_func
(paren
l_string|&quot; (nothing to squash)&quot;
)paren
suffix:colon
l_string|&quot;&quot;
comma
id|msg
)paren
suffix:semicolon
id|drop_save
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|squash_message
r_static
r_void
id|squash_message
c_func
(paren
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_struct
id|rev_info
id|rev
suffix:semicolon
r_struct
id|strbuf
id|out
op_assign
id|STRBUF_INIT
suffix:semicolon
r_struct
id|commit_list
op_star
id|j
suffix:semicolon
r_const
r_char
op_star
id|filename
suffix:semicolon
r_int
id|fd
suffix:semicolon
r_struct
id|pretty_print_context
id|ctx
op_assign
(brace
l_int|0
)brace
suffix:semicolon
id|printf
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Squash commit -- not updating HEAD&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|filename
op_assign
id|git_path
c_func
(paren
l_string|&quot;SQUASH_MSG&quot;
)paren
suffix:semicolon
id|fd
op_assign
id|open
c_func
(paren
id|filename
comma
id|O_WRONLY
op_or
id|O_CREAT
comma
l_int|0666
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Could not write to &squot;%s&squot;&quot;
)paren
comma
id|filename
)paren
suffix:semicolon
id|init_revisions
c_func
(paren
op_amp
id|rev
comma
l_int|NULL
)paren
suffix:semicolon
id|rev.ignore_merges
op_assign
l_int|1
suffix:semicolon
id|rev.commit_format
op_assign
id|CMIT_FMT_MEDIUM
suffix:semicolon
id|commit-&gt;object.flags
op_or_assign
id|UNINTERESTING
suffix:semicolon
id|add_pending_object
c_func
(paren
op_amp
id|rev
comma
op_amp
id|commit-&gt;object
comma
l_int|NULL
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|remoteheads
suffix:semicolon
id|j
suffix:semicolon
id|j
op_assign
id|j-&gt;next
)paren
id|add_pending_object
c_func
(paren
op_amp
id|rev
comma
op_amp
id|j-&gt;item-&gt;object
comma
l_int|NULL
)paren
suffix:semicolon
id|setup_revisions
c_func
(paren
l_int|0
comma
l_int|NULL
comma
op_amp
id|rev
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prepare_revision_walk
c_func
(paren
op_amp
id|rev
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;revision walk setup failed&quot;
)paren
)paren
suffix:semicolon
id|ctx.abbrev
op_assign
id|rev.abbrev
suffix:semicolon
id|ctx.date_mode
op_assign
id|rev.date_mode
suffix:semicolon
id|ctx.fmt
op_assign
id|rev.commit_format
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|out
comma
l_string|&quot;Squashed commit of the following:&bslash;n&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|commit
op_assign
id|get_revision
c_func
(paren
op_amp
id|rev
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|strbuf_addch
c_func
(paren
op_amp
id|out
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
id|out
comma
l_string|&quot;commit %s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|commit-&gt;object.sha1
)paren
)paren
suffix:semicolon
id|pretty_print_commit
c_func
(paren
op_amp
id|ctx
comma
id|commit
comma
op_amp
id|out
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|write
c_func
(paren
id|fd
comma
id|out.buf
comma
id|out.len
)paren
OL
l_int|0
)paren
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Writing SQUASH_MSG&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|close
c_func
(paren
id|fd
)paren
)paren
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Finishing SQUASH_MSG&quot;
)paren
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|out
)paren
suffix:semicolon
)brace
DECL|function|finish
r_static
r_void
id|finish
c_func
(paren
r_struct
id|commit
op_star
id|head_commit
comma
r_const
r_int
r_char
op_star
id|new_head
comma
r_const
r_char
op_star
id|msg
)paren
(brace
r_struct
id|strbuf
id|reflog_message
op_assign
id|STRBUF_INIT
suffix:semicolon
r_const
r_int
r_char
op_star
id|head
op_assign
id|head_commit-&gt;object.sha1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|msg
)paren
id|strbuf_addstr
c_func
(paren
op_amp
id|reflog_message
comma
id|getenv
c_func
(paren
l_string|&quot;GIT_REFLOG_ACTION&quot;
)paren
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|verbosity
op_ge
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|msg
)paren
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
id|reflog_message
comma
l_string|&quot;%s: %s&quot;
comma
id|getenv
c_func
(paren
l_string|&quot;GIT_REFLOG_ACTION&quot;
)paren
comma
id|msg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|squash
)paren
(brace
id|squash_message
c_func
(paren
id|head_commit
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|verbosity
op_ge
l_int|0
op_logical_and
op_logical_neg
id|merge_msg.len
)paren
id|printf
c_func
(paren
id|_
c_func
(paren
l_string|&quot;No merge message -- not updating HEAD&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_else
(brace
r_const
r_char
op_star
id|argv_gc_auto
(braket
)braket
op_assign
(brace
l_string|&quot;gc&quot;
comma
l_string|&quot;--auto&quot;
comma
l_int|NULL
)brace
suffix:semicolon
id|update_ref
c_func
(paren
id|reflog_message.buf
comma
l_string|&quot;HEAD&quot;
comma
id|new_head
comma
id|head
comma
l_int|0
comma
id|DIE_ON_ERR
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * We ignore errors in &squot;gc --auto&squot;, since the&n;&t;&t;&t; * user should see them.&n;&t;&t;&t; */
id|run_command_v_opt
c_func
(paren
id|argv_gc_auto
comma
id|RUN_GIT_CMD
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|new_head
op_logical_and
id|show_diffstat
)paren
(brace
r_struct
id|diff_options
id|opts
suffix:semicolon
id|diff_setup
c_func
(paren
op_amp
id|opts
)paren
suffix:semicolon
id|opts.output_format
op_or_assign
id|DIFF_FORMAT_SUMMARY
op_or
id|DIFF_FORMAT_DIFFSTAT
suffix:semicolon
id|opts.detect_rename
op_assign
id|DIFF_DETECT_RENAME
suffix:semicolon
r_if
c_cond
(paren
id|diff_setup_done
c_func
(paren
op_amp
id|opts
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;diff_setup_done failed&quot;
)paren
)paren
suffix:semicolon
id|diff_tree_sha1
c_func
(paren
id|head
comma
id|new_head
comma
l_string|&quot;&quot;
comma
op_amp
id|opts
)paren
suffix:semicolon
id|diffcore_std
c_func
(paren
op_amp
id|opts
)paren
suffix:semicolon
id|diff_flush
c_func
(paren
op_amp
id|opts
)paren
suffix:semicolon
)brace
multiline_comment|/* Run a post-merge hook */
id|run_hook
c_func
(paren
l_int|NULL
comma
l_string|&quot;post-merge&quot;
comma
id|squash
ques
c_cond
l_string|&quot;1&quot;
suffix:colon
l_string|&quot;0&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|reflog_message
)paren
suffix:semicolon
)brace
multiline_comment|/* Get the name for the merge commit&squot;s message. */
DECL|function|merge_name
r_static
r_void
id|merge_name
c_func
(paren
r_const
r_char
op_star
id|remote
comma
r_struct
id|strbuf
op_star
id|msg
)paren
(brace
r_struct
id|commit
op_star
id|remote_head
suffix:semicolon
r_int
r_char
id|branch_head
(braket
l_int|20
)braket
suffix:semicolon
r_struct
id|strbuf
id|buf
op_assign
id|STRBUF_INIT
suffix:semicolon
r_struct
id|strbuf
id|bname
op_assign
id|STRBUF_INIT
suffix:semicolon
r_const
r_char
op_star
id|ptr
suffix:semicolon
r_char
op_star
id|found_ref
suffix:semicolon
r_int
id|len
comma
id|early
suffix:semicolon
id|strbuf_branchname
c_func
(paren
op_amp
id|bname
comma
id|remote
)paren
suffix:semicolon
id|remote
op_assign
id|bname.buf
suffix:semicolon
id|memset
c_func
(paren
id|branch_head
comma
l_int|0
comma
r_sizeof
(paren
id|branch_head
)paren
)paren
suffix:semicolon
id|remote_head
op_assign
id|get_merge_parent
c_func
(paren
id|remote
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|remote_head
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;&squot;%s&squot; does not point to a commit&quot;
)paren
comma
id|remote
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dwim_ref
c_func
(paren
id|remote
comma
id|strlen
c_func
(paren
id|remote
)paren
comma
id|branch_head
comma
op_amp
id|found_ref
)paren
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|found_ref
comma
l_string|&quot;refs/heads/&quot;
)paren
)paren
(brace
id|strbuf_addf
c_func
(paren
id|msg
comma
l_string|&quot;%s&bslash;t&bslash;tbranch &squot;%s&squot; of .&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|branch_head
)paren
comma
id|remote
)paren
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|found_ref
comma
l_string|&quot;refs/tags/&quot;
)paren
)paren
(brace
id|strbuf_addf
c_func
(paren
id|msg
comma
l_string|&quot;%s&bslash;t&bslash;ttag &squot;%s&squot; of .&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|branch_head
)paren
comma
id|remote
)paren
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|found_ref
comma
l_string|&quot;refs/remotes/&quot;
)paren
)paren
(brace
id|strbuf_addf
c_func
(paren
id|msg
comma
l_string|&quot;%s&bslash;t&bslash;tremote-tracking branch &squot;%s&squot; of .&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|branch_head
)paren
comma
id|remote
)paren
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
)brace
multiline_comment|/* See if remote matches &lt;name&gt;^^^.. or &lt;name&gt;~&lt;number&gt; */
r_for
c_loop
(paren
id|len
op_assign
l_int|0
comma
id|ptr
op_assign
id|remote
op_plus
id|strlen
c_func
(paren
id|remote
)paren
suffix:semicolon
id|remote
OL
id|ptr
op_logical_and
id|ptr
(braket
l_int|1
)braket
op_eq
l_char|&squot;^&squot;
suffix:semicolon
id|ptr
op_decrement
)paren
id|len
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|len
)paren
id|early
op_assign
l_int|1
suffix:semicolon
r_else
(brace
id|early
op_assign
l_int|0
suffix:semicolon
id|ptr
op_assign
id|strrchr
c_func
(paren
id|remote
comma
l_char|&squot;~&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ptr
)paren
(brace
r_int
id|seen_nonzero
op_assign
l_int|0
suffix:semicolon
id|len
op_increment
suffix:semicolon
multiline_comment|/* count ~ */
r_while
c_loop
(paren
op_star
op_increment
id|ptr
op_logical_and
id|isdigit
c_func
(paren
op_star
id|ptr
)paren
)paren
(brace
id|seen_nonzero
op_or_assign
(paren
op_star
id|ptr
op_ne
l_char|&squot;0&squot;
)paren
suffix:semicolon
id|len
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|ptr
)paren
id|len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* not ...~&lt;number&gt; */
r_else
r_if
c_cond
(paren
id|seen_nonzero
)paren
id|early
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|len
op_eq
l_int|1
)paren
id|early
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* &quot;name~&quot; is &quot;name~1&quot;! */
)brace
)brace
r_if
c_cond
(paren
id|len
)paren
(brace
r_struct
id|strbuf
id|truname
op_assign
id|STRBUF_INIT
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|truname
comma
l_string|&quot;refs/heads/&quot;
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|truname
comma
id|remote
)paren
suffix:semicolon
id|strbuf_setlen
c_func
(paren
op_amp
id|truname
comma
id|truname.len
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ref_exists
c_func
(paren
id|truname.buf
)paren
)paren
(brace
id|strbuf_addf
c_func
(paren
id|msg
comma
l_string|&quot;%s&bslash;t&bslash;tbranch &squot;%s&squot;%s of .&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|remote_head-&gt;object.sha1
)paren
comma
id|truname.buf
op_plus
l_int|11
comma
(paren
id|early
ques
c_cond
l_string|&quot; (early part)&quot;
suffix:colon
l_string|&quot;&quot;
)paren
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|truname
)paren
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|remote
comma
l_string|&quot;FETCH_HEAD&quot;
)paren
op_logical_and
op_logical_neg
id|access
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;FETCH_HEAD&quot;
)paren
comma
id|R_OK
)paren
)paren
(brace
r_const
r_char
op_star
id|filename
suffix:semicolon
id|FILE
op_star
id|fp
suffix:semicolon
r_struct
id|strbuf
id|line
op_assign
id|STRBUF_INIT
suffix:semicolon
r_char
op_star
id|ptr
suffix:semicolon
id|filename
op_assign
id|git_path
c_func
(paren
l_string|&quot;FETCH_HEAD&quot;
)paren
suffix:semicolon
id|fp
op_assign
id|fopen
c_func
(paren
id|filename
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fp
)paren
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;could not open &squot;%s&squot; for reading&quot;
)paren
comma
id|filename
)paren
suffix:semicolon
id|strbuf_getline
c_func
(paren
op_amp
id|line
comma
id|fp
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|fclose
c_func
(paren
id|fp
)paren
suffix:semicolon
id|ptr
op_assign
id|strstr
c_func
(paren
id|line.buf
comma
l_string|&quot;&bslash;tnot-for-merge&bslash;t&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ptr
)paren
id|strbuf_remove
c_func
(paren
op_amp
id|line
comma
id|ptr
op_minus
id|line.buf
op_plus
l_int|1
comma
l_int|13
)paren
suffix:semicolon
id|strbuf_addbuf
c_func
(paren
id|msg
comma
op_amp
id|line
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|line
)paren
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
id|strbuf_addf
c_func
(paren
id|msg
comma
l_string|&quot;%s&bslash;t&bslash;tcommit &squot;%s&squot;&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|remote_head-&gt;object.sha1
)paren
comma
id|remote
)paren
suffix:semicolon
id|cleanup
suffix:colon
id|strbuf_release
c_func
(paren
op_amp
id|buf
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|bname
)paren
suffix:semicolon
)brace
DECL|function|parse_branch_merge_options
r_static
r_void
id|parse_branch_merge_options
c_func
(paren
r_char
op_star
id|bmo
)paren
(brace
r_const
r_char
op_star
op_star
id|argv
suffix:semicolon
r_int
id|argc
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bmo
)paren
r_return
suffix:semicolon
id|argc
op_assign
id|split_cmdline
c_func
(paren
id|bmo
comma
op_amp
id|argv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|argc
OL
l_int|0
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Bad branch.%s.mergeoptions string: %s&quot;
)paren
comma
id|branch
comma
id|split_cmdline_strerror
c_func
(paren
id|argc
)paren
)paren
suffix:semicolon
id|argv
op_assign
id|xrealloc
c_func
(paren
id|argv
comma
r_sizeof
(paren
op_star
id|argv
)paren
op_star
(paren
id|argc
op_plus
l_int|2
)paren
)paren
suffix:semicolon
id|memmove
c_func
(paren
id|argv
op_plus
l_int|1
comma
id|argv
comma
r_sizeof
(paren
op_star
id|argv
)paren
op_star
(paren
id|argc
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|argc
op_increment
suffix:semicolon
id|argv
(braket
l_int|0
)braket
op_assign
l_string|&quot;branch.*.mergeoptions&quot;
suffix:semicolon
id|parse_options
c_func
(paren
id|argc
comma
id|argv
comma
l_int|NULL
comma
id|builtin_merge_options
comma
id|builtin_merge_usage
comma
l_int|0
)paren
suffix:semicolon
id|free
c_func
(paren
id|argv
)paren
suffix:semicolon
)brace
DECL|function|git_merge_config
r_static
r_int
id|git_merge_config
c_func
(paren
r_const
r_char
op_star
id|k
comma
r_const
r_char
op_star
id|v
comma
r_void
op_star
id|cb
)paren
(brace
r_int
id|status
suffix:semicolon
r_if
c_cond
(paren
id|branch
op_logical_and
op_logical_neg
id|prefixcmp
c_func
(paren
id|k
comma
l_string|&quot;branch.&quot;
)paren
op_logical_and
op_logical_neg
id|prefixcmp
c_func
(paren
id|k
op_plus
l_int|7
comma
id|branch
)paren
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|k
op_plus
l_int|7
op_plus
id|strlen
c_func
(paren
id|branch
)paren
comma
l_string|&quot;.mergeoptions&quot;
)paren
)paren
(brace
id|free
c_func
(paren
id|branch_mergeoptions
)paren
suffix:semicolon
id|branch_mergeoptions
op_assign
id|xstrdup
c_func
(paren
id|v
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|k
comma
l_string|&quot;merge.diffstat&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|k
comma
l_string|&quot;merge.stat&quot;
)paren
)paren
id|show_diffstat
op_assign
id|git_config_bool
c_func
(paren
id|k
comma
id|v
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|k
comma
l_string|&quot;pull.twohead&quot;
)paren
)paren
r_return
id|git_config_string
c_func
(paren
op_amp
id|pull_twohead
comma
id|k
comma
id|v
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|k
comma
l_string|&quot;pull.octopus&quot;
)paren
)paren
r_return
id|git_config_string
c_func
(paren
op_amp
id|pull_octopus
comma
id|k
comma
id|v
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|k
comma
l_string|&quot;merge.renormalize&quot;
)paren
)paren
id|option_renormalize
op_assign
id|git_config_bool
c_func
(paren
id|k
comma
id|v
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|k
comma
l_string|&quot;merge.ff&quot;
)paren
)paren
(brace
r_int
id|boolval
op_assign
id|git_config_maybe_bool
c_func
(paren
id|k
comma
id|v
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_le
id|boolval
)paren
(brace
id|allow_fast_forward
op_assign
id|boolval
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|v
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|v
comma
l_string|&quot;only&quot;
)paren
)paren
(brace
id|allow_fast_forward
op_assign
l_int|1
suffix:semicolon
id|fast_forward_only
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* do not barf on values from future versions of git */
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|k
comma
l_string|&quot;merge.defaulttoupstream&quot;
)paren
)paren
(brace
id|default_to_upstream
op_assign
id|git_config_bool
c_func
(paren
id|k
comma
id|v
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|status
op_assign
id|fmt_merge_msg_config
c_func
(paren
id|k
comma
id|v
comma
id|cb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
r_return
id|status
suffix:semicolon
id|status
op_assign
id|git_gpg_config
c_func
(paren
id|k
comma
id|v
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
r_return
id|status
suffix:semicolon
r_return
id|git_diff_ui_config
c_func
(paren
id|k
comma
id|v
comma
id|cb
)paren
suffix:semicolon
)brace
DECL|function|read_tree_trivial
r_static
r_int
id|read_tree_trivial
c_func
(paren
r_int
r_char
op_star
id|common
comma
r_int
r_char
op_star
id|head
comma
r_int
r_char
op_star
id|one
)paren
(brace
r_int
id|i
comma
id|nr_trees
op_assign
l_int|0
suffix:semicolon
r_struct
id|tree
op_star
id|trees
(braket
id|MAX_UNPACK_TREES
)braket
suffix:semicolon
r_struct
id|tree_desc
id|t
(braket
id|MAX_UNPACK_TREES
)braket
suffix:semicolon
r_struct
id|unpack_trees_options
id|opts
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|opts
comma
l_int|0
comma
r_sizeof
(paren
id|opts
)paren
)paren
suffix:semicolon
id|opts.head_idx
op_assign
l_int|2
suffix:semicolon
id|opts.src_index
op_assign
op_amp
id|the_index
suffix:semicolon
id|opts.dst_index
op_assign
op_amp
id|the_index
suffix:semicolon
id|opts.update
op_assign
l_int|1
suffix:semicolon
id|opts.verbose_update
op_assign
l_int|1
suffix:semicolon
id|opts.trivial_merges_only
op_assign
l_int|1
suffix:semicolon
id|opts.merge
op_assign
l_int|1
suffix:semicolon
id|trees
(braket
id|nr_trees
)braket
op_assign
id|parse_tree_indirect
c_func
(paren
id|common
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|trees
(braket
id|nr_trees
op_increment
)braket
)paren
r_return
l_int|1
suffix:semicolon
id|trees
(braket
id|nr_trees
)braket
op_assign
id|parse_tree_indirect
c_func
(paren
id|head
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|trees
(braket
id|nr_trees
op_increment
)braket
)paren
r_return
l_int|1
suffix:semicolon
id|trees
(braket
id|nr_trees
)braket
op_assign
id|parse_tree_indirect
c_func
(paren
id|one
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|trees
(braket
id|nr_trees
op_increment
)braket
)paren
r_return
l_int|1
suffix:semicolon
id|opts.fn
op_assign
id|threeway_merge
suffix:semicolon
id|cache_tree_free
c_func
(paren
op_amp
id|active_cache_tree
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_trees
suffix:semicolon
id|i
op_increment
)paren
(brace
id|parse_tree
c_func
(paren
id|trees
(braket
id|i
)braket
)paren
suffix:semicolon
id|init_tree_desc
c_func
(paren
id|t
op_plus
id|i
comma
id|trees
(braket
id|i
)braket
op_member_access_from_pointer
id|buffer
comma
id|trees
(braket
id|i
)braket
op_member_access_from_pointer
id|size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unpack_trees
c_func
(paren
id|nr_trees
comma
id|t
comma
op_amp
id|opts
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|write_tree_trivial
r_static
r_void
id|write_tree_trivial
c_func
(paren
r_int
r_char
op_star
id|sha1
)paren
(brace
r_if
c_cond
(paren
id|write_cache_as_tree
c_func
(paren
id|sha1
comma
l_int|0
comma
l_int|NULL
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;git write-tree failed to write a tree&quot;
)paren
)paren
suffix:semicolon
)brace
DECL|function|merge_argument
r_static
r_const
r_char
op_star
id|merge_argument
c_func
(paren
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_if
c_cond
(paren
id|commit
)paren
r_return
id|sha1_to_hex
c_func
(paren
id|commit-&gt;object.sha1
)paren
suffix:semicolon
r_else
r_return
id|EMPTY_TREE_SHA1_HEX
suffix:semicolon
)brace
DECL|function|try_merge_command
r_int
id|try_merge_command
c_func
(paren
r_const
r_char
op_star
id|strategy
comma
r_int
id|xopts_nr
comma
r_const
r_char
op_star
op_star
id|xopts
comma
r_struct
id|commit_list
op_star
id|common
comma
r_const
r_char
op_star
id|head_arg
comma
r_struct
id|commit_list
op_star
id|remotes
)paren
(brace
r_const
r_char
op_star
op_star
id|args
suffix:semicolon
r_int
id|i
op_assign
l_int|0
comma
id|x
op_assign
l_int|0
comma
id|ret
suffix:semicolon
r_struct
id|commit_list
op_star
id|j
suffix:semicolon
r_struct
id|strbuf
id|buf
op_assign
id|STRBUF_INIT
suffix:semicolon
id|args
op_assign
id|xmalloc
c_func
(paren
(paren
l_int|4
op_plus
id|xopts_nr
op_plus
id|commit_list_count
c_func
(paren
id|common
)paren
op_plus
id|commit_list_count
c_func
(paren
id|remotes
)paren
)paren
op_star
r_sizeof
(paren
r_char
op_star
)paren
)paren
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
id|buf
comma
l_string|&quot;merge-%s&quot;
comma
id|strategy
)paren
suffix:semicolon
id|args
(braket
id|i
op_increment
)braket
op_assign
id|buf.buf
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
id|xopts_nr
suffix:semicolon
id|x
op_increment
)paren
(brace
r_char
op_star
id|s
op_assign
id|xmalloc
c_func
(paren
id|strlen
c_func
(paren
id|xopts
(braket
id|x
)braket
)paren
op_plus
l_int|2
op_plus
l_int|1
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|s
comma
l_string|&quot;--&quot;
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|s
op_plus
l_int|2
comma
id|xopts
(braket
id|x
)braket
)paren
suffix:semicolon
id|args
(braket
id|i
op_increment
)braket
op_assign
id|s
suffix:semicolon
)brace
r_for
c_loop
(paren
id|j
op_assign
id|common
suffix:semicolon
id|j
suffix:semicolon
id|j
op_assign
id|j-&gt;next
)paren
id|args
(braket
id|i
op_increment
)braket
op_assign
id|xstrdup
c_func
(paren
id|merge_argument
c_func
(paren
id|j-&gt;item
)paren
)paren
suffix:semicolon
id|args
(braket
id|i
op_increment
)braket
op_assign
l_string|&quot;--&quot;
suffix:semicolon
id|args
(braket
id|i
op_increment
)braket
op_assign
id|head_arg
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|remotes
suffix:semicolon
id|j
suffix:semicolon
id|j
op_assign
id|j-&gt;next
)paren
id|args
(braket
id|i
op_increment
)braket
op_assign
id|xstrdup
c_func
(paren
id|merge_argument
c_func
(paren
id|j-&gt;item
)paren
)paren
suffix:semicolon
id|args
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|ret
op_assign
id|run_command_v_opt
c_func
(paren
id|args
comma
id|RUN_GIT_CMD
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|buf
)paren
suffix:semicolon
id|i
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
id|xopts_nr
suffix:semicolon
id|x
op_increment
)paren
id|free
c_func
(paren
(paren
r_void
op_star
)paren
id|args
(braket
id|i
op_increment
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|common
suffix:semicolon
id|j
suffix:semicolon
id|j
op_assign
id|j-&gt;next
)paren
id|free
c_func
(paren
(paren
r_void
op_star
)paren
id|args
(braket
id|i
op_increment
)braket
)paren
suffix:semicolon
id|i
op_add_assign
l_int|2
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|remotes
suffix:semicolon
id|j
suffix:semicolon
id|j
op_assign
id|j-&gt;next
)paren
id|free
c_func
(paren
(paren
r_void
op_star
)paren
id|args
(braket
id|i
op_increment
)braket
)paren
suffix:semicolon
id|free
c_func
(paren
id|args
)paren
suffix:semicolon
id|discard_cache
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_cache
c_func
(paren
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;failed to read the cache&quot;
)paren
)paren
suffix:semicolon
id|resolve_undo_clear
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|try_merge_strategy
r_static
r_int
id|try_merge_strategy
c_func
(paren
r_const
r_char
op_star
id|strategy
comma
r_struct
id|commit_list
op_star
id|common
comma
r_struct
id|commit
op_star
id|head
comma
r_const
r_char
op_star
id|head_arg
)paren
(brace
r_int
id|index_fd
suffix:semicolon
r_struct
id|lock_file
op_star
id|lock
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|lock_file
)paren
)paren
suffix:semicolon
id|index_fd
op_assign
id|hold_locked_index
c_func
(paren
id|lock
comma
l_int|1
)paren
suffix:semicolon
id|refresh_cache
c_func
(paren
id|REFRESH_QUIET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|active_cache_changed
op_logical_and
(paren
id|write_cache
c_func
(paren
id|index_fd
comma
id|active_cache
comma
id|active_nr
)paren
op_logical_or
id|commit_locked_index
c_func
(paren
id|lock
)paren
)paren
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Unable to write index.&quot;
)paren
)paren
suffix:semicolon
id|rollback_lock_file
c_func
(paren
id|lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|strategy
comma
l_string|&quot;recursive&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|strategy
comma
l_string|&quot;subtree&quot;
)paren
)paren
(brace
r_int
id|clean
comma
id|x
suffix:semicolon
r_struct
id|commit
op_star
id|result
suffix:semicolon
r_struct
id|lock_file
op_star
id|lock
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|lock_file
)paren
)paren
suffix:semicolon
r_int
id|index_fd
suffix:semicolon
r_struct
id|commit_list
op_star
id|reversed
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|merge_options
id|o
suffix:semicolon
r_struct
id|commit_list
op_star
id|j
suffix:semicolon
r_if
c_cond
(paren
id|remoteheads-&gt;next
)paren
(brace
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Not handling anything other than two heads merge.&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|2
suffix:semicolon
)brace
id|init_merge_options
c_func
(paren
op_amp
id|o
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|strategy
comma
l_string|&quot;subtree&quot;
)paren
)paren
id|o.subtree_shift
op_assign
l_string|&quot;&quot;
suffix:semicolon
id|o.renormalize
op_assign
id|option_renormalize
suffix:semicolon
id|o.show_rename_progress
op_assign
id|show_progress
op_eq
l_int|1
ques
c_cond
id|isatty
c_func
(paren
l_int|2
)paren
suffix:colon
id|show_progress
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
id|xopts_nr
suffix:semicolon
id|x
op_increment
)paren
r_if
c_cond
(paren
id|parse_merge_opt
c_func
(paren
op_amp
id|o
comma
id|xopts
(braket
id|x
)braket
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Unknown option for merge-recursive: -X%s&quot;
)paren
comma
id|xopts
(braket
id|x
)braket
)paren
suffix:semicolon
id|o.branch1
op_assign
id|head_arg
suffix:semicolon
id|o.branch2
op_assign
id|merge_remote_util
c_func
(paren
id|remoteheads-&gt;item
)paren
op_member_access_from_pointer
id|name
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|common
suffix:semicolon
id|j
suffix:semicolon
id|j
op_assign
id|j-&gt;next
)paren
id|commit_list_insert
c_func
(paren
id|j-&gt;item
comma
op_amp
id|reversed
)paren
suffix:semicolon
id|index_fd
op_assign
id|hold_locked_index
c_func
(paren
id|lock
comma
l_int|1
)paren
suffix:semicolon
id|clean
op_assign
id|merge_recursive
c_func
(paren
op_amp
id|o
comma
id|head
comma
id|remoteheads-&gt;item
comma
id|reversed
comma
op_amp
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|active_cache_changed
op_logical_and
(paren
id|write_cache
c_func
(paren
id|index_fd
comma
id|active_cache
comma
id|active_nr
)paren
op_logical_or
id|commit_locked_index
c_func
(paren
id|lock
)paren
)paren
)paren
id|die
(paren
id|_
c_func
(paren
l_string|&quot;unable to write %s&quot;
)paren
comma
id|get_index_file
c_func
(paren
)paren
)paren
suffix:semicolon
id|rollback_lock_file
c_func
(paren
id|lock
)paren
suffix:semicolon
r_return
id|clean
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_return
id|try_merge_command
c_func
(paren
id|strategy
comma
id|xopts_nr
comma
id|xopts
comma
id|common
comma
id|head_arg
comma
id|remoteheads
)paren
suffix:semicolon
)brace
)brace
DECL|function|count_diff_files
r_static
r_void
id|count_diff_files
c_func
(paren
r_struct
id|diff_queue_struct
op_star
id|q
comma
r_struct
id|diff_options
op_star
id|opt
comma
r_void
op_star
id|data
)paren
(brace
r_int
op_star
id|count
op_assign
id|data
suffix:semicolon
(paren
op_star
id|count
)paren
op_add_assign
id|q-&gt;nr
suffix:semicolon
)brace
DECL|function|count_unmerged_entries
r_static
r_int
id|count_unmerged_entries
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|ret
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|active_nr
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|ce_stage
c_func
(paren
id|active_cache
(braket
id|i
)braket
)paren
)paren
id|ret
op_increment
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|checkout_fast_forward
r_int
id|checkout_fast_forward
c_func
(paren
r_const
r_int
r_char
op_star
id|head
comma
r_const
r_int
r_char
op_star
id|remote
)paren
(brace
r_struct
id|tree
op_star
id|trees
(braket
id|MAX_UNPACK_TREES
)braket
suffix:semicolon
r_struct
id|unpack_trees_options
id|opts
suffix:semicolon
r_struct
id|tree_desc
id|t
(braket
id|MAX_UNPACK_TREES
)braket
suffix:semicolon
r_int
id|i
comma
id|fd
comma
id|nr_trees
op_assign
l_int|0
suffix:semicolon
r_struct
id|dir_struct
id|dir
suffix:semicolon
r_struct
id|lock_file
op_star
id|lock_file
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|lock_file
)paren
)paren
suffix:semicolon
id|refresh_cache
c_func
(paren
id|REFRESH_QUIET
)paren
suffix:semicolon
id|fd
op_assign
id|hold_locked_index
c_func
(paren
id|lock_file
comma
l_int|1
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|trees
comma
l_int|0
comma
r_sizeof
(paren
id|trees
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|opts
comma
l_int|0
comma
r_sizeof
(paren
id|opts
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|t
comma
l_int|0
comma
r_sizeof
(paren
id|t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|overwrite_ignore
)paren
(brace
id|memset
c_func
(paren
op_amp
id|dir
comma
l_int|0
comma
r_sizeof
(paren
id|dir
)paren
)paren
suffix:semicolon
id|dir.flags
op_or_assign
id|DIR_SHOW_IGNORED
suffix:semicolon
id|setup_standard_excludes
c_func
(paren
op_amp
id|dir
)paren
suffix:semicolon
id|opts.dir
op_assign
op_amp
id|dir
suffix:semicolon
)brace
id|opts.head_idx
op_assign
l_int|1
suffix:semicolon
id|opts.src_index
op_assign
op_amp
id|the_index
suffix:semicolon
id|opts.dst_index
op_assign
op_amp
id|the_index
suffix:semicolon
id|opts.update
op_assign
l_int|1
suffix:semicolon
id|opts.verbose_update
op_assign
l_int|1
suffix:semicolon
id|opts.merge
op_assign
l_int|1
suffix:semicolon
id|opts.fn
op_assign
id|twoway_merge
suffix:semicolon
id|setup_unpack_trees_porcelain
c_func
(paren
op_amp
id|opts
comma
l_string|&quot;merge&quot;
)paren
suffix:semicolon
id|trees
(braket
id|nr_trees
)braket
op_assign
id|parse_tree_indirect
c_func
(paren
id|head
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|trees
(braket
id|nr_trees
op_increment
)braket
)paren
r_return
l_int|1
suffix:semicolon
id|trees
(braket
id|nr_trees
)braket
op_assign
id|parse_tree_indirect
c_func
(paren
id|remote
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|trees
(braket
id|nr_trees
op_increment
)braket
)paren
r_return
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_trees
suffix:semicolon
id|i
op_increment
)paren
(brace
id|parse_tree
c_func
(paren
id|trees
(braket
id|i
)braket
)paren
suffix:semicolon
id|init_tree_desc
c_func
(paren
id|t
op_plus
id|i
comma
id|trees
(braket
id|i
)braket
op_member_access_from_pointer
id|buffer
comma
id|trees
(braket
id|i
)braket
op_member_access_from_pointer
id|size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unpack_trees
c_func
(paren
id|nr_trees
comma
id|t
comma
op_amp
id|opts
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|write_cache
c_func
(paren
id|fd
comma
id|active_cache
comma
id|active_nr
)paren
op_logical_or
id|commit_locked_index
c_func
(paren
id|lock_file
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;unable to write new index file&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|split_merge_strategies
r_static
r_void
id|split_merge_strategies
c_func
(paren
r_const
r_char
op_star
id|string
comma
r_struct
id|strategy
op_star
op_star
id|list
comma
r_int
op_star
id|nr
comma
r_int
op_star
id|alloc
)paren
(brace
r_char
op_star
id|p
comma
op_star
id|q
comma
op_star
id|buf
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|string
)paren
r_return
suffix:semicolon
id|buf
op_assign
id|xstrdup
c_func
(paren
id|string
)paren
suffix:semicolon
id|q
op_assign
id|buf
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|p
op_assign
id|strchr
c_func
(paren
id|q
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
(brace
id|ALLOC_GROW
c_func
(paren
op_star
id|list
comma
op_star
id|nr
op_plus
l_int|1
comma
op_star
id|alloc
)paren
suffix:semicolon
(paren
op_star
id|list
)paren
(braket
(paren
op_star
id|nr
)paren
op_increment
)braket
dot
id|name
op_assign
id|xstrdup
c_func
(paren
id|q
)paren
suffix:semicolon
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
op_star
id|p
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|ALLOC_GROW
c_func
(paren
op_star
id|list
comma
op_star
id|nr
op_plus
l_int|1
comma
op_star
id|alloc
)paren
suffix:semicolon
(paren
op_star
id|list
)paren
(braket
(paren
op_star
id|nr
)paren
op_increment
)braket
dot
id|name
op_assign
id|xstrdup
c_func
(paren
id|q
)paren
suffix:semicolon
id|q
op_assign
op_increment
id|p
suffix:semicolon
)brace
)brace
)brace
DECL|function|add_strategies
r_static
r_void
id|add_strategies
c_func
(paren
r_const
r_char
op_star
id|string
comma
r_int
id|attr
)paren
(brace
r_struct
id|strategy
op_star
id|list
op_assign
l_int|NULL
suffix:semicolon
r_int
id|list_alloc
op_assign
l_int|0
comma
id|list_nr
op_assign
l_int|0
comma
id|i
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|list
comma
l_int|0
comma
r_sizeof
(paren
id|list
)paren
)paren
suffix:semicolon
id|split_merge_strategies
c_func
(paren
id|string
comma
op_amp
id|list
comma
op_amp
id|list_nr
comma
op_amp
id|list_alloc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|list_nr
suffix:semicolon
id|i
op_increment
)paren
id|append_strategy
c_func
(paren
id|get_strategy
c_func
(paren
id|list
(braket
id|i
)braket
dot
id|name
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|all_strategy
)paren
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|all_strategy
(braket
id|i
)braket
dot
id|attr
op_amp
id|attr
)paren
id|append_strategy
c_func
(paren
op_amp
id|all_strategy
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
DECL|function|write_merge_msg
r_static
r_void
id|write_merge_msg
c_func
(paren
r_struct
id|strbuf
op_star
id|msg
)paren
(brace
r_const
r_char
op_star
id|filename
op_assign
id|git_path
c_func
(paren
l_string|&quot;MERGE_MSG&quot;
)paren
suffix:semicolon
r_int
id|fd
op_assign
id|open
c_func
(paren
id|filename
comma
id|O_WRONLY
op_or
id|O_CREAT
comma
l_int|0666
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Could not open &squot;%s&squot; for writing&quot;
)paren
comma
id|filename
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write_in_full
c_func
(paren
id|fd
comma
id|msg-&gt;buf
comma
id|msg-&gt;len
)paren
op_ne
id|msg-&gt;len
)paren
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Could not write to &squot;%s&squot;&quot;
)paren
comma
id|filename
)paren
suffix:semicolon
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
)brace
DECL|function|read_merge_msg
r_static
r_void
id|read_merge_msg
c_func
(paren
r_struct
id|strbuf
op_star
id|msg
)paren
(brace
r_const
r_char
op_star
id|filename
op_assign
id|git_path
c_func
(paren
l_string|&quot;MERGE_MSG&quot;
)paren
suffix:semicolon
id|strbuf_reset
c_func
(paren
id|msg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strbuf_read_file
c_func
(paren
id|msg
comma
id|filename
comma
l_int|0
)paren
OL
l_int|0
)paren
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Could not read from &squot;%s&squot;&quot;
)paren
comma
id|filename
)paren
suffix:semicolon
)brace
r_static
r_void
id|write_merge_state
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|function|abort_commit
r_static
r_void
id|abort_commit
c_func
(paren
r_const
r_char
op_star
id|err_msg
)paren
(brace
r_if
c_cond
(paren
id|err_msg
)paren
id|error
c_func
(paren
l_string|&quot;%s&quot;
comma
id|err_msg
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
id|_
c_func
(paren
l_string|&quot;Not committing merge; use &squot;git commit&squot; to complete the merge.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|write_merge_state
c_func
(paren
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|prepare_to_commit
r_static
r_void
id|prepare_to_commit
c_func
(paren
r_void
)paren
(brace
r_struct
id|strbuf
id|msg
op_assign
id|STRBUF_INIT
suffix:semicolon
id|strbuf_addbuf
c_func
(paren
op_amp
id|msg
comma
op_amp
id|merge_msg
)paren
suffix:semicolon
id|strbuf_addch
c_func
(paren
op_amp
id|msg
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|write_merge_msg
c_func
(paren
op_amp
id|msg
)paren
suffix:semicolon
id|run_hook
c_func
(paren
id|get_index_file
c_func
(paren
)paren
comma
l_string|&quot;prepare-commit-msg&quot;
comma
id|git_path
c_func
(paren
l_string|&quot;MERGE_MSG&quot;
)paren
comma
l_string|&quot;merge&quot;
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|option_edit
)paren
(brace
r_if
c_cond
(paren
id|launch_editor
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;MERGE_MSG&quot;
)paren
comma
l_int|NULL
comma
l_int|NULL
)paren
)paren
id|abort_commit
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
id|read_merge_msg
c_func
(paren
op_amp
id|msg
)paren
suffix:semicolon
id|stripspace
c_func
(paren
op_amp
id|msg
comma
id|option_edit
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|msg.len
)paren
id|abort_commit
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Empty commit message.&quot;
)paren
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|merge_msg
)paren
suffix:semicolon
id|strbuf_addbuf
c_func
(paren
op_amp
id|merge_msg
comma
op_amp
id|msg
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|msg
)paren
suffix:semicolon
)brace
DECL|function|merge_trivial
r_static
r_int
id|merge_trivial
c_func
(paren
r_struct
id|commit
op_star
id|head
)paren
(brace
r_int
r_char
id|result_tree
(braket
l_int|20
)braket
comma
id|result_commit
(braket
l_int|20
)braket
suffix:semicolon
r_struct
id|commit_list
op_star
id|parent
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|parent
)paren
)paren
suffix:semicolon
id|write_tree_trivial
c_func
(paren
id|result_tree
)paren
suffix:semicolon
id|printf
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Wonderful.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|parent-&gt;item
op_assign
id|head
suffix:semicolon
id|parent-&gt;next
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|parent-&gt;next
)paren
)paren
suffix:semicolon
id|parent-&gt;next-&gt;item
op_assign
id|remoteheads-&gt;item
suffix:semicolon
id|parent-&gt;next-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|prepare_to_commit
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|commit_tree
c_func
(paren
op_amp
id|merge_msg
comma
id|result_tree
comma
id|parent
comma
id|result_commit
comma
l_int|NULL
comma
id|sign_commit
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;failed to write commit object&quot;
)paren
)paren
suffix:semicolon
id|finish
c_func
(paren
id|head
comma
id|result_commit
comma
l_string|&quot;In-index merge&quot;
)paren
suffix:semicolon
id|drop_save
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|finish_automerge
r_static
r_int
id|finish_automerge
c_func
(paren
r_struct
id|commit
op_star
id|head
comma
r_struct
id|commit_list
op_star
id|common
comma
r_int
r_char
op_star
id|result_tree
comma
r_const
r_char
op_star
id|wt_strategy
)paren
(brace
r_struct
id|commit_list
op_star
id|parents
op_assign
l_int|NULL
comma
op_star
id|j
suffix:semicolon
r_struct
id|strbuf
id|buf
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
r_char
id|result_commit
(braket
l_int|20
)braket
suffix:semicolon
id|free_commit_list
c_func
(paren
id|common
)paren
suffix:semicolon
r_if
c_cond
(paren
id|allow_fast_forward
)paren
(brace
id|parents
op_assign
id|remoteheads
suffix:semicolon
id|commit_list_insert
c_func
(paren
id|head
comma
op_amp
id|parents
)paren
suffix:semicolon
id|parents
op_assign
id|reduce_heads
c_func
(paren
id|parents
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|commit_list
op_star
op_star
id|pptr
op_assign
op_amp
id|parents
suffix:semicolon
id|pptr
op_assign
op_amp
id|commit_list_insert
c_func
(paren
id|head
comma
id|pptr
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|remoteheads
suffix:semicolon
id|j
suffix:semicolon
id|j
op_assign
id|j-&gt;next
)paren
id|pptr
op_assign
op_amp
id|commit_list_insert
c_func
(paren
id|j-&gt;item
comma
id|pptr
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
)brace
id|strbuf_addch
c_func
(paren
op_amp
id|merge_msg
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|prepare_to_commit
c_func
(paren
)paren
suffix:semicolon
id|free_commit_list
c_func
(paren
id|remoteheads
)paren
suffix:semicolon
r_if
c_cond
(paren
id|commit_tree
c_func
(paren
op_amp
id|merge_msg
comma
id|result_tree
comma
id|parents
comma
id|result_commit
comma
l_int|NULL
comma
id|sign_commit
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;failed to write commit object&quot;
)paren
)paren
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
id|buf
comma
l_string|&quot;Merge made by the &squot;%s&squot; strategy.&quot;
comma
id|wt_strategy
)paren
suffix:semicolon
id|finish
c_func
(paren
id|head
comma
id|result_commit
comma
id|buf.buf
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|buf
)paren
suffix:semicolon
id|drop_save
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|suggest_conflicts
r_static
r_int
id|suggest_conflicts
c_func
(paren
r_int
id|renormalizing
)paren
(brace
r_const
r_char
op_star
id|filename
suffix:semicolon
id|FILE
op_star
id|fp
suffix:semicolon
r_int
id|pos
suffix:semicolon
id|filename
op_assign
id|git_path
c_func
(paren
l_string|&quot;MERGE_MSG&quot;
)paren
suffix:semicolon
id|fp
op_assign
id|fopen
c_func
(paren
id|filename
comma
l_string|&quot;a&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fp
)paren
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Could not open &squot;%s&squot; for writing&quot;
)paren
comma
id|filename
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|fp
comma
l_string|&quot;&bslash;nConflicts:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pos
op_assign
l_int|0
suffix:semicolon
id|pos
OL
id|active_nr
suffix:semicolon
id|pos
op_increment
)paren
(brace
r_struct
id|cache_entry
op_star
id|ce
op_assign
id|active_cache
(braket
id|pos
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ce_stage
c_func
(paren
id|ce
)paren
)paren
(brace
id|fprintf
c_func
(paren
id|fp
comma
l_string|&quot;&bslash;t%s&bslash;n&quot;
comma
id|ce-&gt;name
)paren
suffix:semicolon
r_while
c_loop
(paren
id|pos
op_plus
l_int|1
OL
id|active_nr
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|ce-&gt;name
comma
id|active_cache
(braket
id|pos
op_plus
l_int|1
)braket
op_member_access_from_pointer
id|name
)paren
)paren
id|pos
op_increment
suffix:semicolon
)brace
)brace
id|fclose
c_func
(paren
id|fp
)paren
suffix:semicolon
id|rerere
c_func
(paren
id|allow_rerere_auto
)paren
suffix:semicolon
id|printf
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Automatic merge failed; &quot;
l_string|&quot;fix conflicts and then commit the result.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|is_old_style_invocation
r_static
r_struct
id|commit
op_star
id|is_old_style_invocation
c_func
(paren
r_int
id|argc
comma
r_const
r_char
op_star
op_star
id|argv
comma
r_const
r_int
r_char
op_star
id|head
)paren
(brace
r_struct
id|commit
op_star
id|second_token
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|argc
OG
l_int|2
)paren
(brace
r_int
r_char
id|second_sha1
(braket
l_int|20
)braket
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
id|second_sha1
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|second_token
op_assign
id|lookup_commit_reference_gently
c_func
(paren
id|second_sha1
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|second_token
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;&squot;%s&squot; is not a commit&quot;
)paren
comma
id|argv
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hashcmp
c_func
(paren
id|second_token-&gt;object.sha1
comma
id|head
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|second_token
suffix:semicolon
)brace
DECL|function|evaluate_result
r_static
r_int
id|evaluate_result
c_func
(paren
r_void
)paren
(brace
r_int
id|cnt
op_assign
l_int|0
suffix:semicolon
r_struct
id|rev_info
id|rev
suffix:semicolon
multiline_comment|/* Check how many files differ. */
id|init_revisions
c_func
(paren
op_amp
id|rev
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
id|setup_revisions
c_func
(paren
l_int|0
comma
l_int|NULL
comma
op_amp
id|rev
comma
l_int|NULL
)paren
suffix:semicolon
id|rev.diffopt.output_format
op_or_assign
id|DIFF_FORMAT_CALLBACK
suffix:semicolon
id|rev.diffopt.format_callback
op_assign
id|count_diff_files
suffix:semicolon
id|rev.diffopt.format_callback_data
op_assign
op_amp
id|cnt
suffix:semicolon
id|run_diff_files
c_func
(paren
op_amp
id|rev
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check how many unmerged entries are&n;&t; * there.&n;&t; */
id|cnt
op_add_assign
id|count_unmerged_entries
c_func
(paren
)paren
suffix:semicolon
r_return
id|cnt
suffix:semicolon
)brace
multiline_comment|/*&n; * Pretend as if the user told us to merge with the tracking&n; * branch we have for the upstream of the current branch&n; */
DECL|function|setup_with_upstream
r_static
r_int
id|setup_with_upstream
c_func
(paren
r_const
r_char
op_star
op_star
op_star
id|argv
)paren
(brace
r_struct
id|branch
op_star
id|branch
op_assign
id|branch_get
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
r_const
r_char
op_star
op_star
id|args
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|branch
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;No current branch.&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|branch-&gt;remote
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;No remote for the current branch.&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|branch-&gt;merge_nr
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;No default upstream defined for the current branch.&quot;
)paren
)paren
suffix:semicolon
id|args
op_assign
id|xcalloc
c_func
(paren
id|branch-&gt;merge_nr
op_plus
l_int|1
comma
r_sizeof
(paren
r_char
op_star
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|branch-&gt;merge_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|branch-&gt;merge
(braket
id|i
)braket
op_member_access_from_pointer
id|dst
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;No remote tracking branch for %s from %s&quot;
)paren
comma
id|branch-&gt;merge
(braket
id|i
)braket
op_member_access_from_pointer
id|src
comma
id|branch-&gt;remote_name
)paren
suffix:semicolon
id|args
(braket
id|i
)braket
op_assign
id|branch-&gt;merge
(braket
id|i
)braket
op_member_access_from_pointer
id|dst
suffix:semicolon
)brace
id|args
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
op_star
id|argv
op_assign
id|args
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
DECL|function|write_merge_state
r_static
r_void
id|write_merge_state
c_func
(paren
r_void
)paren
(brace
r_const
r_char
op_star
id|filename
suffix:semicolon
r_int
id|fd
suffix:semicolon
r_struct
id|commit_list
op_star
id|j
suffix:semicolon
r_struct
id|strbuf
id|buf
op_assign
id|STRBUF_INIT
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|remoteheads
suffix:semicolon
id|j
suffix:semicolon
id|j
op_assign
id|j-&gt;next
)paren
(brace
r_int
r_const
r_char
op_star
id|sha1
suffix:semicolon
r_struct
id|commit
op_star
id|c
op_assign
id|j-&gt;item
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;util
op_logical_and
id|merge_remote_util
c_func
(paren
id|c
)paren
op_member_access_from_pointer
id|obj
)paren
(brace
id|sha1
op_assign
id|merge_remote_util
c_func
(paren
id|c
)paren
op_member_access_from_pointer
id|obj-&gt;sha1
suffix:semicolon
)brace
r_else
(brace
id|sha1
op_assign
id|c-&gt;object.sha1
suffix:semicolon
)brace
id|strbuf_addf
c_func
(paren
op_amp
id|buf
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
)brace
id|filename
op_assign
id|git_path
c_func
(paren
l_string|&quot;MERGE_HEAD&quot;
)paren
suffix:semicolon
id|fd
op_assign
id|open
c_func
(paren
id|filename
comma
id|O_WRONLY
op_or
id|O_CREAT
comma
l_int|0666
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Could not open &squot;%s&squot; for writing&quot;
)paren
comma
id|filename
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write_in_full
c_func
(paren
id|fd
comma
id|buf.buf
comma
id|buf.len
)paren
op_ne
id|buf.len
)paren
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Could not write to &squot;%s&squot;&quot;
)paren
comma
id|filename
)paren
suffix:semicolon
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
id|strbuf_addch
c_func
(paren
op_amp
id|merge_msg
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|write_merge_msg
c_func
(paren
op_amp
id|merge_msg
)paren
suffix:semicolon
id|filename
op_assign
id|git_path
c_func
(paren
l_string|&quot;MERGE_MODE&quot;
)paren
suffix:semicolon
id|fd
op_assign
id|open
c_func
(paren
id|filename
comma
id|O_WRONLY
op_or
id|O_CREAT
op_or
id|O_TRUNC
comma
l_int|0666
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Could not open &squot;%s&squot; for writing&quot;
)paren
comma
id|filename
)paren
suffix:semicolon
id|strbuf_reset
c_func
(paren
op_amp
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|allow_fast_forward
)paren
id|strbuf_addf
c_func
(paren
op_amp
id|buf
comma
l_string|&quot;no-ff&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write_in_full
c_func
(paren
id|fd
comma
id|buf.buf
comma
id|buf.len
)paren
op_ne
id|buf.len
)paren
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Could not write to &squot;%s&squot;&quot;
)paren
comma
id|filename
)paren
suffix:semicolon
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
)brace
DECL|function|cmd_merge
r_int
id|cmd_merge
c_func
(paren
r_int
id|argc
comma
r_const
r_char
op_star
op_star
id|argv
comma
r_const
r_char
op_star
id|prefix
)paren
(brace
r_int
r_char
id|result_tree
(braket
l_int|20
)braket
suffix:semicolon
r_int
r_char
id|stash
(braket
l_int|20
)braket
suffix:semicolon
r_int
r_char
id|head_sha1
(braket
l_int|20
)braket
suffix:semicolon
r_struct
id|commit
op_star
id|head_commit
suffix:semicolon
r_struct
id|strbuf
id|buf
op_assign
id|STRBUF_INIT
suffix:semicolon
r_const
r_char
op_star
id|head_arg
suffix:semicolon
r_int
id|flag
comma
id|i
comma
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|best_cnt
op_assign
l_int|1
comma
id|merge_was_ok
op_assign
l_int|0
comma
id|automerge_was_ok
op_assign
l_int|0
suffix:semicolon
r_struct
id|commit_list
op_star
id|common
op_assign
l_int|NULL
suffix:semicolon
r_const
r_char
op_star
id|best_strategy
op_assign
l_int|NULL
comma
op_star
id|wt_strategy
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|commit_list
op_star
op_star
id|remotes
op_assign
op_amp
id|remoteheads
suffix:semicolon
r_void
op_star
id|branch_to_free
suffix:semicolon
r_if
c_cond
(paren
id|argc
op_eq
l_int|2
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
l_string|&quot;-h&quot;
)paren
)paren
id|usage_with_options
c_func
(paren
id|builtin_merge_usage
comma
id|builtin_merge_options
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check if we are _not_ on a detached HEAD, i.e. if there is a&n;&t; * current branch.&n;&t; */
id|branch
op_assign
id|branch_to_free
op_assign
id|resolve_refdup
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|head_sha1
comma
l_int|0
comma
op_amp
id|flag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|branch
op_logical_and
op_logical_neg
id|prefixcmp
c_func
(paren
id|branch
comma
l_string|&quot;refs/heads/&quot;
)paren
)paren
id|branch
op_add_assign
l_int|11
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|branch
op_logical_or
id|is_null_sha1
c_func
(paren
id|head_sha1
)paren
)paren
id|head_commit
op_assign
l_int|NULL
suffix:semicolon
r_else
id|head_commit
op_assign
id|lookup_commit_or_die
c_func
(paren
id|head_sha1
comma
l_string|&quot;HEAD&quot;
)paren
suffix:semicolon
id|git_config
c_func
(paren
id|git_merge_config
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|branch_mergeoptions
)paren
id|parse_branch_merge_options
c_func
(paren
id|branch_mergeoptions
)paren
suffix:semicolon
id|argc
op_assign
id|parse_options
c_func
(paren
id|argc
comma
id|argv
comma
id|prefix
comma
id|builtin_merge_options
comma
id|builtin_merge_usage
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shortlog_len
OL
l_int|0
)paren
id|shortlog_len
op_assign
(paren
id|merge_log_config
OG
l_int|0
)paren
ques
c_cond
id|merge_log_config
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|verbosity
OL
l_int|0
op_logical_and
id|show_progress
op_eq
l_int|1
)paren
id|show_progress
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|abort_current_merge
)paren
(brace
r_int
id|nargc
op_assign
l_int|2
suffix:semicolon
r_const
r_char
op_star
id|nargv
(braket
)braket
op_assign
(brace
l_string|&quot;reset&quot;
comma
l_string|&quot;--merge&quot;
comma
l_int|NULL
)brace
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file_exists
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;MERGE_HEAD&quot;
)paren
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;There is no merge to abort (MERGE_HEAD missing).&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* Invoke &squot;git reset --merge&squot; */
id|ret
op_assign
id|cmd_reset
c_func
(paren
id|nargc
comma
id|nargv
comma
id|prefix
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_if
c_cond
(paren
id|read_cache_unmerged
c_func
(paren
)paren
)paren
id|die_resolve_conflict
c_func
(paren
l_string|&quot;merge&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file_exists
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;MERGE_HEAD&quot;
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * There is no unmerged entry, don&squot;t advise &squot;git&n;&t;&t; * add/rm &lt;file&gt;&squot;, just &squot;git commit&squot;.&n;&t;&t; */
r_if
c_cond
(paren
id|advice_resolve_conflict
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;You have not concluded your merge (MERGE_HEAD exists).&bslash;n&quot;
l_string|&quot;Please, commit your changes before you can merge.&quot;
)paren
)paren
suffix:semicolon
r_else
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;You have not concluded your merge (MERGE_HEAD exists).&quot;
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file_exists
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;CHERRY_PICK_HEAD&quot;
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|advice_resolve_conflict
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;You have not concluded your cherry-pick (CHERRY_PICK_HEAD exists).&bslash;n&quot;
l_string|&quot;Please, commit your changes before you can merge.&quot;
)paren
)paren
suffix:semicolon
r_else
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;You have not concluded your cherry-pick (CHERRY_PICK_HEAD exists).&quot;
)paren
)paren
suffix:semicolon
)brace
id|resolve_undo_clear
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|verbosity
OL
l_int|0
)paren
id|show_diffstat
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|squash
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|allow_fast_forward
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;You cannot combine --squash with --no-ff.&quot;
)paren
)paren
suffix:semicolon
id|option_commit
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|allow_fast_forward
op_logical_and
id|fast_forward_only
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;You cannot combine --no-ff with --ff-only.&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|abort_current_merge
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|argc
)paren
(brace
r_if
c_cond
(paren
id|default_to_upstream
)paren
id|argc
op_assign
id|setup_with_upstream
c_func
(paren
op_amp
id|argv
)paren
suffix:semicolon
r_else
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;No commit specified and merge.defaultToUpstream not set.&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|argc
op_eq
l_int|1
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|argv
(braket
l_int|0
)braket
comma
l_string|&quot;-&quot;
)paren
)paren
id|argv
(braket
l_int|0
)braket
op_assign
l_string|&quot;@{-1}&quot;
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|argc
)paren
id|usage_with_options
c_func
(paren
id|builtin_merge_usage
comma
id|builtin_merge_options
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This could be traditional &quot;merge &lt;msg&gt; HEAD &lt;commit&gt;...&quot;  and&n;&t; * the way we can tell it is to see if the second token is HEAD,&n;&t; * but some people might have misused the interface and used a&n;&t; * committish that is the same as HEAD there instead.&n;&t; * Traditional format never would have &quot;-m&quot; so it is an&n;&t; * additional safety measure to check for it.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|have_message
op_logical_and
id|head_commit
op_logical_and
id|is_old_style_invocation
c_func
(paren
id|argc
comma
id|argv
comma
id|head_commit-&gt;object.sha1
)paren
)paren
(brace
id|strbuf_addstr
c_func
(paren
op_amp
id|merge_msg
comma
id|argv
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|head_arg
op_assign
id|argv
(braket
l_int|1
)braket
suffix:semicolon
id|argv
op_add_assign
l_int|2
suffix:semicolon
id|argc
op_sub_assign
l_int|2
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|head_commit
)paren
(brace
r_struct
id|commit
op_star
id|remote_head
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the merged head is a valid one there is no reason&n;&t;&t; * to forbid &quot;git merge&quot; into a branch yet to be born.&n;&t;&t; * We do the same for &quot;git pull&quot;.&n;&t;&t; */
r_if
c_cond
(paren
id|argc
op_ne
l_int|1
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Can merge only exactly one commit into &quot;
l_string|&quot;empty head&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|squash
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Squash commit into empty head not supported yet&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|allow_fast_forward
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Non-fast-forward commit does not make sense into &quot;
l_string|&quot;an empty head&quot;
)paren
)paren
suffix:semicolon
id|remote_head
op_assign
id|get_merge_parent
c_func
(paren
id|argv
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|remote_head
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;%s - not something we can merge&quot;
)paren
comma
id|argv
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|read_empty
c_func
(paren
id|remote_head-&gt;object.sha1
comma
l_int|0
)paren
suffix:semicolon
id|update_ref
c_func
(paren
l_string|&quot;initial pull&quot;
comma
l_string|&quot;HEAD&quot;
comma
id|remote_head-&gt;object.sha1
comma
l_int|NULL
comma
l_int|0
comma
id|DIE_ON_ERR
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_else
(brace
r_struct
id|strbuf
id|merge_names
op_assign
id|STRBUF_INIT
suffix:semicolon
multiline_comment|/* We are invoked directly as the first-class UI. */
id|head_arg
op_assign
l_string|&quot;HEAD&quot;
suffix:semicolon
multiline_comment|/*&n;&t;&t; * All the rest are the commits being merged; prepare&n;&t;&t; * the standard merge summary message to be appended&n;&t;&t; * to the given message.&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|argc
suffix:semicolon
id|i
op_increment
)paren
id|merge_name
c_func
(paren
id|argv
(braket
id|i
)braket
comma
op_amp
id|merge_names
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|have_message
op_logical_or
id|shortlog_len
)paren
(brace
r_struct
id|fmt_merge_msg_opts
id|opts
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|opts
comma
l_int|0
comma
r_sizeof
(paren
id|opts
)paren
)paren
suffix:semicolon
id|opts.add_title
op_assign
op_logical_neg
id|have_message
suffix:semicolon
id|opts.shortlog_len
op_assign
id|shortlog_len
suffix:semicolon
id|fmt_merge_msg
c_func
(paren
op_amp
id|merge_names
comma
op_amp
id|merge_msg
comma
op_amp
id|opts
)paren
suffix:semicolon
r_if
c_cond
(paren
id|merge_msg.len
)paren
id|strbuf_setlen
c_func
(paren
op_amp
id|merge_msg
comma
id|merge_msg.len
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|head_commit
op_logical_or
op_logical_neg
id|argc
)paren
id|usage_with_options
c_func
(paren
id|builtin_merge_usage
comma
id|builtin_merge_options
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|buf
comma
l_string|&quot;merge&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|argc
suffix:semicolon
id|i
op_increment
)paren
id|strbuf_addf
c_func
(paren
op_amp
id|buf
comma
l_string|&quot; %s&quot;
comma
id|argv
(braket
id|i
)braket
)paren
suffix:semicolon
id|setenv
c_func
(paren
l_string|&quot;GIT_REFLOG_ACTION&quot;
comma
id|buf.buf
comma
l_int|0
)paren
suffix:semicolon
id|strbuf_reset
c_func
(paren
op_amp
id|buf
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|argc
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
id|get_merge_parent
c_func
(paren
id|argv
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|commit
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;%s - not something we can merge&quot;
)paren
comma
id|argv
(braket
id|i
)braket
)paren
suffix:semicolon
id|remotes
op_assign
op_amp
id|commit_list_insert
c_func
(paren
id|commit
comma
id|remotes
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
id|buf
comma
l_string|&quot;GITHEAD_%s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|commit-&gt;object.sha1
)paren
)paren
suffix:semicolon
id|setenv
c_func
(paren
id|buf.buf
comma
id|argv
(braket
id|i
)braket
comma
l_int|1
)paren
suffix:semicolon
id|strbuf_reset
c_func
(paren
op_amp
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|merge_remote_util
c_func
(paren
id|commit
)paren
op_logical_and
id|merge_remote_util
c_func
(paren
id|commit
)paren
op_member_access_from_pointer
id|obj
op_logical_and
id|merge_remote_util
c_func
(paren
id|commit
)paren
op_member_access_from_pointer
id|obj-&gt;type
op_eq
id|OBJ_TAG
)paren
(brace
id|option_edit
op_assign
l_int|1
suffix:semicolon
id|allow_fast_forward
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|use_strategies
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|remoteheads-&gt;next
)paren
id|add_strategies
c_func
(paren
id|pull_twohead
comma
id|DEFAULT_TWOHEAD
)paren
suffix:semicolon
r_else
id|add_strategies
c_func
(paren
id|pull_octopus
comma
id|DEFAULT_OCTOPUS
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|use_strategies_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|use_strategies
(braket
id|i
)braket
op_member_access_from_pointer
id|attr
op_amp
id|NO_FAST_FORWARD
)paren
id|allow_fast_forward
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|use_strategies
(braket
id|i
)braket
op_member_access_from_pointer
id|attr
op_amp
id|NO_TRIVIAL
)paren
id|allow_trivial
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|remoteheads-&gt;next
)paren
id|common
op_assign
id|get_merge_bases
c_func
(paren
id|head_commit
comma
id|remoteheads-&gt;item
comma
l_int|1
)paren
suffix:semicolon
r_else
(brace
r_struct
id|commit_list
op_star
id|list
op_assign
id|remoteheads
suffix:semicolon
id|commit_list_insert
c_func
(paren
id|head_commit
comma
op_amp
id|list
)paren
suffix:semicolon
id|common
op_assign
id|get_octopus_merge_bases
c_func
(paren
id|list
)paren
suffix:semicolon
id|free
c_func
(paren
id|list
)paren
suffix:semicolon
)brace
id|update_ref
c_func
(paren
l_string|&quot;updating ORIG_HEAD&quot;
comma
l_string|&quot;ORIG_HEAD&quot;
comma
id|head_commit-&gt;object.sha1
comma
l_int|NULL
comma
l_int|0
comma
id|DIE_ON_ERR
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|common
)paren
suffix:semicolon
multiline_comment|/* No common ancestors found. We need a real merge. */
r_else
r_if
c_cond
(paren
op_logical_neg
id|remoteheads-&gt;next
op_logical_and
op_logical_neg
id|common-&gt;next
op_logical_and
id|common-&gt;item
op_eq
id|remoteheads-&gt;item
)paren
(brace
multiline_comment|/*&n;&t;&t; * If head can reach all the merge then we are up to date.&n;&t;&t; * but first the most common case of merging one remote.&n;&t;&t; */
id|finish_up_to_date
c_func
(paren
l_string|&quot;Already up-to-date.&quot;
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|allow_fast_forward
op_logical_and
op_logical_neg
id|remoteheads-&gt;next
op_logical_and
op_logical_neg
id|common-&gt;next
op_logical_and
op_logical_neg
id|hashcmp
c_func
(paren
id|common-&gt;item-&gt;object.sha1
comma
id|head_commit-&gt;object.sha1
)paren
)paren
(brace
multiline_comment|/* Again the most common case of merging one remote. */
r_struct
id|strbuf
id|msg
op_assign
id|STRBUF_INIT
suffix:semicolon
r_struct
id|commit
op_star
id|commit
suffix:semicolon
r_char
id|hex
(braket
l_int|41
)braket
suffix:semicolon
id|strcpy
c_func
(paren
id|hex
comma
id|find_unique_abbrev
c_func
(paren
id|head_commit-&gt;object.sha1
comma
id|DEFAULT_ABBREV
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|verbosity
op_ge
l_int|0
)paren
id|printf
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Updating %s..%s&bslash;n&quot;
)paren
comma
id|hex
comma
id|find_unique_abbrev
c_func
(paren
id|remoteheads-&gt;item-&gt;object.sha1
comma
id|DEFAULT_ABBREV
)paren
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|msg
comma
l_string|&quot;Fast-forward&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|have_message
)paren
id|strbuf_addstr
c_func
(paren
op_amp
id|msg
comma
l_string|&quot; (no commit created; -m option ignored)&quot;
)paren
suffix:semicolon
id|commit
op_assign
id|remoteheads-&gt;item
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|commit
)paren
(brace
id|ret
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_if
c_cond
(paren
id|checkout_fast_forward
c_func
(paren
id|head_commit-&gt;object.sha1
comma
id|commit-&gt;object.sha1
)paren
)paren
(brace
id|ret
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|finish
c_func
(paren
id|head_commit
comma
id|commit-&gt;object.sha1
comma
id|msg.buf
)paren
suffix:semicolon
id|drop_save
c_func
(paren
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|remoteheads-&gt;next
op_logical_and
id|common-&gt;next
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We are not doing octopus and not fast-forward.  Need&n;&t;&t; * a real merge.&n;&t;&t; */
r_else
r_if
c_cond
(paren
op_logical_neg
id|remoteheads-&gt;next
op_logical_and
op_logical_neg
id|common-&gt;next
op_logical_and
id|option_commit
)paren
(brace
multiline_comment|/*&n;&t;&t; * We are not doing octopus, not fast-forward, and have&n;&t;&t; * only one common.&n;&t;&t; */
id|refresh_cache
c_func
(paren
id|REFRESH_QUIET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|allow_trivial
op_logical_and
op_logical_neg
id|fast_forward_only
)paren
(brace
multiline_comment|/* See if it is really trivial. */
id|git_committer_info
c_func
(paren
id|IDENT_ERROR_ON_NO_NAME
)paren
suffix:semicolon
id|printf
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Trying really trivial in-index merge...&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|read_tree_trivial
c_func
(paren
id|common-&gt;item-&gt;object.sha1
comma
id|head_commit-&gt;object.sha1
comma
id|remoteheads-&gt;item-&gt;object.sha1
)paren
)paren
(brace
id|ret
op_assign
id|merge_trivial
c_func
(paren
id|head_commit
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|printf
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Nope.&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * An octopus.  If we can reach all the remote we are up&n;&t;&t; * to date.&n;&t;&t; */
r_int
id|up_to_date
op_assign
l_int|1
suffix:semicolon
r_struct
id|commit_list
op_star
id|j
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|remoteheads
suffix:semicolon
id|j
suffix:semicolon
id|j
op_assign
id|j-&gt;next
)paren
(brace
r_struct
id|commit_list
op_star
id|common_one
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Here we *have* to calculate the individual&n;&t;&t;&t; * merge_bases again, otherwise &quot;git merge HEAD^&n;&t;&t;&t; * HEAD^^&quot; would be missed.&n;&t;&t;&t; */
id|common_one
op_assign
id|get_merge_bases
c_func
(paren
id|head_commit
comma
id|j-&gt;item
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hashcmp
c_func
(paren
id|common_one-&gt;item-&gt;object.sha1
comma
id|j-&gt;item-&gt;object.sha1
)paren
)paren
(brace
id|up_to_date
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|up_to_date
)paren
(brace
id|finish_up_to_date
c_func
(paren
l_string|&quot;Already up-to-date. Yeeah!&quot;
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|fast_forward_only
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Not possible to fast-forward, aborting.&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* We are going to make a new commit. */
id|git_committer_info
c_func
(paren
id|IDENT_ERROR_ON_NO_NAME
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * At this point, we need a real merge.  No matter what strategy&n;&t; * we use, it would operate on the index, possibly affecting the&n;&t; * working tree, and when resolved cleanly, have the desired&n;&t; * tree in the index -- this means that the index must be in&n;&t; * sync with the head commit.  The strategies are responsible&n;&t; * to ensure this.&n;&t; */
r_if
c_cond
(paren
id|use_strategies_nr
op_eq
l_int|1
op_logical_or
multiline_comment|/*&n;&t;     * Stash away the local changes so that we can try more than one.&n;&t;     */
id|save_state
c_func
(paren
id|stash
)paren
)paren
id|hashcpy
c_func
(paren
id|stash
comma
id|null_sha1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|use_strategies_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
(brace
id|printf
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Rewinding the tree to pristine...&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|restore_state
c_func
(paren
id|head_commit-&gt;object.sha1
comma
id|stash
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|use_strategies_nr
op_ne
l_int|1
)paren
id|printf
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Trying merge strategy %s...&bslash;n&quot;
)paren
comma
id|use_strategies
(braket
id|i
)braket
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Remember which strategy left the state in the working&n;&t;&t; * tree.&n;&t;&t; */
id|wt_strategy
op_assign
id|use_strategies
(braket
id|i
)braket
op_member_access_from_pointer
id|name
suffix:semicolon
id|ret
op_assign
id|try_merge_strategy
c_func
(paren
id|use_strategies
(braket
id|i
)braket
op_member_access_from_pointer
id|name
comma
id|common
comma
id|head_commit
comma
id|head_arg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|option_commit
op_logical_and
op_logical_neg
id|ret
)paren
(brace
id|merge_was_ok
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * This is necessary here just to avoid writing&n;&t;&t;&t; * the tree, but later we will *not* exit with&n;&t;&t;&t; * status code 1 because merge_was_ok is set.&n;&t;&t;&t; */
id|ret
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * The backend exits with 1 when conflicts are&n;&t;&t;&t; * left to be resolved, with 2 when it does not&n;&t;&t;&t; * handle the given merge at all.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ret
op_eq
l_int|1
)paren
(brace
r_int
id|cnt
op_assign
id|evaluate_result
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|best_cnt
op_le
l_int|0
op_logical_or
id|cnt
op_le
id|best_cnt
)paren
(brace
id|best_strategy
op_assign
id|use_strategies
(braket
id|i
)braket
op_member_access_from_pointer
id|name
suffix:semicolon
id|best_cnt
op_assign
id|cnt
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|merge_was_ok
)paren
r_break
suffix:semicolon
r_else
r_continue
suffix:semicolon
)brace
multiline_comment|/* Automerge succeeded. */
id|write_tree_trivial
c_func
(paren
id|result_tree
)paren
suffix:semicolon
id|automerge_was_ok
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we have a resulting tree, that means the strategy module&n;&t; * auto resolved the merge cleanly.&n;&t; */
r_if
c_cond
(paren
id|automerge_was_ok
)paren
(brace
id|ret
op_assign
id|finish_automerge
c_func
(paren
id|head_commit
comma
id|common
comma
id|result_tree
comma
id|wt_strategy
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Pick the result from the best strategy and have the user fix&n;&t; * it up.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|best_strategy
)paren
(brace
id|restore_state
c_func
(paren
id|head_commit-&gt;object.sha1
comma
id|stash
)paren
suffix:semicolon
r_if
c_cond
(paren
id|use_strategies_nr
OG
l_int|1
)paren
id|fprintf
c_func
(paren
id|stderr
comma
id|_
c_func
(paren
l_string|&quot;No merge strategy handled the merge.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_else
id|fprintf
c_func
(paren
id|stderr
comma
id|_
c_func
(paren
l_string|&quot;Merge with strategy %s failed.&bslash;n&quot;
)paren
comma
id|use_strategies
(braket
l_int|0
)braket
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
id|ret
op_assign
l_int|2
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|best_strategy
op_eq
id|wt_strategy
)paren
suffix:semicolon
multiline_comment|/* We already have its result in the working tree. */
r_else
(brace
id|printf
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Rewinding the tree to pristine...&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|restore_state
c_func
(paren
id|head_commit-&gt;object.sha1
comma
id|stash
)paren
suffix:semicolon
id|printf
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Using the %s to prepare resolving by hand.&bslash;n&quot;
)paren
comma
id|best_strategy
)paren
suffix:semicolon
id|try_merge_strategy
c_func
(paren
id|best_strategy
comma
id|common
comma
id|head_commit
comma
id|head_arg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|squash
)paren
id|finish
c_func
(paren
id|head_commit
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_else
id|write_merge_state
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|merge_was_ok
)paren
id|fprintf
c_func
(paren
id|stderr
comma
id|_
c_func
(paren
l_string|&quot;Automatic merge went well; &quot;
l_string|&quot;stopped before committing as requested&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_else
id|ret
op_assign
id|suggest_conflicts
c_func
(paren
id|option_renormalize
)paren
suffix:semicolon
id|done
suffix:colon
id|free
c_func
(paren
id|branch_to_free
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
eof
