macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;commit.h&quot;
macro_line|#include &quot;refs.h&quot;
macro_line|#include &quot;builtin.h&quot;
macro_line|#include &quot;color.h&quot;
macro_line|#include &quot;parse-options.h&quot;
DECL|variable|show_branch_usage
r_static
r_const
r_char
op_star
id|show_branch_usage
(braket
)braket
op_assign
(brace
id|N_
c_func
(paren
l_string|&quot;git show-branch [-a | --all] [-r | --remotes] [--topo-order | --date-order]&bslash;n&quot;
l_string|&quot;&t;&t;[--current] [--color[=&lt;when&gt;] | --no-color] [--sparse]&bslash;n&quot;
l_string|&quot;&t;&t;[--more=&lt;n&gt; | --list | --independent | --merge-base]&bslash;n&quot;
l_string|&quot;&t;&t;[--no-name | --sha1-name] [--topics] [(&lt;rev&gt; | &lt;glob&gt;)...]&quot;
)paren
comma
id|N_
c_func
(paren
l_string|&quot;git show-branch (-g | --reflog)[=&lt;n&gt;[,&lt;base&gt;]] [--list] [&lt;ref&gt;]&quot;
)paren
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|showbranch_use_color
r_static
r_int
id|showbranch_use_color
op_assign
l_int|1
suffix:semicolon
DECL|variable|default_num
r_static
r_int
id|default_num
suffix:semicolon
DECL|variable|default_alloc
r_static
r_int
id|default_alloc
suffix:semicolon
DECL|variable|default_arg
r_static
r_const
r_char
op_star
op_star
id|default_arg
suffix:semicolon
DECL|macro|UNINTERESTING
mdefine_line|#define UNINTERESTING&t;01
DECL|macro|REV_SHIFT
mdefine_line|#define REV_SHIFT&t; 2
DECL|macro|MAX_REVS
mdefine_line|#define MAX_REVS&t;(FLAG_BITS - REV_SHIFT) /* should not exceed bits_per_int - REV_SHIFT */
DECL|macro|DEFAULT_REFLOG
mdefine_line|#define DEFAULT_REFLOG&t;4
DECL|function|get_color_code
r_static
r_const
r_char
op_star
id|get_color_code
c_func
(paren
r_int
id|idx
)paren
(brace
r_if
c_cond
(paren
id|want_color
c_func
(paren
id|showbranch_use_color
)paren
)paren
r_return
id|column_colors_ansi
(braket
id|idx
op_mod
id|column_colors_ansi_max
)braket
suffix:semicolon
r_return
l_string|&quot;&quot;
suffix:semicolon
)brace
DECL|function|get_color_reset_code
r_static
r_const
r_char
op_star
id|get_color_reset_code
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|want_color
c_func
(paren
id|showbranch_use_color
)paren
)paren
r_return
id|GIT_COLOR_RESET
suffix:semicolon
r_return
l_string|&quot;&quot;
suffix:semicolon
)brace
DECL|function|interesting
r_static
r_struct
id|commit
op_star
id|interesting
c_func
(paren
r_struct
id|commit_list
op_star
id|list
)paren
(brace
r_while
c_loop
(paren
id|list
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
id|list-&gt;item
suffix:semicolon
id|list
op_assign
id|list-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|commit-&gt;object.flags
op_amp
id|UNINTERESTING
)paren
r_continue
suffix:semicolon
r_return
id|commit
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|pop_one_commit
r_static
r_struct
id|commit
op_star
id|pop_one_commit
c_func
(paren
r_struct
id|commit_list
op_star
op_star
id|list_p
)paren
(brace
r_struct
id|commit
op_star
id|commit
suffix:semicolon
r_struct
id|commit_list
op_star
id|list
suffix:semicolon
id|list
op_assign
op_star
id|list_p
suffix:semicolon
id|commit
op_assign
id|list-&gt;item
suffix:semicolon
op_star
id|list_p
op_assign
id|list-&gt;next
suffix:semicolon
id|free
c_func
(paren
id|list
)paren
suffix:semicolon
r_return
id|commit
suffix:semicolon
)brace
DECL|struct|commit_name
r_struct
id|commit_name
(brace
DECL|member|head_name
r_const
r_char
op_star
id|head_name
suffix:semicolon
multiline_comment|/* which head&squot;s ancestor? */
DECL|member|generation
r_int
id|generation
suffix:semicolon
multiline_comment|/* how many parents away from head_name */
)brace
suffix:semicolon
multiline_comment|/* Name the commit as nth generation ancestor of head_name;&n; * we count only the first-parent relationship for naming purposes.&n; */
DECL|function|name_commit
r_static
r_void
id|name_commit
c_func
(paren
r_struct
id|commit
op_star
id|commit
comma
r_const
r_char
op_star
id|head_name
comma
r_int
id|nth
)paren
(brace
r_struct
id|commit_name
op_star
id|name
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|commit-&gt;util
)paren
id|commit-&gt;util
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|commit_name
)paren
)paren
suffix:semicolon
id|name
op_assign
id|commit-&gt;util
suffix:semicolon
id|name-&gt;head_name
op_assign
id|head_name
suffix:semicolon
id|name-&gt;generation
op_assign
id|nth
suffix:semicolon
)brace
multiline_comment|/* Parent is the first parent of the commit.  We may name it&n; * as (n+1)th generation ancestor of the same head_name as&n; * commit is nth generation ancestor of, if that generation&n; * number is better than the name it already has.&n; */
DECL|function|name_parent
r_static
r_void
id|name_parent
c_func
(paren
r_struct
id|commit
op_star
id|commit
comma
r_struct
id|commit
op_star
id|parent
)paren
(brace
r_struct
id|commit_name
op_star
id|commit_name
op_assign
id|commit-&gt;util
suffix:semicolon
r_struct
id|commit_name
op_star
id|parent_name
op_assign
id|parent-&gt;util
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|commit_name
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parent_name
op_logical_or
id|commit_name-&gt;generation
op_plus
l_int|1
OL
id|parent_name-&gt;generation
)paren
id|name_commit
c_func
(paren
id|parent
comma
id|commit_name-&gt;head_name
comma
id|commit_name-&gt;generation
op_plus
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|name_first_parent_chain
r_static
r_int
id|name_first_parent_chain
c_func
(paren
r_struct
id|commit
op_star
id|c
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|c
)paren
(brace
r_struct
id|commit
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;util
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;parents
)paren
r_break
suffix:semicolon
id|p
op_assign
id|c-&gt;parents-&gt;item
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;util
)paren
(brace
id|name_parent
c_func
(paren
id|c
comma
id|p
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
id|c
op_assign
id|p
suffix:semicolon
)brace
r_return
id|i
suffix:semicolon
)brace
DECL|function|name_commits
r_static
r_void
id|name_commits
c_func
(paren
r_struct
id|commit_list
op_star
id|list
comma
r_struct
id|commit
op_star
op_star
id|rev
comma
r_char
op_star
op_star
id|ref_name
comma
r_int
id|num_rev
)paren
(brace
r_struct
id|commit_list
op_star
id|cl
suffix:semicolon
r_struct
id|commit
op_star
id|c
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* First give names to the given heads */
r_for
c_loop
(paren
id|cl
op_assign
id|list
suffix:semicolon
id|cl
suffix:semicolon
id|cl
op_assign
id|cl-&gt;next
)paren
(brace
id|c
op_assign
id|cl-&gt;item
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;util
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_rev
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|rev
(braket
id|i
)braket
op_eq
id|c
)paren
(brace
id|name_commit
c_func
(paren
id|c
comma
id|ref_name
(braket
id|i
)braket
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Then commits on the first parent ancestry chain */
r_do
(brace
id|i
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|cl
op_assign
id|list
suffix:semicolon
id|cl
suffix:semicolon
id|cl
op_assign
id|cl-&gt;next
)paren
(brace
id|i
op_add_assign
id|name_first_parent_chain
c_func
(paren
id|cl-&gt;item
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|i
)paren
suffix:semicolon
multiline_comment|/* Finally, any unnamed commits */
r_do
(brace
id|i
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|cl
op_assign
id|list
suffix:semicolon
id|cl
suffix:semicolon
id|cl
op_assign
id|cl-&gt;next
)paren
(brace
r_struct
id|commit_list
op_star
id|parents
suffix:semicolon
r_struct
id|commit_name
op_star
id|n
suffix:semicolon
r_int
id|nth
suffix:semicolon
id|c
op_assign
id|cl-&gt;item
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;util
)paren
r_continue
suffix:semicolon
id|n
op_assign
id|c-&gt;util
suffix:semicolon
id|parents
op_assign
id|c-&gt;parents
suffix:semicolon
id|nth
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|parents
)paren
(brace
r_struct
id|commit
op_star
id|p
op_assign
id|parents-&gt;item
suffix:semicolon
r_struct
id|strbuf
id|newname
op_assign
id|STRBUF_INIT
suffix:semicolon
id|parents
op_assign
id|parents-&gt;next
suffix:semicolon
id|nth
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;util
)paren
r_continue
suffix:semicolon
r_switch
c_cond
(paren
id|n-&gt;generation
)paren
(brace
r_case
l_int|0
suffix:colon
id|strbuf_addstr
c_func
(paren
op_amp
id|newname
comma
id|n-&gt;head_name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|strbuf_addf
c_func
(paren
op_amp
id|newname
comma
l_string|&quot;%s^&quot;
comma
id|n-&gt;head_name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|strbuf_addf
c_func
(paren
op_amp
id|newname
comma
l_string|&quot;%s~%d&quot;
comma
id|n-&gt;head_name
comma
id|n-&gt;generation
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nth
op_eq
l_int|1
)paren
id|strbuf_addch
c_func
(paren
op_amp
id|newname
comma
l_char|&squot;^&squot;
)paren
suffix:semicolon
r_else
id|strbuf_addf
c_func
(paren
op_amp
id|newname
comma
l_string|&quot;^%d&quot;
comma
id|nth
)paren
suffix:semicolon
id|name_commit
c_func
(paren
id|p
comma
id|strbuf_detach
c_func
(paren
op_amp
id|newname
comma
l_int|NULL
)paren
comma
l_int|0
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
id|name_first_parent_chain
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
id|i
)paren
suffix:semicolon
)brace
DECL|function|mark_seen
r_static
r_int
id|mark_seen
c_func
(paren
r_struct
id|commit
op_star
id|commit
comma
r_struct
id|commit_list
op_star
op_star
id|seen_p
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|commit-&gt;object.flags
)paren
(brace
id|commit_list_insert
c_func
(paren
id|commit
comma
id|seen_p
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|join_revs
r_static
r_void
id|join_revs
c_func
(paren
r_struct
id|commit_list
op_star
op_star
id|list_p
comma
r_struct
id|commit_list
op_star
op_star
id|seen_p
comma
r_int
id|num_rev
comma
r_int
id|extra
)paren
(brace
r_int
id|all_mask
op_assign
(paren
(paren
l_int|1u
op_lshift
(paren
id|REV_SHIFT
op_plus
id|num_rev
)paren
)paren
l_int|1
)paren
suffix:semicolon
r_int
id|all_revs
op_assign
id|all_mask
op_amp
op_complement
(paren
(paren
l_int|1u
op_lshift
id|REV_SHIFT
)paren
l_int|1
)paren
suffix:semicolon
r_while
c_loop
(paren
op_star
id|list_p
)paren
(brace
r_struct
id|commit_list
op_star
id|parents
suffix:semicolon
r_int
id|still_interesting
op_assign
op_logical_neg
op_logical_neg
id|interesting
c_func
(paren
op_star
id|list_p
)paren
suffix:semicolon
r_struct
id|commit
op_star
id|commit
op_assign
id|pop_one_commit
c_func
(paren
id|list_p
)paren
suffix:semicolon
r_int
id|flags
op_assign
id|commit-&gt;object.flags
op_amp
id|all_mask
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|still_interesting
op_logical_and
id|extra
op_le
l_int|0
)paren
r_break
suffix:semicolon
id|mark_seen
c_func
(paren
id|commit
comma
id|seen_p
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|all_revs
)paren
op_eq
id|all_revs
)paren
id|flags
op_or_assign
id|UNINTERESTING
suffix:semicolon
id|parents
op_assign
id|commit-&gt;parents
suffix:semicolon
r_while
c_loop
(paren
id|parents
)paren
(brace
r_struct
id|commit
op_star
id|p
op_assign
id|parents-&gt;item
suffix:semicolon
r_int
id|this_flag
op_assign
id|p-&gt;object.flags
suffix:semicolon
id|parents
op_assign
id|parents-&gt;next
suffix:semicolon
r_if
c_cond
(paren
(paren
id|this_flag
op_amp
id|flags
)paren
op_eq
id|flags
)paren
r_continue
suffix:semicolon
id|parse_commit
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mark_seen
c_func
(paren
id|p
comma
id|seen_p
)paren
op_logical_and
op_logical_neg
id|still_interesting
)paren
id|extra
op_decrement
suffix:semicolon
id|p-&gt;object.flags
op_or_assign
id|flags
suffix:semicolon
id|commit_list_insert_by_date
c_func
(paren
id|p
comma
id|list_p
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Postprocess to complete well-poisoning.&n;&t; *&n;&t; * At this point we have all the commits we have seen in&n;&t; * seen_p list.  Mark anything that can be reached from&n;&t; * uninteresting commits not interesting.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|changed
op_assign
l_int|0
suffix:semicolon
r_struct
id|commit_list
op_star
id|s
suffix:semicolon
r_for
c_loop
(paren
id|s
op_assign
op_star
id|seen_p
suffix:semicolon
id|s
suffix:semicolon
id|s
op_assign
id|s-&gt;next
)paren
(brace
r_struct
id|commit
op_star
id|c
op_assign
id|s-&gt;item
suffix:semicolon
r_struct
id|commit_list
op_star
id|parents
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|c-&gt;object.flags
op_amp
id|all_revs
)paren
op_ne
id|all_revs
)paren
op_logical_and
op_logical_neg
(paren
id|c-&gt;object.flags
op_amp
id|UNINTERESTING
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* The current commit is either a merge base or&n;&t;&t;&t; * already uninteresting one.  Mark its parents&n;&t;&t;&t; * as uninteresting commits _only_ if they are&n;&t;&t;&t; * already parsed.  No reason to find new ones&n;&t;&t;&t; * here.&n;&t;&t;&t; */
id|parents
op_assign
id|c-&gt;parents
suffix:semicolon
r_while
c_loop
(paren
id|parents
)paren
(brace
r_struct
id|commit
op_star
id|p
op_assign
id|parents-&gt;item
suffix:semicolon
id|parents
op_assign
id|parents-&gt;next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;object.flags
op_amp
id|UNINTERESTING
)paren
)paren
(brace
id|p-&gt;object.flags
op_or_assign
id|UNINTERESTING
suffix:semicolon
id|changed
op_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|changed
)paren
r_break
suffix:semicolon
)brace
)brace
DECL|function|show_one_commit
r_static
r_void
id|show_one_commit
c_func
(paren
r_struct
id|commit
op_star
id|commit
comma
r_int
id|no_name
)paren
(brace
r_struct
id|strbuf
id|pretty
op_assign
id|STRBUF_INIT
suffix:semicolon
r_const
r_char
op_star
id|pretty_str
op_assign
l_string|&quot;(unavailable)&quot;
suffix:semicolon
r_struct
id|commit_name
op_star
id|name
op_assign
id|commit-&gt;util
suffix:semicolon
r_if
c_cond
(paren
id|commit-&gt;object.parsed
)paren
(brace
id|pp_commit_easy
c_func
(paren
id|CMIT_FMT_ONELINE
comma
id|commit
comma
op_amp
id|pretty
)paren
suffix:semicolon
id|pretty_str
op_assign
id|pretty.buf
suffix:semicolon
)brace
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|pretty_str
comma
l_string|&quot;[PATCH] &quot;
)paren
)paren
id|pretty_str
op_add_assign
l_int|8
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|no_name
)paren
(brace
r_if
c_cond
(paren
id|name
op_logical_and
id|name-&gt;head_name
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;[%s&quot;
comma
id|name-&gt;head_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|name-&gt;generation
)paren
(brace
r_if
c_cond
(paren
id|name-&gt;generation
op_eq
l_int|1
)paren
id|printf
c_func
(paren
l_string|&quot;^&quot;
)paren
suffix:semicolon
r_else
id|printf
c_func
(paren
l_string|&quot;~%d&quot;
comma
id|name-&gt;generation
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;] &quot;
)paren
suffix:semicolon
)brace
r_else
id|printf
c_func
(paren
l_string|&quot;[%s] &quot;
comma
id|find_unique_abbrev
c_func
(paren
id|commit-&gt;object.sha1
comma
id|DEFAULT_ABBREV
)paren
)paren
suffix:semicolon
)brace
id|puts
c_func
(paren
id|pretty_str
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|pretty
)paren
suffix:semicolon
)brace
DECL|variable|ref_name
r_static
r_char
op_star
id|ref_name
(braket
id|MAX_REVS
op_plus
l_int|1
)braket
suffix:semicolon
DECL|variable|ref_name_cnt
r_static
r_int
id|ref_name_cnt
suffix:semicolon
DECL|function|find_digit_prefix
r_static
r_const
r_char
op_star
id|find_digit_prefix
c_func
(paren
r_const
r_char
op_star
id|s
comma
r_int
op_star
id|v
)paren
(brace
r_const
r_char
op_star
id|p
suffix:semicolon
r_int
id|ver
suffix:semicolon
r_char
id|ch
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|s
comma
id|ver
op_assign
l_int|0
suffix:semicolon
l_char|&squot;0&squot;
op_le
(paren
id|ch
op_assign
op_star
id|p
)paren
op_logical_and
id|ch
op_le
l_char|&squot;9&squot;
suffix:semicolon
id|p
op_increment
)paren
id|ver
op_assign
id|ver
op_star
l_int|10
op_plus
id|ch
l_char|&squot;0&squot;
suffix:semicolon
op_star
id|v
op_assign
id|ver
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
DECL|function|version_cmp
r_static
r_int
id|version_cmp
c_func
(paren
r_const
r_char
op_star
id|a
comma
r_const
r_char
op_star
id|b
)paren
(brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_int
id|va
comma
id|vb
suffix:semicolon
id|a
op_assign
id|find_digit_prefix
c_func
(paren
id|a
comma
op_amp
id|va
)paren
suffix:semicolon
id|b
op_assign
id|find_digit_prefix
c_func
(paren
id|b
comma
op_amp
id|vb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|va
op_ne
id|vb
)paren
r_return
id|va
id|vb
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_int
id|ca
op_assign
op_star
id|a
suffix:semicolon
r_int
id|cb
op_assign
op_star
id|b
suffix:semicolon
r_if
c_cond
(paren
l_char|&squot;0&squot;
op_le
id|ca
op_logical_and
id|ca
op_le
l_char|&squot;9&squot;
)paren
id|ca
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
l_char|&squot;0&squot;
op_le
id|cb
op_logical_and
id|cb
op_le
l_char|&squot;9&squot;
)paren
id|cb
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ca
op_ne
id|cb
)paren
r_return
id|ca
id|cb
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ca
)paren
r_break
suffix:semicolon
id|a
op_increment
suffix:semicolon
id|b
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|a
op_logical_and
op_logical_neg
op_star
id|b
)paren
r_return
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|compare_ref_name
r_static
r_int
id|compare_ref_name
c_func
(paren
r_const
r_void
op_star
id|a_
comma
r_const
r_void
op_star
id|b_
)paren
(brace
r_const
r_char
op_star
r_const
op_star
id|a
op_assign
id|a_
comma
op_star
r_const
op_star
id|b
op_assign
id|b_
suffix:semicolon
r_return
id|version_cmp
c_func
(paren
op_star
id|a
comma
op_star
id|b
)paren
suffix:semicolon
)brace
DECL|function|sort_ref_range
r_static
r_void
id|sort_ref_range
c_func
(paren
r_int
id|bottom
comma
r_int
id|top
)paren
(brace
id|qsort
c_func
(paren
id|ref_name
op_plus
id|bottom
comma
id|top
id|bottom
comma
r_sizeof
(paren
id|ref_name
(braket
l_int|0
)braket
)paren
comma
id|compare_ref_name
)paren
suffix:semicolon
)brace
DECL|function|append_ref
r_static
r_int
id|append_ref
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_const
r_struct
id|object_id
op_star
id|oid
comma
r_int
id|allow_dups
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
id|lookup_commit_reference_gently
c_func
(paren
id|oid-&gt;hash
comma
l_int|1
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|commit
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|allow_dups
)paren
(brace
multiline_comment|/* Avoid adding the same thing twice */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ref_name_cnt
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|refname
comma
id|ref_name
(braket
id|i
)braket
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|MAX_REVS
op_le
id|ref_name_cnt
)paren
(brace
id|warning
c_func
(paren
l_string|&quot;ignoring %s; cannot handle more than %d refs&quot;
comma
id|refname
comma
id|MAX_REVS
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ref_name
(braket
id|ref_name_cnt
op_increment
)braket
op_assign
id|xstrdup
c_func
(paren
id|refname
)paren
suffix:semicolon
id|ref_name
(braket
id|ref_name_cnt
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|append_head_ref
r_static
r_int
id|append_head_ref
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_const
r_struct
id|object_id
op_star
id|oid
comma
r_int
id|flag
comma
r_void
op_star
id|cb_data
)paren
(brace
r_struct
id|object_id
id|tmp
suffix:semicolon
r_int
id|ofs
op_assign
l_int|11
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|starts_with
c_func
(paren
id|refname
comma
l_string|&quot;refs/heads/&quot;
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* If both heads/foo and tags/foo exists, get_sha1 would&n;&t; * get confused.&n;&t; */
r_if
c_cond
(paren
id|get_sha1
c_func
(paren
id|refname
op_plus
id|ofs
comma
id|tmp.hash
)paren
op_logical_or
id|oidcmp
c_func
(paren
op_amp
id|tmp
comma
id|oid
)paren
)paren
id|ofs
op_assign
l_int|5
suffix:semicolon
r_return
id|append_ref
c_func
(paren
id|refname
op_plus
id|ofs
comma
id|oid
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|append_remote_ref
r_static
r_int
id|append_remote_ref
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_const
r_struct
id|object_id
op_star
id|oid
comma
r_int
id|flag
comma
r_void
op_star
id|cb_data
)paren
(brace
r_struct
id|object_id
id|tmp
suffix:semicolon
r_int
id|ofs
op_assign
l_int|13
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|starts_with
c_func
(paren
id|refname
comma
l_string|&quot;refs/remotes/&quot;
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* If both heads/foo and tags/foo exists, get_sha1 would&n;&t; * get confused.&n;&t; */
r_if
c_cond
(paren
id|get_sha1
c_func
(paren
id|refname
op_plus
id|ofs
comma
id|tmp.hash
)paren
op_logical_or
id|oidcmp
c_func
(paren
op_amp
id|tmp
comma
id|oid
)paren
)paren
id|ofs
op_assign
l_int|5
suffix:semicolon
r_return
id|append_ref
c_func
(paren
id|refname
op_plus
id|ofs
comma
id|oid
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|append_tag_ref
r_static
r_int
id|append_tag_ref
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_const
r_struct
id|object_id
op_star
id|oid
comma
r_int
id|flag
comma
r_void
op_star
id|cb_data
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|starts_with
c_func
(paren
id|refname
comma
l_string|&quot;refs/tags/&quot;
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|append_ref
c_func
(paren
id|refname
op_plus
l_int|5
comma
id|oid
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|variable|match_ref_pattern
r_static
r_const
r_char
op_star
id|match_ref_pattern
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|match_ref_slash
r_static
r_int
id|match_ref_slash
op_assign
l_int|0
suffix:semicolon
DECL|function|count_slash
r_static
r_int
id|count_slash
c_func
(paren
r_const
r_char
op_star
id|s
)paren
(brace
r_int
id|cnt
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_star
id|s
)paren
r_if
c_cond
(paren
op_star
id|s
op_increment
op_eq
l_char|&squot;/&squot;
)paren
id|cnt
op_increment
suffix:semicolon
r_return
id|cnt
suffix:semicolon
)brace
DECL|function|append_matching_ref
r_static
r_int
id|append_matching_ref
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_const
r_struct
id|object_id
op_star
id|oid
comma
r_int
id|flag
comma
r_void
op_star
id|cb_data
)paren
(brace
multiline_comment|/* we want to allow pattern hold/&lt;asterisk&gt; to show all&n;&t; * branches under refs/heads/hold/, and v0.99.9? to show&n;&t; * refs/tags/v0.99.9a and friends.&n;&t; */
r_const
r_char
op_star
id|tail
suffix:semicolon
r_int
id|slash
op_assign
id|count_slash
c_func
(paren
id|refname
)paren
suffix:semicolon
r_for
c_loop
(paren
id|tail
op_assign
id|refname
suffix:semicolon
op_star
id|tail
op_logical_and
id|match_ref_slash
OL
id|slash
suffix:semicolon
)paren
r_if
c_cond
(paren
op_star
id|tail
op_increment
op_eq
l_char|&squot;/&squot;
)paren
id|slash
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|tail
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|wildmatch
c_func
(paren
id|match_ref_pattern
comma
id|tail
comma
l_int|0
comma
l_int|NULL
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|refname
comma
l_string|&quot;refs/heads/&quot;
)paren
)paren
r_return
id|append_head_ref
c_func
(paren
id|refname
comma
id|oid
comma
id|flag
comma
id|cb_data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|refname
comma
l_string|&quot;refs/tags/&quot;
)paren
)paren
r_return
id|append_tag_ref
c_func
(paren
id|refname
comma
id|oid
comma
id|flag
comma
id|cb_data
)paren
suffix:semicolon
r_return
id|append_ref
c_func
(paren
id|refname
comma
id|oid
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|snarf_refs
r_static
r_void
id|snarf_refs
c_func
(paren
r_int
id|head
comma
r_int
id|remotes
)paren
(brace
r_if
c_cond
(paren
id|head
)paren
(brace
r_int
id|orig_cnt
op_assign
id|ref_name_cnt
suffix:semicolon
id|for_each_ref
c_func
(paren
id|append_head_ref
comma
l_int|NULL
)paren
suffix:semicolon
id|sort_ref_range
c_func
(paren
id|orig_cnt
comma
id|ref_name_cnt
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|remotes
)paren
(brace
r_int
id|orig_cnt
op_assign
id|ref_name_cnt
suffix:semicolon
id|for_each_ref
c_func
(paren
id|append_remote_ref
comma
l_int|NULL
)paren
suffix:semicolon
id|sort_ref_range
c_func
(paren
id|orig_cnt
comma
id|ref_name_cnt
)paren
suffix:semicolon
)brace
)brace
DECL|function|rev_is_head
r_static
r_int
id|rev_is_head
c_func
(paren
r_char
op_star
id|head
comma
r_int
id|headlen
comma
r_char
op_star
id|name
comma
r_int
r_char
op_star
id|head_sha1
comma
r_int
r_char
op_star
id|sha1
)paren
(brace
r_if
c_cond
(paren
(paren
op_logical_neg
id|head
(braket
l_int|0
)braket
)paren
op_logical_or
(paren
id|head_sha1
op_logical_and
id|sha1
op_logical_and
id|hashcmp
c_func
(paren
id|head_sha1
comma
id|sha1
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|head
comma
l_string|&quot;refs/heads/&quot;
)paren
)paren
id|head
op_add_assign
l_int|11
suffix:semicolon
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|name
comma
l_string|&quot;refs/heads/&quot;
)paren
)paren
id|name
op_add_assign
l_int|11
suffix:semicolon
r_else
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|name
comma
l_string|&quot;heads/&quot;
)paren
)paren
id|name
op_add_assign
l_int|6
suffix:semicolon
r_return
op_logical_neg
id|strcmp
c_func
(paren
id|head
comma
id|name
)paren
suffix:semicolon
)brace
DECL|function|show_merge_base
r_static
r_int
id|show_merge_base
c_func
(paren
r_struct
id|commit_list
op_star
id|seen
comma
r_int
id|num_rev
)paren
(brace
r_int
id|all_mask
op_assign
(paren
(paren
l_int|1u
op_lshift
(paren
id|REV_SHIFT
op_plus
id|num_rev
)paren
)paren
l_int|1
)paren
suffix:semicolon
r_int
id|all_revs
op_assign
id|all_mask
op_amp
op_complement
(paren
(paren
l_int|1u
op_lshift
id|REV_SHIFT
)paren
l_int|1
)paren
suffix:semicolon
r_int
id|exit_status
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|seen
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
id|pop_one_commit
c_func
(paren
op_amp
id|seen
)paren
suffix:semicolon
r_int
id|flags
op_assign
id|commit-&gt;object.flags
op_amp
id|all_mask
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|UNINTERESTING
)paren
op_logical_and
(paren
(paren
id|flags
op_amp
id|all_revs
)paren
op_eq
id|all_revs
)paren
)paren
(brace
id|puts
c_func
(paren
id|sha1_to_hex
c_func
(paren
id|commit-&gt;object.sha1
)paren
)paren
suffix:semicolon
id|exit_status
op_assign
l_int|0
suffix:semicolon
id|commit-&gt;object.flags
op_or_assign
id|UNINTERESTING
suffix:semicolon
)brace
)brace
r_return
id|exit_status
suffix:semicolon
)brace
DECL|function|show_independent
r_static
r_int
id|show_independent
c_func
(paren
r_struct
id|commit
op_star
op_star
id|rev
comma
r_int
id|num_rev
comma
r_char
op_star
op_star
id|ref_name
comma
r_int
r_int
op_star
id|rev_mask
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_rev
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
id|rev
(braket
id|i
)braket
suffix:semicolon
r_int
r_int
id|flag
op_assign
id|rev_mask
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|commit-&gt;object.flags
op_eq
id|flag
)paren
id|puts
c_func
(paren
id|sha1_to_hex
c_func
(paren
id|commit-&gt;object.sha1
)paren
)paren
suffix:semicolon
id|commit-&gt;object.flags
op_or_assign
id|UNINTERESTING
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|append_one_rev
r_static
r_void
id|append_one_rev
c_func
(paren
r_const
r_char
op_star
id|av
)paren
(brace
r_struct
id|object_id
id|revkey
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|get_sha1
c_func
(paren
id|av
comma
id|revkey.hash
)paren
)paren
(brace
id|append_ref
c_func
(paren
id|av
comma
op_amp
id|revkey
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strchr
c_func
(paren
id|av
comma
l_char|&squot;*&squot;
)paren
op_logical_or
id|strchr
c_func
(paren
id|av
comma
l_char|&squot;?&squot;
)paren
op_logical_or
id|strchr
c_func
(paren
id|av
comma
l_char|&squot;[&squot;
)paren
)paren
(brace
multiline_comment|/* glob style match */
r_int
id|saved_matches
op_assign
id|ref_name_cnt
suffix:semicolon
id|match_ref_pattern
op_assign
id|av
suffix:semicolon
id|match_ref_slash
op_assign
id|count_slash
c_func
(paren
id|av
)paren
suffix:semicolon
id|for_each_ref
c_func
(paren
id|append_matching_ref
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|saved_matches
op_eq
id|ref_name_cnt
op_logical_and
id|ref_name_cnt
OL
id|MAX_REVS
)paren
id|error
c_func
(paren
l_string|&quot;no matching refs with %s&quot;
comma
id|av
)paren
suffix:semicolon
r_if
c_cond
(paren
id|saved_matches
op_plus
l_int|1
OL
id|ref_name_cnt
)paren
id|sort_ref_range
c_func
(paren
id|saved_matches
comma
id|ref_name_cnt
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|die
c_func
(paren
l_string|&quot;bad sha1 reference %s&quot;
comma
id|av
)paren
suffix:semicolon
)brace
DECL|function|git_show_branch_config
r_static
r_int
id|git_show_branch_config
c_func
(paren
r_const
r_char
op_star
id|var
comma
r_const
r_char
op_star
id|value
comma
r_void
op_star
id|cb
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;showbranch.default&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
r_return
id|config_error_nonbool
c_func
(paren
id|var
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * default_arg is now passed to parse_options(), so we need to&n;&t;&t; * mimic the real argv a bit better.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|default_num
)paren
(brace
id|default_alloc
op_assign
l_int|20
suffix:semicolon
id|default_arg
op_assign
id|xcalloc
c_func
(paren
id|default_alloc
comma
r_sizeof
(paren
op_star
id|default_arg
)paren
)paren
suffix:semicolon
id|default_arg
(braket
id|default_num
op_increment
)braket
op_assign
l_string|&quot;show-branch&quot;
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|default_alloc
op_le
id|default_num
op_plus
l_int|1
)paren
(brace
id|default_alloc
op_assign
id|default_alloc
op_star
l_int|3
op_div
l_int|2
op_plus
l_int|20
suffix:semicolon
id|REALLOC_ARRAY
c_func
(paren
id|default_arg
comma
id|default_alloc
)paren
suffix:semicolon
)brace
id|default_arg
(braket
id|default_num
op_increment
)braket
op_assign
id|xstrdup
c_func
(paren
id|value
)paren
suffix:semicolon
id|default_arg
(braket
id|default_num
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;color.showbranch&quot;
)paren
)paren
(brace
id|showbranch_use_color
op_assign
id|git_config_colorbool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|git_color_default_config
c_func
(paren
id|var
comma
id|value
comma
id|cb
)paren
suffix:semicolon
)brace
DECL|function|omit_in_dense
r_static
r_int
id|omit_in_dense
c_func
(paren
r_struct
id|commit
op_star
id|commit
comma
r_struct
id|commit
op_star
op_star
id|rev
comma
r_int
id|n
)paren
(brace
multiline_comment|/* If the commit is tip of the named branches, do not&n;&t; * omit it.&n;&t; * Otherwise, if it is a merge that is reachable from only one&n;&t; * tip, it is not that interesting.&n;&t; */
r_int
id|i
comma
id|flag
comma
id|count
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|rev
(braket
id|i
)braket
op_eq
id|commit
)paren
r_return
l_int|0
suffix:semicolon
id|flag
op_assign
id|commit-&gt;object.flags
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|count
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|flag
op_amp
(paren
l_int|1u
op_lshift
(paren
id|i
op_plus
id|REV_SHIFT
)paren
)paren
)paren
id|count
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
op_eq
l_int|1
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|reflog
r_static
r_int
id|reflog
op_assign
l_int|0
suffix:semicolon
DECL|function|parse_reflog_param
r_static
r_int
id|parse_reflog_param
c_func
(paren
r_const
r_struct
id|option
op_star
id|opt
comma
r_const
r_char
op_star
id|arg
comma
r_int
id|unset
)paren
(brace
r_char
op_star
id|ep
suffix:semicolon
r_const
r_char
op_star
op_star
id|base
op_assign
(paren
r_const
r_char
op_star
op_star
)paren
id|opt-&gt;value
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
id|arg
op_assign
l_string|&quot;&quot;
suffix:semicolon
id|reflog
op_assign
id|strtoul
c_func
(paren
id|arg
comma
op_amp
id|ep
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|ep
op_eq
l_char|&squot;,&squot;
)paren
op_star
id|base
op_assign
id|ep
op_plus
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
op_star
id|ep
)paren
r_return
id|error
c_func
(paren
l_string|&quot;unrecognized reflog param &squot;%s&squot;&quot;
comma
id|arg
)paren
suffix:semicolon
r_else
op_star
id|base
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|reflog
op_le
l_int|0
)paren
id|reflog
op_assign
id|DEFAULT_REFLOG
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cmd_show_branch
r_int
id|cmd_show_branch
c_func
(paren
r_int
id|ac
comma
r_const
r_char
op_star
op_star
id|av
comma
r_const
r_char
op_star
id|prefix
)paren
(brace
r_struct
id|commit
op_star
id|rev
(braket
id|MAX_REVS
)braket
comma
op_star
id|commit
suffix:semicolon
r_char
op_star
id|reflog_msg
(braket
id|MAX_REVS
)braket
suffix:semicolon
r_struct
id|commit_list
op_star
id|list
op_assign
l_int|NULL
comma
op_star
id|seen
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|rev_mask
(braket
id|MAX_REVS
)braket
suffix:semicolon
r_int
id|num_rev
comma
id|i
comma
id|extra
op_assign
l_int|0
suffix:semicolon
r_int
id|all_heads
op_assign
l_int|0
comma
id|all_remotes
op_assign
l_int|0
suffix:semicolon
r_int
id|all_mask
comma
id|all_revs
suffix:semicolon
r_enum
id|rev_sort_order
id|sort_order
op_assign
id|REV_SORT_IN_GRAPH_ORDER
suffix:semicolon
r_char
id|head
(braket
l_int|128
)braket
suffix:semicolon
r_const
r_char
op_star
id|head_p
suffix:semicolon
r_int
id|head_len
suffix:semicolon
r_struct
id|object_id
id|head_oid
suffix:semicolon
r_int
id|merge_base
op_assign
l_int|0
suffix:semicolon
r_int
id|independent
op_assign
l_int|0
suffix:semicolon
r_int
id|no_name
op_assign
l_int|0
suffix:semicolon
r_int
id|sha1_name
op_assign
l_int|0
suffix:semicolon
r_int
id|shown_merge_point
op_assign
l_int|0
suffix:semicolon
r_int
id|with_current_branch
op_assign
l_int|0
suffix:semicolon
r_int
id|head_at
op_assign
l_int|1
suffix:semicolon
r_int
id|topics
op_assign
l_int|0
suffix:semicolon
r_int
id|dense
op_assign
l_int|1
suffix:semicolon
r_const
r_char
op_star
id|reflog_base
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|option
id|builtin_show_branch_options
(braket
)braket
op_assign
(brace
id|OPT_BOOL
c_func
(paren
l_char|&squot;a&squot;
comma
l_string|&quot;all&quot;
comma
op_amp
id|all_heads
comma
id|N_
c_func
(paren
l_string|&quot;show remote-tracking and local branches&quot;
)paren
)paren
comma
id|OPT_BOOL
c_func
(paren
l_char|&squot;r&squot;
comma
l_string|&quot;remotes&quot;
comma
op_amp
id|all_remotes
comma
id|N_
c_func
(paren
l_string|&quot;show remote-tracking branches&quot;
)paren
)paren
comma
id|OPT__COLOR
c_func
(paren
op_amp
id|showbranch_use_color
comma
id|N_
c_func
(paren
l_string|&quot;color &squot;*!+-&squot; corresponding to the branch&quot;
)paren
)paren
comma
(brace
id|OPTION_INTEGER
comma
l_int|0
comma
l_string|&quot;more&quot;
comma
op_amp
id|extra
comma
id|N_
c_func
(paren
l_string|&quot;n&quot;
)paren
comma
id|N_
c_func
(paren
l_string|&quot;show &lt;n&gt; more commits after the common ancestor&quot;
)paren
comma
id|PARSE_OPT_OPTARG
comma
l_int|NULL
comma
(paren
r_intptr
)paren
l_int|1
)brace
comma
id|OPT_SET_INT
c_func
(paren
l_int|0
comma
l_string|&quot;list&quot;
comma
op_amp
id|extra
comma
id|N_
c_func
(paren
l_string|&quot;synonym to more=-1&quot;
)paren
comma
l_int|1
)paren
comma
id|OPT_BOOL
c_func
(paren
l_int|0
comma
l_string|&quot;no-name&quot;
comma
op_amp
id|no_name
comma
id|N_
c_func
(paren
l_string|&quot;suppress naming strings&quot;
)paren
)paren
comma
id|OPT_BOOL
c_func
(paren
l_int|0
comma
l_string|&quot;current&quot;
comma
op_amp
id|with_current_branch
comma
id|N_
c_func
(paren
l_string|&quot;include the current branch&quot;
)paren
)paren
comma
id|OPT_BOOL
c_func
(paren
l_int|0
comma
l_string|&quot;sha1-name&quot;
comma
op_amp
id|sha1_name
comma
id|N_
c_func
(paren
l_string|&quot;name commits with their object names&quot;
)paren
)paren
comma
id|OPT_BOOL
c_func
(paren
l_int|0
comma
l_string|&quot;merge-base&quot;
comma
op_amp
id|merge_base
comma
id|N_
c_func
(paren
l_string|&quot;show possible merge bases&quot;
)paren
)paren
comma
id|OPT_BOOL
c_func
(paren
l_int|0
comma
l_string|&quot;independent&quot;
comma
op_amp
id|independent
comma
id|N_
c_func
(paren
l_string|&quot;show refs unreachable from any other ref&quot;
)paren
)paren
comma
id|OPT_SET_INT
c_func
(paren
l_int|0
comma
l_string|&quot;topo-order&quot;
comma
op_amp
id|sort_order
comma
id|N_
c_func
(paren
l_string|&quot;show commits in topological order&quot;
)paren
comma
id|REV_SORT_IN_GRAPH_ORDER
)paren
comma
id|OPT_BOOL
c_func
(paren
l_int|0
comma
l_string|&quot;topics&quot;
comma
op_amp
id|topics
comma
id|N_
c_func
(paren
l_string|&quot;show only commits not on the first branch&quot;
)paren
)paren
comma
id|OPT_SET_INT
c_func
(paren
l_int|0
comma
l_string|&quot;sparse&quot;
comma
op_amp
id|dense
comma
id|N_
c_func
(paren
l_string|&quot;show merges reachable from only one tip&quot;
)paren
comma
l_int|0
)paren
comma
id|OPT_SET_INT
c_func
(paren
l_int|0
comma
l_string|&quot;date-order&quot;
comma
op_amp
id|sort_order
comma
id|N_
c_func
(paren
l_string|&quot;topologically sort, maintaining date order &quot;
l_string|&quot;where possible&quot;
)paren
comma
id|REV_SORT_BY_COMMIT_DATE
)paren
comma
(brace
id|OPTION_CALLBACK
comma
l_char|&squot;g&squot;
comma
l_string|&quot;reflog&quot;
comma
op_amp
id|reflog_base
comma
id|N_
c_func
(paren
l_string|&quot;&lt;n&gt;[,&lt;base&gt;]&quot;
)paren
comma
id|N_
c_func
(paren
l_string|&quot;show &lt;n&gt; most recent ref-log entries starting at &quot;
l_string|&quot;base&quot;
)paren
comma
id|PARSE_OPT_OPTARG
op_or
id|PARSE_OPT_LITERAL_ARGHELP
comma
id|parse_reflog_param
)brace
comma
id|OPT_END
c_func
(paren
)paren
)brace
suffix:semicolon
id|git_config
c_func
(paren
id|git_show_branch_config
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* If nothing is specified, try the default first */
r_if
c_cond
(paren
id|ac
op_eq
l_int|1
op_logical_and
id|default_num
)paren
(brace
id|ac
op_assign
id|default_num
suffix:semicolon
id|av
op_assign
id|default_arg
suffix:semicolon
)brace
id|ac
op_assign
id|parse_options
c_func
(paren
id|ac
comma
id|av
comma
id|prefix
comma
id|builtin_show_branch_options
comma
id|show_branch_usage
comma
id|PARSE_OPT_STOP_AT_NON_OPTION
)paren
suffix:semicolon
r_if
c_cond
(paren
id|all_heads
)paren
id|all_remotes
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|extra
op_logical_or
id|reflog
)paren
(brace
multiline_comment|/* &quot;listing&quot; mode is incompatible with&n;&t;&t; * independent nor merge-base modes.&n;&t;&t; */
r_if
c_cond
(paren
id|independent
op_logical_or
id|merge_base
)paren
id|usage_with_options
c_func
(paren
id|show_branch_usage
comma
id|builtin_show_branch_options
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reflog
op_logical_and
(paren
(paren
l_int|0
OL
id|extra
)paren
op_logical_or
id|all_heads
op_logical_or
id|all_remotes
)paren
)paren
multiline_comment|/*&n;&t;&t;&t; * Asking for --more in reflog mode does not&n;&t;&t;&t; * make sense.  --list is Ok.&n;&t;&t;&t; *&n;&t;&t;&t; * Also --all and --remotes do not make sense either.&n;&t;&t;&t; */
id|die
c_func
(paren
l_string|&quot;--reflog is incompatible with --all, --remotes, &quot;
l_string|&quot;--independent or --merge-base&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* If nothing is specified, show all branches by default */
r_if
c_cond
(paren
id|ac
op_le
id|topics
op_logical_and
id|all_heads
op_plus
id|all_remotes
op_eq
l_int|0
)paren
id|all_heads
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|reflog
)paren
(brace
r_struct
id|object_id
id|oid
suffix:semicolon
r_char
op_star
id|ref
suffix:semicolon
r_int
id|base
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ac
op_eq
l_int|0
)paren
(brace
r_static
r_const
r_char
op_star
id|fake_av
(braket
l_int|2
)braket
suffix:semicolon
id|fake_av
(braket
l_int|0
)braket
op_assign
id|resolve_refdup
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|RESOLVE_REF_READING
comma
id|oid.hash
comma
l_int|NULL
)paren
suffix:semicolon
id|fake_av
(braket
l_int|1
)braket
op_assign
l_int|NULL
suffix:semicolon
id|av
op_assign
id|fake_av
suffix:semicolon
id|ac
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ac
op_ne
l_int|1
)paren
id|die
c_func
(paren
l_string|&quot;--reflog option needs one branch name&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|MAX_REVS
OL
id|reflog
)paren
id|die
c_func
(paren
l_string|&quot;Only %d entries can be shown at one time.&quot;
comma
id|MAX_REVS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dwim_ref
c_func
(paren
op_star
id|av
comma
id|strlen
c_func
(paren
op_star
id|av
)paren
comma
id|oid.hash
comma
op_amp
id|ref
)paren
)paren
id|die
c_func
(paren
l_string|&quot;No such ref %s&quot;
comma
op_star
id|av
)paren
suffix:semicolon
multiline_comment|/* Has the base been specified? */
r_if
c_cond
(paren
id|reflog_base
)paren
(brace
r_char
op_star
id|ep
suffix:semicolon
id|base
op_assign
id|strtoul
c_func
(paren
id|reflog_base
comma
op_amp
id|ep
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|ep
)paren
(brace
multiline_comment|/* Ah, that is a date spec... */
r_int
r_int
id|at
suffix:semicolon
id|at
op_assign
id|approxidate
c_func
(paren
id|reflog_base
)paren
suffix:semicolon
id|read_ref_at
c_func
(paren
id|ref
comma
id|flags
comma
id|at
comma
l_int|1
comma
id|oid.hash
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
op_amp
id|base
)paren
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|reflog
suffix:semicolon
id|i
op_increment
)paren
(brace
r_char
op_star
id|logmsg
suffix:semicolon
r_char
op_star
id|nth_desc
suffix:semicolon
r_const
r_char
op_star
id|msg
suffix:semicolon
r_int
r_int
id|timestamp
suffix:semicolon
r_int
id|tz
suffix:semicolon
r_if
c_cond
(paren
id|read_ref_at
c_func
(paren
id|ref
comma
id|flags
comma
l_int|0
comma
id|base
op_plus
id|i
comma
id|oid.hash
comma
op_amp
id|logmsg
comma
op_amp
id|timestamp
comma
op_amp
id|tz
comma
l_int|NULL
)paren
)paren
(brace
id|reflog
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
id|msg
op_assign
id|strchr
c_func
(paren
id|logmsg
comma
l_char|&squot;&bslash;t&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|msg
)paren
id|msg
op_assign
l_string|&quot;(none)&quot;
suffix:semicolon
r_else
id|msg
op_increment
suffix:semicolon
id|reflog_msg
(braket
id|i
)braket
op_assign
id|xstrfmt
c_func
(paren
l_string|&quot;(%s) %s&quot;
comma
id|show_date
c_func
(paren
id|timestamp
comma
id|tz
comma
id|DATE_MODE
c_func
(paren
id|RELATIVE
)paren
)paren
comma
id|msg
)paren
suffix:semicolon
id|free
c_func
(paren
id|logmsg
)paren
suffix:semicolon
id|nth_desc
op_assign
id|xstrfmt
c_func
(paren
l_string|&quot;%s@{%d}&quot;
comma
op_star
id|av
comma
id|base
op_plus
id|i
)paren
suffix:semicolon
id|append_ref
c_func
(paren
id|nth_desc
comma
op_amp
id|oid
comma
l_int|1
)paren
suffix:semicolon
id|free
c_func
(paren
id|nth_desc
)paren
suffix:semicolon
)brace
id|free
c_func
(paren
id|ref
)paren
suffix:semicolon
)brace
r_else
(brace
r_while
c_loop
(paren
l_int|0
OL
id|ac
)paren
(brace
id|append_one_rev
c_func
(paren
op_star
id|av
)paren
suffix:semicolon
id|ac
op_decrement
suffix:semicolon
id|av
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|all_heads
op_plus
id|all_remotes
)paren
id|snarf_refs
c_func
(paren
id|all_heads
comma
id|all_remotes
)paren
suffix:semicolon
)brace
id|head_p
op_assign
id|resolve_ref_unsafe
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|RESOLVE_REF_READING
comma
id|head_oid.hash
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|head_p
)paren
(brace
id|head_len
op_assign
id|strlen
c_func
(paren
id|head_p
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|head
comma
id|head_p
comma
id|head_len
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|head_len
op_assign
l_int|0
suffix:semicolon
id|head
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|with_current_branch
op_logical_and
id|head_p
)paren
(brace
r_int
id|has_head
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|has_head
op_logical_and
id|i
OL
id|ref_name_cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* We are only interested in adding the branch&n;&t;&t;&t; * HEAD points at.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|rev_is_head
c_func
(paren
id|head
comma
id|head_len
comma
id|ref_name
(braket
id|i
)braket
comma
id|head_oid.hash
comma
l_int|NULL
)paren
)paren
id|has_head
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|has_head
)paren
(brace
r_int
id|offset
op_assign
id|starts_with
c_func
(paren
id|head
comma
l_string|&quot;refs/heads/&quot;
)paren
ques
c_cond
l_int|11
suffix:colon
l_int|0
suffix:semicolon
id|append_one_rev
c_func
(paren
id|head
op_plus
id|offset
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|ref_name_cnt
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;No revs to be shown.&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|num_rev
op_assign
l_int|0
suffix:semicolon
id|ref_name
(braket
id|num_rev
)braket
suffix:semicolon
id|num_rev
op_increment
)paren
(brace
r_struct
id|object_id
id|revkey
suffix:semicolon
r_int
r_int
id|flag
op_assign
l_int|1u
op_lshift
(paren
id|num_rev
op_plus
id|REV_SHIFT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|MAX_REVS
op_le
id|num_rev
)paren
id|die
c_func
(paren
l_string|&quot;cannot handle more than %d revs.&quot;
comma
id|MAX_REVS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1
c_func
(paren
id|ref_name
(braket
id|num_rev
)braket
comma
id|revkey.hash
)paren
)paren
id|die
c_func
(paren
l_string|&quot;&squot;%s&squot; is not a valid ref.&quot;
comma
id|ref_name
(braket
id|num_rev
)braket
)paren
suffix:semicolon
id|commit
op_assign
id|lookup_commit_reference
c_func
(paren
id|revkey.hash
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|commit
)paren
id|die
c_func
(paren
l_string|&quot;cannot find commit %s (%s)&quot;
comma
id|ref_name
(braket
id|num_rev
)braket
comma
id|oid_to_hex
c_func
(paren
op_amp
id|revkey
)paren
)paren
suffix:semicolon
id|parse_commit
c_func
(paren
id|commit
)paren
suffix:semicolon
id|mark_seen
c_func
(paren
id|commit
comma
op_amp
id|seen
)paren
suffix:semicolon
multiline_comment|/* rev#0 uses bit REV_SHIFT, rev#1 uses bit REV_SHIFT+1,&n;&t;&t; * and so on.  REV_SHIFT bits from bit 0 are used for&n;&t;&t; * internal bookkeeping.&n;&t;&t; */
id|commit-&gt;object.flags
op_or_assign
id|flag
suffix:semicolon
r_if
c_cond
(paren
id|commit-&gt;object.flags
op_eq
id|flag
)paren
id|commit_list_insert_by_date
c_func
(paren
id|commit
comma
op_amp
id|list
)paren
suffix:semicolon
id|rev
(braket
id|num_rev
)braket
op_assign
id|commit
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_rev
suffix:semicolon
id|i
op_increment
)paren
id|rev_mask
(braket
id|i
)braket
op_assign
id|rev
(braket
id|i
)braket
op_member_access_from_pointer
id|object.flags
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_le
id|extra
)paren
id|join_revs
c_func
(paren
op_amp
id|list
comma
op_amp
id|seen
comma
id|num_rev
comma
id|extra
)paren
suffix:semicolon
id|commit_list_sort_by_date
c_func
(paren
op_amp
id|seen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|merge_base
)paren
r_return
id|show_merge_base
c_func
(paren
id|seen
comma
id|num_rev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|independent
)paren
r_return
id|show_independent
c_func
(paren
id|rev
comma
id|num_rev
comma
id|ref_name
comma
id|rev_mask
)paren
suffix:semicolon
multiline_comment|/* Show list; --more=-1 means list-only */
r_if
c_cond
(paren
l_int|1
OL
id|num_rev
op_logical_or
id|extra
OL
l_int|0
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_rev
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|j
suffix:semicolon
r_int
id|is_head
op_assign
id|rev_is_head
c_func
(paren
id|head
comma
id|head_len
comma
id|ref_name
(braket
id|i
)braket
comma
id|head_oid.hash
comma
id|rev
(braket
id|i
)braket
op_member_access_from_pointer
id|object.sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|extra
OL
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;%c [%s] &quot;
comma
id|is_head
ques
c_cond
l_char|&squot;*&squot;
suffix:colon
l_char|&squot; &squot;
comma
id|ref_name
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|i
suffix:semicolon
id|j
op_increment
)paren
id|putchar
c_func
(paren
l_char|&squot; &squot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s%c%s [%s] &quot;
comma
id|get_color_code
c_func
(paren
id|i
)paren
comma
id|is_head
ques
c_cond
l_char|&squot;*&squot;
suffix:colon
l_char|&squot;!&squot;
comma
id|get_color_reset_code
c_func
(paren
)paren
comma
id|ref_name
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|reflog
)paren
(brace
multiline_comment|/* header lines never need name */
id|show_one_commit
c_func
(paren
id|rev
(braket
id|i
)braket
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
id|puts
c_func
(paren
id|reflog_msg
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_head
)paren
id|head_at
op_assign
id|i
suffix:semicolon
)brace
r_if
c_cond
(paren
l_int|0
op_le
id|extra
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_rev
suffix:semicolon
id|i
op_increment
)paren
id|putchar
c_func
(paren
l_char|&squot;-&squot;
)paren
suffix:semicolon
id|putchar
c_func
(paren
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|extra
OL
l_int|0
)paren
m_exit
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Sort topologically */
id|sort_in_topological_order
c_func
(paren
op_amp
id|seen
comma
id|sort_order
)paren
suffix:semicolon
multiline_comment|/* Give names to commits */
r_if
c_cond
(paren
op_logical_neg
id|sha1_name
op_logical_and
op_logical_neg
id|no_name
)paren
id|name_commits
c_func
(paren
id|seen
comma
id|rev
comma
id|ref_name
comma
id|num_rev
)paren
suffix:semicolon
id|all_mask
op_assign
(paren
(paren
l_int|1u
op_lshift
(paren
id|REV_SHIFT
op_plus
id|num_rev
)paren
)paren
l_int|1
)paren
suffix:semicolon
id|all_revs
op_assign
id|all_mask
op_amp
op_complement
(paren
(paren
l_int|1u
op_lshift
id|REV_SHIFT
)paren
l_int|1
)paren
suffix:semicolon
r_while
c_loop
(paren
id|seen
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
id|pop_one_commit
c_func
(paren
op_amp
id|seen
)paren
suffix:semicolon
r_int
id|this_flag
op_assign
id|commit-&gt;object.flags
suffix:semicolon
r_int
id|is_merge_point
op_assign
(paren
(paren
id|this_flag
op_amp
id|all_revs
)paren
op_eq
id|all_revs
)paren
suffix:semicolon
id|shown_merge_point
op_or_assign
id|is_merge_point
suffix:semicolon
r_if
c_cond
(paren
l_int|1
OL
id|num_rev
)paren
(brace
r_int
id|is_merge
op_assign
op_logical_neg
op_logical_neg
(paren
id|commit-&gt;parents
op_logical_and
id|commit-&gt;parents-&gt;next
)paren
suffix:semicolon
r_if
c_cond
(paren
id|topics
op_logical_and
op_logical_neg
id|is_merge_point
op_logical_and
(paren
id|this_flag
op_amp
(paren
l_int|1u
op_lshift
id|REV_SHIFT
)paren
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|dense
op_logical_and
id|is_merge
op_logical_and
id|omit_in_dense
c_func
(paren
id|commit
comma
id|rev
comma
id|num_rev
)paren
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_rev
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|mark
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|this_flag
op_amp
(paren
l_int|1u
op_lshift
(paren
id|i
op_plus
id|REV_SHIFT
)paren
)paren
)paren
)paren
id|mark
op_assign
l_char|&squot; &squot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|is_merge
)paren
id|mark
op_assign
l_char|&squot;-&squot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|i
op_eq
id|head_at
)paren
id|mark
op_assign
l_char|&squot;*&squot;
suffix:semicolon
r_else
id|mark
op_assign
l_char|&squot;+&squot;
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s%c%s&quot;
comma
id|get_color_code
c_func
(paren
id|i
)paren
comma
id|mark
comma
id|get_color_reset_code
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
id|putchar
c_func
(paren
l_char|&squot; &squot;
)paren
suffix:semicolon
)brace
id|show_one_commit
c_func
(paren
id|commit
comma
id|no_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shown_merge_point
op_logical_and
op_decrement
id|extra
OL
l_int|0
)paren
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
