multiline_comment|/*&n; * Builtin &quot;git tag&quot;&n; *&n; * Copyright (c) 2007 Kristian H&oslash;gsberg &lt;krh@redhat.com&gt;,&n; *                    Carlos Rica &lt;jasampler@gmail.com&gt;&n; * Based on git-tag.sh and mktag.c by Linus Torvalds.&n; */
macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;builtin.h&quot;
macro_line|#include &quot;refs.h&quot;
macro_line|#include &quot;tag.h&quot;
macro_line|#include &quot;run-command.h&quot;
macro_line|#include &quot;parse-options.h&quot;
macro_line|#include &quot;diff.h&quot;
macro_line|#include &quot;revision.h&quot;
macro_line|#include &quot;gpg-interface.h&quot;
macro_line|#include &quot;sha1-array.h&quot;
macro_line|#include &quot;column.h&quot;
DECL|variable|git_tag_usage
r_static
r_const
r_char
op_star
r_const
id|git_tag_usage
(braket
)braket
op_assign
(brace
id|N_
c_func
(paren
l_string|&quot;git tag [-a|-s|-u &lt;key-id&gt;] [-f] [-m &lt;msg&gt;|-F &lt;file&gt;] &lt;tagname&gt; [&lt;head&gt;]&quot;
)paren
comma
id|N_
c_func
(paren
l_string|&quot;git tag -d &lt;tagname&gt;...&quot;
)paren
comma
id|N_
c_func
(paren
l_string|&quot;git tag -l [-n[&lt;num&gt;]] [--contains &lt;commit&gt;] [--points-at &lt;object&gt;] &quot;
l_string|&quot;&bslash;n&bslash;t&bslash;t[&lt;pattern&gt;...]&quot;
)paren
comma
id|N_
c_func
(paren
l_string|&quot;git tag -v &lt;tagname&gt;...&quot;
)paren
comma
l_int|NULL
)brace
suffix:semicolon
DECL|macro|STRCMP_SORT
mdefine_line|#define STRCMP_SORT     0&t;/* must be zero */
DECL|macro|VERCMP_SORT
mdefine_line|#define VERCMP_SORT     1
DECL|macro|SORT_MASK
mdefine_line|#define SORT_MASK       0x7fff
DECL|macro|REVERSE_SORT
mdefine_line|#define REVERSE_SORT    0x8000
DECL|variable|tag_sort
r_static
r_int
id|tag_sort
suffix:semicolon
DECL|struct|tag_filter
r_struct
id|tag_filter
(brace
DECL|member|patterns
r_const
r_char
op_star
op_star
id|patterns
suffix:semicolon
DECL|member|lines
r_int
id|lines
suffix:semicolon
DECL|member|sort
r_int
id|sort
suffix:semicolon
DECL|member|tags
r_struct
id|string_list
id|tags
suffix:semicolon
DECL|member|with_commit
r_struct
id|commit_list
op_star
id|with_commit
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|points_at
r_static
r_struct
id|sha1_array
id|points_at
suffix:semicolon
DECL|variable|colopts
r_static
r_int
r_int
id|colopts
suffix:semicolon
DECL|function|match_pattern
r_static
r_int
id|match_pattern
c_func
(paren
r_const
r_char
op_star
op_star
id|patterns
comma
r_const
r_char
op_star
id|ref
)paren
(brace
multiline_comment|/* no pattern means match everything */
r_if
c_cond
(paren
op_logical_neg
op_star
id|patterns
)paren
r_return
l_int|1
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
op_star
id|patterns
suffix:semicolon
id|patterns
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|wildmatch
c_func
(paren
op_star
id|patterns
comma
id|ref
comma
l_int|0
comma
l_int|NULL
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|match_points_at
r_static
r_const
r_int
r_char
op_star
id|match_points_at
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_const
r_int
r_char
op_star
id|tagged_sha1
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|object
op_star
id|obj
suffix:semicolon
r_if
c_cond
(paren
id|sha1_array_lookup
c_func
(paren
op_amp
id|points_at
comma
id|sha1
)paren
op_ge
l_int|0
)paren
r_return
id|sha1
suffix:semicolon
id|obj
op_assign
id|parse_object
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|obj
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;malformed object at &squot;%s&squot;&quot;
)paren
comma
id|refname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|obj-&gt;type
op_eq
id|OBJ_TAG
)paren
id|tagged_sha1
op_assign
(paren
(paren
r_struct
id|tag
op_star
)paren
id|obj
)paren
op_member_access_from_pointer
id|tagged-&gt;sha1
suffix:semicolon
r_if
c_cond
(paren
id|tagged_sha1
op_logical_and
id|sha1_array_lookup
c_func
(paren
op_amp
id|points_at
comma
id|tagged_sha1
)paren
op_ge
l_int|0
)paren
r_return
id|tagged_sha1
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|in_commit_list
r_static
r_int
id|in_commit_list
c_func
(paren
r_const
r_struct
id|commit_list
op_star
id|want
comma
r_struct
id|commit
op_star
id|c
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|want
suffix:semicolon
id|want
op_assign
id|want-&gt;next
)paren
r_if
c_cond
(paren
op_logical_neg
id|hashcmp
c_func
(paren
id|want-&gt;item-&gt;object.sha1
comma
id|c-&gt;object.sha1
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|enum|contains_result
r_enum
id|contains_result
(brace
DECL|enumerator|CONTAINS_UNKNOWN
id|CONTAINS_UNKNOWN
op_assign
l_int|1
comma
DECL|enumerator|CONTAINS_NO
id|CONTAINS_NO
op_assign
l_int|0
comma
DECL|enumerator|CONTAINS_YES
id|CONTAINS_YES
op_assign
l_int|1
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Test whether the candidate or one of its parents is contained in the list.&n; * Do not recurse to find out, though, but return -1 if inconclusive.&n; */
DECL|function|contains_test
r_static
r_enum
id|contains_result
id|contains_test
c_func
(paren
r_struct
id|commit
op_star
id|candidate
comma
r_const
r_struct
id|commit_list
op_star
id|want
)paren
(brace
multiline_comment|/* was it previously marked as containing a want commit? */
r_if
c_cond
(paren
id|candidate-&gt;object.flags
op_amp
id|TMP_MARK
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* or marked as not possibly containing a want commit? */
r_if
c_cond
(paren
id|candidate-&gt;object.flags
op_amp
id|UNINTERESTING
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* or are we it? */
r_if
c_cond
(paren
id|in_commit_list
c_func
(paren
id|want
comma
id|candidate
)paren
)paren
(brace
id|candidate-&gt;object.flags
op_or_assign
id|TMP_MARK
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|parse_commit
c_func
(paren
id|candidate
)paren
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Mimicking the real stack, this stack lives on the heap, avoiding stack&n; * overflows.&n; *&n; * At each recursion step, the stack items points to the commits whose&n; * ancestors are to be inspected.&n; */
DECL|struct|stack
r_struct
id|stack
(brace
DECL|member|nr
DECL|member|alloc
r_int
id|nr
comma
id|alloc
suffix:semicolon
DECL|struct|stack_entry
r_struct
id|stack_entry
(brace
DECL|member|commit
r_struct
id|commit
op_star
id|commit
suffix:semicolon
DECL|member|parents
r_struct
id|commit_list
op_star
id|parents
suffix:semicolon
DECL|member|stack
)brace
op_star
id|stack
suffix:semicolon
)brace
suffix:semicolon
DECL|function|push_to_stack
r_static
r_void
id|push_to_stack
c_func
(paren
r_struct
id|commit
op_star
id|candidate
comma
r_struct
id|stack
op_star
id|stack
)paren
(brace
r_int
id|index
op_assign
id|stack-&gt;nr
op_increment
suffix:semicolon
id|ALLOC_GROW
c_func
(paren
id|stack-&gt;stack
comma
id|stack-&gt;nr
comma
id|stack-&gt;alloc
)paren
suffix:semicolon
id|stack-&gt;stack
(braket
id|index
)braket
dot
id|commit
op_assign
id|candidate
suffix:semicolon
id|stack-&gt;stack
(braket
id|index
)braket
dot
id|parents
op_assign
id|candidate-&gt;parents
suffix:semicolon
)brace
DECL|function|contains
r_static
r_enum
id|contains_result
id|contains
c_func
(paren
r_struct
id|commit
op_star
id|candidate
comma
r_const
r_struct
id|commit_list
op_star
id|want
)paren
(brace
r_struct
id|stack
id|stack
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|NULL
)brace
suffix:semicolon
r_int
id|result
op_assign
id|contains_test
c_func
(paren
id|candidate
comma
id|want
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|CONTAINS_UNKNOWN
)paren
r_return
id|result
suffix:semicolon
id|push_to_stack
c_func
(paren
id|candidate
comma
op_amp
id|stack
)paren
suffix:semicolon
r_while
c_loop
(paren
id|stack.nr
)paren
(brace
r_struct
id|stack_entry
op_star
id|entry
op_assign
op_amp
id|stack.stack
(braket
id|stack.nr
l_int|1
)braket
suffix:semicolon
r_struct
id|commit
op_star
id|commit
op_assign
id|entry-&gt;commit
suffix:semicolon
r_struct
id|commit_list
op_star
id|parents
op_assign
id|entry-&gt;parents
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parents
)paren
(brace
id|commit-&gt;object.flags
op_or_assign
id|UNINTERESTING
suffix:semicolon
id|stack.nr
op_decrement
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If we just popped the stack, parents-&gt;item has been marked,&n;&t;&t; * therefore contains_test will return a meaningful 0 or 1.&n;&t;&t; */
r_else
r_switch
c_cond
(paren
id|contains_test
c_func
(paren
id|parents-&gt;item
comma
id|want
)paren
)paren
(brace
r_case
id|CONTAINS_YES
suffix:colon
id|commit-&gt;object.flags
op_or_assign
id|TMP_MARK
suffix:semicolon
id|stack.nr
op_decrement
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CONTAINS_NO
suffix:colon
id|entry-&gt;parents
op_assign
id|parents-&gt;next
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CONTAINS_UNKNOWN
suffix:colon
id|push_to_stack
c_func
(paren
id|parents-&gt;item
comma
op_amp
id|stack
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|free
c_func
(paren
id|stack.stack
)paren
suffix:semicolon
r_return
id|contains_test
c_func
(paren
id|candidate
comma
id|want
)paren
suffix:semicolon
)brace
DECL|function|show_tag_lines
r_static
r_void
id|show_tag_lines
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
id|lines
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_enum
id|object_type
id|type
suffix:semicolon
r_char
op_star
id|buf
comma
op_star
id|sp
comma
op_star
id|eol
suffix:semicolon
r_int
id|len
suffix:semicolon
id|buf
op_assign
id|read_sha1_file
c_func
(paren
id|sha1
comma
op_amp
id|type
comma
op_amp
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
id|die_errno
c_func
(paren
l_string|&quot;unable to read object %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
id|OBJ_COMMIT
op_logical_and
id|type
op_ne
id|OBJ_TAG
)paren
r_goto
id|free_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|size
)paren
id|die
c_func
(paren
l_string|&quot;an empty %s object %s?&quot;
comma
r_typename
(paren
id|type
)paren
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
multiline_comment|/* skip header */
id|sp
op_assign
id|strstr
c_func
(paren
id|buf
comma
l_string|&quot;&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sp
)paren
r_goto
id|free_return
suffix:semicolon
multiline_comment|/* only take up to &quot;lines&quot; lines, and strip the signature from a tag */
r_if
c_cond
(paren
id|type
op_eq
id|OBJ_TAG
)paren
id|size
op_assign
id|parse_signature
c_func
(paren
id|buf
comma
id|size
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|sp
op_add_assign
l_int|2
suffix:semicolon
id|i
OL
id|lines
op_logical_and
id|sp
OL
id|buf
op_plus
id|size
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
)paren
id|printf
c_func
(paren
l_string|&quot;&bslash;n    &quot;
)paren
suffix:semicolon
id|eol
op_assign
id|memchr
c_func
(paren
id|sp
comma
l_char|&squot;&bslash;n&squot;
comma
id|size
(paren
id|sp
id|buf
)paren
)paren
suffix:semicolon
id|len
op_assign
id|eol
ques
c_cond
id|eol
id|sp
suffix:colon
id|size
(paren
id|sp
id|buf
)paren
suffix:semicolon
id|fwrite
c_func
(paren
id|sp
comma
id|len
comma
l_int|1
comma
id|stdout
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|eol
)paren
r_break
suffix:semicolon
id|sp
op_assign
id|eol
op_plus
l_int|1
suffix:semicolon
)brace
id|free_return
suffix:colon
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
DECL|function|show_reference
r_static
r_int
id|show_reference
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
id|flag
comma
r_void
op_star
id|cb_data
)paren
(brace
r_struct
id|tag_filter
op_star
id|filter
op_assign
id|cb_data
suffix:semicolon
r_if
c_cond
(paren
id|match_pattern
c_func
(paren
id|filter-&gt;patterns
comma
id|refname
)paren
)paren
(brace
r_if
c_cond
(paren
id|filter-&gt;with_commit
)paren
(brace
r_struct
id|commit
op_star
id|commit
suffix:semicolon
id|commit
op_assign
id|lookup_commit_reference_gently
c_func
(paren
id|sha1
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|commit
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|contains
c_func
(paren
id|commit
comma
id|filter-&gt;with_commit
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|points_at.nr
op_logical_and
op_logical_neg
id|match_points_at
c_func
(paren
id|refname
comma
id|sha1
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|filter-&gt;lines
)paren
(brace
r_if
c_cond
(paren
id|filter-&gt;sort
)paren
id|string_list_append
c_func
(paren
op_amp
id|filter-&gt;tags
comma
id|refname
)paren
suffix:semicolon
r_else
id|printf
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|refname
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;%-15s &quot;
comma
id|refname
)paren
suffix:semicolon
id|show_tag_lines
c_func
(paren
id|sha1
comma
id|filter-&gt;lines
)paren
suffix:semicolon
id|putchar
c_func
(paren
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sort_by_version
r_static
r_int
id|sort_by_version
c_func
(paren
r_const
r_void
op_star
id|a_
comma
r_const
r_void
op_star
id|b_
)paren
(brace
r_const
r_struct
id|string_list_item
op_star
id|a
op_assign
id|a_
suffix:semicolon
r_const
r_struct
id|string_list_item
op_star
id|b
op_assign
id|b_
suffix:semicolon
r_return
id|versioncmp
c_func
(paren
id|a-&gt;string
comma
id|b-&gt;string
)paren
suffix:semicolon
)brace
DECL|function|list_tags
r_static
r_int
id|list_tags
c_func
(paren
r_const
r_char
op_star
op_star
id|patterns
comma
r_int
id|lines
comma
r_struct
id|commit_list
op_star
id|with_commit
comma
r_int
id|sort
)paren
(brace
r_struct
id|tag_filter
id|filter
suffix:semicolon
id|filter.patterns
op_assign
id|patterns
suffix:semicolon
id|filter.lines
op_assign
id|lines
suffix:semicolon
id|filter.sort
op_assign
id|sort
suffix:semicolon
id|filter.with_commit
op_assign
id|with_commit
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|filter.tags
comma
l_int|0
comma
r_sizeof
(paren
id|filter.tags
)paren
)paren
suffix:semicolon
id|filter.tags.strdup_strings
op_assign
l_int|1
suffix:semicolon
id|for_each_tag_ref
c_func
(paren
id|show_reference
comma
(paren
r_void
op_star
)paren
op_amp
id|filter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sort
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sort
op_amp
id|SORT_MASK
)paren
op_eq
id|VERCMP_SORT
)paren
id|qsort
c_func
(paren
id|filter.tags.items
comma
id|filter.tags.nr
comma
r_sizeof
(paren
r_struct
id|string_list_item
)paren
comma
id|sort_by_version
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sort
op_amp
id|REVERSE_SORT
)paren
r_for
c_loop
(paren
id|i
op_assign
id|filter.tags.nr
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
id|printf
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|filter.tags.items
(braket
id|i
)braket
dot
id|string
)paren
suffix:semicolon
r_else
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|filter.tags.nr
suffix:semicolon
id|i
op_increment
)paren
id|printf
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|filter.tags.items
(braket
id|i
)braket
dot
id|string
)paren
suffix:semicolon
id|string_list_clear
c_func
(paren
op_amp
id|filter.tags
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|typedef|each_tag_name_fn
r_typedef
r_int
(paren
op_star
id|each_tag_name_fn
)paren
(paren
r_const
r_char
op_star
id|name
comma
r_const
r_char
op_star
id|ref
comma
r_const
r_int
r_char
op_star
id|sha1
)paren
suffix:semicolon
DECL|function|for_each_tag_name
r_static
r_int
id|for_each_tag_name
c_func
(paren
r_const
r_char
op_star
op_star
id|argv
comma
id|each_tag_name_fn
id|fn
)paren
(brace
r_const
r_char
op_star
op_star
id|p
suffix:semicolon
r_char
id|ref
(braket
id|PATH_MAX
)braket
suffix:semicolon
r_int
id|had_error
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|argv
suffix:semicolon
op_star
id|p
suffix:semicolon
id|p
op_increment
)paren
(brace
r_if
c_cond
(paren
id|snprintf
c_func
(paren
id|ref
comma
r_sizeof
(paren
id|ref
)paren
comma
l_string|&quot;refs/tags/%s&quot;
comma
op_star
id|p
)paren
op_ge
r_sizeof
(paren
id|ref
)paren
)paren
(brace
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;tag name too long: %.*s...&quot;
)paren
comma
l_int|50
comma
op_star
id|p
)paren
suffix:semicolon
id|had_error
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|read_ref
c_func
(paren
id|ref
comma
id|sha1
)paren
)paren
(brace
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;tag &squot;%s&squot; not found.&quot;
)paren
comma
op_star
id|p
)paren
suffix:semicolon
id|had_error
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fn
c_func
(paren
op_star
id|p
comma
id|ref
comma
id|sha1
)paren
)paren
id|had_error
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|had_error
suffix:semicolon
)brace
DECL|function|delete_tag
r_static
r_int
id|delete_tag
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_const
r_char
op_star
id|ref
comma
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_if
c_cond
(paren
id|delete_ref
c_func
(paren
id|ref
comma
id|sha1
comma
l_int|0
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|printf
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Deleted tag &squot;%s&squot; (was %s)&bslash;n&quot;
)paren
comma
id|name
comma
id|find_unique_abbrev
c_func
(paren
id|sha1
comma
id|DEFAULT_ABBREV
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|verify_tag
r_static
r_int
id|verify_tag
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_const
r_char
op_star
id|ref
comma
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_const
r_char
op_star
id|argv_verify_tag
(braket
)braket
op_assign
(brace
l_string|&quot;verify-tag&quot;
comma
l_string|&quot;-v&quot;
comma
l_string|&quot;SHA1_HEX&quot;
comma
l_int|NULL
)brace
suffix:semicolon
id|argv_verify_tag
(braket
l_int|2
)braket
op_assign
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|run_command_v_opt
c_func
(paren
id|argv_verify_tag
comma
id|RUN_GIT_CMD
)paren
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;could not verify the tag &squot;%s&squot;&quot;
)paren
comma
id|name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|do_sign
r_static
r_int
id|do_sign
c_func
(paren
r_struct
id|strbuf
op_star
id|buffer
)paren
(brace
r_return
id|sign_buffer
c_func
(paren
id|buffer
comma
id|buffer
comma
id|get_signing_key
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
DECL|variable|tag_template
r_static
r_const
r_char
id|tag_template
(braket
)braket
op_assign
id|N_
c_func
(paren
l_string|&quot;&bslash;nWrite a message for tag:&bslash;n  %s&bslash;n&quot;
l_string|&quot;Lines starting with &squot;%c&squot; will be ignored.&bslash;n&quot;
)paren
suffix:semicolon
DECL|variable|tag_template_nocleanup
r_static
r_const
r_char
id|tag_template_nocleanup
(braket
)braket
op_assign
id|N_
c_func
(paren
l_string|&quot;&bslash;nWrite a message for tag:&bslash;n  %s&bslash;n&quot;
l_string|&quot;Lines starting with &squot;%c&squot; will be kept; you may remove them&quot;
l_string|&quot; yourself if you want to.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n; * Parse a sort string, and return 0 if parsed successfully. Will return&n; * non-zero when the sort string does not parse into a known type. If var is&n; * given, the error message becomes a warning and includes information about&n; * the configuration value.&n; */
DECL|function|parse_sort_string
r_static
r_int
id|parse_sort_string
c_func
(paren
r_const
r_char
op_star
id|var
comma
r_const
r_char
op_star
id|arg
comma
r_int
op_star
id|sort
)paren
(brace
r_int
id|type
op_assign
l_int|0
comma
id|flags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|skip_prefix
c_func
(paren
id|arg
comma
l_string|&quot;-&quot;
comma
op_amp
id|arg
)paren
)paren
id|flags
op_or_assign
id|REVERSE_SORT
suffix:semicolon
r_if
c_cond
(paren
id|skip_prefix
c_func
(paren
id|arg
comma
l_string|&quot;version:&quot;
comma
op_amp
id|arg
)paren
op_logical_or
id|skip_prefix
c_func
(paren
id|arg
comma
l_string|&quot;v:&quot;
comma
op_amp
id|arg
)paren
)paren
id|type
op_assign
id|VERCMP_SORT
suffix:semicolon
r_else
id|type
op_assign
id|STRCMP_SORT
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;refname&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|var
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;unsupported sort specification &squot;%s&squot;&quot;
)paren
comma
id|arg
)paren
suffix:semicolon
r_else
(brace
id|warning
c_func
(paren
id|_
c_func
(paren
l_string|&quot;unsupported sort specification &squot;%s&squot; in variable &squot;%s&squot;&quot;
)paren
comma
id|var
comma
id|arg
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
op_star
id|sort
op_assign
(paren
id|type
op_or
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|git_tag_config
r_static
r_int
id|git_tag_config
c_func
(paren
r_const
r_char
op_star
id|var
comma
r_const
r_char
op_star
id|value
comma
r_void
op_star
id|cb
)paren
(brace
r_int
id|status
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;tag.sort&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
r_return
id|config_error_nonbool
c_func
(paren
id|var
)paren
suffix:semicolon
id|parse_sort_string
c_func
(paren
id|var
comma
id|value
comma
op_amp
id|tag_sort
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|status
op_assign
id|git_gpg_config
c_func
(paren
id|var
comma
id|value
comma
id|cb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
r_return
id|status
suffix:semicolon
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|var
comma
l_string|&quot;column.&quot;
)paren
)paren
r_return
id|git_column_config
c_func
(paren
id|var
comma
id|value
comma
l_string|&quot;tag&quot;
comma
op_amp
id|colopts
)paren
suffix:semicolon
r_return
id|git_default_config
c_func
(paren
id|var
comma
id|value
comma
id|cb
)paren
suffix:semicolon
)brace
DECL|function|write_tag_body
r_static
r_void
id|write_tag_body
c_func
(paren
r_int
id|fd
comma
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_int
r_int
id|size
suffix:semicolon
r_enum
id|object_type
id|type
suffix:semicolon
r_char
op_star
id|buf
comma
op_star
id|sp
suffix:semicolon
id|buf
op_assign
id|read_sha1_file
c_func
(paren
id|sha1
comma
op_amp
id|type
comma
op_amp
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
r_return
suffix:semicolon
multiline_comment|/* skip header */
id|sp
op_assign
id|strstr
c_func
(paren
id|buf
comma
l_string|&quot;&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sp
op_logical_or
op_logical_neg
id|size
op_logical_or
id|type
op_ne
id|OBJ_TAG
)paren
(brace
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sp
op_add_assign
l_int|2
suffix:semicolon
multiline_comment|/* skip the 2 LFs */
id|write_or_die
c_func
(paren
id|fd
comma
id|sp
comma
id|parse_signature
c_func
(paren
id|sp
comma
id|buf
op_plus
id|size
id|sp
)paren
)paren
suffix:semicolon
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
DECL|function|build_tag_object
r_static
r_int
id|build_tag_object
c_func
(paren
r_struct
id|strbuf
op_star
id|buf
comma
r_int
id|sign
comma
r_int
r_char
op_star
id|result
)paren
(brace
r_if
c_cond
(paren
id|sign
op_logical_and
id|do_sign
c_func
(paren
id|buf
)paren
OL
l_int|0
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;unable to sign the tag&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write_sha1_file
c_func
(paren
id|buf-&gt;buf
comma
id|buf-&gt;len
comma
id|tag_type
comma
id|result
)paren
OL
l_int|0
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;unable to write tag file&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|struct|create_tag_options
r_struct
id|create_tag_options
(brace
DECL|member|message_given
r_int
r_int
id|message_given
suffix:colon
l_int|1
suffix:semicolon
DECL|member|sign
r_int
r_int
id|sign
suffix:semicolon
r_enum
(brace
DECL|enumerator|CLEANUP_NONE
id|CLEANUP_NONE
comma
DECL|enumerator|CLEANUP_SPACE
id|CLEANUP_SPACE
comma
DECL|enumerator|CLEANUP_ALL
id|CLEANUP_ALL
DECL|member|cleanup_mode
)brace
id|cleanup_mode
suffix:semicolon
)brace
suffix:semicolon
DECL|function|create_tag
r_static
r_void
id|create_tag
c_func
(paren
r_const
r_int
r_char
op_star
id|object
comma
r_const
r_char
op_star
id|tag
comma
r_struct
id|strbuf
op_star
id|buf
comma
r_struct
id|create_tag_options
op_star
id|opt
comma
r_int
r_char
op_star
id|prev
comma
r_int
r_char
op_star
id|result
)paren
(brace
r_enum
id|object_type
id|type
suffix:semicolon
r_char
id|header_buf
(braket
l_int|1024
)braket
suffix:semicolon
r_int
id|header_len
suffix:semicolon
r_char
op_star
id|path
op_assign
l_int|NULL
suffix:semicolon
id|type
op_assign
id|sha1_object_info
c_func
(paren
id|object
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_le
id|OBJ_NONE
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;bad object type.&quot;
)paren
)paren
suffix:semicolon
id|header_len
op_assign
id|snprintf
c_func
(paren
id|header_buf
comma
r_sizeof
(paren
id|header_buf
)paren
comma
l_string|&quot;object %s&bslash;n&quot;
l_string|&quot;type %s&bslash;n&quot;
l_string|&quot;tag %s&bslash;n&quot;
l_string|&quot;tagger %s&bslash;n&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|object
)paren
comma
r_typename
(paren
id|type
)paren
comma
id|tag
comma
id|git_committer_info
c_func
(paren
id|IDENT_STRICT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|header_len
OG
r_sizeof
(paren
id|header_buf
)paren
l_int|1
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;tag header too big.&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|opt-&gt;message_given
)paren
(brace
r_int
id|fd
suffix:semicolon
multiline_comment|/* write the template message before editing: */
id|path
op_assign
id|git_pathdup
c_func
(paren
l_string|&quot;TAG_EDITMSG&quot;
)paren
suffix:semicolon
id|fd
op_assign
id|open
c_func
(paren
id|path
comma
id|O_CREAT
op_or
id|O_TRUNC
op_or
id|O_WRONLY
comma
l_int|0600
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;could not create file &squot;%s&squot;&quot;
)paren
comma
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_null_sha1
c_func
(paren
id|prev
)paren
)paren
(brace
id|write_tag_body
c_func
(paren
id|fd
comma
id|prev
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|strbuf
id|buf
op_assign
id|STRBUF_INIT
suffix:semicolon
id|strbuf_addch
c_func
(paren
op_amp
id|buf
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opt-&gt;cleanup_mode
op_eq
id|CLEANUP_ALL
)paren
id|strbuf_commented_addf
c_func
(paren
op_amp
id|buf
comma
id|_
c_func
(paren
id|tag_template
)paren
comma
id|tag
comma
id|comment_line_char
)paren
suffix:semicolon
r_else
id|strbuf_commented_addf
c_func
(paren
op_amp
id|buf
comma
id|_
c_func
(paren
id|tag_template_nocleanup
)paren
comma
id|tag
comma
id|comment_line_char
)paren
suffix:semicolon
id|write_or_die
c_func
(paren
id|fd
comma
id|buf.buf
comma
id|buf.len
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|buf
)paren
suffix:semicolon
)brace
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|launch_editor
c_func
(paren
id|path
comma
id|buf
comma
l_int|NULL
)paren
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
id|_
c_func
(paren
l_string|&quot;Please supply the message using either -m or -F option.&bslash;n&quot;
)paren
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|opt-&gt;cleanup_mode
op_ne
id|CLEANUP_NONE
)paren
id|stripspace
c_func
(paren
id|buf
comma
id|opt-&gt;cleanup_mode
op_eq
id|CLEANUP_ALL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|opt-&gt;message_given
op_logical_and
op_logical_neg
id|buf-&gt;len
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;no tag message?&quot;
)paren
)paren
suffix:semicolon
id|strbuf_insert
c_func
(paren
id|buf
comma
l_int|0
comma
id|header_buf
comma
id|header_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|build_tag_object
c_func
(paren
id|buf
comma
id|opt-&gt;sign
comma
id|result
)paren
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|path
)paren
id|fprintf
c_func
(paren
id|stderr
comma
id|_
c_func
(paren
l_string|&quot;The tag message has been left in %s&bslash;n&quot;
)paren
comma
id|path
)paren
suffix:semicolon
m_exit
(paren
l_int|128
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|path
)paren
(brace
id|unlink_or_warn
c_func
(paren
id|path
)paren
suffix:semicolon
id|free
c_func
(paren
id|path
)paren
suffix:semicolon
)brace
)brace
DECL|struct|msg_arg
r_struct
id|msg_arg
(brace
DECL|member|given
r_int
id|given
suffix:semicolon
DECL|member|buf
r_struct
id|strbuf
id|buf
suffix:semicolon
)brace
suffix:semicolon
DECL|function|parse_msg_arg
r_static
r_int
id|parse_msg_arg
c_func
(paren
r_const
r_struct
id|option
op_star
id|opt
comma
r_const
r_char
op_star
id|arg
comma
r_int
id|unset
)paren
(brace
r_struct
id|msg_arg
op_star
id|msg
op_assign
id|opt-&gt;value
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|msg-&gt;buf.len
)paren
id|strbuf_addstr
c_func
(paren
op_amp
(paren
id|msg-&gt;buf
)paren
comma
l_string|&quot;&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
(paren
id|msg-&gt;buf
)paren
comma
id|arg
)paren
suffix:semicolon
id|msg-&gt;given
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|strbuf_check_tag_ref
r_static
r_int
id|strbuf_check_tag_ref
c_func
(paren
r_struct
id|strbuf
op_star
id|sb
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_if
c_cond
(paren
id|name
(braket
l_int|0
)braket
op_eq
l_char|&squot;-&squot;
)paren
r_return
l_int|1
suffix:semicolon
id|strbuf_reset
c_func
(paren
id|sb
)paren
suffix:semicolon
id|strbuf_addf
c_func
(paren
id|sb
comma
l_string|&quot;refs/tags/%s&quot;
comma
id|name
)paren
suffix:semicolon
r_return
id|check_refname_format
c_func
(paren
id|sb-&gt;buf
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|parse_opt_points_at
r_static
r_int
id|parse_opt_points_at
c_func
(paren
r_const
r_struct
id|option
op_star
id|opt
id|__attribute__
c_func
(paren
(paren
id|unused
)paren
)paren
comma
r_const
r_char
op_star
id|arg
comma
r_int
id|unset
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_if
c_cond
(paren
id|unset
)paren
(brace
id|sha1_array_clear
c_func
(paren
op_amp
id|points_at
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;switch &squot;points-at&squot; requires an object&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1
c_func
(paren
id|arg
comma
id|sha1
)paren
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;malformed object name &squot;%s&squot;&quot;
)paren
comma
id|arg
)paren
suffix:semicolon
id|sha1_array_append
c_func
(paren
op_amp
id|points_at
comma
id|sha1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|parse_opt_sort
r_static
r_int
id|parse_opt_sort
c_func
(paren
r_const
r_struct
id|option
op_star
id|opt
comma
r_const
r_char
op_star
id|arg
comma
r_int
id|unset
)paren
(brace
r_int
op_star
id|sort
op_assign
id|opt-&gt;value
suffix:semicolon
r_return
id|parse_sort_string
c_func
(paren
l_int|NULL
comma
id|arg
comma
id|sort
)paren
suffix:semicolon
)brace
DECL|function|cmd_tag
r_int
id|cmd_tag
c_func
(paren
r_int
id|argc
comma
r_const
r_char
op_star
op_star
id|argv
comma
r_const
r_char
op_star
id|prefix
)paren
(brace
r_struct
id|strbuf
id|buf
op_assign
id|STRBUF_INIT
suffix:semicolon
r_struct
id|strbuf
id|ref
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
r_char
id|object
(braket
l_int|20
)braket
comma
id|prev
(braket
l_int|20
)braket
suffix:semicolon
r_const
r_char
op_star
id|object_ref
comma
op_star
id|tag
suffix:semicolon
r_struct
id|ref_lock
op_star
id|lock
suffix:semicolon
r_struct
id|create_tag_options
id|opt
suffix:semicolon
r_char
op_star
id|cleanup_arg
op_assign
l_int|NULL
suffix:semicolon
r_int
id|annotate
op_assign
l_int|0
comma
id|force
op_assign
l_int|0
comma
id|lines
op_assign
l_int|1
suffix:semicolon
r_int
id|cmdmode
op_assign
l_int|0
suffix:semicolon
r_const
r_char
op_star
id|msgfile
op_assign
l_int|NULL
comma
op_star
id|keyid
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|msg_arg
id|msg
op_assign
(brace
l_int|0
comma
id|STRBUF_INIT
)brace
suffix:semicolon
r_struct
id|commit_list
op_star
id|with_commit
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|option
id|options
(braket
)braket
op_assign
(brace
id|OPT_CMDMODE
c_func
(paren
l_char|&squot;l&squot;
comma
l_string|&quot;list&quot;
comma
op_amp
id|cmdmode
comma
id|N_
c_func
(paren
l_string|&quot;list tag names&quot;
)paren
comma
l_char|&squot;l&squot;
)paren
comma
(brace
id|OPTION_INTEGER
comma
l_char|&squot;n&squot;
comma
l_int|NULL
comma
op_amp
id|lines
comma
id|N_
c_func
(paren
l_string|&quot;n&quot;
)paren
comma
id|N_
c_func
(paren
l_string|&quot;print &lt;n&gt; lines of each tag message&quot;
)paren
comma
id|PARSE_OPT_OPTARG
comma
l_int|NULL
comma
l_int|1
)brace
comma
id|OPT_CMDMODE
c_func
(paren
l_char|&squot;d&squot;
comma
l_string|&quot;delete&quot;
comma
op_amp
id|cmdmode
comma
id|N_
c_func
(paren
l_string|&quot;delete tags&quot;
)paren
comma
l_char|&squot;d&squot;
)paren
comma
id|OPT_CMDMODE
c_func
(paren
l_char|&squot;v&squot;
comma
l_string|&quot;verify&quot;
comma
op_amp
id|cmdmode
comma
id|N_
c_func
(paren
l_string|&quot;verify tags&quot;
)paren
comma
l_char|&squot;v&squot;
)paren
comma
id|OPT_GROUP
c_func
(paren
id|N_
c_func
(paren
l_string|&quot;Tag creation options&quot;
)paren
)paren
comma
id|OPT_BOOL
c_func
(paren
l_char|&squot;a&squot;
comma
l_string|&quot;annotate&quot;
comma
op_amp
id|annotate
comma
id|N_
c_func
(paren
l_string|&quot;annotated tag, needs a message&quot;
)paren
)paren
comma
id|OPT_CALLBACK
c_func
(paren
l_char|&squot;m&squot;
comma
l_string|&quot;message&quot;
comma
op_amp
id|msg
comma
id|N_
c_func
(paren
l_string|&quot;message&quot;
)paren
comma
id|N_
c_func
(paren
l_string|&quot;tag message&quot;
)paren
comma
id|parse_msg_arg
)paren
comma
id|OPT_FILENAME
c_func
(paren
l_char|&squot;F&squot;
comma
l_string|&quot;file&quot;
comma
op_amp
id|msgfile
comma
id|N_
c_func
(paren
l_string|&quot;read message from file&quot;
)paren
)paren
comma
id|OPT_BOOL
c_func
(paren
l_char|&squot;s&squot;
comma
l_string|&quot;sign&quot;
comma
op_amp
id|opt.sign
comma
id|N_
c_func
(paren
l_string|&quot;annotated and GPG-signed tag&quot;
)paren
)paren
comma
id|OPT_STRING
c_func
(paren
l_int|0
comma
l_string|&quot;cleanup&quot;
comma
op_amp
id|cleanup_arg
comma
id|N_
c_func
(paren
l_string|&quot;mode&quot;
)paren
comma
id|N_
c_func
(paren
l_string|&quot;how to strip spaces and #comments from message&quot;
)paren
)paren
comma
id|OPT_STRING
c_func
(paren
l_char|&squot;u&squot;
comma
l_string|&quot;local-user&quot;
comma
op_amp
id|keyid
comma
id|N_
c_func
(paren
l_string|&quot;key-id&quot;
)paren
comma
id|N_
c_func
(paren
l_string|&quot;use another key to sign the tag&quot;
)paren
)paren
comma
id|OPT__FORCE
c_func
(paren
op_amp
id|force
comma
id|N_
c_func
(paren
l_string|&quot;replace the tag if exists&quot;
)paren
)paren
comma
id|OPT_GROUP
c_func
(paren
id|N_
c_func
(paren
l_string|&quot;Tag listing options&quot;
)paren
)paren
comma
id|OPT_COLUMN
c_func
(paren
l_int|0
comma
l_string|&quot;column&quot;
comma
op_amp
id|colopts
comma
id|N_
c_func
(paren
l_string|&quot;show tag list in columns&quot;
)paren
)paren
comma
(brace
id|OPTION_CALLBACK
comma
l_int|0
comma
l_string|&quot;sort&quot;
comma
op_amp
id|tag_sort
comma
id|N_
c_func
(paren
l_string|&quot;type&quot;
)paren
comma
id|N_
c_func
(paren
l_string|&quot;sort tags&quot;
)paren
comma
id|PARSE_OPT_NONEG
comma
id|parse_opt_sort
)brace
comma
(brace
id|OPTION_CALLBACK
comma
l_int|0
comma
l_string|&quot;contains&quot;
comma
op_amp
id|with_commit
comma
id|N_
c_func
(paren
l_string|&quot;commit&quot;
)paren
comma
id|N_
c_func
(paren
l_string|&quot;print only tags that contain the commit&quot;
)paren
comma
id|PARSE_OPT_LASTARG_DEFAULT
comma
id|parse_opt_with_commit
comma
(paren
r_intptr
)paren
l_string|&quot;HEAD&quot;
comma
)brace
comma
(brace
id|OPTION_CALLBACK
comma
l_int|0
comma
l_string|&quot;with&quot;
comma
op_amp
id|with_commit
comma
id|N_
c_func
(paren
l_string|&quot;commit&quot;
)paren
comma
id|N_
c_func
(paren
l_string|&quot;print only tags that contain the commit&quot;
)paren
comma
id|PARSE_OPT_HIDDEN
op_or
id|PARSE_OPT_LASTARG_DEFAULT
comma
id|parse_opt_with_commit
comma
(paren
r_intptr
)paren
l_string|&quot;HEAD&quot;
comma
)brace
comma
(brace
id|OPTION_CALLBACK
comma
l_int|0
comma
l_string|&quot;points-at&quot;
comma
l_int|NULL
comma
id|N_
c_func
(paren
l_string|&quot;object&quot;
)paren
comma
id|N_
c_func
(paren
l_string|&quot;print only tags of the object&quot;
)paren
comma
l_int|0
comma
id|parse_opt_points_at
)brace
comma
id|OPT_END
c_func
(paren
)paren
)brace
suffix:semicolon
id|git_config
c_func
(paren
id|git_tag_config
comma
l_int|NULL
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|opt
comma
l_int|0
comma
r_sizeof
(paren
id|opt
)paren
)paren
suffix:semicolon
id|argc
op_assign
id|parse_options
c_func
(paren
id|argc
comma
id|argv
comma
id|prefix
comma
id|options
comma
id|git_tag_usage
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|keyid
)paren
(brace
id|opt.sign
op_assign
l_int|1
suffix:semicolon
id|set_signing_key
c_func
(paren
id|keyid
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|opt.sign
)paren
id|annotate
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|argc
op_eq
l_int|0
op_logical_and
op_logical_neg
id|cmdmode
)paren
id|cmdmode
op_assign
l_char|&squot;l&squot;
suffix:semicolon
r_if
c_cond
(paren
(paren
id|annotate
op_logical_or
id|msg.given
op_logical_or
id|msgfile
op_logical_or
id|force
)paren
op_logical_and
(paren
id|cmdmode
op_ne
l_int|0
)paren
)paren
id|usage_with_options
c_func
(paren
id|git_tag_usage
comma
id|options
)paren
suffix:semicolon
id|finalize_colopts
c_func
(paren
op_amp
id|colopts
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmdmode
op_eq
l_char|&squot;l&squot;
op_logical_and
id|lines
op_ne
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|explicitly_enable_column
c_func
(paren
id|colopts
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;--column and -n are incompatible&quot;
)paren
)paren
suffix:semicolon
id|colopts
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmdmode
op_eq
l_char|&squot;l&squot;
)paren
(brace
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|column_active
c_func
(paren
id|colopts
)paren
)paren
(brace
r_struct
id|column_options
id|copts
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|copts
comma
l_int|0
comma
r_sizeof
(paren
id|copts
)paren
)paren
suffix:semicolon
id|copts.padding
op_assign
l_int|2
suffix:semicolon
id|run_column_filter
c_func
(paren
id|colopts
comma
op_amp
id|copts
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lines
op_ne
l_int|1
op_logical_and
id|tag_sort
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;--sort and -n are incompatible&quot;
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|list_tags
c_func
(paren
id|argv
comma
id|lines
op_eq
l_int|1
ques
c_cond
l_int|0
suffix:colon
id|lines
comma
id|with_commit
comma
id|tag_sort
)paren
suffix:semicolon
r_if
c_cond
(paren
id|column_active
c_func
(paren
id|colopts
)paren
)paren
id|stop_column_filter
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lines
op_ne
l_int|1
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;-n option is only allowed with -l.&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|with_commit
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;--contains option is only allowed with -l.&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|points_at.nr
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;--points-at option is only allowed with -l.&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmdmode
op_eq
l_char|&squot;d&squot;
)paren
r_return
id|for_each_tag_name
c_func
(paren
id|argv
comma
id|delete_tag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmdmode
op_eq
l_char|&squot;v&squot;
)paren
r_return
id|for_each_tag_name
c_func
(paren
id|argv
comma
id|verify_tag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg.given
op_logical_or
id|msgfile
)paren
(brace
r_if
c_cond
(paren
id|msg.given
op_logical_and
id|msgfile
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;only one -F or -m option is allowed.&quot;
)paren
)paren
suffix:semicolon
id|annotate
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|msg.given
)paren
id|strbuf_addbuf
c_func
(paren
op_amp
id|buf
comma
op_amp
(paren
id|msg.buf
)paren
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|msgfile
comma
l_string|&quot;-&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|strbuf_read
c_func
(paren
op_amp
id|buf
comma
l_int|0
comma
l_int|1024
)paren
OL
l_int|0
)paren
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;cannot read &squot;%s&squot;&quot;
)paren
comma
id|msgfile
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|strbuf_read_file
c_func
(paren
op_amp
id|buf
comma
id|msgfile
comma
l_int|1024
)paren
OL
l_int|0
)paren
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;could not open or read &squot;%s&squot;&quot;
)paren
comma
id|msgfile
)paren
suffix:semicolon
)brace
)brace
)brace
id|tag
op_assign
id|argv
(braket
l_int|0
)braket
suffix:semicolon
id|object_ref
op_assign
id|argc
op_eq
l_int|2
ques
c_cond
id|argv
(braket
l_int|1
)braket
suffix:colon
l_string|&quot;HEAD&quot;
suffix:semicolon
r_if
c_cond
(paren
id|argc
OG
l_int|2
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;too many params&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1
c_func
(paren
id|object_ref
comma
id|object
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Failed to resolve &squot;%s&squot; as a valid ref.&quot;
)paren
comma
id|object_ref
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strbuf_check_tag_ref
c_func
(paren
op_amp
id|ref
comma
id|tag
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;&squot;%s&squot; is not a valid tag name.&quot;
)paren
comma
id|tag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_ref
c_func
(paren
id|ref.buf
comma
id|prev
)paren
)paren
id|hashclr
c_func
(paren
id|prev
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|force
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;tag &squot;%s&squot; already exists&quot;
)paren
comma
id|tag
)paren
suffix:semicolon
id|opt.message_given
op_assign
id|msg.given
op_logical_or
id|msgfile
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cleanup_arg
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|cleanup_arg
comma
l_string|&quot;strip&quot;
)paren
)paren
id|opt.cleanup_mode
op_assign
id|CLEANUP_ALL
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|cleanup_arg
comma
l_string|&quot;verbatim&quot;
)paren
)paren
id|opt.cleanup_mode
op_assign
id|CLEANUP_NONE
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|cleanup_arg
comma
l_string|&quot;whitespace&quot;
)paren
)paren
id|opt.cleanup_mode
op_assign
id|CLEANUP_SPACE
suffix:semicolon
r_else
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Invalid cleanup mode %s&quot;
)paren
comma
id|cleanup_arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|annotate
)paren
id|create_tag
c_func
(paren
id|object
comma
id|tag
comma
op_amp
id|buf
comma
op_amp
id|opt
comma
id|prev
comma
id|object
)paren
suffix:semicolon
id|lock
op_assign
id|lock_any_ref_for_update
c_func
(paren
id|ref.buf
comma
id|prev
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lock
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;%s: cannot lock the ref&quot;
)paren
comma
id|ref.buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write_ref_sha1
c_func
(paren
id|lock
comma
id|object
comma
l_int|NULL
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;%s: cannot update the ref&quot;
)paren
comma
id|ref.buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|force
op_logical_and
op_logical_neg
id|is_null_sha1
c_func
(paren
id|prev
)paren
op_logical_and
id|hashcmp
c_func
(paren
id|prev
comma
id|object
)paren
)paren
id|printf
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Updated tag &squot;%s&squot; (was %s)&bslash;n&quot;
)paren
comma
id|tag
comma
id|find_unique_abbrev
c_func
(paren
id|prev
comma
id|DEFAULT_ABBREV
)paren
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|buf
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|ref
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
