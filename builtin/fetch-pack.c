macro_line|#include &quot;builtin.h&quot;
macro_line|#include &quot;pkt-line.h&quot;
macro_line|#include &quot;fetch-pack.h&quot;
macro_line|#include &quot;remote.h&quot;
macro_line|#include &quot;connect.h&quot;
macro_line|#include &quot;sha1-array.h&quot;
DECL|variable|fetch_pack_usage
r_static
r_const
r_char
id|fetch_pack_usage
(braket
)braket
op_assign
l_string|&quot;git fetch-pack [--all] [--stdin] [--quiet|-q] [--keep|-k] [--thin] &quot;
l_string|&quot;[--include-tag] [--upload-pack=&lt;git-upload-pack&gt;] [--depth=&lt;n&gt;] &quot;
l_string|&quot;[--no-progress] [-v] [&lt;host&gt;:]&lt;directory&gt; [&lt;refs&gt;...]&quot;
suffix:semicolon
DECL|function|add_sought_entry_mem
r_static
r_void
id|add_sought_entry_mem
c_func
(paren
r_struct
id|ref
op_star
op_star
op_star
id|sought
comma
r_int
op_star
id|nr
comma
r_int
op_star
id|alloc
comma
r_const
r_char
op_star
id|name
comma
r_int
id|namelen
)paren
(brace
r_struct
id|ref
op_star
id|ref
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|ref
)paren
op_plus
id|namelen
op_plus
l_int|1
)paren
suffix:semicolon
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_if
c_cond
(paren
id|namelen
OG
l_int|41
op_logical_and
id|name
(braket
l_int|40
)braket
op_eq
l_char|&squot; &squot;
op_logical_and
op_logical_neg
id|get_sha1_hex
c_func
(paren
id|name
comma
id|sha1
)paren
)paren
(brace
id|hashcpy
c_func
(paren
id|ref-&gt;old_sha1
comma
id|sha1
)paren
suffix:semicolon
id|name
op_add_assign
l_int|41
suffix:semicolon
id|namelen
op_sub_assign
l_int|41
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|ref-&gt;name
comma
id|name
comma
id|namelen
)paren
suffix:semicolon
id|ref-&gt;name
(braket
id|namelen
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
(paren
op_star
id|nr
)paren
op_increment
suffix:semicolon
id|ALLOC_GROW
c_func
(paren
op_star
id|sought
comma
op_star
id|nr
comma
op_star
id|alloc
)paren
suffix:semicolon
(paren
op_star
id|sought
)paren
(braket
op_star
id|nr
l_int|1
)braket
op_assign
id|ref
suffix:semicolon
)brace
DECL|function|add_sought_entry
r_static
r_void
id|add_sought_entry
c_func
(paren
r_struct
id|ref
op_star
op_star
op_star
id|sought
comma
r_int
op_star
id|nr
comma
r_int
op_star
id|alloc
comma
r_const
r_char
op_star
id|string
)paren
(brace
id|add_sought_entry_mem
c_func
(paren
id|sought
comma
id|nr
comma
id|alloc
comma
id|string
comma
id|strlen
c_func
(paren
id|string
)paren
)paren
suffix:semicolon
)brace
DECL|function|cmd_fetch_pack
r_int
id|cmd_fetch_pack
c_func
(paren
r_int
id|argc
comma
r_const
r_char
op_star
op_star
id|argv
comma
r_const
r_char
op_star
id|prefix
)paren
(brace
r_int
id|i
comma
id|ret
suffix:semicolon
r_struct
id|ref
op_star
id|ref
op_assign
l_int|NULL
suffix:semicolon
r_const
r_char
op_star
id|dest
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|ref
op_star
op_star
id|sought
op_assign
l_int|NULL
suffix:semicolon
r_int
id|nr_sought
op_assign
l_int|0
comma
id|alloc_sought
op_assign
l_int|0
suffix:semicolon
r_int
id|fd
(braket
l_int|2
)braket
suffix:semicolon
r_char
op_star
id|pack_lockfile
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
op_star
id|pack_lockfile_ptr
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|child_process
op_star
id|conn
suffix:semicolon
r_struct
id|fetch_pack_args
id|args
suffix:semicolon
r_struct
id|sha1_array
id|shallow
op_assign
id|SHA1_ARRAY_INIT
suffix:semicolon
id|packet_trace_identity
c_func
(paren
l_string|&quot;fetch-pack&quot;
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|args
)paren
)paren
suffix:semicolon
id|args.uploadpack
op_assign
l_string|&quot;git-upload-pack&quot;
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|argc
op_logical_and
op_star
id|argv
(braket
id|i
)braket
op_eq
l_char|&squot;-&squot;
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_char
op_star
id|arg
op_assign
id|argv
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;--upload-pack=&quot;
)paren
)paren
(brace
id|args.uploadpack
op_assign
id|arg
op_plus
l_int|14
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;--exec=&quot;
)paren
)paren
(brace
id|args.uploadpack
op_assign
id|arg
op_plus
l_int|7
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--quiet&quot;
comma
id|arg
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;-q&quot;
comma
id|arg
)paren
)paren
(brace
id|args.quiet
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--keep&quot;
comma
id|arg
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;-k&quot;
comma
id|arg
)paren
)paren
(brace
id|args.lock_pack
op_assign
id|args.keep_pack
suffix:semicolon
id|args.keep_pack
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--thin&quot;
comma
id|arg
)paren
)paren
(brace
id|args.use_thin_pack
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--include-tag&quot;
comma
id|arg
)paren
)paren
(brace
id|args.include_tag
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--all&quot;
comma
id|arg
)paren
)paren
(brace
id|args.fetch_all
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--stdin&quot;
comma
id|arg
)paren
)paren
(brace
id|args.stdin_refs
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;-v&quot;
comma
id|arg
)paren
)paren
(brace
id|args.verbose
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;--depth=&quot;
)paren
)paren
(brace
id|args.depth
op_assign
id|strtol
c_func
(paren
id|arg
op_plus
l_int|8
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--no-progress&quot;
comma
id|arg
)paren
)paren
(brace
id|args.no_progress
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--stateless-rpc&quot;
comma
id|arg
)paren
)paren
(brace
id|args.stateless_rpc
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--lock-pack&quot;
comma
id|arg
)paren
)paren
(brace
id|args.lock_pack
op_assign
l_int|1
suffix:semicolon
id|pack_lockfile_ptr
op_assign
op_amp
id|pack_lockfile
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--check-self-contained-and-connected&quot;
comma
id|arg
)paren
)paren
(brace
id|args.check_self_contained_and_connected
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--cloning&quot;
comma
id|arg
)paren
)paren
(brace
id|args.cloning
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--update-shallow&quot;
comma
id|arg
)paren
)paren
(brace
id|args.update_shallow
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|usage
c_func
(paren
id|fetch_pack_usage
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
OL
id|argc
)paren
id|dest
op_assign
id|argv
(braket
id|i
op_increment
)braket
suffix:semicolon
r_else
id|usage
c_func
(paren
id|fetch_pack_usage
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Copy refs from cmdline to growable list, then append any&n;&t; * refs from the standard input:&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
id|argc
suffix:semicolon
id|i
op_increment
)paren
id|add_sought_entry
c_func
(paren
op_amp
id|sought
comma
op_amp
id|nr_sought
comma
op_amp
id|alloc_sought
comma
id|argv
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|args.stdin_refs
)paren
(brace
r_if
c_cond
(paren
id|args.stateless_rpc
)paren
(brace
multiline_comment|/* in stateless RPC mode we use pkt-line to read&n;&t;&t;&t; * from stdin, until we get a flush packet&n;&t;&t;&t; */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_char
op_star
id|line
op_assign
id|packet_read_line
c_func
(paren
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|line
)paren
r_break
suffix:semicolon
id|add_sought_entry
c_func
(paren
op_amp
id|sought
comma
op_amp
id|nr_sought
comma
op_amp
id|alloc_sought
comma
id|line
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* read from stdin one ref per line, until EOF */
r_struct
id|strbuf
id|line
op_assign
id|STRBUF_INIT
suffix:semicolon
r_while
c_loop
(paren
id|strbuf_getline
c_func
(paren
op_amp
id|line
comma
id|stdin
comma
l_char|&squot;&bslash;n&squot;
)paren
op_ne
id|EOF
)paren
id|add_sought_entry
c_func
(paren
op_amp
id|sought
comma
op_amp
id|nr_sought
comma
op_amp
id|alloc_sought
comma
id|line.buf
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|line
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|args.stateless_rpc
)paren
(brace
id|conn
op_assign
l_int|NULL
suffix:semicolon
id|fd
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|fd
(braket
l_int|1
)braket
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|conn
op_assign
id|git_connect
c_func
(paren
id|fd
comma
id|dest
comma
id|args.uploadpack
comma
id|args.verbose
ques
c_cond
id|CONNECT_VERBOSE
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
id|get_remote_heads
c_func
(paren
id|fd
(braket
l_int|0
)braket
comma
l_int|NULL
comma
l_int|0
comma
op_amp
id|ref
comma
l_int|0
comma
l_int|NULL
comma
op_amp
id|shallow
)paren
suffix:semicolon
id|ref
op_assign
id|fetch_pack
c_func
(paren
op_amp
id|args
comma
id|fd
comma
id|conn
comma
id|ref
comma
id|dest
comma
id|sought
comma
id|nr_sought
comma
op_amp
id|shallow
comma
id|pack_lockfile_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pack_lockfile
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;lock %s&bslash;n&quot;
comma
id|pack_lockfile
)paren
suffix:semicolon
id|fflush
c_func
(paren
id|stdout
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|args.check_self_contained_and_connected
op_logical_and
id|args.self_contained_and_connected
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;connectivity-ok&bslash;n&quot;
)paren
suffix:semicolon
id|fflush
c_func
(paren
id|stdout
)paren
suffix:semicolon
)brace
id|close
c_func
(paren
id|fd
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|close
c_func
(paren
id|fd
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|finish_connect
c_func
(paren
id|conn
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|ret
op_assign
op_logical_neg
id|ref
suffix:semicolon
multiline_comment|/*&n;&t; * If the heads to pull were given, we should have consumed&n;&t; * all of them by matching the remote.  Otherwise, &squot;git fetch&n;&t; * remote no-such-ref&squot; would silently succeed without issuing&n;&t; * an error.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_sought
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sought
(braket
id|i
)braket
op_logical_or
id|sought
(braket
id|i
)braket
op_member_access_from_pointer
id|matched
)paren
r_continue
suffix:semicolon
id|error
c_func
(paren
l_string|&quot;no such remote ref %s&quot;
comma
id|sought
(braket
id|i
)braket
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
)brace
r_while
c_loop
(paren
id|ref
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s %s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|ref-&gt;old_sha1
)paren
comma
id|ref-&gt;name
)paren
suffix:semicolon
id|ref
op_assign
id|ref-&gt;next
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
eof
