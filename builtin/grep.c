multiline_comment|/*&n; * Builtin &quot;git grep&quot;&n; *&n; * Copyright (c) 2006 Junio C Hamano&n; */
macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;blob.h&quot;
macro_line|#include &quot;tree.h&quot;
macro_line|#include &quot;commit.h&quot;
macro_line|#include &quot;tag.h&quot;
macro_line|#include &quot;tree-walk.h&quot;
macro_line|#include &quot;builtin.h&quot;
macro_line|#include &quot;parse-options.h&quot;
macro_line|#include &quot;userdiff.h&quot;
macro_line|#include &quot;grep.h&quot;
macro_line|#include &quot;quote.h&quot;
macro_line|#include &quot;dir.h&quot;
macro_line|#ifndef NO_PTHREADS
macro_line|#include &quot;thread-utils.h&quot;
macro_line|#include &lt;pthread.h&gt;
macro_line|#endif
DECL|variable|grep_usage
r_static
r_char
r_const
op_star
r_const
id|grep_usage
(braket
)braket
op_assign
(brace
l_string|&quot;git grep [options] [-e] &lt;pattern&gt; [&lt;rev&gt;...] [[--] path...]&quot;
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|use_threads
r_static
r_int
id|use_threads
op_assign
l_int|1
suffix:semicolon
macro_line|#ifndef NO_PTHREADS
DECL|macro|THREADS
mdefine_line|#define THREADS 8
DECL|variable|threads
r_static
id|pthread_t
id|threads
(braket
id|THREADS
)braket
suffix:semicolon
r_static
r_void
op_star
id|load_sha1
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
r_int
op_star
id|size
comma
r_const
r_char
op_star
id|name
)paren
suffix:semicolon
r_static
r_void
op_star
id|load_file
c_func
(paren
r_const
r_char
op_star
id|filename
comma
r_int
op_star
id|sz
)paren
suffix:semicolon
DECL|enum|work_type
DECL|enumerator|WORK_SHA1
DECL|enumerator|WORK_FILE
r_enum
id|work_type
(brace
id|WORK_SHA1
comma
id|WORK_FILE
)brace
suffix:semicolon
multiline_comment|/* We use one producer thread and THREADS consumer&n; * threads. The producer adds struct work_items to &squot;todo&squot; and the&n; * consumers pick work items from the same array.&n; */
DECL|struct|work_item
r_struct
id|work_item
(brace
DECL|member|type
r_enum
id|work_type
id|type
suffix:semicolon
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
multiline_comment|/* if type == WORK_SHA1, then &squot;identifier&squot; is a SHA1,&n;&t; * otherwise type == WORK_FILE, and &squot;identifier&squot; is a NUL&n;&t; * terminated filename.&n;&t; */
DECL|member|identifier
r_void
op_star
id|identifier
suffix:semicolon
DECL|member|done
r_char
id|done
suffix:semicolon
DECL|member|out
r_struct
id|strbuf
id|out
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* In the range [todo_done, todo_start) in &squot;todo&squot; we have work_items&n; * that have been or are processed by a consumer thread. We haven&squot;t&n; * written the result for these to stdout yet.&n; *&n; * The work_items in [todo_start, todo_end) are waiting to be picked&n; * up by a consumer thread.&n; *&n; * The ranges are modulo TODO_SIZE.&n; */
DECL|macro|TODO_SIZE
mdefine_line|#define TODO_SIZE 128
DECL|variable|todo
r_static
r_struct
id|work_item
id|todo
(braket
id|TODO_SIZE
)braket
suffix:semicolon
DECL|variable|todo_start
r_static
r_int
id|todo_start
suffix:semicolon
DECL|variable|todo_end
r_static
r_int
id|todo_end
suffix:semicolon
DECL|variable|todo_done
r_static
r_int
id|todo_done
suffix:semicolon
multiline_comment|/* Has all work items been added? */
DECL|variable|all_work_added
r_static
r_int
id|all_work_added
suffix:semicolon
multiline_comment|/* This lock protects all the variables above. */
DECL|variable|grep_mutex
r_static
id|pthread_mutex_t
id|grep_mutex
suffix:semicolon
multiline_comment|/* Used to serialize calls to read_sha1_file. */
DECL|variable|read_sha1_mutex
r_static
id|pthread_mutex_t
id|read_sha1_mutex
suffix:semicolon
DECL|macro|grep_lock
mdefine_line|#define grep_lock() pthread_mutex_lock(&amp;grep_mutex)
DECL|macro|grep_unlock
mdefine_line|#define grep_unlock() pthread_mutex_unlock(&amp;grep_mutex)
DECL|macro|read_sha1_lock
mdefine_line|#define read_sha1_lock() pthread_mutex_lock(&amp;read_sha1_mutex)
DECL|macro|read_sha1_unlock
mdefine_line|#define read_sha1_unlock() pthread_mutex_unlock(&amp;read_sha1_mutex)
multiline_comment|/* Signalled when a new work_item is added to todo. */
DECL|variable|cond_add
r_static
id|pthread_cond_t
id|cond_add
suffix:semicolon
multiline_comment|/* Signalled when the result from one work_item is written to&n; * stdout.&n; */
DECL|variable|cond_write
r_static
id|pthread_cond_t
id|cond_write
suffix:semicolon
multiline_comment|/* Signalled when we are finished with everything. */
DECL|variable|cond_result
r_static
id|pthread_cond_t
id|cond_result
suffix:semicolon
DECL|variable|print_hunk_marks_between_files
r_static
r_int
id|print_hunk_marks_between_files
suffix:semicolon
DECL|variable|printed_something
r_static
r_int
id|printed_something
suffix:semicolon
DECL|function|add_work
r_static
r_void
id|add_work
c_func
(paren
r_enum
id|work_type
id|type
comma
r_char
op_star
id|name
comma
r_void
op_star
id|id
)paren
(brace
id|grep_lock
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|todo_end
op_plus
l_int|1
)paren
op_mod
id|ARRAY_SIZE
c_func
(paren
id|todo
)paren
op_eq
id|todo_done
)paren
(brace
id|pthread_cond_wait
c_func
(paren
op_amp
id|cond_write
comma
op_amp
id|grep_mutex
)paren
suffix:semicolon
)brace
id|todo
(braket
id|todo_end
)braket
dot
id|type
op_assign
id|type
suffix:semicolon
id|todo
(braket
id|todo_end
)braket
dot
id|name
op_assign
id|name
suffix:semicolon
id|todo
(braket
id|todo_end
)braket
dot
id|identifier
op_assign
id|id
suffix:semicolon
id|todo
(braket
id|todo_end
)braket
dot
id|done
op_assign
l_int|0
suffix:semicolon
id|strbuf_reset
c_func
(paren
op_amp
id|todo
(braket
id|todo_end
)braket
dot
id|out
)paren
suffix:semicolon
id|todo_end
op_assign
(paren
id|todo_end
op_plus
l_int|1
)paren
op_mod
id|ARRAY_SIZE
c_func
(paren
id|todo
)paren
suffix:semicolon
id|pthread_cond_signal
c_func
(paren
op_amp
id|cond_add
)paren
suffix:semicolon
id|grep_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|get_work
r_static
r_struct
id|work_item
op_star
id|get_work
c_func
(paren
r_void
)paren
(brace
r_struct
id|work_item
op_star
id|ret
suffix:semicolon
id|grep_lock
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|todo_start
op_eq
id|todo_end
op_logical_and
op_logical_neg
id|all_work_added
)paren
(brace
id|pthread_cond_wait
c_func
(paren
op_amp
id|cond_add
comma
op_amp
id|grep_mutex
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|todo_start
op_eq
id|todo_end
op_logical_and
id|all_work_added
)paren
(brace
id|ret
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
op_amp
id|todo
(braket
id|todo_start
)braket
suffix:semicolon
id|todo_start
op_assign
(paren
id|todo_start
op_plus
l_int|1
)paren
op_mod
id|ARRAY_SIZE
c_func
(paren
id|todo
)paren
suffix:semicolon
)brace
id|grep_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|grep_sha1_async
r_static
r_void
id|grep_sha1_async
c_func
(paren
r_struct
id|grep_opt
op_star
id|opt
comma
r_char
op_star
id|name
comma
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_int
r_char
op_star
id|s
suffix:semicolon
id|s
op_assign
id|xmalloc
c_func
(paren
l_int|20
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|s
comma
id|sha1
comma
l_int|20
)paren
suffix:semicolon
id|add_work
c_func
(paren
id|WORK_SHA1
comma
id|name
comma
id|s
)paren
suffix:semicolon
)brace
DECL|function|grep_file_async
r_static
r_void
id|grep_file_async
c_func
(paren
r_struct
id|grep_opt
op_star
id|opt
comma
r_char
op_star
id|name
comma
r_const
r_char
op_star
id|filename
)paren
(brace
id|add_work
c_func
(paren
id|WORK_FILE
comma
id|name
comma
id|xstrdup
c_func
(paren
id|filename
)paren
)paren
suffix:semicolon
)brace
DECL|function|work_done
r_static
r_void
id|work_done
c_func
(paren
r_struct
id|work_item
op_star
id|w
)paren
(brace
r_int
id|old_done
suffix:semicolon
id|grep_lock
c_func
(paren
)paren
suffix:semicolon
id|w-&gt;done
op_assign
l_int|1
suffix:semicolon
id|old_done
op_assign
id|todo_done
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|todo
(braket
id|todo_done
)braket
dot
id|done
op_logical_and
id|todo_done
op_ne
id|todo_start
suffix:semicolon
id|todo_done
op_assign
(paren
id|todo_done
op_plus
l_int|1
)paren
op_mod
id|ARRAY_SIZE
c_func
(paren
id|todo
)paren
)paren
(brace
id|w
op_assign
op_amp
id|todo
(braket
id|todo_done
)braket
suffix:semicolon
r_if
c_cond
(paren
id|w-&gt;out.len
)paren
(brace
r_if
c_cond
(paren
id|print_hunk_marks_between_files
op_logical_and
id|printed_something
)paren
id|write_or_die
c_func
(paren
l_int|1
comma
l_string|&quot;--&bslash;n&quot;
comma
l_int|3
)paren
suffix:semicolon
id|write_or_die
c_func
(paren
l_int|1
comma
id|w-&gt;out.buf
comma
id|w-&gt;out.len
)paren
suffix:semicolon
id|printed_something
op_assign
l_int|1
suffix:semicolon
)brace
id|free
c_func
(paren
id|w-&gt;name
)paren
suffix:semicolon
id|free
c_func
(paren
id|w-&gt;identifier
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|old_done
op_ne
id|todo_done
)paren
id|pthread_cond_signal
c_func
(paren
op_amp
id|cond_write
)paren
suffix:semicolon
r_if
c_cond
(paren
id|all_work_added
op_logical_and
id|todo_done
op_eq
id|todo_end
)paren
id|pthread_cond_signal
c_func
(paren
op_amp
id|cond_result
)paren
suffix:semicolon
id|grep_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|run
r_static
r_void
op_star
id|run
c_func
(paren
r_void
op_star
id|arg
)paren
(brace
r_int
id|hit
op_assign
l_int|0
suffix:semicolon
r_struct
id|grep_opt
op_star
id|opt
op_assign
id|arg
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_struct
id|work_item
op_star
id|w
op_assign
id|get_work
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|w
)paren
r_break
suffix:semicolon
id|opt-&gt;output_priv
op_assign
id|w
suffix:semicolon
r_if
c_cond
(paren
id|w-&gt;type
op_eq
id|WORK_SHA1
)paren
(brace
r_int
r_int
id|sz
suffix:semicolon
r_void
op_star
id|data
op_assign
id|load_sha1
c_func
(paren
id|w-&gt;identifier
comma
op_amp
id|sz
comma
id|w-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data
)paren
(brace
id|hit
op_or_assign
id|grep_buffer
c_func
(paren
id|opt
comma
id|w-&gt;name
comma
id|data
comma
id|sz
)paren
suffix:semicolon
id|free
c_func
(paren
id|data
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|w-&gt;type
op_eq
id|WORK_FILE
)paren
(brace
r_int
id|sz
suffix:semicolon
r_void
op_star
id|data
op_assign
id|load_file
c_func
(paren
id|w-&gt;identifier
comma
op_amp
id|sz
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data
)paren
(brace
id|hit
op_or_assign
id|grep_buffer
c_func
(paren
id|opt
comma
id|w-&gt;name
comma
id|data
comma
id|sz
)paren
suffix:semicolon
id|free
c_func
(paren
id|data
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
m_assert
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|work_done
c_func
(paren
id|w
)paren
suffix:semicolon
)brace
id|free_grep_patterns
c_func
(paren
id|arg
)paren
suffix:semicolon
id|free
c_func
(paren
id|arg
)paren
suffix:semicolon
r_return
(paren
r_void
op_star
)paren
(paren
r_intptr
)paren
id|hit
suffix:semicolon
)brace
DECL|function|strbuf_out
r_static
r_void
id|strbuf_out
c_func
(paren
r_struct
id|grep_opt
op_star
id|opt
comma
r_const
r_void
op_star
id|buf
comma
r_int
id|size
)paren
(brace
r_struct
id|work_item
op_star
id|w
op_assign
id|opt-&gt;output_priv
suffix:semicolon
id|strbuf_add
c_func
(paren
op_amp
id|w-&gt;out
comma
id|buf
comma
id|size
)paren
suffix:semicolon
)brace
DECL|function|start_threads
r_static
r_void
id|start_threads
c_func
(paren
r_struct
id|grep_opt
op_star
id|opt
)paren
(brace
r_int
id|i
suffix:semicolon
id|pthread_mutex_init
c_func
(paren
op_amp
id|grep_mutex
comma
l_int|NULL
)paren
suffix:semicolon
id|pthread_mutex_init
c_func
(paren
op_amp
id|read_sha1_mutex
comma
l_int|NULL
)paren
suffix:semicolon
id|pthread_cond_init
c_func
(paren
op_amp
id|cond_add
comma
l_int|NULL
)paren
suffix:semicolon
id|pthread_cond_init
c_func
(paren
op_amp
id|cond_write
comma
l_int|NULL
)paren
suffix:semicolon
id|pthread_cond_init
c_func
(paren
op_amp
id|cond_result
comma
l_int|NULL
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|todo
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|strbuf_init
c_func
(paren
op_amp
id|todo
(braket
id|i
)braket
dot
id|out
comma
l_int|0
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|threads
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|err
suffix:semicolon
r_struct
id|grep_opt
op_star
id|o
op_assign
id|grep_opt_dup
c_func
(paren
id|opt
)paren
suffix:semicolon
id|o-&gt;output
op_assign
id|strbuf_out
suffix:semicolon
id|compile_grep_patterns
c_func
(paren
id|o
)paren
suffix:semicolon
id|err
op_assign
id|pthread_create
c_func
(paren
op_amp
id|threads
(braket
id|i
)braket
comma
l_int|NULL
comma
id|run
comma
id|o
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
id|die
c_func
(paren
l_string|&quot;grep: failed to create thread: %s&quot;
comma
id|strerror
c_func
(paren
id|err
)paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|wait_all
r_static
r_int
id|wait_all
c_func
(paren
r_void
)paren
(brace
r_int
id|hit
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
id|grep_lock
c_func
(paren
)paren
suffix:semicolon
id|all_work_added
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Wait until all work is done. */
r_while
c_loop
(paren
id|todo_done
op_ne
id|todo_end
)paren
id|pthread_cond_wait
c_func
(paren
op_amp
id|cond_result
comma
op_amp
id|grep_mutex
)paren
suffix:semicolon
multiline_comment|/* Wake up all the consumer threads so they can see that there&n;&t; * is no more work to do.&n;&t; */
id|pthread_cond_broadcast
c_func
(paren
op_amp
id|cond_add
)paren
suffix:semicolon
id|grep_unlock
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|threads
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_void
op_star
id|h
suffix:semicolon
id|pthread_join
c_func
(paren
id|threads
(braket
id|i
)braket
comma
op_amp
id|h
)paren
suffix:semicolon
id|hit
op_or_assign
(paren
r_int
)paren
(paren
r_intptr
)paren
id|h
suffix:semicolon
)brace
id|pthread_mutex_destroy
c_func
(paren
op_amp
id|grep_mutex
)paren
suffix:semicolon
id|pthread_mutex_destroy
c_func
(paren
op_amp
id|read_sha1_mutex
)paren
suffix:semicolon
id|pthread_cond_destroy
c_func
(paren
op_amp
id|cond_add
)paren
suffix:semicolon
id|pthread_cond_destroy
c_func
(paren
op_amp
id|cond_write
)paren
suffix:semicolon
id|pthread_cond_destroy
c_func
(paren
op_amp
id|cond_result
)paren
suffix:semicolon
r_return
id|hit
suffix:semicolon
)brace
macro_line|#else /* !NO_PTHREADS */
DECL|macro|read_sha1_lock
mdefine_line|#define read_sha1_lock()
DECL|macro|read_sha1_unlock
mdefine_line|#define read_sha1_unlock()
DECL|function|wait_all
r_static
r_int
id|wait_all
c_func
(paren
r_void
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
DECL|function|grep_config
r_static
r_int
id|grep_config
c_func
(paren
r_const
r_char
op_star
id|var
comma
r_const
r_char
op_star
id|value
comma
r_void
op_star
id|cb
)paren
(brace
r_struct
id|grep_opt
op_star
id|opt
op_assign
id|cb
suffix:semicolon
r_char
op_star
id|color
op_assign
l_int|NULL
suffix:semicolon
r_switch
c_cond
(paren
id|userdiff_config
c_func
(paren
id|var
comma
id|value
)paren
)paren
(brace
r_case
l_int|0
suffix:colon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
r_return
l_int|1
suffix:semicolon
r_default
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;color.grep&quot;
)paren
)paren
id|opt-&gt;color
op_assign
id|git_config_colorbool
c_func
(paren
id|var
comma
id|value
comma
l_int|1
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;color.grep.context&quot;
)paren
)paren
id|color
op_assign
id|opt-&gt;color_context
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;color.grep.filename&quot;
)paren
)paren
id|color
op_assign
id|opt-&gt;color_filename
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;color.grep.function&quot;
)paren
)paren
id|color
op_assign
id|opt-&gt;color_function
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;color.grep.linenumber&quot;
)paren
)paren
id|color
op_assign
id|opt-&gt;color_lineno
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;color.grep.match&quot;
)paren
)paren
id|color
op_assign
id|opt-&gt;color_match
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;color.grep.selected&quot;
)paren
)paren
id|color
op_assign
id|opt-&gt;color_selected
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;color.grep.separator&quot;
)paren
)paren
id|color
op_assign
id|opt-&gt;color_sep
suffix:semicolon
r_else
r_return
id|git_color_default_config
c_func
(paren
id|var
comma
id|value
comma
id|cb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|color
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
r_return
id|config_error_nonbool
c_func
(paren
id|var
)paren
suffix:semicolon
id|color_parse
c_func
(paren
id|value
comma
id|var
comma
id|color
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Return non-zero if max_depth is negative or path has no more then max_depth&n; * slashes.&n; */
DECL|function|accept_subdir
r_static
r_int
id|accept_subdir
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_int
id|max_depth
)paren
(brace
r_if
c_cond
(paren
id|max_depth
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_while
c_loop
(paren
(paren
id|path
op_assign
id|strchr
c_func
(paren
id|path
comma
l_char|&squot;/&squot;
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|max_depth
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|max_depth
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|path
op_increment
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Return non-zero if name is a subdirectory of match and is not too deep.&n; */
DECL|function|is_subdir
r_static
r_int
id|is_subdir
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_int
id|namelen
comma
r_const
r_char
op_star
id|match
comma
r_int
id|matchlen
comma
r_int
id|max_depth
)paren
(brace
r_if
c_cond
(paren
id|matchlen
OG
id|namelen
op_logical_or
id|strncmp
c_func
(paren
id|name
comma
id|match
comma
id|matchlen
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|name
(braket
id|matchlen
)braket
op_eq
l_char|&squot;&bslash;0&squot;
)paren
multiline_comment|/* exact match */
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|matchlen
op_logical_or
id|match
(braket
id|matchlen
op_minus
l_int|1
)braket
op_eq
l_char|&squot;/&squot;
op_logical_or
id|name
(braket
id|matchlen
)braket
op_eq
l_char|&squot;/&squot;
)paren
r_return
id|accept_subdir
c_func
(paren
id|name
op_plus
id|matchlen
op_plus
l_int|1
comma
id|max_depth
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * git grep pathspecs are somewhat different from diff-tree pathspecs;&n; * pathname wildcards are allowed.&n; */
DECL|function|pathspec_matches
r_static
r_int
id|pathspec_matches
c_func
(paren
r_const
r_char
op_star
op_star
id|paths
comma
r_const
r_char
op_star
id|name
comma
r_int
id|max_depth
)paren
(brace
r_int
id|namelen
comma
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|paths
op_logical_or
op_logical_neg
op_star
id|paths
)paren
r_return
id|accept_subdir
c_func
(paren
id|name
comma
id|max_depth
)paren
suffix:semicolon
id|namelen
op_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|paths
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_char
op_star
id|match
op_assign
id|paths
(braket
id|i
)braket
suffix:semicolon
r_int
id|matchlen
op_assign
id|strlen
c_func
(paren
id|match
)paren
suffix:semicolon
r_const
r_char
op_star
id|cp
comma
op_star
id|meta
suffix:semicolon
r_if
c_cond
(paren
id|is_subdir
c_func
(paren
id|name
comma
id|namelen
comma
id|match
comma
id|matchlen
comma
id|max_depth
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fnmatch
c_func
(paren
id|match
comma
id|name
comma
l_int|0
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|name
(braket
id|namelen
op_minus
l_int|1
)braket
op_ne
l_char|&squot;/&squot;
)paren
r_continue
suffix:semicolon
multiline_comment|/* We are being asked if the directory (&quot;name&quot;) is worth&n;&t;&t; * descending into.&n;&t;&t; *&n;&t;&t; * Find the longest leading directory name that does&n;&t;&t; * not have metacharacter in the pathspec; the name&n;&t;&t; * we are looking at must overlap with that directory.&n;&t;&t; */
r_for
c_loop
(paren
id|cp
op_assign
id|match
comma
id|meta
op_assign
l_int|NULL
suffix:semicolon
id|cp
id|match
OL
id|matchlen
suffix:semicolon
id|cp
op_increment
)paren
(brace
r_char
id|ch
op_assign
op_star
id|cp
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;*&squot;
op_logical_or
id|ch
op_eq
l_char|&squot;[&squot;
op_logical_or
id|ch
op_eq
l_char|&squot;?&squot;
)paren
(brace
id|meta
op_assign
id|cp
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|meta
)paren
id|meta
op_assign
id|cp
suffix:semicolon
multiline_comment|/* fully literal */
r_if
c_cond
(paren
id|namelen
op_le
id|meta
id|match
)paren
(brace
multiline_comment|/* Looking at &quot;Documentation/&quot; and&n;&t;&t;&t; * the pattern says &quot;Documentation/howto/&quot;, or&n;&t;&t;&t; * &quot;Documentation/diff*.txt&quot;.  The name we&n;&t;&t;&t; * have should match prefix.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|match
comma
id|name
comma
id|namelen
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|meta
id|match
OL
id|namelen
)paren
(brace
multiline_comment|/* Looking at &quot;Documentation/howto/&quot; and&n;&t;&t;&t; * the pattern says &quot;Documentation/h*&quot;;&n;&t;&t;&t; * match up to &quot;Do.../h&quot;; this avoids descending&n;&t;&t;&t; * into &quot;Documentation/technical/&quot;.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|match
comma
id|name
comma
id|meta
id|match
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|lock_and_read_sha1_file
r_static
r_void
op_star
id|lock_and_read_sha1_file
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
comma
r_enum
id|object_type
op_star
id|type
comma
r_int
r_int
op_star
id|size
)paren
(brace
r_void
op_star
id|data
suffix:semicolon
r_if
c_cond
(paren
id|use_threads
)paren
(brace
id|read_sha1_lock
c_func
(paren
)paren
suffix:semicolon
id|data
op_assign
id|read_sha1_file
c_func
(paren
id|sha1
comma
id|type
comma
id|size
)paren
suffix:semicolon
id|read_sha1_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|data
op_assign
id|read_sha1_file
c_func
(paren
id|sha1
comma
id|type
comma
id|size
)paren
suffix:semicolon
)brace
r_return
id|data
suffix:semicolon
)brace
DECL|function|load_sha1
r_static
r_void
op_star
id|load_sha1
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
r_int
op_star
id|size
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_enum
id|object_type
id|type
suffix:semicolon
r_void
op_star
id|data
op_assign
id|lock_and_read_sha1_file
c_func
(paren
id|sha1
comma
op_amp
id|type
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
id|error
c_func
(paren
l_string|&quot;&squot;%s&squot;: unable to read %s&quot;
comma
id|name
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
r_return
id|data
suffix:semicolon
)brace
DECL|function|grep_sha1
r_static
r_int
id|grep_sha1
c_func
(paren
r_struct
id|grep_opt
op_star
id|opt
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_const
r_char
op_star
id|filename
comma
r_int
id|tree_name_len
)paren
(brace
r_struct
id|strbuf
id|pathbuf
op_assign
id|STRBUF_INIT
suffix:semicolon
r_char
op_star
id|name
suffix:semicolon
r_if
c_cond
(paren
id|opt-&gt;relative
op_logical_and
id|opt-&gt;prefix_length
)paren
(brace
id|quote_path_relative
c_func
(paren
id|filename
op_plus
id|tree_name_len
comma
l_int|1
comma
op_amp
id|pathbuf
comma
id|opt-&gt;prefix
)paren
suffix:semicolon
id|strbuf_insert
c_func
(paren
op_amp
id|pathbuf
comma
l_int|0
comma
id|filename
comma
id|tree_name_len
)paren
suffix:semicolon
)brace
r_else
(brace
id|strbuf_addstr
c_func
(paren
op_amp
id|pathbuf
comma
id|filename
)paren
suffix:semicolon
)brace
id|name
op_assign
id|strbuf_detach
c_func
(paren
op_amp
id|pathbuf
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#ifndef NO_PTHREADS
r_if
c_cond
(paren
id|use_threads
)paren
(brace
id|grep_sha1_async
c_func
(paren
id|opt
comma
id|name
comma
id|sha1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
macro_line|#endif
(brace
r_int
id|hit
suffix:semicolon
r_int
r_int
id|sz
suffix:semicolon
r_void
op_star
id|data
op_assign
id|load_sha1
c_func
(paren
id|sha1
comma
op_amp
id|sz
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
id|hit
op_assign
l_int|0
suffix:semicolon
r_else
id|hit
op_assign
id|grep_buffer
c_func
(paren
id|opt
comma
id|name
comma
id|data
comma
id|sz
)paren
suffix:semicolon
id|free
c_func
(paren
id|data
)paren
suffix:semicolon
id|free
c_func
(paren
id|name
)paren
suffix:semicolon
r_return
id|hit
suffix:semicolon
)brace
)brace
DECL|function|load_file
r_static
r_void
op_star
id|load_file
c_func
(paren
r_const
r_char
op_star
id|filename
comma
r_int
op_star
id|sz
)paren
(brace
r_struct
id|stat
id|st
suffix:semicolon
r_char
op_star
id|data
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|lstat
c_func
(paren
id|filename
comma
op_amp
id|st
)paren
OL
l_int|0
)paren
(brace
id|err_ret
suffix:colon
r_if
c_cond
(paren
id|errno
op_ne
id|ENOENT
)paren
id|error
c_func
(paren
l_string|&quot;&squot;%s&squot;: %s&quot;
comma
id|filename
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|S_ISREG
c_func
(paren
id|st.st_mode
)paren
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|sz
op_assign
id|xsize_t
c_func
(paren
id|st.st_size
)paren
suffix:semicolon
id|i
op_assign
id|open
c_func
(paren
id|filename
comma
id|O_RDONLY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
r_goto
id|err_ret
suffix:semicolon
id|data
op_assign
id|xmalloc
c_func
(paren
op_star
id|sz
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st.st_size
op_ne
id|read_in_full
c_func
(paren
id|i
comma
id|data
comma
op_star
id|sz
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;&squot;%s&squot;: short read %s&quot;
comma
id|filename
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
id|close
c_func
(paren
id|i
)paren
suffix:semicolon
id|free
c_func
(paren
id|data
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|close
c_func
(paren
id|i
)paren
suffix:semicolon
id|data
(braket
op_star
id|sz
)braket
op_assign
l_int|0
suffix:semicolon
r_return
id|data
suffix:semicolon
)brace
DECL|function|grep_file
r_static
r_int
id|grep_file
c_func
(paren
r_struct
id|grep_opt
op_star
id|opt
comma
r_const
r_char
op_star
id|filename
)paren
(brace
r_struct
id|strbuf
id|buf
op_assign
id|STRBUF_INIT
suffix:semicolon
r_char
op_star
id|name
suffix:semicolon
r_if
c_cond
(paren
id|opt-&gt;relative
op_logical_and
id|opt-&gt;prefix_length
)paren
id|quote_path_relative
c_func
(paren
id|filename
comma
l_int|1
comma
op_amp
id|buf
comma
id|opt-&gt;prefix
)paren
suffix:semicolon
r_else
id|strbuf_addstr
c_func
(paren
op_amp
id|buf
comma
id|filename
)paren
suffix:semicolon
id|name
op_assign
id|strbuf_detach
c_func
(paren
op_amp
id|buf
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#ifndef NO_PTHREADS
r_if
c_cond
(paren
id|use_threads
)paren
(brace
id|grep_file_async
c_func
(paren
id|opt
comma
id|name
comma
id|filename
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
macro_line|#endif
(brace
r_int
id|hit
suffix:semicolon
r_int
id|sz
suffix:semicolon
r_void
op_star
id|data
op_assign
id|load_file
c_func
(paren
id|filename
comma
op_amp
id|sz
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
id|hit
op_assign
l_int|0
suffix:semicolon
r_else
id|hit
op_assign
id|grep_buffer
c_func
(paren
id|opt
comma
id|name
comma
id|data
comma
id|sz
)paren
suffix:semicolon
id|free
c_func
(paren
id|data
)paren
suffix:semicolon
id|free
c_func
(paren
id|name
)paren
suffix:semicolon
r_return
id|hit
suffix:semicolon
)brace
)brace
DECL|function|grep_cache
r_static
r_int
id|grep_cache
c_func
(paren
r_struct
id|grep_opt
op_star
id|opt
comma
r_const
r_char
op_star
op_star
id|paths
comma
r_int
id|cached
)paren
(brace
r_int
id|hit
op_assign
l_int|0
suffix:semicolon
r_int
id|nr
suffix:semicolon
id|read_cache
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|nr
op_assign
l_int|0
suffix:semicolon
id|nr
OL
id|active_nr
suffix:semicolon
id|nr
op_increment
)paren
(brace
r_struct
id|cache_entry
op_star
id|ce
op_assign
id|active_cache
(braket
id|nr
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISREG
c_func
(paren
id|ce-&gt;ce_mode
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pathspec_matches
c_func
(paren
id|paths
comma
id|ce-&gt;name
comma
id|opt-&gt;max_depth
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If CE_VALID is on, we assume worktree file and its cache entry&n;&t;&t; * are identical, even if worktree file has been modified, so use&n;&t;&t; * cache version instead&n;&t;&t; */
r_if
c_cond
(paren
id|cached
op_logical_or
(paren
id|ce-&gt;ce_flags
op_amp
id|CE_VALID
)paren
op_logical_or
id|ce_skip_worktree
c_func
(paren
id|ce
)paren
)paren
(brace
r_if
c_cond
(paren
id|ce_stage
c_func
(paren
id|ce
)paren
)paren
r_continue
suffix:semicolon
id|hit
op_or_assign
id|grep_sha1
c_func
(paren
id|opt
comma
id|ce-&gt;sha1
comma
id|ce-&gt;name
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
id|hit
op_or_assign
id|grep_file
c_func
(paren
id|opt
comma
id|ce-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ce_stage
c_func
(paren
id|ce
)paren
)paren
(brace
r_do
(brace
id|nr
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|nr
OL
id|active_nr
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|ce-&gt;name
comma
id|active_cache
(braket
id|nr
)braket
op_member_access_from_pointer
id|name
)paren
)paren
suffix:semicolon
id|nr
op_decrement
suffix:semicolon
multiline_comment|/* compensate for loop control */
)brace
r_if
c_cond
(paren
id|hit
op_logical_and
id|opt-&gt;status_only
)paren
r_break
suffix:semicolon
)brace
id|free_grep_patterns
c_func
(paren
id|opt
)paren
suffix:semicolon
r_return
id|hit
suffix:semicolon
)brace
DECL|function|grep_tree
r_static
r_int
id|grep_tree
c_func
(paren
r_struct
id|grep_opt
op_star
id|opt
comma
r_const
r_char
op_star
op_star
id|paths
comma
r_struct
id|tree_desc
op_star
id|tree
comma
r_const
r_char
op_star
id|tree_name
comma
r_const
r_char
op_star
id|base
)paren
(brace
r_int
id|len
suffix:semicolon
r_int
id|hit
op_assign
l_int|0
suffix:semicolon
r_struct
id|name_entry
id|entry
suffix:semicolon
r_char
op_star
id|down
suffix:semicolon
r_int
id|tn_len
op_assign
id|strlen
c_func
(paren
id|tree_name
)paren
suffix:semicolon
r_struct
id|strbuf
id|pathbuf
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|pathbuf
comma
id|PATH_MAX
op_plus
id|tn_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tn_len
)paren
(brace
id|strbuf_add
c_func
(paren
op_amp
id|pathbuf
comma
id|tree_name
comma
id|tn_len
)paren
suffix:semicolon
id|strbuf_addch
c_func
(paren
op_amp
id|pathbuf
comma
l_char|&squot;:&squot;
)paren
suffix:semicolon
id|tn_len
op_assign
id|pathbuf.len
suffix:semicolon
)brace
id|strbuf_addstr
c_func
(paren
op_amp
id|pathbuf
comma
id|base
)paren
suffix:semicolon
id|len
op_assign
id|pathbuf.len
suffix:semicolon
r_while
c_loop
(paren
id|tree_entry
c_func
(paren
id|tree
comma
op_amp
id|entry
)paren
)paren
(brace
r_int
id|te_len
op_assign
id|tree_entry_len
c_func
(paren
id|entry.path
comma
id|entry.sha1
)paren
suffix:semicolon
id|pathbuf.len
op_assign
id|len
suffix:semicolon
id|strbuf_add
c_func
(paren
op_amp
id|pathbuf
comma
id|entry.path
comma
id|te_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|entry.mode
)paren
)paren
multiline_comment|/* Match &quot;abc/&quot; against pathspec to&n;&t;&t;&t; * decide if we want to descend into &quot;abc&quot;&n;&t;&t;&t; * directory.&n;&t;&t;&t; */
id|strbuf_addch
c_func
(paren
op_amp
id|pathbuf
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
id|down
op_assign
id|pathbuf.buf
op_plus
id|tn_len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pathspec_matches
c_func
(paren
id|paths
comma
id|down
comma
id|opt-&gt;max_depth
)paren
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|entry.mode
)paren
)paren
id|hit
op_or_assign
id|grep_sha1
c_func
(paren
id|opt
comma
id|entry.sha1
comma
id|pathbuf.buf
comma
id|tn_len
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|entry.mode
)paren
)paren
(brace
r_enum
id|object_type
id|type
suffix:semicolon
r_struct
id|tree_desc
id|sub
suffix:semicolon
r_void
op_star
id|data
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
id|data
op_assign
id|lock_and_read_sha1_file
c_func
(paren
id|entry.sha1
comma
op_amp
id|type
comma
op_amp
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
id|die
c_func
(paren
l_string|&quot;unable to read tree (%s)&quot;
comma
id|sha1_to_hex
c_func
(paren
id|entry.sha1
)paren
)paren
suffix:semicolon
id|init_tree_desc
c_func
(paren
op_amp
id|sub
comma
id|data
comma
id|size
)paren
suffix:semicolon
id|hit
op_or_assign
id|grep_tree
c_func
(paren
id|opt
comma
id|paths
comma
op_amp
id|sub
comma
id|tree_name
comma
id|down
)paren
suffix:semicolon
id|free
c_func
(paren
id|data
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hit
op_logical_and
id|opt-&gt;status_only
)paren
r_break
suffix:semicolon
)brace
id|strbuf_release
c_func
(paren
op_amp
id|pathbuf
)paren
suffix:semicolon
r_return
id|hit
suffix:semicolon
)brace
DECL|function|grep_object
r_static
r_int
id|grep_object
c_func
(paren
r_struct
id|grep_opt
op_star
id|opt
comma
r_const
r_char
op_star
op_star
id|paths
comma
r_struct
id|object
op_star
id|obj
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_if
c_cond
(paren
id|obj-&gt;type
op_eq
id|OBJ_BLOB
)paren
r_return
id|grep_sha1
c_func
(paren
id|opt
comma
id|obj-&gt;sha1
comma
id|name
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|obj-&gt;type
op_eq
id|OBJ_COMMIT
op_logical_or
id|obj-&gt;type
op_eq
id|OBJ_TREE
)paren
(brace
r_struct
id|tree_desc
id|tree
suffix:semicolon
r_void
op_star
id|data
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_int
id|hit
suffix:semicolon
id|data
op_assign
id|read_object_with_reference
c_func
(paren
id|obj-&gt;sha1
comma
id|tree_type
comma
op_amp
id|size
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
id|die
c_func
(paren
l_string|&quot;unable to read tree (%s)&quot;
comma
id|sha1_to_hex
c_func
(paren
id|obj-&gt;sha1
)paren
)paren
suffix:semicolon
id|init_tree_desc
c_func
(paren
op_amp
id|tree
comma
id|data
comma
id|size
)paren
suffix:semicolon
id|hit
op_assign
id|grep_tree
c_func
(paren
id|opt
comma
id|paths
comma
op_amp
id|tree
comma
id|name
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
id|free
c_func
(paren
id|data
)paren
suffix:semicolon
r_return
id|hit
suffix:semicolon
)brace
id|die
c_func
(paren
l_string|&quot;unable to grep from object of type %s&quot;
comma
r_typename
(paren
id|obj-&gt;type
)paren
)paren
suffix:semicolon
)brace
DECL|function|grep_directory
r_static
r_int
id|grep_directory
c_func
(paren
r_struct
id|grep_opt
op_star
id|opt
comma
r_const
r_char
op_star
op_star
id|paths
)paren
(brace
r_struct
id|dir_struct
id|dir
suffix:semicolon
r_int
id|i
comma
id|hit
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|dir
comma
l_int|0
comma
r_sizeof
(paren
id|dir
)paren
)paren
suffix:semicolon
id|setup_standard_excludes
c_func
(paren
op_amp
id|dir
)paren
suffix:semicolon
id|fill_directory
c_func
(paren
op_amp
id|dir
comma
id|paths
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dir.nr
suffix:semicolon
id|i
op_increment
)paren
(brace
id|hit
op_or_assign
id|grep_file
c_func
(paren
id|opt
comma
id|dir.entries
(braket
id|i
)braket
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hit
op_logical_and
id|opt-&gt;status_only
)paren
r_break
suffix:semicolon
)brace
id|free_grep_patterns
c_func
(paren
id|opt
)paren
suffix:semicolon
r_return
id|hit
suffix:semicolon
)brace
DECL|function|context_callback
r_static
r_int
id|context_callback
c_func
(paren
r_const
r_struct
id|option
op_star
id|opt
comma
r_const
r_char
op_star
id|arg
comma
r_int
id|unset
)paren
(brace
r_struct
id|grep_opt
op_star
id|grep_opt
op_assign
id|opt-&gt;value
suffix:semicolon
r_int
id|value
suffix:semicolon
r_const
r_char
op_star
id|endp
suffix:semicolon
r_if
c_cond
(paren
id|unset
)paren
(brace
id|grep_opt-&gt;pre_context
op_assign
id|grep_opt-&gt;post_context
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|value
op_assign
id|strtol
c_func
(paren
id|arg
comma
(paren
r_char
op_star
op_star
)paren
op_amp
id|endp
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|endp
)paren
(brace
r_return
id|error
c_func
(paren
l_string|&quot;switch `%c&squot; expects a numerical value&quot;
comma
id|opt-&gt;short_name
)paren
suffix:semicolon
)brace
id|grep_opt-&gt;pre_context
op_assign
id|grep_opt-&gt;post_context
op_assign
id|value
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|file_callback
r_static
r_int
id|file_callback
c_func
(paren
r_const
r_struct
id|option
op_star
id|opt
comma
r_const
r_char
op_star
id|arg
comma
r_int
id|unset
)paren
(brace
r_struct
id|grep_opt
op_star
id|grep_opt
op_assign
id|opt-&gt;value
suffix:semicolon
id|FILE
op_star
id|patterns
suffix:semicolon
r_int
id|lno
op_assign
l_int|0
suffix:semicolon
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
id|patterns
op_assign
id|fopen
c_func
(paren
id|arg
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|patterns
)paren
id|die_errno
c_func
(paren
l_string|&quot;cannot open &squot;%s&squot;&quot;
comma
id|arg
)paren
suffix:semicolon
r_while
c_loop
(paren
id|strbuf_getline
c_func
(paren
op_amp
id|sb
comma
id|patterns
comma
l_char|&squot;&bslash;n&squot;
)paren
op_eq
l_int|0
)paren
(brace
r_char
op_star
id|s
suffix:semicolon
r_int
id|len
suffix:semicolon
multiline_comment|/* ignore empty line like grep does */
r_if
c_cond
(paren
id|sb.len
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|s
op_assign
id|strbuf_detach
c_func
(paren
op_amp
id|sb
comma
op_amp
id|len
)paren
suffix:semicolon
id|append_grep_pat
c_func
(paren
id|grep_opt
comma
id|s
comma
id|len
comma
id|arg
comma
op_increment
id|lno
comma
id|GREP_PATTERN
)paren
suffix:semicolon
)brace
id|fclose
c_func
(paren
id|patterns
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|not_callback
r_static
r_int
id|not_callback
c_func
(paren
r_const
r_struct
id|option
op_star
id|opt
comma
r_const
r_char
op_star
id|arg
comma
r_int
id|unset
)paren
(brace
r_struct
id|grep_opt
op_star
id|grep_opt
op_assign
id|opt-&gt;value
suffix:semicolon
id|append_grep_pattern
c_func
(paren
id|grep_opt
comma
l_string|&quot;--not&quot;
comma
l_string|&quot;command line&quot;
comma
l_int|0
comma
id|GREP_NOT
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|and_callback
r_static
r_int
id|and_callback
c_func
(paren
r_const
r_struct
id|option
op_star
id|opt
comma
r_const
r_char
op_star
id|arg
comma
r_int
id|unset
)paren
(brace
r_struct
id|grep_opt
op_star
id|grep_opt
op_assign
id|opt-&gt;value
suffix:semicolon
id|append_grep_pattern
c_func
(paren
id|grep_opt
comma
l_string|&quot;--and&quot;
comma
l_string|&quot;command line&quot;
comma
l_int|0
comma
id|GREP_AND
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|open_callback
r_static
r_int
id|open_callback
c_func
(paren
r_const
r_struct
id|option
op_star
id|opt
comma
r_const
r_char
op_star
id|arg
comma
r_int
id|unset
)paren
(brace
r_struct
id|grep_opt
op_star
id|grep_opt
op_assign
id|opt-&gt;value
suffix:semicolon
id|append_grep_pattern
c_func
(paren
id|grep_opt
comma
l_string|&quot;(&quot;
comma
l_string|&quot;command line&quot;
comma
l_int|0
comma
id|GREP_OPEN_PAREN
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|close_callback
r_static
r_int
id|close_callback
c_func
(paren
r_const
r_struct
id|option
op_star
id|opt
comma
r_const
r_char
op_star
id|arg
comma
r_int
id|unset
)paren
(brace
r_struct
id|grep_opt
op_star
id|grep_opt
op_assign
id|opt-&gt;value
suffix:semicolon
id|append_grep_pattern
c_func
(paren
id|grep_opt
comma
l_string|&quot;)&quot;
comma
l_string|&quot;command line&quot;
comma
l_int|0
comma
id|GREP_CLOSE_PAREN
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pattern_callback
r_static
r_int
id|pattern_callback
c_func
(paren
r_const
r_struct
id|option
op_star
id|opt
comma
r_const
r_char
op_star
id|arg
comma
r_int
id|unset
)paren
(brace
r_struct
id|grep_opt
op_star
id|grep_opt
op_assign
id|opt-&gt;value
suffix:semicolon
id|append_grep_pattern
c_func
(paren
id|grep_opt
comma
id|arg
comma
l_string|&quot;-e option&quot;
comma
l_int|0
comma
id|GREP_PATTERN
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|help_callback
r_static
r_int
id|help_callback
c_func
(paren
r_const
r_struct
id|option
op_star
id|opt
comma
r_const
r_char
op_star
id|arg
comma
r_int
id|unset
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|cmd_grep
r_int
id|cmd_grep
c_func
(paren
r_int
id|argc
comma
r_const
r_char
op_star
op_star
id|argv
comma
r_const
r_char
op_star
id|prefix
)paren
(brace
r_int
id|hit
op_assign
l_int|0
suffix:semicolon
r_int
id|cached
op_assign
l_int|0
suffix:semicolon
r_int
id|seen_dashdash
op_assign
l_int|0
suffix:semicolon
r_int
id|external_grep_allowed__ignored
suffix:semicolon
r_struct
id|grep_opt
id|opt
suffix:semicolon
r_struct
id|object_array
id|list
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|NULL
)brace
suffix:semicolon
r_const
r_char
op_star
op_star
id|paths
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|dummy
suffix:semicolon
r_int
id|nongit
op_assign
l_int|0
comma
id|use_index
op_assign
l_int|1
suffix:semicolon
r_struct
id|option
id|options
(braket
)braket
op_assign
(brace
id|OPT_BOOLEAN
c_func
(paren
l_int|0
comma
l_string|&quot;cached&quot;
comma
op_amp
id|cached
comma
l_string|&quot;search in index instead of in the work tree&quot;
)paren
comma
id|OPT_BOOLEAN
c_func
(paren
l_int|0
comma
l_string|&quot;index&quot;
comma
op_amp
id|use_index
comma
l_string|&quot;--no-index finds in contents not managed by git&quot;
)paren
comma
id|OPT_GROUP
c_func
(paren
l_string|&quot;&quot;
)paren
comma
id|OPT_BOOLEAN
c_func
(paren
l_char|&squot;v&squot;
comma
l_string|&quot;invert-match&quot;
comma
op_amp
id|opt.invert
comma
l_string|&quot;show non-matching lines&quot;
)paren
comma
id|OPT_BOOLEAN
c_func
(paren
l_char|&squot;i&squot;
comma
l_string|&quot;ignore-case&quot;
comma
op_amp
id|opt.ignore_case
comma
l_string|&quot;case insensitive matching&quot;
)paren
comma
id|OPT_BOOLEAN
c_func
(paren
l_char|&squot;w&squot;
comma
l_string|&quot;word-regexp&quot;
comma
op_amp
id|opt.word_regexp
comma
l_string|&quot;match patterns only at word boundaries&quot;
)paren
comma
id|OPT_SET_INT
c_func
(paren
l_char|&squot;a&squot;
comma
l_string|&quot;text&quot;
comma
op_amp
id|opt.binary
comma
l_string|&quot;process binary files as text&quot;
comma
id|GREP_BINARY_TEXT
)paren
comma
id|OPT_SET_INT
c_func
(paren
l_char|&squot;I&squot;
comma
l_int|NULL
comma
op_amp
id|opt.binary
comma
l_string|&quot;don&squot;t match patterns in binary files&quot;
comma
id|GREP_BINARY_NOMATCH
)paren
comma
(brace
id|OPTION_INTEGER
comma
l_int|0
comma
l_string|&quot;max-depth&quot;
comma
op_amp
id|opt.max_depth
comma
l_string|&quot;depth&quot;
comma
l_string|&quot;descend at most &lt;depth&gt; levels&quot;
comma
id|PARSE_OPT_NONEG
comma
l_int|NULL
comma
l_int|1
)brace
comma
id|OPT_GROUP
c_func
(paren
l_string|&quot;&quot;
)paren
comma
id|OPT_BIT
c_func
(paren
l_char|&squot;E&squot;
comma
l_string|&quot;extended-regexp&quot;
comma
op_amp
id|opt.regflags
comma
l_string|&quot;use extended POSIX regular expressions&quot;
comma
id|REG_EXTENDED
)paren
comma
id|OPT_NEGBIT
c_func
(paren
l_char|&squot;G&squot;
comma
l_string|&quot;basic-regexp&quot;
comma
op_amp
id|opt.regflags
comma
l_string|&quot;use basic POSIX regular expressions (default)&quot;
comma
id|REG_EXTENDED
)paren
comma
id|OPT_BOOLEAN
c_func
(paren
l_char|&squot;F&squot;
comma
l_string|&quot;fixed-strings&quot;
comma
op_amp
id|opt.fixed
comma
l_string|&quot;interpret patterns as fixed strings&quot;
)paren
comma
id|OPT_GROUP
c_func
(paren
l_string|&quot;&quot;
)paren
comma
id|OPT_BOOLEAN
c_func
(paren
l_char|&squot;n&squot;
comma
l_int|NULL
comma
op_amp
id|opt.linenum
comma
l_string|&quot;show line numbers&quot;
)paren
comma
id|OPT_NEGBIT
c_func
(paren
l_char|&squot;h&squot;
comma
l_int|NULL
comma
op_amp
id|opt.pathname
comma
l_string|&quot;don&squot;t show filenames&quot;
comma
l_int|1
)paren
comma
id|OPT_BIT
c_func
(paren
l_char|&squot;H&squot;
comma
l_int|NULL
comma
op_amp
id|opt.pathname
comma
l_string|&quot;show filenames&quot;
comma
l_int|1
)paren
comma
id|OPT_NEGBIT
c_func
(paren
l_int|0
comma
l_string|&quot;full-name&quot;
comma
op_amp
id|opt.relative
comma
l_string|&quot;show filenames relative to top directory&quot;
comma
l_int|1
)paren
comma
id|OPT_BOOLEAN
c_func
(paren
l_char|&squot;l&squot;
comma
l_string|&quot;files-with-matches&quot;
comma
op_amp
id|opt.name_only
comma
l_string|&quot;show only filenames instead of matching lines&quot;
)paren
comma
id|OPT_BOOLEAN
c_func
(paren
l_int|0
comma
l_string|&quot;name-only&quot;
comma
op_amp
id|opt.name_only
comma
l_string|&quot;synonym for --files-with-matches&quot;
)paren
comma
id|OPT_BOOLEAN
c_func
(paren
l_char|&squot;L&squot;
comma
l_string|&quot;files-without-match&quot;
comma
op_amp
id|opt.unmatch_name_only
comma
l_string|&quot;show only the names of files without match&quot;
)paren
comma
id|OPT_BOOLEAN
c_func
(paren
l_char|&squot;z&squot;
comma
l_string|&quot;null&quot;
comma
op_amp
id|opt.null_following_name
comma
l_string|&quot;print NUL after filenames&quot;
)paren
comma
id|OPT_BOOLEAN
c_func
(paren
l_char|&squot;c&squot;
comma
l_string|&quot;count&quot;
comma
op_amp
id|opt.count
comma
l_string|&quot;show the number of matches instead of matching lines&quot;
)paren
comma
id|OPT__COLOR
c_func
(paren
op_amp
id|opt.color
comma
l_string|&quot;highlight matches&quot;
)paren
comma
id|OPT_GROUP
c_func
(paren
l_string|&quot;&quot;
)paren
comma
id|OPT_CALLBACK
c_func
(paren
l_char|&squot;C&squot;
comma
l_int|NULL
comma
op_amp
id|opt
comma
l_string|&quot;n&quot;
comma
l_string|&quot;show &lt;n&gt; context lines before and after matches&quot;
comma
id|context_callback
)paren
comma
id|OPT_INTEGER
c_func
(paren
l_char|&squot;B&squot;
comma
l_int|NULL
comma
op_amp
id|opt.pre_context
comma
l_string|&quot;show &lt;n&gt; context lines before matches&quot;
)paren
comma
id|OPT_INTEGER
c_func
(paren
l_char|&squot;A&squot;
comma
l_int|NULL
comma
op_amp
id|opt.post_context
comma
l_string|&quot;show &lt;n&gt; context lines after matches&quot;
)paren
comma
id|OPT_NUMBER_CALLBACK
c_func
(paren
op_amp
id|opt
comma
l_string|&quot;shortcut for -C NUM&quot;
comma
id|context_callback
)paren
comma
id|OPT_BOOLEAN
c_func
(paren
l_char|&squot;p&squot;
comma
l_string|&quot;show-function&quot;
comma
op_amp
id|opt.funcname
comma
l_string|&quot;show a line with the function name before matches&quot;
)paren
comma
id|OPT_GROUP
c_func
(paren
l_string|&quot;&quot;
)paren
comma
id|OPT_CALLBACK
c_func
(paren
l_char|&squot;f&squot;
comma
l_int|NULL
comma
op_amp
id|opt
comma
l_string|&quot;file&quot;
comma
l_string|&quot;read patterns from file&quot;
comma
id|file_callback
)paren
comma
(brace
id|OPTION_CALLBACK
comma
l_char|&squot;e&squot;
comma
l_int|NULL
comma
op_amp
id|opt
comma
l_string|&quot;pattern&quot;
comma
l_string|&quot;match &lt;pattern&gt;&quot;
comma
id|PARSE_OPT_NONEG
comma
id|pattern_callback
)brace
comma
(brace
id|OPTION_CALLBACK
comma
l_int|0
comma
l_string|&quot;and&quot;
comma
op_amp
id|opt
comma
l_int|NULL
comma
l_string|&quot;combine patterns specified with -e&quot;
comma
id|PARSE_OPT_NOARG
op_or
id|PARSE_OPT_NONEG
comma
id|and_callback
)brace
comma
id|OPT_BOOLEAN
c_func
(paren
l_int|0
comma
l_string|&quot;or&quot;
comma
op_amp
id|dummy
comma
l_string|&quot;&quot;
)paren
comma
(brace
id|OPTION_CALLBACK
comma
l_int|0
comma
l_string|&quot;not&quot;
comma
op_amp
id|opt
comma
l_int|NULL
comma
l_string|&quot;&quot;
comma
id|PARSE_OPT_NOARG
op_or
id|PARSE_OPT_NONEG
comma
id|not_callback
)brace
comma
(brace
id|OPTION_CALLBACK
comma
l_char|&squot;(&squot;
comma
l_int|NULL
comma
op_amp
id|opt
comma
l_int|NULL
comma
l_string|&quot;&quot;
comma
id|PARSE_OPT_NOARG
op_or
id|PARSE_OPT_NONEG
op_or
id|PARSE_OPT_NODASH
comma
id|open_callback
)brace
comma
(brace
id|OPTION_CALLBACK
comma
l_char|&squot;)&squot;
comma
l_int|NULL
comma
op_amp
id|opt
comma
l_int|NULL
comma
l_string|&quot;&quot;
comma
id|PARSE_OPT_NOARG
op_or
id|PARSE_OPT_NONEG
op_or
id|PARSE_OPT_NODASH
comma
id|close_callback
)brace
comma
id|OPT_BOOLEAN
c_func
(paren
l_char|&squot;q&squot;
comma
l_string|&quot;quiet&quot;
comma
op_amp
id|opt.status_only
comma
l_string|&quot;indicate hit with exit status without output&quot;
)paren
comma
id|OPT_BOOLEAN
c_func
(paren
l_int|0
comma
l_string|&quot;all-match&quot;
comma
op_amp
id|opt.all_match
comma
l_string|&quot;show only matches from files that match all patterns&quot;
)paren
comma
id|OPT_GROUP
c_func
(paren
l_string|&quot;&quot;
)paren
comma
id|OPT_BOOLEAN
c_func
(paren
l_int|0
comma
l_string|&quot;ext-grep&quot;
comma
op_amp
id|external_grep_allowed__ignored
comma
l_string|&quot;allow calling of grep(1) (ignored by this build)&quot;
)paren
comma
(brace
id|OPTION_CALLBACK
comma
l_int|0
comma
l_string|&quot;help-all&quot;
comma
op_amp
id|options
comma
l_int|NULL
comma
l_string|&quot;show usage&quot;
comma
id|PARSE_OPT_HIDDEN
op_or
id|PARSE_OPT_NOARG
comma
id|help_callback
)brace
comma
id|OPT_END
c_func
(paren
)paren
)brace
suffix:semicolon
id|prefix
op_assign
id|setup_git_directory_gently
c_func
(paren
op_amp
id|nongit
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * &squot;git grep -h&squot;, unlike &squot;git grep -h &lt;pattern&gt;&squot;, is a request&n;&t; * to show usage information and exit.&n;&t; */
r_if
c_cond
(paren
id|argc
op_eq
l_int|2
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
l_string|&quot;-h&quot;
)paren
)paren
id|usage_with_options
c_func
(paren
id|grep_usage
comma
id|options
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|opt
comma
l_int|0
comma
r_sizeof
(paren
id|opt
)paren
)paren
suffix:semicolon
id|opt.prefix
op_assign
id|prefix
suffix:semicolon
id|opt.prefix_length
op_assign
(paren
id|prefix
op_logical_and
op_star
id|prefix
)paren
ques
c_cond
id|strlen
c_func
(paren
id|prefix
)paren
suffix:colon
l_int|0
suffix:semicolon
id|opt.relative
op_assign
l_int|1
suffix:semicolon
id|opt.pathname
op_assign
l_int|1
suffix:semicolon
id|opt.pattern_tail
op_assign
op_amp
id|opt.pattern_list
suffix:semicolon
id|opt.header_tail
op_assign
op_amp
id|opt.header_list
suffix:semicolon
id|opt.regflags
op_assign
id|REG_NEWLINE
suffix:semicolon
id|opt.max_depth
op_assign
l_int|1
suffix:semicolon
id|strcpy
c_func
(paren
id|opt.color_context
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|opt.color_filename
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|opt.color_function
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|opt.color_lineno
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|opt.color_match
comma
id|GIT_COLOR_BOLD_RED
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|opt.color_selected
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|opt.color_sep
comma
id|GIT_COLOR_CYAN
)paren
suffix:semicolon
id|opt.color
op_assign
l_int|1
suffix:semicolon
id|git_config
c_func
(paren
id|grep_config
comma
op_amp
id|opt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opt.color
op_eq
l_int|1
)paren
id|opt.color
op_assign
id|git_use_color_default
suffix:semicolon
multiline_comment|/*&n;&t; * If there is no -- then the paths must exist in the working&n;&t; * tree.  If there is no explicit pattern specified with -e or&n;&t; * -f, we take the first unrecognized non option to be the&n;&t; * pattern, but then what follows it must be zero or more&n;&t; * valid refs up to the -- (if exists), and then existing&n;&t; * paths.  If there is an explicit pattern, then the first&n;&t; * unrecognized non option is the beginning of the refs list&n;&t; * that continues up to the -- (if exists), and then paths.&n;&t; */
id|argc
op_assign
id|parse_options
c_func
(paren
id|argc
comma
id|argv
comma
id|prefix
comma
id|options
comma
id|grep_usage
comma
id|PARSE_OPT_KEEP_DASHDASH
op_or
id|PARSE_OPT_STOP_AT_NON_OPTION
op_or
id|PARSE_OPT_NO_INTERNAL_HELP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|use_index
op_logical_and
id|nongit
)paren
multiline_comment|/* die the same way as if we did it at the beginning */
id|setup_git_directory
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * skip a -- separator; we know it cannot be&n;&t; * separating revisions from pathnames if&n;&t; * we haven&squot;t even had any patterns yet&n;&t; */
r_if
c_cond
(paren
id|argc
OG
l_int|0
op_logical_and
op_logical_neg
id|opt.pattern_list
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|argv
(braket
l_int|0
)braket
comma
l_string|&quot;--&quot;
)paren
)paren
(brace
id|argv
op_increment
suffix:semicolon
id|argc
op_decrement
suffix:semicolon
)brace
multiline_comment|/* First unrecognized non-option token */
r_if
c_cond
(paren
id|argc
OG
l_int|0
op_logical_and
op_logical_neg
id|opt.pattern_list
)paren
(brace
id|append_grep_pattern
c_func
(paren
op_amp
id|opt
comma
id|argv
(braket
l_int|0
)braket
comma
l_string|&quot;command line&quot;
comma
l_int|0
comma
id|GREP_PATTERN
)paren
suffix:semicolon
id|argv
op_increment
suffix:semicolon
id|argc
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|opt.pattern_list
)paren
id|die
c_func
(paren
l_string|&quot;no pattern given.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|opt.fixed
op_logical_and
id|opt.ignore_case
)paren
id|opt.regflags
op_or_assign
id|REG_ICASE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|opt.regflags
op_ne
id|REG_NEWLINE
)paren
op_logical_and
id|opt.fixed
)paren
id|die
c_func
(paren
l_string|&quot;cannot mix --fixed-strings and regexp&quot;
)paren
suffix:semicolon
macro_line|#ifndef NO_PTHREADS
r_if
c_cond
(paren
id|online_cpus
c_func
(paren
)paren
op_eq
l_int|1
op_logical_or
op_logical_neg
id|grep_threads_ok
c_func
(paren
op_amp
id|opt
)paren
)paren
id|use_threads
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|use_threads
)paren
(brace
r_if
c_cond
(paren
id|opt.pre_context
op_logical_or
id|opt.post_context
)paren
id|print_hunk_marks_between_files
op_assign
l_int|1
suffix:semicolon
id|start_threads
c_func
(paren
op_amp
id|opt
)paren
suffix:semicolon
)brace
macro_line|#else
id|use_threads
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|compile_grep_patterns
c_func
(paren
op_amp
id|opt
)paren
suffix:semicolon
multiline_comment|/* Check revs and then paths */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|argc
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_char
op_star
id|arg
op_assign
id|argv
(braket
id|i
)braket
suffix:semicolon
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
multiline_comment|/* Is it a rev? */
r_if
c_cond
(paren
op_logical_neg
id|get_sha1
c_func
(paren
id|arg
comma
id|sha1
)paren
)paren
(brace
r_struct
id|object
op_star
id|object
op_assign
id|parse_object
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|object
)paren
id|die
c_func
(paren
l_string|&quot;bad object %s&quot;
comma
id|arg
)paren
suffix:semicolon
id|add_object_array
c_func
(paren
id|object
comma
id|arg
comma
op_amp
id|list
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--&quot;
)paren
)paren
(brace
id|i
op_increment
suffix:semicolon
id|seen_dashdash
op_assign
l_int|1
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/* The rest are paths */
r_if
c_cond
(paren
op_logical_neg
id|seen_dashdash
)paren
(brace
r_int
id|j
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|i
suffix:semicolon
id|j
OL
id|argc
suffix:semicolon
id|j
op_increment
)paren
id|verify_filename
c_func
(paren
id|prefix
comma
id|argv
(braket
id|j
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
OL
id|argc
)paren
id|paths
op_assign
id|get_pathspec
c_func
(paren
id|prefix
comma
id|argv
op_plus
id|i
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|prefix
)paren
(brace
id|paths
op_assign
id|xcalloc
c_func
(paren
l_int|2
comma
r_sizeof
(paren
r_const
r_char
op_star
)paren
)paren
suffix:semicolon
id|paths
(braket
l_int|0
)braket
op_assign
id|prefix
suffix:semicolon
id|paths
(braket
l_int|1
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|use_index
)paren
(brace
r_int
id|hit
suffix:semicolon
r_if
c_cond
(paren
id|cached
)paren
id|die
c_func
(paren
l_string|&quot;--cached cannot be used with --no-index.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list.nr
)paren
id|die
c_func
(paren
l_string|&quot;--no-index cannot be used with revs.&quot;
)paren
suffix:semicolon
id|hit
op_assign
id|grep_directory
c_func
(paren
op_amp
id|opt
comma
id|paths
)paren
suffix:semicolon
r_if
c_cond
(paren
id|use_threads
)paren
id|hit
op_or_assign
id|wait_all
c_func
(paren
)paren
suffix:semicolon
r_return
op_logical_neg
id|hit
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|list.nr
)paren
(brace
r_int
id|hit
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cached
)paren
id|setup_work_tree
c_func
(paren
)paren
suffix:semicolon
id|hit
op_assign
id|grep_cache
c_func
(paren
op_amp
id|opt
comma
id|paths
comma
id|cached
)paren
suffix:semicolon
r_if
c_cond
(paren
id|use_threads
)paren
id|hit
op_or_assign
id|wait_all
c_func
(paren
)paren
suffix:semicolon
r_return
op_logical_neg
id|hit
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cached
)paren
id|die
c_func
(paren
l_string|&quot;both --cached and trees are given.&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|list.nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|object
op_star
id|real_obj
suffix:semicolon
id|real_obj
op_assign
id|deref_tag
c_func
(paren
id|list.objects
(braket
id|i
)braket
dot
id|item
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|grep_object
c_func
(paren
op_amp
id|opt
comma
id|paths
comma
id|real_obj
comma
id|list.objects
(braket
id|i
)braket
dot
id|name
)paren
)paren
(brace
id|hit
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|opt.status_only
)paren
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|use_threads
)paren
id|hit
op_or_assign
id|wait_all
c_func
(paren
)paren
suffix:semicolon
id|free_grep_patterns
c_func
(paren
op_amp
id|opt
)paren
suffix:semicolon
r_return
op_logical_neg
id|hit
suffix:semicolon
)brace
eof
