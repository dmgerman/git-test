macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;builtin.h&quot;
macro_line|#include &quot;parse-options.h&quot;
macro_line|#include &quot;refs.h&quot;
macro_line|#include &quot;commit.h&quot;
macro_line|#include &quot;tree.h&quot;
macro_line|#include &quot;tree-walk.h&quot;
macro_line|#include &quot;cache-tree.h&quot;
macro_line|#include &quot;unpack-trees.h&quot;
macro_line|#include &quot;dir.h&quot;
macro_line|#include &quot;run-command.h&quot;
macro_line|#include &quot;merge-recursive.h&quot;
macro_line|#include &quot;branch.h&quot;
macro_line|#include &quot;diff.h&quot;
macro_line|#include &quot;revision.h&quot;
macro_line|#include &quot;remote.h&quot;
macro_line|#include &quot;blob.h&quot;
macro_line|#include &quot;xdiff-interface.h&quot;
macro_line|#include &quot;ll-merge.h&quot;
macro_line|#include &quot;resolve-undo.h&quot;
macro_line|#include &quot;submodule.h&quot;
macro_line|#include &quot;argv-array.h&quot;
DECL|variable|checkout_usage
r_static
r_const
r_char
op_star
r_const
id|checkout_usage
(braket
)braket
op_assign
(brace
l_string|&quot;git checkout [options] &lt;branch&gt;&quot;
comma
l_string|&quot;git checkout [options] [&lt;branch&gt;] -- &lt;file&gt;...&quot;
comma
l_int|NULL
comma
)brace
suffix:semicolon
DECL|struct|checkout_opts
r_struct
id|checkout_opts
(brace
DECL|member|quiet
r_int
id|quiet
suffix:semicolon
DECL|member|merge
r_int
id|merge
suffix:semicolon
DECL|member|force
r_int
id|force
suffix:semicolon
DECL|member|force_detach
r_int
id|force_detach
suffix:semicolon
DECL|member|writeout_stage
r_int
id|writeout_stage
suffix:semicolon
DECL|member|writeout_error
r_int
id|writeout_error
suffix:semicolon
DECL|member|overwrite_ignore
r_int
id|overwrite_ignore
suffix:semicolon
multiline_comment|/* not set by parse_options */
DECL|member|branch_exists
r_int
id|branch_exists
suffix:semicolon
DECL|member|new_branch
r_const
r_char
op_star
id|new_branch
suffix:semicolon
DECL|member|new_branch_force
r_const
r_char
op_star
id|new_branch_force
suffix:semicolon
DECL|member|new_orphan_branch
r_const
r_char
op_star
id|new_orphan_branch
suffix:semicolon
DECL|member|new_branch_log
r_int
id|new_branch_log
suffix:semicolon
DECL|member|track
r_enum
id|branch_track
id|track
suffix:semicolon
DECL|member|diff_options
r_struct
id|diff_options
id|diff_options
suffix:semicolon
)brace
suffix:semicolon
DECL|function|post_checkout_hook
r_static
r_int
id|post_checkout_hook
c_func
(paren
r_struct
id|commit
op_star
id|old
comma
r_struct
id|commit
op_star
r_new
comma
r_int
id|changed
)paren
(brace
r_return
id|run_hook
c_func
(paren
l_int|NULL
comma
l_string|&quot;post-checkout&quot;
comma
id|sha1_to_hex
c_func
(paren
id|old
ques
c_cond
id|old-&gt;object.sha1
suffix:colon
id|null_sha1
)paren
comma
id|sha1_to_hex
c_func
(paren
r_new
ques
c_cond
r_new
op_member_access_from_pointer
id|object.sha1
suffix:colon
id|null_sha1
)paren
comma
id|changed
ques
c_cond
l_string|&quot;1&quot;
suffix:colon
l_string|&quot;0&quot;
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* &quot;new&quot; can be NULL when checking out from the index before&n;&t;   a commit exists. */
)brace
DECL|function|update_some
r_static
r_int
id|update_some
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
comma
r_const
r_char
op_star
id|base
comma
r_int
id|baselen
comma
r_const
r_char
op_star
id|pathname
comma
r_int
id|mode
comma
r_int
id|stage
comma
r_void
op_star
id|context
)paren
(brace
r_int
id|len
suffix:semicolon
r_struct
id|cache_entry
op_star
id|ce
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|mode
)paren
)paren
r_return
id|READ_TREE_RECURSIVE
suffix:semicolon
id|len
op_assign
id|baselen
op_plus
id|strlen
c_func
(paren
id|pathname
)paren
suffix:semicolon
id|ce
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
id|cache_entry_size
c_func
(paren
id|len
)paren
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|ce-&gt;sha1
comma
id|sha1
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ce-&gt;name
comma
id|base
comma
id|baselen
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ce-&gt;name
op_plus
id|baselen
comma
id|pathname
comma
id|len
id|baselen
)paren
suffix:semicolon
id|ce-&gt;ce_flags
op_assign
id|create_ce_flags
c_func
(paren
id|len
comma
l_int|0
)paren
op_or
id|CE_UPDATE
suffix:semicolon
id|ce-&gt;ce_mode
op_assign
id|create_ce_mode
c_func
(paren
id|mode
)paren
suffix:semicolon
id|add_cache_entry
c_func
(paren
id|ce
comma
id|ADD_CACHE_OK_TO_ADD
op_or
id|ADD_CACHE_OK_TO_REPLACE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|read_tree_some
r_static
r_int
id|read_tree_some
c_func
(paren
r_struct
id|tree
op_star
id|tree
comma
r_const
r_char
op_star
op_star
id|pathspec
)paren
(brace
r_struct
id|pathspec
id|ps
suffix:semicolon
id|init_pathspec
c_func
(paren
op_amp
id|ps
comma
id|pathspec
)paren
suffix:semicolon
id|read_tree_recursive
c_func
(paren
id|tree
comma
l_string|&quot;&quot;
comma
l_int|0
comma
l_int|0
comma
op_amp
id|ps
comma
id|update_some
comma
l_int|NULL
)paren
suffix:semicolon
id|free_pathspec
c_func
(paren
op_amp
id|ps
)paren
suffix:semicolon
multiline_comment|/* update the index with the given tree&squot;s info&n;&t; * for all args, expanding wildcards, and exit&n;&t; * with any non-zero return code.&n;&t; */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|skip_same_name
r_static
r_int
id|skip_same_name
c_func
(paren
r_struct
id|cache_entry
op_star
id|ce
comma
r_int
id|pos
)paren
(brace
r_while
c_loop
(paren
op_increment
id|pos
OL
id|active_nr
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|active_cache
(braket
id|pos
)braket
op_member_access_from_pointer
id|name
comma
id|ce-&gt;name
)paren
)paren
suffix:semicolon
multiline_comment|/* skip */
r_return
id|pos
suffix:semicolon
)brace
DECL|function|check_stage
r_static
r_int
id|check_stage
c_func
(paren
r_int
id|stage
comma
r_struct
id|cache_entry
op_star
id|ce
comma
r_int
id|pos
)paren
(brace
r_while
c_loop
(paren
id|pos
OL
id|active_nr
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|active_cache
(braket
id|pos
)braket
op_member_access_from_pointer
id|name
comma
id|ce-&gt;name
)paren
)paren
(brace
r_if
c_cond
(paren
id|ce_stage
c_func
(paren
id|active_cache
(braket
id|pos
)braket
)paren
op_eq
id|stage
)paren
r_return
l_int|0
suffix:semicolon
id|pos
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stage
op_eq
l_int|2
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;path &squot;%s&squot; does not have our version&quot;
)paren
comma
id|ce-&gt;name
)paren
suffix:semicolon
r_else
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;path &squot;%s&squot; does not have their version&quot;
)paren
comma
id|ce-&gt;name
)paren
suffix:semicolon
)brace
DECL|function|check_stages
r_static
r_int
id|check_stages
c_func
(paren
r_int
id|stages
comma
r_struct
id|cache_entry
op_star
id|ce
comma
r_int
id|pos
)paren
(brace
r_int
id|seen
op_assign
l_int|0
suffix:semicolon
r_const
r_char
op_star
id|name
op_assign
id|ce-&gt;name
suffix:semicolon
r_while
c_loop
(paren
id|pos
OL
id|active_nr
)paren
(brace
id|ce
op_assign
id|active_cache
(braket
id|pos
)braket
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|name
comma
id|ce-&gt;name
)paren
)paren
r_break
suffix:semicolon
id|seen
op_or_assign
(paren
l_int|1
op_lshift
id|ce_stage
c_func
(paren
id|ce
)paren
)paren
suffix:semicolon
id|pos
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|stages
op_amp
id|seen
)paren
op_ne
id|stages
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;path &squot;%s&squot; does not have all necessary versions&quot;
)paren
comma
id|name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|checkout_stage
r_static
r_int
id|checkout_stage
c_func
(paren
r_int
id|stage
comma
r_struct
id|cache_entry
op_star
id|ce
comma
r_int
id|pos
comma
r_struct
id|checkout
op_star
id|state
)paren
(brace
r_while
c_loop
(paren
id|pos
OL
id|active_nr
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|active_cache
(braket
id|pos
)braket
op_member_access_from_pointer
id|name
comma
id|ce-&gt;name
)paren
)paren
(brace
r_if
c_cond
(paren
id|ce_stage
c_func
(paren
id|active_cache
(braket
id|pos
)braket
)paren
op_eq
id|stage
)paren
r_return
id|checkout_entry
c_func
(paren
id|active_cache
(braket
id|pos
)braket
comma
id|state
comma
l_int|NULL
)paren
suffix:semicolon
id|pos
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stage
op_eq
l_int|2
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;path &squot;%s&squot; does not have our version&quot;
)paren
comma
id|ce-&gt;name
)paren
suffix:semicolon
r_else
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;path &squot;%s&squot; does not have their version&quot;
)paren
comma
id|ce-&gt;name
)paren
suffix:semicolon
)brace
DECL|function|checkout_merged
r_static
r_int
id|checkout_merged
c_func
(paren
r_int
id|pos
comma
r_struct
id|checkout
op_star
id|state
)paren
(brace
r_struct
id|cache_entry
op_star
id|ce
op_assign
id|active_cache
(braket
id|pos
)braket
suffix:semicolon
r_const
r_char
op_star
id|path
op_assign
id|ce-&gt;name
suffix:semicolon
id|mmfile_t
id|ancestor
comma
id|ours
comma
id|theirs
suffix:semicolon
r_int
id|status
suffix:semicolon
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
id|mmbuffer_t
id|result_buf
suffix:semicolon
r_int
r_char
id|threeway
(braket
l_int|3
)braket
(braket
l_int|20
)braket
suffix:semicolon
r_int
id|mode
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|threeway
comma
l_int|0
comma
r_sizeof
(paren
id|threeway
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|pos
OL
id|active_nr
)paren
(brace
r_int
id|stage
suffix:semicolon
id|stage
op_assign
id|ce_stage
c_func
(paren
id|ce
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stage
op_logical_or
id|strcmp
c_func
(paren
id|path
comma
id|ce-&gt;name
)paren
)paren
r_break
suffix:semicolon
id|hashcpy
c_func
(paren
id|threeway
(braket
id|stage
l_int|1
)braket
comma
id|ce-&gt;sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stage
op_eq
l_int|2
)paren
id|mode
op_assign
id|create_ce_mode
c_func
(paren
id|ce-&gt;ce_mode
)paren
suffix:semicolon
id|pos
op_increment
suffix:semicolon
id|ce
op_assign
id|active_cache
(braket
id|pos
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_null_sha1
c_func
(paren
id|threeway
(braket
l_int|1
)braket
)paren
op_logical_or
id|is_null_sha1
c_func
(paren
id|threeway
(braket
l_int|2
)braket
)paren
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;path &squot;%s&squot; does not have necessary versions&quot;
)paren
comma
id|path
)paren
suffix:semicolon
id|read_mmblob
c_func
(paren
op_amp
id|ancestor
comma
id|threeway
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|read_mmblob
c_func
(paren
op_amp
id|ours
comma
id|threeway
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|read_mmblob
c_func
(paren
op_amp
id|theirs
comma
id|threeway
(braket
l_int|2
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * NEEDSWORK: re-create conflicts from merges with&n;&t; * merge.renormalize set, too&n;&t; */
id|status
op_assign
id|ll_merge
c_func
(paren
op_amp
id|result_buf
comma
id|path
comma
op_amp
id|ancestor
comma
l_string|&quot;base&quot;
comma
op_amp
id|ours
comma
l_string|&quot;ours&quot;
comma
op_amp
id|theirs
comma
l_string|&quot;theirs&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|free
c_func
(paren
id|ancestor.ptr
)paren
suffix:semicolon
id|free
c_func
(paren
id|ours.ptr
)paren
suffix:semicolon
id|free
c_func
(paren
id|theirs.ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
op_logical_or
op_logical_neg
id|result_buf.ptr
)paren
(brace
id|free
c_func
(paren
id|result_buf.ptr
)paren
suffix:semicolon
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;path &squot;%s&squot;: cannot merge&quot;
)paren
comma
id|path
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * NEEDSWORK:&n;&t; * There is absolutely no reason to write this as a blob object&n;&t; * and create a phony cache entry just to leak.  This hack is&n;&t; * primarily to get to the write_entry() machinery that massages&n;&t; * the contents to work-tree format and writes out which only&n;&t; * allows it for a cache entry.  The code in write_entry() needs&n;&t; * to be refactored to allow us to feed a &lt;buffer, size, mode&gt;&n;&t; * instead of a cache entry.  Such a refactoring would help&n;&t; * merge_recursive as well (it also writes the merge result to the&n;&t; * object database even when it may contain conflicts).&n;&t; */
r_if
c_cond
(paren
id|write_sha1_file
c_func
(paren
id|result_buf.ptr
comma
id|result_buf.size
comma
id|blob_type
comma
id|sha1
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Unable to add merge result for &squot;%s&squot;&quot;
)paren
comma
id|path
)paren
suffix:semicolon
id|ce
op_assign
id|make_cache_entry
c_func
(paren
id|mode
comma
id|sha1
comma
id|path
comma
l_int|2
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ce
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;make_cache_entry failed for path &squot;%s&squot;&quot;
)paren
comma
id|path
)paren
suffix:semicolon
id|status
op_assign
id|checkout_entry
c_func
(paren
id|ce
comma
id|state
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
DECL|function|checkout_paths
r_static
r_int
id|checkout_paths
c_func
(paren
r_struct
id|tree
op_star
id|source_tree
comma
r_const
r_char
op_star
op_star
id|pathspec
comma
r_const
r_char
op_star
id|prefix
comma
r_struct
id|checkout_opts
op_star
id|opts
)paren
(brace
r_int
id|pos
suffix:semicolon
r_struct
id|checkout
id|state
suffix:semicolon
r_static
r_char
op_star
id|ps_matched
suffix:semicolon
r_int
r_char
id|rev
(braket
l_int|20
)braket
suffix:semicolon
r_int
id|flag
suffix:semicolon
r_struct
id|commit
op_star
id|head
suffix:semicolon
r_int
id|errs
op_assign
l_int|0
suffix:semicolon
r_int
id|stage
op_assign
id|opts-&gt;writeout_stage
suffix:semicolon
r_int
id|merge
op_assign
id|opts-&gt;merge
suffix:semicolon
r_int
id|newfd
suffix:semicolon
r_struct
id|lock_file
op_star
id|lock_file
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|lock_file
)paren
)paren
suffix:semicolon
id|newfd
op_assign
id|hold_locked_index
c_func
(paren
id|lock_file
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_cache_preload
c_func
(paren
id|pathspec
)paren
OL
l_int|0
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;corrupt index file&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|source_tree
)paren
id|read_tree_some
c_func
(paren
id|source_tree
comma
id|pathspec
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pos
op_assign
l_int|0
suffix:semicolon
id|pathspec
(braket
id|pos
)braket
suffix:semicolon
id|pos
op_increment
)paren
suffix:semicolon
id|ps_matched
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
id|pos
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pos
op_assign
l_int|0
suffix:semicolon
id|pos
OL
id|active_nr
suffix:semicolon
id|pos
op_increment
)paren
(brace
r_struct
id|cache_entry
op_star
id|ce
op_assign
id|active_cache
(braket
id|pos
)braket
suffix:semicolon
r_if
c_cond
(paren
id|source_tree
op_logical_and
op_logical_neg
(paren
id|ce-&gt;ce_flags
op_amp
id|CE_UPDATE
)paren
)paren
r_continue
suffix:semicolon
id|match_pathspec
c_func
(paren
id|pathspec
comma
id|ce-&gt;name
comma
id|ce_namelen
c_func
(paren
id|ce
)paren
comma
l_int|0
comma
id|ps_matched
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|report_path_error
c_func
(paren
id|ps_matched
comma
id|pathspec
comma
id|prefix
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* &quot;checkout -m path&quot; to recreate conflicted state */
r_if
c_cond
(paren
id|opts-&gt;merge
)paren
id|unmerge_cache
c_func
(paren
id|pathspec
)paren
suffix:semicolon
multiline_comment|/* Any unmerged paths? */
r_for
c_loop
(paren
id|pos
op_assign
l_int|0
suffix:semicolon
id|pos
OL
id|active_nr
suffix:semicolon
id|pos
op_increment
)paren
(brace
r_struct
id|cache_entry
op_star
id|ce
op_assign
id|active_cache
(braket
id|pos
)braket
suffix:semicolon
r_if
c_cond
(paren
id|match_pathspec
c_func
(paren
id|pathspec
comma
id|ce-&gt;name
comma
id|ce_namelen
c_func
(paren
id|ce
)paren
comma
l_int|0
comma
l_int|NULL
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ce_stage
c_func
(paren
id|ce
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|opts-&gt;force
)paren
(brace
id|warning
c_func
(paren
id|_
c_func
(paren
l_string|&quot;path &squot;%s&squot; is unmerged&quot;
)paren
comma
id|ce-&gt;name
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|stage
)paren
(brace
id|errs
op_or_assign
id|check_stage
c_func
(paren
id|stage
comma
id|ce
comma
id|pos
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|opts-&gt;merge
)paren
(brace
id|errs
op_or_assign
id|check_stages
c_func
(paren
(paren
l_int|1
op_lshift
l_int|2
)paren
op_or
(paren
l_int|1
op_lshift
l_int|3
)paren
comma
id|ce
comma
id|pos
)paren
suffix:semicolon
)brace
r_else
(brace
id|errs
op_assign
l_int|1
suffix:semicolon
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;path &squot;%s&squot; is unmerged&quot;
)paren
comma
id|ce-&gt;name
)paren
suffix:semicolon
)brace
id|pos
op_assign
id|skip_same_name
c_func
(paren
id|ce
comma
id|pos
)paren
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|errs
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Now we are committed to check them out */
id|memset
c_func
(paren
op_amp
id|state
comma
l_int|0
comma
r_sizeof
(paren
id|state
)paren
)paren
suffix:semicolon
id|state.force
op_assign
l_int|1
suffix:semicolon
id|state.refresh_cache
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|pos
op_assign
l_int|0
suffix:semicolon
id|pos
OL
id|active_nr
suffix:semicolon
id|pos
op_increment
)paren
(brace
r_struct
id|cache_entry
op_star
id|ce
op_assign
id|active_cache
(braket
id|pos
)braket
suffix:semicolon
r_if
c_cond
(paren
id|source_tree
op_logical_and
op_logical_neg
(paren
id|ce-&gt;ce_flags
op_amp
id|CE_UPDATE
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|match_pathspec
c_func
(paren
id|pathspec
comma
id|ce-&gt;name
comma
id|ce_namelen
c_func
(paren
id|ce
)paren
comma
l_int|0
comma
l_int|NULL
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ce_stage
c_func
(paren
id|ce
)paren
)paren
(brace
id|errs
op_or_assign
id|checkout_entry
c_func
(paren
id|ce
comma
op_amp
id|state
comma
l_int|NULL
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stage
)paren
id|errs
op_or_assign
id|checkout_stage
c_func
(paren
id|stage
comma
id|ce
comma
id|pos
comma
op_amp
id|state
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|merge
)paren
id|errs
op_or_assign
id|checkout_merged
c_func
(paren
id|pos
comma
op_amp
id|state
)paren
suffix:semicolon
id|pos
op_assign
id|skip_same_name
c_func
(paren
id|ce
comma
id|pos
)paren
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|write_cache
c_func
(paren
id|newfd
comma
id|active_cache
comma
id|active_nr
)paren
op_logical_or
id|commit_locked_index
c_func
(paren
id|lock_file
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;unable to write new index file&quot;
)paren
)paren
suffix:semicolon
id|read_ref_full
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|rev
comma
l_int|0
comma
op_amp
id|flag
)paren
suffix:semicolon
id|head
op_assign
id|lookup_commit_reference_gently
c_func
(paren
id|rev
comma
l_int|1
)paren
suffix:semicolon
id|errs
op_or_assign
id|post_checkout_hook
c_func
(paren
id|head
comma
id|head
comma
l_int|0
)paren
suffix:semicolon
r_return
id|errs
suffix:semicolon
)brace
DECL|function|show_local_changes
r_static
r_void
id|show_local_changes
c_func
(paren
r_struct
id|object
op_star
id|head
comma
r_struct
id|diff_options
op_star
id|opts
)paren
(brace
r_struct
id|rev_info
id|rev
suffix:semicolon
multiline_comment|/* I think we want full paths, even if we&squot;re in a subdirectory. */
id|init_revisions
c_func
(paren
op_amp
id|rev
comma
l_int|NULL
)paren
suffix:semicolon
id|rev.diffopt.flags
op_assign
id|opts-&gt;flags
suffix:semicolon
id|rev.diffopt.output_format
op_or_assign
id|DIFF_FORMAT_NAME_STATUS
suffix:semicolon
r_if
c_cond
(paren
id|diff_setup_done
c_func
(paren
op_amp
id|rev.diffopt
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;diff_setup_done failed&quot;
)paren
)paren
suffix:semicolon
id|add_pending_object
c_func
(paren
op_amp
id|rev
comma
id|head
comma
l_int|NULL
)paren
suffix:semicolon
id|run_diff_index
c_func
(paren
op_amp
id|rev
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|describe_detached_head
r_static
r_void
id|describe_detached_head
c_func
(paren
r_const
r_char
op_star
id|msg
comma
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
id|parse_commit
c_func
(paren
id|commit
)paren
suffix:semicolon
id|pp_commit_easy
c_func
(paren
id|CMIT_FMT_ONELINE
comma
id|commit
comma
op_amp
id|sb
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s %s... %s&bslash;n&quot;
comma
id|msg
comma
id|find_unique_abbrev
c_func
(paren
id|commit-&gt;object.sha1
comma
id|DEFAULT_ABBREV
)paren
comma
id|sb.buf
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
)brace
DECL|function|reset_tree
r_static
r_int
id|reset_tree
c_func
(paren
r_struct
id|tree
op_star
id|tree
comma
r_struct
id|checkout_opts
op_star
id|o
comma
r_int
id|worktree
)paren
(brace
r_struct
id|unpack_trees_options
id|opts
suffix:semicolon
r_struct
id|tree_desc
id|tree_desc
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|opts
comma
l_int|0
comma
r_sizeof
(paren
id|opts
)paren
)paren
suffix:semicolon
id|opts.head_idx
op_assign
l_int|1
suffix:semicolon
id|opts.update
op_assign
id|worktree
suffix:semicolon
id|opts.skip_unmerged
op_assign
op_logical_neg
id|worktree
suffix:semicolon
id|opts.reset
op_assign
l_int|1
suffix:semicolon
id|opts.merge
op_assign
l_int|1
suffix:semicolon
id|opts.fn
op_assign
id|oneway_merge
suffix:semicolon
id|opts.verbose_update
op_assign
op_logical_neg
id|o-&gt;quiet
suffix:semicolon
id|opts.src_index
op_assign
op_amp
id|the_index
suffix:semicolon
id|opts.dst_index
op_assign
op_amp
id|the_index
suffix:semicolon
id|parse_tree
c_func
(paren
id|tree
)paren
suffix:semicolon
id|init_tree_desc
c_func
(paren
op_amp
id|tree_desc
comma
id|tree-&gt;buffer
comma
id|tree-&gt;size
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|unpack_trees
c_func
(paren
l_int|1
comma
op_amp
id|tree_desc
comma
op_amp
id|opts
)paren
)paren
(brace
r_case
l_int|2
suffix:colon
id|o-&gt;writeout_error
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We return 0 nevertheless, as the index is all right&n;&t;&t; * and more importantly we have made best efforts to&n;&t;&t; * update paths in the work tree, and we cannot revert&n;&t;&t; * them.&n;&t;&t; */
r_case
l_int|0
suffix:colon
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
r_return
l_int|128
suffix:semicolon
)brace
)brace
DECL|struct|branch_info
r_struct
id|branch_info
(brace
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
multiline_comment|/* The short name used */
DECL|member|path
r_const
r_char
op_star
id|path
suffix:semicolon
multiline_comment|/* The full name of a real branch */
DECL|member|commit
r_struct
id|commit
op_star
id|commit
suffix:semicolon
multiline_comment|/* The named commit */
)brace
suffix:semicolon
DECL|function|setup_branch_path
r_static
r_void
id|setup_branch_path
c_func
(paren
r_struct
id|branch_info
op_star
id|branch
)paren
(brace
r_struct
id|strbuf
id|buf
op_assign
id|STRBUF_INIT
suffix:semicolon
id|strbuf_branchname
c_func
(paren
op_amp
id|buf
comma
id|branch-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|buf.buf
comma
id|branch-&gt;name
)paren
)paren
id|branch-&gt;name
op_assign
id|xstrdup
c_func
(paren
id|buf.buf
)paren
suffix:semicolon
id|strbuf_splice
c_func
(paren
op_amp
id|buf
comma
l_int|0
comma
l_int|0
comma
l_string|&quot;refs/heads/&quot;
comma
l_int|11
)paren
suffix:semicolon
id|branch-&gt;path
op_assign
id|strbuf_detach
c_func
(paren
op_amp
id|buf
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|merge_working_tree
r_static
r_int
id|merge_working_tree
c_func
(paren
r_struct
id|checkout_opts
op_star
id|opts
comma
r_struct
id|branch_info
op_star
id|old
comma
r_struct
id|branch_info
op_star
r_new
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|lock_file
op_star
id|lock_file
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|lock_file
)paren
)paren
suffix:semicolon
r_int
id|newfd
op_assign
id|hold_locked_index
c_func
(paren
id|lock_file
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_cache_preload
c_func
(paren
l_int|NULL
)paren
OL
l_int|0
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;corrupt index file&quot;
)paren
)paren
suffix:semicolon
id|resolve_undo_clear
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opts-&gt;force
)paren
(brace
id|ret
op_assign
id|reset_tree
c_func
(paren
r_new
op_member_access_from_pointer
id|commit-&gt;tree
comma
id|opts
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
)brace
r_else
(brace
r_struct
id|tree_desc
id|trees
(braket
l_int|2
)braket
suffix:semicolon
r_struct
id|tree
op_star
id|tree
suffix:semicolon
r_struct
id|unpack_trees_options
id|topts
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|topts
comma
l_int|0
comma
r_sizeof
(paren
id|topts
)paren
)paren
suffix:semicolon
id|topts.head_idx
op_assign
l_int|1
suffix:semicolon
id|topts.src_index
op_assign
op_amp
id|the_index
suffix:semicolon
id|topts.dst_index
op_assign
op_amp
id|the_index
suffix:semicolon
id|setup_unpack_trees_porcelain
c_func
(paren
op_amp
id|topts
comma
l_string|&quot;checkout&quot;
)paren
suffix:semicolon
id|refresh_cache
c_func
(paren
id|REFRESH_QUIET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unmerged_cache
c_func
(paren
)paren
)paren
(brace
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;you need to resolve your current index first&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* 2-way merge to the new branch */
id|topts.initial_checkout
op_assign
id|is_cache_unborn
c_func
(paren
)paren
suffix:semicolon
id|topts.update
op_assign
l_int|1
suffix:semicolon
id|topts.merge
op_assign
l_int|1
suffix:semicolon
id|topts.gently
op_assign
id|opts-&gt;merge
op_logical_and
id|old-&gt;commit
suffix:semicolon
id|topts.verbose_update
op_assign
op_logical_neg
id|opts-&gt;quiet
suffix:semicolon
id|topts.fn
op_assign
id|twoway_merge
suffix:semicolon
r_if
c_cond
(paren
id|opts-&gt;overwrite_ignore
)paren
(brace
id|topts.dir
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|topts.dir
)paren
)paren
suffix:semicolon
id|topts.dir-&gt;flags
op_or_assign
id|DIR_SHOW_IGNORED
suffix:semicolon
id|setup_standard_excludes
c_func
(paren
id|topts.dir
)paren
suffix:semicolon
)brace
id|tree
op_assign
id|parse_tree_indirect
c_func
(paren
id|old-&gt;commit
ques
c_cond
id|old-&gt;commit-&gt;object.sha1
suffix:colon
id|EMPTY_TREE_SHA1_BIN
)paren
suffix:semicolon
id|init_tree_desc
c_func
(paren
op_amp
id|trees
(braket
l_int|0
)braket
comma
id|tree-&gt;buffer
comma
id|tree-&gt;size
)paren
suffix:semicolon
id|tree
op_assign
id|parse_tree_indirect
c_func
(paren
r_new
op_member_access_from_pointer
id|commit-&gt;object.sha1
)paren
suffix:semicolon
id|init_tree_desc
c_func
(paren
op_amp
id|trees
(braket
l_int|1
)braket
comma
id|tree-&gt;buffer
comma
id|tree-&gt;size
)paren
suffix:semicolon
id|ret
op_assign
id|unpack_trees
c_func
(paren
l_int|2
comma
id|trees
comma
op_amp
id|topts
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Unpack couldn&squot;t do a trivial merge; either&n;&t;&t;&t; * give up or do a real merge, depending on&n;&t;&t;&t; * whether the merge flag was used.&n;&t;&t;&t; */
r_struct
id|tree
op_star
id|result
suffix:semicolon
r_struct
id|tree
op_star
id|work
suffix:semicolon
r_struct
id|merge_options
id|o
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|opts-&gt;merge
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Without old-&gt;commit, the below is the same as&n;&t;&t;&t; * the two-tree unpack we already tried and failed.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|old-&gt;commit
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Do more real merge */
multiline_comment|/*&n;&t;&t;&t; * We update the index fully, then write the&n;&t;&t;&t; * tree from the index, then merge the new&n;&t;&t;&t; * branch with the current tree, with the old&n;&t;&t;&t; * branch as the base. Then we reset the index&n;&t;&t;&t; * (but not the working tree) to the new&n;&t;&t;&t; * branch, leaving the working tree as the&n;&t;&t;&t; * merged version, but skipping unmerged&n;&t;&t;&t; * entries in the index.&n;&t;&t;&t; */
id|add_files_to_cache
c_func
(paren
l_int|NULL
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * NEEDSWORK: carrying over local changes&n;&t;&t;&t; * when branches have different end-of-line&n;&t;&t;&t; * normalization (or clean+smudge rules) is&n;&t;&t;&t; * a pain; plumb in an option to set&n;&t;&t;&t; * o.renormalize?&n;&t;&t;&t; */
id|init_merge_options
c_func
(paren
op_amp
id|o
)paren
suffix:semicolon
id|o.verbosity
op_assign
l_int|0
suffix:semicolon
id|work
op_assign
id|write_tree_from_memory
c_func
(paren
op_amp
id|o
)paren
suffix:semicolon
id|ret
op_assign
id|reset_tree
c_func
(paren
r_new
op_member_access_from_pointer
id|commit-&gt;tree
comma
id|opts
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
id|o.ancestor
op_assign
id|old-&gt;name
suffix:semicolon
id|o.branch1
op_assign
r_new
op_member_access_from_pointer
id|name
suffix:semicolon
id|o.branch2
op_assign
l_string|&quot;local&quot;
suffix:semicolon
id|merge_trees
c_func
(paren
op_amp
id|o
comma
r_new
op_member_access_from_pointer
id|commit-&gt;tree
comma
id|work
comma
id|old-&gt;commit-&gt;tree
comma
op_amp
id|result
)paren
suffix:semicolon
id|ret
op_assign
id|reset_tree
c_func
(paren
r_new
op_member_access_from_pointer
id|commit-&gt;tree
comma
id|opts
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|write_cache
c_func
(paren
id|newfd
comma
id|active_cache
comma
id|active_nr
)paren
op_logical_or
id|commit_locked_index
c_func
(paren
id|lock_file
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;unable to write new index file&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|opts-&gt;force
op_logical_and
op_logical_neg
id|opts-&gt;quiet
)paren
id|show_local_changes
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|commit-&gt;object
comma
op_amp
id|opts-&gt;diff_options
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|report_tracking
r_static
r_void
id|report_tracking
c_func
(paren
r_struct
id|branch_info
op_star
r_new
)paren
(brace
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
r_struct
id|branch
op_star
id|branch
op_assign
id|branch_get
c_func
(paren
r_new
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|format_tracking_info
c_func
(paren
id|branch
comma
op_amp
id|sb
)paren
)paren
r_return
suffix:semicolon
id|fputs
c_func
(paren
id|sb.buf
comma
id|stdout
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
)brace
DECL|function|update_refs_for_switch
r_static
r_void
id|update_refs_for_switch
c_func
(paren
r_struct
id|checkout_opts
op_star
id|opts
comma
r_struct
id|branch_info
op_star
id|old
comma
r_struct
id|branch_info
op_star
r_new
)paren
(brace
r_struct
id|strbuf
id|msg
op_assign
id|STRBUF_INIT
suffix:semicolon
r_const
r_char
op_star
id|old_desc
suffix:semicolon
r_if
c_cond
(paren
id|opts-&gt;new_branch
)paren
(brace
r_if
c_cond
(paren
id|opts-&gt;new_orphan_branch
)paren
(brace
r_if
c_cond
(paren
id|opts-&gt;new_branch_log
op_logical_and
op_logical_neg
id|log_all_ref_updates
)paren
(brace
r_int
id|temp
suffix:semicolon
r_char
id|log_file
(braket
id|PATH_MAX
)braket
suffix:semicolon
r_char
op_star
id|ref_name
op_assign
id|mkpath
c_func
(paren
l_string|&quot;refs/heads/%s&quot;
comma
id|opts-&gt;new_orphan_branch
)paren
suffix:semicolon
id|temp
op_assign
id|log_all_ref_updates
suffix:semicolon
id|log_all_ref_updates
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|log_ref_setup
c_func
(paren
id|ref_name
comma
id|log_file
comma
r_sizeof
(paren
id|log_file
)paren
)paren
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
id|_
c_func
(paren
l_string|&quot;Can not do reflog for &squot;%s&squot;&bslash;n&quot;
)paren
comma
id|opts-&gt;new_orphan_branch
)paren
suffix:semicolon
id|log_all_ref_updates
op_assign
id|temp
suffix:semicolon
r_return
suffix:semicolon
)brace
id|log_all_ref_updates
op_assign
id|temp
suffix:semicolon
)brace
)brace
r_else
id|create_branch
c_func
(paren
id|old-&gt;name
comma
id|opts-&gt;new_branch
comma
r_new
op_member_access_from_pointer
id|name
comma
id|opts-&gt;new_branch_force
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|opts-&gt;new_branch_log
comma
id|opts-&gt;new_branch_force
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|opts-&gt;quiet
comma
id|opts-&gt;track
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|name
op_assign
id|opts-&gt;new_branch
suffix:semicolon
id|setup_branch_path
c_func
(paren
r_new
)paren
suffix:semicolon
)brace
id|old_desc
op_assign
id|old-&gt;name
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|old_desc
op_logical_and
id|old-&gt;commit
)paren
id|old_desc
op_assign
id|sha1_to_hex
c_func
(paren
id|old-&gt;commit-&gt;object.sha1
)paren
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
id|msg
comma
l_string|&quot;checkout: moving from %s to %s&quot;
comma
id|old_desc
ques
c_cond
id|old_desc
suffix:colon
l_string|&quot;(invalid)&quot;
comma
r_new
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
r_new
op_member_access_from_pointer
id|name
comma
l_string|&quot;HEAD&quot;
)paren
op_logical_and
op_logical_neg
r_new
op_member_access_from_pointer
id|path
op_logical_and
op_logical_neg
id|opts-&gt;force_detach
)paren
(brace
multiline_comment|/* Nothing to do. */
)brace
r_else
r_if
c_cond
(paren
id|opts-&gt;force_detach
op_logical_or
op_logical_neg
r_new
op_member_access_from_pointer
id|path
)paren
(brace
multiline_comment|/* No longer on any branch. */
id|update_ref
c_func
(paren
id|msg.buf
comma
l_string|&quot;HEAD&quot;
comma
r_new
op_member_access_from_pointer
id|commit-&gt;object.sha1
comma
l_int|NULL
comma
id|REF_NODEREF
comma
id|DIE_ON_ERR
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|opts-&gt;quiet
)paren
(brace
r_if
c_cond
(paren
id|old-&gt;path
op_logical_and
id|advice_detached_head
)paren
id|detach_advice
c_func
(paren
r_new
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
id|describe_detached_head
c_func
(paren
id|_
c_func
(paren
l_string|&quot;HEAD is now at&quot;
)paren
comma
r_new
op_member_access_from_pointer
id|commit
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
r_new
op_member_access_from_pointer
id|path
)paren
(brace
multiline_comment|/* Switch branches. */
id|create_symref
c_func
(paren
l_string|&quot;HEAD&quot;
comma
r_new
op_member_access_from_pointer
id|path
comma
id|msg.buf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|opts-&gt;quiet
)paren
(brace
r_if
c_cond
(paren
id|old-&gt;path
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
r_new
op_member_access_from_pointer
id|path
comma
id|old-&gt;path
)paren
)paren
(brace
r_if
c_cond
(paren
id|opts-&gt;new_branch_force
)paren
id|fprintf
c_func
(paren
id|stderr
comma
id|_
c_func
(paren
l_string|&quot;Reset branch &squot;%s&squot;&bslash;n&quot;
)paren
comma
r_new
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
r_else
id|fprintf
c_func
(paren
id|stderr
comma
id|_
c_func
(paren
l_string|&quot;Already on &squot;%s&squot;&bslash;n&quot;
)paren
comma
r_new
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|opts-&gt;new_branch
)paren
(brace
r_if
c_cond
(paren
id|opts-&gt;branch_exists
)paren
id|fprintf
c_func
(paren
id|stderr
comma
id|_
c_func
(paren
l_string|&quot;Switched to and reset branch &squot;%s&squot;&bslash;n&quot;
)paren
comma
r_new
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
r_else
id|fprintf
c_func
(paren
id|stderr
comma
id|_
c_func
(paren
l_string|&quot;Switched to a new branch &squot;%s&squot;&bslash;n&quot;
)paren
comma
r_new
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
)brace
r_else
(brace
id|fprintf
c_func
(paren
id|stderr
comma
id|_
c_func
(paren
l_string|&quot;Switched to branch &squot;%s&squot;&bslash;n&quot;
)paren
comma
r_new
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|old-&gt;path
op_logical_and
id|old-&gt;name
)paren
(brace
r_char
id|log_file
(braket
id|PATH_MAX
)braket
comma
id|ref_file
(braket
id|PATH_MAX
)braket
suffix:semicolon
id|git_snpath
c_func
(paren
id|log_file
comma
r_sizeof
(paren
id|log_file
)paren
comma
l_string|&quot;logs/%s&quot;
comma
id|old-&gt;path
)paren
suffix:semicolon
id|git_snpath
c_func
(paren
id|ref_file
comma
r_sizeof
(paren
id|ref_file
)paren
comma
l_string|&quot;%s&quot;
comma
id|old-&gt;path
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file_exists
c_func
(paren
id|ref_file
)paren
op_logical_and
id|file_exists
c_func
(paren
id|log_file
)paren
)paren
id|remove_path
c_func
(paren
id|log_file
)paren
suffix:semicolon
)brace
)brace
id|remove_branch_state
c_func
(paren
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|msg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|opts-&gt;quiet
op_logical_and
(paren
r_new
op_member_access_from_pointer
id|path
op_logical_or
(paren
op_logical_neg
id|opts-&gt;force_detach
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
r_new
op_member_access_from_pointer
id|name
comma
l_string|&quot;HEAD&quot;
)paren
)paren
)paren
)paren
id|report_tracking
c_func
(paren
r_new
)paren
suffix:semicolon
)brace
DECL|function|add_pending_uninteresting_ref
r_static
r_int
id|add_pending_uninteresting_ref
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
id|flags
comma
r_void
op_star
id|cb_data
)paren
(brace
id|add_pending_sha1
c_func
(paren
id|cb_data
comma
id|refname
comma
id|sha1
comma
id|flags
op_or
id|UNINTERESTING
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|describe_one_orphan
r_static
r_void
id|describe_one_orphan
c_func
(paren
r_struct
id|strbuf
op_star
id|sb
comma
r_struct
id|commit
op_star
id|commit
)paren
(brace
id|parse_commit
c_func
(paren
id|commit
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
id|sb
comma
l_string|&quot;  &quot;
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|find_unique_abbrev
c_func
(paren
id|commit-&gt;object.sha1
comma
id|DEFAULT_ABBREV
)paren
)paren
suffix:semicolon
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
id|pp_commit_easy
c_func
(paren
id|CMIT_FMT_ONELINE
comma
id|commit
comma
id|sb
)paren
suffix:semicolon
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
DECL|macro|ORPHAN_CUTOFF
mdefine_line|#define ORPHAN_CUTOFF 4
DECL|function|suggest_reattach
r_static
r_void
id|suggest_reattach
c_func
(paren
r_struct
id|commit
op_star
id|commit
comma
r_struct
id|rev_info
op_star
id|revs
)paren
(brace
r_struct
id|commit
op_star
id|c
comma
op_star
id|last
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|lost
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
id|get_revision
c_func
(paren
id|revs
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|lost
OL
id|ORPHAN_CUTOFF
)paren
id|describe_one_orphan
c_func
(paren
op_amp
id|sb
comma
id|c
)paren
suffix:semicolon
id|last
op_assign
id|c
suffix:semicolon
id|lost
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ORPHAN_CUTOFF
OL
id|lost
)paren
(brace
r_int
id|more
op_assign
id|lost
id|ORPHAN_CUTOFF
suffix:semicolon
r_if
c_cond
(paren
id|more
op_eq
l_int|1
)paren
id|describe_one_orphan
c_func
(paren
op_amp
id|sb
comma
id|last
)paren
suffix:semicolon
r_else
id|strbuf_addf
c_func
(paren
op_amp
id|sb
comma
id|_
c_func
(paren
l_string|&quot; ... and %d more.&bslash;n&quot;
)paren
comma
id|more
)paren
suffix:semicolon
)brace
id|fprintf
c_func
(paren
id|stderr
comma
id|Q_
c_func
(paren
multiline_comment|/* The singular version */
l_string|&quot;Warning: you are leaving %d commit behind, &quot;
l_string|&quot;not connected to&bslash;n&quot;
l_string|&quot;any of your branches:&bslash;n&bslash;n&quot;
l_string|&quot;%s&bslash;n&quot;
comma
multiline_comment|/* The plural version */
l_string|&quot;Warning: you are leaving %d commits behind, &quot;
l_string|&quot;not connected to&bslash;n&quot;
l_string|&quot;any of your branches:&bslash;n&bslash;n&quot;
l_string|&quot;%s&bslash;n&quot;
comma
multiline_comment|/* Give ngettext() the count */
id|lost
)paren
comma
id|lost
comma
id|sb.buf
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|advice_detached_head
)paren
id|fprintf
c_func
(paren
id|stderr
comma
id|_
c_func
(paren
l_string|&quot;If you want to keep them by creating a new branch, &quot;
l_string|&quot;this may be a good time&bslash;nto do so with:&bslash;n&bslash;n&quot;
l_string|&quot; git branch new_branch_name %s&bslash;n&bslash;n&quot;
)paren
comma
id|sha1_to_hex
c_func
(paren
id|commit-&gt;object.sha1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * We are about to leave commit that was at the tip of a detached&n; * HEAD.  If it is not reachable from any ref, this is the last chance&n; * for the user to do so without resorting to reflog.&n; */
DECL|function|orphaned_commit_warning
r_static
r_void
id|orphaned_commit_warning
c_func
(paren
r_struct
id|commit
op_star
id|old
comma
r_struct
id|commit
op_star
r_new
)paren
(brace
r_struct
id|rev_info
id|revs
suffix:semicolon
r_struct
id|object
op_star
id|object
op_assign
op_amp
id|old-&gt;object
suffix:semicolon
r_struct
id|object_array
id|refs
suffix:semicolon
id|init_revisions
c_func
(paren
op_amp
id|revs
comma
l_int|NULL
)paren
suffix:semicolon
id|setup_revisions
c_func
(paren
l_int|0
comma
l_int|NULL
comma
op_amp
id|revs
comma
l_int|NULL
)paren
suffix:semicolon
id|object-&gt;flags
op_and_assign
op_complement
id|UNINTERESTING
suffix:semicolon
id|add_pending_object
c_func
(paren
op_amp
id|revs
comma
id|object
comma
id|sha1_to_hex
c_func
(paren
id|object-&gt;sha1
)paren
)paren
suffix:semicolon
id|for_each_ref
c_func
(paren
id|add_pending_uninteresting_ref
comma
op_amp
id|revs
)paren
suffix:semicolon
id|add_pending_sha1
c_func
(paren
op_amp
id|revs
comma
l_string|&quot;HEAD&quot;
comma
r_new
op_member_access_from_pointer
id|object.sha1
comma
id|UNINTERESTING
)paren
suffix:semicolon
id|refs
op_assign
id|revs.pending
suffix:semicolon
id|revs.leak_pending
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|prepare_revision_walk
c_func
(paren
op_amp
id|revs
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;internal error in revision walk&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|old-&gt;object.flags
op_amp
id|UNINTERESTING
)paren
)paren
id|suggest_reattach
c_func
(paren
id|old
comma
op_amp
id|revs
)paren
suffix:semicolon
r_else
id|describe_detached_head
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Previous HEAD position was&quot;
)paren
comma
id|old
)paren
suffix:semicolon
id|clear_commit_marks_for_object_array
c_func
(paren
op_amp
id|refs
comma
id|ALL_REV_FLAGS
)paren
suffix:semicolon
id|free
c_func
(paren
id|refs.objects
)paren
suffix:semicolon
)brace
DECL|function|switch_branches
r_static
r_int
id|switch_branches
c_func
(paren
r_struct
id|checkout_opts
op_star
id|opts
comma
r_struct
id|branch_info
op_star
r_new
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_struct
id|branch_info
id|old
suffix:semicolon
r_void
op_star
id|path_to_free
suffix:semicolon
r_int
r_char
id|rev
(braket
l_int|20
)braket
suffix:semicolon
r_int
id|flag
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|old
comma
l_int|0
comma
r_sizeof
(paren
id|old
)paren
)paren
suffix:semicolon
id|old.path
op_assign
id|path_to_free
op_assign
id|resolve_refdup
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|rev
comma
l_int|0
comma
op_amp
id|flag
)paren
suffix:semicolon
id|old.commit
op_assign
id|lookup_commit_reference_gently
c_func
(paren
id|rev
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flag
op_amp
id|REF_ISSYMREF
)paren
)paren
id|old.path
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|old.path
op_logical_and
op_logical_neg
id|prefixcmp
c_func
(paren
id|old.path
comma
l_string|&quot;refs/heads/&quot;
)paren
)paren
id|old.name
op_assign
id|old.path
op_plus
id|strlen
c_func
(paren
l_string|&quot;refs/heads/&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
op_member_access_from_pointer
id|name
)paren
(brace
r_new
op_member_access_from_pointer
id|name
op_assign
l_string|&quot;HEAD&quot;
suffix:semicolon
r_new
op_member_access_from_pointer
id|commit
op_assign
id|old.commit
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
op_member_access_from_pointer
id|commit
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;You are on a branch yet to be born&quot;
)paren
)paren
suffix:semicolon
id|parse_commit
c_func
(paren
r_new
op_member_access_from_pointer
id|commit
)paren
suffix:semicolon
)brace
id|ret
op_assign
id|merge_working_tree
c_func
(paren
id|opts
comma
op_amp
id|old
comma
r_new
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|free
c_func
(paren
id|path_to_free
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|opts-&gt;quiet
op_logical_and
op_logical_neg
id|old.path
op_logical_and
id|old.commit
op_logical_and
r_new
op_member_access_from_pointer
id|commit
op_ne
id|old.commit
)paren
id|orphaned_commit_warning
c_func
(paren
id|old.commit
comma
r_new
op_member_access_from_pointer
id|commit
)paren
suffix:semicolon
id|update_refs_for_switch
c_func
(paren
id|opts
comma
op_amp
id|old
comma
r_new
)paren
suffix:semicolon
id|ret
op_assign
id|post_checkout_hook
c_func
(paren
id|old.commit
comma
r_new
op_member_access_from_pointer
id|commit
comma
l_int|1
)paren
suffix:semicolon
id|free
c_func
(paren
id|path_to_free
)paren
suffix:semicolon
r_return
id|ret
op_logical_or
id|opts-&gt;writeout_error
suffix:semicolon
)brace
DECL|function|git_checkout_config
r_static
r_int
id|git_checkout_config
c_func
(paren
r_const
r_char
op_star
id|var
comma
r_const
r_char
op_star
id|value
comma
r_void
op_star
id|cb
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;diff.ignoresubmodules&quot;
)paren
)paren
(brace
r_struct
id|checkout_opts
op_star
id|opts
op_assign
id|cb
suffix:semicolon
id|handle_ignore_submodules_arg
c_func
(paren
op_amp
id|opts-&gt;diff_options
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|var
comma
l_string|&quot;submodule.&quot;
)paren
)paren
r_return
id|parse_submodule_config_option
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
id|git_xmerge_config
c_func
(paren
id|var
comma
id|value
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|interactive_checkout
r_static
r_int
id|interactive_checkout
c_func
(paren
r_const
r_char
op_star
id|revision
comma
r_const
r_char
op_star
op_star
id|pathspec
comma
r_struct
id|checkout_opts
op_star
id|opts
)paren
(brace
r_return
id|run_add_interactive
c_func
(paren
id|revision
comma
l_string|&quot;--patch=checkout&quot;
comma
id|pathspec
)paren
suffix:semicolon
)brace
DECL|struct|tracking_name_data
r_struct
id|tracking_name_data
(brace
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
DECL|member|remote
r_char
op_star
id|remote
suffix:semicolon
DECL|member|unique
r_int
id|unique
suffix:semicolon
)brace
suffix:semicolon
DECL|function|check_tracking_name
r_static
r_int
id|check_tracking_name
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
id|flags
comma
r_void
op_star
id|cb_data
)paren
(brace
r_struct
id|tracking_name_data
op_star
id|cb
op_assign
id|cb_data
suffix:semicolon
r_const
r_char
op_star
id|slash
suffix:semicolon
r_if
c_cond
(paren
id|prefixcmp
c_func
(paren
id|refname
comma
l_string|&quot;refs/remotes/&quot;
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|slash
op_assign
id|strchr
c_func
(paren
id|refname
op_plus
l_int|13
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|slash
op_logical_or
id|strcmp
c_func
(paren
id|slash
op_plus
l_int|1
comma
id|cb-&gt;name
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cb-&gt;remote
)paren
(brace
id|cb-&gt;unique
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|cb-&gt;remote
op_assign
id|xstrdup
c_func
(paren
id|refname
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|unique_tracking_name
r_static
r_const
r_char
op_star
id|unique_tracking_name
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|tracking_name_data
id|cb_data
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|1
)brace
suffix:semicolon
id|cb_data.name
op_assign
id|name
suffix:semicolon
id|for_each_ref
c_func
(paren
id|check_tracking_name
comma
op_amp
id|cb_data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cb_data.unique
)paren
r_return
id|cb_data.remote
suffix:semicolon
id|free
c_func
(paren
id|cb_data.remote
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|parse_branchname_arg
r_static
r_int
id|parse_branchname_arg
c_func
(paren
r_int
id|argc
comma
r_const
r_char
op_star
op_star
id|argv
comma
r_int
id|dwim_new_local_branch_ok
comma
r_struct
id|branch_info
op_star
r_new
comma
r_struct
id|tree
op_star
op_star
id|source_tree
comma
r_int
r_char
id|rev
(braket
l_int|20
)braket
comma
r_const
r_char
op_star
op_star
id|new_branch
)paren
(brace
r_int
id|argcount
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|branch_rev
(braket
l_int|20
)braket
suffix:semicolon
r_const
r_char
op_star
id|arg
suffix:semicolon
r_int
id|has_dash_dash
suffix:semicolon
multiline_comment|/*&n;&t; * case 1: git checkout &lt;ref&gt; -- [&lt;paths&gt;]&n;&t; *&n;&t; *   &lt;ref&gt; must be a valid tree, everything after the &squot;--&squot; must be&n;&t; *   a path.&n;&t; *&n;&t; * case 2: git checkout -- [&lt;paths&gt;]&n;&t; *&n;&t; *   everything after the &squot;--&squot; must be paths.&n;&t; *&n;&t; * case 3: git checkout &lt;something&gt; [&lt;paths&gt;]&n;&t; *&n;&t; *   With no paths, if &lt;something&gt; is a commit, that is to&n;&t; *   switch to the branch or detach HEAD at it.  As a special case,&n;&t; *   if &lt;something&gt; is A...B (missing A or B means HEAD but you can&n;&t; *   omit at most one side), and if there is a unique merge base&n;&t; *   between A and B, A...B names that merge base.&n;&t; *&n;&t; *   With no paths, if &lt;something&gt; is _not_ a commit, no -t nor -b&n;&t; *   was given, and there is a tracking branch whose name is&n;&t; *   &lt;something&gt; in one and only one remote, then this is a short-hand&n;&t; *   to fork local &lt;something&gt; from that remote-tracking branch.&n;&t; *&n;&t; *   Otherwise &lt;something&gt; shall not be ambiguous.&n;&t; *   - If it&squot;s *only* a reference, treat it like case (1).&n;&t; *   - If it&squot;s only a path, treat it like case (2).&n;&t; *   - else: fail.&n;&t; *&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|argc
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|argv
(braket
l_int|0
)braket
comma
l_string|&quot;--&quot;
)paren
)paren
multiline_comment|/* case (2) */
r_return
l_int|1
suffix:semicolon
id|arg
op_assign
id|argv
(braket
l_int|0
)braket
suffix:semicolon
id|has_dash_dash
op_assign
(paren
id|argc
OG
l_int|1
)paren
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
l_string|&quot;--&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;-&quot;
)paren
)paren
id|arg
op_assign
l_string|&quot;@{-1}&quot;
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1_mb
c_func
(paren
id|arg
comma
id|rev
)paren
)paren
(brace
r_if
c_cond
(paren
id|has_dash_dash
)paren
multiline_comment|/* case (1) */
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;invalid reference: %s&quot;
)paren
comma
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dwim_new_local_branch_ok
op_logical_and
op_logical_neg
id|check_filename
c_func
(paren
l_int|NULL
comma
id|arg
)paren
op_logical_and
id|argc
op_eq
l_int|1
)paren
(brace
r_const
r_char
op_star
id|remote
op_assign
id|unique_tracking_name
c_func
(paren
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|remote
op_logical_or
id|get_sha1
c_func
(paren
id|remote
comma
id|rev
)paren
)paren
r_return
id|argcount
suffix:semicolon
op_star
id|new_branch
op_assign
id|arg
suffix:semicolon
id|arg
op_assign
id|remote
suffix:semicolon
multiline_comment|/* DWIMmed to create local branch */
)brace
r_else
(brace
r_return
id|argcount
suffix:semicolon
)brace
)brace
multiline_comment|/* we can&squot;t end up being in (2) anymore, eat the argument */
id|argcount
op_increment
suffix:semicolon
id|argv
op_increment
suffix:semicolon
id|argc
op_decrement
suffix:semicolon
r_new
op_member_access_from_pointer
id|name
op_assign
id|arg
suffix:semicolon
id|setup_branch_path
c_func
(paren
r_new
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|check_refname_format
c_func
(paren
r_new
op_member_access_from_pointer
id|path
comma
l_int|0
)paren
op_logical_and
op_logical_neg
id|read_ref
c_func
(paren
r_new
op_member_access_from_pointer
id|path
comma
id|branch_rev
)paren
)paren
id|hashcpy
c_func
(paren
id|rev
comma
id|branch_rev
)paren
suffix:semicolon
r_else
r_new
op_member_access_from_pointer
id|path
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* not an existing branch */
r_new
op_member_access_from_pointer
id|commit
op_assign
id|lookup_commit_reference_gently
c_func
(paren
id|rev
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
op_member_access_from_pointer
id|commit
)paren
(brace
multiline_comment|/* not a commit */
op_star
id|source_tree
op_assign
id|parse_tree_indirect
c_func
(paren
id|rev
)paren
suffix:semicolon
)brace
r_else
(brace
id|parse_commit
c_func
(paren
r_new
op_member_access_from_pointer
id|commit
)paren
suffix:semicolon
op_star
id|source_tree
op_assign
r_new
op_member_access_from_pointer
id|commit-&gt;tree
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|source_tree
)paren
multiline_comment|/* case (1): want a tree */
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;reference is not a tree: %s&quot;
)paren
comma
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|has_dash_dash
)paren
(brace
multiline_comment|/* case (3 -&gt; 1) */
multiline_comment|/*&n;&t;&t; * Do not complain the most common case&n;&t;&t; *&t;git checkout branch&n;&t;&t; * even if there happen to be a file called &squot;branch&squot;;&n;&t;&t; * it would be extremely annoying.&n;&t;&t; */
r_if
c_cond
(paren
id|argc
)paren
id|verify_non_filename
c_func
(paren
l_int|NULL
comma
id|arg
)paren
suffix:semicolon
)brace
r_else
(brace
id|argcount
op_increment
suffix:semicolon
id|argv
op_increment
suffix:semicolon
id|argc
op_decrement
suffix:semicolon
)brace
r_return
id|argcount
suffix:semicolon
)brace
DECL|function|switch_unborn_to_new_branch
r_static
r_int
id|switch_unborn_to_new_branch
c_func
(paren
r_struct
id|checkout_opts
op_star
id|opts
)paren
(brace
r_int
id|status
suffix:semicolon
r_struct
id|strbuf
id|branch_ref
op_assign
id|STRBUF_INIT
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
id|branch_ref
comma
l_string|&quot;refs/heads/%s&quot;
comma
id|opts-&gt;new_branch
)paren
suffix:semicolon
id|status
op_assign
id|create_symref
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|branch_ref.buf
comma
l_string|&quot;checkout -b&quot;
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|branch_ref
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
DECL|function|cmd_checkout
r_int
id|cmd_checkout
c_func
(paren
r_int
id|argc
comma
r_const
r_char
op_star
op_star
id|argv
comma
r_const
r_char
op_star
id|prefix
)paren
(brace
r_struct
id|checkout_opts
id|opts
suffix:semicolon
r_int
r_char
id|rev
(braket
l_int|20
)braket
suffix:semicolon
r_struct
id|branch_info
r_new
suffix:semicolon
r_struct
id|tree
op_star
id|source_tree
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
id|conflict_style
op_assign
l_int|NULL
suffix:semicolon
r_int
id|patch_mode
op_assign
l_int|0
suffix:semicolon
r_int
id|dwim_new_local_branch
op_assign
l_int|1
suffix:semicolon
r_struct
id|option
id|options
(braket
)braket
op_assign
(brace
id|OPT__QUIET
c_func
(paren
op_amp
id|opts.quiet
comma
l_string|&quot;suppress progress reporting&quot;
)paren
comma
id|OPT_STRING
c_func
(paren
l_char|&squot;b&squot;
comma
l_int|NULL
comma
op_amp
id|opts.new_branch
comma
l_string|&quot;branch&quot;
comma
l_string|&quot;create and checkout a new branch&quot;
)paren
comma
id|OPT_STRING
c_func
(paren
l_char|&squot;B&squot;
comma
l_int|NULL
comma
op_amp
id|opts.new_branch_force
comma
l_string|&quot;branch&quot;
comma
l_string|&quot;create/reset and checkout a branch&quot;
)paren
comma
id|OPT_BOOLEAN
c_func
(paren
l_char|&squot;l&squot;
comma
l_int|NULL
comma
op_amp
id|opts.new_branch_log
comma
l_string|&quot;create reflog for new branch&quot;
)paren
comma
id|OPT_BOOLEAN
c_func
(paren
l_int|0
comma
l_string|&quot;detach&quot;
comma
op_amp
id|opts.force_detach
comma
l_string|&quot;detach the HEAD at named commit&quot;
)paren
comma
id|OPT_SET_INT
c_func
(paren
l_char|&squot;t&squot;
comma
l_string|&quot;track&quot;
comma
op_amp
id|opts.track
comma
l_string|&quot;set upstream info for new branch&quot;
comma
id|BRANCH_TRACK_EXPLICIT
)paren
comma
id|OPT_STRING
c_func
(paren
l_int|0
comma
l_string|&quot;orphan&quot;
comma
op_amp
id|opts.new_orphan_branch
comma
l_string|&quot;new branch&quot;
comma
l_string|&quot;new unparented branch&quot;
)paren
comma
id|OPT_SET_INT
c_func
(paren
l_char|&squot;2&squot;
comma
l_string|&quot;ours&quot;
comma
op_amp
id|opts.writeout_stage
comma
l_string|&quot;checkout our version for unmerged files&quot;
comma
l_int|2
)paren
comma
id|OPT_SET_INT
c_func
(paren
l_char|&squot;3&squot;
comma
l_string|&quot;theirs&quot;
comma
op_amp
id|opts.writeout_stage
comma
l_string|&quot;checkout their version for unmerged files&quot;
comma
l_int|3
)paren
comma
id|OPT__FORCE
c_func
(paren
op_amp
id|opts.force
comma
l_string|&quot;force checkout (throw away local modifications)&quot;
)paren
comma
id|OPT_BOOLEAN
c_func
(paren
l_char|&squot;m&squot;
comma
l_string|&quot;merge&quot;
comma
op_amp
id|opts.merge
comma
l_string|&quot;perform a 3-way merge with the new branch&quot;
)paren
comma
id|OPT_BOOLEAN
c_func
(paren
l_int|0
comma
l_string|&quot;overwrite-ignore&quot;
comma
op_amp
id|opts.overwrite_ignore
comma
l_string|&quot;update ignored files (default)&quot;
)paren
comma
id|OPT_STRING
c_func
(paren
l_int|0
comma
l_string|&quot;conflict&quot;
comma
op_amp
id|conflict_style
comma
l_string|&quot;style&quot;
comma
l_string|&quot;conflict style (merge or diff3)&quot;
)paren
comma
id|OPT_BOOLEAN
c_func
(paren
l_char|&squot;p&squot;
comma
l_string|&quot;patch&quot;
comma
op_amp
id|patch_mode
comma
l_string|&quot;select hunks interactively&quot;
)paren
comma
(brace
id|OPTION_BOOLEAN
comma
l_int|0
comma
l_string|&quot;guess&quot;
comma
op_amp
id|dwim_new_local_branch
comma
l_int|NULL
comma
l_string|&quot;second guess &squot;git checkout no-such-branch&squot;&quot;
comma
id|PARSE_OPT_NOARG
op_or
id|PARSE_OPT_HIDDEN
)brace
comma
id|OPT_END
c_func
(paren
)paren
comma
)brace
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|opts
comma
l_int|0
comma
r_sizeof
(paren
id|opts
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
r_new
comma
l_int|0
comma
r_sizeof
(paren
r_new
)paren
)paren
suffix:semicolon
id|opts.overwrite_ignore
op_assign
l_int|1
suffix:semicolon
id|gitmodules_config
c_func
(paren
)paren
suffix:semicolon
id|git_config
c_func
(paren
id|git_checkout_config
comma
op_amp
id|opts
)paren
suffix:semicolon
id|opts.track
op_assign
id|BRANCH_TRACK_UNSPECIFIED
suffix:semicolon
id|argc
op_assign
id|parse_options
c_func
(paren
id|argc
comma
id|argv
comma
id|prefix
comma
id|options
comma
id|checkout_usage
comma
id|PARSE_OPT_KEEP_DASHDASH
)paren
suffix:semicolon
multiline_comment|/* we can assume from now on new_branch = !new_branch_force */
r_if
c_cond
(paren
id|opts.new_branch
op_logical_and
id|opts.new_branch_force
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;-B cannot be used with -b&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* copy -B over to -b, so that we can just check the latter */
r_if
c_cond
(paren
id|opts.new_branch_force
)paren
id|opts.new_branch
op_assign
id|opts.new_branch_force
suffix:semicolon
r_if
c_cond
(paren
id|patch_mode
op_logical_and
(paren
id|opts.track
OG
l_int|0
op_logical_or
id|opts.new_branch
op_logical_or
id|opts.new_branch_log
op_logical_or
id|opts.merge
op_logical_or
id|opts.force
op_logical_or
id|opts.force_detach
)paren
)paren
id|die
(paren
id|_
c_func
(paren
l_string|&quot;--patch is incompatible with all other options&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opts.force_detach
op_logical_and
(paren
id|opts.new_branch
op_logical_or
id|opts.new_orphan_branch
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;--detach cannot be used with -b/-B/--orphan&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opts.force_detach
op_logical_and
l_int|0
OL
id|opts.track
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;--detach cannot be used with -t&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* --track without -b should DWIM */
r_if
c_cond
(paren
l_int|0
OL
id|opts.track
op_logical_and
op_logical_neg
id|opts.new_branch
)paren
(brace
r_const
r_char
op_star
id|argv0
op_assign
id|argv
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|argc
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|argv0
comma
l_string|&quot;--&quot;
)paren
)paren
id|die
(paren
id|_
c_func
(paren
l_string|&quot;--track needs a branch name&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|argv0
comma
l_string|&quot;refs/&quot;
)paren
)paren
id|argv0
op_add_assign
l_int|5
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|argv0
comma
l_string|&quot;remotes/&quot;
)paren
)paren
id|argv0
op_add_assign
l_int|8
suffix:semicolon
id|argv0
op_assign
id|strchr
c_func
(paren
id|argv0
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|argv0
op_logical_or
op_logical_neg
id|argv0
(braket
l_int|1
)braket
)paren
id|die
(paren
id|_
c_func
(paren
l_string|&quot;Missing branch name; try -b&quot;
)paren
)paren
suffix:semicolon
id|opts.new_branch
op_assign
id|argv0
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|opts.new_orphan_branch
)paren
(brace
r_if
c_cond
(paren
id|opts.new_branch
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;--orphan and -b|-B are mutually exclusive&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opts.track
OG
l_int|0
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;--orphan cannot be used with -t&quot;
)paren
)paren
suffix:semicolon
id|opts.new_branch
op_assign
id|opts.new_orphan_branch
suffix:semicolon
)brace
r_if
c_cond
(paren
id|conflict_style
)paren
(brace
id|opts.merge
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* implied */
id|git_xmerge_config
c_func
(paren
l_string|&quot;merge.conflictstyle&quot;
comma
id|conflict_style
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|opts.force
op_logical_and
id|opts.merge
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;git checkout: -f and -m are incompatible&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Extract branch name from command line arguments, so&n;&t; * all that is left is pathspecs.&n;&t; *&n;&t; * Handle&n;&t; *&n;&t; *  1) git checkout &lt;tree&gt; -- [&lt;paths&gt;]&n;&t; *  2) git checkout -- [&lt;paths&gt;]&n;&t; *  3) git checkout &lt;something&gt; [&lt;paths&gt;]&n;&t; *&n;&t; * including &quot;last branch&quot; syntax and DWIM-ery for names of&n;&t; * remote branches, erroring out for invalid or ambiguous cases.&n;&t; */
r_if
c_cond
(paren
id|argc
)paren
(brace
r_int
id|dwim_ok
op_assign
op_logical_neg
id|patch_mode
op_logical_and
id|dwim_new_local_branch
op_logical_and
id|opts.track
op_eq
id|BRANCH_TRACK_UNSPECIFIED
op_logical_and
op_logical_neg
id|opts.new_branch
suffix:semicolon
r_int
id|n
op_assign
id|parse_branchname_arg
c_func
(paren
id|argc
comma
id|argv
comma
id|dwim_ok
comma
op_amp
r_new
comma
op_amp
id|source_tree
comma
id|rev
comma
op_amp
id|opts.new_branch
)paren
suffix:semicolon
id|argv
op_add_assign
id|n
suffix:semicolon
id|argc
op_sub_assign
id|n
suffix:semicolon
)brace
r_if
c_cond
(paren
id|opts.track
op_eq
id|BRANCH_TRACK_UNSPECIFIED
)paren
id|opts.track
op_assign
id|git_branch_track
suffix:semicolon
r_if
c_cond
(paren
id|argc
)paren
(brace
r_const
r_char
op_star
op_star
id|pathspec
op_assign
id|get_pathspec
c_func
(paren
id|prefix
comma
id|argv
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pathspec
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;invalid path specification&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|patch_mode
)paren
r_return
id|interactive_checkout
c_func
(paren
r_new
dot
id|name
comma
id|pathspec
comma
op_amp
id|opts
)paren
suffix:semicolon
multiline_comment|/* Checkout paths */
r_if
c_cond
(paren
id|opts.new_branch
)paren
(brace
r_if
c_cond
(paren
id|argc
op_eq
l_int|1
)paren
(brace
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;git checkout: updating paths is incompatible with switching branches.&bslash;nDid you intend to checkout &squot;%s&squot; which can not be resolved as commit?&quot;
)paren
comma
id|argv
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;git checkout: updating paths is incompatible with switching branches.&quot;
)paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|opts.force_detach
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;git checkout: --detach does not take a path argument&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|1
OL
op_logical_neg
op_logical_neg
id|opts.writeout_stage
op_plus
op_logical_neg
op_logical_neg
id|opts.force
op_plus
op_logical_neg
op_logical_neg
id|opts.merge
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;git checkout: --ours/--theirs, --force and --merge are incompatible when&bslash;nchecking out of the index.&quot;
)paren
)paren
suffix:semicolon
r_return
id|checkout_paths
c_func
(paren
id|source_tree
comma
id|pathspec
comma
id|prefix
comma
op_amp
id|opts
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|patch_mode
)paren
r_return
id|interactive_checkout
c_func
(paren
r_new
dot
id|name
comma
l_int|NULL
comma
op_amp
id|opts
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opts.new_branch
)paren
(brace
r_struct
id|strbuf
id|buf
op_assign
id|STRBUF_INIT
suffix:semicolon
id|opts.branch_exists
op_assign
id|validate_new_branchname
c_func
(paren
id|opts.new_branch
comma
op_amp
id|buf
comma
op_logical_neg
op_logical_neg
id|opts.new_branch_force
comma
op_logical_neg
op_logical_neg
id|opts.new_branch_force
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|buf
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
r_new
dot
id|name
op_logical_and
op_logical_neg
r_new
dot
id|commit
)paren
(brace
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Cannot switch branch to a non-commit.&quot;
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|opts.writeout_stage
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;--ours/--theirs is incompatible with switching branches.&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
dot
id|commit
op_logical_and
id|opts.new_branch
)paren
(brace
r_int
r_char
id|rev
(braket
l_int|20
)braket
suffix:semicolon
r_int
id|flag
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|read_ref_full
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|rev
comma
l_int|0
comma
op_amp
id|flag
)paren
op_logical_and
(paren
id|flag
op_amp
id|REF_ISSYMREF
)paren
op_logical_and
id|is_null_sha1
c_func
(paren
id|rev
)paren
)paren
r_return
id|switch_unborn_to_new_branch
c_func
(paren
op_amp
id|opts
)paren
suffix:semicolon
)brace
r_return
id|switch_branches
c_func
(paren
op_amp
id|opts
comma
op_amp
r_new
)paren
suffix:semicolon
)brace
eof
