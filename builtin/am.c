multiline_comment|/*&n; * Builtin &quot;git am&quot;&n; *&n; * Based on git-am.sh by Junio C Hamano.&n; */
macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;builtin.h&quot;
macro_line|#include &quot;exec_cmd.h&quot;
macro_line|#include &quot;parse-options.h&quot;
macro_line|#include &quot;dir.h&quot;
DECL|struct|am_state
r_struct
id|am_state
(brace
multiline_comment|/* state directory path */
DECL|member|dir
r_char
op_star
id|dir
suffix:semicolon
multiline_comment|/* current and last patch numbers, 1-indexed */
DECL|member|cur
r_int
id|cur
suffix:semicolon
DECL|member|last
r_int
id|last
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/**&n; * Initializes am_state with the default values. The state directory is set to&n; * dir.&n; */
DECL|function|am_state_init
r_static
r_void
id|am_state_init
c_func
(paren
r_struct
id|am_state
op_star
id|state
comma
r_const
r_char
op_star
id|dir
)paren
(brace
id|memset
c_func
(paren
id|state
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|state
)paren
)paren
suffix:semicolon
m_assert
(paren
id|dir
)paren
suffix:semicolon
id|state-&gt;dir
op_assign
id|xstrdup
c_func
(paren
id|dir
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Releases memory allocated by an am_state.&n; */
DECL|function|am_state_release
r_static
r_void
id|am_state_release
c_func
(paren
r_struct
id|am_state
op_star
id|state
)paren
(brace
id|free
c_func
(paren
id|state-&gt;dir
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Returns path relative to the am_state directory.&n; */
DECL|function|am_path
r_static
r_inline
r_const
r_char
op_star
id|am_path
c_func
(paren
r_const
r_struct
id|am_state
op_star
id|state
comma
r_const
r_char
op_star
id|path
)paren
(brace
r_return
id|mkpath
c_func
(paren
l_string|&quot;%s/%s&quot;
comma
id|state-&gt;dir
comma
id|path
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Returns 1 if there is an am session in progress, 0 otherwise.&n; */
DECL|function|am_in_progress
r_static
r_int
id|am_in_progress
c_func
(paren
r_const
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_struct
id|stat
id|st
suffix:semicolon
r_if
c_cond
(paren
id|lstat
c_func
(paren
id|state-&gt;dir
comma
op_amp
id|st
)paren
OL
l_int|0
op_logical_or
op_logical_neg
id|S_ISDIR
c_func
(paren
id|st.st_mode
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|lstat
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;last&quot;
)paren
comma
op_amp
id|st
)paren
op_logical_or
op_logical_neg
id|S_ISREG
c_func
(paren
id|st.st_mode
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|lstat
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;next&quot;
)paren
comma
op_amp
id|st
)paren
op_logical_or
op_logical_neg
id|S_ISREG
c_func
(paren
id|st.st_mode
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * Reads the contents of `file` in the `state` directory into `sb`. Returns the&n; * number of bytes read on success, -1 if the file does not exist. If `trim` is&n; * set, trailing whitespace will be removed.&n; */
DECL|function|read_state_file
r_static
r_int
id|read_state_file
c_func
(paren
r_struct
id|strbuf
op_star
id|sb
comma
r_const
r_struct
id|am_state
op_star
id|state
comma
r_const
r_char
op_star
id|file
comma
r_int
id|trim
)paren
(brace
id|strbuf_reset
c_func
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strbuf_read_file
c_func
(paren
id|sb
comma
id|am_path
c_func
(paren
id|state
comma
id|file
)paren
comma
l_int|0
)paren
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|trim
)paren
id|strbuf_trim
c_func
(paren
id|sb
)paren
suffix:semicolon
r_return
id|sb-&gt;len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|errno
op_eq
id|ENOENT
)paren
r_return
l_int|1
suffix:semicolon
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;could not read &squot;%s&squot;&quot;
)paren
comma
id|am_path
c_func
(paren
id|state
comma
id|file
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Loads state from disk.&n; */
DECL|function|am_load
r_static
r_void
id|am_load
c_func
(paren
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
r_if
c_cond
(paren
id|read_state_file
c_func
(paren
op_amp
id|sb
comma
id|state
comma
l_string|&quot;next&quot;
comma
l_int|1
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;BUG: state file &squot;next&squot; does not exist&quot;
)paren
suffix:semicolon
id|state-&gt;cur
op_assign
id|strtol
c_func
(paren
id|sb.buf
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_state_file
c_func
(paren
op_amp
id|sb
comma
id|state
comma
l_string|&quot;last&quot;
comma
l_int|1
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;BUG: state file &squot;last&squot; does not exist&quot;
)paren
suffix:semicolon
id|state-&gt;last
op_assign
id|strtol
c_func
(paren
id|sb.buf
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Removes the am_state directory, forcefully terminating the current am&n; * session.&n; */
DECL|function|am_destroy
r_static
r_void
id|am_destroy
c_func
(paren
r_const
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|sb
comma
id|state-&gt;dir
)paren
suffix:semicolon
id|remove_dir_recursively
c_func
(paren
op_amp
id|sb
comma
l_int|0
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Setup a new am session for applying patches&n; */
DECL|function|am_setup
r_static
r_void
id|am_setup
c_func
(paren
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_if
c_cond
(paren
id|mkdir
c_func
(paren
id|state-&gt;dir
comma
l_int|0777
)paren
OL
l_int|0
op_logical_and
id|errno
op_ne
id|EEXIST
)paren
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;failed to create directory &squot;%s&squot;&quot;
)paren
comma
id|state-&gt;dir
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * NOTE: Since the &quot;next&quot; and &quot;last&quot; files determine if an am_state&n;&t; * session is in progress, they should be written last.&n;&t; */
id|write_file
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;next&quot;
)paren
comma
l_int|1
comma
l_string|&quot;%d&quot;
comma
id|state-&gt;cur
)paren
suffix:semicolon
id|write_file
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;last&quot;
)paren
comma
l_int|1
comma
l_string|&quot;%d&quot;
comma
id|state-&gt;last
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Increments the patch pointer, and cleans am_state for the application of the&n; * next patch.&n; */
DECL|function|am_next
r_static
r_void
id|am_next
c_func
(paren
r_struct
id|am_state
op_star
id|state
)paren
(brace
id|state-&gt;cur
op_increment
suffix:semicolon
id|write_file
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;next&quot;
)paren
comma
l_int|1
comma
l_string|&quot;%d&quot;
comma
id|state-&gt;cur
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Applies all queued mail.&n; */
DECL|function|am_run
r_static
r_void
id|am_run
c_func
(paren
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_while
c_loop
(paren
id|state-&gt;cur
op_le
id|state-&gt;last
)paren
(brace
multiline_comment|/* NEEDSWORK: Patch application not implemented yet */
id|am_next
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
id|am_destroy
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
DECL|function|cmd_am
r_int
id|cmd_am
c_func
(paren
r_int
id|argc
comma
r_const
r_char
op_star
op_star
id|argv
comma
r_const
r_char
op_star
id|prefix
)paren
(brace
r_struct
id|am_state
id|state
suffix:semicolon
r_const
r_char
op_star
r_const
id|usage
(braket
)braket
op_assign
(brace
id|N_
c_func
(paren
l_string|&quot;git am [options] [(&lt;mbox&gt;|&lt;Maildir&gt;)...]&quot;
)paren
comma
l_int|NULL
)brace
suffix:semicolon
r_struct
id|option
id|options
(braket
)braket
op_assign
(brace
id|OPT_END
c_func
(paren
)paren
)brace
suffix:semicolon
multiline_comment|/*&n;&t; * NEEDSWORK: Once all the features of git-am.sh have been&n;&t; * re-implemented in builtin/am.c, this preamble can be removed.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|getenv
c_func
(paren
l_string|&quot;_GIT_USE_BUILTIN_AM&quot;
)paren
)paren
(brace
r_const
r_char
op_star
id|path
op_assign
id|mkpath
c_func
(paren
l_string|&quot;%s/git-am&quot;
comma
id|git_exec_path
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sane_execvp
c_func
(paren
id|path
comma
(paren
r_char
op_star
op_star
)paren
id|argv
)paren
OL
l_int|0
)paren
id|die_errno
c_func
(paren
l_string|&quot;could not exec %s&quot;
comma
id|path
)paren
suffix:semicolon
)brace
r_else
(brace
id|prefix
op_assign
id|setup_git_directory
c_func
(paren
)paren
suffix:semicolon
id|trace_repo_setup
c_func
(paren
id|prefix
)paren
suffix:semicolon
id|setup_work_tree
c_func
(paren
)paren
suffix:semicolon
)brace
id|git_config
c_func
(paren
id|git_default_config
comma
l_int|NULL
)paren
suffix:semicolon
id|am_state_init
c_func
(paren
op_amp
id|state
comma
id|git_path
c_func
(paren
l_string|&quot;rebase-apply&quot;
)paren
)paren
suffix:semicolon
id|argc
op_assign
id|parse_options
c_func
(paren
id|argc
comma
id|argv
comma
id|prefix
comma
id|options
comma
id|usage
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|am_in_progress
c_func
(paren
op_amp
id|state
)paren
)paren
id|am_load
c_func
(paren
op_amp
id|state
)paren
suffix:semicolon
r_else
id|am_setup
c_func
(paren
op_amp
id|state
)paren
suffix:semicolon
id|am_run
c_func
(paren
op_amp
id|state
)paren
suffix:semicolon
id|am_state_release
c_func
(paren
op_amp
id|state
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
