multiline_comment|/*&n; * Builtin &quot;git am&quot;&n; *&n; * Based on git-am.sh by Junio C Hamano.&n; */
macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;builtin.h&quot;
macro_line|#include &quot;exec_cmd.h&quot;
macro_line|#include &quot;parse-options.h&quot;
macro_line|#include &quot;dir.h&quot;
macro_line|#include &quot;run-command.h&quot;
DECL|enum|patch_format
r_enum
id|patch_format
(brace
DECL|enumerator|PATCH_FORMAT_UNKNOWN
id|PATCH_FORMAT_UNKNOWN
op_assign
l_int|0
comma
DECL|enumerator|PATCH_FORMAT_MBOX
id|PATCH_FORMAT_MBOX
)brace
suffix:semicolon
DECL|struct|am_state
r_struct
id|am_state
(brace
multiline_comment|/* state directory path */
DECL|member|dir
r_char
op_star
id|dir
suffix:semicolon
multiline_comment|/* current and last patch numbers, 1-indexed */
DECL|member|cur
r_int
id|cur
suffix:semicolon
DECL|member|last
r_int
id|last
suffix:semicolon
multiline_comment|/* number of digits in patch filename */
DECL|member|prec
r_int
id|prec
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/**&n; * Initializes am_state with the default values. The state directory is set to&n; * dir.&n; */
DECL|function|am_state_init
r_static
r_void
id|am_state_init
c_func
(paren
r_struct
id|am_state
op_star
id|state
comma
r_const
r_char
op_star
id|dir
)paren
(brace
id|memset
c_func
(paren
id|state
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|state
)paren
)paren
suffix:semicolon
m_assert
(paren
id|dir
)paren
suffix:semicolon
id|state-&gt;dir
op_assign
id|xstrdup
c_func
(paren
id|dir
)paren
suffix:semicolon
id|state-&gt;prec
op_assign
l_int|4
suffix:semicolon
)brace
multiline_comment|/**&n; * Releases memory allocated by an am_state.&n; */
DECL|function|am_state_release
r_static
r_void
id|am_state_release
c_func
(paren
r_struct
id|am_state
op_star
id|state
)paren
(brace
id|free
c_func
(paren
id|state-&gt;dir
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Returns path relative to the am_state directory.&n; */
DECL|function|am_path
r_static
r_inline
r_const
r_char
op_star
id|am_path
c_func
(paren
r_const
r_struct
id|am_state
op_star
id|state
comma
r_const
r_char
op_star
id|path
)paren
(brace
r_return
id|mkpath
c_func
(paren
l_string|&quot;%s/%s&quot;
comma
id|state-&gt;dir
comma
id|path
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Returns 1 if there is an am session in progress, 0 otherwise.&n; */
DECL|function|am_in_progress
r_static
r_int
id|am_in_progress
c_func
(paren
r_const
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_struct
id|stat
id|st
suffix:semicolon
r_if
c_cond
(paren
id|lstat
c_func
(paren
id|state-&gt;dir
comma
op_amp
id|st
)paren
OL
l_int|0
op_logical_or
op_logical_neg
id|S_ISDIR
c_func
(paren
id|st.st_mode
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|lstat
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;last&quot;
)paren
comma
op_amp
id|st
)paren
op_logical_or
op_logical_neg
id|S_ISREG
c_func
(paren
id|st.st_mode
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|lstat
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;next&quot;
)paren
comma
op_amp
id|st
)paren
op_logical_or
op_logical_neg
id|S_ISREG
c_func
(paren
id|st.st_mode
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * Reads the contents of `file` in the `state` directory into `sb`. Returns the&n; * number of bytes read on success, -1 if the file does not exist. If `trim` is&n; * set, trailing whitespace will be removed.&n; */
DECL|function|read_state_file
r_static
r_int
id|read_state_file
c_func
(paren
r_struct
id|strbuf
op_star
id|sb
comma
r_const
r_struct
id|am_state
op_star
id|state
comma
r_const
r_char
op_star
id|file
comma
r_int
id|trim
)paren
(brace
id|strbuf_reset
c_func
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strbuf_read_file
c_func
(paren
id|sb
comma
id|am_path
c_func
(paren
id|state
comma
id|file
)paren
comma
l_int|0
)paren
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|trim
)paren
id|strbuf_trim
c_func
(paren
id|sb
)paren
suffix:semicolon
r_return
id|sb-&gt;len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|errno
op_eq
id|ENOENT
)paren
r_return
l_int|1
suffix:semicolon
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;could not read &squot;%s&squot;&quot;
)paren
comma
id|am_path
c_func
(paren
id|state
comma
id|file
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Loads state from disk.&n; */
DECL|function|am_load
r_static
r_void
id|am_load
c_func
(paren
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
r_if
c_cond
(paren
id|read_state_file
c_func
(paren
op_amp
id|sb
comma
id|state
comma
l_string|&quot;next&quot;
comma
l_int|1
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;BUG: state file &squot;next&squot; does not exist&quot;
)paren
suffix:semicolon
id|state-&gt;cur
op_assign
id|strtol
c_func
(paren
id|sb.buf
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_state_file
c_func
(paren
op_amp
id|sb
comma
id|state
comma
l_string|&quot;last&quot;
comma
l_int|1
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;BUG: state file &squot;last&squot; does not exist&quot;
)paren
suffix:semicolon
id|state-&gt;last
op_assign
id|strtol
c_func
(paren
id|sb.buf
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Removes the am_state directory, forcefully terminating the current am&n; * session.&n; */
DECL|function|am_destroy
r_static
r_void
id|am_destroy
c_func
(paren
r_const
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|sb
comma
id|state-&gt;dir
)paren
suffix:semicolon
id|remove_dir_recursively
c_func
(paren
op_amp
id|sb
comma
l_int|0
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Splits out individual email patches from `paths`, where each path is either&n; * a mbox file or a Maildir. Returns 0 on success, -1 on failure.&n; */
DECL|function|split_mail_mbox
r_static
r_int
id|split_mail_mbox
c_func
(paren
r_struct
id|am_state
op_star
id|state
comma
r_const
r_char
op_star
op_star
id|paths
)paren
(brace
r_struct
id|child_process
id|cp
op_assign
id|CHILD_PROCESS_INIT
suffix:semicolon
r_struct
id|strbuf
id|last
op_assign
id|STRBUF_INIT
suffix:semicolon
id|cp.git_cmd
op_assign
l_int|1
suffix:semicolon
id|argv_array_push
c_func
(paren
op_amp
id|cp.args
comma
l_string|&quot;mailsplit&quot;
)paren
suffix:semicolon
id|argv_array_pushf
c_func
(paren
op_amp
id|cp.args
comma
l_string|&quot;-d%d&quot;
comma
id|state-&gt;prec
)paren
suffix:semicolon
id|argv_array_pushf
c_func
(paren
op_amp
id|cp.args
comma
l_string|&quot;-o%s&quot;
comma
id|state-&gt;dir
)paren
suffix:semicolon
id|argv_array_push
c_func
(paren
op_amp
id|cp.args
comma
l_string|&quot;-b&quot;
)paren
suffix:semicolon
id|argv_array_push
c_func
(paren
op_amp
id|cp.args
comma
l_string|&quot;--&quot;
)paren
suffix:semicolon
id|argv_array_pushv
c_func
(paren
op_amp
id|cp.args
comma
id|paths
)paren
suffix:semicolon
r_if
c_cond
(paren
id|capture_command
c_func
(paren
op_amp
id|cp
comma
op_amp
id|last
comma
l_int|8
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|state-&gt;cur
op_assign
l_int|1
suffix:semicolon
id|state-&gt;last
op_assign
id|strtol
c_func
(paren
id|last.buf
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * Splits a list of files/directories into individual email patches. Each path&n; * in `paths` must be a file/directory that is formatted according to&n; * `patch_format`.&n; *&n; * Once split out, the individual email patches will be stored in the state&n; * directory, with each patch&squot;s filename being its index, padded to state-&gt;prec&n; * digits.&n; *&n; * state-&gt;cur will be set to the index of the first mail, and state-&gt;last will&n; * be set to the index of the last mail.&n; *&n; * Returns 0 on success, -1 on failure.&n; */
DECL|function|split_mail
r_static
r_int
id|split_mail
c_func
(paren
r_struct
id|am_state
op_star
id|state
comma
r_enum
id|patch_format
id|patch_format
comma
r_const
r_char
op_star
op_star
id|paths
)paren
(brace
r_switch
c_cond
(paren
id|patch_format
)paren
(brace
r_case
id|PATCH_FORMAT_MBOX
suffix:colon
r_return
id|split_mail_mbox
c_func
(paren
id|state
comma
id|paths
)paren
suffix:semicolon
r_default
suffix:colon
id|die
c_func
(paren
l_string|&quot;BUG: invalid patch_format&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * Setup a new am session for applying patches&n; */
DECL|function|am_setup
r_static
r_void
id|am_setup
c_func
(paren
r_struct
id|am_state
op_star
id|state
comma
r_enum
id|patch_format
id|patch_format
comma
r_const
r_char
op_star
op_star
id|paths
)paren
(brace
r_if
c_cond
(paren
id|mkdir
c_func
(paren
id|state-&gt;dir
comma
l_int|0777
)paren
OL
l_int|0
op_logical_and
id|errno
op_ne
id|EEXIST
)paren
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;failed to create directory &squot;%s&squot;&quot;
)paren
comma
id|state-&gt;dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|split_mail
c_func
(paren
id|state
comma
id|patch_format
comma
id|paths
)paren
OL
l_int|0
)paren
(brace
id|am_destroy
c_func
(paren
id|state
)paren
suffix:semicolon
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Failed to split patches.&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * NOTE: Since the &quot;next&quot; and &quot;last&quot; files determine if an am_state&n;&t; * session is in progress, they should be written last.&n;&t; */
id|write_file
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;next&quot;
)paren
comma
l_int|1
comma
l_string|&quot;%d&quot;
comma
id|state-&gt;cur
)paren
suffix:semicolon
id|write_file
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;last&quot;
)paren
comma
l_int|1
comma
l_string|&quot;%d&quot;
comma
id|state-&gt;last
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Increments the patch pointer, and cleans am_state for the application of the&n; * next patch.&n; */
DECL|function|am_next
r_static
r_void
id|am_next
c_func
(paren
r_struct
id|am_state
op_star
id|state
)paren
(brace
id|state-&gt;cur
op_increment
suffix:semicolon
id|write_file
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;next&quot;
)paren
comma
l_int|1
comma
l_string|&quot;%d&quot;
comma
id|state-&gt;cur
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Applies all queued mail.&n; */
DECL|function|am_run
r_static
r_void
id|am_run
c_func
(paren
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_while
c_loop
(paren
id|state-&gt;cur
op_le
id|state-&gt;last
)paren
(brace
multiline_comment|/* NEEDSWORK: Patch application not implemented yet */
id|am_next
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
id|am_destroy
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * parse_options() callback that validates and sets opt-&gt;value to the&n; * PATCH_FORMAT_* enum value corresponding to `arg`.&n; */
DECL|function|parse_opt_patchformat
r_static
r_int
id|parse_opt_patchformat
c_func
(paren
r_const
r_struct
id|option
op_star
id|opt
comma
r_const
r_char
op_star
id|arg
comma
r_int
id|unset
)paren
(brace
r_int
op_star
id|opt_value
op_assign
id|opt-&gt;value
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;mbox&quot;
)paren
)paren
op_star
id|opt_value
op_assign
id|PATCH_FORMAT_MBOX
suffix:semicolon
r_else
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Invalid value for --patch-format: %s&quot;
)paren
comma
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cmd_am
r_int
id|cmd_am
c_func
(paren
r_int
id|argc
comma
r_const
r_char
op_star
op_star
id|argv
comma
r_const
r_char
op_star
id|prefix
)paren
(brace
r_struct
id|am_state
id|state
suffix:semicolon
r_int
id|patch_format
op_assign
id|PATCH_FORMAT_UNKNOWN
suffix:semicolon
r_const
r_char
op_star
r_const
id|usage
(braket
)braket
op_assign
(brace
id|N_
c_func
(paren
l_string|&quot;git am [options] [(&lt;mbox&gt;|&lt;Maildir&gt;)...]&quot;
)paren
comma
l_int|NULL
)brace
suffix:semicolon
r_struct
id|option
id|options
(braket
)braket
op_assign
(brace
id|OPT_CALLBACK
c_func
(paren
l_int|0
comma
l_string|&quot;patch-format&quot;
comma
op_amp
id|patch_format
comma
id|N_
c_func
(paren
l_string|&quot;format&quot;
)paren
comma
id|N_
c_func
(paren
l_string|&quot;format the patch(es) are in&quot;
)paren
comma
id|parse_opt_patchformat
)paren
comma
id|OPT_END
c_func
(paren
)paren
)brace
suffix:semicolon
multiline_comment|/*&n;&t; * NEEDSWORK: Once all the features of git-am.sh have been&n;&t; * re-implemented in builtin/am.c, this preamble can be removed.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|getenv
c_func
(paren
l_string|&quot;_GIT_USE_BUILTIN_AM&quot;
)paren
)paren
(brace
r_const
r_char
op_star
id|path
op_assign
id|mkpath
c_func
(paren
l_string|&quot;%s/git-am&quot;
comma
id|git_exec_path
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sane_execvp
c_func
(paren
id|path
comma
(paren
r_char
op_star
op_star
)paren
id|argv
)paren
OL
l_int|0
)paren
id|die_errno
c_func
(paren
l_string|&quot;could not exec %s&quot;
comma
id|path
)paren
suffix:semicolon
)brace
r_else
(brace
id|prefix
op_assign
id|setup_git_directory
c_func
(paren
)paren
suffix:semicolon
id|trace_repo_setup
c_func
(paren
id|prefix
)paren
suffix:semicolon
id|setup_work_tree
c_func
(paren
)paren
suffix:semicolon
)brace
id|git_config
c_func
(paren
id|git_default_config
comma
l_int|NULL
)paren
suffix:semicolon
id|am_state_init
c_func
(paren
op_amp
id|state
comma
id|git_path
c_func
(paren
l_string|&quot;rebase-apply&quot;
)paren
)paren
suffix:semicolon
id|argc
op_assign
id|parse_options
c_func
(paren
id|argc
comma
id|argv
comma
id|prefix
comma
id|options
comma
id|usage
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|am_in_progress
c_func
(paren
op_amp
id|state
)paren
)paren
id|am_load
c_func
(paren
op_amp
id|state
)paren
suffix:semicolon
r_else
(brace
r_struct
id|argv_array
id|paths
op_assign
id|ARGV_ARRAY_INIT
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|argc
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|is_absolute_path
c_func
(paren
id|argv
(braket
id|i
)braket
)paren
op_logical_or
op_logical_neg
id|prefix
)paren
id|argv_array_push
c_func
(paren
op_amp
id|paths
comma
id|argv
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|argv_array_push
c_func
(paren
op_amp
id|paths
comma
id|mkpath
c_func
(paren
l_string|&quot;%s/%s&quot;
comma
id|prefix
comma
id|argv
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
)brace
id|am_setup
c_func
(paren
op_amp
id|state
comma
id|patch_format
comma
id|paths.argv
)paren
suffix:semicolon
id|argv_array_clear
c_func
(paren
op_amp
id|paths
)paren
suffix:semicolon
)brace
id|am_run
c_func
(paren
op_amp
id|state
)paren
suffix:semicolon
id|am_state_release
c_func
(paren
op_amp
id|state
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
