multiline_comment|/*&n; * Builtin &quot;git am&quot;&n; *&n; * Based on git-am.sh by Junio C Hamano.&n; */
macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;builtin.h&quot;
macro_line|#include &quot;exec_cmd.h&quot;
macro_line|#include &quot;parse-options.h&quot;
macro_line|#include &quot;dir.h&quot;
macro_line|#include &quot;run-command.h&quot;
macro_line|#include &quot;quote.h&quot;
macro_line|#include &quot;lockfile.h&quot;
macro_line|#include &quot;cache-tree.h&quot;
macro_line|#include &quot;refs.h&quot;
macro_line|#include &quot;commit.h&quot;
macro_line|#include &quot;diff.h&quot;
macro_line|#include &quot;diffcore.h&quot;
macro_line|#include &quot;unpack-trees.h&quot;
macro_line|#include &quot;branch.h&quot;
macro_line|#include &quot;sequencer.h&quot;
macro_line|#include &quot;revision.h&quot;
macro_line|#include &quot;merge-recursive.h&quot;
macro_line|#include &quot;revision.h&quot;
macro_line|#include &quot;log-tree.h&quot;
macro_line|#include &quot;notes-utils.h&quot;
macro_line|#include &quot;rerere.h&quot;
multiline_comment|/**&n; * Returns 1 if the file is empty or does not exist, 0 otherwise.&n; */
DECL|function|is_empty_file
r_static
r_int
id|is_empty_file
c_func
(paren
r_const
r_char
op_star
id|filename
)paren
(brace
r_struct
id|stat
id|st
suffix:semicolon
r_if
c_cond
(paren
id|stat
c_func
(paren
id|filename
comma
op_amp
id|st
)paren
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|errno
op_eq
id|ENOENT
)paren
r_return
l_int|1
suffix:semicolon
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;could not stat %s&quot;
)paren
comma
id|filename
)paren
suffix:semicolon
)brace
r_return
op_logical_neg
id|st.st_size
suffix:semicolon
)brace
multiline_comment|/**&n; * Like strbuf_getline(), but treats both &squot;&bslash;n&squot; and &quot;&bslash;r&bslash;n&quot; as line terminators.&n; */
DECL|function|strbuf_getline_crlf
r_static
r_int
id|strbuf_getline_crlf
c_func
(paren
r_struct
id|strbuf
op_star
id|sb
comma
id|FILE
op_star
id|fp
)paren
(brace
r_if
c_cond
(paren
id|strbuf_getwholeline
c_func
(paren
id|sb
comma
id|fp
comma
l_char|&squot;&bslash;n&squot;
)paren
)paren
r_return
id|EOF
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;buf
(braket
id|sb-&gt;len
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|strbuf_setlen
c_func
(paren
id|sb
comma
id|sb-&gt;len
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;len
OG
l_int|0
op_logical_and
id|sb-&gt;buf
(braket
id|sb-&gt;len
l_int|1
)braket
op_eq
l_char|&squot;&bslash;r&squot;
)paren
id|strbuf_setlen
c_func
(paren
id|sb
comma
id|sb-&gt;len
l_int|1
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * Returns the length of the first line of msg.&n; */
DECL|function|linelen
r_static
r_int
id|linelen
c_func
(paren
r_const
r_char
op_star
id|msg
)paren
(brace
r_return
id|strchrnul
c_func
(paren
id|msg
comma
l_char|&squot;&bslash;n&squot;
)paren
id|msg
suffix:semicolon
)brace
multiline_comment|/**&n; * Returns true if `str` consists of only whitespace, false otherwise.&n; */
DECL|function|str_isspace
r_static
r_int
id|str_isspace
c_func
(paren
r_const
r_char
op_star
id|str
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
op_star
id|str
suffix:semicolon
id|str
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|isspace
c_func
(paren
op_star
id|str
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|enum|patch_format
r_enum
id|patch_format
(brace
DECL|enumerator|PATCH_FORMAT_UNKNOWN
id|PATCH_FORMAT_UNKNOWN
op_assign
l_int|0
comma
DECL|enumerator|PATCH_FORMAT_MBOX
id|PATCH_FORMAT_MBOX
comma
DECL|enumerator|PATCH_FORMAT_STGIT
id|PATCH_FORMAT_STGIT
)brace
suffix:semicolon
DECL|enum|keep_type
r_enum
id|keep_type
(brace
DECL|enumerator|KEEP_FALSE
id|KEEP_FALSE
op_assign
l_int|0
comma
DECL|enumerator|KEEP_TRUE
id|KEEP_TRUE
comma
multiline_comment|/* pass -k flag to git-mailinfo */
DECL|enumerator|KEEP_NON_PATCH
id|KEEP_NON_PATCH
multiline_comment|/* pass -b flag to git-mailinfo */
)brace
suffix:semicolon
DECL|enum|scissors_type
r_enum
id|scissors_type
(brace
DECL|enumerator|SCISSORS_UNSET
id|SCISSORS_UNSET
op_assign
l_int|1
comma
DECL|enumerator|SCISSORS_FALSE
id|SCISSORS_FALSE
op_assign
l_int|0
comma
multiline_comment|/* pass --no-scissors to git-mailinfo */
DECL|enumerator|SCISSORS_TRUE
id|SCISSORS_TRUE
multiline_comment|/* pass --scissors to git-mailinfo */
)brace
suffix:semicolon
DECL|struct|am_state
r_struct
id|am_state
(brace
multiline_comment|/* state directory path */
DECL|member|dir
r_char
op_star
id|dir
suffix:semicolon
multiline_comment|/* current and last patch numbers, 1-indexed */
DECL|member|cur
r_int
id|cur
suffix:semicolon
DECL|member|last
r_int
id|last
suffix:semicolon
multiline_comment|/* commit metadata and message */
DECL|member|author_name
r_char
op_star
id|author_name
suffix:semicolon
DECL|member|author_email
r_char
op_star
id|author_email
suffix:semicolon
DECL|member|author_date
r_char
op_star
id|author_date
suffix:semicolon
DECL|member|msg
r_char
op_star
id|msg
suffix:semicolon
DECL|member|msg_len
r_int
id|msg_len
suffix:semicolon
multiline_comment|/* when --rebasing, records the original commit the patch came from */
DECL|member|orig_commit
r_int
r_char
id|orig_commit
(braket
id|GIT_SHA1_RAWSZ
)braket
suffix:semicolon
multiline_comment|/* number of digits in patch filename */
DECL|member|prec
r_int
id|prec
suffix:semicolon
multiline_comment|/* various operating modes and command line options */
DECL|member|threeway
r_int
id|threeway
suffix:semicolon
DECL|member|quiet
r_int
id|quiet
suffix:semicolon
DECL|member|signoff
r_int
id|signoff
suffix:semicolon
DECL|member|utf8
r_int
id|utf8
suffix:semicolon
DECL|member|keep
r_int
id|keep
suffix:semicolon
multiline_comment|/* enum keep_type */
DECL|member|message_id
r_int
id|message_id
suffix:semicolon
DECL|member|scissors
r_int
id|scissors
suffix:semicolon
multiline_comment|/* enum scissors_type */
DECL|member|git_apply_opts
r_struct
id|argv_array
id|git_apply_opts
suffix:semicolon
DECL|member|resolvemsg
r_const
r_char
op_star
id|resolvemsg
suffix:semicolon
DECL|member|committer_date_is_author_date
r_int
id|committer_date_is_author_date
suffix:semicolon
DECL|member|ignore_date
r_int
id|ignore_date
suffix:semicolon
DECL|member|allow_rerere_autoupdate
r_int
id|allow_rerere_autoupdate
suffix:semicolon
DECL|member|sign_commit
r_const
r_char
op_star
id|sign_commit
suffix:semicolon
DECL|member|rebasing
r_int
id|rebasing
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/**&n; * Initializes am_state with the default values. The state directory is set to&n; * dir.&n; */
DECL|function|am_state_init
r_static
r_void
id|am_state_init
c_func
(paren
r_struct
id|am_state
op_star
id|state
comma
r_const
r_char
op_star
id|dir
)paren
(brace
r_int
id|gpgsign
suffix:semicolon
id|memset
c_func
(paren
id|state
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|state
)paren
)paren
suffix:semicolon
m_assert
(paren
id|dir
)paren
suffix:semicolon
id|state-&gt;dir
op_assign
id|xstrdup
c_func
(paren
id|dir
)paren
suffix:semicolon
id|state-&gt;prec
op_assign
l_int|4
suffix:semicolon
id|state-&gt;utf8
op_assign
l_int|1
suffix:semicolon
id|git_config_get_bool
c_func
(paren
l_string|&quot;am.messageid&quot;
comma
op_amp
id|state-&gt;message_id
)paren
suffix:semicolon
id|state-&gt;scissors
op_assign
id|SCISSORS_UNSET
suffix:semicolon
id|argv_array_init
c_func
(paren
op_amp
id|state-&gt;git_apply_opts
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|git_config_get_bool
c_func
(paren
l_string|&quot;commit.gpgsign&quot;
comma
op_amp
id|gpgsign
)paren
)paren
id|state-&gt;sign_commit
op_assign
id|gpgsign
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; * Releases memory allocated by an am_state.&n; */
DECL|function|am_state_release
r_static
r_void
id|am_state_release
c_func
(paren
r_struct
id|am_state
op_star
id|state
)paren
(brace
id|free
c_func
(paren
id|state-&gt;dir
)paren
suffix:semicolon
id|free
c_func
(paren
id|state-&gt;author_name
)paren
suffix:semicolon
id|free
c_func
(paren
id|state-&gt;author_email
)paren
suffix:semicolon
id|free
c_func
(paren
id|state-&gt;author_date
)paren
suffix:semicolon
id|free
c_func
(paren
id|state-&gt;msg
)paren
suffix:semicolon
id|argv_array_clear
c_func
(paren
op_amp
id|state-&gt;git_apply_opts
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Returns path relative to the am_state directory.&n; */
DECL|function|am_path
r_static
r_inline
r_const
r_char
op_star
id|am_path
c_func
(paren
r_const
r_struct
id|am_state
op_star
id|state
comma
r_const
r_char
op_star
id|path
)paren
(brace
r_return
id|mkpath
c_func
(paren
l_string|&quot;%s/%s&quot;
comma
id|state-&gt;dir
comma
id|path
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * If state-&gt;quiet is false, calls fprintf(fp, fmt, ...), and appends a newline&n; * at the end.&n; */
DECL|function|say
r_static
r_void
id|say
c_func
(paren
r_const
r_struct
id|am_state
op_star
id|state
comma
id|FILE
op_star
id|fp
comma
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
id|va_list
id|ap
suffix:semicolon
id|va_start
c_func
(paren
id|ap
comma
id|fmt
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|state-&gt;quiet
)paren
(brace
id|vfprintf
c_func
(paren
id|fp
comma
id|fmt
comma
id|ap
)paren
suffix:semicolon
id|putc
c_func
(paren
l_char|&squot;&bslash;n&squot;
comma
id|fp
)paren
suffix:semicolon
)brace
id|va_end
c_func
(paren
id|ap
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Returns 1 if there is an am session in progress, 0 otherwise.&n; */
DECL|function|am_in_progress
r_static
r_int
id|am_in_progress
c_func
(paren
r_const
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_struct
id|stat
id|st
suffix:semicolon
r_if
c_cond
(paren
id|lstat
c_func
(paren
id|state-&gt;dir
comma
op_amp
id|st
)paren
OL
l_int|0
op_logical_or
op_logical_neg
id|S_ISDIR
c_func
(paren
id|st.st_mode
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|lstat
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;last&quot;
)paren
comma
op_amp
id|st
)paren
op_logical_or
op_logical_neg
id|S_ISREG
c_func
(paren
id|st.st_mode
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|lstat
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;next&quot;
)paren
comma
op_amp
id|st
)paren
op_logical_or
op_logical_neg
id|S_ISREG
c_func
(paren
id|st.st_mode
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * Reads the contents of `file` in the `state` directory into `sb`. Returns the&n; * number of bytes read on success, -1 if the file does not exist. If `trim` is&n; * set, trailing whitespace will be removed.&n; */
DECL|function|read_state_file
r_static
r_int
id|read_state_file
c_func
(paren
r_struct
id|strbuf
op_star
id|sb
comma
r_const
r_struct
id|am_state
op_star
id|state
comma
r_const
r_char
op_star
id|file
comma
r_int
id|trim
)paren
(brace
id|strbuf_reset
c_func
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strbuf_read_file
c_func
(paren
id|sb
comma
id|am_path
c_func
(paren
id|state
comma
id|file
)paren
comma
l_int|0
)paren
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|trim
)paren
id|strbuf_trim
c_func
(paren
id|sb
)paren
suffix:semicolon
r_return
id|sb-&gt;len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|errno
op_eq
id|ENOENT
)paren
r_return
l_int|1
suffix:semicolon
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;could not read &squot;%s&squot;&quot;
)paren
comma
id|am_path
c_func
(paren
id|state
comma
id|file
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Reads a KEY=VALUE shell variable assignment from `fp`, returning the VALUE&n; * as a newly-allocated string. VALUE must be a quoted string, and the KEY must&n; * match `key`. Returns NULL on failure.&n; *&n; * This is used by read_author_script() to read the GIT_AUTHOR_* variables from&n; * the author-script.&n; */
DECL|function|read_shell_var
r_static
r_char
op_star
id|read_shell_var
c_func
(paren
id|FILE
op_star
id|fp
comma
r_const
r_char
op_star
id|key
)paren
(brace
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
r_const
r_char
op_star
id|str
suffix:semicolon
r_if
c_cond
(paren
id|strbuf_getline
c_func
(paren
op_amp
id|sb
comma
id|fp
comma
l_char|&squot;&bslash;n&squot;
)paren
)paren
r_goto
id|fail
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skip_prefix
c_func
(paren
id|sb.buf
comma
id|key
comma
op_amp
id|str
)paren
)paren
r_goto
id|fail
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skip_prefix
c_func
(paren
id|str
comma
l_string|&quot;=&quot;
comma
op_amp
id|str
)paren
)paren
r_goto
id|fail
suffix:semicolon
id|strbuf_remove
c_func
(paren
op_amp
id|sb
comma
l_int|0
comma
id|str
id|sb.buf
)paren
suffix:semicolon
id|str
op_assign
id|sq_dequote
c_func
(paren
id|sb.buf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|str
)paren
r_goto
id|fail
suffix:semicolon
r_return
id|strbuf_detach
c_func
(paren
op_amp
id|sb
comma
l_int|NULL
)paren
suffix:semicolon
id|fail
suffix:colon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; * Reads and parses the state directory&squot;s &quot;author-script&quot; file, and sets&n; * state-&gt;author_name, state-&gt;author_email and state-&gt;author_date accordingly.&n; * Returns 0 on success, -1 if the file could not be parsed.&n; *&n; * The author script is of the format:&n; *&n; *&t;GIT_AUTHOR_NAME=&squot;$author_name&squot;&n; *&t;GIT_AUTHOR_EMAIL=&squot;$author_email&squot;&n; *&t;GIT_AUTHOR_DATE=&squot;$author_date&squot;&n; *&n; * where $author_name, $author_email and $author_date are quoted. We are strict&n; * with our parsing, as the file was meant to be eval&squot;d in the old git-am.sh&n; * script, and thus if the file differs from what this function expects, it is&n; * better to bail out than to do something that the user does not expect.&n; */
DECL|function|read_author_script
r_static
r_int
id|read_author_script
c_func
(paren
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_const
r_char
op_star
id|filename
op_assign
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;author-script&quot;
)paren
suffix:semicolon
id|FILE
op_star
id|fp
suffix:semicolon
m_assert
(paren
op_logical_neg
id|state-&gt;author_name
)paren
suffix:semicolon
m_assert
(paren
op_logical_neg
id|state-&gt;author_email
)paren
suffix:semicolon
m_assert
(paren
op_logical_neg
id|state-&gt;author_date
)paren
suffix:semicolon
id|fp
op_assign
id|fopen
c_func
(paren
id|filename
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fp
)paren
(brace
r_if
c_cond
(paren
id|errno
op_eq
id|ENOENT
)paren
r_return
l_int|0
suffix:semicolon
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;could not open &squot;%s&squot; for reading&quot;
)paren
comma
id|filename
)paren
suffix:semicolon
)brace
id|state-&gt;author_name
op_assign
id|read_shell_var
c_func
(paren
id|fp
comma
l_string|&quot;GIT_AUTHOR_NAME&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|state-&gt;author_name
)paren
(brace
id|fclose
c_func
(paren
id|fp
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|state-&gt;author_email
op_assign
id|read_shell_var
c_func
(paren
id|fp
comma
l_string|&quot;GIT_AUTHOR_EMAIL&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|state-&gt;author_email
)paren
(brace
id|fclose
c_func
(paren
id|fp
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|state-&gt;author_date
op_assign
id|read_shell_var
c_func
(paren
id|fp
comma
l_string|&quot;GIT_AUTHOR_DATE&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|state-&gt;author_date
)paren
(brace
id|fclose
c_func
(paren
id|fp
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fgetc
c_func
(paren
id|fp
)paren
op_ne
id|EOF
)paren
(brace
id|fclose
c_func
(paren
id|fp
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|fclose
c_func
(paren
id|fp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * Saves state-&gt;author_name, state-&gt;author_email and state-&gt;author_date in the&n; * state directory&squot;s &quot;author-script&quot; file.&n; */
DECL|function|write_author_script
r_static
r_void
id|write_author_script
c_func
(paren
r_const
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|sb
comma
l_string|&quot;GIT_AUTHOR_NAME=&quot;
)paren
suffix:semicolon
id|sq_quote_buf
c_func
(paren
op_amp
id|sb
comma
id|state-&gt;author_name
)paren
suffix:semicolon
id|strbuf_addch
c_func
(paren
op_amp
id|sb
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|sb
comma
l_string|&quot;GIT_AUTHOR_EMAIL=&quot;
)paren
suffix:semicolon
id|sq_quote_buf
c_func
(paren
op_amp
id|sb
comma
id|state-&gt;author_email
)paren
suffix:semicolon
id|strbuf_addch
c_func
(paren
op_amp
id|sb
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|sb
comma
l_string|&quot;GIT_AUTHOR_DATE=&quot;
)paren
suffix:semicolon
id|sq_quote_buf
c_func
(paren
op_amp
id|sb
comma
id|state-&gt;author_date
)paren
suffix:semicolon
id|strbuf_addch
c_func
(paren
op_amp
id|sb
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|write_file
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;author-script&quot;
)paren
comma
l_int|1
comma
l_string|&quot;%s&quot;
comma
id|sb.buf
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Reads the commit message from the state directory&squot;s &quot;final-commit&quot; file,&n; * setting state-&gt;msg to its contents and state-&gt;msg_len to the length of its&n; * contents in bytes.&n; *&n; * Returns 0 on success, -1 if the file does not exist.&n; */
DECL|function|read_commit_msg
r_static
r_int
id|read_commit_msg
c_func
(paren
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
m_assert
(paren
op_logical_neg
id|state-&gt;msg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_state_file
c_func
(paren
op_amp
id|sb
comma
id|state
comma
l_string|&quot;final-commit&quot;
comma
l_int|0
)paren
OL
l_int|0
)paren
(brace
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|state-&gt;msg
op_assign
id|strbuf_detach
c_func
(paren
op_amp
id|sb
comma
op_amp
id|state-&gt;msg_len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * Saves state-&gt;msg in the state directory&squot;s &quot;final-commit&quot; file.&n; */
DECL|function|write_commit_msg
r_static
r_void
id|write_commit_msg
c_func
(paren
r_const
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_int
id|fd
suffix:semicolon
r_const
r_char
op_star
id|filename
op_assign
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;final-commit&quot;
)paren
suffix:semicolon
id|fd
op_assign
id|xopen
c_func
(paren
id|filename
comma
id|O_WRONLY
op_or
id|O_CREAT
comma
l_int|0666
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write_in_full
c_func
(paren
id|fd
comma
id|state-&gt;msg
comma
id|state-&gt;msg_len
)paren
OL
l_int|0
)paren
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;could not write to %s&quot;
)paren
comma
id|filename
)paren
suffix:semicolon
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Loads state from disk.&n; */
DECL|function|am_load
r_static
r_void
id|am_load
c_func
(paren
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
r_if
c_cond
(paren
id|read_state_file
c_func
(paren
op_amp
id|sb
comma
id|state
comma
l_string|&quot;next&quot;
comma
l_int|1
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;BUG: state file &squot;next&squot; does not exist&quot;
)paren
suffix:semicolon
id|state-&gt;cur
op_assign
id|strtol
c_func
(paren
id|sb.buf
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_state_file
c_func
(paren
op_amp
id|sb
comma
id|state
comma
l_string|&quot;last&quot;
comma
l_int|1
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;BUG: state file &squot;last&squot; does not exist&quot;
)paren
suffix:semicolon
id|state-&gt;last
op_assign
id|strtol
c_func
(paren
id|sb.buf
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_author_script
c_func
(paren
id|state
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;could not parse author script&quot;
)paren
)paren
suffix:semicolon
id|read_commit_msg
c_func
(paren
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_state_file
c_func
(paren
op_amp
id|sb
comma
id|state
comma
l_string|&quot;original-commit&quot;
comma
l_int|1
)paren
OL
l_int|0
)paren
id|hashclr
c_func
(paren
id|state-&gt;orig_commit
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|sb.buf
comma
id|state-&gt;orig_commit
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;could not parse %s&quot;
)paren
comma
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;original-commit&quot;
)paren
)paren
suffix:semicolon
id|read_state_file
c_func
(paren
op_amp
id|sb
comma
id|state
comma
l_string|&quot;threeway&quot;
comma
l_int|1
)paren
suffix:semicolon
id|state-&gt;threeway
op_assign
op_logical_neg
id|strcmp
c_func
(paren
id|sb.buf
comma
l_string|&quot;t&quot;
)paren
suffix:semicolon
id|read_state_file
c_func
(paren
op_amp
id|sb
comma
id|state
comma
l_string|&quot;quiet&quot;
comma
l_int|1
)paren
suffix:semicolon
id|state-&gt;quiet
op_assign
op_logical_neg
id|strcmp
c_func
(paren
id|sb.buf
comma
l_string|&quot;t&quot;
)paren
suffix:semicolon
id|read_state_file
c_func
(paren
op_amp
id|sb
comma
id|state
comma
l_string|&quot;sign&quot;
comma
l_int|1
)paren
suffix:semicolon
id|state-&gt;signoff
op_assign
op_logical_neg
id|strcmp
c_func
(paren
id|sb.buf
comma
l_string|&quot;t&quot;
)paren
suffix:semicolon
id|read_state_file
c_func
(paren
op_amp
id|sb
comma
id|state
comma
l_string|&quot;utf8&quot;
comma
l_int|1
)paren
suffix:semicolon
id|state-&gt;utf8
op_assign
op_logical_neg
id|strcmp
c_func
(paren
id|sb.buf
comma
l_string|&quot;t&quot;
)paren
suffix:semicolon
id|read_state_file
c_func
(paren
op_amp
id|sb
comma
id|state
comma
l_string|&quot;keep&quot;
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|sb.buf
comma
l_string|&quot;t&quot;
)paren
)paren
id|state-&gt;keep
op_assign
id|KEEP_TRUE
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|sb.buf
comma
l_string|&quot;b&quot;
)paren
)paren
id|state-&gt;keep
op_assign
id|KEEP_NON_PATCH
suffix:semicolon
r_else
id|state-&gt;keep
op_assign
id|KEEP_FALSE
suffix:semicolon
id|read_state_file
c_func
(paren
op_amp
id|sb
comma
id|state
comma
l_string|&quot;messageid&quot;
comma
l_int|1
)paren
suffix:semicolon
id|state-&gt;message_id
op_assign
op_logical_neg
id|strcmp
c_func
(paren
id|sb.buf
comma
l_string|&quot;t&quot;
)paren
suffix:semicolon
id|read_state_file
c_func
(paren
op_amp
id|sb
comma
id|state
comma
l_string|&quot;scissors&quot;
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|sb.buf
comma
l_string|&quot;t&quot;
)paren
)paren
id|state-&gt;scissors
op_assign
id|SCISSORS_TRUE
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|sb.buf
comma
l_string|&quot;f&quot;
)paren
)paren
id|state-&gt;scissors
op_assign
id|SCISSORS_FALSE
suffix:semicolon
r_else
id|state-&gt;scissors
op_assign
id|SCISSORS_UNSET
suffix:semicolon
id|read_state_file
c_func
(paren
op_amp
id|sb
comma
id|state
comma
l_string|&quot;apply-opt&quot;
comma
l_int|1
)paren
suffix:semicolon
id|argv_array_clear
c_func
(paren
op_amp
id|state-&gt;git_apply_opts
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sq_dequote_to_argv_array
c_func
(paren
id|sb.buf
comma
op_amp
id|state-&gt;git_apply_opts
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;could not parse %s&quot;
)paren
comma
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;apply-opt&quot;
)paren
)paren
suffix:semicolon
id|state-&gt;rebasing
op_assign
op_logical_neg
op_logical_neg
id|file_exists
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;rebasing&quot;
)paren
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Removes the am_state directory, forcefully terminating the current am&n; * session.&n; */
DECL|function|am_destroy
r_static
r_void
id|am_destroy
c_func
(paren
r_const
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|sb
comma
id|state-&gt;dir
)paren
suffix:semicolon
id|remove_dir_recursively
c_func
(paren
op_amp
id|sb
comma
l_int|0
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Runs applypatch-msg hook. Returns its exit code.&n; */
DECL|function|run_applypatch_msg_hook
r_static
r_int
id|run_applypatch_msg_hook
c_func
(paren
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_int
id|ret
suffix:semicolon
m_assert
(paren
id|state-&gt;msg
)paren
suffix:semicolon
id|ret
op_assign
id|run_hook_le
c_func
(paren
l_int|NULL
comma
l_string|&quot;applypatch-msg&quot;
comma
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;final-commit&quot;
)paren
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
id|free
c_func
(paren
id|state-&gt;msg
)paren
suffix:semicolon
id|state-&gt;msg
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|read_commit_msg
c_func
(paren
id|state
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;&squot;%s&squot; was deleted by the applypatch-msg hook&quot;
)paren
comma
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;final-commit&quot;
)paren
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; * Runs post-rewrite hook. Returns it exit code.&n; */
DECL|function|run_post_rewrite_hook
r_static
r_int
id|run_post_rewrite_hook
c_func
(paren
r_const
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_struct
id|child_process
id|cp
op_assign
id|CHILD_PROCESS_INIT
suffix:semicolon
r_const
r_char
op_star
id|hook
op_assign
id|find_hook
c_func
(paren
l_string|&quot;post-rewrite&quot;
)paren
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hook
)paren
r_return
l_int|0
suffix:semicolon
id|argv_array_push
c_func
(paren
op_amp
id|cp.args
comma
id|hook
)paren
suffix:semicolon
id|argv_array_push
c_func
(paren
op_amp
id|cp.args
comma
l_string|&quot;rebase&quot;
)paren
suffix:semicolon
id|cp.in
op_assign
id|xopen
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;rewritten&quot;
)paren
comma
id|O_RDONLY
)paren
suffix:semicolon
id|cp.stdout_to_stderr
op_assign
l_int|1
suffix:semicolon
id|ret
op_assign
id|run_command
c_func
(paren
op_amp
id|cp
)paren
suffix:semicolon
id|close
c_func
(paren
id|cp.in
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; * Reads the state directory&squot;s &quot;rewritten&quot; file, and copies notes from the old&n; * commits listed in the file to their rewritten commits.&n; *&n; * Returns 0 on success, -1 on failure.&n; */
DECL|function|copy_notes_for_rebase
r_static
r_int
id|copy_notes_for_rebase
c_func
(paren
r_const
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_struct
id|notes_rewrite_cfg
op_star
id|c
suffix:semicolon
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
r_const
r_char
op_star
id|invalid_line
op_assign
id|_
c_func
(paren
l_string|&quot;Malformed input line: &squot;%s&squot;.&quot;
)paren
suffix:semicolon
r_const
r_char
op_star
id|msg
op_assign
l_string|&quot;Notes added by &squot;git rebase&squot;&quot;
suffix:semicolon
id|FILE
op_star
id|fp
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
m_assert
(paren
id|state-&gt;rebasing
)paren
suffix:semicolon
id|c
op_assign
id|init_copy_notes_for_rewrite
c_func
(paren
l_string|&quot;rebase&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
r_return
l_int|0
suffix:semicolon
id|fp
op_assign
id|xfopen
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;rewritten&quot;
)paren
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|strbuf_getline
c_func
(paren
op_amp
id|sb
comma
id|fp
comma
l_char|&squot;&bslash;n&squot;
)paren
)paren
(brace
r_int
r_char
id|from_obj
(braket
id|GIT_SHA1_RAWSZ
)braket
comma
id|to_obj
(braket
id|GIT_SHA1_RAWSZ
)braket
suffix:semicolon
r_if
c_cond
(paren
id|sb.len
op_ne
id|GIT_SHA1_HEXSZ
op_star
l_int|2
op_plus
l_int|1
)paren
(brace
id|ret
op_assign
id|error
c_func
(paren
id|invalid_line
comma
id|sb.buf
)paren
suffix:semicolon
r_goto
id|finish
suffix:semicolon
)brace
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|sb.buf
comma
id|from_obj
)paren
)paren
(brace
id|ret
op_assign
id|error
c_func
(paren
id|invalid_line
comma
id|sb.buf
)paren
suffix:semicolon
r_goto
id|finish
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sb.buf
(braket
id|GIT_SHA1_HEXSZ
)braket
op_ne
l_char|&squot; &squot;
)paren
(brace
id|ret
op_assign
id|error
c_func
(paren
id|invalid_line
comma
id|sb.buf
)paren
suffix:semicolon
r_goto
id|finish
suffix:semicolon
)brace
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|sb.buf
op_plus
id|GIT_SHA1_HEXSZ
op_plus
l_int|1
comma
id|to_obj
)paren
)paren
(brace
id|ret
op_assign
id|error
c_func
(paren
id|invalid_line
comma
id|sb.buf
)paren
suffix:semicolon
r_goto
id|finish
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_note_for_rewrite
c_func
(paren
id|c
comma
id|from_obj
comma
id|to_obj
)paren
)paren
id|ret
op_assign
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Failed to copy notes from &squot;%s&squot; to &squot;%s&squot;&quot;
)paren
comma
id|sha1_to_hex
c_func
(paren
id|from_obj
)paren
comma
id|sha1_to_hex
c_func
(paren
id|to_obj
)paren
)paren
suffix:semicolon
)brace
id|finish
suffix:colon
id|finish_copy_notes_for_rewrite
c_func
(paren
id|c
comma
id|msg
)paren
suffix:semicolon
id|fclose
c_func
(paren
id|fp
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; * Determines if the file looks like a piece of RFC2822 mail by grabbing all&n; * non-indented lines and checking if they look like they begin with valid&n; * header field names.&n; *&n; * Returns 1 if the file looks like a piece of mail, 0 otherwise.&n; */
DECL|function|is_mail
r_static
r_int
id|is_mail
c_func
(paren
id|FILE
op_star
id|fp
)paren
(brace
r_const
r_char
op_star
id|header_regex
op_assign
l_string|&quot;^[!-9;-~]+:&quot;
suffix:semicolon
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
id|regex_t
id|regex
suffix:semicolon
r_int
id|ret
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|fseek
c_func
(paren
id|fp
comma
l_int|0L
comma
id|SEEK_SET
)paren
)paren
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;fseek failed&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|regcomp
c_func
(paren
op_amp
id|regex
comma
id|header_regex
comma
id|REG_NOSUB
op_or
id|REG_EXTENDED
)paren
)paren
id|die
c_func
(paren
l_string|&quot;invalid pattern: %s&quot;
comma
id|header_regex
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|strbuf_getline_crlf
c_func
(paren
op_amp
id|sb
comma
id|fp
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sb.len
)paren
r_break
suffix:semicolon
multiline_comment|/* End of header */
multiline_comment|/* Ignore indented folded lines */
r_if
c_cond
(paren
op_star
id|sb.buf
op_eq
l_char|&squot;&bslash;t&squot;
op_logical_or
op_star
id|sb.buf
op_eq
l_char|&squot; &squot;
)paren
r_continue
suffix:semicolon
multiline_comment|/* It&squot;s a header if it matches header_regex */
r_if
c_cond
(paren
id|regexec
c_func
(paren
op_amp
id|regex
comma
id|sb.buf
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
)paren
)paren
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
)brace
id|done
suffix:colon
id|regfree
c_func
(paren
op_amp
id|regex
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; * Attempts to detect the patch_format of the patches contained in `paths`,&n; * returning the PATCH_FORMAT_* enum value. Returns PATCH_FORMAT_UNKNOWN if&n; * detection fails.&n; */
DECL|function|detect_patch_format
r_static
r_int
id|detect_patch_format
c_func
(paren
r_const
r_char
op_star
op_star
id|paths
)paren
(brace
r_enum
id|patch_format
id|ret
op_assign
id|PATCH_FORMAT_UNKNOWN
suffix:semicolon
r_struct
id|strbuf
id|l1
op_assign
id|STRBUF_INIT
suffix:semicolon
r_struct
id|strbuf
id|l2
op_assign
id|STRBUF_INIT
suffix:semicolon
r_struct
id|strbuf
id|l3
op_assign
id|STRBUF_INIT
suffix:semicolon
id|FILE
op_star
id|fp
suffix:semicolon
multiline_comment|/*&n;&t; * We default to mbox format if input is from stdin and for directories&n;&t; */
r_if
c_cond
(paren
op_logical_neg
op_star
id|paths
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
op_star
id|paths
comma
l_string|&quot;-&quot;
)paren
op_logical_or
id|is_directory
c_func
(paren
op_star
id|paths
)paren
)paren
r_return
id|PATCH_FORMAT_MBOX
suffix:semicolon
multiline_comment|/*&n;&t; * Otherwise, check the first few lines of the first patch, starting&n;&t; * from the first non-blank line, to try to detect its format.&n;&t; */
id|fp
op_assign
id|xfopen
c_func
(paren
op_star
id|paths
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|strbuf_getline_crlf
c_func
(paren
op_amp
id|l1
comma
id|fp
)paren
)paren
(brace
r_if
c_cond
(paren
id|l1.len
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|l1.buf
comma
l_string|&quot;From &quot;
)paren
op_logical_or
id|starts_with
c_func
(paren
id|l1.buf
comma
l_string|&quot;From: &quot;
)paren
)paren
(brace
id|ret
op_assign
id|PATCH_FORMAT_MBOX
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|strbuf_reset
c_func
(paren
op_amp
id|l2
)paren
suffix:semicolon
id|strbuf_getline_crlf
c_func
(paren
op_amp
id|l2
comma
id|fp
)paren
suffix:semicolon
id|strbuf_reset
c_func
(paren
op_amp
id|l3
)paren
suffix:semicolon
id|strbuf_getline_crlf
c_func
(paren
op_amp
id|l3
comma
id|fp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the second line is empty and the third is a From, Author or Date&n;&t; * entry, this is likely an StGit patch.&n;&t; */
r_if
c_cond
(paren
id|l1.len
op_logical_and
op_logical_neg
id|l2.len
op_logical_and
(paren
id|starts_with
c_func
(paren
id|l3.buf
comma
l_string|&quot;From:&quot;
)paren
op_logical_or
id|starts_with
c_func
(paren
id|l3.buf
comma
l_string|&quot;Author:&quot;
)paren
op_logical_or
id|starts_with
c_func
(paren
id|l3.buf
comma
l_string|&quot;Date:&quot;
)paren
)paren
)paren
(brace
id|ret
op_assign
id|PATCH_FORMAT_STGIT
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_if
c_cond
(paren
id|l1.len
op_logical_and
id|is_mail
c_func
(paren
id|fp
)paren
)paren
(brace
id|ret
op_assign
id|PATCH_FORMAT_MBOX
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|done
suffix:colon
id|fclose
c_func
(paren
id|fp
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|l1
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; * Splits out individual email patches from `paths`, where each path is either&n; * a mbox file or a Maildir. Returns 0 on success, -1 on failure.&n; */
DECL|function|split_mail_mbox
r_static
r_int
id|split_mail_mbox
c_func
(paren
r_struct
id|am_state
op_star
id|state
comma
r_const
r_char
op_star
op_star
id|paths
comma
r_int
id|keep_cr
)paren
(brace
r_struct
id|child_process
id|cp
op_assign
id|CHILD_PROCESS_INIT
suffix:semicolon
r_struct
id|strbuf
id|last
op_assign
id|STRBUF_INIT
suffix:semicolon
id|cp.git_cmd
op_assign
l_int|1
suffix:semicolon
id|argv_array_push
c_func
(paren
op_amp
id|cp.args
comma
l_string|&quot;mailsplit&quot;
)paren
suffix:semicolon
id|argv_array_pushf
c_func
(paren
op_amp
id|cp.args
comma
l_string|&quot;-d%d&quot;
comma
id|state-&gt;prec
)paren
suffix:semicolon
id|argv_array_pushf
c_func
(paren
op_amp
id|cp.args
comma
l_string|&quot;-o%s&quot;
comma
id|state-&gt;dir
)paren
suffix:semicolon
id|argv_array_push
c_func
(paren
op_amp
id|cp.args
comma
l_string|&quot;-b&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|keep_cr
)paren
id|argv_array_push
c_func
(paren
op_amp
id|cp.args
comma
l_string|&quot;--keep-cr&quot;
)paren
suffix:semicolon
id|argv_array_push
c_func
(paren
op_amp
id|cp.args
comma
l_string|&quot;--&quot;
)paren
suffix:semicolon
id|argv_array_pushv
c_func
(paren
op_amp
id|cp.args
comma
id|paths
)paren
suffix:semicolon
r_if
c_cond
(paren
id|capture_command
c_func
(paren
op_amp
id|cp
comma
op_amp
id|last
comma
l_int|8
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|state-&gt;cur
op_assign
l_int|1
suffix:semicolon
id|state-&gt;last
op_assign
id|strtol
c_func
(paren
id|last.buf
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * Callback signature for split_mail_conv(). The foreign patch should be&n; * read from `in`, and the converted patch (in RFC2822 mail format) should be&n; * written to `out`. Return 0 on success, or -1 on failure.&n; */
DECL|typedef|mail_conv_fn
r_typedef
r_int
(paren
op_star
id|mail_conv_fn
)paren
(paren
id|FILE
op_star
id|out
comma
id|FILE
op_star
id|in
comma
r_int
id|keep_cr
)paren
suffix:semicolon
multiline_comment|/**&n; * Calls `fn` for each file in `paths` to convert the foreign patch to the&n; * RFC2822 mail format suitable for parsing with git-mailinfo.&n; *&n; * Returns 0 on success, -1 on failure.&n; */
DECL|function|split_mail_conv
r_static
r_int
id|split_mail_conv
c_func
(paren
id|mail_conv_fn
id|fn
comma
r_struct
id|am_state
op_star
id|state
comma
r_const
r_char
op_star
op_star
id|paths
comma
r_int
id|keep_cr
)paren
(brace
r_static
r_const
r_char
op_star
id|stdin_only
(braket
)braket
op_assign
(brace
l_string|&quot;-&quot;
comma
l_int|NULL
)brace
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|paths
)paren
id|paths
op_assign
id|stdin_only
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
op_star
id|paths
suffix:semicolon
id|paths
op_increment
comma
id|i
op_increment
)paren
(brace
id|FILE
op_star
id|in
comma
op_star
id|out
suffix:semicolon
r_const
r_char
op_star
id|mail
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
op_star
id|paths
comma
l_string|&quot;-&quot;
)paren
)paren
id|in
op_assign
id|stdin
suffix:semicolon
r_else
id|in
op_assign
id|fopen
c_func
(paren
op_star
id|paths
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|in
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;could not open &squot;%s&squot; for reading: %s&quot;
)paren
comma
op_star
id|paths
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
id|mail
op_assign
id|mkpath
c_func
(paren
l_string|&quot;%s/%0*d&quot;
comma
id|state-&gt;dir
comma
id|state-&gt;prec
comma
id|i
op_plus
l_int|1
)paren
suffix:semicolon
id|out
op_assign
id|fopen
c_func
(paren
id|mail
comma
l_string|&quot;w&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|out
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;could not open &squot;%s&squot; for writing: %s&quot;
)paren
comma
id|mail
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|fn
c_func
(paren
id|out
comma
id|in
comma
id|keep_cr
)paren
suffix:semicolon
id|fclose
c_func
(paren
id|out
)paren
suffix:semicolon
id|fclose
c_func
(paren
id|in
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;could not parse patch &squot;%s&squot;&quot;
)paren
comma
op_star
id|paths
)paren
suffix:semicolon
)brace
id|state-&gt;cur
op_assign
l_int|1
suffix:semicolon
id|state-&gt;last
op_assign
id|i
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * A split_mail_conv() callback that converts an StGit patch to an RFC2822&n; * message suitable for parsing with git-mailinfo.&n; */
DECL|function|stgit_patch_to_mail
r_static
r_int
id|stgit_patch_to_mail
c_func
(paren
id|FILE
op_star
id|out
comma
id|FILE
op_star
id|in
comma
r_int
id|keep_cr
)paren
(brace
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|subject_printed
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|strbuf_getline
c_func
(paren
op_amp
id|sb
comma
id|in
comma
l_char|&squot;&bslash;n&squot;
)paren
)paren
(brace
r_const
r_char
op_star
id|str
suffix:semicolon
r_if
c_cond
(paren
id|str_isspace
c_func
(paren
id|sb.buf
)paren
)paren
r_continue
suffix:semicolon
r_else
r_if
c_cond
(paren
id|skip_prefix
c_func
(paren
id|sb.buf
comma
l_string|&quot;Author:&quot;
comma
op_amp
id|str
)paren
)paren
id|fprintf
c_func
(paren
id|out
comma
l_string|&quot;From:%s&bslash;n&quot;
comma
id|str
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|sb.buf
comma
l_string|&quot;From&quot;
)paren
op_logical_or
id|starts_with
c_func
(paren
id|sb.buf
comma
l_string|&quot;Date&quot;
)paren
)paren
id|fprintf
c_func
(paren
id|out
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|sb.buf
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|subject_printed
)paren
(brace
id|fprintf
c_func
(paren
id|out
comma
l_string|&quot;Subject: %s&bslash;n&quot;
comma
id|sb.buf
)paren
suffix:semicolon
id|subject_printed
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|fprintf
c_func
(paren
id|out
comma
l_string|&quot;&bslash;n%s&bslash;n&quot;
comma
id|sb.buf
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|strbuf_reset
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
r_while
c_loop
(paren
id|strbuf_fread
c_func
(paren
op_amp
id|sb
comma
l_int|8192
comma
id|in
)paren
OG
l_int|0
)paren
(brace
id|fwrite
c_func
(paren
id|sb.buf
comma
l_int|1
comma
id|sb.len
comma
id|out
)paren
suffix:semicolon
id|strbuf_reset
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
)brace
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * Splits a list of files/directories into individual email patches. Each path&n; * in `paths` must be a file/directory that is formatted according to&n; * `patch_format`.&n; *&n; * Once split out, the individual email patches will be stored in the state&n; * directory, with each patch&squot;s filename being its index, padded to state-&gt;prec&n; * digits.&n; *&n; * state-&gt;cur will be set to the index of the first mail, and state-&gt;last will&n; * be set to the index of the last mail.&n; *&n; * Set keep_cr to 0 to convert all lines ending with &bslash;r&bslash;n to end with &bslash;n, 1&n; * to disable this behavior, -1 to use the default configured setting.&n; *&n; * Returns 0 on success, -1 on failure.&n; */
DECL|function|split_mail
r_static
r_int
id|split_mail
c_func
(paren
r_struct
id|am_state
op_star
id|state
comma
r_enum
id|patch_format
id|patch_format
comma
r_const
r_char
op_star
op_star
id|paths
comma
r_int
id|keep_cr
)paren
(brace
r_if
c_cond
(paren
id|keep_cr
OL
l_int|0
)paren
(brace
id|keep_cr
op_assign
l_int|0
suffix:semicolon
id|git_config_get_bool
c_func
(paren
l_string|&quot;am.keepcr&quot;
comma
op_amp
id|keep_cr
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|patch_format
)paren
(brace
r_case
id|PATCH_FORMAT_MBOX
suffix:colon
r_return
id|split_mail_mbox
c_func
(paren
id|state
comma
id|paths
comma
id|keep_cr
)paren
suffix:semicolon
r_case
id|PATCH_FORMAT_STGIT
suffix:colon
r_return
id|split_mail_conv
c_func
(paren
id|stgit_patch_to_mail
comma
id|state
comma
id|paths
comma
id|keep_cr
)paren
suffix:semicolon
r_default
suffix:colon
id|die
c_func
(paren
l_string|&quot;BUG: invalid patch_format&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * Setup a new am session for applying patches&n; */
DECL|function|am_setup
r_static
r_void
id|am_setup
c_func
(paren
r_struct
id|am_state
op_star
id|state
comma
r_enum
id|patch_format
id|patch_format
comma
r_const
r_char
op_star
op_star
id|paths
comma
r_int
id|keep_cr
)paren
(brace
r_int
r_char
id|curr_head
(braket
id|GIT_SHA1_RAWSZ
)braket
suffix:semicolon
r_const
r_char
op_star
id|str
suffix:semicolon
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|patch_format
)paren
id|patch_format
op_assign
id|detect_patch_format
c_func
(paren
id|paths
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|patch_format
)paren
(brace
id|fprintf_ln
c_func
(paren
id|stderr
comma
id|_
c_func
(paren
l_string|&quot;Patch format detection failed.&quot;
)paren
)paren
suffix:semicolon
m_exit
(paren
l_int|128
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mkdir
c_func
(paren
id|state-&gt;dir
comma
l_int|0777
)paren
OL
l_int|0
op_logical_and
id|errno
op_ne
id|EEXIST
)paren
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;failed to create directory &squot;%s&squot;&quot;
)paren
comma
id|state-&gt;dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|split_mail
c_func
(paren
id|state
comma
id|patch_format
comma
id|paths
comma
id|keep_cr
)paren
OL
l_int|0
)paren
(brace
id|am_destroy
c_func
(paren
id|state
)paren
suffix:semicolon
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Failed to split patches.&quot;
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|state-&gt;rebasing
)paren
id|state-&gt;threeway
op_assign
l_int|1
suffix:semicolon
id|write_file
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;threeway&quot;
)paren
comma
l_int|1
comma
id|state-&gt;threeway
ques
c_cond
l_string|&quot;t&quot;
suffix:colon
l_string|&quot;f&quot;
)paren
suffix:semicolon
id|write_file
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;quiet&quot;
)paren
comma
l_int|1
comma
id|state-&gt;quiet
ques
c_cond
l_string|&quot;t&quot;
suffix:colon
l_string|&quot;f&quot;
)paren
suffix:semicolon
id|write_file
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;sign&quot;
)paren
comma
l_int|1
comma
id|state-&gt;signoff
ques
c_cond
l_string|&quot;t&quot;
suffix:colon
l_string|&quot;f&quot;
)paren
suffix:semicolon
id|write_file
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;utf8&quot;
)paren
comma
l_int|1
comma
id|state-&gt;utf8
ques
c_cond
l_string|&quot;t&quot;
suffix:colon
l_string|&quot;f&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|state-&gt;keep
)paren
(brace
r_case
id|KEEP_FALSE
suffix:colon
id|str
op_assign
l_string|&quot;f&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|KEEP_TRUE
suffix:colon
id|str
op_assign
l_string|&quot;t&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|KEEP_NON_PATCH
suffix:colon
id|str
op_assign
l_string|&quot;b&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|die
c_func
(paren
l_string|&quot;BUG: invalid value for state-&gt;keep&quot;
)paren
suffix:semicolon
)brace
id|write_file
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;keep&quot;
)paren
comma
l_int|1
comma
l_string|&quot;%s&quot;
comma
id|str
)paren
suffix:semicolon
id|write_file
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;messageid&quot;
)paren
comma
l_int|1
comma
id|state-&gt;message_id
ques
c_cond
l_string|&quot;t&quot;
suffix:colon
l_string|&quot;f&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|state-&gt;scissors
)paren
(brace
r_case
id|SCISSORS_UNSET
suffix:colon
id|str
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCISSORS_FALSE
suffix:colon
id|str
op_assign
l_string|&quot;f&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCISSORS_TRUE
suffix:colon
id|str
op_assign
l_string|&quot;t&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|die
c_func
(paren
l_string|&quot;BUG: invalid value for state-&gt;scissors&quot;
)paren
suffix:semicolon
)brace
id|write_file
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;scissors&quot;
)paren
comma
l_int|1
comma
l_string|&quot;%s&quot;
comma
id|str
)paren
suffix:semicolon
id|sq_quote_argv
c_func
(paren
op_amp
id|sb
comma
id|state-&gt;git_apply_opts.argv
comma
l_int|0
)paren
suffix:semicolon
id|write_file
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;apply-opt&quot;
)paren
comma
l_int|1
comma
l_string|&quot;%s&quot;
comma
id|sb.buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;rebasing
)paren
id|write_file
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;rebasing&quot;
)paren
comma
l_int|1
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
r_else
id|write_file
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;applying&quot;
)paren
comma
l_int|1
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|get_sha1
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|curr_head
)paren
)paren
(brace
id|write_file
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;abort-safety&quot;
)paren
comma
l_int|1
comma
l_string|&quot;%s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|curr_head
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|state-&gt;rebasing
)paren
id|update_ref
c_func
(paren
l_string|&quot;am&quot;
comma
l_string|&quot;ORIG_HEAD&quot;
comma
id|curr_head
comma
l_int|NULL
comma
l_int|0
comma
id|UPDATE_REFS_DIE_ON_ERR
)paren
suffix:semicolon
)brace
r_else
(brace
id|write_file
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;abort-safety&quot;
)paren
comma
l_int|1
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|state-&gt;rebasing
)paren
id|delete_ref
c_func
(paren
l_string|&quot;ORIG_HEAD&quot;
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * NOTE: Since the &quot;next&quot; and &quot;last&quot; files determine if an am_state&n;&t; * session is in progress, they should be written last.&n;&t; */
id|write_file
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;next&quot;
)paren
comma
l_int|1
comma
l_string|&quot;%d&quot;
comma
id|state-&gt;cur
)paren
suffix:semicolon
id|write_file
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;last&quot;
)paren
comma
l_int|1
comma
l_string|&quot;%d&quot;
comma
id|state-&gt;last
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Increments the patch pointer, and cleans am_state for the application of the&n; * next patch.&n; */
DECL|function|am_next
r_static
r_void
id|am_next
c_func
(paren
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_int
r_char
id|head
(braket
id|GIT_SHA1_RAWSZ
)braket
suffix:semicolon
id|free
c_func
(paren
id|state-&gt;author_name
)paren
suffix:semicolon
id|state-&gt;author_name
op_assign
l_int|NULL
suffix:semicolon
id|free
c_func
(paren
id|state-&gt;author_email
)paren
suffix:semicolon
id|state-&gt;author_email
op_assign
l_int|NULL
suffix:semicolon
id|free
c_func
(paren
id|state-&gt;author_date
)paren
suffix:semicolon
id|state-&gt;author_date
op_assign
l_int|NULL
suffix:semicolon
id|free
c_func
(paren
id|state-&gt;msg
)paren
suffix:semicolon
id|state-&gt;msg
op_assign
l_int|NULL
suffix:semicolon
id|state-&gt;msg_len
op_assign
l_int|0
suffix:semicolon
id|unlink
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;author-script&quot;
)paren
)paren
suffix:semicolon
id|unlink
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;final-commit&quot;
)paren
)paren
suffix:semicolon
id|hashclr
c_func
(paren
id|state-&gt;orig_commit
)paren
suffix:semicolon
id|unlink
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;original-commit&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|get_sha1
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|head
)paren
)paren
id|write_file
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;abort-safety&quot;
)paren
comma
l_int|1
comma
l_string|&quot;%s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|head
)paren
)paren
suffix:semicolon
r_else
id|write_file
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;abort-safety&quot;
)paren
comma
l_int|1
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
id|state-&gt;cur
op_increment
suffix:semicolon
id|write_file
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;next&quot;
)paren
comma
l_int|1
comma
l_string|&quot;%d&quot;
comma
id|state-&gt;cur
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Returns the filename of the current patch email.&n; */
DECL|function|msgnum
r_static
r_const
r_char
op_star
id|msgnum
c_func
(paren
r_const
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_static
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
id|strbuf_reset
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
id|sb
comma
l_string|&quot;%0*d&quot;
comma
id|state-&gt;prec
comma
id|state-&gt;cur
)paren
suffix:semicolon
r_return
id|sb.buf
suffix:semicolon
)brace
multiline_comment|/**&n; * Refresh and write index.&n; */
DECL|function|refresh_and_write_cache
r_static
r_void
id|refresh_and_write_cache
c_func
(paren
r_void
)paren
(brace
r_struct
id|lock_file
op_star
id|lock_file
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|lock_file
)paren
)paren
suffix:semicolon
id|hold_locked_index
c_func
(paren
id|lock_file
comma
l_int|1
)paren
suffix:semicolon
id|refresh_cache
c_func
(paren
id|REFRESH_QUIET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write_locked_index
c_func
(paren
op_amp
id|the_index
comma
id|lock_file
comma
id|COMMIT_LOCK
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;unable to write index file&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Returns 1 if the index differs from HEAD, 0 otherwise. When on an unborn&n; * branch, returns 1 if there are entries in the index, 0 otherwise. If an&n; * strbuf is provided, the space-separated list of files that differ will be&n; * appended to it.&n; */
DECL|function|index_has_changes
r_static
r_int
id|index_has_changes
c_func
(paren
r_struct
id|strbuf
op_star
id|sb
)paren
(brace
r_int
r_char
id|head
(braket
id|GIT_SHA1_RAWSZ
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|get_sha1_tree
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|head
)paren
)paren
(brace
r_struct
id|diff_options
id|opt
suffix:semicolon
id|diff_setup
c_func
(paren
op_amp
id|opt
)paren
suffix:semicolon
id|DIFF_OPT_SET
c_func
(paren
op_amp
id|opt
comma
id|EXIT_WITH_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sb
)paren
id|DIFF_OPT_SET
c_func
(paren
op_amp
id|opt
comma
id|QUICK
)paren
suffix:semicolon
id|do_diff_cache
c_func
(paren
id|head
comma
op_amp
id|opt
)paren
suffix:semicolon
id|diffcore_std
c_func
(paren
op_amp
id|opt
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|sb
op_logical_and
id|i
OL
id|diff_queued_diff.nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
)paren
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|diff_queued_diff.queue
(braket
id|i
)braket
op_member_access_from_pointer
id|two-&gt;path
)paren
suffix:semicolon
)brace
id|diff_flush
c_func
(paren
op_amp
id|opt
)paren
suffix:semicolon
r_return
id|DIFF_OPT_TST
c_func
(paren
op_amp
id|opt
comma
id|HAS_CHANGES
)paren
op_ne
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|sb
op_logical_and
id|i
OL
id|active_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
)paren
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|active_cache
(braket
id|i
)braket
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
)brace
r_return
op_logical_neg
op_logical_neg
id|active_nr
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * Dies with a user-friendly message on how to proceed after resolving the&n; * problem. This message can be overridden with state-&gt;resolvemsg.&n; */
DECL|function|die_user_resolve
r_static
r_void
id|NORETURN
id|die_user_resolve
c_func
(paren
r_const
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_if
c_cond
(paren
id|state-&gt;resolvemsg
)paren
(brace
id|printf_ln
c_func
(paren
l_string|&quot;%s&quot;
comma
id|state-&gt;resolvemsg
)paren
suffix:semicolon
)brace
r_else
(brace
r_const
r_char
op_star
id|cmdline
op_assign
l_string|&quot;git am&quot;
suffix:semicolon
id|printf_ln
c_func
(paren
id|_
c_func
(paren
l_string|&quot;When you have resolved this problem, run &bslash;&quot;%s --continue&bslash;&quot;.&quot;
)paren
comma
id|cmdline
)paren
suffix:semicolon
id|printf_ln
c_func
(paren
id|_
c_func
(paren
l_string|&quot;If you prefer to skip this patch, run &bslash;&quot;%s --skip&bslash;&quot; instead.&quot;
)paren
comma
id|cmdline
)paren
suffix:semicolon
id|printf_ln
c_func
(paren
id|_
c_func
(paren
l_string|&quot;To restore the original branch and stop patching, run &bslash;&quot;%s --abort&bslash;&quot;.&quot;
)paren
comma
id|cmdline
)paren
suffix:semicolon
)brace
m_exit
(paren
l_int|128
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Parses `mail` using git-mailinfo, extracting its patch and authorship info.&n; * state-&gt;msg will be set to the patch message. state-&gt;author_name,&n; * state-&gt;author_email and state-&gt;author_date will be set to the patch author&squot;s&n; * name, email and date respectively. The patch body will be written to the&n; * state directory&squot;s &quot;patch&quot; file.&n; *&n; * Returns 1 if the patch should be skipped, 0 otherwise.&n; */
DECL|function|parse_mail
r_static
r_int
id|parse_mail
c_func
(paren
r_struct
id|am_state
op_star
id|state
comma
r_const
r_char
op_star
id|mail
)paren
(brace
id|FILE
op_star
id|fp
suffix:semicolon
r_struct
id|child_process
id|cp
op_assign
id|CHILD_PROCESS_INIT
suffix:semicolon
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
r_struct
id|strbuf
id|msg
op_assign
id|STRBUF_INIT
suffix:semicolon
r_struct
id|strbuf
id|author_name
op_assign
id|STRBUF_INIT
suffix:semicolon
r_struct
id|strbuf
id|author_date
op_assign
id|STRBUF_INIT
suffix:semicolon
r_struct
id|strbuf
id|author_email
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|cp.git_cmd
op_assign
l_int|1
suffix:semicolon
id|cp.in
op_assign
id|xopen
c_func
(paren
id|mail
comma
id|O_RDONLY
comma
l_int|0
)paren
suffix:semicolon
id|cp.out
op_assign
id|xopen
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;info&quot;
)paren
comma
id|O_WRONLY
op_or
id|O_CREAT
comma
l_int|0777
)paren
suffix:semicolon
id|argv_array_push
c_func
(paren
op_amp
id|cp.args
comma
l_string|&quot;mailinfo&quot;
)paren
suffix:semicolon
id|argv_array_push
c_func
(paren
op_amp
id|cp.args
comma
id|state-&gt;utf8
ques
c_cond
l_string|&quot;-u&quot;
suffix:colon
l_string|&quot;-n&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|state-&gt;keep
)paren
(brace
r_case
id|KEEP_FALSE
suffix:colon
r_break
suffix:semicolon
r_case
id|KEEP_TRUE
suffix:colon
id|argv_array_push
c_func
(paren
op_amp
id|cp.args
comma
l_string|&quot;-k&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|KEEP_NON_PATCH
suffix:colon
id|argv_array_push
c_func
(paren
op_amp
id|cp.args
comma
l_string|&quot;-b&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|die
c_func
(paren
l_string|&quot;BUG: invalid value for state-&gt;keep&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|state-&gt;message_id
)paren
id|argv_array_push
c_func
(paren
op_amp
id|cp.args
comma
l_string|&quot;-m&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|state-&gt;scissors
)paren
(brace
r_case
id|SCISSORS_UNSET
suffix:colon
r_break
suffix:semicolon
r_case
id|SCISSORS_FALSE
suffix:colon
id|argv_array_push
c_func
(paren
op_amp
id|cp.args
comma
l_string|&quot;--no-scissors&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCISSORS_TRUE
suffix:colon
id|argv_array_push
c_func
(paren
op_amp
id|cp.args
comma
l_string|&quot;--scissors&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|die
c_func
(paren
l_string|&quot;BUG: invalid value for state-&gt;scissors&quot;
)paren
suffix:semicolon
)brace
id|argv_array_push
c_func
(paren
op_amp
id|cp.args
comma
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;msg&quot;
)paren
)paren
suffix:semicolon
id|argv_array_push
c_func
(paren
op_amp
id|cp.args
comma
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;patch&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|run_command
c_func
(paren
op_amp
id|cp
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;could not parse patch&quot;
)paren
suffix:semicolon
id|close
c_func
(paren
id|cp.in
)paren
suffix:semicolon
id|close
c_func
(paren
id|cp.out
)paren
suffix:semicolon
multiline_comment|/* Extract message and author information */
id|fp
op_assign
id|xfopen
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;info&quot;
)paren
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|strbuf_getline
c_func
(paren
op_amp
id|sb
comma
id|fp
comma
l_char|&squot;&bslash;n&squot;
)paren
)paren
(brace
r_const
r_char
op_star
id|x
suffix:semicolon
r_if
c_cond
(paren
id|skip_prefix
c_func
(paren
id|sb.buf
comma
l_string|&quot;Subject: &quot;
comma
op_amp
id|x
)paren
)paren
(brace
r_if
c_cond
(paren
id|msg.len
)paren
id|strbuf_addch
c_func
(paren
op_amp
id|msg
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|msg
comma
id|x
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|skip_prefix
c_func
(paren
id|sb.buf
comma
l_string|&quot;Author: &quot;
comma
op_amp
id|x
)paren
)paren
id|strbuf_addstr
c_func
(paren
op_amp
id|author_name
comma
id|x
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|skip_prefix
c_func
(paren
id|sb.buf
comma
l_string|&quot;Email: &quot;
comma
op_amp
id|x
)paren
)paren
id|strbuf_addstr
c_func
(paren
op_amp
id|author_email
comma
id|x
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|skip_prefix
c_func
(paren
id|sb.buf
comma
l_string|&quot;Date: &quot;
comma
op_amp
id|x
)paren
)paren
id|strbuf_addstr
c_func
(paren
op_amp
id|author_date
comma
id|x
)paren
suffix:semicolon
)brace
id|fclose
c_func
(paren
id|fp
)paren
suffix:semicolon
multiline_comment|/* Skip pine&squot;s internal folder data */
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|author_name.buf
comma
l_string|&quot;Mail System Internal Data&quot;
)paren
)paren
(brace
id|ret
op_assign
l_int|1
suffix:semicolon
r_goto
id|finish
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_empty_file
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;patch&quot;
)paren
)paren
)paren
(brace
id|printf_ln
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Patch is empty. Was it split wrong?&quot;
)paren
)paren
suffix:semicolon
id|die_user_resolve
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
id|strbuf_addstr
c_func
(paren
op_amp
id|msg
comma
l_string|&quot;&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strbuf_read_file
c_func
(paren
op_amp
id|msg
comma
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;msg&quot;
)paren
comma
l_int|0
)paren
OL
l_int|0
)paren
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;could not read &squot;%s&squot;&quot;
)paren
comma
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;msg&quot;
)paren
)paren
suffix:semicolon
id|stripspace
c_func
(paren
op_amp
id|msg
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;signoff
)paren
id|append_signoff
c_func
(paren
op_amp
id|msg
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
m_assert
(paren
op_logical_neg
id|state-&gt;author_name
)paren
suffix:semicolon
id|state-&gt;author_name
op_assign
id|strbuf_detach
c_func
(paren
op_amp
id|author_name
comma
l_int|NULL
)paren
suffix:semicolon
m_assert
(paren
op_logical_neg
id|state-&gt;author_email
)paren
suffix:semicolon
id|state-&gt;author_email
op_assign
id|strbuf_detach
c_func
(paren
op_amp
id|author_email
comma
l_int|NULL
)paren
suffix:semicolon
m_assert
(paren
op_logical_neg
id|state-&gt;author_date
)paren
suffix:semicolon
id|state-&gt;author_date
op_assign
id|strbuf_detach
c_func
(paren
op_amp
id|author_date
comma
l_int|NULL
)paren
suffix:semicolon
m_assert
(paren
op_logical_neg
id|state-&gt;msg
)paren
suffix:semicolon
id|state-&gt;msg
op_assign
id|strbuf_detach
c_func
(paren
op_amp
id|msg
comma
op_amp
id|state-&gt;msg_len
)paren
suffix:semicolon
id|finish
suffix:colon
id|strbuf_release
c_func
(paren
op_amp
id|msg
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|author_date
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|author_email
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|author_name
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; * Sets commit_id to the commit hash where the mail was generated from.&n; * Returns 0 on success, -1 on failure.&n; */
DECL|function|get_mail_commit_sha1
r_static
r_int
id|get_mail_commit_sha1
c_func
(paren
r_int
r_char
op_star
id|commit_id
comma
r_const
r_char
op_star
id|mail
)paren
(brace
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
id|FILE
op_star
id|fp
op_assign
id|xfopen
c_func
(paren
id|mail
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_const
r_char
op_star
id|x
suffix:semicolon
r_if
c_cond
(paren
id|strbuf_getline
c_func
(paren
op_amp
id|sb
comma
id|fp
comma
l_char|&squot;&bslash;n&squot;
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skip_prefix
c_func
(paren
id|sb.buf
comma
l_string|&quot;From &quot;
comma
op_amp
id|x
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|x
comma
id|commit_id
)paren
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
id|fclose
c_func
(paren
id|fp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * Sets state-&gt;msg, state-&gt;author_name, state-&gt;author_email, state-&gt;author_date&n; * to the commit&squot;s respective info.&n; */
DECL|function|get_commit_info
r_static
r_void
id|get_commit_info
c_func
(paren
r_struct
id|am_state
op_star
id|state
comma
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_const
r_char
op_star
id|buffer
comma
op_star
id|ident_line
comma
op_star
id|author_date
comma
op_star
id|msg
suffix:semicolon
r_int
id|ident_len
suffix:semicolon
r_struct
id|ident_split
id|ident_split
suffix:semicolon
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
id|buffer
op_assign
id|logmsg_reencode
c_func
(paren
id|commit
comma
l_int|NULL
comma
id|get_commit_output_encoding
c_func
(paren
)paren
)paren
suffix:semicolon
id|ident_line
op_assign
id|find_commit_header
c_func
(paren
id|buffer
comma
l_string|&quot;author&quot;
comma
op_amp
id|ident_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|split_ident_line
c_func
(paren
op_amp
id|ident_split
comma
id|ident_line
comma
id|ident_len
)paren
OL
l_int|0
)paren
(brace
id|strbuf_add
c_func
(paren
op_amp
id|sb
comma
id|ident_line
comma
id|ident_len
)paren
suffix:semicolon
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;invalid ident line: %s&quot;
)paren
comma
id|sb.buf
)paren
suffix:semicolon
)brace
m_assert
(paren
op_logical_neg
id|state-&gt;author_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ident_split.name_begin
)paren
(brace
id|strbuf_add
c_func
(paren
op_amp
id|sb
comma
id|ident_split.name_begin
comma
id|ident_split.name_end
id|ident_split.name_begin
)paren
suffix:semicolon
id|state-&gt;author_name
op_assign
id|strbuf_detach
c_func
(paren
op_amp
id|sb
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_else
id|state-&gt;author_name
op_assign
id|xstrdup
c_func
(paren
l_string|&quot;&quot;
)paren
suffix:semicolon
m_assert
(paren
op_logical_neg
id|state-&gt;author_email
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ident_split.mail_begin
)paren
(brace
id|strbuf_add
c_func
(paren
op_amp
id|sb
comma
id|ident_split.mail_begin
comma
id|ident_split.mail_end
id|ident_split.mail_begin
)paren
suffix:semicolon
id|state-&gt;author_email
op_assign
id|strbuf_detach
c_func
(paren
op_amp
id|sb
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_else
id|state-&gt;author_email
op_assign
id|xstrdup
c_func
(paren
l_string|&quot;&quot;
)paren
suffix:semicolon
id|author_date
op_assign
id|show_ident_date
c_func
(paren
op_amp
id|ident_split
comma
id|DATE_MODE
c_func
(paren
id|NORMAL
)paren
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|sb
comma
id|author_date
)paren
suffix:semicolon
m_assert
(paren
op_logical_neg
id|state-&gt;author_date
)paren
suffix:semicolon
id|state-&gt;author_date
op_assign
id|strbuf_detach
c_func
(paren
op_amp
id|sb
comma
l_int|NULL
)paren
suffix:semicolon
m_assert
(paren
op_logical_neg
id|state-&gt;msg
)paren
suffix:semicolon
id|msg
op_assign
id|strstr
c_func
(paren
id|buffer
comma
l_string|&quot;&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|msg
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;unable to parse commit %s&quot;
)paren
comma
id|sha1_to_hex
c_func
(paren
id|commit-&gt;object.sha1
)paren
)paren
suffix:semicolon
id|state-&gt;msg
op_assign
id|xstrdup
c_func
(paren
id|msg
op_plus
l_int|2
)paren
suffix:semicolon
id|state-&gt;msg_len
op_assign
id|strlen
c_func
(paren
id|state-&gt;msg
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Writes `commit` as a patch to the state directory&squot;s &quot;patch&quot; file.&n; */
DECL|function|write_commit_patch
r_static
r_void
id|write_commit_patch
c_func
(paren
r_const
r_struct
id|am_state
op_star
id|state
comma
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_struct
id|rev_info
id|rev_info
suffix:semicolon
id|FILE
op_star
id|fp
suffix:semicolon
id|fp
op_assign
id|xfopen
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;patch&quot;
)paren
comma
l_string|&quot;w&quot;
)paren
suffix:semicolon
id|init_revisions
c_func
(paren
op_amp
id|rev_info
comma
l_int|NULL
)paren
suffix:semicolon
id|rev_info.diff
op_assign
l_int|1
suffix:semicolon
id|rev_info.abbrev
op_assign
l_int|0
suffix:semicolon
id|rev_info.disable_stdin
op_assign
l_int|1
suffix:semicolon
id|rev_info.show_root_diff
op_assign
l_int|1
suffix:semicolon
id|rev_info.diffopt.output_format
op_assign
id|DIFF_FORMAT_PATCH
suffix:semicolon
id|rev_info.no_commit_id
op_assign
l_int|1
suffix:semicolon
id|DIFF_OPT_SET
c_func
(paren
op_amp
id|rev_info.diffopt
comma
id|BINARY
)paren
suffix:semicolon
id|DIFF_OPT_SET
c_func
(paren
op_amp
id|rev_info.diffopt
comma
id|FULL_INDEX
)paren
suffix:semicolon
id|rev_info.diffopt.use_color
op_assign
l_int|0
suffix:semicolon
id|rev_info.diffopt.file
op_assign
id|fp
suffix:semicolon
id|rev_info.diffopt.close_file
op_assign
l_int|1
suffix:semicolon
id|add_pending_object
c_func
(paren
op_amp
id|rev_info
comma
op_amp
id|commit-&gt;object
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
id|diff_setup_done
c_func
(paren
op_amp
id|rev_info.diffopt
)paren
suffix:semicolon
id|log_tree_commit
c_func
(paren
op_amp
id|rev_info
comma
id|commit
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Like parse_mail(), but parses the mail by looking up its commit ID&n; * directly. This is used in --rebasing mode to bypass git-mailinfo&squot;s munging&n; * of patches.&n; *&n; * state-&gt;orig_commit will be set to the original commit ID.&n; *&n; * Will always return 0 as the patch should never be skipped.&n; */
DECL|function|parse_mail_rebase
r_static
r_int
id|parse_mail_rebase
c_func
(paren
r_struct
id|am_state
op_star
id|state
comma
r_const
r_char
op_star
id|mail
)paren
(brace
r_struct
id|commit
op_star
id|commit
suffix:semicolon
r_int
r_char
id|commit_sha1
(braket
id|GIT_SHA1_RAWSZ
)braket
suffix:semicolon
r_if
c_cond
(paren
id|get_mail_commit_sha1
c_func
(paren
id|commit_sha1
comma
id|mail
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;could not parse %s&quot;
)paren
comma
id|mail
)paren
suffix:semicolon
id|commit
op_assign
id|lookup_commit_or_die
c_func
(paren
id|commit_sha1
comma
id|mail
)paren
suffix:semicolon
id|get_commit_info
c_func
(paren
id|state
comma
id|commit
)paren
suffix:semicolon
id|write_commit_patch
c_func
(paren
id|state
comma
id|commit
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|state-&gt;orig_commit
comma
id|commit_sha1
)paren
suffix:semicolon
id|write_file
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;original-commit&quot;
)paren
comma
l_int|1
comma
l_string|&quot;%s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|commit_sha1
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * Applies current patch with git-apply. Returns 0 on success, -1 otherwise. If&n; * `index_file` is not NULL, the patch will be applied to that index.&n; */
DECL|function|run_apply
r_static
r_int
id|run_apply
c_func
(paren
r_const
r_struct
id|am_state
op_star
id|state
comma
r_const
r_char
op_star
id|index_file
)paren
(brace
r_struct
id|child_process
id|cp
op_assign
id|CHILD_PROCESS_INIT
suffix:semicolon
id|cp.git_cmd
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|index_file
)paren
id|argv_array_pushf
c_func
(paren
op_amp
id|cp.env_array
comma
l_string|&quot;GIT_INDEX_FILE=%s&quot;
comma
id|index_file
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we are allowed to fall back on 3-way merge, don&squot;t give false&n;&t; * errors during the initial attempt.&n;&t; */
r_if
c_cond
(paren
id|state-&gt;threeway
op_logical_and
op_logical_neg
id|index_file
)paren
(brace
id|cp.no_stdout
op_assign
l_int|1
suffix:semicolon
id|cp.no_stderr
op_assign
l_int|1
suffix:semicolon
)brace
id|argv_array_push
c_func
(paren
op_amp
id|cp.args
comma
l_string|&quot;apply&quot;
)paren
suffix:semicolon
id|argv_array_pushv
c_func
(paren
op_amp
id|cp.args
comma
id|state-&gt;git_apply_opts.argv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index_file
)paren
id|argv_array_push
c_func
(paren
op_amp
id|cp.args
comma
l_string|&quot;--cached&quot;
)paren
suffix:semicolon
r_else
id|argv_array_push
c_func
(paren
op_amp
id|cp.args
comma
l_string|&quot;--index&quot;
)paren
suffix:semicolon
id|argv_array_push
c_func
(paren
op_amp
id|cp.args
comma
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;patch&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|run_command
c_func
(paren
op_amp
id|cp
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Reload index as git-apply will have modified it. */
id|discard_cache
c_func
(paren
)paren
suffix:semicolon
id|read_cache_from
c_func
(paren
id|index_file
ques
c_cond
id|index_file
suffix:colon
id|get_index_file
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * Builds an index that contains just the blobs needed for a 3way merge.&n; */
DECL|function|build_fake_ancestor
r_static
r_int
id|build_fake_ancestor
c_func
(paren
r_const
r_struct
id|am_state
op_star
id|state
comma
r_const
r_char
op_star
id|index_file
)paren
(brace
r_struct
id|child_process
id|cp
op_assign
id|CHILD_PROCESS_INIT
suffix:semicolon
id|cp.git_cmd
op_assign
l_int|1
suffix:semicolon
id|argv_array_push
c_func
(paren
op_amp
id|cp.args
comma
l_string|&quot;apply&quot;
)paren
suffix:semicolon
id|argv_array_pushv
c_func
(paren
op_amp
id|cp.args
comma
id|state-&gt;git_apply_opts.argv
)paren
suffix:semicolon
id|argv_array_pushf
c_func
(paren
op_amp
id|cp.args
comma
l_string|&quot;--build-fake-ancestor=%s&quot;
comma
id|index_file
)paren
suffix:semicolon
id|argv_array_push
c_func
(paren
op_amp
id|cp.args
comma
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;patch&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|run_command
c_func
(paren
op_amp
id|cp
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * Attempt a threeway merge, using index_path as the temporary index.&n; */
DECL|function|fall_back_threeway
r_static
r_int
id|fall_back_threeway
c_func
(paren
r_const
r_struct
id|am_state
op_star
id|state
comma
r_const
r_char
op_star
id|index_path
)paren
(brace
r_int
r_char
id|orig_tree
(braket
id|GIT_SHA1_RAWSZ
)braket
comma
id|his_tree
(braket
id|GIT_SHA1_RAWSZ
)braket
comma
id|our_tree
(braket
id|GIT_SHA1_RAWSZ
)braket
suffix:semicolon
r_const
r_int
r_char
op_star
id|bases
(braket
l_int|1
)braket
op_assign
(brace
id|orig_tree
)brace
suffix:semicolon
r_struct
id|merge_options
id|o
suffix:semicolon
r_struct
id|commit
op_star
id|result
suffix:semicolon
r_char
op_star
id|his_tree_name
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|our_tree
)paren
OL
l_int|0
)paren
id|hashcpy
c_func
(paren
id|our_tree
comma
id|EMPTY_TREE_SHA1_BIN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|build_fake_ancestor
c_func
(paren
id|state
comma
id|index_path
)paren
)paren
r_return
id|error
c_func
(paren
l_string|&quot;could not build fake ancestor&quot;
)paren
suffix:semicolon
id|discard_cache
c_func
(paren
)paren
suffix:semicolon
id|read_cache_from
c_func
(paren
id|index_path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write_index_as_tree
c_func
(paren
id|orig_tree
comma
op_amp
id|the_index
comma
id|index_path
comma
l_int|0
comma
l_int|NULL
)paren
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Repository lacks necessary blobs to fall back on 3-way merge.&quot;
)paren
)paren
suffix:semicolon
id|say
c_func
(paren
id|state
comma
id|stdout
comma
id|_
c_func
(paren
l_string|&quot;Using index info to reconstruct a base tree...&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|state-&gt;quiet
)paren
(brace
multiline_comment|/*&n;&t;&t; * List paths that needed 3-way fallback, so that the user can&n;&t;&t; * review them with extra care to spot mismerges.&n;&t;&t; */
r_struct
id|rev_info
id|rev_info
suffix:semicolon
r_const
r_char
op_star
id|diff_filter_str
op_assign
l_string|&quot;--diff-filter=AM&quot;
suffix:semicolon
id|init_revisions
c_func
(paren
op_amp
id|rev_info
comma
l_int|NULL
)paren
suffix:semicolon
id|rev_info.diffopt.output_format
op_assign
id|DIFF_FORMAT_NAME_STATUS
suffix:semicolon
id|diff_opt_parse
c_func
(paren
op_amp
id|rev_info.diffopt
comma
op_amp
id|diff_filter_str
comma
l_int|1
)paren
suffix:semicolon
id|add_pending_sha1
c_func
(paren
op_amp
id|rev_info
comma
l_string|&quot;HEAD&quot;
comma
id|our_tree
comma
l_int|0
)paren
suffix:semicolon
id|diff_setup_done
c_func
(paren
op_amp
id|rev_info.diffopt
)paren
suffix:semicolon
id|run_diff_index
c_func
(paren
op_amp
id|rev_info
comma
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|run_apply
c_func
(paren
id|state
comma
id|index_path
)paren
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Did you hand edit your patch?&bslash;n&quot;
l_string|&quot;It does not apply to blobs recorded in its index.&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write_index_as_tree
c_func
(paren
id|his_tree
comma
op_amp
id|the_index
comma
id|index_path
comma
l_int|0
comma
l_int|NULL
)paren
)paren
r_return
id|error
c_func
(paren
l_string|&quot;could not write tree&quot;
)paren
suffix:semicolon
id|say
c_func
(paren
id|state
comma
id|stdout
comma
id|_
c_func
(paren
l_string|&quot;Falling back to patching base and 3-way merge...&quot;
)paren
)paren
suffix:semicolon
id|discard_cache
c_func
(paren
)paren
suffix:semicolon
id|read_cache
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This is not so wrong. Depending on which base we picked, orig_tree&n;&t; * may be wildly different from ours, but his_tree has the same set of&n;&t; * wildly different changes in parts the patch did not touch, so&n;&t; * recursive ends up canceling them, saying that we reverted all those&n;&t; * changes.&n;&t; */
id|init_merge_options
c_func
(paren
op_amp
id|o
)paren
suffix:semicolon
id|o.branch1
op_assign
l_string|&quot;HEAD&quot;
suffix:semicolon
id|his_tree_name
op_assign
id|xstrfmt
c_func
(paren
l_string|&quot;%.*s&quot;
comma
id|linelen
c_func
(paren
id|state-&gt;msg
)paren
comma
id|state-&gt;msg
)paren
suffix:semicolon
id|o.branch2
op_assign
id|his_tree_name
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;quiet
)paren
id|o.verbosity
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|merge_recursive_generic
c_func
(paren
op_amp
id|o
comma
id|our_tree
comma
id|his_tree
comma
l_int|1
comma
id|bases
comma
op_amp
id|result
)paren
)paren
(brace
id|rerere
c_func
(paren
id|state-&gt;allow_rerere_autoupdate
)paren
suffix:semicolon
id|free
c_func
(paren
id|his_tree_name
)paren
suffix:semicolon
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Failed to merge in the changes.&quot;
)paren
)paren
suffix:semicolon
)brace
id|free
c_func
(paren
id|his_tree_name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * Commits the current index with state-&gt;msg as the commit message and&n; * state-&gt;author_name, state-&gt;author_email and state-&gt;author_date as the author&n; * information.&n; */
DECL|function|do_commit
r_static
r_void
id|do_commit
c_func
(paren
r_const
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_int
r_char
id|tree
(braket
id|GIT_SHA1_RAWSZ
)braket
comma
id|parent
(braket
id|GIT_SHA1_RAWSZ
)braket
comma
id|commit
(braket
id|GIT_SHA1_RAWSZ
)braket
suffix:semicolon
r_int
r_char
op_star
id|ptr
suffix:semicolon
r_struct
id|commit_list
op_star
id|parents
op_assign
l_int|NULL
suffix:semicolon
r_const
r_char
op_star
id|reflog_msg
comma
op_star
id|author
suffix:semicolon
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
r_if
c_cond
(paren
id|run_hook_le
c_func
(paren
l_int|NULL
comma
l_string|&quot;pre-applypatch&quot;
comma
l_int|NULL
)paren
)paren
m_exit
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write_cache_as_tree
c_func
(paren
id|tree
comma
l_int|0
comma
l_int|NULL
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;git write-tree failed to write a tree&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|get_sha1_commit
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|parent
)paren
)paren
(brace
id|ptr
op_assign
id|parent
suffix:semicolon
id|commit_list_insert
c_func
(paren
id|lookup_commit
c_func
(paren
id|parent
)paren
comma
op_amp
id|parents
)paren
suffix:semicolon
)brace
r_else
(brace
id|ptr
op_assign
l_int|NULL
suffix:semicolon
id|say
c_func
(paren
id|state
comma
id|stderr
comma
id|_
c_func
(paren
l_string|&quot;applying to an empty history&quot;
)paren
)paren
suffix:semicolon
)brace
id|author
op_assign
id|fmt_ident
c_func
(paren
id|state-&gt;author_name
comma
id|state-&gt;author_email
comma
id|state-&gt;ignore_date
ques
c_cond
l_int|NULL
suffix:colon
id|state-&gt;author_date
comma
id|IDENT_STRICT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;committer_date_is_author_date
)paren
id|setenv
c_func
(paren
l_string|&quot;GIT_COMMITTER_DATE&quot;
comma
id|state-&gt;ignore_date
ques
c_cond
l_string|&quot;&quot;
suffix:colon
id|state-&gt;author_date
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|commit_tree
c_func
(paren
id|state-&gt;msg
comma
id|state-&gt;msg_len
comma
id|tree
comma
id|parents
comma
id|commit
comma
id|author
comma
id|state-&gt;sign_commit
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;failed to write commit object&quot;
)paren
)paren
suffix:semicolon
id|reflog_msg
op_assign
id|getenv
c_func
(paren
l_string|&quot;GIT_REFLOG_ACTION&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|reflog_msg
)paren
id|reflog_msg
op_assign
l_string|&quot;am&quot;
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
id|sb
comma
l_string|&quot;%s: %.*s&quot;
comma
id|reflog_msg
comma
id|linelen
c_func
(paren
id|state-&gt;msg
)paren
comma
id|state-&gt;msg
)paren
suffix:semicolon
id|update_ref
c_func
(paren
id|sb.buf
comma
l_string|&quot;HEAD&quot;
comma
id|commit
comma
id|ptr
comma
l_int|0
comma
id|UPDATE_REFS_DIE_ON_ERR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;rebasing
)paren
(brace
id|FILE
op_star
id|fp
op_assign
id|xfopen
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;rewritten&quot;
)paren
comma
l_string|&quot;a&quot;
)paren
suffix:semicolon
m_assert
(paren
op_logical_neg
id|is_null_sha1
c_func
(paren
id|state-&gt;orig_commit
)paren
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|fp
comma
l_string|&quot;%s &quot;
comma
id|sha1_to_hex
c_func
(paren
id|state-&gt;orig_commit
)paren
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|fp
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|commit
)paren
)paren
suffix:semicolon
id|fclose
c_func
(paren
id|fp
)paren
suffix:semicolon
)brace
id|run_hook_le
c_func
(paren
l_int|NULL
comma
l_string|&quot;post-applypatch&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Validates the am_state for resuming -- the &quot;msg&quot; and authorship fields must&n; * be filled up.&n; */
DECL|function|validate_resume_state
r_static
r_void
id|validate_resume_state
c_func
(paren
r_const
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|state-&gt;msg
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;cannot resume: %s does not exist.&quot;
)paren
comma
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;final-commit&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|state-&gt;author_name
op_logical_or
op_logical_neg
id|state-&gt;author_email
op_logical_or
op_logical_neg
id|state-&gt;author_date
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;cannot resume: %s does not exist.&quot;
)paren
comma
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;author-script&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Applies all queued mail.&n; *&n; * If `resume` is true, we are &quot;resuming&quot;. The &quot;msg&quot; and authorship fields, as&n; * well as the state directory&squot;s &quot;patch&quot; file is used as-is for applying the&n; * patch and committing it.&n; */
DECL|function|am_run
r_static
r_void
id|am_run
c_func
(paren
r_struct
id|am_state
op_star
id|state
comma
r_int
id|resume
)paren
(brace
r_const
r_char
op_star
id|argv_gc_auto
(braket
)braket
op_assign
(brace
l_string|&quot;gc&quot;
comma
l_string|&quot;--auto&quot;
comma
l_int|NULL
)brace
suffix:semicolon
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
id|unlink
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;dirtyindex&quot;
)paren
)paren
suffix:semicolon
id|refresh_and_write_cache
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index_has_changes
c_func
(paren
op_amp
id|sb
)paren
)paren
(brace
id|write_file
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;dirtyindex&quot;
)paren
comma
l_int|1
comma
l_string|&quot;t&quot;
)paren
suffix:semicolon
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Dirty index: cannot apply patches (dirty: %s)&quot;
)paren
comma
id|sb.buf
)paren
suffix:semicolon
)brace
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
r_while
c_loop
(paren
id|state-&gt;cur
op_le
id|state-&gt;last
)paren
(brace
r_const
r_char
op_star
id|mail
op_assign
id|am_path
c_func
(paren
id|state
comma
id|msgnum
c_func
(paren
id|state
)paren
)paren
suffix:semicolon
r_int
id|apply_status
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file_exists
c_func
(paren
id|mail
)paren
)paren
r_goto
id|next
suffix:semicolon
r_if
c_cond
(paren
id|resume
)paren
(brace
id|validate_resume_state
c_func
(paren
id|state
)paren
suffix:semicolon
id|resume
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_int
id|skip
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;rebasing
)paren
id|skip
op_assign
id|parse_mail_rebase
c_func
(paren
id|state
comma
id|mail
)paren
suffix:semicolon
r_else
id|skip
op_assign
id|parse_mail
c_func
(paren
id|state
comma
id|mail
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skip
)paren
r_goto
id|next
suffix:semicolon
multiline_comment|/* mail should be skipped */
id|write_author_script
c_func
(paren
id|state
)paren
suffix:semicolon
id|write_commit_msg
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|run_applypatch_msg_hook
c_func
(paren
id|state
)paren
)paren
m_exit
(paren
l_int|1
)paren
suffix:semicolon
id|say
c_func
(paren
id|state
comma
id|stdout
comma
id|_
c_func
(paren
l_string|&quot;Applying: %.*s&quot;
)paren
comma
id|linelen
c_func
(paren
id|state-&gt;msg
)paren
comma
id|state-&gt;msg
)paren
suffix:semicolon
id|apply_status
op_assign
id|run_apply
c_func
(paren
id|state
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|apply_status
op_logical_and
id|state-&gt;threeway
)paren
(brace
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|sb
comma
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;patch-merge-index&quot;
)paren
)paren
suffix:semicolon
id|apply_status
op_assign
id|fall_back_threeway
c_func
(paren
id|state
comma
id|sb.buf
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Applying the patch to an earlier tree and merging&n;&t;&t;&t; * the result may have produced the same tree as ours.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|apply_status
op_logical_and
op_logical_neg
id|index_has_changes
c_func
(paren
l_int|NULL
)paren
)paren
(brace
id|say
c_func
(paren
id|state
comma
id|stdout
comma
id|_
c_func
(paren
l_string|&quot;No changes -- Patch already applied.&quot;
)paren
)paren
suffix:semicolon
r_goto
id|next
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|apply_status
)paren
(brace
r_int
id|advice_amworkdir
op_assign
l_int|1
suffix:semicolon
id|printf_ln
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Patch failed at %s %.*s&quot;
)paren
comma
id|msgnum
c_func
(paren
id|state
)paren
comma
id|linelen
c_func
(paren
id|state-&gt;msg
)paren
comma
id|state-&gt;msg
)paren
suffix:semicolon
id|git_config_get_bool
c_func
(paren
l_string|&quot;advice.amworkdir&quot;
comma
op_amp
id|advice_amworkdir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|advice_amworkdir
)paren
id|printf_ln
c_func
(paren
id|_
c_func
(paren
l_string|&quot;The copy of the patch that failed is found in: %s&quot;
)paren
comma
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;patch&quot;
)paren
)paren
suffix:semicolon
id|die_user_resolve
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
id|do_commit
c_func
(paren
id|state
)paren
suffix:semicolon
id|next
suffix:colon
id|am_next
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|is_empty_file
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;rewritten&quot;
)paren
)paren
)paren
(brace
m_assert
(paren
id|state-&gt;rebasing
)paren
suffix:semicolon
id|copy_notes_for_rebase
c_func
(paren
id|state
)paren
suffix:semicolon
id|run_post_rewrite_hook
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * In rebasing mode, it&squot;s up to the caller to take care of&n;&t; * housekeeping.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|state-&gt;rebasing
)paren
(brace
id|am_destroy
c_func
(paren
id|state
)paren
suffix:semicolon
id|run_command_v_opt
c_func
(paren
id|argv_gc_auto
comma
id|RUN_GIT_CMD
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * Resume the current am session after patch application failure. The user did&n; * all the hard work, and we do not have to do any patch application. Just&n; * trust and commit what the user has in the index and working tree.&n; */
DECL|function|am_resolve
r_static
r_void
id|am_resolve
c_func
(paren
r_struct
id|am_state
op_star
id|state
)paren
(brace
id|validate_resume_state
c_func
(paren
id|state
)paren
suffix:semicolon
id|say
c_func
(paren
id|state
comma
id|stdout
comma
id|_
c_func
(paren
l_string|&quot;Applying: %.*s&quot;
)paren
comma
id|linelen
c_func
(paren
id|state-&gt;msg
)paren
comma
id|state-&gt;msg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|index_has_changes
c_func
(paren
l_int|NULL
)paren
)paren
(brace
id|printf_ln
c_func
(paren
id|_
c_func
(paren
l_string|&quot;No changes - did you forget to use &squot;git add&squot;?&bslash;n&quot;
l_string|&quot;If there is nothing left to stage, chances are that something else&bslash;n&quot;
l_string|&quot;already introduced the same changes; you might want to skip this patch.&quot;
)paren
)paren
suffix:semicolon
id|die_user_resolve
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unmerged_cache
c_func
(paren
)paren
)paren
(brace
id|printf_ln
c_func
(paren
id|_
c_func
(paren
l_string|&quot;You still have unmerged paths in your index.&bslash;n&quot;
l_string|&quot;Did you forget to use &squot;git add&squot;?&quot;
)paren
)paren
suffix:semicolon
id|die_user_resolve
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
id|rerere
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|do_commit
c_func
(paren
id|state
)paren
suffix:semicolon
id|am_next
c_func
(paren
id|state
)paren
suffix:semicolon
id|am_run
c_func
(paren
id|state
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Performs a checkout fast-forward from `head` to `remote`. If `reset` is&n; * true, any unmerged entries will be discarded. Returns 0 on success, -1 on&n; * failure.&n; */
DECL|function|fast_forward_to
r_static
r_int
id|fast_forward_to
c_func
(paren
r_struct
id|tree
op_star
id|head
comma
r_struct
id|tree
op_star
id|remote
comma
r_int
id|reset
)paren
(brace
r_struct
id|lock_file
op_star
id|lock_file
suffix:semicolon
r_struct
id|unpack_trees_options
id|opts
suffix:semicolon
r_struct
id|tree_desc
id|t
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
id|parse_tree
c_func
(paren
id|head
)paren
op_logical_or
id|parse_tree
c_func
(paren
id|remote
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|lock_file
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|lock_file
)paren
)paren
suffix:semicolon
id|hold_locked_index
c_func
(paren
id|lock_file
comma
l_int|1
)paren
suffix:semicolon
id|refresh_cache
c_func
(paren
id|REFRESH_QUIET
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|opts
comma
l_int|0
comma
r_sizeof
(paren
id|opts
)paren
)paren
suffix:semicolon
id|opts.head_idx
op_assign
l_int|1
suffix:semicolon
id|opts.src_index
op_assign
op_amp
id|the_index
suffix:semicolon
id|opts.dst_index
op_assign
op_amp
id|the_index
suffix:semicolon
id|opts.update
op_assign
l_int|1
suffix:semicolon
id|opts.merge
op_assign
l_int|1
suffix:semicolon
id|opts.reset
op_assign
id|reset
suffix:semicolon
id|opts.fn
op_assign
id|twoway_merge
suffix:semicolon
id|init_tree_desc
c_func
(paren
op_amp
id|t
(braket
l_int|0
)braket
comma
id|head-&gt;buffer
comma
id|head-&gt;size
)paren
suffix:semicolon
id|init_tree_desc
c_func
(paren
op_amp
id|t
(braket
l_int|1
)braket
comma
id|remote-&gt;buffer
comma
id|remote-&gt;size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unpack_trees
c_func
(paren
l_int|2
comma
id|t
comma
op_amp
id|opts
)paren
)paren
(brace
id|rollback_lock_file
c_func
(paren
id|lock_file
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|write_locked_index
c_func
(paren
op_amp
id|the_index
comma
id|lock_file
comma
id|COMMIT_LOCK
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;unable to write new index file&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * Clean the index without touching entries that are not modified between&n; * `head` and `remote`.&n; */
DECL|function|clean_index
r_static
r_int
id|clean_index
c_func
(paren
r_const
r_int
r_char
op_star
id|head
comma
r_const
r_int
r_char
op_star
id|remote
)paren
(brace
r_struct
id|lock_file
op_star
id|lock_file
suffix:semicolon
r_struct
id|tree
op_star
id|head_tree
comma
op_star
id|remote_tree
comma
op_star
id|index_tree
suffix:semicolon
r_int
r_char
id|index
(braket
id|GIT_SHA1_RAWSZ
)braket
suffix:semicolon
r_struct
id|pathspec
id|pathspec
suffix:semicolon
id|head_tree
op_assign
id|parse_tree_indirect
c_func
(paren
id|head
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|head_tree
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Could not parse object &squot;%s&squot;.&quot;
)paren
comma
id|sha1_to_hex
c_func
(paren
id|head
)paren
)paren
suffix:semicolon
id|remote_tree
op_assign
id|parse_tree_indirect
c_func
(paren
id|remote
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|remote_tree
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Could not parse object &squot;%s&squot;.&quot;
)paren
comma
id|sha1_to_hex
c_func
(paren
id|remote
)paren
)paren
suffix:semicolon
id|read_cache_unmerged
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fast_forward_to
c_func
(paren
id|head_tree
comma
id|head_tree
comma
l_int|1
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|write_cache_as_tree
c_func
(paren
id|index
comma
l_int|0
comma
l_int|NULL
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|index_tree
op_assign
id|parse_tree_indirect
c_func
(paren
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|index_tree
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Could not parse object &squot;%s&squot;.&quot;
)paren
comma
id|sha1_to_hex
c_func
(paren
id|index
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fast_forward_to
c_func
(paren
id|index_tree
comma
id|remote_tree
comma
l_int|0
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|pathspec
comma
l_int|0
comma
r_sizeof
(paren
id|pathspec
)paren
)paren
suffix:semicolon
id|lock_file
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|lock_file
)paren
)paren
suffix:semicolon
id|hold_locked_index
c_func
(paren
id|lock_file
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_tree
c_func
(paren
id|remote_tree
comma
l_int|0
comma
op_amp
id|pathspec
)paren
)paren
(brace
id|rollback_lock_file
c_func
(paren
id|lock_file
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|write_locked_index
c_func
(paren
op_amp
id|the_index
comma
id|lock_file
comma
id|COMMIT_LOCK
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;unable to write new index file&quot;
)paren
)paren
suffix:semicolon
id|remove_branch_state
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * Resets rerere&squot;s merge resolution metadata.&n; */
DECL|function|am_rerere_clear
r_static
r_void
id|am_rerere_clear
c_func
(paren
r_void
)paren
(brace
r_struct
id|string_list
id|merge_rr
op_assign
id|STRING_LIST_INIT_DUP
suffix:semicolon
r_int
id|fd
op_assign
id|setup_rerere
c_func
(paren
op_amp
id|merge_rr
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
r_return
suffix:semicolon
id|rerere_clear
c_func
(paren
op_amp
id|merge_rr
)paren
suffix:semicolon
id|string_list_clear
c_func
(paren
op_amp
id|merge_rr
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Resume the current am session by skipping the current patch.&n; */
DECL|function|am_skip
r_static
r_void
id|am_skip
c_func
(paren
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_int
r_char
id|head
(braket
id|GIT_SHA1_RAWSZ
)braket
suffix:semicolon
id|am_rerere_clear
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|head
)paren
)paren
id|hashcpy
c_func
(paren
id|head
comma
id|EMPTY_TREE_SHA1_BIN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|clean_index
c_func
(paren
id|head
comma
id|head
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;failed to clean index&quot;
)paren
)paren
suffix:semicolon
id|am_next
c_func
(paren
id|state
)paren
suffix:semicolon
id|am_run
c_func
(paren
id|state
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Returns true if it is safe to reset HEAD to the ORIG_HEAD, false otherwise.&n; *&n; * It is not safe to reset HEAD when:&n; * 1. git-am previously failed because the index was dirty.&n; * 2. HEAD has moved since git-am previously failed.&n; */
DECL|function|safe_to_abort
r_static
r_int
id|safe_to_abort
c_func
(paren
r_const
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
r_char
id|abort_safety
(braket
id|GIT_SHA1_RAWSZ
)braket
comma
id|head
(braket
id|GIT_SHA1_RAWSZ
)braket
suffix:semicolon
r_if
c_cond
(paren
id|file_exists
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;dirtyindex&quot;
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|read_state_file
c_func
(paren
op_amp
id|sb
comma
id|state
comma
l_string|&quot;abort-safety&quot;
comma
l_int|1
)paren
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|sb.buf
comma
id|abort_safety
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;could not parse %s&quot;
)paren
comma
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;abort_safety&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
id|hashclr
c_func
(paren
id|abort_safety
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|head
)paren
)paren
id|hashclr
c_func
(paren
id|head
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hashcmp
c_func
(paren
id|head
comma
id|abort_safety
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;You seem to have moved HEAD since the last &squot;am&squot; failure.&bslash;n&quot;
l_string|&quot;Not rewinding to ORIG_HEAD&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * Aborts the current am session if it is safe to do so.&n; */
DECL|function|am_abort
r_static
r_void
id|am_abort
c_func
(paren
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_int
r_char
id|curr_head
(braket
id|GIT_SHA1_RAWSZ
)braket
comma
id|orig_head
(braket
id|GIT_SHA1_RAWSZ
)braket
suffix:semicolon
r_int
id|has_curr_head
comma
id|has_orig_head
suffix:semicolon
r_char
op_star
id|curr_branch
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|safe_to_abort
c_func
(paren
id|state
)paren
)paren
(brace
id|am_destroy
c_func
(paren
id|state
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|am_rerere_clear
c_func
(paren
)paren
suffix:semicolon
id|curr_branch
op_assign
id|resolve_refdup
c_func
(paren
l_string|&quot;HEAD&quot;
comma
l_int|0
comma
id|curr_head
comma
l_int|NULL
)paren
suffix:semicolon
id|has_curr_head
op_assign
op_logical_neg
id|is_null_sha1
c_func
(paren
id|curr_head
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|has_curr_head
)paren
id|hashcpy
c_func
(paren
id|curr_head
comma
id|EMPTY_TREE_SHA1_BIN
)paren
suffix:semicolon
id|has_orig_head
op_assign
op_logical_neg
id|get_sha1
c_func
(paren
l_string|&quot;ORIG_HEAD&quot;
comma
id|orig_head
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|has_orig_head
)paren
id|hashcpy
c_func
(paren
id|orig_head
comma
id|EMPTY_TREE_SHA1_BIN
)paren
suffix:semicolon
id|clean_index
c_func
(paren
id|curr_head
comma
id|orig_head
)paren
suffix:semicolon
r_if
c_cond
(paren
id|has_orig_head
)paren
id|update_ref
c_func
(paren
l_string|&quot;am --abort&quot;
comma
l_string|&quot;HEAD&quot;
comma
id|orig_head
comma
id|has_curr_head
ques
c_cond
id|curr_head
suffix:colon
l_int|NULL
comma
l_int|0
comma
id|UPDATE_REFS_DIE_ON_ERR
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|curr_branch
)paren
id|delete_ref
c_func
(paren
id|curr_branch
comma
l_int|NULL
comma
id|REF_NODEREF
)paren
suffix:semicolon
id|free
c_func
(paren
id|curr_branch
)paren
suffix:semicolon
id|am_destroy
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * parse_options() callback that validates and sets opt-&gt;value to the&n; * PATCH_FORMAT_* enum value corresponding to `arg`.&n; */
DECL|function|parse_opt_patchformat
r_static
r_int
id|parse_opt_patchformat
c_func
(paren
r_const
r_struct
id|option
op_star
id|opt
comma
r_const
r_char
op_star
id|arg
comma
r_int
id|unset
)paren
(brace
r_int
op_star
id|opt_value
op_assign
id|opt-&gt;value
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;mbox&quot;
)paren
)paren
op_star
id|opt_value
op_assign
id|PATCH_FORMAT_MBOX
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;stgit&quot;
)paren
)paren
op_star
id|opt_value
op_assign
id|PATCH_FORMAT_STGIT
suffix:semicolon
r_else
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Invalid value for --patch-format: %s&quot;
)paren
comma
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|enum|resume_mode
r_enum
id|resume_mode
(brace
DECL|enumerator|RESUME_FALSE
id|RESUME_FALSE
op_assign
l_int|0
comma
DECL|enumerator|RESUME_APPLY
id|RESUME_APPLY
comma
DECL|enumerator|RESUME_RESOLVED
id|RESUME_RESOLVED
comma
DECL|enumerator|RESUME_SKIP
id|RESUME_SKIP
comma
DECL|enumerator|RESUME_ABORT
id|RESUME_ABORT
)brace
suffix:semicolon
DECL|function|cmd_am
r_int
id|cmd_am
c_func
(paren
r_int
id|argc
comma
r_const
r_char
op_star
op_star
id|argv
comma
r_const
r_char
op_star
id|prefix
)paren
(brace
r_struct
id|am_state
id|state
suffix:semicolon
r_int
id|keep_cr
op_assign
l_int|1
suffix:semicolon
r_int
id|patch_format
op_assign
id|PATCH_FORMAT_UNKNOWN
suffix:semicolon
r_enum
id|resume_mode
id|resume
op_assign
id|RESUME_FALSE
suffix:semicolon
r_const
r_char
op_star
r_const
id|usage
(braket
)braket
op_assign
(brace
id|N_
c_func
(paren
l_string|&quot;git am [options] [(&lt;mbox&gt;|&lt;Maildir&gt;)...]&quot;
)paren
comma
id|N_
c_func
(paren
l_string|&quot;git am [options] (--continue | --skip | --abort)&quot;
)paren
comma
l_int|NULL
)brace
suffix:semicolon
r_struct
id|option
id|options
(braket
)braket
op_assign
(brace
id|OPT_BOOL
c_func
(paren
l_char|&squot;3&squot;
comma
l_string|&quot;3way&quot;
comma
op_amp
id|state.threeway
comma
id|N_
c_func
(paren
l_string|&quot;allow fall back on 3way merging if needed&quot;
)paren
)paren
comma
id|OPT__QUIET
c_func
(paren
op_amp
id|state.quiet
comma
id|N_
c_func
(paren
l_string|&quot;be quiet&quot;
)paren
)paren
comma
id|OPT_BOOL
c_func
(paren
l_char|&squot;s&squot;
comma
l_string|&quot;signoff&quot;
comma
op_amp
id|state.signoff
comma
id|N_
c_func
(paren
l_string|&quot;add a Signed-off-by line to the commit message&quot;
)paren
)paren
comma
id|OPT_BOOL
c_func
(paren
l_char|&squot;u&squot;
comma
l_string|&quot;utf8&quot;
comma
op_amp
id|state.utf8
comma
id|N_
c_func
(paren
l_string|&quot;recode into utf8 (default)&quot;
)paren
)paren
comma
id|OPT_SET_INT
c_func
(paren
l_char|&squot;k&squot;
comma
l_string|&quot;keep&quot;
comma
op_amp
id|state.keep
comma
id|N_
c_func
(paren
l_string|&quot;pass -k flag to git-mailinfo&quot;
)paren
comma
id|KEEP_TRUE
)paren
comma
id|OPT_SET_INT
c_func
(paren
l_int|0
comma
l_string|&quot;keep-non-patch&quot;
comma
op_amp
id|state.keep
comma
id|N_
c_func
(paren
l_string|&quot;pass -b flag to git-mailinfo&quot;
)paren
comma
id|KEEP_NON_PATCH
)paren
comma
id|OPT_BOOL
c_func
(paren
l_char|&squot;m&squot;
comma
l_string|&quot;message-id&quot;
comma
op_amp
id|state.message_id
comma
id|N_
c_func
(paren
l_string|&quot;pass -m flag to git-mailinfo&quot;
)paren
)paren
comma
(brace
id|OPTION_SET_INT
comma
l_int|0
comma
l_string|&quot;keep-cr&quot;
comma
op_amp
id|keep_cr
comma
l_int|NULL
comma
id|N_
c_func
(paren
l_string|&quot;pass --keep-cr flag to git-mailsplit for mbox format&quot;
)paren
comma
id|PARSE_OPT_NOARG
op_or
id|PARSE_OPT_NONEG
comma
l_int|NULL
comma
l_int|1
)brace
comma
(brace
id|OPTION_SET_INT
comma
l_int|0
comma
l_string|&quot;no-keep-cr&quot;
comma
op_amp
id|keep_cr
comma
l_int|NULL
comma
id|N_
c_func
(paren
l_string|&quot;do not pass --keep-cr flag to git-mailsplit independent of am.keepcr&quot;
)paren
comma
id|PARSE_OPT_NOARG
op_or
id|PARSE_OPT_NONEG
comma
l_int|NULL
comma
l_int|0
)brace
comma
id|OPT_BOOL
c_func
(paren
l_char|&squot;c&squot;
comma
l_string|&quot;scissors&quot;
comma
op_amp
id|state.scissors
comma
id|N_
c_func
(paren
l_string|&quot;strip everything before a scissors line&quot;
)paren
)paren
comma
id|OPT_PASSTHRU_ARGV
c_func
(paren
l_int|0
comma
l_string|&quot;whitespace&quot;
comma
op_amp
id|state.git_apply_opts
comma
id|N_
c_func
(paren
l_string|&quot;action&quot;
)paren
comma
id|N_
c_func
(paren
l_string|&quot;pass it through git-apply&quot;
)paren
comma
l_int|0
)paren
comma
id|OPT_PASSTHRU_ARGV
c_func
(paren
l_int|0
comma
l_string|&quot;ignore-space-change&quot;
comma
op_amp
id|state.git_apply_opts
comma
l_int|NULL
comma
id|N_
c_func
(paren
l_string|&quot;pass it through git-apply&quot;
)paren
comma
id|PARSE_OPT_NOARG
)paren
comma
id|OPT_PASSTHRU_ARGV
c_func
(paren
l_int|0
comma
l_string|&quot;ignore-whitespace&quot;
comma
op_amp
id|state.git_apply_opts
comma
l_int|NULL
comma
id|N_
c_func
(paren
l_string|&quot;pass it through git-apply&quot;
)paren
comma
id|PARSE_OPT_NOARG
)paren
comma
id|OPT_PASSTHRU_ARGV
c_func
(paren
l_int|0
comma
l_string|&quot;directory&quot;
comma
op_amp
id|state.git_apply_opts
comma
id|N_
c_func
(paren
l_string|&quot;root&quot;
)paren
comma
id|N_
c_func
(paren
l_string|&quot;pass it through git-apply&quot;
)paren
comma
l_int|0
)paren
comma
id|OPT_PASSTHRU_ARGV
c_func
(paren
l_int|0
comma
l_string|&quot;exclude&quot;
comma
op_amp
id|state.git_apply_opts
comma
id|N_
c_func
(paren
l_string|&quot;path&quot;
)paren
comma
id|N_
c_func
(paren
l_string|&quot;pass it through git-apply&quot;
)paren
comma
l_int|0
)paren
comma
id|OPT_PASSTHRU_ARGV
c_func
(paren
l_int|0
comma
l_string|&quot;include&quot;
comma
op_amp
id|state.git_apply_opts
comma
id|N_
c_func
(paren
l_string|&quot;path&quot;
)paren
comma
id|N_
c_func
(paren
l_string|&quot;pass it through git-apply&quot;
)paren
comma
l_int|0
)paren
comma
id|OPT_PASSTHRU_ARGV
c_func
(paren
l_char|&squot;C&squot;
comma
l_int|NULL
comma
op_amp
id|state.git_apply_opts
comma
id|N_
c_func
(paren
l_string|&quot;n&quot;
)paren
comma
id|N_
c_func
(paren
l_string|&quot;pass it through git-apply&quot;
)paren
comma
l_int|0
)paren
comma
id|OPT_PASSTHRU_ARGV
c_func
(paren
l_char|&squot;p&squot;
comma
l_int|NULL
comma
op_amp
id|state.git_apply_opts
comma
id|N_
c_func
(paren
l_string|&quot;num&quot;
)paren
comma
id|N_
c_func
(paren
l_string|&quot;pass it through git-apply&quot;
)paren
comma
l_int|0
)paren
comma
id|OPT_CALLBACK
c_func
(paren
l_int|0
comma
l_string|&quot;patch-format&quot;
comma
op_amp
id|patch_format
comma
id|N_
c_func
(paren
l_string|&quot;format&quot;
)paren
comma
id|N_
c_func
(paren
l_string|&quot;format the patch(es) are in&quot;
)paren
comma
id|parse_opt_patchformat
)paren
comma
id|OPT_PASSTHRU_ARGV
c_func
(paren
l_int|0
comma
l_string|&quot;reject&quot;
comma
op_amp
id|state.git_apply_opts
comma
l_int|NULL
comma
id|N_
c_func
(paren
l_string|&quot;pass it through git-apply&quot;
)paren
comma
id|PARSE_OPT_NOARG
)paren
comma
id|OPT_STRING
c_func
(paren
l_int|0
comma
l_string|&quot;resolvemsg&quot;
comma
op_amp
id|state.resolvemsg
comma
l_int|NULL
comma
id|N_
c_func
(paren
l_string|&quot;override error message when patch failure occurs&quot;
)paren
)paren
comma
id|OPT_CMDMODE
c_func
(paren
l_int|0
comma
l_string|&quot;continue&quot;
comma
op_amp
id|resume
comma
id|N_
c_func
(paren
l_string|&quot;continue applying patches after resolving a conflict&quot;
)paren
comma
id|RESUME_RESOLVED
)paren
comma
id|OPT_CMDMODE
c_func
(paren
l_char|&squot;r&squot;
comma
l_string|&quot;resolved&quot;
comma
op_amp
id|resume
comma
id|N_
c_func
(paren
l_string|&quot;synonyms for --continue&quot;
)paren
comma
id|RESUME_RESOLVED
)paren
comma
id|OPT_CMDMODE
c_func
(paren
l_int|0
comma
l_string|&quot;skip&quot;
comma
op_amp
id|resume
comma
id|N_
c_func
(paren
l_string|&quot;skip the current patch&quot;
)paren
comma
id|RESUME_SKIP
)paren
comma
id|OPT_CMDMODE
c_func
(paren
l_int|0
comma
l_string|&quot;abort&quot;
comma
op_amp
id|resume
comma
id|N_
c_func
(paren
l_string|&quot;restore the original branch and abort the patching operation.&quot;
)paren
comma
id|RESUME_ABORT
)paren
comma
id|OPT_BOOL
c_func
(paren
l_int|0
comma
l_string|&quot;committer-date-is-author-date&quot;
comma
op_amp
id|state.committer_date_is_author_date
comma
id|N_
c_func
(paren
l_string|&quot;lie about committer date&quot;
)paren
)paren
comma
id|OPT_BOOL
c_func
(paren
l_int|0
comma
l_string|&quot;ignore-date&quot;
comma
op_amp
id|state.ignore_date
comma
id|N_
c_func
(paren
l_string|&quot;use current timestamp for author date&quot;
)paren
)paren
comma
id|OPT_RERERE_AUTOUPDATE
c_func
(paren
op_amp
id|state.allow_rerere_autoupdate
)paren
comma
(brace
id|OPTION_STRING
comma
l_char|&squot;S&squot;
comma
l_string|&quot;gpg-sign&quot;
comma
op_amp
id|state.sign_commit
comma
id|N_
c_func
(paren
l_string|&quot;key-id&quot;
)paren
comma
id|N_
c_func
(paren
l_string|&quot;GPG-sign commits&quot;
)paren
comma
id|PARSE_OPT_OPTARG
comma
l_int|NULL
comma
(paren
r_intptr
)paren
l_string|&quot;&quot;
)brace
comma
id|OPT_HIDDEN_BOOL
c_func
(paren
l_int|0
comma
l_string|&quot;rebasing&quot;
comma
op_amp
id|state.rebasing
comma
id|N_
c_func
(paren
l_string|&quot;(internal use for git-rebase)&quot;
)paren
)paren
comma
id|OPT_END
c_func
(paren
)paren
)brace
suffix:semicolon
multiline_comment|/*&n;&t; * NEEDSWORK: Once all the features of git-am.sh have been&n;&t; * re-implemented in builtin/am.c, this preamble can be removed.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|getenv
c_func
(paren
l_string|&quot;_GIT_USE_BUILTIN_AM&quot;
)paren
)paren
(brace
r_const
r_char
op_star
id|path
op_assign
id|mkpath
c_func
(paren
l_string|&quot;%s/git-am&quot;
comma
id|git_exec_path
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sane_execvp
c_func
(paren
id|path
comma
(paren
r_char
op_star
op_star
)paren
id|argv
)paren
OL
l_int|0
)paren
id|die_errno
c_func
(paren
l_string|&quot;could not exec %s&quot;
comma
id|path
)paren
suffix:semicolon
)brace
r_else
(brace
id|prefix
op_assign
id|setup_git_directory
c_func
(paren
)paren
suffix:semicolon
id|trace_repo_setup
c_func
(paren
id|prefix
)paren
suffix:semicolon
id|setup_work_tree
c_func
(paren
)paren
suffix:semicolon
)brace
id|git_config
c_func
(paren
id|git_default_config
comma
l_int|NULL
)paren
suffix:semicolon
id|am_state_init
c_func
(paren
op_amp
id|state
comma
id|git_path
c_func
(paren
l_string|&quot;rebase-apply&quot;
)paren
)paren
suffix:semicolon
id|argc
op_assign
id|parse_options
c_func
(paren
id|argc
comma
id|argv
comma
id|prefix
comma
id|options
comma
id|usage
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_index_preload
c_func
(paren
op_amp
id|the_index
comma
l_int|NULL
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;failed to read the index&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|am_in_progress
c_func
(paren
op_amp
id|state
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Catch user error to feed us patches when there is a session&n;&t;&t; * in progress:&n;&t;&t; *&n;&t;&t; * 1. mbox path(s) are provided on the command-line.&n;&t;&t; * 2. stdin is not a tty: the user is trying to feed us a patch&n;&t;&t; *    from standard input. This is somewhat unreliable -- stdin&n;&t;&t; *    could be /dev/null for example and the caller did not&n;&t;&t; *    intend to feed us a patch but wanted to continue&n;&t;&t; *    unattended.&n;&t;&t; */
r_if
c_cond
(paren
id|argc
op_logical_or
(paren
id|resume
op_eq
id|RESUME_FALSE
op_logical_and
op_logical_neg
id|isatty
c_func
(paren
l_int|0
)paren
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;previous rebase directory %s still exists but mbox given.&quot;
)paren
comma
id|state.dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|resume
op_eq
id|RESUME_FALSE
)paren
id|resume
op_assign
id|RESUME_APPLY
suffix:semicolon
id|am_load
c_func
(paren
op_amp
id|state
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|argv_array
id|paths
op_assign
id|ARGV_ARRAY_INIT
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Handle stray state directory in the independent-run case. In&n;&t;&t; * the --rebasing case, it is up to the caller to take care of&n;&t;&t; * stray directories.&n;&t;&t; */
r_if
c_cond
(paren
id|file_exists
c_func
(paren
id|state.dir
)paren
op_logical_and
op_logical_neg
id|state.rebasing
)paren
(brace
r_if
c_cond
(paren
id|resume
op_eq
id|RESUME_ABORT
)paren
(brace
id|am_destroy
c_func
(paren
op_amp
id|state
)paren
suffix:semicolon
id|am_state_release
c_func
(paren
op_amp
id|state
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Stray %s directory found.&bslash;n&quot;
l_string|&quot;Use &bslash;&quot;git am --abort&bslash;&quot; to remove it.&quot;
)paren
comma
id|state.dir
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|resume
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Resolve operation not in progress, we are not resuming.&quot;
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|argc
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|is_absolute_path
c_func
(paren
id|argv
(braket
id|i
)braket
)paren
op_logical_or
op_logical_neg
id|prefix
)paren
id|argv_array_push
c_func
(paren
op_amp
id|paths
comma
id|argv
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|argv_array_push
c_func
(paren
op_amp
id|paths
comma
id|mkpath
c_func
(paren
l_string|&quot;%s/%s&quot;
comma
id|prefix
comma
id|argv
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
)brace
id|am_setup
c_func
(paren
op_amp
id|state
comma
id|patch_format
comma
id|paths.argv
comma
id|keep_cr
)paren
suffix:semicolon
id|argv_array_clear
c_func
(paren
op_amp
id|paths
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|resume
)paren
(brace
r_case
id|RESUME_FALSE
suffix:colon
id|am_run
c_func
(paren
op_amp
id|state
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RESUME_APPLY
suffix:colon
id|am_run
c_func
(paren
op_amp
id|state
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RESUME_RESOLVED
suffix:colon
id|am_resolve
c_func
(paren
op_amp
id|state
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RESUME_SKIP
suffix:colon
id|am_skip
c_func
(paren
op_amp
id|state
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RESUME_ABORT
suffix:colon
id|am_abort
c_func
(paren
op_amp
id|state
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|die
c_func
(paren
l_string|&quot;BUG: invalid resume value&quot;
)paren
suffix:semicolon
)brace
id|am_state_release
c_func
(paren
op_amp
id|state
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
