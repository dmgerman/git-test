multiline_comment|/*&n; * Builtin &quot;git am&quot;&n; *&n; * Based on git-am.sh by Junio C Hamano.&n; */
macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;builtin.h&quot;
macro_line|#include &quot;exec_cmd.h&quot;
macro_line|#include &quot;parse-options.h&quot;
macro_line|#include &quot;dir.h&quot;
macro_line|#include &quot;run-command.h&quot;
macro_line|#include &quot;quote.h&quot;
macro_line|#include &quot;lockfile.h&quot;
macro_line|#include &quot;cache-tree.h&quot;
macro_line|#include &quot;refs.h&quot;
macro_line|#include &quot;commit.h&quot;
macro_line|#include &quot;diff.h&quot;
macro_line|#include &quot;diffcore.h&quot;
macro_line|#include &quot;unpack-trees.h&quot;
macro_line|#include &quot;branch.h&quot;
multiline_comment|/**&n; * Returns 1 if the file is empty or does not exist, 0 otherwise.&n; */
DECL|function|is_empty_file
r_static
r_int
id|is_empty_file
c_func
(paren
r_const
r_char
op_star
id|filename
)paren
(brace
r_struct
id|stat
id|st
suffix:semicolon
r_if
c_cond
(paren
id|stat
c_func
(paren
id|filename
comma
op_amp
id|st
)paren
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|errno
op_eq
id|ENOENT
)paren
r_return
l_int|1
suffix:semicolon
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;could not stat %s&quot;
)paren
comma
id|filename
)paren
suffix:semicolon
)brace
r_return
op_logical_neg
id|st.st_size
suffix:semicolon
)brace
multiline_comment|/**&n; * Like strbuf_getline(), but treats both &squot;&bslash;n&squot; and &quot;&bslash;r&bslash;n&quot; as line terminators.&n; */
DECL|function|strbuf_getline_crlf
r_static
r_int
id|strbuf_getline_crlf
c_func
(paren
r_struct
id|strbuf
op_star
id|sb
comma
id|FILE
op_star
id|fp
)paren
(brace
r_if
c_cond
(paren
id|strbuf_getwholeline
c_func
(paren
id|sb
comma
id|fp
comma
l_char|&squot;&bslash;n&squot;
)paren
)paren
r_return
id|EOF
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;buf
(braket
id|sb-&gt;len
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|strbuf_setlen
c_func
(paren
id|sb
comma
id|sb-&gt;len
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;len
OG
l_int|0
op_logical_and
id|sb-&gt;buf
(braket
id|sb-&gt;len
l_int|1
)braket
op_eq
l_char|&squot;&bslash;r&squot;
)paren
id|strbuf_setlen
c_func
(paren
id|sb
comma
id|sb-&gt;len
l_int|1
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * Returns the length of the first line of msg.&n; */
DECL|function|linelen
r_static
r_int
id|linelen
c_func
(paren
r_const
r_char
op_star
id|msg
)paren
(brace
r_return
id|strchrnul
c_func
(paren
id|msg
comma
l_char|&squot;&bslash;n&squot;
)paren
id|msg
suffix:semicolon
)brace
DECL|enum|patch_format
r_enum
id|patch_format
(brace
DECL|enumerator|PATCH_FORMAT_UNKNOWN
id|PATCH_FORMAT_UNKNOWN
op_assign
l_int|0
comma
DECL|enumerator|PATCH_FORMAT_MBOX
id|PATCH_FORMAT_MBOX
)brace
suffix:semicolon
DECL|struct|am_state
r_struct
id|am_state
(brace
multiline_comment|/* state directory path */
DECL|member|dir
r_char
op_star
id|dir
suffix:semicolon
multiline_comment|/* current and last patch numbers, 1-indexed */
DECL|member|cur
r_int
id|cur
suffix:semicolon
DECL|member|last
r_int
id|last
suffix:semicolon
multiline_comment|/* commit metadata and message */
DECL|member|author_name
r_char
op_star
id|author_name
suffix:semicolon
DECL|member|author_email
r_char
op_star
id|author_email
suffix:semicolon
DECL|member|author_date
r_char
op_star
id|author_date
suffix:semicolon
DECL|member|msg
r_char
op_star
id|msg
suffix:semicolon
DECL|member|msg_len
r_int
id|msg_len
suffix:semicolon
multiline_comment|/* number of digits in patch filename */
DECL|member|prec
r_int
id|prec
suffix:semicolon
multiline_comment|/* various operating modes and command line options */
DECL|member|quiet
r_int
id|quiet
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/**&n; * Initializes am_state with the default values. The state directory is set to&n; * dir.&n; */
DECL|function|am_state_init
r_static
r_void
id|am_state_init
c_func
(paren
r_struct
id|am_state
op_star
id|state
comma
r_const
r_char
op_star
id|dir
)paren
(brace
id|memset
c_func
(paren
id|state
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|state
)paren
)paren
suffix:semicolon
m_assert
(paren
id|dir
)paren
suffix:semicolon
id|state-&gt;dir
op_assign
id|xstrdup
c_func
(paren
id|dir
)paren
suffix:semicolon
id|state-&gt;prec
op_assign
l_int|4
suffix:semicolon
)brace
multiline_comment|/**&n; * Releases memory allocated by an am_state.&n; */
DECL|function|am_state_release
r_static
r_void
id|am_state_release
c_func
(paren
r_struct
id|am_state
op_star
id|state
)paren
(brace
id|free
c_func
(paren
id|state-&gt;dir
)paren
suffix:semicolon
id|free
c_func
(paren
id|state-&gt;author_name
)paren
suffix:semicolon
id|free
c_func
(paren
id|state-&gt;author_email
)paren
suffix:semicolon
id|free
c_func
(paren
id|state-&gt;author_date
)paren
suffix:semicolon
id|free
c_func
(paren
id|state-&gt;msg
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Returns path relative to the am_state directory.&n; */
DECL|function|am_path
r_static
r_inline
r_const
r_char
op_star
id|am_path
c_func
(paren
r_const
r_struct
id|am_state
op_star
id|state
comma
r_const
r_char
op_star
id|path
)paren
(brace
r_return
id|mkpath
c_func
(paren
l_string|&quot;%s/%s&quot;
comma
id|state-&gt;dir
comma
id|path
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * If state-&gt;quiet is false, calls fprintf(fp, fmt, ...), and appends a newline&n; * at the end.&n; */
DECL|function|say
r_static
r_void
id|say
c_func
(paren
r_const
r_struct
id|am_state
op_star
id|state
comma
id|FILE
op_star
id|fp
comma
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
id|va_list
id|ap
suffix:semicolon
id|va_start
c_func
(paren
id|ap
comma
id|fmt
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|state-&gt;quiet
)paren
(brace
id|vfprintf
c_func
(paren
id|fp
comma
id|fmt
comma
id|ap
)paren
suffix:semicolon
id|putc
c_func
(paren
l_char|&squot;&bslash;n&squot;
comma
id|fp
)paren
suffix:semicolon
)brace
id|va_end
c_func
(paren
id|ap
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Returns 1 if there is an am session in progress, 0 otherwise.&n; */
DECL|function|am_in_progress
r_static
r_int
id|am_in_progress
c_func
(paren
r_const
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_struct
id|stat
id|st
suffix:semicolon
r_if
c_cond
(paren
id|lstat
c_func
(paren
id|state-&gt;dir
comma
op_amp
id|st
)paren
OL
l_int|0
op_logical_or
op_logical_neg
id|S_ISDIR
c_func
(paren
id|st.st_mode
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|lstat
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;last&quot;
)paren
comma
op_amp
id|st
)paren
op_logical_or
op_logical_neg
id|S_ISREG
c_func
(paren
id|st.st_mode
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|lstat
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;next&quot;
)paren
comma
op_amp
id|st
)paren
op_logical_or
op_logical_neg
id|S_ISREG
c_func
(paren
id|st.st_mode
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * Reads the contents of `file` in the `state` directory into `sb`. Returns the&n; * number of bytes read on success, -1 if the file does not exist. If `trim` is&n; * set, trailing whitespace will be removed.&n; */
DECL|function|read_state_file
r_static
r_int
id|read_state_file
c_func
(paren
r_struct
id|strbuf
op_star
id|sb
comma
r_const
r_struct
id|am_state
op_star
id|state
comma
r_const
r_char
op_star
id|file
comma
r_int
id|trim
)paren
(brace
id|strbuf_reset
c_func
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strbuf_read_file
c_func
(paren
id|sb
comma
id|am_path
c_func
(paren
id|state
comma
id|file
)paren
comma
l_int|0
)paren
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|trim
)paren
id|strbuf_trim
c_func
(paren
id|sb
)paren
suffix:semicolon
r_return
id|sb-&gt;len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|errno
op_eq
id|ENOENT
)paren
r_return
l_int|1
suffix:semicolon
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;could not read &squot;%s&squot;&quot;
)paren
comma
id|am_path
c_func
(paren
id|state
comma
id|file
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Reads a KEY=VALUE shell variable assignment from `fp`, returning the VALUE&n; * as a newly-allocated string. VALUE must be a quoted string, and the KEY must&n; * match `key`. Returns NULL on failure.&n; *&n; * This is used by read_author_script() to read the GIT_AUTHOR_* variables from&n; * the author-script.&n; */
DECL|function|read_shell_var
r_static
r_char
op_star
id|read_shell_var
c_func
(paren
id|FILE
op_star
id|fp
comma
r_const
r_char
op_star
id|key
)paren
(brace
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
r_const
r_char
op_star
id|str
suffix:semicolon
r_if
c_cond
(paren
id|strbuf_getline
c_func
(paren
op_amp
id|sb
comma
id|fp
comma
l_char|&squot;&bslash;n&squot;
)paren
)paren
r_goto
id|fail
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skip_prefix
c_func
(paren
id|sb.buf
comma
id|key
comma
op_amp
id|str
)paren
)paren
r_goto
id|fail
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skip_prefix
c_func
(paren
id|str
comma
l_string|&quot;=&quot;
comma
op_amp
id|str
)paren
)paren
r_goto
id|fail
suffix:semicolon
id|strbuf_remove
c_func
(paren
op_amp
id|sb
comma
l_int|0
comma
id|str
id|sb.buf
)paren
suffix:semicolon
id|str
op_assign
id|sq_dequote
c_func
(paren
id|sb.buf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|str
)paren
r_goto
id|fail
suffix:semicolon
r_return
id|strbuf_detach
c_func
(paren
op_amp
id|sb
comma
l_int|NULL
)paren
suffix:semicolon
id|fail
suffix:colon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; * Reads and parses the state directory&squot;s &quot;author-script&quot; file, and sets&n; * state-&gt;author_name, state-&gt;author_email and state-&gt;author_date accordingly.&n; * Returns 0 on success, -1 if the file could not be parsed.&n; *&n; * The author script is of the format:&n; *&n; *&t;GIT_AUTHOR_NAME=&squot;$author_name&squot;&n; *&t;GIT_AUTHOR_EMAIL=&squot;$author_email&squot;&n; *&t;GIT_AUTHOR_DATE=&squot;$author_date&squot;&n; *&n; * where $author_name, $author_email and $author_date are quoted. We are strict&n; * with our parsing, as the file was meant to be eval&squot;d in the old git-am.sh&n; * script, and thus if the file differs from what this function expects, it is&n; * better to bail out than to do something that the user does not expect.&n; */
DECL|function|read_author_script
r_static
r_int
id|read_author_script
c_func
(paren
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_const
r_char
op_star
id|filename
op_assign
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;author-script&quot;
)paren
suffix:semicolon
id|FILE
op_star
id|fp
suffix:semicolon
m_assert
(paren
op_logical_neg
id|state-&gt;author_name
)paren
suffix:semicolon
m_assert
(paren
op_logical_neg
id|state-&gt;author_email
)paren
suffix:semicolon
m_assert
(paren
op_logical_neg
id|state-&gt;author_date
)paren
suffix:semicolon
id|fp
op_assign
id|fopen
c_func
(paren
id|filename
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fp
)paren
(brace
r_if
c_cond
(paren
id|errno
op_eq
id|ENOENT
)paren
r_return
l_int|0
suffix:semicolon
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;could not open &squot;%s&squot; for reading&quot;
)paren
comma
id|filename
)paren
suffix:semicolon
)brace
id|state-&gt;author_name
op_assign
id|read_shell_var
c_func
(paren
id|fp
comma
l_string|&quot;GIT_AUTHOR_NAME&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|state-&gt;author_name
)paren
(brace
id|fclose
c_func
(paren
id|fp
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|state-&gt;author_email
op_assign
id|read_shell_var
c_func
(paren
id|fp
comma
l_string|&quot;GIT_AUTHOR_EMAIL&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|state-&gt;author_email
)paren
(brace
id|fclose
c_func
(paren
id|fp
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|state-&gt;author_date
op_assign
id|read_shell_var
c_func
(paren
id|fp
comma
l_string|&quot;GIT_AUTHOR_DATE&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|state-&gt;author_date
)paren
(brace
id|fclose
c_func
(paren
id|fp
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fgetc
c_func
(paren
id|fp
)paren
op_ne
id|EOF
)paren
(brace
id|fclose
c_func
(paren
id|fp
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|fclose
c_func
(paren
id|fp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * Saves state-&gt;author_name, state-&gt;author_email and state-&gt;author_date in the&n; * state directory&squot;s &quot;author-script&quot; file.&n; */
DECL|function|write_author_script
r_static
r_void
id|write_author_script
c_func
(paren
r_const
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|sb
comma
l_string|&quot;GIT_AUTHOR_NAME=&quot;
)paren
suffix:semicolon
id|sq_quote_buf
c_func
(paren
op_amp
id|sb
comma
id|state-&gt;author_name
)paren
suffix:semicolon
id|strbuf_addch
c_func
(paren
op_amp
id|sb
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|sb
comma
l_string|&quot;GIT_AUTHOR_EMAIL=&quot;
)paren
suffix:semicolon
id|sq_quote_buf
c_func
(paren
op_amp
id|sb
comma
id|state-&gt;author_email
)paren
suffix:semicolon
id|strbuf_addch
c_func
(paren
op_amp
id|sb
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|sb
comma
l_string|&quot;GIT_AUTHOR_DATE=&quot;
)paren
suffix:semicolon
id|sq_quote_buf
c_func
(paren
op_amp
id|sb
comma
id|state-&gt;author_date
)paren
suffix:semicolon
id|strbuf_addch
c_func
(paren
op_amp
id|sb
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|write_file
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;author-script&quot;
)paren
comma
l_int|1
comma
l_string|&quot;%s&quot;
comma
id|sb.buf
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Reads the commit message from the state directory&squot;s &quot;final-commit&quot; file,&n; * setting state-&gt;msg to its contents and state-&gt;msg_len to the length of its&n; * contents in bytes.&n; *&n; * Returns 0 on success, -1 if the file does not exist.&n; */
DECL|function|read_commit_msg
r_static
r_int
id|read_commit_msg
c_func
(paren
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
m_assert
(paren
op_logical_neg
id|state-&gt;msg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_state_file
c_func
(paren
op_amp
id|sb
comma
id|state
comma
l_string|&quot;final-commit&quot;
comma
l_int|0
)paren
OL
l_int|0
)paren
(brace
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|state-&gt;msg
op_assign
id|strbuf_detach
c_func
(paren
op_amp
id|sb
comma
op_amp
id|state-&gt;msg_len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * Saves state-&gt;msg in the state directory&squot;s &quot;final-commit&quot; file.&n; */
DECL|function|write_commit_msg
r_static
r_void
id|write_commit_msg
c_func
(paren
r_const
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_int
id|fd
suffix:semicolon
r_const
r_char
op_star
id|filename
op_assign
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;final-commit&quot;
)paren
suffix:semicolon
id|fd
op_assign
id|xopen
c_func
(paren
id|filename
comma
id|O_WRONLY
op_or
id|O_CREAT
comma
l_int|0666
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write_in_full
c_func
(paren
id|fd
comma
id|state-&gt;msg
comma
id|state-&gt;msg_len
)paren
OL
l_int|0
)paren
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;could not write to %s&quot;
)paren
comma
id|filename
)paren
suffix:semicolon
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Loads state from disk.&n; */
DECL|function|am_load
r_static
r_void
id|am_load
c_func
(paren
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
r_if
c_cond
(paren
id|read_state_file
c_func
(paren
op_amp
id|sb
comma
id|state
comma
l_string|&quot;next&quot;
comma
l_int|1
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;BUG: state file &squot;next&squot; does not exist&quot;
)paren
suffix:semicolon
id|state-&gt;cur
op_assign
id|strtol
c_func
(paren
id|sb.buf
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_state_file
c_func
(paren
op_amp
id|sb
comma
id|state
comma
l_string|&quot;last&quot;
comma
l_int|1
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;BUG: state file &squot;last&squot; does not exist&quot;
)paren
suffix:semicolon
id|state-&gt;last
op_assign
id|strtol
c_func
(paren
id|sb.buf
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_author_script
c_func
(paren
id|state
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;could not parse author script&quot;
)paren
)paren
suffix:semicolon
id|read_commit_msg
c_func
(paren
id|state
)paren
suffix:semicolon
id|read_state_file
c_func
(paren
op_amp
id|sb
comma
id|state
comma
l_string|&quot;quiet&quot;
comma
l_int|1
)paren
suffix:semicolon
id|state-&gt;quiet
op_assign
op_logical_neg
id|strcmp
c_func
(paren
id|sb.buf
comma
l_string|&quot;t&quot;
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Removes the am_state directory, forcefully terminating the current am&n; * session.&n; */
DECL|function|am_destroy
r_static
r_void
id|am_destroy
c_func
(paren
r_const
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|sb
comma
id|state-&gt;dir
)paren
suffix:semicolon
id|remove_dir_recursively
c_func
(paren
op_amp
id|sb
comma
l_int|0
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Determines if the file looks like a piece of RFC2822 mail by grabbing all&n; * non-indented lines and checking if they look like they begin with valid&n; * header field names.&n; *&n; * Returns 1 if the file looks like a piece of mail, 0 otherwise.&n; */
DECL|function|is_mail
r_static
r_int
id|is_mail
c_func
(paren
id|FILE
op_star
id|fp
)paren
(brace
r_const
r_char
op_star
id|header_regex
op_assign
l_string|&quot;^[!-9;-~]+:&quot;
suffix:semicolon
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
id|regex_t
id|regex
suffix:semicolon
r_int
id|ret
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|fseek
c_func
(paren
id|fp
comma
l_int|0L
comma
id|SEEK_SET
)paren
)paren
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;fseek failed&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|regcomp
c_func
(paren
op_amp
id|regex
comma
id|header_regex
comma
id|REG_NOSUB
op_or
id|REG_EXTENDED
)paren
)paren
id|die
c_func
(paren
l_string|&quot;invalid pattern: %s&quot;
comma
id|header_regex
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|strbuf_getline_crlf
c_func
(paren
op_amp
id|sb
comma
id|fp
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sb.len
)paren
r_break
suffix:semicolon
multiline_comment|/* End of header */
multiline_comment|/* Ignore indented folded lines */
r_if
c_cond
(paren
op_star
id|sb.buf
op_eq
l_char|&squot;&bslash;t&squot;
op_logical_or
op_star
id|sb.buf
op_eq
l_char|&squot; &squot;
)paren
r_continue
suffix:semicolon
multiline_comment|/* It&squot;s a header if it matches header_regex */
r_if
c_cond
(paren
id|regexec
c_func
(paren
op_amp
id|regex
comma
id|sb.buf
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
)paren
)paren
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
)brace
id|done
suffix:colon
id|regfree
c_func
(paren
op_amp
id|regex
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; * Attempts to detect the patch_format of the patches contained in `paths`,&n; * returning the PATCH_FORMAT_* enum value. Returns PATCH_FORMAT_UNKNOWN if&n; * detection fails.&n; */
DECL|function|detect_patch_format
r_static
r_int
id|detect_patch_format
c_func
(paren
r_const
r_char
op_star
op_star
id|paths
)paren
(brace
r_enum
id|patch_format
id|ret
op_assign
id|PATCH_FORMAT_UNKNOWN
suffix:semicolon
r_struct
id|strbuf
id|l1
op_assign
id|STRBUF_INIT
suffix:semicolon
id|FILE
op_star
id|fp
suffix:semicolon
multiline_comment|/*&n;&t; * We default to mbox format if input is from stdin and for directories&n;&t; */
r_if
c_cond
(paren
op_logical_neg
op_star
id|paths
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
op_star
id|paths
comma
l_string|&quot;-&quot;
)paren
op_logical_or
id|is_directory
c_func
(paren
op_star
id|paths
)paren
)paren
r_return
id|PATCH_FORMAT_MBOX
suffix:semicolon
multiline_comment|/*&n;&t; * Otherwise, check the first few lines of the first patch, starting&n;&t; * from the first non-blank line, to try to detect its format.&n;&t; */
id|fp
op_assign
id|xfopen
c_func
(paren
op_star
id|paths
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|strbuf_getline_crlf
c_func
(paren
op_amp
id|l1
comma
id|fp
)paren
)paren
(brace
r_if
c_cond
(paren
id|l1.len
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|l1.buf
comma
l_string|&quot;From &quot;
)paren
op_logical_or
id|starts_with
c_func
(paren
id|l1.buf
comma
l_string|&quot;From: &quot;
)paren
)paren
(brace
id|ret
op_assign
id|PATCH_FORMAT_MBOX
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_if
c_cond
(paren
id|l1.len
op_logical_and
id|is_mail
c_func
(paren
id|fp
)paren
)paren
(brace
id|ret
op_assign
id|PATCH_FORMAT_MBOX
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|done
suffix:colon
id|fclose
c_func
(paren
id|fp
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|l1
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; * Splits out individual email patches from `paths`, where each path is either&n; * a mbox file or a Maildir. Returns 0 on success, -1 on failure.&n; */
DECL|function|split_mail_mbox
r_static
r_int
id|split_mail_mbox
c_func
(paren
r_struct
id|am_state
op_star
id|state
comma
r_const
r_char
op_star
op_star
id|paths
)paren
(brace
r_struct
id|child_process
id|cp
op_assign
id|CHILD_PROCESS_INIT
suffix:semicolon
r_struct
id|strbuf
id|last
op_assign
id|STRBUF_INIT
suffix:semicolon
id|cp.git_cmd
op_assign
l_int|1
suffix:semicolon
id|argv_array_push
c_func
(paren
op_amp
id|cp.args
comma
l_string|&quot;mailsplit&quot;
)paren
suffix:semicolon
id|argv_array_pushf
c_func
(paren
op_amp
id|cp.args
comma
l_string|&quot;-d%d&quot;
comma
id|state-&gt;prec
)paren
suffix:semicolon
id|argv_array_pushf
c_func
(paren
op_amp
id|cp.args
comma
l_string|&quot;-o%s&quot;
comma
id|state-&gt;dir
)paren
suffix:semicolon
id|argv_array_push
c_func
(paren
op_amp
id|cp.args
comma
l_string|&quot;-b&quot;
)paren
suffix:semicolon
id|argv_array_push
c_func
(paren
op_amp
id|cp.args
comma
l_string|&quot;--&quot;
)paren
suffix:semicolon
id|argv_array_pushv
c_func
(paren
op_amp
id|cp.args
comma
id|paths
)paren
suffix:semicolon
r_if
c_cond
(paren
id|capture_command
c_func
(paren
op_amp
id|cp
comma
op_amp
id|last
comma
l_int|8
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|state-&gt;cur
op_assign
l_int|1
suffix:semicolon
id|state-&gt;last
op_assign
id|strtol
c_func
(paren
id|last.buf
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * Splits a list of files/directories into individual email patches. Each path&n; * in `paths` must be a file/directory that is formatted according to&n; * `patch_format`.&n; *&n; * Once split out, the individual email patches will be stored in the state&n; * directory, with each patch&squot;s filename being its index, padded to state-&gt;prec&n; * digits.&n; *&n; * state-&gt;cur will be set to the index of the first mail, and state-&gt;last will&n; * be set to the index of the last mail.&n; *&n; * Returns 0 on success, -1 on failure.&n; */
DECL|function|split_mail
r_static
r_int
id|split_mail
c_func
(paren
r_struct
id|am_state
op_star
id|state
comma
r_enum
id|patch_format
id|patch_format
comma
r_const
r_char
op_star
op_star
id|paths
)paren
(brace
r_switch
c_cond
(paren
id|patch_format
)paren
(brace
r_case
id|PATCH_FORMAT_MBOX
suffix:colon
r_return
id|split_mail_mbox
c_func
(paren
id|state
comma
id|paths
)paren
suffix:semicolon
r_default
suffix:colon
id|die
c_func
(paren
l_string|&quot;BUG: invalid patch_format&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * Setup a new am session for applying patches&n; */
DECL|function|am_setup
r_static
r_void
id|am_setup
c_func
(paren
r_struct
id|am_state
op_star
id|state
comma
r_enum
id|patch_format
id|patch_format
comma
r_const
r_char
op_star
op_star
id|paths
)paren
(brace
r_int
r_char
id|curr_head
(braket
id|GIT_SHA1_RAWSZ
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|patch_format
)paren
id|patch_format
op_assign
id|detect_patch_format
c_func
(paren
id|paths
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|patch_format
)paren
(brace
id|fprintf_ln
c_func
(paren
id|stderr
comma
id|_
c_func
(paren
l_string|&quot;Patch format detection failed.&quot;
)paren
)paren
suffix:semicolon
m_exit
(paren
l_int|128
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mkdir
c_func
(paren
id|state-&gt;dir
comma
l_int|0777
)paren
OL
l_int|0
op_logical_and
id|errno
op_ne
id|EEXIST
)paren
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;failed to create directory &squot;%s&squot;&quot;
)paren
comma
id|state-&gt;dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|split_mail
c_func
(paren
id|state
comma
id|patch_format
comma
id|paths
)paren
OL
l_int|0
)paren
(brace
id|am_destroy
c_func
(paren
id|state
)paren
suffix:semicolon
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Failed to split patches.&quot;
)paren
)paren
suffix:semicolon
)brace
id|write_file
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;quiet&quot;
)paren
comma
l_int|1
comma
id|state-&gt;quiet
ques
c_cond
l_string|&quot;t&quot;
suffix:colon
l_string|&quot;f&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|get_sha1
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|curr_head
)paren
)paren
(brace
id|write_file
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;abort-safety&quot;
)paren
comma
l_int|1
comma
l_string|&quot;%s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|curr_head
)paren
)paren
suffix:semicolon
id|update_ref
c_func
(paren
l_string|&quot;am&quot;
comma
l_string|&quot;ORIG_HEAD&quot;
comma
id|curr_head
comma
l_int|NULL
comma
l_int|0
comma
id|UPDATE_REFS_DIE_ON_ERR
)paren
suffix:semicolon
)brace
r_else
(brace
id|write_file
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;abort-safety&quot;
)paren
comma
l_int|1
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
id|delete_ref
c_func
(paren
l_string|&quot;ORIG_HEAD&quot;
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * NOTE: Since the &quot;next&quot; and &quot;last&quot; files determine if an am_state&n;&t; * session is in progress, they should be written last.&n;&t; */
id|write_file
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;next&quot;
)paren
comma
l_int|1
comma
l_string|&quot;%d&quot;
comma
id|state-&gt;cur
)paren
suffix:semicolon
id|write_file
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;last&quot;
)paren
comma
l_int|1
comma
l_string|&quot;%d&quot;
comma
id|state-&gt;last
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Increments the patch pointer, and cleans am_state for the application of the&n; * next patch.&n; */
DECL|function|am_next
r_static
r_void
id|am_next
c_func
(paren
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_int
r_char
id|head
(braket
id|GIT_SHA1_RAWSZ
)braket
suffix:semicolon
id|free
c_func
(paren
id|state-&gt;author_name
)paren
suffix:semicolon
id|state-&gt;author_name
op_assign
l_int|NULL
suffix:semicolon
id|free
c_func
(paren
id|state-&gt;author_email
)paren
suffix:semicolon
id|state-&gt;author_email
op_assign
l_int|NULL
suffix:semicolon
id|free
c_func
(paren
id|state-&gt;author_date
)paren
suffix:semicolon
id|state-&gt;author_date
op_assign
l_int|NULL
suffix:semicolon
id|free
c_func
(paren
id|state-&gt;msg
)paren
suffix:semicolon
id|state-&gt;msg
op_assign
l_int|NULL
suffix:semicolon
id|state-&gt;msg_len
op_assign
l_int|0
suffix:semicolon
id|unlink
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;author-script&quot;
)paren
)paren
suffix:semicolon
id|unlink
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;final-commit&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|get_sha1
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|head
)paren
)paren
id|write_file
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;abort-safety&quot;
)paren
comma
l_int|1
comma
l_string|&quot;%s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|head
)paren
)paren
suffix:semicolon
r_else
id|write_file
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;abort-safety&quot;
)paren
comma
l_int|1
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
id|state-&gt;cur
op_increment
suffix:semicolon
id|write_file
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;next&quot;
)paren
comma
l_int|1
comma
l_string|&quot;%d&quot;
comma
id|state-&gt;cur
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Returns the filename of the current patch email.&n; */
DECL|function|msgnum
r_static
r_const
r_char
op_star
id|msgnum
c_func
(paren
r_const
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_static
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
id|strbuf_reset
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
id|sb
comma
l_string|&quot;%0*d&quot;
comma
id|state-&gt;prec
comma
id|state-&gt;cur
)paren
suffix:semicolon
r_return
id|sb.buf
suffix:semicolon
)brace
multiline_comment|/**&n; * Refresh and write index.&n; */
DECL|function|refresh_and_write_cache
r_static
r_void
id|refresh_and_write_cache
c_func
(paren
r_void
)paren
(brace
r_struct
id|lock_file
op_star
id|lock_file
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|lock_file
)paren
)paren
suffix:semicolon
id|hold_locked_index
c_func
(paren
id|lock_file
comma
l_int|1
)paren
suffix:semicolon
id|refresh_cache
c_func
(paren
id|REFRESH_QUIET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write_locked_index
c_func
(paren
op_amp
id|the_index
comma
id|lock_file
comma
id|COMMIT_LOCK
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;unable to write index file&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Returns 1 if the index differs from HEAD, 0 otherwise. When on an unborn&n; * branch, returns 1 if there are entries in the index, 0 otherwise. If an&n; * strbuf is provided, the space-separated list of files that differ will be&n; * appended to it.&n; */
DECL|function|index_has_changes
r_static
r_int
id|index_has_changes
c_func
(paren
r_struct
id|strbuf
op_star
id|sb
)paren
(brace
r_int
r_char
id|head
(braket
id|GIT_SHA1_RAWSZ
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|get_sha1_tree
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|head
)paren
)paren
(brace
r_struct
id|diff_options
id|opt
suffix:semicolon
id|diff_setup
c_func
(paren
op_amp
id|opt
)paren
suffix:semicolon
id|DIFF_OPT_SET
c_func
(paren
op_amp
id|opt
comma
id|EXIT_WITH_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sb
)paren
id|DIFF_OPT_SET
c_func
(paren
op_amp
id|opt
comma
id|QUICK
)paren
suffix:semicolon
id|do_diff_cache
c_func
(paren
id|head
comma
op_amp
id|opt
)paren
suffix:semicolon
id|diffcore_std
c_func
(paren
op_amp
id|opt
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|sb
op_logical_and
id|i
OL
id|diff_queued_diff.nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
)paren
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|diff_queued_diff.queue
(braket
id|i
)braket
op_member_access_from_pointer
id|two-&gt;path
)paren
suffix:semicolon
)brace
id|diff_flush
c_func
(paren
op_amp
id|opt
)paren
suffix:semicolon
r_return
id|DIFF_OPT_TST
c_func
(paren
op_amp
id|opt
comma
id|HAS_CHANGES
)paren
op_ne
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|sb
op_logical_and
id|i
OL
id|active_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
)paren
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|active_cache
(braket
id|i
)braket
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
)brace
r_return
op_logical_neg
op_logical_neg
id|active_nr
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * Parses `mail` using git-mailinfo, extracting its patch and authorship info.&n; * state-&gt;msg will be set to the patch message. state-&gt;author_name,&n; * state-&gt;author_email and state-&gt;author_date will be set to the patch author&squot;s&n; * name, email and date respectively. The patch body will be written to the&n; * state directory&squot;s &quot;patch&quot; file.&n; *&n; * Returns 1 if the patch should be skipped, 0 otherwise.&n; */
DECL|function|parse_mail
r_static
r_int
id|parse_mail
c_func
(paren
r_struct
id|am_state
op_star
id|state
comma
r_const
r_char
op_star
id|mail
)paren
(brace
id|FILE
op_star
id|fp
suffix:semicolon
r_struct
id|child_process
id|cp
op_assign
id|CHILD_PROCESS_INIT
suffix:semicolon
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
r_struct
id|strbuf
id|msg
op_assign
id|STRBUF_INIT
suffix:semicolon
r_struct
id|strbuf
id|author_name
op_assign
id|STRBUF_INIT
suffix:semicolon
r_struct
id|strbuf
id|author_date
op_assign
id|STRBUF_INIT
suffix:semicolon
r_struct
id|strbuf
id|author_email
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|cp.git_cmd
op_assign
l_int|1
suffix:semicolon
id|cp.in
op_assign
id|xopen
c_func
(paren
id|mail
comma
id|O_RDONLY
comma
l_int|0
)paren
suffix:semicolon
id|cp.out
op_assign
id|xopen
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;info&quot;
)paren
comma
id|O_WRONLY
op_or
id|O_CREAT
comma
l_int|0777
)paren
suffix:semicolon
id|argv_array_push
c_func
(paren
op_amp
id|cp.args
comma
l_string|&quot;mailinfo&quot;
)paren
suffix:semicolon
id|argv_array_push
c_func
(paren
op_amp
id|cp.args
comma
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;msg&quot;
)paren
)paren
suffix:semicolon
id|argv_array_push
c_func
(paren
op_amp
id|cp.args
comma
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;patch&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|run_command
c_func
(paren
op_amp
id|cp
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;could not parse patch&quot;
)paren
suffix:semicolon
id|close
c_func
(paren
id|cp.in
)paren
suffix:semicolon
id|close
c_func
(paren
id|cp.out
)paren
suffix:semicolon
multiline_comment|/* Extract message and author information */
id|fp
op_assign
id|xfopen
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;info&quot;
)paren
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|strbuf_getline
c_func
(paren
op_amp
id|sb
comma
id|fp
comma
l_char|&squot;&bslash;n&squot;
)paren
)paren
(brace
r_const
r_char
op_star
id|x
suffix:semicolon
r_if
c_cond
(paren
id|skip_prefix
c_func
(paren
id|sb.buf
comma
l_string|&quot;Subject: &quot;
comma
op_amp
id|x
)paren
)paren
(brace
r_if
c_cond
(paren
id|msg.len
)paren
id|strbuf_addch
c_func
(paren
op_amp
id|msg
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|msg
comma
id|x
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|skip_prefix
c_func
(paren
id|sb.buf
comma
l_string|&quot;Author: &quot;
comma
op_amp
id|x
)paren
)paren
id|strbuf_addstr
c_func
(paren
op_amp
id|author_name
comma
id|x
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|skip_prefix
c_func
(paren
id|sb.buf
comma
l_string|&quot;Email: &quot;
comma
op_amp
id|x
)paren
)paren
id|strbuf_addstr
c_func
(paren
op_amp
id|author_email
comma
id|x
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|skip_prefix
c_func
(paren
id|sb.buf
comma
l_string|&quot;Date: &quot;
comma
op_amp
id|x
)paren
)paren
id|strbuf_addstr
c_func
(paren
op_amp
id|author_date
comma
id|x
)paren
suffix:semicolon
)brace
id|fclose
c_func
(paren
id|fp
)paren
suffix:semicolon
multiline_comment|/* Skip pine&squot;s internal folder data */
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|author_name.buf
comma
l_string|&quot;Mail System Internal Data&quot;
)paren
)paren
(brace
id|ret
op_assign
l_int|1
suffix:semicolon
r_goto
id|finish
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_empty_file
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;patch&quot;
)paren
)paren
)paren
(brace
id|printf_ln
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Patch is empty. Was it split wrong?&quot;
)paren
)paren
suffix:semicolon
m_exit
(paren
l_int|128
)paren
suffix:semicolon
)brace
id|strbuf_addstr
c_func
(paren
op_amp
id|msg
comma
l_string|&quot;&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strbuf_read_file
c_func
(paren
op_amp
id|msg
comma
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;msg&quot;
)paren
comma
l_int|0
)paren
OL
l_int|0
)paren
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;could not read &squot;%s&squot;&quot;
)paren
comma
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;msg&quot;
)paren
)paren
suffix:semicolon
id|stripspace
c_func
(paren
op_amp
id|msg
comma
l_int|0
)paren
suffix:semicolon
m_assert
(paren
op_logical_neg
id|state-&gt;author_name
)paren
suffix:semicolon
id|state-&gt;author_name
op_assign
id|strbuf_detach
c_func
(paren
op_amp
id|author_name
comma
l_int|NULL
)paren
suffix:semicolon
m_assert
(paren
op_logical_neg
id|state-&gt;author_email
)paren
suffix:semicolon
id|state-&gt;author_email
op_assign
id|strbuf_detach
c_func
(paren
op_amp
id|author_email
comma
l_int|NULL
)paren
suffix:semicolon
m_assert
(paren
op_logical_neg
id|state-&gt;author_date
)paren
suffix:semicolon
id|state-&gt;author_date
op_assign
id|strbuf_detach
c_func
(paren
op_amp
id|author_date
comma
l_int|NULL
)paren
suffix:semicolon
m_assert
(paren
op_logical_neg
id|state-&gt;msg
)paren
suffix:semicolon
id|state-&gt;msg
op_assign
id|strbuf_detach
c_func
(paren
op_amp
id|msg
comma
op_amp
id|state-&gt;msg_len
)paren
suffix:semicolon
id|finish
suffix:colon
id|strbuf_release
c_func
(paren
op_amp
id|msg
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|author_date
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|author_email
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|author_name
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; * Applies current patch with git-apply. Returns 0 on success, -1 otherwise.&n; */
DECL|function|run_apply
r_static
r_int
id|run_apply
c_func
(paren
r_const
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_struct
id|child_process
id|cp
op_assign
id|CHILD_PROCESS_INIT
suffix:semicolon
id|cp.git_cmd
op_assign
l_int|1
suffix:semicolon
id|argv_array_push
c_func
(paren
op_amp
id|cp.args
comma
l_string|&quot;apply&quot;
)paren
suffix:semicolon
id|argv_array_push
c_func
(paren
op_amp
id|cp.args
comma
l_string|&quot;--index&quot;
)paren
suffix:semicolon
id|argv_array_push
c_func
(paren
op_amp
id|cp.args
comma
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;patch&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|run_command
c_func
(paren
op_amp
id|cp
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Reload index as git-apply will have modified it. */
id|discard_cache
c_func
(paren
)paren
suffix:semicolon
id|read_cache
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * Commits the current index with state-&gt;msg as the commit message and&n; * state-&gt;author_name, state-&gt;author_email and state-&gt;author_date as the author&n; * information.&n; */
DECL|function|do_commit
r_static
r_void
id|do_commit
c_func
(paren
r_const
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_int
r_char
id|tree
(braket
id|GIT_SHA1_RAWSZ
)braket
comma
id|parent
(braket
id|GIT_SHA1_RAWSZ
)braket
comma
id|commit
(braket
id|GIT_SHA1_RAWSZ
)braket
suffix:semicolon
r_int
r_char
op_star
id|ptr
suffix:semicolon
r_struct
id|commit_list
op_star
id|parents
op_assign
l_int|NULL
suffix:semicolon
r_const
r_char
op_star
id|reflog_msg
comma
op_star
id|author
suffix:semicolon
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
r_if
c_cond
(paren
id|write_cache_as_tree
c_func
(paren
id|tree
comma
l_int|0
comma
l_int|NULL
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;git write-tree failed to write a tree&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|get_sha1_commit
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|parent
)paren
)paren
(brace
id|ptr
op_assign
id|parent
suffix:semicolon
id|commit_list_insert
c_func
(paren
id|lookup_commit
c_func
(paren
id|parent
)paren
comma
op_amp
id|parents
)paren
suffix:semicolon
)brace
r_else
(brace
id|ptr
op_assign
l_int|NULL
suffix:semicolon
id|say
c_func
(paren
id|state
comma
id|stderr
comma
id|_
c_func
(paren
l_string|&quot;applying to an empty history&quot;
)paren
)paren
suffix:semicolon
)brace
id|author
op_assign
id|fmt_ident
c_func
(paren
id|state-&gt;author_name
comma
id|state-&gt;author_email
comma
id|state-&gt;author_date
comma
id|IDENT_STRICT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|commit_tree
c_func
(paren
id|state-&gt;msg
comma
id|state-&gt;msg_len
comma
id|tree
comma
id|parents
comma
id|commit
comma
id|author
comma
l_int|NULL
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;failed to write commit object&quot;
)paren
)paren
suffix:semicolon
id|reflog_msg
op_assign
id|getenv
c_func
(paren
l_string|&quot;GIT_REFLOG_ACTION&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|reflog_msg
)paren
id|reflog_msg
op_assign
l_string|&quot;am&quot;
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
id|sb
comma
l_string|&quot;%s: %.*s&quot;
comma
id|reflog_msg
comma
id|linelen
c_func
(paren
id|state-&gt;msg
)paren
comma
id|state-&gt;msg
)paren
suffix:semicolon
id|update_ref
c_func
(paren
id|sb.buf
comma
l_string|&quot;HEAD&quot;
comma
id|commit
comma
id|ptr
comma
l_int|0
comma
id|UPDATE_REFS_DIE_ON_ERR
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Validates the am_state for resuming -- the &quot;msg&quot; and authorship fields must&n; * be filled up.&n; */
DECL|function|validate_resume_state
r_static
r_void
id|validate_resume_state
c_func
(paren
r_const
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|state-&gt;msg
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;cannot resume: %s does not exist.&quot;
)paren
comma
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;final-commit&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|state-&gt;author_name
op_logical_or
op_logical_neg
id|state-&gt;author_email
op_logical_or
op_logical_neg
id|state-&gt;author_date
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;cannot resume: %s does not exist.&quot;
)paren
comma
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;author-script&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Applies all queued mail.&n; *&n; * If `resume` is true, we are &quot;resuming&quot;. The &quot;msg&quot; and authorship fields, as&n; * well as the state directory&squot;s &quot;patch&quot; file is used as-is for applying the&n; * patch and committing it.&n; */
DECL|function|am_run
r_static
r_void
id|am_run
c_func
(paren
r_struct
id|am_state
op_star
id|state
comma
r_int
id|resume
)paren
(brace
r_const
r_char
op_star
id|argv_gc_auto
(braket
)braket
op_assign
(brace
l_string|&quot;gc&quot;
comma
l_string|&quot;--auto&quot;
comma
l_int|NULL
)brace
suffix:semicolon
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
id|unlink
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;dirtyindex&quot;
)paren
)paren
suffix:semicolon
id|refresh_and_write_cache
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index_has_changes
c_func
(paren
op_amp
id|sb
)paren
)paren
(brace
id|write_file
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;dirtyindex&quot;
)paren
comma
l_int|1
comma
l_string|&quot;t&quot;
)paren
suffix:semicolon
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Dirty index: cannot apply patches (dirty: %s)&quot;
)paren
comma
id|sb.buf
)paren
suffix:semicolon
)brace
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
r_while
c_loop
(paren
id|state-&gt;cur
op_le
id|state-&gt;last
)paren
(brace
r_const
r_char
op_star
id|mail
op_assign
id|am_path
c_func
(paren
id|state
comma
id|msgnum
c_func
(paren
id|state
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file_exists
c_func
(paren
id|mail
)paren
)paren
r_goto
id|next
suffix:semicolon
r_if
c_cond
(paren
id|resume
)paren
(brace
id|validate_resume_state
c_func
(paren
id|state
)paren
suffix:semicolon
id|resume
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|parse_mail
c_func
(paren
id|state
comma
id|mail
)paren
)paren
r_goto
id|next
suffix:semicolon
multiline_comment|/* mail should be skipped */
id|write_author_script
c_func
(paren
id|state
)paren
suffix:semicolon
id|write_commit_msg
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
id|say
c_func
(paren
id|state
comma
id|stdout
comma
id|_
c_func
(paren
l_string|&quot;Applying: %.*s&quot;
)paren
comma
id|linelen
c_func
(paren
id|state-&gt;msg
)paren
comma
id|state-&gt;msg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|run_apply
c_func
(paren
id|state
)paren
OL
l_int|0
)paren
(brace
r_int
id|advice_amworkdir
op_assign
l_int|1
suffix:semicolon
id|printf_ln
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Patch failed at %s %.*s&quot;
)paren
comma
id|msgnum
c_func
(paren
id|state
)paren
comma
id|linelen
c_func
(paren
id|state-&gt;msg
)paren
comma
id|state-&gt;msg
)paren
suffix:semicolon
id|git_config_get_bool
c_func
(paren
l_string|&quot;advice.amworkdir&quot;
comma
op_amp
id|advice_amworkdir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|advice_amworkdir
)paren
id|printf_ln
c_func
(paren
id|_
c_func
(paren
l_string|&quot;The copy of the patch that failed is found in: %s&quot;
)paren
comma
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;patch&quot;
)paren
)paren
suffix:semicolon
m_exit
(paren
l_int|128
)paren
suffix:semicolon
)brace
id|do_commit
c_func
(paren
id|state
)paren
suffix:semicolon
id|next
suffix:colon
id|am_next
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
id|am_destroy
c_func
(paren
id|state
)paren
suffix:semicolon
id|run_command_v_opt
c_func
(paren
id|argv_gc_auto
comma
id|RUN_GIT_CMD
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Resume the current am session after patch application failure. The user did&n; * all the hard work, and we do not have to do any patch application. Just&n; * trust and commit what the user has in the index and working tree.&n; */
DECL|function|am_resolve
r_static
r_void
id|am_resolve
c_func
(paren
r_struct
id|am_state
op_star
id|state
)paren
(brace
id|validate_resume_state
c_func
(paren
id|state
)paren
suffix:semicolon
id|say
c_func
(paren
id|state
comma
id|stdout
comma
id|_
c_func
(paren
l_string|&quot;Applying: %.*s&quot;
)paren
comma
id|linelen
c_func
(paren
id|state-&gt;msg
)paren
comma
id|state-&gt;msg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|index_has_changes
c_func
(paren
l_int|NULL
)paren
)paren
(brace
id|printf_ln
c_func
(paren
id|_
c_func
(paren
l_string|&quot;No changes - did you forget to use &squot;git add&squot;?&bslash;n&quot;
l_string|&quot;If there is nothing left to stage, chances are that something else&bslash;n&quot;
l_string|&quot;already introduced the same changes; you might want to skip this patch.&quot;
)paren
)paren
suffix:semicolon
m_exit
(paren
l_int|128
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unmerged_cache
c_func
(paren
)paren
)paren
(brace
id|printf_ln
c_func
(paren
id|_
c_func
(paren
l_string|&quot;You still have unmerged paths in your index.&bslash;n&quot;
l_string|&quot;Did you forget to use &squot;git add&squot;?&quot;
)paren
)paren
suffix:semicolon
m_exit
(paren
l_int|128
)paren
suffix:semicolon
)brace
id|do_commit
c_func
(paren
id|state
)paren
suffix:semicolon
id|am_next
c_func
(paren
id|state
)paren
suffix:semicolon
id|am_run
c_func
(paren
id|state
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Performs a checkout fast-forward from `head` to `remote`. If `reset` is&n; * true, any unmerged entries will be discarded. Returns 0 on success, -1 on&n; * failure.&n; */
DECL|function|fast_forward_to
r_static
r_int
id|fast_forward_to
c_func
(paren
r_struct
id|tree
op_star
id|head
comma
r_struct
id|tree
op_star
id|remote
comma
r_int
id|reset
)paren
(brace
r_struct
id|lock_file
op_star
id|lock_file
suffix:semicolon
r_struct
id|unpack_trees_options
id|opts
suffix:semicolon
r_struct
id|tree_desc
id|t
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
id|parse_tree
c_func
(paren
id|head
)paren
op_logical_or
id|parse_tree
c_func
(paren
id|remote
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|lock_file
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|lock_file
)paren
)paren
suffix:semicolon
id|hold_locked_index
c_func
(paren
id|lock_file
comma
l_int|1
)paren
suffix:semicolon
id|refresh_cache
c_func
(paren
id|REFRESH_QUIET
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|opts
comma
l_int|0
comma
r_sizeof
(paren
id|opts
)paren
)paren
suffix:semicolon
id|opts.head_idx
op_assign
l_int|1
suffix:semicolon
id|opts.src_index
op_assign
op_amp
id|the_index
suffix:semicolon
id|opts.dst_index
op_assign
op_amp
id|the_index
suffix:semicolon
id|opts.update
op_assign
l_int|1
suffix:semicolon
id|opts.merge
op_assign
l_int|1
suffix:semicolon
id|opts.reset
op_assign
id|reset
suffix:semicolon
id|opts.fn
op_assign
id|twoway_merge
suffix:semicolon
id|init_tree_desc
c_func
(paren
op_amp
id|t
(braket
l_int|0
)braket
comma
id|head-&gt;buffer
comma
id|head-&gt;size
)paren
suffix:semicolon
id|init_tree_desc
c_func
(paren
op_amp
id|t
(braket
l_int|1
)braket
comma
id|remote-&gt;buffer
comma
id|remote-&gt;size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unpack_trees
c_func
(paren
l_int|2
comma
id|t
comma
op_amp
id|opts
)paren
)paren
(brace
id|rollback_lock_file
c_func
(paren
id|lock_file
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|write_locked_index
c_func
(paren
op_amp
id|the_index
comma
id|lock_file
comma
id|COMMIT_LOCK
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;unable to write new index file&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * Clean the index without touching entries that are not modified between&n; * `head` and `remote`.&n; */
DECL|function|clean_index
r_static
r_int
id|clean_index
c_func
(paren
r_const
r_int
r_char
op_star
id|head
comma
r_const
r_int
r_char
op_star
id|remote
)paren
(brace
r_struct
id|lock_file
op_star
id|lock_file
suffix:semicolon
r_struct
id|tree
op_star
id|head_tree
comma
op_star
id|remote_tree
comma
op_star
id|index_tree
suffix:semicolon
r_int
r_char
id|index
(braket
id|GIT_SHA1_RAWSZ
)braket
suffix:semicolon
r_struct
id|pathspec
id|pathspec
suffix:semicolon
id|head_tree
op_assign
id|parse_tree_indirect
c_func
(paren
id|head
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|head_tree
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Could not parse object &squot;%s&squot;.&quot;
)paren
comma
id|sha1_to_hex
c_func
(paren
id|head
)paren
)paren
suffix:semicolon
id|remote_tree
op_assign
id|parse_tree_indirect
c_func
(paren
id|remote
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|remote_tree
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Could not parse object &squot;%s&squot;.&quot;
)paren
comma
id|sha1_to_hex
c_func
(paren
id|remote
)paren
)paren
suffix:semicolon
id|read_cache_unmerged
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fast_forward_to
c_func
(paren
id|head_tree
comma
id|head_tree
comma
l_int|1
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|write_cache_as_tree
c_func
(paren
id|index
comma
l_int|0
comma
l_int|NULL
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|index_tree
op_assign
id|parse_tree_indirect
c_func
(paren
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|index_tree
)paren
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Could not parse object &squot;%s&squot;.&quot;
)paren
comma
id|sha1_to_hex
c_func
(paren
id|index
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fast_forward_to
c_func
(paren
id|index_tree
comma
id|remote_tree
comma
l_int|0
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|pathspec
comma
l_int|0
comma
r_sizeof
(paren
id|pathspec
)paren
)paren
suffix:semicolon
id|lock_file
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|lock_file
)paren
)paren
suffix:semicolon
id|hold_locked_index
c_func
(paren
id|lock_file
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_tree
c_func
(paren
id|remote_tree
comma
l_int|0
comma
op_amp
id|pathspec
)paren
)paren
(brace
id|rollback_lock_file
c_func
(paren
id|lock_file
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|write_locked_index
c_func
(paren
op_amp
id|the_index
comma
id|lock_file
comma
id|COMMIT_LOCK
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;unable to write new index file&quot;
)paren
)paren
suffix:semicolon
id|remove_branch_state
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * Resume the current am session by skipping the current patch.&n; */
DECL|function|am_skip
r_static
r_void
id|am_skip
c_func
(paren
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_int
r_char
id|head
(braket
id|GIT_SHA1_RAWSZ
)braket
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|head
)paren
)paren
id|hashcpy
c_func
(paren
id|head
comma
id|EMPTY_TREE_SHA1_BIN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|clean_index
c_func
(paren
id|head
comma
id|head
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;failed to clean index&quot;
)paren
)paren
suffix:semicolon
id|am_next
c_func
(paren
id|state
)paren
suffix:semicolon
id|am_run
c_func
(paren
id|state
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Returns true if it is safe to reset HEAD to the ORIG_HEAD, false otherwise.&n; *&n; * It is not safe to reset HEAD when:&n; * 1. git-am previously failed because the index was dirty.&n; * 2. HEAD has moved since git-am previously failed.&n; */
DECL|function|safe_to_abort
r_static
r_int
id|safe_to_abort
c_func
(paren
r_const
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
r_char
id|abort_safety
(braket
id|GIT_SHA1_RAWSZ
)braket
comma
id|head
(braket
id|GIT_SHA1_RAWSZ
)braket
suffix:semicolon
r_if
c_cond
(paren
id|file_exists
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;dirtyindex&quot;
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|read_state_file
c_func
(paren
op_amp
id|sb
comma
id|state
comma
l_string|&quot;abort-safety&quot;
comma
l_int|1
)paren
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|sb.buf
comma
id|abort_safety
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;could not parse %s&quot;
)paren
comma
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;abort_safety&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
id|hashclr
c_func
(paren
id|abort_safety
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|head
)paren
)paren
id|hashclr
c_func
(paren
id|head
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hashcmp
c_func
(paren
id|head
comma
id|abort_safety
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;You seem to have moved HEAD since the last &squot;am&squot; failure.&bslash;n&quot;
l_string|&quot;Not rewinding to ORIG_HEAD&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * Aborts the current am session if it is safe to do so.&n; */
DECL|function|am_abort
r_static
r_void
id|am_abort
c_func
(paren
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_int
r_char
id|curr_head
(braket
id|GIT_SHA1_RAWSZ
)braket
comma
id|orig_head
(braket
id|GIT_SHA1_RAWSZ
)braket
suffix:semicolon
r_int
id|has_curr_head
comma
id|has_orig_head
suffix:semicolon
r_char
op_star
id|curr_branch
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|safe_to_abort
c_func
(paren
id|state
)paren
)paren
(brace
id|am_destroy
c_func
(paren
id|state
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|curr_branch
op_assign
id|resolve_refdup
c_func
(paren
l_string|&quot;HEAD&quot;
comma
l_int|0
comma
id|curr_head
comma
l_int|NULL
)paren
suffix:semicolon
id|has_curr_head
op_assign
op_logical_neg
id|is_null_sha1
c_func
(paren
id|curr_head
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|has_curr_head
)paren
id|hashcpy
c_func
(paren
id|curr_head
comma
id|EMPTY_TREE_SHA1_BIN
)paren
suffix:semicolon
id|has_orig_head
op_assign
op_logical_neg
id|get_sha1
c_func
(paren
l_string|&quot;ORIG_HEAD&quot;
comma
id|orig_head
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|has_orig_head
)paren
id|hashcpy
c_func
(paren
id|orig_head
comma
id|EMPTY_TREE_SHA1_BIN
)paren
suffix:semicolon
id|clean_index
c_func
(paren
id|curr_head
comma
id|orig_head
)paren
suffix:semicolon
r_if
c_cond
(paren
id|has_orig_head
)paren
id|update_ref
c_func
(paren
l_string|&quot;am --abort&quot;
comma
l_string|&quot;HEAD&quot;
comma
id|orig_head
comma
id|has_curr_head
ques
c_cond
id|curr_head
suffix:colon
l_int|NULL
comma
l_int|0
comma
id|UPDATE_REFS_DIE_ON_ERR
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|curr_branch
)paren
id|delete_ref
c_func
(paren
id|curr_branch
comma
l_int|NULL
comma
id|REF_NODEREF
)paren
suffix:semicolon
id|free
c_func
(paren
id|curr_branch
)paren
suffix:semicolon
id|am_destroy
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * parse_options() callback that validates and sets opt-&gt;value to the&n; * PATCH_FORMAT_* enum value corresponding to `arg`.&n; */
DECL|function|parse_opt_patchformat
r_static
r_int
id|parse_opt_patchformat
c_func
(paren
r_const
r_struct
id|option
op_star
id|opt
comma
r_const
r_char
op_star
id|arg
comma
r_int
id|unset
)paren
(brace
r_int
op_star
id|opt_value
op_assign
id|opt-&gt;value
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;mbox&quot;
)paren
)paren
op_star
id|opt_value
op_assign
id|PATCH_FORMAT_MBOX
suffix:semicolon
r_else
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Invalid value for --patch-format: %s&quot;
)paren
comma
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|enum|resume_mode
r_enum
id|resume_mode
(brace
DECL|enumerator|RESUME_FALSE
id|RESUME_FALSE
op_assign
l_int|0
comma
DECL|enumerator|RESUME_APPLY
id|RESUME_APPLY
comma
DECL|enumerator|RESUME_RESOLVED
id|RESUME_RESOLVED
comma
DECL|enumerator|RESUME_SKIP
id|RESUME_SKIP
comma
DECL|enumerator|RESUME_ABORT
id|RESUME_ABORT
)brace
suffix:semicolon
DECL|function|cmd_am
r_int
id|cmd_am
c_func
(paren
r_int
id|argc
comma
r_const
r_char
op_star
op_star
id|argv
comma
r_const
r_char
op_star
id|prefix
)paren
(brace
r_struct
id|am_state
id|state
suffix:semicolon
r_int
id|patch_format
op_assign
id|PATCH_FORMAT_UNKNOWN
suffix:semicolon
r_enum
id|resume_mode
id|resume
op_assign
id|RESUME_FALSE
suffix:semicolon
r_const
r_char
op_star
r_const
id|usage
(braket
)braket
op_assign
(brace
id|N_
c_func
(paren
l_string|&quot;git am [options] [(&lt;mbox&gt;|&lt;Maildir&gt;)...]&quot;
)paren
comma
id|N_
c_func
(paren
l_string|&quot;git am [options] (--continue | --skip | --abort)&quot;
)paren
comma
l_int|NULL
)brace
suffix:semicolon
r_struct
id|option
id|options
(braket
)braket
op_assign
(brace
id|OPT__QUIET
c_func
(paren
op_amp
id|state.quiet
comma
id|N_
c_func
(paren
l_string|&quot;be quiet&quot;
)paren
)paren
comma
id|OPT_CALLBACK
c_func
(paren
l_int|0
comma
l_string|&quot;patch-format&quot;
comma
op_amp
id|patch_format
comma
id|N_
c_func
(paren
l_string|&quot;format&quot;
)paren
comma
id|N_
c_func
(paren
l_string|&quot;format the patch(es) are in&quot;
)paren
comma
id|parse_opt_patchformat
)paren
comma
id|OPT_CMDMODE
c_func
(paren
l_int|0
comma
l_string|&quot;continue&quot;
comma
op_amp
id|resume
comma
id|N_
c_func
(paren
l_string|&quot;continue applying patches after resolving a conflict&quot;
)paren
comma
id|RESUME_RESOLVED
)paren
comma
id|OPT_CMDMODE
c_func
(paren
l_char|&squot;r&squot;
comma
l_string|&quot;resolved&quot;
comma
op_amp
id|resume
comma
id|N_
c_func
(paren
l_string|&quot;synonyms for --continue&quot;
)paren
comma
id|RESUME_RESOLVED
)paren
comma
id|OPT_CMDMODE
c_func
(paren
l_int|0
comma
l_string|&quot;skip&quot;
comma
op_amp
id|resume
comma
id|N_
c_func
(paren
l_string|&quot;skip the current patch&quot;
)paren
comma
id|RESUME_SKIP
)paren
comma
id|OPT_CMDMODE
c_func
(paren
l_int|0
comma
l_string|&quot;abort&quot;
comma
op_amp
id|resume
comma
id|N_
c_func
(paren
l_string|&quot;restore the original branch and abort the patching operation.&quot;
)paren
comma
id|RESUME_ABORT
)paren
comma
id|OPT_END
c_func
(paren
)paren
)brace
suffix:semicolon
multiline_comment|/*&n;&t; * NEEDSWORK: Once all the features of git-am.sh have been&n;&t; * re-implemented in builtin/am.c, this preamble can be removed.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|getenv
c_func
(paren
l_string|&quot;_GIT_USE_BUILTIN_AM&quot;
)paren
)paren
(brace
r_const
r_char
op_star
id|path
op_assign
id|mkpath
c_func
(paren
l_string|&quot;%s/git-am&quot;
comma
id|git_exec_path
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sane_execvp
c_func
(paren
id|path
comma
(paren
r_char
op_star
op_star
)paren
id|argv
)paren
OL
l_int|0
)paren
id|die_errno
c_func
(paren
l_string|&quot;could not exec %s&quot;
comma
id|path
)paren
suffix:semicolon
)brace
r_else
(brace
id|prefix
op_assign
id|setup_git_directory
c_func
(paren
)paren
suffix:semicolon
id|trace_repo_setup
c_func
(paren
id|prefix
)paren
suffix:semicolon
id|setup_work_tree
c_func
(paren
)paren
suffix:semicolon
)brace
id|git_config
c_func
(paren
id|git_default_config
comma
l_int|NULL
)paren
suffix:semicolon
id|am_state_init
c_func
(paren
op_amp
id|state
comma
id|git_path
c_func
(paren
l_string|&quot;rebase-apply&quot;
)paren
)paren
suffix:semicolon
id|argc
op_assign
id|parse_options
c_func
(paren
id|argc
comma
id|argv
comma
id|prefix
comma
id|options
comma
id|usage
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_index_preload
c_func
(paren
op_amp
id|the_index
comma
l_int|NULL
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;failed to read the index&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|am_in_progress
c_func
(paren
op_amp
id|state
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Catch user error to feed us patches when there is a session&n;&t;&t; * in progress:&n;&t;&t; *&n;&t;&t; * 1. mbox path(s) are provided on the command-line.&n;&t;&t; * 2. stdin is not a tty: the user is trying to feed us a patch&n;&t;&t; *    from standard input. This is somewhat unreliable -- stdin&n;&t;&t; *    could be /dev/null for example and the caller did not&n;&t;&t; *    intend to feed us a patch but wanted to continue&n;&t;&t; *    unattended.&n;&t;&t; */
r_if
c_cond
(paren
id|argc
op_logical_or
(paren
id|resume
op_eq
id|RESUME_FALSE
op_logical_and
op_logical_neg
id|isatty
c_func
(paren
l_int|0
)paren
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;previous rebase directory %s still exists but mbox given.&quot;
)paren
comma
id|state.dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|resume
op_eq
id|RESUME_FALSE
)paren
id|resume
op_assign
id|RESUME_APPLY
suffix:semicolon
id|am_load
c_func
(paren
op_amp
id|state
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|argv_array
id|paths
op_assign
id|ARGV_ARRAY_INIT
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|resume
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Resolve operation not in progress, we are not resuming.&quot;
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|argc
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|is_absolute_path
c_func
(paren
id|argv
(braket
id|i
)braket
)paren
op_logical_or
op_logical_neg
id|prefix
)paren
id|argv_array_push
c_func
(paren
op_amp
id|paths
comma
id|argv
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|argv_array_push
c_func
(paren
op_amp
id|paths
comma
id|mkpath
c_func
(paren
l_string|&quot;%s/%s&quot;
comma
id|prefix
comma
id|argv
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
)brace
id|am_setup
c_func
(paren
op_amp
id|state
comma
id|patch_format
comma
id|paths.argv
)paren
suffix:semicolon
id|argv_array_clear
c_func
(paren
op_amp
id|paths
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|resume
)paren
(brace
r_case
id|RESUME_FALSE
suffix:colon
id|am_run
c_func
(paren
op_amp
id|state
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RESUME_APPLY
suffix:colon
id|am_run
c_func
(paren
op_amp
id|state
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RESUME_RESOLVED
suffix:colon
id|am_resolve
c_func
(paren
op_amp
id|state
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RESUME_SKIP
suffix:colon
id|am_skip
c_func
(paren
op_amp
id|state
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RESUME_ABORT
suffix:colon
id|am_abort
c_func
(paren
op_amp
id|state
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|die
c_func
(paren
l_string|&quot;BUG: invalid resume value&quot;
)paren
suffix:semicolon
)brace
id|am_state_release
c_func
(paren
op_amp
id|state
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
