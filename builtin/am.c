multiline_comment|/*&n; * Builtin &quot;git am&quot;&n; *&n; * Based on git-am.sh by Junio C Hamano.&n; */
macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;builtin.h&quot;
macro_line|#include &quot;exec_cmd.h&quot;
macro_line|#include &quot;parse-options.h&quot;
macro_line|#include &quot;dir.h&quot;
macro_line|#include &quot;run-command.h&quot;
macro_line|#include &quot;quote.h&quot;
macro_line|#include &quot;lockfile.h&quot;
macro_line|#include &quot;cache-tree.h&quot;
macro_line|#include &quot;refs.h&quot;
macro_line|#include &quot;commit.h&quot;
multiline_comment|/**&n; * Returns 1 if the file is empty or does not exist, 0 otherwise.&n; */
DECL|function|is_empty_file
r_static
r_int
id|is_empty_file
c_func
(paren
r_const
r_char
op_star
id|filename
)paren
(brace
r_struct
id|stat
id|st
suffix:semicolon
r_if
c_cond
(paren
id|stat
c_func
(paren
id|filename
comma
op_amp
id|st
)paren
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|errno
op_eq
id|ENOENT
)paren
r_return
l_int|1
suffix:semicolon
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;could not stat %s&quot;
)paren
comma
id|filename
)paren
suffix:semicolon
)brace
r_return
op_logical_neg
id|st.st_size
suffix:semicolon
)brace
multiline_comment|/**&n; * Like strbuf_getline(), but treats both &squot;&bslash;n&squot; and &quot;&bslash;r&bslash;n&quot; as line terminators.&n; */
DECL|function|strbuf_getline_crlf
r_static
r_int
id|strbuf_getline_crlf
c_func
(paren
r_struct
id|strbuf
op_star
id|sb
comma
id|FILE
op_star
id|fp
)paren
(brace
r_if
c_cond
(paren
id|strbuf_getwholeline
c_func
(paren
id|sb
comma
id|fp
comma
l_char|&squot;&bslash;n&squot;
)paren
)paren
r_return
id|EOF
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;buf
(braket
id|sb-&gt;len
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|strbuf_setlen
c_func
(paren
id|sb
comma
id|sb-&gt;len
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;len
OG
l_int|0
op_logical_and
id|sb-&gt;buf
(braket
id|sb-&gt;len
l_int|1
)braket
op_eq
l_char|&squot;&bslash;r&squot;
)paren
id|strbuf_setlen
c_func
(paren
id|sb
comma
id|sb-&gt;len
l_int|1
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * Returns the length of the first line of msg.&n; */
DECL|function|linelen
r_static
r_int
id|linelen
c_func
(paren
r_const
r_char
op_star
id|msg
)paren
(brace
r_return
id|strchrnul
c_func
(paren
id|msg
comma
l_char|&squot;&bslash;n&squot;
)paren
id|msg
suffix:semicolon
)brace
DECL|enum|patch_format
r_enum
id|patch_format
(brace
DECL|enumerator|PATCH_FORMAT_UNKNOWN
id|PATCH_FORMAT_UNKNOWN
op_assign
l_int|0
comma
DECL|enumerator|PATCH_FORMAT_MBOX
id|PATCH_FORMAT_MBOX
)brace
suffix:semicolon
DECL|struct|am_state
r_struct
id|am_state
(brace
multiline_comment|/* state directory path */
DECL|member|dir
r_char
op_star
id|dir
suffix:semicolon
multiline_comment|/* current and last patch numbers, 1-indexed */
DECL|member|cur
r_int
id|cur
suffix:semicolon
DECL|member|last
r_int
id|last
suffix:semicolon
multiline_comment|/* commit metadata and message */
DECL|member|author_name
r_char
op_star
id|author_name
suffix:semicolon
DECL|member|author_email
r_char
op_star
id|author_email
suffix:semicolon
DECL|member|author_date
r_char
op_star
id|author_date
suffix:semicolon
DECL|member|msg
r_char
op_star
id|msg
suffix:semicolon
DECL|member|msg_len
r_int
id|msg_len
suffix:semicolon
multiline_comment|/* number of digits in patch filename */
DECL|member|prec
r_int
id|prec
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/**&n; * Initializes am_state with the default values. The state directory is set to&n; * dir.&n; */
DECL|function|am_state_init
r_static
r_void
id|am_state_init
c_func
(paren
r_struct
id|am_state
op_star
id|state
comma
r_const
r_char
op_star
id|dir
)paren
(brace
id|memset
c_func
(paren
id|state
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|state
)paren
)paren
suffix:semicolon
m_assert
(paren
id|dir
)paren
suffix:semicolon
id|state-&gt;dir
op_assign
id|xstrdup
c_func
(paren
id|dir
)paren
suffix:semicolon
id|state-&gt;prec
op_assign
l_int|4
suffix:semicolon
)brace
multiline_comment|/**&n; * Releases memory allocated by an am_state.&n; */
DECL|function|am_state_release
r_static
r_void
id|am_state_release
c_func
(paren
r_struct
id|am_state
op_star
id|state
)paren
(brace
id|free
c_func
(paren
id|state-&gt;dir
)paren
suffix:semicolon
id|free
c_func
(paren
id|state-&gt;author_name
)paren
suffix:semicolon
id|free
c_func
(paren
id|state-&gt;author_email
)paren
suffix:semicolon
id|free
c_func
(paren
id|state-&gt;author_date
)paren
suffix:semicolon
id|free
c_func
(paren
id|state-&gt;msg
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Returns path relative to the am_state directory.&n; */
DECL|function|am_path
r_static
r_inline
r_const
r_char
op_star
id|am_path
c_func
(paren
r_const
r_struct
id|am_state
op_star
id|state
comma
r_const
r_char
op_star
id|path
)paren
(brace
r_return
id|mkpath
c_func
(paren
l_string|&quot;%s/%s&quot;
comma
id|state-&gt;dir
comma
id|path
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Returns 1 if there is an am session in progress, 0 otherwise.&n; */
DECL|function|am_in_progress
r_static
r_int
id|am_in_progress
c_func
(paren
r_const
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_struct
id|stat
id|st
suffix:semicolon
r_if
c_cond
(paren
id|lstat
c_func
(paren
id|state-&gt;dir
comma
op_amp
id|st
)paren
OL
l_int|0
op_logical_or
op_logical_neg
id|S_ISDIR
c_func
(paren
id|st.st_mode
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|lstat
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;last&quot;
)paren
comma
op_amp
id|st
)paren
op_logical_or
op_logical_neg
id|S_ISREG
c_func
(paren
id|st.st_mode
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|lstat
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;next&quot;
)paren
comma
op_amp
id|st
)paren
op_logical_or
op_logical_neg
id|S_ISREG
c_func
(paren
id|st.st_mode
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * Reads the contents of `file` in the `state` directory into `sb`. Returns the&n; * number of bytes read on success, -1 if the file does not exist. If `trim` is&n; * set, trailing whitespace will be removed.&n; */
DECL|function|read_state_file
r_static
r_int
id|read_state_file
c_func
(paren
r_struct
id|strbuf
op_star
id|sb
comma
r_const
r_struct
id|am_state
op_star
id|state
comma
r_const
r_char
op_star
id|file
comma
r_int
id|trim
)paren
(brace
id|strbuf_reset
c_func
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strbuf_read_file
c_func
(paren
id|sb
comma
id|am_path
c_func
(paren
id|state
comma
id|file
)paren
comma
l_int|0
)paren
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|trim
)paren
id|strbuf_trim
c_func
(paren
id|sb
)paren
suffix:semicolon
r_return
id|sb-&gt;len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|errno
op_eq
id|ENOENT
)paren
r_return
l_int|1
suffix:semicolon
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;could not read &squot;%s&squot;&quot;
)paren
comma
id|am_path
c_func
(paren
id|state
comma
id|file
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Reads a KEY=VALUE shell variable assignment from `fp`, returning the VALUE&n; * as a newly-allocated string. VALUE must be a quoted string, and the KEY must&n; * match `key`. Returns NULL on failure.&n; *&n; * This is used by read_author_script() to read the GIT_AUTHOR_* variables from&n; * the author-script.&n; */
DECL|function|read_shell_var
r_static
r_char
op_star
id|read_shell_var
c_func
(paren
id|FILE
op_star
id|fp
comma
r_const
r_char
op_star
id|key
)paren
(brace
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
r_const
r_char
op_star
id|str
suffix:semicolon
r_if
c_cond
(paren
id|strbuf_getline
c_func
(paren
op_amp
id|sb
comma
id|fp
comma
l_char|&squot;&bslash;n&squot;
)paren
)paren
r_goto
id|fail
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skip_prefix
c_func
(paren
id|sb.buf
comma
id|key
comma
op_amp
id|str
)paren
)paren
r_goto
id|fail
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skip_prefix
c_func
(paren
id|str
comma
l_string|&quot;=&quot;
comma
op_amp
id|str
)paren
)paren
r_goto
id|fail
suffix:semicolon
id|strbuf_remove
c_func
(paren
op_amp
id|sb
comma
l_int|0
comma
id|str
id|sb.buf
)paren
suffix:semicolon
id|str
op_assign
id|sq_dequote
c_func
(paren
id|sb.buf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|str
)paren
r_goto
id|fail
suffix:semicolon
r_return
id|strbuf_detach
c_func
(paren
op_amp
id|sb
comma
l_int|NULL
)paren
suffix:semicolon
id|fail
suffix:colon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; * Reads and parses the state directory&squot;s &quot;author-script&quot; file, and sets&n; * state-&gt;author_name, state-&gt;author_email and state-&gt;author_date accordingly.&n; * Returns 0 on success, -1 if the file could not be parsed.&n; *&n; * The author script is of the format:&n; *&n; *&t;GIT_AUTHOR_NAME=&squot;$author_name&squot;&n; *&t;GIT_AUTHOR_EMAIL=&squot;$author_email&squot;&n; *&t;GIT_AUTHOR_DATE=&squot;$author_date&squot;&n; *&n; * where $author_name, $author_email and $author_date are quoted. We are strict&n; * with our parsing, as the file was meant to be eval&squot;d in the old git-am.sh&n; * script, and thus if the file differs from what this function expects, it is&n; * better to bail out than to do something that the user does not expect.&n; */
DECL|function|read_author_script
r_static
r_int
id|read_author_script
c_func
(paren
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_const
r_char
op_star
id|filename
op_assign
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;author-script&quot;
)paren
suffix:semicolon
id|FILE
op_star
id|fp
suffix:semicolon
m_assert
(paren
op_logical_neg
id|state-&gt;author_name
)paren
suffix:semicolon
m_assert
(paren
op_logical_neg
id|state-&gt;author_email
)paren
suffix:semicolon
m_assert
(paren
op_logical_neg
id|state-&gt;author_date
)paren
suffix:semicolon
id|fp
op_assign
id|fopen
c_func
(paren
id|filename
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fp
)paren
(brace
r_if
c_cond
(paren
id|errno
op_eq
id|ENOENT
)paren
r_return
l_int|0
suffix:semicolon
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;could not open &squot;%s&squot; for reading&quot;
)paren
comma
id|filename
)paren
suffix:semicolon
)brace
id|state-&gt;author_name
op_assign
id|read_shell_var
c_func
(paren
id|fp
comma
l_string|&quot;GIT_AUTHOR_NAME&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|state-&gt;author_name
)paren
(brace
id|fclose
c_func
(paren
id|fp
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|state-&gt;author_email
op_assign
id|read_shell_var
c_func
(paren
id|fp
comma
l_string|&quot;GIT_AUTHOR_EMAIL&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|state-&gt;author_email
)paren
(brace
id|fclose
c_func
(paren
id|fp
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|state-&gt;author_date
op_assign
id|read_shell_var
c_func
(paren
id|fp
comma
l_string|&quot;GIT_AUTHOR_DATE&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|state-&gt;author_date
)paren
(brace
id|fclose
c_func
(paren
id|fp
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fgetc
c_func
(paren
id|fp
)paren
op_ne
id|EOF
)paren
(brace
id|fclose
c_func
(paren
id|fp
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|fclose
c_func
(paren
id|fp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * Saves state-&gt;author_name, state-&gt;author_email and state-&gt;author_date in the&n; * state directory&squot;s &quot;author-script&quot; file.&n; */
DECL|function|write_author_script
r_static
r_void
id|write_author_script
c_func
(paren
r_const
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|sb
comma
l_string|&quot;GIT_AUTHOR_NAME=&quot;
)paren
suffix:semicolon
id|sq_quote_buf
c_func
(paren
op_amp
id|sb
comma
id|state-&gt;author_name
)paren
suffix:semicolon
id|strbuf_addch
c_func
(paren
op_amp
id|sb
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|sb
comma
l_string|&quot;GIT_AUTHOR_EMAIL=&quot;
)paren
suffix:semicolon
id|sq_quote_buf
c_func
(paren
op_amp
id|sb
comma
id|state-&gt;author_email
)paren
suffix:semicolon
id|strbuf_addch
c_func
(paren
op_amp
id|sb
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|sb
comma
l_string|&quot;GIT_AUTHOR_DATE=&quot;
)paren
suffix:semicolon
id|sq_quote_buf
c_func
(paren
op_amp
id|sb
comma
id|state-&gt;author_date
)paren
suffix:semicolon
id|strbuf_addch
c_func
(paren
op_amp
id|sb
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|write_file
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;author-script&quot;
)paren
comma
l_int|1
comma
l_string|&quot;%s&quot;
comma
id|sb.buf
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Reads the commit message from the state directory&squot;s &quot;final-commit&quot; file,&n; * setting state-&gt;msg to its contents and state-&gt;msg_len to the length of its&n; * contents in bytes.&n; *&n; * Returns 0 on success, -1 if the file does not exist.&n; */
DECL|function|read_commit_msg
r_static
r_int
id|read_commit_msg
c_func
(paren
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
m_assert
(paren
op_logical_neg
id|state-&gt;msg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_state_file
c_func
(paren
op_amp
id|sb
comma
id|state
comma
l_string|&quot;final-commit&quot;
comma
l_int|0
)paren
OL
l_int|0
)paren
(brace
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|state-&gt;msg
op_assign
id|strbuf_detach
c_func
(paren
op_amp
id|sb
comma
op_amp
id|state-&gt;msg_len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * Saves state-&gt;msg in the state directory&squot;s &quot;final-commit&quot; file.&n; */
DECL|function|write_commit_msg
r_static
r_void
id|write_commit_msg
c_func
(paren
r_const
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_int
id|fd
suffix:semicolon
r_const
r_char
op_star
id|filename
op_assign
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;final-commit&quot;
)paren
suffix:semicolon
id|fd
op_assign
id|xopen
c_func
(paren
id|filename
comma
id|O_WRONLY
op_or
id|O_CREAT
comma
l_int|0666
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write_in_full
c_func
(paren
id|fd
comma
id|state-&gt;msg
comma
id|state-&gt;msg_len
)paren
OL
l_int|0
)paren
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;could not write to %s&quot;
)paren
comma
id|filename
)paren
suffix:semicolon
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Loads state from disk.&n; */
DECL|function|am_load
r_static
r_void
id|am_load
c_func
(paren
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
r_if
c_cond
(paren
id|read_state_file
c_func
(paren
op_amp
id|sb
comma
id|state
comma
l_string|&quot;next&quot;
comma
l_int|1
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;BUG: state file &squot;next&squot; does not exist&quot;
)paren
suffix:semicolon
id|state-&gt;cur
op_assign
id|strtol
c_func
(paren
id|sb.buf
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_state_file
c_func
(paren
op_amp
id|sb
comma
id|state
comma
l_string|&quot;last&quot;
comma
l_int|1
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;BUG: state file &squot;last&squot; does not exist&quot;
)paren
suffix:semicolon
id|state-&gt;last
op_assign
id|strtol
c_func
(paren
id|sb.buf
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_author_script
c_func
(paren
id|state
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;could not parse author script&quot;
)paren
)paren
suffix:semicolon
id|read_commit_msg
c_func
(paren
id|state
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Removes the am_state directory, forcefully terminating the current am&n; * session.&n; */
DECL|function|am_destroy
r_static
r_void
id|am_destroy
c_func
(paren
r_const
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|sb
comma
id|state-&gt;dir
)paren
suffix:semicolon
id|remove_dir_recursively
c_func
(paren
op_amp
id|sb
comma
l_int|0
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Determines if the file looks like a piece of RFC2822 mail by grabbing all&n; * non-indented lines and checking if they look like they begin with valid&n; * header field names.&n; *&n; * Returns 1 if the file looks like a piece of mail, 0 otherwise.&n; */
DECL|function|is_mail
r_static
r_int
id|is_mail
c_func
(paren
id|FILE
op_star
id|fp
)paren
(brace
r_const
r_char
op_star
id|header_regex
op_assign
l_string|&quot;^[!-9;-~]+:&quot;
suffix:semicolon
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
id|regex_t
id|regex
suffix:semicolon
r_int
id|ret
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|fseek
c_func
(paren
id|fp
comma
l_int|0L
comma
id|SEEK_SET
)paren
)paren
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;fseek failed&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|regcomp
c_func
(paren
op_amp
id|regex
comma
id|header_regex
comma
id|REG_NOSUB
op_or
id|REG_EXTENDED
)paren
)paren
id|die
c_func
(paren
l_string|&quot;invalid pattern: %s&quot;
comma
id|header_regex
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|strbuf_getline_crlf
c_func
(paren
op_amp
id|sb
comma
id|fp
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sb.len
)paren
r_break
suffix:semicolon
multiline_comment|/* End of header */
multiline_comment|/* Ignore indented folded lines */
r_if
c_cond
(paren
op_star
id|sb.buf
op_eq
l_char|&squot;&bslash;t&squot;
op_logical_or
op_star
id|sb.buf
op_eq
l_char|&squot; &squot;
)paren
r_continue
suffix:semicolon
multiline_comment|/* It&squot;s a header if it matches header_regex */
r_if
c_cond
(paren
id|regexec
c_func
(paren
op_amp
id|regex
comma
id|sb.buf
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
)paren
)paren
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
)brace
id|done
suffix:colon
id|regfree
c_func
(paren
op_amp
id|regex
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; * Attempts to detect the patch_format of the patches contained in `paths`,&n; * returning the PATCH_FORMAT_* enum value. Returns PATCH_FORMAT_UNKNOWN if&n; * detection fails.&n; */
DECL|function|detect_patch_format
r_static
r_int
id|detect_patch_format
c_func
(paren
r_const
r_char
op_star
op_star
id|paths
)paren
(brace
r_enum
id|patch_format
id|ret
op_assign
id|PATCH_FORMAT_UNKNOWN
suffix:semicolon
r_struct
id|strbuf
id|l1
op_assign
id|STRBUF_INIT
suffix:semicolon
id|FILE
op_star
id|fp
suffix:semicolon
multiline_comment|/*&n;&t; * We default to mbox format if input is from stdin and for directories&n;&t; */
r_if
c_cond
(paren
op_logical_neg
op_star
id|paths
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
op_star
id|paths
comma
l_string|&quot;-&quot;
)paren
op_logical_or
id|is_directory
c_func
(paren
op_star
id|paths
)paren
)paren
r_return
id|PATCH_FORMAT_MBOX
suffix:semicolon
multiline_comment|/*&n;&t; * Otherwise, check the first few lines of the first patch, starting&n;&t; * from the first non-blank line, to try to detect its format.&n;&t; */
id|fp
op_assign
id|xfopen
c_func
(paren
op_star
id|paths
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|strbuf_getline_crlf
c_func
(paren
op_amp
id|l1
comma
id|fp
)paren
)paren
(brace
r_if
c_cond
(paren
id|l1.len
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|l1.buf
comma
l_string|&quot;From &quot;
)paren
op_logical_or
id|starts_with
c_func
(paren
id|l1.buf
comma
l_string|&quot;From: &quot;
)paren
)paren
(brace
id|ret
op_assign
id|PATCH_FORMAT_MBOX
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_if
c_cond
(paren
id|l1.len
op_logical_and
id|is_mail
c_func
(paren
id|fp
)paren
)paren
(brace
id|ret
op_assign
id|PATCH_FORMAT_MBOX
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|done
suffix:colon
id|fclose
c_func
(paren
id|fp
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|l1
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; * Splits out individual email patches from `paths`, where each path is either&n; * a mbox file or a Maildir. Returns 0 on success, -1 on failure.&n; */
DECL|function|split_mail_mbox
r_static
r_int
id|split_mail_mbox
c_func
(paren
r_struct
id|am_state
op_star
id|state
comma
r_const
r_char
op_star
op_star
id|paths
)paren
(brace
r_struct
id|child_process
id|cp
op_assign
id|CHILD_PROCESS_INIT
suffix:semicolon
r_struct
id|strbuf
id|last
op_assign
id|STRBUF_INIT
suffix:semicolon
id|cp.git_cmd
op_assign
l_int|1
suffix:semicolon
id|argv_array_push
c_func
(paren
op_amp
id|cp.args
comma
l_string|&quot;mailsplit&quot;
)paren
suffix:semicolon
id|argv_array_pushf
c_func
(paren
op_amp
id|cp.args
comma
l_string|&quot;-d%d&quot;
comma
id|state-&gt;prec
)paren
suffix:semicolon
id|argv_array_pushf
c_func
(paren
op_amp
id|cp.args
comma
l_string|&quot;-o%s&quot;
comma
id|state-&gt;dir
)paren
suffix:semicolon
id|argv_array_push
c_func
(paren
op_amp
id|cp.args
comma
l_string|&quot;-b&quot;
)paren
suffix:semicolon
id|argv_array_push
c_func
(paren
op_amp
id|cp.args
comma
l_string|&quot;--&quot;
)paren
suffix:semicolon
id|argv_array_pushv
c_func
(paren
op_amp
id|cp.args
comma
id|paths
)paren
suffix:semicolon
r_if
c_cond
(paren
id|capture_command
c_func
(paren
op_amp
id|cp
comma
op_amp
id|last
comma
l_int|8
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|state-&gt;cur
op_assign
l_int|1
suffix:semicolon
id|state-&gt;last
op_assign
id|strtol
c_func
(paren
id|last.buf
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * Splits a list of files/directories into individual email patches. Each path&n; * in `paths` must be a file/directory that is formatted according to&n; * `patch_format`.&n; *&n; * Once split out, the individual email patches will be stored in the state&n; * directory, with each patch&squot;s filename being its index, padded to state-&gt;prec&n; * digits.&n; *&n; * state-&gt;cur will be set to the index of the first mail, and state-&gt;last will&n; * be set to the index of the last mail.&n; *&n; * Returns 0 on success, -1 on failure.&n; */
DECL|function|split_mail
r_static
r_int
id|split_mail
c_func
(paren
r_struct
id|am_state
op_star
id|state
comma
r_enum
id|patch_format
id|patch_format
comma
r_const
r_char
op_star
op_star
id|paths
)paren
(brace
r_switch
c_cond
(paren
id|patch_format
)paren
(brace
r_case
id|PATCH_FORMAT_MBOX
suffix:colon
r_return
id|split_mail_mbox
c_func
(paren
id|state
comma
id|paths
)paren
suffix:semicolon
r_default
suffix:colon
id|die
c_func
(paren
l_string|&quot;BUG: invalid patch_format&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * Setup a new am session for applying patches&n; */
DECL|function|am_setup
r_static
r_void
id|am_setup
c_func
(paren
r_struct
id|am_state
op_star
id|state
comma
r_enum
id|patch_format
id|patch_format
comma
r_const
r_char
op_star
op_star
id|paths
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|patch_format
)paren
id|patch_format
op_assign
id|detect_patch_format
c_func
(paren
id|paths
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|patch_format
)paren
(brace
id|fprintf_ln
c_func
(paren
id|stderr
comma
id|_
c_func
(paren
l_string|&quot;Patch format detection failed.&quot;
)paren
)paren
suffix:semicolon
m_exit
(paren
l_int|128
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mkdir
c_func
(paren
id|state-&gt;dir
comma
l_int|0777
)paren
OL
l_int|0
op_logical_and
id|errno
op_ne
id|EEXIST
)paren
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;failed to create directory &squot;%s&squot;&quot;
)paren
comma
id|state-&gt;dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|split_mail
c_func
(paren
id|state
comma
id|patch_format
comma
id|paths
)paren
OL
l_int|0
)paren
(brace
id|am_destroy
c_func
(paren
id|state
)paren
suffix:semicolon
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Failed to split patches.&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * NOTE: Since the &quot;next&quot; and &quot;last&quot; files determine if an am_state&n;&t; * session is in progress, they should be written last.&n;&t; */
id|write_file
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;next&quot;
)paren
comma
l_int|1
comma
l_string|&quot;%d&quot;
comma
id|state-&gt;cur
)paren
suffix:semicolon
id|write_file
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;last&quot;
)paren
comma
l_int|1
comma
l_string|&quot;%d&quot;
comma
id|state-&gt;last
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Increments the patch pointer, and cleans am_state for the application of the&n; * next patch.&n; */
DECL|function|am_next
r_static
r_void
id|am_next
c_func
(paren
r_struct
id|am_state
op_star
id|state
)paren
(brace
id|free
c_func
(paren
id|state-&gt;author_name
)paren
suffix:semicolon
id|state-&gt;author_name
op_assign
l_int|NULL
suffix:semicolon
id|free
c_func
(paren
id|state-&gt;author_email
)paren
suffix:semicolon
id|state-&gt;author_email
op_assign
l_int|NULL
suffix:semicolon
id|free
c_func
(paren
id|state-&gt;author_date
)paren
suffix:semicolon
id|state-&gt;author_date
op_assign
l_int|NULL
suffix:semicolon
id|free
c_func
(paren
id|state-&gt;msg
)paren
suffix:semicolon
id|state-&gt;msg
op_assign
l_int|NULL
suffix:semicolon
id|state-&gt;msg_len
op_assign
l_int|0
suffix:semicolon
id|unlink
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;author-script&quot;
)paren
)paren
suffix:semicolon
id|unlink
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;final-commit&quot;
)paren
)paren
suffix:semicolon
id|state-&gt;cur
op_increment
suffix:semicolon
id|write_file
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;next&quot;
)paren
comma
l_int|1
comma
l_string|&quot;%d&quot;
comma
id|state-&gt;cur
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Returns the filename of the current patch email.&n; */
DECL|function|msgnum
r_static
r_const
r_char
op_star
id|msgnum
c_func
(paren
r_const
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_static
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
id|strbuf_reset
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
id|sb
comma
l_string|&quot;%0*d&quot;
comma
id|state-&gt;prec
comma
id|state-&gt;cur
)paren
suffix:semicolon
r_return
id|sb.buf
suffix:semicolon
)brace
multiline_comment|/**&n; * Refresh and write index.&n; */
DECL|function|refresh_and_write_cache
r_static
r_void
id|refresh_and_write_cache
c_func
(paren
r_void
)paren
(brace
r_struct
id|lock_file
op_star
id|lock_file
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|lock_file
)paren
)paren
suffix:semicolon
id|hold_locked_index
c_func
(paren
id|lock_file
comma
l_int|1
)paren
suffix:semicolon
id|refresh_cache
c_func
(paren
id|REFRESH_QUIET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write_locked_index
c_func
(paren
op_amp
id|the_index
comma
id|lock_file
comma
id|COMMIT_LOCK
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;unable to write index file&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Parses `mail` using git-mailinfo, extracting its patch and authorship info.&n; * state-&gt;msg will be set to the patch message. state-&gt;author_name,&n; * state-&gt;author_email and state-&gt;author_date will be set to the patch author&squot;s&n; * name, email and date respectively. The patch body will be written to the&n; * state directory&squot;s &quot;patch&quot; file.&n; *&n; * Returns 1 if the patch should be skipped, 0 otherwise.&n; */
DECL|function|parse_mail
r_static
r_int
id|parse_mail
c_func
(paren
r_struct
id|am_state
op_star
id|state
comma
r_const
r_char
op_star
id|mail
)paren
(brace
id|FILE
op_star
id|fp
suffix:semicolon
r_struct
id|child_process
id|cp
op_assign
id|CHILD_PROCESS_INIT
suffix:semicolon
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
r_struct
id|strbuf
id|msg
op_assign
id|STRBUF_INIT
suffix:semicolon
r_struct
id|strbuf
id|author_name
op_assign
id|STRBUF_INIT
suffix:semicolon
r_struct
id|strbuf
id|author_date
op_assign
id|STRBUF_INIT
suffix:semicolon
r_struct
id|strbuf
id|author_email
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|cp.git_cmd
op_assign
l_int|1
suffix:semicolon
id|cp.in
op_assign
id|xopen
c_func
(paren
id|mail
comma
id|O_RDONLY
comma
l_int|0
)paren
suffix:semicolon
id|cp.out
op_assign
id|xopen
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;info&quot;
)paren
comma
id|O_WRONLY
op_or
id|O_CREAT
comma
l_int|0777
)paren
suffix:semicolon
id|argv_array_push
c_func
(paren
op_amp
id|cp.args
comma
l_string|&quot;mailinfo&quot;
)paren
suffix:semicolon
id|argv_array_push
c_func
(paren
op_amp
id|cp.args
comma
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;msg&quot;
)paren
)paren
suffix:semicolon
id|argv_array_push
c_func
(paren
op_amp
id|cp.args
comma
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;patch&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|run_command
c_func
(paren
op_amp
id|cp
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;could not parse patch&quot;
)paren
suffix:semicolon
id|close
c_func
(paren
id|cp.in
)paren
suffix:semicolon
id|close
c_func
(paren
id|cp.out
)paren
suffix:semicolon
multiline_comment|/* Extract message and author information */
id|fp
op_assign
id|xfopen
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;info&quot;
)paren
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|strbuf_getline
c_func
(paren
op_amp
id|sb
comma
id|fp
comma
l_char|&squot;&bslash;n&squot;
)paren
)paren
(brace
r_const
r_char
op_star
id|x
suffix:semicolon
r_if
c_cond
(paren
id|skip_prefix
c_func
(paren
id|sb.buf
comma
l_string|&quot;Subject: &quot;
comma
op_amp
id|x
)paren
)paren
(brace
r_if
c_cond
(paren
id|msg.len
)paren
id|strbuf_addch
c_func
(paren
op_amp
id|msg
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|msg
comma
id|x
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|skip_prefix
c_func
(paren
id|sb.buf
comma
l_string|&quot;Author: &quot;
comma
op_amp
id|x
)paren
)paren
id|strbuf_addstr
c_func
(paren
op_amp
id|author_name
comma
id|x
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|skip_prefix
c_func
(paren
id|sb.buf
comma
l_string|&quot;Email: &quot;
comma
op_amp
id|x
)paren
)paren
id|strbuf_addstr
c_func
(paren
op_amp
id|author_email
comma
id|x
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|skip_prefix
c_func
(paren
id|sb.buf
comma
l_string|&quot;Date: &quot;
comma
op_amp
id|x
)paren
)paren
id|strbuf_addstr
c_func
(paren
op_amp
id|author_date
comma
id|x
)paren
suffix:semicolon
)brace
id|fclose
c_func
(paren
id|fp
)paren
suffix:semicolon
multiline_comment|/* Skip pine&squot;s internal folder data */
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|author_name.buf
comma
l_string|&quot;Mail System Internal Data&quot;
)paren
)paren
(brace
id|ret
op_assign
l_int|1
suffix:semicolon
r_goto
id|finish
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_empty_file
c_func
(paren
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;patch&quot;
)paren
)paren
)paren
(brace
id|printf_ln
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Patch is empty. Was it split wrong?&quot;
)paren
)paren
suffix:semicolon
m_exit
(paren
l_int|128
)paren
suffix:semicolon
)brace
id|strbuf_addstr
c_func
(paren
op_amp
id|msg
comma
l_string|&quot;&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strbuf_read_file
c_func
(paren
op_amp
id|msg
comma
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;msg&quot;
)paren
comma
l_int|0
)paren
OL
l_int|0
)paren
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;could not read &squot;%s&squot;&quot;
)paren
comma
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;msg&quot;
)paren
)paren
suffix:semicolon
id|stripspace
c_func
(paren
op_amp
id|msg
comma
l_int|0
)paren
suffix:semicolon
m_assert
(paren
op_logical_neg
id|state-&gt;author_name
)paren
suffix:semicolon
id|state-&gt;author_name
op_assign
id|strbuf_detach
c_func
(paren
op_amp
id|author_name
comma
l_int|NULL
)paren
suffix:semicolon
m_assert
(paren
op_logical_neg
id|state-&gt;author_email
)paren
suffix:semicolon
id|state-&gt;author_email
op_assign
id|strbuf_detach
c_func
(paren
op_amp
id|author_email
comma
l_int|NULL
)paren
suffix:semicolon
m_assert
(paren
op_logical_neg
id|state-&gt;author_date
)paren
suffix:semicolon
id|state-&gt;author_date
op_assign
id|strbuf_detach
c_func
(paren
op_amp
id|author_date
comma
l_int|NULL
)paren
suffix:semicolon
m_assert
(paren
op_logical_neg
id|state-&gt;msg
)paren
suffix:semicolon
id|state-&gt;msg
op_assign
id|strbuf_detach
c_func
(paren
op_amp
id|msg
comma
op_amp
id|state-&gt;msg_len
)paren
suffix:semicolon
id|finish
suffix:colon
id|strbuf_release
c_func
(paren
op_amp
id|msg
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|author_date
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|author_email
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|author_name
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; * Applies current patch with git-apply. Returns 0 on success, -1 otherwise.&n; */
DECL|function|run_apply
r_static
r_int
id|run_apply
c_func
(paren
r_const
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_struct
id|child_process
id|cp
op_assign
id|CHILD_PROCESS_INIT
suffix:semicolon
id|cp.git_cmd
op_assign
l_int|1
suffix:semicolon
id|argv_array_push
c_func
(paren
op_amp
id|cp.args
comma
l_string|&quot;apply&quot;
)paren
suffix:semicolon
id|argv_array_push
c_func
(paren
op_amp
id|cp.args
comma
l_string|&quot;--index&quot;
)paren
suffix:semicolon
id|argv_array_push
c_func
(paren
op_amp
id|cp.args
comma
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;patch&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|run_command
c_func
(paren
op_amp
id|cp
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Reload index as git-apply will have modified it. */
id|discard_cache
c_func
(paren
)paren
suffix:semicolon
id|read_cache
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * Commits the current index with state-&gt;msg as the commit message and&n; * state-&gt;author_name, state-&gt;author_email and state-&gt;author_date as the author&n; * information.&n; */
DECL|function|do_commit
r_static
r_void
id|do_commit
c_func
(paren
r_const
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_int
r_char
id|tree
(braket
id|GIT_SHA1_RAWSZ
)braket
comma
id|parent
(braket
id|GIT_SHA1_RAWSZ
)braket
comma
id|commit
(braket
id|GIT_SHA1_RAWSZ
)braket
suffix:semicolon
r_int
r_char
op_star
id|ptr
suffix:semicolon
r_struct
id|commit_list
op_star
id|parents
op_assign
l_int|NULL
suffix:semicolon
r_const
r_char
op_star
id|reflog_msg
comma
op_star
id|author
suffix:semicolon
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
r_if
c_cond
(paren
id|write_cache_as_tree
c_func
(paren
id|tree
comma
l_int|0
comma
l_int|NULL
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;git write-tree failed to write a tree&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|get_sha1_commit
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|parent
)paren
)paren
(brace
id|ptr
op_assign
id|parent
suffix:semicolon
id|commit_list_insert
c_func
(paren
id|lookup_commit
c_func
(paren
id|parent
)paren
comma
op_amp
id|parents
)paren
suffix:semicolon
)brace
r_else
(brace
id|ptr
op_assign
l_int|NULL
suffix:semicolon
id|fprintf_ln
c_func
(paren
id|stderr
comma
id|_
c_func
(paren
l_string|&quot;applying to an empty history&quot;
)paren
)paren
suffix:semicolon
)brace
id|author
op_assign
id|fmt_ident
c_func
(paren
id|state-&gt;author_name
comma
id|state-&gt;author_email
comma
id|state-&gt;author_date
comma
id|IDENT_STRICT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|commit_tree
c_func
(paren
id|state-&gt;msg
comma
id|state-&gt;msg_len
comma
id|tree
comma
id|parents
comma
id|commit
comma
id|author
comma
l_int|NULL
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;failed to write commit object&quot;
)paren
)paren
suffix:semicolon
id|reflog_msg
op_assign
id|getenv
c_func
(paren
l_string|&quot;GIT_REFLOG_ACTION&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|reflog_msg
)paren
id|reflog_msg
op_assign
l_string|&quot;am&quot;
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
id|sb
comma
l_string|&quot;%s: %.*s&quot;
comma
id|reflog_msg
comma
id|linelen
c_func
(paren
id|state-&gt;msg
)paren
comma
id|state-&gt;msg
)paren
suffix:semicolon
id|update_ref
c_func
(paren
id|sb.buf
comma
l_string|&quot;HEAD&quot;
comma
id|commit
comma
id|ptr
comma
l_int|0
comma
id|UPDATE_REFS_DIE_ON_ERR
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Applies all queued mail.&n; */
DECL|function|am_run
r_static
r_void
id|am_run
c_func
(paren
r_struct
id|am_state
op_star
id|state
)paren
(brace
r_const
r_char
op_star
id|argv_gc_auto
(braket
)braket
op_assign
(brace
l_string|&quot;gc&quot;
comma
l_string|&quot;--auto&quot;
comma
l_int|NULL
)brace
suffix:semicolon
id|refresh_and_write_cache
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|state-&gt;cur
op_le
id|state-&gt;last
)paren
(brace
r_const
r_char
op_star
id|mail
op_assign
id|am_path
c_func
(paren
id|state
comma
id|msgnum
c_func
(paren
id|state
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file_exists
c_func
(paren
id|mail
)paren
)paren
r_goto
id|next
suffix:semicolon
r_if
c_cond
(paren
id|parse_mail
c_func
(paren
id|state
comma
id|mail
)paren
)paren
r_goto
id|next
suffix:semicolon
multiline_comment|/* mail should be skipped */
id|write_author_script
c_func
(paren
id|state
)paren
suffix:semicolon
id|write_commit_msg
c_func
(paren
id|state
)paren
suffix:semicolon
id|printf_ln
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Applying: %.*s&quot;
)paren
comma
id|linelen
c_func
(paren
id|state-&gt;msg
)paren
comma
id|state-&gt;msg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|run_apply
c_func
(paren
id|state
)paren
OL
l_int|0
)paren
(brace
r_int
id|advice_amworkdir
op_assign
l_int|1
suffix:semicolon
id|printf_ln
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Patch failed at %s %.*s&quot;
)paren
comma
id|msgnum
c_func
(paren
id|state
)paren
comma
id|linelen
c_func
(paren
id|state-&gt;msg
)paren
comma
id|state-&gt;msg
)paren
suffix:semicolon
id|git_config_get_bool
c_func
(paren
l_string|&quot;advice.amworkdir&quot;
comma
op_amp
id|advice_amworkdir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|advice_amworkdir
)paren
id|printf_ln
c_func
(paren
id|_
c_func
(paren
l_string|&quot;The copy of the patch that failed is found in: %s&quot;
)paren
comma
id|am_path
c_func
(paren
id|state
comma
l_string|&quot;patch&quot;
)paren
)paren
suffix:semicolon
m_exit
(paren
l_int|128
)paren
suffix:semicolon
)brace
id|do_commit
c_func
(paren
id|state
)paren
suffix:semicolon
id|next
suffix:colon
id|am_next
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
id|am_destroy
c_func
(paren
id|state
)paren
suffix:semicolon
id|run_command_v_opt
c_func
(paren
id|argv_gc_auto
comma
id|RUN_GIT_CMD
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * parse_options() callback that validates and sets opt-&gt;value to the&n; * PATCH_FORMAT_* enum value corresponding to `arg`.&n; */
DECL|function|parse_opt_patchformat
r_static
r_int
id|parse_opt_patchformat
c_func
(paren
r_const
r_struct
id|option
op_star
id|opt
comma
r_const
r_char
op_star
id|arg
comma
r_int
id|unset
)paren
(brace
r_int
op_star
id|opt_value
op_assign
id|opt-&gt;value
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;mbox&quot;
)paren
)paren
op_star
id|opt_value
op_assign
id|PATCH_FORMAT_MBOX
suffix:semicolon
r_else
r_return
id|error
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Invalid value for --patch-format: %s&quot;
)paren
comma
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cmd_am
r_int
id|cmd_am
c_func
(paren
r_int
id|argc
comma
r_const
r_char
op_star
op_star
id|argv
comma
r_const
r_char
op_star
id|prefix
)paren
(brace
r_struct
id|am_state
id|state
suffix:semicolon
r_int
id|patch_format
op_assign
id|PATCH_FORMAT_UNKNOWN
suffix:semicolon
r_const
r_char
op_star
r_const
id|usage
(braket
)braket
op_assign
(brace
id|N_
c_func
(paren
l_string|&quot;git am [options] [(&lt;mbox&gt;|&lt;Maildir&gt;)...]&quot;
)paren
comma
l_int|NULL
)brace
suffix:semicolon
r_struct
id|option
id|options
(braket
)braket
op_assign
(brace
id|OPT_CALLBACK
c_func
(paren
l_int|0
comma
l_string|&quot;patch-format&quot;
comma
op_amp
id|patch_format
comma
id|N_
c_func
(paren
l_string|&quot;format&quot;
)paren
comma
id|N_
c_func
(paren
l_string|&quot;format the patch(es) are in&quot;
)paren
comma
id|parse_opt_patchformat
)paren
comma
id|OPT_END
c_func
(paren
)paren
)brace
suffix:semicolon
multiline_comment|/*&n;&t; * NEEDSWORK: Once all the features of git-am.sh have been&n;&t; * re-implemented in builtin/am.c, this preamble can be removed.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|getenv
c_func
(paren
l_string|&quot;_GIT_USE_BUILTIN_AM&quot;
)paren
)paren
(brace
r_const
r_char
op_star
id|path
op_assign
id|mkpath
c_func
(paren
l_string|&quot;%s/git-am&quot;
comma
id|git_exec_path
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sane_execvp
c_func
(paren
id|path
comma
(paren
r_char
op_star
op_star
)paren
id|argv
)paren
OL
l_int|0
)paren
id|die_errno
c_func
(paren
l_string|&quot;could not exec %s&quot;
comma
id|path
)paren
suffix:semicolon
)brace
r_else
(brace
id|prefix
op_assign
id|setup_git_directory
c_func
(paren
)paren
suffix:semicolon
id|trace_repo_setup
c_func
(paren
id|prefix
)paren
suffix:semicolon
id|setup_work_tree
c_func
(paren
)paren
suffix:semicolon
)brace
id|git_config
c_func
(paren
id|git_default_config
comma
l_int|NULL
)paren
suffix:semicolon
id|am_state_init
c_func
(paren
op_amp
id|state
comma
id|git_path
c_func
(paren
l_string|&quot;rebase-apply&quot;
)paren
)paren
suffix:semicolon
id|argc
op_assign
id|parse_options
c_func
(paren
id|argc
comma
id|argv
comma
id|prefix
comma
id|options
comma
id|usage
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_index_preload
c_func
(paren
op_amp
id|the_index
comma
l_int|NULL
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;failed to read the index&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|am_in_progress
c_func
(paren
op_amp
id|state
)paren
)paren
id|am_load
c_func
(paren
op_amp
id|state
)paren
suffix:semicolon
r_else
(brace
r_struct
id|argv_array
id|paths
op_assign
id|ARGV_ARRAY_INIT
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|argc
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|is_absolute_path
c_func
(paren
id|argv
(braket
id|i
)braket
)paren
op_logical_or
op_logical_neg
id|prefix
)paren
id|argv_array_push
c_func
(paren
op_amp
id|paths
comma
id|argv
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|argv_array_push
c_func
(paren
op_amp
id|paths
comma
id|mkpath
c_func
(paren
l_string|&quot;%s/%s&quot;
comma
id|prefix
comma
id|argv
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
)brace
id|am_setup
c_func
(paren
op_amp
id|state
comma
id|patch_format
comma
id|paths.argv
)paren
suffix:semicolon
id|argv_array_clear
c_func
(paren
op_amp
id|paths
)paren
suffix:semicolon
)brace
id|am_run
c_func
(paren
op_amp
id|state
)paren
suffix:semicolon
id|am_state_release
c_func
(paren
op_amp
id|state
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
