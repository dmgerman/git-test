multiline_comment|/*&n; * Blame&n; *&n; * Copyright (c) 2006, 2014 by its authors&n; * See COPYING for licensing conditions&n; */
macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;refs.h&quot;
macro_line|#include &quot;builtin.h&quot;
macro_line|#include &quot;blob.h&quot;
macro_line|#include &quot;commit.h&quot;
macro_line|#include &quot;tag.h&quot;
macro_line|#include &quot;tree-walk.h&quot;
macro_line|#include &quot;diff.h&quot;
macro_line|#include &quot;diffcore.h&quot;
macro_line|#include &quot;revision.h&quot;
macro_line|#include &quot;quote.h&quot;
macro_line|#include &quot;xdiff-interface.h&quot;
macro_line|#include &quot;cache-tree.h&quot;
macro_line|#include &quot;string-list.h&quot;
macro_line|#include &quot;mailmap.h&quot;
macro_line|#include &quot;mergesort.h&quot;
macro_line|#include &quot;parse-options.h&quot;
macro_line|#include &quot;prio-queue.h&quot;
macro_line|#include &quot;utf8.h&quot;
macro_line|#include &quot;userdiff.h&quot;
macro_line|#include &quot;line-range.h&quot;
macro_line|#include &quot;line-log.h&quot;
macro_line|#include &quot;dir.h&quot;
DECL|variable|blame_usage
r_static
r_char
id|blame_usage
(braket
)braket
op_assign
id|N_
c_func
(paren
l_string|&quot;git blame [&lt;options&gt;] [&lt;rev-opts&gt;] [&lt;rev&gt;] [--] &lt;file&gt;&quot;
)paren
suffix:semicolon
DECL|variable|blame_opt_usage
r_static
r_const
r_char
op_star
id|blame_opt_usage
(braket
)braket
op_assign
(brace
id|blame_usage
comma
l_string|&quot;&quot;
comma
id|N_
c_func
(paren
l_string|&quot;&lt;rev-opts&gt; are documented in git-rev-list(1)&quot;
)paren
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|longest_file
r_static
r_int
id|longest_file
suffix:semicolon
DECL|variable|longest_author
r_static
r_int
id|longest_author
suffix:semicolon
DECL|variable|max_orig_digits
r_static
r_int
id|max_orig_digits
suffix:semicolon
DECL|variable|max_digits
r_static
r_int
id|max_digits
suffix:semicolon
DECL|variable|max_score_digits
r_static
r_int
id|max_score_digits
suffix:semicolon
DECL|variable|show_root
r_static
r_int
id|show_root
suffix:semicolon
DECL|variable|reverse
r_static
r_int
id|reverse
suffix:semicolon
DECL|variable|blank_boundary
r_static
r_int
id|blank_boundary
suffix:semicolon
DECL|variable|incremental
r_static
r_int
id|incremental
suffix:semicolon
DECL|variable|xdl_opts
r_static
r_int
id|xdl_opts
suffix:semicolon
DECL|variable|abbrev
r_static
r_int
id|abbrev
op_assign
l_int|1
suffix:semicolon
DECL|variable|no_whole_file_rename
r_static
r_int
id|no_whole_file_rename
suffix:semicolon
DECL|variable|blame_date_mode
r_static
r_struct
id|date_mode
id|blame_date_mode
op_assign
(brace
id|DATE_ISO8601
)brace
suffix:semicolon
DECL|variable|blame_date_width
r_static
r_int
id|blame_date_width
suffix:semicolon
DECL|variable|mailmap
r_static
r_struct
id|string_list
id|mailmap
suffix:semicolon
macro_line|#ifndef DEBUG
DECL|macro|DEBUG
mdefine_line|#define DEBUG 0
macro_line|#endif
multiline_comment|/* stats */
DECL|variable|num_read_blob
r_static
r_int
id|num_read_blob
suffix:semicolon
DECL|variable|num_get_patch
r_static
r_int
id|num_get_patch
suffix:semicolon
DECL|variable|num_commits
r_static
r_int
id|num_commits
suffix:semicolon
DECL|macro|PICKAXE_BLAME_MOVE
mdefine_line|#define PICKAXE_BLAME_MOVE&t;&t;01
DECL|macro|PICKAXE_BLAME_COPY
mdefine_line|#define PICKAXE_BLAME_COPY&t;&t;02
DECL|macro|PICKAXE_BLAME_COPY_HARDER
mdefine_line|#define PICKAXE_BLAME_COPY_HARDER&t;04
DECL|macro|PICKAXE_BLAME_COPY_HARDEST
mdefine_line|#define PICKAXE_BLAME_COPY_HARDEST&t;010
multiline_comment|/*&n; * blame for a blame_entry with score lower than these thresholds&n; * is not passed to the parent using move/copy logic.&n; */
DECL|variable|blame_move_score
r_static
r_int
id|blame_move_score
suffix:semicolon
DECL|variable|blame_copy_score
r_static
r_int
id|blame_copy_score
suffix:semicolon
DECL|macro|BLAME_DEFAULT_MOVE_SCORE
mdefine_line|#define BLAME_DEFAULT_MOVE_SCORE&t;20
DECL|macro|BLAME_DEFAULT_COPY_SCORE
mdefine_line|#define BLAME_DEFAULT_COPY_SCORE&t;40
multiline_comment|/* Remember to update object flag allocation in object.h */
DECL|macro|METAINFO_SHOWN
mdefine_line|#define METAINFO_SHOWN&t;&t;(1u&lt;&lt;12)
DECL|macro|MORE_THAN_ONE_PATH
mdefine_line|#define MORE_THAN_ONE_PATH&t;(1u&lt;&lt;13)
multiline_comment|/*&n; * One blob in a commit that is being suspected&n; */
DECL|struct|origin
r_struct
id|origin
(brace
DECL|member|refcnt
r_int
id|refcnt
suffix:semicolon
multiline_comment|/* Record preceding blame record for this blob */
DECL|member|previous
r_struct
id|origin
op_star
id|previous
suffix:semicolon
multiline_comment|/* origins are put in a list linked via `next&squot; hanging off the&n;&t; * corresponding commit&squot;s util field in order to make finding&n;&t; * them fast.  The presence in this chain does not count&n;&t; * towards the origin&squot;s reference count.  It is tempting to&n;&t; * let it count as long as the commit is pending examination,&n;&t; * but even under circumstances where the commit will be&n;&t; * present multiple times in the priority queue of unexamined&n;&t; * commits, processing the first instance will not leave any&n;&t; * work requiring the origin data for the second instance.  An&n;&t; * interspersed commit changing that would have to be&n;&t; * preexisting with a different ancestry and with the same&n;&t; * commit date in order to wedge itself between two instances&n;&t; * of the same commit in the priority queue _and_ produce&n;&t; * blame entries relevant for it.  While we don&squot;t want to let&n;&t; * us get tripped up by this case, it certainly does not seem&n;&t; * worth optimizing for.&n;&t; */
DECL|member|next
r_struct
id|origin
op_star
id|next
suffix:semicolon
DECL|member|commit
r_struct
id|commit
op_star
id|commit
suffix:semicolon
multiline_comment|/* `suspects&squot; contains blame entries that may be attributed to&n;&t; * this origin&squot;s commit or to parent commits.  When a commit&n;&t; * is being processed, all suspects will be moved, either by&n;&t; * assigning them to an origin in a different commit, or by&n;&t; * shipping them to the scoreboard&squot;s ent list because they&n;&t; * cannot be attributed to a different commit.&n;&t; */
DECL|member|suspects
r_struct
id|blame_entry
op_star
id|suspects
suffix:semicolon
DECL|member|file
id|mmfile_t
id|file
suffix:semicolon
DECL|member|blob_sha1
r_int
r_char
id|blob_sha1
(braket
l_int|20
)braket
suffix:semicolon
DECL|member|mode
r_int
id|mode
suffix:semicolon
multiline_comment|/* guilty gets set when shipping any suspects to the final&n;&t; * blame list instead of other commits&n;&t; */
DECL|member|guilty
r_char
id|guilty
suffix:semicolon
DECL|member|path
r_char
id|path
(braket
id|FLEX_ARRAY
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|function|diff_hunks
r_static
r_int
id|diff_hunks
c_func
(paren
id|mmfile_t
op_star
id|file_a
comma
id|mmfile_t
op_star
id|file_b
comma
r_int
id|ctxlen
comma
id|xdl_emit_hunk_consume_func_t
id|hunk_func
comma
r_void
op_star
id|cb_data
)paren
(brace
id|xpparam_t
id|xpp
op_assign
(brace
l_int|0
)brace
suffix:semicolon
id|xdemitconf_t
id|xecfg
op_assign
(brace
l_int|0
)brace
suffix:semicolon
id|xdemitcb_t
id|ecb
op_assign
(brace
l_int|NULL
)brace
suffix:semicolon
id|xpp.flags
op_assign
id|xdl_opts
suffix:semicolon
id|xecfg.ctxlen
op_assign
id|ctxlen
suffix:semicolon
id|xecfg.hunk_func
op_assign
id|hunk_func
suffix:semicolon
id|ecb.priv
op_assign
id|cb_data
suffix:semicolon
r_return
id|xdi_diff
c_func
(paren
id|file_a
comma
id|file_b
comma
op_amp
id|xpp
comma
op_amp
id|xecfg
comma
op_amp
id|ecb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Prepare diff_filespec and convert it using diff textconv API&n; * if the textconv driver exists.&n; * Return 1 if the conversion succeeds, 0 otherwise.&n; */
DECL|function|textconv_object
r_int
id|textconv_object
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_int
id|mode
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
id|sha1_valid
comma
r_char
op_star
op_star
id|buf
comma
r_int
r_int
op_star
id|buf_size
)paren
(brace
r_struct
id|diff_filespec
op_star
id|df
suffix:semicolon
r_struct
id|userdiff_driver
op_star
id|textconv
suffix:semicolon
id|df
op_assign
id|alloc_filespec
c_func
(paren
id|path
)paren
suffix:semicolon
id|fill_filespec
c_func
(paren
id|df
comma
id|sha1
comma
id|sha1_valid
comma
id|mode
)paren
suffix:semicolon
id|textconv
op_assign
id|get_textconv
c_func
(paren
id|df
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|textconv
)paren
(brace
id|free_filespec
c_func
(paren
id|df
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
op_star
id|buf_size
op_assign
id|fill_textconv
c_func
(paren
id|textconv
comma
id|df
comma
id|buf
)paren
suffix:semicolon
id|free_filespec
c_func
(paren
id|df
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Given an origin, prepare mmfile_t structure to be used by the&n; * diff machinery&n; */
DECL|function|fill_origin_blob
r_static
r_void
id|fill_origin_blob
c_func
(paren
r_struct
id|diff_options
op_star
id|opt
comma
r_struct
id|origin
op_star
id|o
comma
id|mmfile_t
op_star
id|file
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|o-&gt;file.ptr
)paren
(brace
r_enum
id|object_type
id|type
suffix:semicolon
r_int
r_int
id|file_size
suffix:semicolon
id|num_read_blob
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|DIFF_OPT_TST
c_func
(paren
id|opt
comma
id|ALLOW_TEXTCONV
)paren
op_logical_and
id|textconv_object
c_func
(paren
id|o-&gt;path
comma
id|o-&gt;mode
comma
id|o-&gt;blob_sha1
comma
l_int|1
comma
op_amp
id|file-&gt;ptr
comma
op_amp
id|file_size
)paren
)paren
suffix:semicolon
r_else
id|file-&gt;ptr
op_assign
id|read_sha1_file
c_func
(paren
id|o-&gt;blob_sha1
comma
op_amp
id|type
comma
op_amp
id|file_size
)paren
suffix:semicolon
id|file-&gt;size
op_assign
id|file_size
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file-&gt;ptr
)paren
id|die
c_func
(paren
l_string|&quot;Cannot read blob %s for path %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|o-&gt;blob_sha1
)paren
comma
id|o-&gt;path
)paren
suffix:semicolon
id|o-&gt;file
op_assign
op_star
id|file
suffix:semicolon
)brace
r_else
op_star
id|file
op_assign
id|o-&gt;file
suffix:semicolon
)brace
multiline_comment|/*&n; * Origin is refcounted and usually we keep the blob contents to be&n; * reused.&n; */
DECL|function|origin_incref
r_static
r_inline
r_struct
id|origin
op_star
id|origin_incref
c_func
(paren
r_struct
id|origin
op_star
id|o
)paren
(brace
r_if
c_cond
(paren
id|o
)paren
id|o-&gt;refcnt
op_increment
suffix:semicolon
r_return
id|o
suffix:semicolon
)brace
DECL|function|origin_decref
r_static
r_void
id|origin_decref
c_func
(paren
r_struct
id|origin
op_star
id|o
)paren
(brace
r_if
c_cond
(paren
id|o
op_logical_and
op_decrement
id|o-&gt;refcnt
op_le
l_int|0
)paren
(brace
r_struct
id|origin
op_star
id|p
comma
op_star
id|l
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|o-&gt;previous
)paren
id|origin_decref
c_func
(paren
id|o-&gt;previous
)paren
suffix:semicolon
id|free
c_func
(paren
id|o-&gt;file.ptr
)paren
suffix:semicolon
multiline_comment|/* Should be present exactly once in commit chain */
r_for
c_loop
(paren
id|p
op_assign
id|o-&gt;commit-&gt;util
suffix:semicolon
id|p
suffix:semicolon
id|l
op_assign
id|p
comma
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|p
op_eq
id|o
)paren
(brace
r_if
c_cond
(paren
id|l
)paren
id|l-&gt;next
op_assign
id|p-&gt;next
suffix:semicolon
r_else
id|o-&gt;commit-&gt;util
op_assign
id|p-&gt;next
suffix:semicolon
id|free
c_func
(paren
id|o
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|die
c_func
(paren
l_string|&quot;internal error in blame::origin_decref&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|function|drop_origin_blob
r_static
r_void
id|drop_origin_blob
c_func
(paren
r_struct
id|origin
op_star
id|o
)paren
(brace
r_if
c_cond
(paren
id|o-&gt;file.ptr
)paren
(brace
id|free
c_func
(paren
id|o-&gt;file.ptr
)paren
suffix:semicolon
id|o-&gt;file.ptr
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Each group of lines is described by a blame_entry; it can be split&n; * as we pass blame to the parents.  They are arranged in linked lists&n; * kept as `suspects&squot; of some unprocessed origin, or entered (when the&n; * blame origin has been finalized) into the scoreboard structure.&n; * While the scoreboard structure is only sorted at the end of&n; * processing (according to final image line number), the lists&n; * attached to an origin are sorted by the target line number.&n; */
DECL|struct|blame_entry
r_struct
id|blame_entry
(brace
DECL|member|next
r_struct
id|blame_entry
op_star
id|next
suffix:semicolon
multiline_comment|/* the first line of this group in the final image;&n;&t; * internally all line numbers are 0 based.&n;&t; */
DECL|member|lno
r_int
id|lno
suffix:semicolon
multiline_comment|/* how many lines this group has */
DECL|member|num_lines
r_int
id|num_lines
suffix:semicolon
multiline_comment|/* the commit that introduced this group into the final image */
DECL|member|suspect
r_struct
id|origin
op_star
id|suspect
suffix:semicolon
multiline_comment|/* the line number of the first line of this group in the&n;&t; * suspect&squot;s file; internally all line numbers are 0 based.&n;&t; */
DECL|member|s_lno
r_int
id|s_lno
suffix:semicolon
multiline_comment|/* how significant this entry is -- cached to avoid&n;&t; * scanning the lines over and over.&n;&t; */
DECL|member|score
r_int
id|score
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Any merge of blames happens on lists of blames that arrived via&n; * different parents in a single suspect.  In this case, we want to&n; * sort according to the suspect line numbers as opposed to the final&n; * image line numbers.  The function body is somewhat longish because&n; * it avoids unnecessary writes.&n; */
DECL|function|blame_merge
r_static
r_struct
id|blame_entry
op_star
id|blame_merge
c_func
(paren
r_struct
id|blame_entry
op_star
id|list1
comma
r_struct
id|blame_entry
op_star
id|list2
)paren
(brace
r_struct
id|blame_entry
op_star
id|p1
op_assign
id|list1
comma
op_star
id|p2
op_assign
id|list2
comma
op_star
op_star
id|tail
op_assign
op_amp
id|list1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p1
)paren
r_return
id|p2
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p2
)paren
r_return
id|p1
suffix:semicolon
r_if
c_cond
(paren
id|p1-&gt;s_lno
op_le
id|p2-&gt;s_lno
)paren
(brace
r_do
(brace
id|tail
op_assign
op_amp
id|p1-&gt;next
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p1
op_assign
op_star
id|tail
)paren
op_eq
l_int|NULL
)paren
(brace
op_star
id|tail
op_assign
id|p2
suffix:semicolon
r_return
id|list1
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|p1-&gt;s_lno
op_le
id|p2-&gt;s_lno
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
op_star
id|tail
op_assign
id|p2
suffix:semicolon
r_do
(brace
id|tail
op_assign
op_amp
id|p2-&gt;next
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p2
op_assign
op_star
id|tail
)paren
op_eq
l_int|NULL
)paren
(brace
op_star
id|tail
op_assign
id|p1
suffix:semicolon
r_return
id|list1
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|p1-&gt;s_lno
OG
id|p2-&gt;s_lno
)paren
suffix:semicolon
op_star
id|tail
op_assign
id|p1
suffix:semicolon
r_do
(brace
id|tail
op_assign
op_amp
id|p1-&gt;next
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p1
op_assign
op_star
id|tail
)paren
op_eq
l_int|NULL
)paren
(brace
op_star
id|tail
op_assign
id|p2
suffix:semicolon
r_return
id|list1
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|p1-&gt;s_lno
op_le
id|p2-&gt;s_lno
)paren
suffix:semicolon
)brace
)brace
DECL|function|get_next_blame
r_static
r_void
op_star
id|get_next_blame
c_func
(paren
r_const
r_void
op_star
id|p
)paren
(brace
r_return
(paren
(paren
r_struct
id|blame_entry
op_star
)paren
id|p
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
)brace
DECL|function|set_next_blame
r_static
r_void
id|set_next_blame
c_func
(paren
r_void
op_star
id|p1
comma
r_void
op_star
id|p2
)paren
(brace
(paren
(paren
r_struct
id|blame_entry
op_star
)paren
id|p1
)paren
op_member_access_from_pointer
id|next
op_assign
id|p2
suffix:semicolon
)brace
multiline_comment|/*&n; * Final image line numbers are all different, so we don&squot;t need a&n; * three-way comparison here.&n; */
DECL|function|compare_blame_final
r_static
r_int
id|compare_blame_final
c_func
(paren
r_const
r_void
op_star
id|p1
comma
r_const
r_void
op_star
id|p2
)paren
(brace
r_return
(paren
(paren
r_struct
id|blame_entry
op_star
)paren
id|p1
)paren
op_member_access_from_pointer
id|lno
OG
(paren
(paren
r_struct
id|blame_entry
op_star
)paren
id|p2
)paren
op_member_access_from_pointer
id|lno
ques
c_cond
l_int|1
suffix:colon
l_int|1
suffix:semicolon
)brace
DECL|function|compare_blame_suspect
r_static
r_int
id|compare_blame_suspect
c_func
(paren
r_const
r_void
op_star
id|p1
comma
r_const
r_void
op_star
id|p2
)paren
(brace
r_const
r_struct
id|blame_entry
op_star
id|s1
op_assign
id|p1
comma
op_star
id|s2
op_assign
id|p2
suffix:semicolon
multiline_comment|/*&n;&t; * to allow for collating suspects, we sort according to the&n;&t; * respective pointer value as the primary sorting criterion.&n;&t; * The actual relation is pretty unimportant as long as it&n;&t; * establishes a total order.  Comparing as integers gives us&n;&t; * that.&n;&t; */
r_if
c_cond
(paren
id|s1-&gt;suspect
op_ne
id|s2-&gt;suspect
)paren
r_return
(paren
r_intptr
)paren
id|s1-&gt;suspect
OG
(paren
r_intptr
)paren
id|s2-&gt;suspect
ques
c_cond
l_int|1
suffix:colon
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|s1-&gt;s_lno
op_eq
id|s2-&gt;s_lno
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|s1-&gt;s_lno
OG
id|s2-&gt;s_lno
ques
c_cond
l_int|1
suffix:colon
l_int|1
suffix:semicolon
)brace
DECL|function|blame_sort
r_static
r_struct
id|blame_entry
op_star
id|blame_sort
c_func
(paren
r_struct
id|blame_entry
op_star
id|head
comma
r_int
(paren
op_star
id|compare_fn
)paren
(paren
r_const
r_void
op_star
comma
r_const
r_void
op_star
)paren
)paren
(brace
r_return
id|llist_mergesort
(paren
id|head
comma
id|get_next_blame
comma
id|set_next_blame
comma
id|compare_fn
)paren
suffix:semicolon
)brace
DECL|function|compare_commits_by_reverse_commit_date
r_static
r_int
id|compare_commits_by_reverse_commit_date
c_func
(paren
r_const
r_void
op_star
id|a
comma
r_const
r_void
op_star
id|b
comma
r_void
op_star
id|c
)paren
(brace
r_return
id|compare_commits_by_commit_date
c_func
(paren
id|a
comma
id|b
comma
id|c
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The current state of the blame assignment.&n; */
DECL|struct|scoreboard
r_struct
id|scoreboard
(brace
multiline_comment|/* the final commit (i.e. where we started digging from) */
DECL|member|final
r_struct
id|commit
op_star
id|final
suffix:semicolon
multiline_comment|/* Priority queue for commits with unassigned blame records */
DECL|member|commits
r_struct
id|prio_queue
id|commits
suffix:semicolon
DECL|member|revs
r_struct
id|rev_info
op_star
id|revs
suffix:semicolon
DECL|member|path
r_const
r_char
op_star
id|path
suffix:semicolon
multiline_comment|/*&n;&t; * The contents in the final image.&n;&t; * Used by many functions to obtain contents of the nth line,&n;&t; * indexed with scoreboard.lineno[blame_entry.lno].&n;&t; */
DECL|member|final_buf
r_const
r_char
op_star
id|final_buf
suffix:semicolon
DECL|member|final_buf_size
r_int
r_int
id|final_buf_size
suffix:semicolon
multiline_comment|/* linked list of blames */
DECL|member|ent
r_struct
id|blame_entry
op_star
id|ent
suffix:semicolon
multiline_comment|/* look-up a line in the final buffer */
DECL|member|num_lines
r_int
id|num_lines
suffix:semicolon
DECL|member|lineno
r_int
op_star
id|lineno
suffix:semicolon
)brace
suffix:semicolon
r_static
r_void
id|sanity_check_refcnt
c_func
(paren
r_struct
id|scoreboard
op_star
)paren
suffix:semicolon
multiline_comment|/*&n; * If two blame entries that are next to each other came from&n; * contiguous lines in the same origin (i.e. &lt;commit, path&gt; pair),&n; * merge them together.&n; */
DECL|function|coalesce
r_static
r_void
id|coalesce
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
)paren
(brace
r_struct
id|blame_entry
op_star
id|ent
comma
op_star
id|next
suffix:semicolon
r_for
c_loop
(paren
id|ent
op_assign
id|sb-&gt;ent
suffix:semicolon
id|ent
op_logical_and
(paren
id|next
op_assign
id|ent-&gt;next
)paren
suffix:semicolon
id|ent
op_assign
id|next
)paren
(brace
r_if
c_cond
(paren
id|ent-&gt;suspect
op_eq
id|next-&gt;suspect
op_logical_and
id|ent-&gt;s_lno
op_plus
id|ent-&gt;num_lines
op_eq
id|next-&gt;s_lno
)paren
(brace
id|ent-&gt;num_lines
op_add_assign
id|next-&gt;num_lines
suffix:semicolon
id|ent-&gt;next
op_assign
id|next-&gt;next
suffix:semicolon
id|origin_decref
c_func
(paren
id|next-&gt;suspect
)paren
suffix:semicolon
id|free
c_func
(paren
id|next
)paren
suffix:semicolon
id|ent-&gt;score
op_assign
l_int|0
suffix:semicolon
id|next
op_assign
id|ent
suffix:semicolon
multiline_comment|/* again */
)brace
)brace
r_if
c_cond
(paren
id|DEBUG
)paren
multiline_comment|/* sanity */
id|sanity_check_refcnt
c_func
(paren
id|sb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Merge the given sorted list of blames into a preexisting origin.&n; * If there were no previous blames to that commit, it is entered into&n; * the commit priority queue of the score board.&n; */
DECL|function|queue_blames
r_static
r_void
id|queue_blames
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_struct
id|origin
op_star
id|porigin
comma
r_struct
id|blame_entry
op_star
id|sorted
)paren
(brace
r_if
c_cond
(paren
id|porigin-&gt;suspects
)paren
id|porigin-&gt;suspects
op_assign
id|blame_merge
c_func
(paren
id|porigin-&gt;suspects
comma
id|sorted
)paren
suffix:semicolon
r_else
(brace
r_struct
id|origin
op_star
id|o
suffix:semicolon
r_for
c_loop
(paren
id|o
op_assign
id|porigin-&gt;commit-&gt;util
suffix:semicolon
id|o
suffix:semicolon
id|o
op_assign
id|o-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|o-&gt;suspects
)paren
(brace
id|porigin-&gt;suspects
op_assign
id|sorted
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|porigin-&gt;suspects
op_assign
id|sorted
suffix:semicolon
id|prio_queue_put
c_func
(paren
op_amp
id|sb-&gt;commits
comma
id|porigin-&gt;commit
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Given a commit and a path in it, create a new origin structure.&n; * The callers that add blame to the scoreboard should use&n; * get_origin() to obtain shared, refcounted copy instead of calling&n; * this function directly.&n; */
DECL|function|make_origin
r_static
r_struct
id|origin
op_star
id|make_origin
c_func
(paren
r_struct
id|commit
op_star
id|commit
comma
r_const
r_char
op_star
id|path
)paren
(brace
r_struct
id|origin
op_star
id|o
suffix:semicolon
r_int
id|pathlen
op_assign
id|strlen
c_func
(paren
id|path
)paren
op_plus
l_int|1
suffix:semicolon
id|o
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|o
)paren
op_plus
id|pathlen
)paren
suffix:semicolon
id|o-&gt;commit
op_assign
id|commit
suffix:semicolon
id|o-&gt;refcnt
op_assign
l_int|1
suffix:semicolon
id|o-&gt;next
op_assign
id|commit-&gt;util
suffix:semicolon
id|commit-&gt;util
op_assign
id|o
suffix:semicolon
id|memcpy
c_func
(paren
id|o-&gt;path
comma
id|path
comma
id|pathlen
)paren
suffix:semicolon
multiline_comment|/* includes NUL */
r_return
id|o
suffix:semicolon
)brace
multiline_comment|/*&n; * Locate an existing origin or create a new one.&n; * This moves the origin to front position in the commit util list.&n; */
DECL|function|get_origin
r_static
r_struct
id|origin
op_star
id|get_origin
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_struct
id|commit
op_star
id|commit
comma
r_const
r_char
op_star
id|path
)paren
(brace
r_struct
id|origin
op_star
id|o
comma
op_star
id|l
suffix:semicolon
r_for
c_loop
(paren
id|o
op_assign
id|commit-&gt;util
comma
id|l
op_assign
l_int|NULL
suffix:semicolon
id|o
suffix:semicolon
id|l
op_assign
id|o
comma
id|o
op_assign
id|o-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|o-&gt;path
comma
id|path
)paren
)paren
(brace
multiline_comment|/* bump to front */
r_if
c_cond
(paren
id|l
)paren
(brace
id|l-&gt;next
op_assign
id|o-&gt;next
suffix:semicolon
id|o-&gt;next
op_assign
id|commit-&gt;util
suffix:semicolon
id|commit-&gt;util
op_assign
id|o
suffix:semicolon
)brace
r_return
id|origin_incref
c_func
(paren
id|o
)paren
suffix:semicolon
)brace
)brace
r_return
id|make_origin
c_func
(paren
id|commit
comma
id|path
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Fill the blob_sha1 field of an origin if it hasn&squot;t, so that later&n; * call to fill_origin_blob() can use it to locate the data.  blob_sha1&n; * for an origin is also used to pass the blame for the entire file to&n; * the parent to detect the case where a child&squot;s blob is identical to&n; * that of its parent&squot;s.&n; *&n; * This also fills origin-&gt;mode for corresponding tree path.&n; */
DECL|function|fill_blob_sha1_and_mode
r_static
r_int
id|fill_blob_sha1_and_mode
c_func
(paren
r_struct
id|origin
op_star
id|origin
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|is_null_sha1
c_func
(paren
id|origin-&gt;blob_sha1
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|get_tree_entry
c_func
(paren
id|get_object_hash
c_func
(paren
id|origin-&gt;commit-&gt;object
)paren
comma
id|origin-&gt;path
comma
id|origin-&gt;blob_sha1
comma
op_amp
id|origin-&gt;mode
)paren
)paren
r_goto
id|error_out
suffix:semicolon
r_if
c_cond
(paren
id|sha1_object_info
c_func
(paren
id|origin-&gt;blob_sha1
comma
l_int|NULL
)paren
op_ne
id|OBJ_BLOB
)paren
r_goto
id|error_out
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|error_out
suffix:colon
id|hashclr
c_func
(paren
id|origin-&gt;blob_sha1
)paren
suffix:semicolon
id|origin-&gt;mode
op_assign
id|S_IFINVALID
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * We have an origin -- check if the same path exists in the&n; * parent and return an origin structure to represent it.&n; */
DECL|function|find_origin
r_static
r_struct
id|origin
op_star
id|find_origin
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_struct
id|commit
op_star
id|parent
comma
r_struct
id|origin
op_star
id|origin
)paren
(brace
r_struct
id|origin
op_star
id|porigin
suffix:semicolon
r_struct
id|diff_options
id|diff_opts
suffix:semicolon
r_const
r_char
op_star
id|paths
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* First check any existing origins */
r_for
c_loop
(paren
id|porigin
op_assign
id|parent-&gt;util
suffix:semicolon
id|porigin
suffix:semicolon
id|porigin
op_assign
id|porigin-&gt;next
)paren
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|porigin-&gt;path
comma
id|origin-&gt;path
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * The same path between origin and its parent&n;&t;&t;&t; * without renaming -- the most common case.&n;&t;&t;&t; */
r_return
id|origin_incref
(paren
id|porigin
)paren
suffix:semicolon
)brace
multiline_comment|/* See if the origin-&gt;path is different between parent&n;&t; * and origin first.  Most of the time they are the&n;&t; * same and diff-tree is fairly efficient about this.&n;&t; */
id|diff_setup
c_func
(paren
op_amp
id|diff_opts
)paren
suffix:semicolon
id|DIFF_OPT_SET
c_func
(paren
op_amp
id|diff_opts
comma
id|RECURSIVE
)paren
suffix:semicolon
id|diff_opts.detect_rename
op_assign
l_int|0
suffix:semicolon
id|diff_opts.output_format
op_assign
id|DIFF_FORMAT_NO_OUTPUT
suffix:semicolon
id|paths
(braket
l_int|0
)braket
op_assign
id|origin-&gt;path
suffix:semicolon
id|paths
(braket
l_int|1
)braket
op_assign
l_int|NULL
suffix:semicolon
id|parse_pathspec
c_func
(paren
op_amp
id|diff_opts.pathspec
comma
id|PATHSPEC_ALL_MAGIC
op_amp
op_complement
id|PATHSPEC_LITERAL
comma
id|PATHSPEC_LITERAL_PATH
comma
l_string|&quot;&quot;
comma
id|paths
)paren
suffix:semicolon
id|diff_setup_done
c_func
(paren
op_amp
id|diff_opts
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_null_oid
c_func
(paren
op_amp
id|origin-&gt;commit-&gt;object.oid
)paren
)paren
id|do_diff_cache
c_func
(paren
id|get_object_hash
c_func
(paren
id|parent-&gt;tree-&gt;object
)paren
comma
op_amp
id|diff_opts
)paren
suffix:semicolon
r_else
id|diff_tree_sha1
c_func
(paren
id|get_object_hash
c_func
(paren
id|parent-&gt;tree-&gt;object
)paren
comma
id|get_object_hash
c_func
(paren
id|origin-&gt;commit-&gt;tree-&gt;object
)paren
comma
l_string|&quot;&quot;
comma
op_amp
id|diff_opts
)paren
suffix:semicolon
id|diffcore_std
c_func
(paren
op_amp
id|diff_opts
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|diff_queued_diff.nr
)paren
(brace
multiline_comment|/* The path is the same as parent */
id|porigin
op_assign
id|get_origin
c_func
(paren
id|sb
comma
id|parent
comma
id|origin-&gt;path
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|porigin-&gt;blob_sha1
comma
id|origin-&gt;blob_sha1
)paren
suffix:semicolon
id|porigin-&gt;mode
op_assign
id|origin-&gt;mode
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Since origin-&gt;path is a pathspec, if the parent&n;&t;&t; * commit had it as a directory, we will see a whole&n;&t;&t; * bunch of deletion of files in the directory that we&n;&t;&t; * do not care about.&n;&t;&t; */
r_int
id|i
suffix:semicolon
r_struct
id|diff_filepair
op_star
id|p
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|diff_queued_diff.nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_char
op_star
id|name
suffix:semicolon
id|p
op_assign
id|diff_queued_diff.queue
(braket
id|i
)braket
suffix:semicolon
id|name
op_assign
id|p-&gt;one-&gt;path
ques
c_cond
id|p-&gt;one-&gt;path
suffix:colon
id|p-&gt;two-&gt;path
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
id|origin-&gt;path
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
id|die
c_func
(paren
l_string|&quot;internal error in blame::find_origin&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|p-&gt;status
)paren
(brace
r_default
suffix:colon
id|die
c_func
(paren
l_string|&quot;internal error in blame::find_origin (%c)&quot;
comma
id|p-&gt;status
)paren
suffix:semicolon
r_case
l_char|&squot;M&squot;
suffix:colon
id|porigin
op_assign
id|get_origin
c_func
(paren
id|sb
comma
id|parent
comma
id|origin-&gt;path
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|porigin-&gt;blob_sha1
comma
id|p-&gt;one-&gt;sha1
)paren
suffix:semicolon
id|porigin-&gt;mode
op_assign
id|p-&gt;one-&gt;mode
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;A&squot;
suffix:colon
r_case
l_char|&squot;T&squot;
suffix:colon
multiline_comment|/* Did not exist in parent, or type changed */
r_break
suffix:semicolon
)brace
)brace
id|diff_flush
c_func
(paren
op_amp
id|diff_opts
)paren
suffix:semicolon
id|free_pathspec
c_func
(paren
op_amp
id|diff_opts.pathspec
)paren
suffix:semicolon
r_return
id|porigin
suffix:semicolon
)brace
multiline_comment|/*&n; * We have an origin -- find the path that corresponds to it in its&n; * parent and return an origin structure to represent it.&n; */
DECL|function|find_rename
r_static
r_struct
id|origin
op_star
id|find_rename
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_struct
id|commit
op_star
id|parent
comma
r_struct
id|origin
op_star
id|origin
)paren
(brace
r_struct
id|origin
op_star
id|porigin
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|diff_options
id|diff_opts
suffix:semicolon
r_int
id|i
suffix:semicolon
id|diff_setup
c_func
(paren
op_amp
id|diff_opts
)paren
suffix:semicolon
id|DIFF_OPT_SET
c_func
(paren
op_amp
id|diff_opts
comma
id|RECURSIVE
)paren
suffix:semicolon
id|diff_opts.detect_rename
op_assign
id|DIFF_DETECT_RENAME
suffix:semicolon
id|diff_opts.output_format
op_assign
id|DIFF_FORMAT_NO_OUTPUT
suffix:semicolon
id|diff_opts.single_follow
op_assign
id|origin-&gt;path
suffix:semicolon
id|diff_setup_done
c_func
(paren
op_amp
id|diff_opts
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_null_oid
c_func
(paren
op_amp
id|origin-&gt;commit-&gt;object.oid
)paren
)paren
id|do_diff_cache
c_func
(paren
id|get_object_hash
c_func
(paren
id|parent-&gt;tree-&gt;object
)paren
comma
op_amp
id|diff_opts
)paren
suffix:semicolon
r_else
id|diff_tree_sha1
c_func
(paren
id|get_object_hash
c_func
(paren
id|parent-&gt;tree-&gt;object
)paren
comma
id|get_object_hash
c_func
(paren
id|origin-&gt;commit-&gt;tree-&gt;object
)paren
comma
l_string|&quot;&quot;
comma
op_amp
id|diff_opts
)paren
suffix:semicolon
id|diffcore_std
c_func
(paren
op_amp
id|diff_opts
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|diff_queued_diff.nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|diff_filepair
op_star
id|p
op_assign
id|diff_queued_diff.queue
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;status
op_eq
l_char|&squot;R&squot;
op_logical_or
id|p-&gt;status
op_eq
l_char|&squot;C&squot;
)paren
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|p-&gt;two-&gt;path
comma
id|origin-&gt;path
)paren
)paren
(brace
id|porigin
op_assign
id|get_origin
c_func
(paren
id|sb
comma
id|parent
comma
id|p-&gt;one-&gt;path
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|porigin-&gt;blob_sha1
comma
id|p-&gt;one-&gt;sha1
)paren
suffix:semicolon
id|porigin-&gt;mode
op_assign
id|p-&gt;one-&gt;mode
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|diff_flush
c_func
(paren
op_amp
id|diff_opts
)paren
suffix:semicolon
id|free_pathspec
c_func
(paren
op_amp
id|diff_opts.pathspec
)paren
suffix:semicolon
r_return
id|porigin
suffix:semicolon
)brace
multiline_comment|/*&n; * Append a new blame entry to a given output queue.&n; */
DECL|function|add_blame_entry
r_static
r_void
id|add_blame_entry
c_func
(paren
r_struct
id|blame_entry
op_star
op_star
op_star
id|queue
comma
r_struct
id|blame_entry
op_star
id|e
)paren
(brace
id|origin_incref
c_func
(paren
id|e-&gt;suspect
)paren
suffix:semicolon
id|e-&gt;next
op_assign
op_star
op_star
id|queue
suffix:semicolon
op_star
op_star
id|queue
op_assign
id|e
suffix:semicolon
op_star
id|queue
op_assign
op_amp
id|e-&gt;next
suffix:semicolon
)brace
multiline_comment|/*&n; * src typically is on-stack; we want to copy the information in it to&n; * a malloced blame_entry that gets added to the given queue.  The&n; * origin of dst loses a refcnt.&n; */
DECL|function|dup_entry
r_static
r_void
id|dup_entry
c_func
(paren
r_struct
id|blame_entry
op_star
op_star
op_star
id|queue
comma
r_struct
id|blame_entry
op_star
id|dst
comma
r_struct
id|blame_entry
op_star
id|src
)paren
(brace
id|origin_incref
c_func
(paren
id|src-&gt;suspect
)paren
suffix:semicolon
id|origin_decref
c_func
(paren
id|dst-&gt;suspect
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|dst
comma
id|src
comma
r_sizeof
(paren
op_star
id|src
)paren
)paren
suffix:semicolon
id|dst-&gt;next
op_assign
op_star
op_star
id|queue
suffix:semicolon
op_star
op_star
id|queue
op_assign
id|dst
suffix:semicolon
op_star
id|queue
op_assign
op_amp
id|dst-&gt;next
suffix:semicolon
)brace
DECL|function|nth_line
r_static
r_const
r_char
op_star
id|nth_line
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_int
id|lno
)paren
(brace
r_return
id|sb-&gt;final_buf
op_plus
id|sb-&gt;lineno
(braket
id|lno
)braket
suffix:semicolon
)brace
DECL|function|nth_line_cb
r_static
r_const
r_char
op_star
id|nth_line_cb
c_func
(paren
r_void
op_star
id|data
comma
r_int
id|lno
)paren
(brace
r_return
id|nth_line
c_func
(paren
(paren
r_struct
id|scoreboard
op_star
)paren
id|data
comma
id|lno
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * It is known that lines between tlno to same came from parent, and e&n; * has an overlap with that range.  it also is known that parent&squot;s&n; * line plno corresponds to e&squot;s line tlno.&n; *&n; *                &lt;---- e -----&gt;&n; *                   &lt;------&gt;&n; *                   &lt;------------&gt;&n; *             &lt;------------&gt;&n; *             &lt;------------------&gt;&n; *&n; * Split e into potentially three parts; before this chunk, the chunk&n; * to be blamed for the parent, and after that portion.&n; */
DECL|function|split_overlap
r_static
r_void
id|split_overlap
c_func
(paren
r_struct
id|blame_entry
op_star
id|split
comma
r_struct
id|blame_entry
op_star
id|e
comma
r_int
id|tlno
comma
r_int
id|plno
comma
r_int
id|same
comma
r_struct
id|origin
op_star
id|parent
)paren
(brace
r_int
id|chunk_end_lno
suffix:semicolon
id|memset
c_func
(paren
id|split
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|blame_entry
(braket
l_int|3
)braket
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e-&gt;s_lno
OL
id|tlno
)paren
(brace
multiline_comment|/* there is a pre-chunk part not blamed on parent */
id|split
(braket
l_int|0
)braket
dot
id|suspect
op_assign
id|origin_incref
c_func
(paren
id|e-&gt;suspect
)paren
suffix:semicolon
id|split
(braket
l_int|0
)braket
dot
id|lno
op_assign
id|e-&gt;lno
suffix:semicolon
id|split
(braket
l_int|0
)braket
dot
id|s_lno
op_assign
id|e-&gt;s_lno
suffix:semicolon
id|split
(braket
l_int|0
)braket
dot
id|num_lines
op_assign
id|tlno
id|e-&gt;s_lno
suffix:semicolon
id|split
(braket
l_int|1
)braket
dot
id|lno
op_assign
id|e-&gt;lno
op_plus
id|tlno
id|e-&gt;s_lno
suffix:semicolon
id|split
(braket
l_int|1
)braket
dot
id|s_lno
op_assign
id|plno
suffix:semicolon
)brace
r_else
(brace
id|split
(braket
l_int|1
)braket
dot
id|lno
op_assign
id|e-&gt;lno
suffix:semicolon
id|split
(braket
l_int|1
)braket
dot
id|s_lno
op_assign
id|plno
op_plus
(paren
id|e-&gt;s_lno
id|tlno
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|same
OL
id|e-&gt;s_lno
op_plus
id|e-&gt;num_lines
)paren
(brace
multiline_comment|/* there is a post-chunk part not blamed on parent */
id|split
(braket
l_int|2
)braket
dot
id|suspect
op_assign
id|origin_incref
c_func
(paren
id|e-&gt;suspect
)paren
suffix:semicolon
id|split
(braket
l_int|2
)braket
dot
id|lno
op_assign
id|e-&gt;lno
op_plus
(paren
id|same
id|e-&gt;s_lno
)paren
suffix:semicolon
id|split
(braket
l_int|2
)braket
dot
id|s_lno
op_assign
id|e-&gt;s_lno
op_plus
(paren
id|same
id|e-&gt;s_lno
)paren
suffix:semicolon
id|split
(braket
l_int|2
)braket
dot
id|num_lines
op_assign
id|e-&gt;s_lno
op_plus
id|e-&gt;num_lines
id|same
suffix:semicolon
id|chunk_end_lno
op_assign
id|split
(braket
l_int|2
)braket
dot
id|lno
suffix:semicolon
)brace
r_else
id|chunk_end_lno
op_assign
id|e-&gt;lno
op_plus
id|e-&gt;num_lines
suffix:semicolon
id|split
(braket
l_int|1
)braket
dot
id|num_lines
op_assign
id|chunk_end_lno
id|split
(braket
l_int|1
)braket
dot
id|lno
suffix:semicolon
multiline_comment|/*&n;&t; * if it turns out there is nothing to blame the parent for,&n;&t; * forget about the splitting.  !split[1].suspect signals this.&n;&t; */
r_if
c_cond
(paren
id|split
(braket
l_int|1
)braket
dot
id|num_lines
OL
l_int|1
)paren
r_return
suffix:semicolon
id|split
(braket
l_int|1
)braket
dot
id|suspect
op_assign
id|origin_incref
c_func
(paren
id|parent
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * split_overlap() divided an existing blame e into up to three parts&n; * in split.  Any assigned blame is moved to queue to&n; * reflect the split.&n; */
DECL|function|split_blame
r_static
r_void
id|split_blame
c_func
(paren
r_struct
id|blame_entry
op_star
op_star
op_star
id|blamed
comma
r_struct
id|blame_entry
op_star
op_star
op_star
id|unblamed
comma
r_struct
id|blame_entry
op_star
id|split
comma
r_struct
id|blame_entry
op_star
id|e
)paren
(brace
r_struct
id|blame_entry
op_star
id|new_entry
suffix:semicolon
r_if
c_cond
(paren
id|split
(braket
l_int|0
)braket
dot
id|suspect
op_logical_and
id|split
(braket
l_int|2
)braket
dot
id|suspect
)paren
(brace
multiline_comment|/* The first part (reuse storage for the existing entry e) */
id|dup_entry
c_func
(paren
id|unblamed
comma
id|e
comma
op_amp
id|split
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/* The last part -- me */
id|new_entry
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|new_entry
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|new_entry
comma
op_amp
(paren
id|split
(braket
l_int|2
)braket
)paren
comma
r_sizeof
(paren
r_struct
id|blame_entry
)paren
)paren
suffix:semicolon
id|add_blame_entry
c_func
(paren
id|unblamed
comma
id|new_entry
)paren
suffix:semicolon
multiline_comment|/* ... and the middle part -- parent */
id|new_entry
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|new_entry
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|new_entry
comma
op_amp
(paren
id|split
(braket
l_int|1
)braket
)paren
comma
r_sizeof
(paren
r_struct
id|blame_entry
)paren
)paren
suffix:semicolon
id|add_blame_entry
c_func
(paren
id|blamed
comma
id|new_entry
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|split
(braket
l_int|0
)braket
dot
id|suspect
op_logical_and
op_logical_neg
id|split
(braket
l_int|2
)braket
dot
id|suspect
)paren
multiline_comment|/*&n;&t;&t; * The parent covers the entire area; reuse storage for&n;&t;&t; * e and replace it with the parent.&n;&t;&t; */
id|dup_entry
c_func
(paren
id|blamed
comma
id|e
comma
op_amp
id|split
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|split
(braket
l_int|0
)braket
dot
id|suspect
)paren
(brace
multiline_comment|/* me and then parent */
id|dup_entry
c_func
(paren
id|unblamed
comma
id|e
comma
op_amp
id|split
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|new_entry
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|new_entry
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|new_entry
comma
op_amp
(paren
id|split
(braket
l_int|1
)braket
)paren
comma
r_sizeof
(paren
r_struct
id|blame_entry
)paren
)paren
suffix:semicolon
id|add_blame_entry
c_func
(paren
id|blamed
comma
id|new_entry
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* parent and then me */
id|dup_entry
c_func
(paren
id|blamed
comma
id|e
comma
op_amp
id|split
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|new_entry
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|new_entry
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|new_entry
comma
op_amp
(paren
id|split
(braket
l_int|2
)braket
)paren
comma
r_sizeof
(paren
r_struct
id|blame_entry
)paren
)paren
suffix:semicolon
id|add_blame_entry
c_func
(paren
id|unblamed
comma
id|new_entry
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * After splitting the blame, the origins used by the&n; * on-stack blame_entry should lose one refcnt each.&n; */
DECL|function|decref_split
r_static
r_void
id|decref_split
c_func
(paren
r_struct
id|blame_entry
op_star
id|split
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
id|origin_decref
c_func
(paren
id|split
(braket
id|i
)braket
dot
id|suspect
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * reverse_blame reverses the list given in head, appending tail.&n; * That allows us to build lists in reverse order, then reverse them&n; * afterwards.  This can be faster than building the list in proper&n; * order right away.  The reason is that building in proper order&n; * requires writing a link in the _previous_ element, while building&n; * in reverse order just requires placing the list head into the&n; * _current_ element.&n; */
DECL|function|reverse_blame
r_static
r_struct
id|blame_entry
op_star
id|reverse_blame
c_func
(paren
r_struct
id|blame_entry
op_star
id|head
comma
r_struct
id|blame_entry
op_star
id|tail
)paren
(brace
r_while
c_loop
(paren
id|head
)paren
(brace
r_struct
id|blame_entry
op_star
id|next
op_assign
id|head-&gt;next
suffix:semicolon
id|head-&gt;next
op_assign
id|tail
suffix:semicolon
id|tail
op_assign
id|head
suffix:semicolon
id|head
op_assign
id|next
suffix:semicolon
)brace
r_return
id|tail
suffix:semicolon
)brace
multiline_comment|/*&n; * Process one hunk from the patch between the current suspect for&n; * blame_entry e and its parent.  This first blames any unfinished&n; * entries before the chunk (which is where target and parent start&n; * differing) on the parent, and then splits blame entries at the&n; * start and at the end of the difference region.  Since use of -M and&n; * -C options may lead to overlapping/duplicate source line number&n; * ranges, all we can rely on from sorting/merging is the order of the&n; * first suspect line number.&n; */
DECL|function|blame_chunk
r_static
r_void
id|blame_chunk
c_func
(paren
r_struct
id|blame_entry
op_star
op_star
op_star
id|dstq
comma
r_struct
id|blame_entry
op_star
op_star
op_star
id|srcq
comma
r_int
id|tlno
comma
r_int
id|offset
comma
r_int
id|same
comma
r_struct
id|origin
op_star
id|parent
)paren
(brace
r_struct
id|blame_entry
op_star
id|e
op_assign
op_star
op_star
id|srcq
suffix:semicolon
r_struct
id|blame_entry
op_star
id|samep
op_assign
l_int|NULL
comma
op_star
id|diffp
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|e
op_logical_and
id|e-&gt;s_lno
OL
id|tlno
)paren
(brace
r_struct
id|blame_entry
op_star
id|next
op_assign
id|e-&gt;next
suffix:semicolon
multiline_comment|/*&n;&t;&t; * current record starts before differing portion.  If&n;&t;&t; * it reaches into it, we need to split it up and&n;&t;&t; * examine the second part separately.&n;&t;&t; */
r_if
c_cond
(paren
id|e-&gt;s_lno
op_plus
id|e-&gt;num_lines
OG
id|tlno
)paren
(brace
multiline_comment|/* Move second half to a new record */
r_int
id|len
op_assign
id|tlno
id|e-&gt;s_lno
suffix:semicolon
r_struct
id|blame_entry
op_star
id|n
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|blame_entry
)paren
)paren
suffix:semicolon
id|n-&gt;suspect
op_assign
id|e-&gt;suspect
suffix:semicolon
id|n-&gt;lno
op_assign
id|e-&gt;lno
op_plus
id|len
suffix:semicolon
id|n-&gt;s_lno
op_assign
id|e-&gt;s_lno
op_plus
id|len
suffix:semicolon
id|n-&gt;num_lines
op_assign
id|e-&gt;num_lines
id|len
suffix:semicolon
id|e-&gt;num_lines
op_assign
id|len
suffix:semicolon
id|e-&gt;score
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Push new record to diffp */
id|n-&gt;next
op_assign
id|diffp
suffix:semicolon
id|diffp
op_assign
id|n
suffix:semicolon
)brace
r_else
id|origin_decref
c_func
(paren
id|e-&gt;suspect
)paren
suffix:semicolon
multiline_comment|/* Pass blame for everything before the differing&n;&t;&t; * chunk to the parent */
id|e-&gt;suspect
op_assign
id|origin_incref
c_func
(paren
id|parent
)paren
suffix:semicolon
id|e-&gt;s_lno
op_add_assign
id|offset
suffix:semicolon
id|e-&gt;next
op_assign
id|samep
suffix:semicolon
id|samep
op_assign
id|e
suffix:semicolon
id|e
op_assign
id|next
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * As we don&squot;t know how much of a common stretch after this&n;&t; * diff will occur, the currently blamed parts are all that we&n;&t; * can assign to the parent for now.&n;&t; */
r_if
c_cond
(paren
id|samep
)paren
(brace
op_star
op_star
id|dstq
op_assign
id|reverse_blame
c_func
(paren
id|samep
comma
op_star
op_star
id|dstq
)paren
suffix:semicolon
op_star
id|dstq
op_assign
op_amp
id|samep-&gt;next
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Prepend the split off portions: everything after e starts&n;&t; * after the blameable portion.&n;&t; */
id|e
op_assign
id|reverse_blame
c_func
(paren
id|diffp
comma
id|e
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Now retain records on the target while parts are different&n;&t; * from the parent.&n;&t; */
id|samep
op_assign
l_int|NULL
suffix:semicolon
id|diffp
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|e
op_logical_and
id|e-&gt;s_lno
OL
id|same
)paren
(brace
r_struct
id|blame_entry
op_star
id|next
op_assign
id|e-&gt;next
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If current record extends into sameness, need to split.&n;&t;&t; */
r_if
c_cond
(paren
id|e-&gt;s_lno
op_plus
id|e-&gt;num_lines
OG
id|same
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Move second half to a new record to be&n;&t;&t;&t; * processed by later chunks&n;&t;&t;&t; */
r_int
id|len
op_assign
id|same
id|e-&gt;s_lno
suffix:semicolon
r_struct
id|blame_entry
op_star
id|n
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|blame_entry
)paren
)paren
suffix:semicolon
id|n-&gt;suspect
op_assign
id|origin_incref
c_func
(paren
id|e-&gt;suspect
)paren
suffix:semicolon
id|n-&gt;lno
op_assign
id|e-&gt;lno
op_plus
id|len
suffix:semicolon
id|n-&gt;s_lno
op_assign
id|e-&gt;s_lno
op_plus
id|len
suffix:semicolon
id|n-&gt;num_lines
op_assign
id|e-&gt;num_lines
id|len
suffix:semicolon
id|e-&gt;num_lines
op_assign
id|len
suffix:semicolon
id|e-&gt;score
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Push new record to samep */
id|n-&gt;next
op_assign
id|samep
suffix:semicolon
id|samep
op_assign
id|n
suffix:semicolon
)brace
id|e-&gt;next
op_assign
id|diffp
suffix:semicolon
id|diffp
op_assign
id|e
suffix:semicolon
id|e
op_assign
id|next
suffix:semicolon
)brace
op_star
op_star
id|srcq
op_assign
id|reverse_blame
c_func
(paren
id|diffp
comma
id|reverse_blame
c_func
(paren
id|samep
comma
id|e
)paren
)paren
suffix:semicolon
multiline_comment|/* Move across elements that are in the unblamable portion */
r_if
c_cond
(paren
id|diffp
)paren
op_star
id|srcq
op_assign
op_amp
id|diffp-&gt;next
suffix:semicolon
)brace
DECL|struct|blame_chunk_cb_data
r_struct
id|blame_chunk_cb_data
(brace
DECL|member|parent
r_struct
id|origin
op_star
id|parent
suffix:semicolon
DECL|member|offset
r_int
id|offset
suffix:semicolon
DECL|member|dstq
r_struct
id|blame_entry
op_star
op_star
id|dstq
suffix:semicolon
DECL|member|srcq
r_struct
id|blame_entry
op_star
op_star
id|srcq
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* diff chunks are from parent to target */
DECL|function|blame_chunk_cb
r_static
r_int
id|blame_chunk_cb
c_func
(paren
r_int
id|start_a
comma
r_int
id|count_a
comma
r_int
id|start_b
comma
r_int
id|count_b
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|blame_chunk_cb_data
op_star
id|d
op_assign
id|data
suffix:semicolon
r_if
c_cond
(paren
id|start_a
id|start_b
op_ne
id|d-&gt;offset
)paren
id|die
c_func
(paren
l_string|&quot;internal error in blame::blame_chunk_cb&quot;
)paren
suffix:semicolon
id|blame_chunk
c_func
(paren
op_amp
id|d-&gt;dstq
comma
op_amp
id|d-&gt;srcq
comma
id|start_b
comma
id|start_a
id|start_b
comma
id|start_b
op_plus
id|count_b
comma
id|d-&gt;parent
)paren
suffix:semicolon
id|d-&gt;offset
op_assign
id|start_a
op_plus
id|count_a
(paren
id|start_b
op_plus
id|count_b
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * We are looking at the origin &squot;target&squot; and aiming to pass blame&n; * for the lines it is suspected to its parent.  Run diff to find&n; * which lines came from parent and pass blame for them.&n; */
DECL|function|pass_blame_to_parent
r_static
r_void
id|pass_blame_to_parent
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_struct
id|origin
op_star
id|target
comma
r_struct
id|origin
op_star
id|parent
)paren
(brace
id|mmfile_t
id|file_p
comma
id|file_o
suffix:semicolon
r_struct
id|blame_chunk_cb_data
id|d
suffix:semicolon
r_struct
id|blame_entry
op_star
id|newdest
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|target-&gt;suspects
)paren
r_return
suffix:semicolon
multiline_comment|/* nothing remains for this target */
id|d.parent
op_assign
id|parent
suffix:semicolon
id|d.offset
op_assign
l_int|0
suffix:semicolon
id|d.dstq
op_assign
op_amp
id|newdest
suffix:semicolon
id|d.srcq
op_assign
op_amp
id|target-&gt;suspects
suffix:semicolon
id|fill_origin_blob
c_func
(paren
op_amp
id|sb-&gt;revs-&gt;diffopt
comma
id|parent
comma
op_amp
id|file_p
)paren
suffix:semicolon
id|fill_origin_blob
c_func
(paren
op_amp
id|sb-&gt;revs-&gt;diffopt
comma
id|target
comma
op_amp
id|file_o
)paren
suffix:semicolon
id|num_get_patch
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|diff_hunks
c_func
(paren
op_amp
id|file_p
comma
op_amp
id|file_o
comma
l_int|0
comma
id|blame_chunk_cb
comma
op_amp
id|d
)paren
)paren
id|die
c_func
(paren
l_string|&quot;unable to generate diff (%s -&gt; %s)&quot;
comma
id|oid_to_hex
c_func
(paren
op_amp
id|parent-&gt;commit-&gt;object.oid
)paren
comma
id|oid_to_hex
c_func
(paren
op_amp
id|target-&gt;commit-&gt;object.oid
)paren
)paren
suffix:semicolon
multiline_comment|/* The rest are the same as the parent */
id|blame_chunk
c_func
(paren
op_amp
id|d.dstq
comma
op_amp
id|d.srcq
comma
id|INT_MAX
comma
id|d.offset
comma
id|INT_MAX
comma
id|parent
)paren
suffix:semicolon
op_star
id|d.dstq
op_assign
l_int|NULL
suffix:semicolon
id|queue_blames
c_func
(paren
id|sb
comma
id|parent
comma
id|newdest
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * The lines in blame_entry after splitting blames many times can become&n; * very small and trivial, and at some point it becomes pointless to&n; * blame the parents.  E.g. &quot;&bslash;t&bslash;t}&bslash;n&bslash;t}&bslash;n&bslash;n&quot; appears everywhere in any&n; * ordinary C program, and it is not worth to say it was copied from&n; * totally unrelated file in the parent.&n; *&n; * Compute how trivial the lines in the blame_entry are.&n; */
DECL|function|ent_score
r_static
r_int
id|ent_score
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_struct
id|blame_entry
op_star
id|e
)paren
(brace
r_int
id|score
suffix:semicolon
r_const
r_char
op_star
id|cp
comma
op_star
id|ep
suffix:semicolon
r_if
c_cond
(paren
id|e-&gt;score
)paren
r_return
id|e-&gt;score
suffix:semicolon
id|score
op_assign
l_int|1
suffix:semicolon
id|cp
op_assign
id|nth_line
c_func
(paren
id|sb
comma
id|e-&gt;lno
)paren
suffix:semicolon
id|ep
op_assign
id|nth_line
c_func
(paren
id|sb
comma
id|e-&gt;lno
op_plus
id|e-&gt;num_lines
)paren
suffix:semicolon
r_while
c_loop
(paren
id|cp
OL
id|ep
)paren
(brace
r_int
id|ch
op_assign
op_star
(paren
(paren
r_int
r_char
op_star
)paren
id|cp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|isalnum
c_func
(paren
id|ch
)paren
)paren
id|score
op_increment
suffix:semicolon
id|cp
op_increment
suffix:semicolon
)brace
id|e-&gt;score
op_assign
id|score
suffix:semicolon
r_return
id|score
suffix:semicolon
)brace
multiline_comment|/*&n; * best_so_far[] and this[] are both a split of an existing blame_entry&n; * that passes blame to the parent.  Maintain best_so_far the best split&n; * so far, by comparing this and best_so_far and copying this into&n; * bst_so_far as needed.&n; */
DECL|function|copy_split_if_better
r_static
r_void
id|copy_split_if_better
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_struct
id|blame_entry
op_star
id|best_so_far
comma
r_struct
id|blame_entry
op_star
id|this
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|this
(braket
l_int|1
)braket
dot
id|suspect
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|best_so_far
(braket
l_int|1
)braket
dot
id|suspect
)paren
(brace
r_if
c_cond
(paren
id|ent_score
c_func
(paren
id|sb
comma
op_amp
id|this
(braket
l_int|1
)braket
)paren
OL
id|ent_score
c_func
(paren
id|sb
comma
op_amp
id|best_so_far
(braket
l_int|1
)braket
)paren
)paren
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
id|origin_incref
c_func
(paren
id|this
(braket
id|i
)braket
dot
id|suspect
)paren
suffix:semicolon
id|decref_split
c_func
(paren
id|best_so_far
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|best_so_far
comma
id|this
comma
r_sizeof
(paren
r_struct
id|blame_entry
(braket
l_int|3
)braket
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * We are looking at a part of the final image represented by&n; * ent (tlno and same are offset by ent-&gt;s_lno).&n; * tlno is where we are looking at in the final image.&n; * up to (but not including) same match preimage.&n; * plno is where we are looking at in the preimage.&n; *&n; * &lt;-------------- final image ----------------------&gt;&n; *       &lt;------ent------&gt;&n; *         ^tlno ^same&n; *    &lt;---------preimage-----&gt;&n; *         ^plno&n; *&n; * All line numbers are 0-based.&n; */
DECL|function|handle_split
r_static
r_void
id|handle_split
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_struct
id|blame_entry
op_star
id|ent
comma
r_int
id|tlno
comma
r_int
id|plno
comma
r_int
id|same
comma
r_struct
id|origin
op_star
id|parent
comma
r_struct
id|blame_entry
op_star
id|split
)paren
(brace
r_if
c_cond
(paren
id|ent-&gt;num_lines
op_le
id|tlno
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|tlno
OL
id|same
)paren
(brace
r_struct
id|blame_entry
id|this
(braket
l_int|3
)braket
suffix:semicolon
id|tlno
op_add_assign
id|ent-&gt;s_lno
suffix:semicolon
id|same
op_add_assign
id|ent-&gt;s_lno
suffix:semicolon
id|split_overlap
c_func
(paren
id|this
comma
id|ent
comma
id|tlno
comma
id|plno
comma
id|same
comma
id|parent
)paren
suffix:semicolon
id|copy_split_if_better
c_func
(paren
id|sb
comma
id|split
comma
id|this
)paren
suffix:semicolon
id|decref_split
c_func
(paren
id|this
)paren
suffix:semicolon
)brace
)brace
DECL|struct|handle_split_cb_data
r_struct
id|handle_split_cb_data
(brace
DECL|member|sb
r_struct
id|scoreboard
op_star
id|sb
suffix:semicolon
DECL|member|ent
r_struct
id|blame_entry
op_star
id|ent
suffix:semicolon
DECL|member|parent
r_struct
id|origin
op_star
id|parent
suffix:semicolon
DECL|member|split
r_struct
id|blame_entry
op_star
id|split
suffix:semicolon
DECL|member|plno
r_int
id|plno
suffix:semicolon
DECL|member|tlno
r_int
id|tlno
suffix:semicolon
)brace
suffix:semicolon
DECL|function|handle_split_cb
r_static
r_int
id|handle_split_cb
c_func
(paren
r_int
id|start_a
comma
r_int
id|count_a
comma
r_int
id|start_b
comma
r_int
id|count_b
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|handle_split_cb_data
op_star
id|d
op_assign
id|data
suffix:semicolon
id|handle_split
c_func
(paren
id|d-&gt;sb
comma
id|d-&gt;ent
comma
id|d-&gt;tlno
comma
id|d-&gt;plno
comma
id|start_b
comma
id|d-&gt;parent
comma
id|d-&gt;split
)paren
suffix:semicolon
id|d-&gt;plno
op_assign
id|start_a
op_plus
id|count_a
suffix:semicolon
id|d-&gt;tlno
op_assign
id|start_b
op_plus
id|count_b
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Find the lines from parent that are the same as ent so that&n; * we can pass blames to it.  file_p has the blob contents for&n; * the parent.&n; */
DECL|function|find_copy_in_blob
r_static
r_void
id|find_copy_in_blob
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_struct
id|blame_entry
op_star
id|ent
comma
r_struct
id|origin
op_star
id|parent
comma
r_struct
id|blame_entry
op_star
id|split
comma
id|mmfile_t
op_star
id|file_p
)paren
(brace
r_const
r_char
op_star
id|cp
suffix:semicolon
id|mmfile_t
id|file_o
suffix:semicolon
r_struct
id|handle_split_cb_data
id|d
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|d
comma
l_int|0
comma
r_sizeof
(paren
id|d
)paren
)paren
suffix:semicolon
id|d.sb
op_assign
id|sb
suffix:semicolon
id|d.ent
op_assign
id|ent
suffix:semicolon
id|d.parent
op_assign
id|parent
suffix:semicolon
id|d.split
op_assign
id|split
suffix:semicolon
multiline_comment|/*&n;&t; * Prepare mmfile that contains only the lines in ent.&n;&t; */
id|cp
op_assign
id|nth_line
c_func
(paren
id|sb
comma
id|ent-&gt;lno
)paren
suffix:semicolon
id|file_o.ptr
op_assign
(paren
r_char
op_star
)paren
id|cp
suffix:semicolon
id|file_o.size
op_assign
id|nth_line
c_func
(paren
id|sb
comma
id|ent-&gt;lno
op_plus
id|ent-&gt;num_lines
)paren
id|cp
suffix:semicolon
multiline_comment|/*&n;&t; * file_o is a part of final image we are annotating.&n;&t; * file_p partially may match that image.&n;&t; */
id|memset
c_func
(paren
id|split
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|blame_entry
(braket
l_int|3
)braket
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|diff_hunks
c_func
(paren
id|file_p
comma
op_amp
id|file_o
comma
l_int|1
comma
id|handle_split_cb
comma
op_amp
id|d
)paren
)paren
id|die
c_func
(paren
l_string|&quot;unable to generate diff (%s)&quot;
comma
id|oid_to_hex
c_func
(paren
op_amp
id|parent-&gt;commit-&gt;object.oid
)paren
)paren
suffix:semicolon
multiline_comment|/* remainder, if any, all match the preimage */
id|handle_split
c_func
(paren
id|sb
comma
id|ent
comma
id|d.tlno
comma
id|d.plno
comma
id|ent-&gt;num_lines
comma
id|parent
comma
id|split
)paren
suffix:semicolon
)brace
multiline_comment|/* Move all blame entries from list *source that have a score smaller&n; * than score_min to the front of list *small.&n; * Returns a pointer to the link pointing to the old head of the small list.&n; */
DECL|function|filter_small
r_static
r_struct
id|blame_entry
op_star
op_star
id|filter_small
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_struct
id|blame_entry
op_star
op_star
id|small
comma
r_struct
id|blame_entry
op_star
op_star
id|source
comma
r_int
id|score_min
)paren
(brace
r_struct
id|blame_entry
op_star
id|p
op_assign
op_star
id|source
suffix:semicolon
r_struct
id|blame_entry
op_star
id|oldsmall
op_assign
op_star
id|small
suffix:semicolon
r_while
c_loop
(paren
id|p
)paren
(brace
r_if
c_cond
(paren
id|ent_score
c_func
(paren
id|sb
comma
id|p
)paren
op_le
id|score_min
)paren
(brace
op_star
id|small
op_assign
id|p
suffix:semicolon
id|small
op_assign
op_amp
id|p-&gt;next
suffix:semicolon
id|p
op_assign
op_star
id|small
suffix:semicolon
)brace
r_else
(brace
op_star
id|source
op_assign
id|p
suffix:semicolon
id|source
op_assign
op_amp
id|p-&gt;next
suffix:semicolon
id|p
op_assign
op_star
id|source
suffix:semicolon
)brace
)brace
op_star
id|small
op_assign
id|oldsmall
suffix:semicolon
op_star
id|source
op_assign
l_int|NULL
suffix:semicolon
r_return
id|small
suffix:semicolon
)brace
multiline_comment|/*&n; * See if lines currently target is suspected for can be attributed to&n; * parent.&n; */
DECL|function|find_move_in_parent
r_static
r_void
id|find_move_in_parent
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_struct
id|blame_entry
op_star
op_star
op_star
id|blamed
comma
r_struct
id|blame_entry
op_star
op_star
id|toosmall
comma
r_struct
id|origin
op_star
id|target
comma
r_struct
id|origin
op_star
id|parent
)paren
(brace
r_struct
id|blame_entry
op_star
id|e
comma
id|split
(braket
l_int|3
)braket
suffix:semicolon
r_struct
id|blame_entry
op_star
id|unblamed
op_assign
id|target-&gt;suspects
suffix:semicolon
r_struct
id|blame_entry
op_star
id|leftover
op_assign
l_int|NULL
suffix:semicolon
id|mmfile_t
id|file_p
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|unblamed
)paren
r_return
suffix:semicolon
multiline_comment|/* nothing remains for this target */
id|fill_origin_blob
c_func
(paren
op_amp
id|sb-&gt;revs-&gt;diffopt
comma
id|parent
comma
op_amp
id|file_p
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file_p.ptr
)paren
r_return
suffix:semicolon
multiline_comment|/* At each iteration, unblamed has a NULL-terminated list of&n;&t; * entries that have not yet been tested for blame.  leftover&n;&t; * contains the reversed list of entries that have been tested&n;&t; * without being assignable to the parent.&n;&t; */
r_do
(brace
r_struct
id|blame_entry
op_star
op_star
id|unblamedtail
op_assign
op_amp
id|unblamed
suffix:semicolon
r_struct
id|blame_entry
op_star
id|next
suffix:semicolon
r_for
c_loop
(paren
id|e
op_assign
id|unblamed
suffix:semicolon
id|e
suffix:semicolon
id|e
op_assign
id|next
)paren
(brace
id|next
op_assign
id|e-&gt;next
suffix:semicolon
id|find_copy_in_blob
c_func
(paren
id|sb
comma
id|e
comma
id|parent
comma
id|split
comma
op_amp
id|file_p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|split
(braket
l_int|1
)braket
dot
id|suspect
op_logical_and
id|blame_move_score
OL
id|ent_score
c_func
(paren
id|sb
comma
op_amp
id|split
(braket
l_int|1
)braket
)paren
)paren
(brace
id|split_blame
c_func
(paren
id|blamed
comma
op_amp
id|unblamedtail
comma
id|split
comma
id|e
)paren
suffix:semicolon
)brace
r_else
(brace
id|e-&gt;next
op_assign
id|leftover
suffix:semicolon
id|leftover
op_assign
id|e
suffix:semicolon
)brace
id|decref_split
c_func
(paren
id|split
)paren
suffix:semicolon
)brace
op_star
id|unblamedtail
op_assign
l_int|NULL
suffix:semicolon
id|toosmall
op_assign
id|filter_small
c_func
(paren
id|sb
comma
id|toosmall
comma
op_amp
id|unblamed
comma
id|blame_move_score
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|unblamed
)paren
suffix:semicolon
id|target-&gt;suspects
op_assign
id|reverse_blame
c_func
(paren
id|leftover
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|struct|blame_list
r_struct
id|blame_list
(brace
DECL|member|ent
r_struct
id|blame_entry
op_star
id|ent
suffix:semicolon
DECL|member|split
r_struct
id|blame_entry
id|split
(braket
l_int|3
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Count the number of entries the target is suspected for,&n; * and prepare a list of entry and the best split.&n; */
DECL|function|setup_blame_list
r_static
r_struct
id|blame_list
op_star
id|setup_blame_list
c_func
(paren
r_struct
id|blame_entry
op_star
id|unblamed
comma
r_int
op_star
id|num_ents_p
)paren
(brace
r_struct
id|blame_entry
op_star
id|e
suffix:semicolon
r_int
id|num_ents
comma
id|i
suffix:semicolon
r_struct
id|blame_list
op_star
id|blame_list
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|e
op_assign
id|unblamed
comma
id|num_ents
op_assign
l_int|0
suffix:semicolon
id|e
suffix:semicolon
id|e
op_assign
id|e-&gt;next
)paren
id|num_ents
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|num_ents
)paren
(brace
id|blame_list
op_assign
id|xcalloc
c_func
(paren
id|num_ents
comma
r_sizeof
(paren
r_struct
id|blame_list
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|e
op_assign
id|unblamed
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|e
suffix:semicolon
id|e
op_assign
id|e-&gt;next
)paren
id|blame_list
(braket
id|i
op_increment
)braket
dot
id|ent
op_assign
id|e
suffix:semicolon
)brace
op_star
id|num_ents_p
op_assign
id|num_ents
suffix:semicolon
r_return
id|blame_list
suffix:semicolon
)brace
multiline_comment|/*&n; * For lines target is suspected for, see if we can find code movement&n; * across file boundary from the parent commit.  porigin is the path&n; * in the parent we already tried.&n; */
DECL|function|find_copy_in_parent
r_static
r_void
id|find_copy_in_parent
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_struct
id|blame_entry
op_star
op_star
op_star
id|blamed
comma
r_struct
id|blame_entry
op_star
op_star
id|toosmall
comma
r_struct
id|origin
op_star
id|target
comma
r_struct
id|commit
op_star
id|parent
comma
r_struct
id|origin
op_star
id|porigin
comma
r_int
id|opt
)paren
(brace
r_struct
id|diff_options
id|diff_opts
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_struct
id|blame_list
op_star
id|blame_list
suffix:semicolon
r_int
id|num_ents
suffix:semicolon
r_struct
id|blame_entry
op_star
id|unblamed
op_assign
id|target-&gt;suspects
suffix:semicolon
r_struct
id|blame_entry
op_star
id|leftover
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|unblamed
)paren
r_return
suffix:semicolon
multiline_comment|/* nothing remains for this target */
id|diff_setup
c_func
(paren
op_amp
id|diff_opts
)paren
suffix:semicolon
id|DIFF_OPT_SET
c_func
(paren
op_amp
id|diff_opts
comma
id|RECURSIVE
)paren
suffix:semicolon
id|diff_opts.output_format
op_assign
id|DIFF_FORMAT_NO_OUTPUT
suffix:semicolon
id|diff_setup_done
c_func
(paren
op_amp
id|diff_opts
)paren
suffix:semicolon
multiline_comment|/* Try &quot;find copies harder&quot; on new path if requested;&n;&t; * we do not want to use diffcore_rename() actually to&n;&t; * match things up; find_copies_harder is set only to&n;&t; * force diff_tree_sha1() to feed all filepairs to diff_queue,&n;&t; * and this code needs to be after diff_setup_done(), which&n;&t; * usually makes find-copies-harder imply copy detection.&n;&t; */
r_if
c_cond
(paren
(paren
id|opt
op_amp
id|PICKAXE_BLAME_COPY_HARDEST
)paren
op_logical_or
(paren
(paren
id|opt
op_amp
id|PICKAXE_BLAME_COPY_HARDER
)paren
op_logical_and
(paren
op_logical_neg
id|porigin
op_logical_or
id|strcmp
c_func
(paren
id|target-&gt;path
comma
id|porigin-&gt;path
)paren
)paren
)paren
)paren
id|DIFF_OPT_SET
c_func
(paren
op_amp
id|diff_opts
comma
id|FIND_COPIES_HARDER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_null_oid
c_func
(paren
op_amp
id|target-&gt;commit-&gt;object.oid
)paren
)paren
id|do_diff_cache
c_func
(paren
id|get_object_hash
c_func
(paren
id|parent-&gt;tree-&gt;object
)paren
comma
op_amp
id|diff_opts
)paren
suffix:semicolon
r_else
id|diff_tree_sha1
c_func
(paren
id|get_object_hash
c_func
(paren
id|parent-&gt;tree-&gt;object
)paren
comma
id|get_object_hash
c_func
(paren
id|target-&gt;commit-&gt;tree-&gt;object
)paren
comma
l_string|&quot;&quot;
comma
op_amp
id|diff_opts
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|DIFF_OPT_TST
c_func
(paren
op_amp
id|diff_opts
comma
id|FIND_COPIES_HARDER
)paren
)paren
id|diffcore_std
c_func
(paren
op_amp
id|diff_opts
)paren
suffix:semicolon
r_do
(brace
r_struct
id|blame_entry
op_star
op_star
id|unblamedtail
op_assign
op_amp
id|unblamed
suffix:semicolon
id|blame_list
op_assign
id|setup_blame_list
c_func
(paren
id|unblamed
comma
op_amp
id|num_ents
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|diff_queued_diff.nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|diff_filepair
op_star
id|p
op_assign
id|diff_queued_diff.queue
(braket
id|i
)braket
suffix:semicolon
r_struct
id|origin
op_star
id|norigin
suffix:semicolon
id|mmfile_t
id|file_p
suffix:semicolon
r_struct
id|blame_entry
id|this
(braket
l_int|3
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|DIFF_FILE_VALID
c_func
(paren
id|p-&gt;one
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* does not exist in parent */
r_if
c_cond
(paren
id|S_ISGITLINK
c_func
(paren
id|p-&gt;one-&gt;mode
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* ignore git links */
r_if
c_cond
(paren
id|porigin
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|p-&gt;one-&gt;path
comma
id|porigin-&gt;path
)paren
)paren
multiline_comment|/* find_move already dealt with this path */
r_continue
suffix:semicolon
id|norigin
op_assign
id|get_origin
c_func
(paren
id|sb
comma
id|parent
comma
id|p-&gt;one-&gt;path
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|norigin-&gt;blob_sha1
comma
id|p-&gt;one-&gt;sha1
)paren
suffix:semicolon
id|norigin-&gt;mode
op_assign
id|p-&gt;one-&gt;mode
suffix:semicolon
id|fill_origin_blob
c_func
(paren
op_amp
id|sb-&gt;revs-&gt;diffopt
comma
id|norigin
comma
op_amp
id|file_p
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file_p.ptr
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|num_ents
suffix:semicolon
id|j
op_increment
)paren
(brace
id|find_copy_in_blob
c_func
(paren
id|sb
comma
id|blame_list
(braket
id|j
)braket
dot
id|ent
comma
id|norigin
comma
id|this
comma
op_amp
id|file_p
)paren
suffix:semicolon
id|copy_split_if_better
c_func
(paren
id|sb
comma
id|blame_list
(braket
id|j
)braket
dot
id|split
comma
id|this
)paren
suffix:semicolon
id|decref_split
c_func
(paren
id|this
)paren
suffix:semicolon
)brace
id|origin_decref
c_func
(paren
id|norigin
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|num_ents
suffix:semicolon
id|j
op_increment
)paren
(brace
r_struct
id|blame_entry
op_star
id|split
op_assign
id|blame_list
(braket
id|j
)braket
dot
id|split
suffix:semicolon
r_if
c_cond
(paren
id|split
(braket
l_int|1
)braket
dot
id|suspect
op_logical_and
id|blame_copy_score
OL
id|ent_score
c_func
(paren
id|sb
comma
op_amp
id|split
(braket
l_int|1
)braket
)paren
)paren
(brace
id|split_blame
c_func
(paren
id|blamed
comma
op_amp
id|unblamedtail
comma
id|split
comma
id|blame_list
(braket
id|j
)braket
dot
id|ent
)paren
suffix:semicolon
)brace
r_else
(brace
id|blame_list
(braket
id|j
)braket
dot
id|ent-&gt;next
op_assign
id|leftover
suffix:semicolon
id|leftover
op_assign
id|blame_list
(braket
id|j
)braket
dot
id|ent
suffix:semicolon
)brace
id|decref_split
c_func
(paren
id|split
)paren
suffix:semicolon
)brace
id|free
c_func
(paren
id|blame_list
)paren
suffix:semicolon
op_star
id|unblamedtail
op_assign
l_int|NULL
suffix:semicolon
id|toosmall
op_assign
id|filter_small
c_func
(paren
id|sb
comma
id|toosmall
comma
op_amp
id|unblamed
comma
id|blame_copy_score
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|unblamed
)paren
suffix:semicolon
id|target-&gt;suspects
op_assign
id|reverse_blame
c_func
(paren
id|leftover
comma
l_int|NULL
)paren
suffix:semicolon
id|diff_flush
c_func
(paren
op_amp
id|diff_opts
)paren
suffix:semicolon
id|free_pathspec
c_func
(paren
op_amp
id|diff_opts.pathspec
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The blobs of origin and porigin exactly match, so everything&n; * origin is suspected for can be blamed on the parent.&n; */
DECL|function|pass_whole_blame
r_static
r_void
id|pass_whole_blame
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_struct
id|origin
op_star
id|origin
comma
r_struct
id|origin
op_star
id|porigin
)paren
(brace
r_struct
id|blame_entry
op_star
id|e
comma
op_star
id|suspects
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|porigin-&gt;file.ptr
op_logical_and
id|origin-&gt;file.ptr
)paren
(brace
multiline_comment|/* Steal its file */
id|porigin-&gt;file
op_assign
id|origin-&gt;file
suffix:semicolon
id|origin-&gt;file.ptr
op_assign
l_int|NULL
suffix:semicolon
)brace
id|suspects
op_assign
id|origin-&gt;suspects
suffix:semicolon
id|origin-&gt;suspects
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|e
op_assign
id|suspects
suffix:semicolon
id|e
suffix:semicolon
id|e
op_assign
id|e-&gt;next
)paren
(brace
id|origin_incref
c_func
(paren
id|porigin
)paren
suffix:semicolon
id|origin_decref
c_func
(paren
id|e-&gt;suspect
)paren
suffix:semicolon
id|e-&gt;suspect
op_assign
id|porigin
suffix:semicolon
)brace
id|queue_blames
c_func
(paren
id|sb
comma
id|porigin
comma
id|suspects
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * We pass blame from the current commit to its parents.  We keep saying&n; * &quot;parent&quot; (and &quot;porigin&quot;), but what we mean is to find scapegoat to&n; * exonerate ourselves.&n; */
DECL|function|first_scapegoat
r_static
r_struct
id|commit_list
op_star
id|first_scapegoat
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|reverse
)paren
(brace
r_if
c_cond
(paren
id|revs-&gt;first_parent_only
op_logical_and
id|commit-&gt;parents
op_logical_and
id|commit-&gt;parents-&gt;next
)paren
(brace
id|free_commit_list
c_func
(paren
id|commit-&gt;parents-&gt;next
)paren
suffix:semicolon
id|commit-&gt;parents-&gt;next
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|commit-&gt;parents
suffix:semicolon
)brace
r_return
id|lookup_decoration
c_func
(paren
op_amp
id|revs-&gt;children
comma
op_amp
id|commit-&gt;object
)paren
suffix:semicolon
)brace
DECL|function|num_scapegoats
r_static
r_int
id|num_scapegoats
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_struct
id|commit_list
op_star
id|l
op_assign
id|first_scapegoat
c_func
(paren
id|revs
comma
id|commit
)paren
suffix:semicolon
r_return
id|commit_list_count
c_func
(paren
id|l
)paren
suffix:semicolon
)brace
multiline_comment|/* Distribute collected unsorted blames to the respected sorted lists&n; * in the various origins.&n; */
DECL|function|distribute_blame
r_static
r_void
id|distribute_blame
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_struct
id|blame_entry
op_star
id|blamed
)paren
(brace
id|blamed
op_assign
id|blame_sort
c_func
(paren
id|blamed
comma
id|compare_blame_suspect
)paren
suffix:semicolon
r_while
c_loop
(paren
id|blamed
)paren
(brace
r_struct
id|origin
op_star
id|porigin
op_assign
id|blamed-&gt;suspect
suffix:semicolon
r_struct
id|blame_entry
op_star
id|suspects
op_assign
l_int|NULL
suffix:semicolon
r_do
(brace
r_struct
id|blame_entry
op_star
id|next
op_assign
id|blamed-&gt;next
suffix:semicolon
id|blamed-&gt;next
op_assign
id|suspects
suffix:semicolon
id|suspects
op_assign
id|blamed
suffix:semicolon
id|blamed
op_assign
id|next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|blamed
op_logical_and
id|blamed-&gt;suspect
op_eq
id|porigin
)paren
suffix:semicolon
id|suspects
op_assign
id|reverse_blame
c_func
(paren
id|suspects
comma
l_int|NULL
)paren
suffix:semicolon
id|queue_blames
c_func
(paren
id|sb
comma
id|porigin
comma
id|suspects
)paren
suffix:semicolon
)brace
)brace
DECL|macro|MAXSG
mdefine_line|#define MAXSG 16
DECL|function|pass_blame
r_static
r_void
id|pass_blame
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_struct
id|origin
op_star
id|origin
comma
r_int
id|opt
)paren
(brace
r_struct
id|rev_info
op_star
id|revs
op_assign
id|sb-&gt;revs
suffix:semicolon
r_int
id|i
comma
id|pass
comma
id|num_sg
suffix:semicolon
r_struct
id|commit
op_star
id|commit
op_assign
id|origin-&gt;commit
suffix:semicolon
r_struct
id|commit_list
op_star
id|sg
suffix:semicolon
r_struct
id|origin
op_star
id|sg_buf
(braket
id|MAXSG
)braket
suffix:semicolon
r_struct
id|origin
op_star
id|porigin
comma
op_star
op_star
id|sg_origin
op_assign
id|sg_buf
suffix:semicolon
r_struct
id|blame_entry
op_star
id|toosmall
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|blame_entry
op_star
id|blames
comma
op_star
op_star
id|blametail
op_assign
op_amp
id|blames
suffix:semicolon
id|num_sg
op_assign
id|num_scapegoats
c_func
(paren
id|revs
comma
id|commit
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|num_sg
)paren
r_goto
id|finish
suffix:semicolon
r_else
r_if
c_cond
(paren
id|num_sg
OL
id|ARRAY_SIZE
c_func
(paren
id|sg_buf
)paren
)paren
id|memset
c_func
(paren
id|sg_buf
comma
l_int|0
comma
r_sizeof
(paren
id|sg_buf
)paren
)paren
suffix:semicolon
r_else
id|sg_origin
op_assign
id|xcalloc
c_func
(paren
id|num_sg
comma
r_sizeof
(paren
op_star
id|sg_origin
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The first pass looks for unrenamed path to optimize for&n;&t; * common cases, then we look for renames in the second pass.&n;&t; */
r_for
c_loop
(paren
id|pass
op_assign
l_int|0
suffix:semicolon
id|pass
OL
l_int|2
id|no_whole_file_rename
suffix:semicolon
id|pass
op_increment
)paren
(brace
r_struct
id|origin
op_star
(paren
op_star
id|find
)paren
(paren
r_struct
id|scoreboard
op_star
comma
r_struct
id|commit
op_star
comma
r_struct
id|origin
op_star
)paren
suffix:semicolon
id|find
op_assign
id|pass
ques
c_cond
id|find_rename
suffix:colon
id|find_origin
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|sg
op_assign
id|first_scapegoat
c_func
(paren
id|revs
comma
id|commit
)paren
suffix:semicolon
id|i
OL
id|num_sg
op_logical_and
id|sg
suffix:semicolon
id|sg
op_assign
id|sg-&gt;next
comma
id|i
op_increment
)paren
(brace
r_struct
id|commit
op_star
id|p
op_assign
id|sg-&gt;item
suffix:semicolon
r_int
id|j
comma
id|same
suffix:semicolon
r_if
c_cond
(paren
id|sg_origin
(braket
id|i
)braket
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|parse_commit
c_func
(paren
id|p
)paren
)paren
r_continue
suffix:semicolon
id|porigin
op_assign
id|find
c_func
(paren
id|sb
comma
id|p
comma
id|origin
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|porigin
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hashcmp
c_func
(paren
id|porigin-&gt;blob_sha1
comma
id|origin-&gt;blob_sha1
)paren
)paren
(brace
id|pass_whole_blame
c_func
(paren
id|sb
comma
id|origin
comma
id|porigin
)paren
suffix:semicolon
id|origin_decref
c_func
(paren
id|porigin
)paren
suffix:semicolon
r_goto
id|finish
suffix:semicolon
)brace
r_for
c_loop
(paren
id|j
op_assign
id|same
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|i
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
id|sg_origin
(braket
id|j
)braket
op_logical_and
op_logical_neg
id|hashcmp
c_func
(paren
id|sg_origin
(braket
id|j
)braket
op_member_access_from_pointer
id|blob_sha1
comma
id|porigin-&gt;blob_sha1
)paren
)paren
(brace
id|same
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|same
)paren
id|sg_origin
(braket
id|i
)braket
op_assign
id|porigin
suffix:semicolon
r_else
id|origin_decref
c_func
(paren
id|porigin
)paren
suffix:semicolon
)brace
)brace
id|num_commits
op_increment
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|sg
op_assign
id|first_scapegoat
c_func
(paren
id|revs
comma
id|commit
)paren
suffix:semicolon
id|i
OL
id|num_sg
op_logical_and
id|sg
suffix:semicolon
id|sg
op_assign
id|sg-&gt;next
comma
id|i
op_increment
)paren
(brace
r_struct
id|origin
op_star
id|porigin
op_assign
id|sg_origin
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|porigin
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|origin-&gt;previous
)paren
(brace
id|origin_incref
c_func
(paren
id|porigin
)paren
suffix:semicolon
id|origin-&gt;previous
op_assign
id|porigin
suffix:semicolon
)brace
id|pass_blame_to_parent
c_func
(paren
id|sb
comma
id|origin
comma
id|porigin
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|origin-&gt;suspects
)paren
r_goto
id|finish
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Optionally find moves in parents&squot; files.&n;&t; */
r_if
c_cond
(paren
id|opt
op_amp
id|PICKAXE_BLAME_MOVE
)paren
(brace
id|filter_small
c_func
(paren
id|sb
comma
op_amp
id|toosmall
comma
op_amp
id|origin-&gt;suspects
comma
id|blame_move_score
)paren
suffix:semicolon
r_if
c_cond
(paren
id|origin-&gt;suspects
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|sg
op_assign
id|first_scapegoat
c_func
(paren
id|revs
comma
id|commit
)paren
suffix:semicolon
id|i
OL
id|num_sg
op_logical_and
id|sg
suffix:semicolon
id|sg
op_assign
id|sg-&gt;next
comma
id|i
op_increment
)paren
(brace
r_struct
id|origin
op_star
id|porigin
op_assign
id|sg_origin
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|porigin
)paren
r_continue
suffix:semicolon
id|find_move_in_parent
c_func
(paren
id|sb
comma
op_amp
id|blametail
comma
op_amp
id|toosmall
comma
id|origin
comma
id|porigin
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|origin-&gt;suspects
)paren
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * Optionally find copies from parents&squot; files.&n;&t; */
r_if
c_cond
(paren
id|opt
op_amp
id|PICKAXE_BLAME_COPY
)paren
(brace
r_if
c_cond
(paren
id|blame_copy_score
OG
id|blame_move_score
)paren
id|filter_small
c_func
(paren
id|sb
comma
op_amp
id|toosmall
comma
op_amp
id|origin-&gt;suspects
comma
id|blame_copy_score
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|blame_copy_score
OL
id|blame_move_score
)paren
(brace
id|origin-&gt;suspects
op_assign
id|blame_merge
c_func
(paren
id|origin-&gt;suspects
comma
id|toosmall
)paren
suffix:semicolon
id|toosmall
op_assign
l_int|NULL
suffix:semicolon
id|filter_small
c_func
(paren
id|sb
comma
op_amp
id|toosmall
comma
op_amp
id|origin-&gt;suspects
comma
id|blame_copy_score
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|origin-&gt;suspects
)paren
r_goto
id|finish
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|sg
op_assign
id|first_scapegoat
c_func
(paren
id|revs
comma
id|commit
)paren
suffix:semicolon
id|i
OL
id|num_sg
op_logical_and
id|sg
suffix:semicolon
id|sg
op_assign
id|sg-&gt;next
comma
id|i
op_increment
)paren
(brace
r_struct
id|origin
op_star
id|porigin
op_assign
id|sg_origin
(braket
id|i
)braket
suffix:semicolon
id|find_copy_in_parent
c_func
(paren
id|sb
comma
op_amp
id|blametail
comma
op_amp
id|toosmall
comma
id|origin
comma
id|sg-&gt;item
comma
id|porigin
comma
id|opt
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|origin-&gt;suspects
)paren
r_goto
id|finish
suffix:semicolon
)brace
)brace
id|finish
suffix:colon
op_star
id|blametail
op_assign
l_int|NULL
suffix:semicolon
id|distribute_blame
c_func
(paren
id|sb
comma
id|blames
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * prepend toosmall to origin-&gt;suspects&n;&t; *&n;&t; * There is no point in sorting: this ends up on a big&n;&t; * unsorted list in the caller anyway.&n;&t; */
r_if
c_cond
(paren
id|toosmall
)paren
(brace
r_struct
id|blame_entry
op_star
op_star
id|tail
op_assign
op_amp
id|toosmall
suffix:semicolon
r_while
c_loop
(paren
op_star
id|tail
)paren
id|tail
op_assign
op_amp
(paren
op_star
id|tail
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
op_star
id|tail
op_assign
id|origin-&gt;suspects
suffix:semicolon
id|origin-&gt;suspects
op_assign
id|toosmall
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_sg
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|sg_origin
(braket
id|i
)braket
)paren
(brace
id|drop_origin_blob
c_func
(paren
id|sg_origin
(braket
id|i
)braket
)paren
suffix:semicolon
id|origin_decref
c_func
(paren
id|sg_origin
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
id|drop_origin_blob
c_func
(paren
id|origin
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sg_buf
op_ne
id|sg_origin
)paren
id|free
c_func
(paren
id|sg_origin
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Information on commits, used for output.&n; */
DECL|struct|commit_info
r_struct
id|commit_info
(brace
DECL|member|author
r_struct
id|strbuf
id|author
suffix:semicolon
DECL|member|author_mail
r_struct
id|strbuf
id|author_mail
suffix:semicolon
DECL|member|author_time
r_int
r_int
id|author_time
suffix:semicolon
DECL|member|author_tz
r_struct
id|strbuf
id|author_tz
suffix:semicolon
multiline_comment|/* filled only when asked for details */
DECL|member|committer
r_struct
id|strbuf
id|committer
suffix:semicolon
DECL|member|committer_mail
r_struct
id|strbuf
id|committer_mail
suffix:semicolon
DECL|member|committer_time
r_int
r_int
id|committer_time
suffix:semicolon
DECL|member|committer_tz
r_struct
id|strbuf
id|committer_tz
suffix:semicolon
DECL|member|summary
r_struct
id|strbuf
id|summary
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Parse author/committer line in the commit object buffer&n; */
DECL|function|get_ac_line
r_static
r_void
id|get_ac_line
c_func
(paren
r_const
r_char
op_star
id|inbuf
comma
r_const
r_char
op_star
id|what
comma
r_struct
id|strbuf
op_star
id|name
comma
r_struct
id|strbuf
op_star
id|mail
comma
r_int
r_int
op_star
id|time
comma
r_struct
id|strbuf
op_star
id|tz
)paren
(brace
r_struct
id|ident_split
id|ident
suffix:semicolon
r_int
id|len
comma
id|maillen
comma
id|namelen
suffix:semicolon
r_char
op_star
id|tmp
comma
op_star
id|endp
suffix:semicolon
r_const
r_char
op_star
id|namebuf
comma
op_star
id|mailbuf
suffix:semicolon
id|tmp
op_assign
id|strstr
c_func
(paren
id|inbuf
comma
id|what
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp
)paren
r_goto
id|error_out
suffix:semicolon
id|tmp
op_add_assign
id|strlen
c_func
(paren
id|what
)paren
suffix:semicolon
id|endp
op_assign
id|strchr
c_func
(paren
id|tmp
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|endp
)paren
id|len
op_assign
id|strlen
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_else
id|len
op_assign
id|endp
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|split_ident_line
c_func
(paren
op_amp
id|ident
comma
id|tmp
comma
id|len
)paren
)paren
(brace
id|error_out
suffix:colon
multiline_comment|/* Ugh */
id|tmp
op_assign
l_string|&quot;(unknown)&quot;
suffix:semicolon
id|strbuf_addstr
c_func
(paren
id|name
comma
id|tmp
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
id|mail
comma
id|tmp
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
id|tz
comma
id|tmp
)paren
suffix:semicolon
op_star
id|time
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
id|namelen
op_assign
id|ident.name_end
id|ident.name_begin
suffix:semicolon
id|namebuf
op_assign
id|ident.name_begin
suffix:semicolon
id|maillen
op_assign
id|ident.mail_end
id|ident.mail_begin
suffix:semicolon
id|mailbuf
op_assign
id|ident.mail_begin
suffix:semicolon
r_if
c_cond
(paren
id|ident.date_begin
op_logical_and
id|ident.date_end
)paren
op_star
id|time
op_assign
id|strtoul
c_func
(paren
id|ident.date_begin
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_else
op_star
id|time
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ident.tz_begin
op_logical_and
id|ident.tz_end
)paren
id|strbuf_add
c_func
(paren
id|tz
comma
id|ident.tz_begin
comma
id|ident.tz_end
id|ident.tz_begin
)paren
suffix:semicolon
r_else
id|strbuf_addstr
c_func
(paren
id|tz
comma
l_string|&quot;(unknown)&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Now, convert both name and e-mail using mailmap&n;&t; */
id|map_user
c_func
(paren
op_amp
id|mailmap
comma
op_amp
id|mailbuf
comma
op_amp
id|maillen
comma
op_amp
id|namebuf
comma
op_amp
id|namelen
)paren
suffix:semicolon
id|strbuf_addf
c_func
(paren
id|mail
comma
l_string|&quot;&lt;%.*s&gt;&quot;
comma
(paren
r_int
)paren
id|maillen
comma
id|mailbuf
)paren
suffix:semicolon
id|strbuf_add
c_func
(paren
id|name
comma
id|namebuf
comma
id|namelen
)paren
suffix:semicolon
)brace
DECL|function|commit_info_init
r_static
r_void
id|commit_info_init
c_func
(paren
r_struct
id|commit_info
op_star
id|ci
)paren
(brace
id|strbuf_init
c_func
(paren
op_amp
id|ci-&gt;author
comma
l_int|0
)paren
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|ci-&gt;author_mail
comma
l_int|0
)paren
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|ci-&gt;author_tz
comma
l_int|0
)paren
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|ci-&gt;committer
comma
l_int|0
)paren
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|ci-&gt;committer_mail
comma
l_int|0
)paren
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|ci-&gt;committer_tz
comma
l_int|0
)paren
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|ci-&gt;summary
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|commit_info_destroy
r_static
r_void
id|commit_info_destroy
c_func
(paren
r_struct
id|commit_info
op_star
id|ci
)paren
(brace
id|strbuf_release
c_func
(paren
op_amp
id|ci-&gt;author
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|ci-&gt;author_mail
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|ci-&gt;author_tz
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|ci-&gt;committer
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|ci-&gt;committer_mail
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|ci-&gt;committer_tz
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|ci-&gt;summary
)paren
suffix:semicolon
)brace
DECL|function|get_commit_info
r_static
r_void
id|get_commit_info
c_func
(paren
r_struct
id|commit
op_star
id|commit
comma
r_struct
id|commit_info
op_star
id|ret
comma
r_int
id|detailed
)paren
(brace
r_int
id|len
suffix:semicolon
r_const
r_char
op_star
id|subject
comma
op_star
id|encoding
suffix:semicolon
r_const
r_char
op_star
id|message
suffix:semicolon
id|commit_info_init
c_func
(paren
id|ret
)paren
suffix:semicolon
id|encoding
op_assign
id|get_log_output_encoding
c_func
(paren
)paren
suffix:semicolon
id|message
op_assign
id|logmsg_reencode
c_func
(paren
id|commit
comma
l_int|NULL
comma
id|encoding
)paren
suffix:semicolon
id|get_ac_line
c_func
(paren
id|message
comma
l_string|&quot;&bslash;nauthor &quot;
comma
op_amp
id|ret-&gt;author
comma
op_amp
id|ret-&gt;author_mail
comma
op_amp
id|ret-&gt;author_time
comma
op_amp
id|ret-&gt;author_tz
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|detailed
)paren
(brace
id|unuse_commit_buffer
c_func
(paren
id|commit
comma
id|message
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|get_ac_line
c_func
(paren
id|message
comma
l_string|&quot;&bslash;ncommitter &quot;
comma
op_amp
id|ret-&gt;committer
comma
op_amp
id|ret-&gt;committer_mail
comma
op_amp
id|ret-&gt;committer_time
comma
op_amp
id|ret-&gt;committer_tz
)paren
suffix:semicolon
id|len
op_assign
id|find_commit_subject
c_func
(paren
id|message
comma
op_amp
id|subject
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
)paren
id|strbuf_add
c_func
(paren
op_amp
id|ret-&gt;summary
comma
id|subject
comma
id|len
)paren
suffix:semicolon
r_else
id|strbuf_addf
c_func
(paren
op_amp
id|ret-&gt;summary
comma
l_string|&quot;(%s)&quot;
comma
id|oid_to_hex
c_func
(paren
op_amp
id|commit-&gt;object.oid
)paren
)paren
suffix:semicolon
id|unuse_commit_buffer
c_func
(paren
id|commit
comma
id|message
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * To allow LF and other nonportable characters in pathnames,&n; * they are c-style quoted as needed.&n; */
DECL|function|write_filename_info
r_static
r_void
id|write_filename_info
c_func
(paren
r_const
r_char
op_star
id|path
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;filename &quot;
)paren
suffix:semicolon
id|write_name_quoted
c_func
(paren
id|path
comma
id|stdout
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Porcelain/Incremental format wants to show a lot of details per&n; * commit.  Instead of repeating this every line, emit it only once,&n; * the first time each commit appears in the output (unless the&n; * user has specifically asked for us to repeat).&n; */
DECL|function|emit_one_suspect_detail
r_static
r_int
id|emit_one_suspect_detail
c_func
(paren
r_struct
id|origin
op_star
id|suspect
comma
r_int
id|repeat
)paren
(brace
r_struct
id|commit_info
id|ci
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|repeat
op_logical_and
(paren
id|suspect-&gt;commit-&gt;object.flags
op_amp
id|METAINFO_SHOWN
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|suspect-&gt;commit-&gt;object.flags
op_or_assign
id|METAINFO_SHOWN
suffix:semicolon
id|get_commit_info
c_func
(paren
id|suspect-&gt;commit
comma
op_amp
id|ci
comma
l_int|1
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;author %s&bslash;n&quot;
comma
id|ci.author.buf
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;author-mail %s&bslash;n&quot;
comma
id|ci.author_mail.buf
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;author-time %lu&bslash;n&quot;
comma
id|ci.author_time
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;author-tz %s&bslash;n&quot;
comma
id|ci.author_tz.buf
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;committer %s&bslash;n&quot;
comma
id|ci.committer.buf
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;committer-mail %s&bslash;n&quot;
comma
id|ci.committer_mail.buf
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;committer-time %lu&bslash;n&quot;
comma
id|ci.committer_time
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;committer-tz %s&bslash;n&quot;
comma
id|ci.committer_tz.buf
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;summary %s&bslash;n&quot;
comma
id|ci.summary.buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|suspect-&gt;commit-&gt;object.flags
op_amp
id|UNINTERESTING
)paren
id|printf
c_func
(paren
l_string|&quot;boundary&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|suspect-&gt;previous
)paren
(brace
r_struct
id|origin
op_star
id|prev
op_assign
id|suspect-&gt;previous
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;previous %s &quot;
comma
id|oid_to_hex
c_func
(paren
op_amp
id|prev-&gt;commit-&gt;object.oid
)paren
)paren
suffix:semicolon
id|write_name_quoted
c_func
(paren
id|prev-&gt;path
comma
id|stdout
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
id|commit_info_destroy
c_func
(paren
op_amp
id|ci
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * The blame_entry is found to be guilty for the range.&n; * Show it in incremental output.&n; */
DECL|function|found_guilty_entry
r_static
r_void
id|found_guilty_entry
c_func
(paren
r_struct
id|blame_entry
op_star
id|ent
)paren
(brace
r_if
c_cond
(paren
id|incremental
)paren
(brace
r_struct
id|origin
op_star
id|suspect
op_assign
id|ent-&gt;suspect
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s %d %d %d&bslash;n&quot;
comma
id|oid_to_hex
c_func
(paren
op_amp
id|suspect-&gt;commit-&gt;object.oid
)paren
comma
id|ent-&gt;s_lno
op_plus
l_int|1
comma
id|ent-&gt;lno
op_plus
l_int|1
comma
id|ent-&gt;num_lines
)paren
suffix:semicolon
id|emit_one_suspect_detail
c_func
(paren
id|suspect
comma
l_int|0
)paren
suffix:semicolon
id|write_filename_info
c_func
(paren
id|suspect-&gt;path
)paren
suffix:semicolon
id|maybe_flush_or_die
c_func
(paren
id|stdout
comma
l_string|&quot;stdout&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * The main loop -- while we have blobs with lines whose true origin&n; * is still unknown, pick one blob, and allow its lines to pass blames&n; * to its parents. */
DECL|function|assign_blame
r_static
r_void
id|assign_blame
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_int
id|opt
)paren
(brace
r_struct
id|rev_info
op_star
id|revs
op_assign
id|sb-&gt;revs
suffix:semicolon
r_struct
id|commit
op_star
id|commit
op_assign
id|prio_queue_get
c_func
(paren
op_amp
id|sb-&gt;commits
)paren
suffix:semicolon
r_while
c_loop
(paren
id|commit
)paren
(brace
r_struct
id|blame_entry
op_star
id|ent
suffix:semicolon
r_struct
id|origin
op_star
id|suspect
op_assign
id|commit-&gt;util
suffix:semicolon
multiline_comment|/* find one suspect to break down */
r_while
c_loop
(paren
id|suspect
op_logical_and
op_logical_neg
id|suspect-&gt;suspects
)paren
id|suspect
op_assign
id|suspect-&gt;next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|suspect
)paren
(brace
id|commit
op_assign
id|prio_queue_get
c_func
(paren
op_amp
id|sb-&gt;commits
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
m_assert
(paren
id|commit
op_eq
id|suspect-&gt;commit
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We will use this suspect later in the loop,&n;&t;&t; * so hold onto it in the meantime.&n;&t;&t; */
id|origin_incref
c_func
(paren
id|suspect
)paren
suffix:semicolon
id|parse_commit
c_func
(paren
id|commit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reverse
op_logical_or
(paren
op_logical_neg
(paren
id|commit-&gt;object.flags
op_amp
id|UNINTERESTING
)paren
op_logical_and
op_logical_neg
(paren
id|revs-&gt;max_age
op_ne
l_int|1
op_logical_and
id|commit-&gt;date
OL
id|revs-&gt;max_age
)paren
)paren
)paren
id|pass_blame
c_func
(paren
id|sb
comma
id|suspect
comma
id|opt
)paren
suffix:semicolon
r_else
(brace
id|commit-&gt;object.flags
op_or_assign
id|UNINTERESTING
suffix:semicolon
r_if
c_cond
(paren
id|commit-&gt;object.parsed
)paren
id|mark_parents_uninteresting
c_func
(paren
id|commit
)paren
suffix:semicolon
)brace
multiline_comment|/* treat root commit as boundary */
r_if
c_cond
(paren
op_logical_neg
id|commit-&gt;parents
op_logical_and
op_logical_neg
id|show_root
)paren
id|commit-&gt;object.flags
op_or_assign
id|UNINTERESTING
suffix:semicolon
multiline_comment|/* Take responsibility for the remaining entries */
id|ent
op_assign
id|suspect-&gt;suspects
suffix:semicolon
r_if
c_cond
(paren
id|ent
)paren
(brace
id|suspect-&gt;guilty
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|blame_entry
op_star
id|next
op_assign
id|ent-&gt;next
suffix:semicolon
id|found_guilty_entry
c_func
(paren
id|ent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|next
)paren
(brace
id|ent
op_assign
id|next
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|ent-&gt;next
op_assign
id|sb-&gt;ent
suffix:semicolon
id|sb-&gt;ent
op_assign
id|suspect-&gt;suspects
suffix:semicolon
id|suspect-&gt;suspects
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|origin_decref
c_func
(paren
id|suspect
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG
)paren
multiline_comment|/* sanity */
id|sanity_check_refcnt
c_func
(paren
id|sb
)paren
suffix:semicolon
)brace
)brace
DECL|function|format_time
r_static
r_const
r_char
op_star
id|format_time
c_func
(paren
r_int
r_int
id|time
comma
r_const
r_char
op_star
id|tz_str
comma
r_int
id|show_raw_time
)paren
(brace
r_static
r_struct
id|strbuf
id|time_buf
op_assign
id|STRBUF_INIT
suffix:semicolon
id|strbuf_reset
c_func
(paren
op_amp
id|time_buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|show_raw_time
)paren
(brace
id|strbuf_addf
c_func
(paren
op_amp
id|time_buf
comma
l_string|&quot;%lu %s&quot;
comma
id|time
comma
id|tz_str
)paren
suffix:semicolon
)brace
r_else
(brace
r_const
r_char
op_star
id|time_str
suffix:semicolon
r_int
id|time_width
suffix:semicolon
r_int
id|tz
suffix:semicolon
id|tz
op_assign
id|atoi
c_func
(paren
id|tz_str
)paren
suffix:semicolon
id|time_str
op_assign
id|show_date
c_func
(paren
id|time
comma
id|tz
comma
op_amp
id|blame_date_mode
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|time_buf
comma
id|time_str
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Add space paddings to time_buf to display a fixed width&n;&t;&t; * string, and use time_width for display width calibration.&n;&t;&t; */
r_for
c_loop
(paren
id|time_width
op_assign
id|utf8_strwidth
c_func
(paren
id|time_str
)paren
suffix:semicolon
id|time_width
OL
id|blame_date_width
suffix:semicolon
id|time_width
op_increment
)paren
id|strbuf_addch
c_func
(paren
op_amp
id|time_buf
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
)brace
r_return
id|time_buf.buf
suffix:semicolon
)brace
DECL|macro|OUTPUT_ANNOTATE_COMPAT
mdefine_line|#define OUTPUT_ANNOTATE_COMPAT&t;001
DECL|macro|OUTPUT_LONG_OBJECT_NAME
mdefine_line|#define OUTPUT_LONG_OBJECT_NAME&t;002
DECL|macro|OUTPUT_RAW_TIMESTAMP
mdefine_line|#define OUTPUT_RAW_TIMESTAMP&t;004
DECL|macro|OUTPUT_PORCELAIN
mdefine_line|#define OUTPUT_PORCELAIN&t;010
DECL|macro|OUTPUT_SHOW_NAME
mdefine_line|#define OUTPUT_SHOW_NAME&t;020
DECL|macro|OUTPUT_SHOW_NUMBER
mdefine_line|#define OUTPUT_SHOW_NUMBER&t;040
DECL|macro|OUTPUT_SHOW_SCORE
mdefine_line|#define OUTPUT_SHOW_SCORE      0100
DECL|macro|OUTPUT_NO_AUTHOR
mdefine_line|#define OUTPUT_NO_AUTHOR       0200
DECL|macro|OUTPUT_SHOW_EMAIL
mdefine_line|#define OUTPUT_SHOW_EMAIL&t;0400
DECL|macro|OUTPUT_LINE_PORCELAIN
mdefine_line|#define OUTPUT_LINE_PORCELAIN 01000
DECL|function|emit_porcelain_details
r_static
r_void
id|emit_porcelain_details
c_func
(paren
r_struct
id|origin
op_star
id|suspect
comma
r_int
id|repeat
)paren
(brace
r_if
c_cond
(paren
id|emit_one_suspect_detail
c_func
(paren
id|suspect
comma
id|repeat
)paren
op_logical_or
(paren
id|suspect-&gt;commit-&gt;object.flags
op_amp
id|MORE_THAN_ONE_PATH
)paren
)paren
id|write_filename_info
c_func
(paren
id|suspect-&gt;path
)paren
suffix:semicolon
)brace
DECL|function|emit_porcelain
r_static
r_void
id|emit_porcelain
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_struct
id|blame_entry
op_star
id|ent
comma
r_int
id|opt
)paren
(brace
r_int
id|repeat
op_assign
id|opt
op_amp
id|OUTPUT_LINE_PORCELAIN
suffix:semicolon
r_int
id|cnt
suffix:semicolon
r_const
r_char
op_star
id|cp
suffix:semicolon
r_struct
id|origin
op_star
id|suspect
op_assign
id|ent-&gt;suspect
suffix:semicolon
r_char
id|hex
(braket
id|GIT_SHA1_HEXSZ
op_plus
l_int|1
)braket
suffix:semicolon
id|sha1_to_hex_r
c_func
(paren
id|hex
comma
id|suspect-&gt;commit-&gt;object.oid.hash
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s %d %d %d&bslash;n&quot;
comma
id|hex
comma
id|ent-&gt;s_lno
op_plus
l_int|1
comma
id|ent-&gt;lno
op_plus
l_int|1
comma
id|ent-&gt;num_lines
)paren
suffix:semicolon
id|emit_porcelain_details
c_func
(paren
id|suspect
comma
id|repeat
)paren
suffix:semicolon
id|cp
op_assign
id|nth_line
c_func
(paren
id|sb
comma
id|ent-&gt;lno
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|ent-&gt;num_lines
suffix:semicolon
id|cnt
op_increment
)paren
(brace
r_char
id|ch
suffix:semicolon
r_if
c_cond
(paren
id|cnt
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s %d %d&bslash;n&quot;
comma
id|hex
comma
id|ent-&gt;s_lno
op_plus
l_int|1
op_plus
id|cnt
comma
id|ent-&gt;lno
op_plus
l_int|1
op_plus
id|cnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|repeat
)paren
id|emit_porcelain_details
c_func
(paren
id|suspect
comma
l_int|1
)paren
suffix:semicolon
)brace
id|putchar
c_func
(paren
l_char|&squot;&bslash;t&squot;
)paren
suffix:semicolon
r_do
(brace
id|ch
op_assign
op_star
id|cp
op_increment
suffix:semicolon
id|putchar
c_func
(paren
id|ch
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|ch
op_ne
l_char|&squot;&bslash;n&squot;
op_logical_and
id|cp
OL
id|sb-&gt;final_buf
op_plus
id|sb-&gt;final_buf_size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sb-&gt;final_buf_size
op_logical_and
id|cp
(braket
l_int|1
)braket
op_ne
l_char|&squot;&bslash;n&squot;
)paren
id|putchar
c_func
(paren
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
DECL|function|emit_other
r_static
r_void
id|emit_other
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_struct
id|blame_entry
op_star
id|ent
comma
r_int
id|opt
)paren
(brace
r_int
id|cnt
suffix:semicolon
r_const
r_char
op_star
id|cp
suffix:semicolon
r_struct
id|origin
op_star
id|suspect
op_assign
id|ent-&gt;suspect
suffix:semicolon
r_struct
id|commit_info
id|ci
suffix:semicolon
r_char
id|hex
(braket
id|GIT_SHA1_HEXSZ
op_plus
l_int|1
)braket
suffix:semicolon
r_int
id|show_raw_time
op_assign
op_logical_neg
op_logical_neg
(paren
id|opt
op_amp
id|OUTPUT_RAW_TIMESTAMP
)paren
suffix:semicolon
id|get_commit_info
c_func
(paren
id|suspect-&gt;commit
comma
op_amp
id|ci
comma
l_int|1
)paren
suffix:semicolon
id|sha1_to_hex_r
c_func
(paren
id|hex
comma
id|suspect-&gt;commit-&gt;object.oid.hash
)paren
suffix:semicolon
id|cp
op_assign
id|nth_line
c_func
(paren
id|sb
comma
id|ent-&gt;lno
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|ent-&gt;num_lines
suffix:semicolon
id|cnt
op_increment
)paren
(brace
r_char
id|ch
suffix:semicolon
r_int
id|length
op_assign
(paren
id|opt
op_amp
id|OUTPUT_LONG_OBJECT_NAME
)paren
ques
c_cond
l_int|40
suffix:colon
id|abbrev
suffix:semicolon
r_if
c_cond
(paren
id|suspect-&gt;commit-&gt;object.flags
op_amp
id|UNINTERESTING
)paren
(brace
r_if
c_cond
(paren
id|blank_boundary
)paren
id|memset
c_func
(paren
id|hex
comma
l_char|&squot; &squot;
comma
id|length
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|opt
op_amp
id|OUTPUT_ANNOTATE_COMPAT
)paren
)paren
(brace
id|length
op_decrement
suffix:semicolon
id|putchar
c_func
(paren
l_char|&squot;^&squot;
)paren
suffix:semicolon
)brace
)brace
id|printf
c_func
(paren
l_string|&quot;%.*s&quot;
comma
id|length
comma
id|hex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opt
op_amp
id|OUTPUT_ANNOTATE_COMPAT
)paren
(brace
r_const
r_char
op_star
id|name
suffix:semicolon
r_if
c_cond
(paren
id|opt
op_amp
id|OUTPUT_SHOW_EMAIL
)paren
id|name
op_assign
id|ci.author_mail.buf
suffix:semicolon
r_else
id|name
op_assign
id|ci.author.buf
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;t(%10s&bslash;t%10s&bslash;t%d)&quot;
comma
id|name
comma
id|format_time
c_func
(paren
id|ci.author_time
comma
id|ci.author_tz.buf
comma
id|show_raw_time
)paren
comma
id|ent-&gt;lno
op_plus
l_int|1
op_plus
id|cnt
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|opt
op_amp
id|OUTPUT_SHOW_SCORE
)paren
id|printf
c_func
(paren
l_string|&quot; %*d %02d&quot;
comma
id|max_score_digits
comma
id|ent-&gt;score
comma
id|ent-&gt;suspect-&gt;refcnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opt
op_amp
id|OUTPUT_SHOW_NAME
)paren
id|printf
c_func
(paren
l_string|&quot; %-*.*s&quot;
comma
id|longest_file
comma
id|longest_file
comma
id|suspect-&gt;path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opt
op_amp
id|OUTPUT_SHOW_NUMBER
)paren
id|printf
c_func
(paren
l_string|&quot; %*d&quot;
comma
id|max_orig_digits
comma
id|ent-&gt;s_lno
op_plus
l_int|1
op_plus
id|cnt
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|opt
op_amp
id|OUTPUT_NO_AUTHOR
)paren
)paren
(brace
r_const
r_char
op_star
id|name
suffix:semicolon
r_int
id|pad
suffix:semicolon
r_if
c_cond
(paren
id|opt
op_amp
id|OUTPUT_SHOW_EMAIL
)paren
id|name
op_assign
id|ci.author_mail.buf
suffix:semicolon
r_else
id|name
op_assign
id|ci.author.buf
suffix:semicolon
id|pad
op_assign
id|longest_author
id|utf8_strwidth
c_func
(paren
id|name
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot; (%s%*s %10s&quot;
comma
id|name
comma
id|pad
comma
l_string|&quot;&quot;
comma
id|format_time
c_func
(paren
id|ci.author_time
comma
id|ci.author_tz.buf
comma
id|show_raw_time
)paren
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot; %*d) &quot;
comma
id|max_digits
comma
id|ent-&gt;lno
op_plus
l_int|1
op_plus
id|cnt
)paren
suffix:semicolon
)brace
r_do
(brace
id|ch
op_assign
op_star
id|cp
op_increment
suffix:semicolon
id|putchar
c_func
(paren
id|ch
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|ch
op_ne
l_char|&squot;&bslash;n&squot;
op_logical_and
id|cp
OL
id|sb-&gt;final_buf
op_plus
id|sb-&gt;final_buf_size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sb-&gt;final_buf_size
op_logical_and
id|cp
(braket
l_int|1
)braket
op_ne
l_char|&squot;&bslash;n&squot;
)paren
id|putchar
c_func
(paren
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|commit_info_destroy
c_func
(paren
op_amp
id|ci
)paren
suffix:semicolon
)brace
DECL|function|output
r_static
r_void
id|output
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_int
id|option
)paren
(brace
r_struct
id|blame_entry
op_star
id|ent
suffix:semicolon
r_if
c_cond
(paren
id|option
op_amp
id|OUTPUT_PORCELAIN
)paren
(brace
r_for
c_loop
(paren
id|ent
op_assign
id|sb-&gt;ent
suffix:semicolon
id|ent
suffix:semicolon
id|ent
op_assign
id|ent-&gt;next
)paren
(brace
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_struct
id|origin
op_star
id|suspect
suffix:semicolon
r_struct
id|commit
op_star
id|commit
op_assign
id|ent-&gt;suspect-&gt;commit
suffix:semicolon
r_if
c_cond
(paren
id|commit-&gt;object.flags
op_amp
id|MORE_THAN_ONE_PATH
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|suspect
op_assign
id|commit-&gt;util
suffix:semicolon
id|suspect
suffix:semicolon
id|suspect
op_assign
id|suspect-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|suspect-&gt;guilty
op_logical_and
id|count
op_increment
)paren
(brace
id|commit-&gt;object.flags
op_or_assign
id|MORE_THAN_ONE_PATH
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
)brace
r_for
c_loop
(paren
id|ent
op_assign
id|sb-&gt;ent
suffix:semicolon
id|ent
suffix:semicolon
id|ent
op_assign
id|ent-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|option
op_amp
id|OUTPUT_PORCELAIN
)paren
id|emit_porcelain
c_func
(paren
id|sb
comma
id|ent
comma
id|option
)paren
suffix:semicolon
r_else
(brace
id|emit_other
c_func
(paren
id|sb
comma
id|ent
comma
id|option
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|get_next_line
r_static
r_const
r_char
op_star
id|get_next_line
c_func
(paren
r_const
r_char
op_star
id|start
comma
r_const
r_char
op_star
id|end
)paren
(brace
r_const
r_char
op_star
id|nl
op_assign
id|memchr
c_func
(paren
id|start
comma
l_char|&squot;&bslash;n&squot;
comma
id|end
id|start
)paren
suffix:semicolon
r_return
id|nl
ques
c_cond
id|nl
op_plus
l_int|1
suffix:colon
id|end
suffix:semicolon
)brace
multiline_comment|/*&n; * To allow quick access to the contents of nth line in the&n; * final image, prepare an index in the scoreboard.&n; */
DECL|function|prepare_lines
r_static
r_int
id|prepare_lines
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
)paren
(brace
r_const
r_char
op_star
id|buf
op_assign
id|sb-&gt;final_buf
suffix:semicolon
r_int
r_int
id|len
op_assign
id|sb-&gt;final_buf_size
suffix:semicolon
r_const
r_char
op_star
id|end
op_assign
id|buf
op_plus
id|len
suffix:semicolon
r_const
r_char
op_star
id|p
suffix:semicolon
r_int
op_star
id|lineno
suffix:semicolon
r_int
id|num
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|buf
suffix:semicolon
id|p
OL
id|end
suffix:semicolon
id|p
op_assign
id|get_next_line
c_func
(paren
id|p
comma
id|end
)paren
)paren
id|num
op_increment
suffix:semicolon
id|sb-&gt;lineno
op_assign
id|lineno
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|sb-&gt;lineno
)paren
op_star
(paren
id|num
op_plus
l_int|1
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|buf
suffix:semicolon
id|p
OL
id|end
suffix:semicolon
id|p
op_assign
id|get_next_line
c_func
(paren
id|p
comma
id|end
)paren
)paren
op_star
id|lineno
op_increment
op_assign
id|p
id|buf
suffix:semicolon
op_star
id|lineno
op_assign
id|len
suffix:semicolon
id|sb-&gt;num_lines
op_assign
id|num
suffix:semicolon
r_return
id|sb-&gt;num_lines
suffix:semicolon
)brace
multiline_comment|/*&n; * Add phony grafts for use with -S; this is primarily to&n; * support git&squot;s cvsserver that wants to give a linear history&n; * to its clients.&n; */
DECL|function|read_ancestry
r_static
r_int
id|read_ancestry
c_func
(paren
r_const
r_char
op_star
id|graft_file
)paren
(brace
id|FILE
op_star
id|fp
op_assign
id|fopen
c_func
(paren
id|graft_file
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_struct
id|strbuf
id|buf
op_assign
id|STRBUF_INIT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fp
)paren
r_return
l_int|1
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|strbuf_getwholeline
c_func
(paren
op_amp
id|buf
comma
id|fp
comma
l_char|&squot;&bslash;n&squot;
)paren
)paren
(brace
multiline_comment|/* The format is just &quot;Commit Parent1 Parent2 ...&bslash;n&quot; */
r_struct
id|commit_graft
op_star
id|graft
op_assign
id|read_graft_line
c_func
(paren
id|buf.buf
comma
id|buf.len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|graft
)paren
id|register_commit_graft
c_func
(paren
id|graft
comma
l_int|0
)paren
suffix:semicolon
)brace
id|fclose
c_func
(paren
id|fp
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|buf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|update_auto_abbrev
r_static
r_int
id|update_auto_abbrev
c_func
(paren
r_int
id|auto_abbrev
comma
r_struct
id|origin
op_star
id|suspect
)paren
(brace
r_const
r_char
op_star
id|uniq
op_assign
id|find_unique_abbrev
c_func
(paren
id|get_object_hash
c_func
(paren
id|suspect-&gt;commit-&gt;object
)paren
comma
id|auto_abbrev
)paren
suffix:semicolon
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|uniq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|auto_abbrev
OL
id|len
)paren
r_return
id|len
suffix:semicolon
r_return
id|auto_abbrev
suffix:semicolon
)brace
multiline_comment|/*&n; * How many columns do we need to show line numbers, authors,&n; * and filenames?&n; */
DECL|function|find_alignment
r_static
r_void
id|find_alignment
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
comma
r_int
op_star
id|option
)paren
(brace
r_int
id|longest_src_lines
op_assign
l_int|0
suffix:semicolon
r_int
id|longest_dst_lines
op_assign
l_int|0
suffix:semicolon
r_int
id|largest_score
op_assign
l_int|0
suffix:semicolon
r_struct
id|blame_entry
op_star
id|e
suffix:semicolon
r_int
id|compute_auto_abbrev
op_assign
(paren
id|abbrev
OL
l_int|0
)paren
suffix:semicolon
r_int
id|auto_abbrev
op_assign
id|default_abbrev
suffix:semicolon
r_for
c_loop
(paren
id|e
op_assign
id|sb-&gt;ent
suffix:semicolon
id|e
suffix:semicolon
id|e
op_assign
id|e-&gt;next
)paren
(brace
r_struct
id|origin
op_star
id|suspect
op_assign
id|e-&gt;suspect
suffix:semicolon
r_int
id|num
suffix:semicolon
r_if
c_cond
(paren
id|compute_auto_abbrev
)paren
id|auto_abbrev
op_assign
id|update_auto_abbrev
c_func
(paren
id|auto_abbrev
comma
id|suspect
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|suspect-&gt;path
comma
id|sb-&gt;path
)paren
)paren
op_star
id|option
op_or_assign
id|OUTPUT_SHOW_NAME
suffix:semicolon
id|num
op_assign
id|strlen
c_func
(paren
id|suspect-&gt;path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|longest_file
OL
id|num
)paren
id|longest_file
op_assign
id|num
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|suspect-&gt;commit-&gt;object.flags
op_amp
id|METAINFO_SHOWN
)paren
)paren
(brace
r_struct
id|commit_info
id|ci
suffix:semicolon
id|suspect-&gt;commit-&gt;object.flags
op_or_assign
id|METAINFO_SHOWN
suffix:semicolon
id|get_commit_info
c_func
(paren
id|suspect-&gt;commit
comma
op_amp
id|ci
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|option
op_amp
id|OUTPUT_SHOW_EMAIL
)paren
id|num
op_assign
id|utf8_strwidth
c_func
(paren
id|ci.author_mail.buf
)paren
suffix:semicolon
r_else
id|num
op_assign
id|utf8_strwidth
c_func
(paren
id|ci.author.buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|longest_author
OL
id|num
)paren
id|longest_author
op_assign
id|num
suffix:semicolon
id|commit_info_destroy
c_func
(paren
op_amp
id|ci
)paren
suffix:semicolon
)brace
id|num
op_assign
id|e-&gt;s_lno
op_plus
id|e-&gt;num_lines
suffix:semicolon
r_if
c_cond
(paren
id|longest_src_lines
OL
id|num
)paren
id|longest_src_lines
op_assign
id|num
suffix:semicolon
id|num
op_assign
id|e-&gt;lno
op_plus
id|e-&gt;num_lines
suffix:semicolon
r_if
c_cond
(paren
id|longest_dst_lines
OL
id|num
)paren
id|longest_dst_lines
op_assign
id|num
suffix:semicolon
r_if
c_cond
(paren
id|largest_score
OL
id|ent_score
c_func
(paren
id|sb
comma
id|e
)paren
)paren
id|largest_score
op_assign
id|ent_score
c_func
(paren
id|sb
comma
id|e
)paren
suffix:semicolon
)brace
id|max_orig_digits
op_assign
id|decimal_width
c_func
(paren
id|longest_src_lines
)paren
suffix:semicolon
id|max_digits
op_assign
id|decimal_width
c_func
(paren
id|longest_dst_lines
)paren
suffix:semicolon
id|max_score_digits
op_assign
id|decimal_width
c_func
(paren
id|largest_score
)paren
suffix:semicolon
r_if
c_cond
(paren
id|compute_auto_abbrev
)paren
multiline_comment|/* one more abbrev length is needed for the boundary commit */
id|abbrev
op_assign
id|auto_abbrev
op_plus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * For debugging -- origin is refcounted, and this asserts that&n; * we do not underflow.&n; */
DECL|function|sanity_check_refcnt
r_static
r_void
id|sanity_check_refcnt
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
)paren
(brace
r_int
id|baa
op_assign
l_int|0
suffix:semicolon
r_struct
id|blame_entry
op_star
id|ent
suffix:semicolon
r_for
c_loop
(paren
id|ent
op_assign
id|sb-&gt;ent
suffix:semicolon
id|ent
suffix:semicolon
id|ent
op_assign
id|ent-&gt;next
)paren
(brace
multiline_comment|/* Nobody should have zero or negative refcnt */
r_if
c_cond
(paren
id|ent-&gt;suspect-&gt;refcnt
op_le
l_int|0
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s in %s has negative refcnt %d&bslash;n&quot;
comma
id|ent-&gt;suspect-&gt;path
comma
id|oid_to_hex
c_func
(paren
op_amp
id|ent-&gt;suspect-&gt;commit-&gt;object.oid
)paren
comma
id|ent-&gt;suspect-&gt;refcnt
)paren
suffix:semicolon
id|baa
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|baa
)paren
(brace
r_int
id|opt
op_assign
l_int|0160
suffix:semicolon
id|find_alignment
c_func
(paren
id|sb
comma
op_amp
id|opt
)paren
suffix:semicolon
id|output
c_func
(paren
id|sb
comma
id|opt
)paren
suffix:semicolon
id|die
c_func
(paren
l_string|&quot;Baa %d!&quot;
comma
id|baa
)paren
suffix:semicolon
)brace
)brace
DECL|function|parse_score
r_static
r_int
id|parse_score
c_func
(paren
r_const
r_char
op_star
id|arg
)paren
(brace
r_char
op_star
id|end
suffix:semicolon
r_int
r_int
id|score
op_assign
id|strtoul
c_func
(paren
id|arg
comma
op_amp
id|end
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|end
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|score
suffix:semicolon
)brace
DECL|function|add_prefix
r_static
r_const
r_char
op_star
id|add_prefix
c_func
(paren
r_const
r_char
op_star
id|prefix
comma
r_const
r_char
op_star
id|path
)paren
(brace
r_return
id|prefix_path
c_func
(paren
id|prefix
comma
id|prefix
ques
c_cond
id|strlen
c_func
(paren
id|prefix
)paren
suffix:colon
l_int|0
comma
id|path
)paren
suffix:semicolon
)brace
DECL|function|git_blame_config
r_static
r_int
id|git_blame_config
c_func
(paren
r_const
r_char
op_star
id|var
comma
r_const
r_char
op_star
id|value
comma
r_void
op_star
id|cb
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;blame.showroot&quot;
)paren
)paren
(brace
id|show_root
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;blame.blankboundary&quot;
)paren
)paren
(brace
id|blank_boundary
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;blame.showemail&quot;
)paren
)paren
(brace
r_int
op_star
id|output_option
op_assign
id|cb
suffix:semicolon
r_if
c_cond
(paren
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
)paren
op_star
id|output_option
op_or_assign
id|OUTPUT_SHOW_EMAIL
suffix:semicolon
r_else
op_star
id|output_option
op_and_assign
op_complement
id|OUTPUT_SHOW_EMAIL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;blame.date&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
r_return
id|config_error_nonbool
c_func
(paren
id|var
)paren
suffix:semicolon
id|parse_date_format
c_func
(paren
id|value
comma
op_amp
id|blame_date_mode
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|userdiff_config
c_func
(paren
id|var
comma
id|value
)paren
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_return
id|git_default_config
c_func
(paren
id|var
comma
id|value
comma
id|cb
)paren
suffix:semicolon
)brace
DECL|function|verify_working_tree_path
r_static
r_void
id|verify_working_tree_path
c_func
(paren
r_struct
id|commit
op_star
id|work_tree
comma
r_const
r_char
op_star
id|path
)paren
(brace
r_struct
id|commit_list
op_star
id|parents
suffix:semicolon
r_for
c_loop
(paren
id|parents
op_assign
id|work_tree-&gt;parents
suffix:semicolon
id|parents
suffix:semicolon
id|parents
op_assign
id|parents-&gt;next
)paren
(brace
r_const
r_int
r_char
op_star
id|commit_sha1
op_assign
id|get_object_hash
c_func
(paren
id|parents-&gt;item-&gt;object
)paren
suffix:semicolon
r_int
r_char
id|blob_sha1
(braket
l_int|20
)braket
suffix:semicolon
r_int
id|mode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|get_tree_entry
c_func
(paren
id|commit_sha1
comma
id|path
comma
id|blob_sha1
comma
op_amp
id|mode
)paren
op_logical_and
id|sha1_object_info
c_func
(paren
id|blob_sha1
comma
l_int|NULL
)paren
op_eq
id|OBJ_BLOB
)paren
r_return
suffix:semicolon
)brace
id|die
c_func
(paren
l_string|&quot;no such path &squot;%s&squot; in HEAD&quot;
comma
id|path
)paren
suffix:semicolon
)brace
DECL|function|append_parent
r_static
r_struct
id|commit_list
op_star
op_star
id|append_parent
c_func
(paren
r_struct
id|commit_list
op_star
op_star
id|tail
comma
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_struct
id|commit
op_star
id|parent
suffix:semicolon
id|parent
op_assign
id|lookup_commit_reference
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parent
)paren
id|die
c_func
(paren
l_string|&quot;no such commit %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
r_return
op_amp
id|commit_list_insert
c_func
(paren
id|parent
comma
id|tail
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
)brace
DECL|function|append_merge_parents
r_static
r_void
id|append_merge_parents
c_func
(paren
r_struct
id|commit_list
op_star
op_star
id|tail
)paren
(brace
r_int
id|merge_head
suffix:semicolon
r_struct
id|strbuf
id|line
op_assign
id|STRBUF_INIT
suffix:semicolon
id|merge_head
op_assign
id|open
c_func
(paren
id|git_path_merge_head
c_func
(paren
)paren
comma
id|O_RDONLY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|merge_head
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|errno
op_eq
id|ENOENT
)paren
r_return
suffix:semicolon
id|die
c_func
(paren
l_string|&quot;cannot open &squot;%s&squot; for reading&quot;
comma
id|git_path_merge_head
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|strbuf_getwholeline_fd
c_func
(paren
op_amp
id|line
comma
id|merge_head
comma
l_char|&squot;&bslash;n&squot;
)paren
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_if
c_cond
(paren
id|line.len
OL
l_int|40
op_logical_or
id|get_sha1_hex
c_func
(paren
id|line.buf
comma
id|sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;unknown line in &squot;%s&squot;: %s&quot;
comma
id|git_path_merge_head
c_func
(paren
)paren
comma
id|line.buf
)paren
suffix:semicolon
id|tail
op_assign
id|append_parent
c_func
(paren
id|tail
comma
id|sha1
)paren
suffix:semicolon
)brace
id|close
c_func
(paren
id|merge_head
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|line
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This isn&squot;t as simple as passing sb-&gt;buf and sb-&gt;len, because we&n; * want to transfer ownership of the buffer to the commit (so we&n; * must use detach).&n; */
DECL|function|set_commit_buffer_from_strbuf
r_static
r_void
id|set_commit_buffer_from_strbuf
c_func
(paren
r_struct
id|commit
op_star
id|c
comma
r_struct
id|strbuf
op_star
id|sb
)paren
(brace
r_int
id|len
suffix:semicolon
r_void
op_star
id|buf
op_assign
id|strbuf_detach
c_func
(paren
id|sb
comma
op_amp
id|len
)paren
suffix:semicolon
id|set_commit_buffer
c_func
(paren
id|c
comma
id|buf
comma
id|len
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Prepare a dummy commit that represents the work tree (or staged) item.&n; * Note that annotating work tree item never works in the reverse.&n; */
DECL|function|fake_working_tree_commit
r_static
r_struct
id|commit
op_star
id|fake_working_tree_commit
c_func
(paren
r_struct
id|diff_options
op_star
id|opt
comma
r_const
r_char
op_star
id|path
comma
r_const
r_char
op_star
id|contents_from
)paren
(brace
r_struct
id|commit
op_star
id|commit
suffix:semicolon
r_struct
id|origin
op_star
id|origin
suffix:semicolon
r_struct
id|commit_list
op_star
op_star
id|parent_tail
comma
op_star
id|parent
suffix:semicolon
r_int
r_char
id|head_sha1
(braket
l_int|20
)braket
suffix:semicolon
r_struct
id|strbuf
id|buf
op_assign
id|STRBUF_INIT
suffix:semicolon
r_const
r_char
op_star
id|ident
suffix:semicolon
id|time_t
id|now
suffix:semicolon
r_int
id|size
comma
id|len
suffix:semicolon
r_struct
id|cache_entry
op_star
id|ce
suffix:semicolon
r_int
id|mode
suffix:semicolon
r_struct
id|strbuf
id|msg
op_assign
id|STRBUF_INIT
suffix:semicolon
id|time
c_func
(paren
op_amp
id|now
)paren
suffix:semicolon
id|commit
op_assign
id|alloc_commit_node
c_func
(paren
)paren
suffix:semicolon
id|commit-&gt;object.parsed
op_assign
l_int|1
suffix:semicolon
id|commit-&gt;date
op_assign
id|now
suffix:semicolon
id|parent_tail
op_assign
op_amp
id|commit-&gt;parents
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|resolve_ref_unsafe
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|RESOLVE_REF_READING
comma
id|head_sha1
comma
l_int|NULL
)paren
)paren
id|die
c_func
(paren
l_string|&quot;no such ref: HEAD&quot;
)paren
suffix:semicolon
id|parent_tail
op_assign
id|append_parent
c_func
(paren
id|parent_tail
comma
id|head_sha1
)paren
suffix:semicolon
id|append_merge_parents
c_func
(paren
id|parent_tail
)paren
suffix:semicolon
id|verify_working_tree_path
c_func
(paren
id|commit
comma
id|path
)paren
suffix:semicolon
id|origin
op_assign
id|make_origin
c_func
(paren
id|commit
comma
id|path
)paren
suffix:semicolon
id|ident
op_assign
id|fmt_ident
c_func
(paren
l_string|&quot;Not Committed Yet&quot;
comma
l_string|&quot;not.committed.yet&quot;
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|msg
comma
l_string|&quot;tree 0000000000000000000000000000000000000000&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|parent
op_assign
id|commit-&gt;parents
suffix:semicolon
id|parent
suffix:semicolon
id|parent
op_assign
id|parent-&gt;next
)paren
id|strbuf_addf
c_func
(paren
op_amp
id|msg
comma
l_string|&quot;parent %s&bslash;n&quot;
comma
id|oid_to_hex
c_func
(paren
op_amp
id|parent-&gt;item-&gt;object.oid
)paren
)paren
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
id|msg
comma
l_string|&quot;author %s&bslash;n&quot;
l_string|&quot;committer %s&bslash;n&bslash;n&quot;
l_string|&quot;Version of %s from %s&bslash;n&quot;
comma
id|ident
comma
id|ident
comma
id|path
comma
(paren
op_logical_neg
id|contents_from
ques
c_cond
id|path
suffix:colon
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|contents_from
comma
l_string|&quot;-&quot;
)paren
ques
c_cond
l_string|&quot;standard input&quot;
suffix:colon
id|contents_from
)paren
)paren
)paren
suffix:semicolon
id|set_commit_buffer_from_strbuf
c_func
(paren
id|commit
comma
op_amp
id|msg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|contents_from
op_logical_or
id|strcmp
c_func
(paren
l_string|&quot;-&quot;
comma
id|contents_from
)paren
)paren
(brace
r_struct
id|stat
id|st
suffix:semicolon
r_const
r_char
op_star
id|read_from
suffix:semicolon
r_char
op_star
id|buf_ptr
suffix:semicolon
r_int
r_int
id|buf_len
suffix:semicolon
r_if
c_cond
(paren
id|contents_from
)paren
(brace
r_if
c_cond
(paren
id|stat
c_func
(paren
id|contents_from
comma
op_amp
id|st
)paren
OL
l_int|0
)paren
id|die_errno
c_func
(paren
l_string|&quot;Cannot stat &squot;%s&squot;&quot;
comma
id|contents_from
)paren
suffix:semicolon
id|read_from
op_assign
id|contents_from
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|lstat
c_func
(paren
id|path
comma
op_amp
id|st
)paren
OL
l_int|0
)paren
id|die_errno
c_func
(paren
l_string|&quot;Cannot lstat &squot;%s&squot;&quot;
comma
id|path
)paren
suffix:semicolon
id|read_from
op_assign
id|path
suffix:semicolon
)brace
id|mode
op_assign
id|canon_mode
c_func
(paren
id|st.st_mode
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|st.st_mode
op_amp
id|S_IFMT
)paren
(brace
r_case
id|S_IFREG
suffix:colon
r_if
c_cond
(paren
id|DIFF_OPT_TST
c_func
(paren
id|opt
comma
id|ALLOW_TEXTCONV
)paren
op_logical_and
id|textconv_object
c_func
(paren
id|read_from
comma
id|mode
comma
id|null_sha1
comma
l_int|0
comma
op_amp
id|buf_ptr
comma
op_amp
id|buf_len
)paren
)paren
id|strbuf_attach
c_func
(paren
op_amp
id|buf
comma
id|buf_ptr
comma
id|buf_len
comma
id|buf_len
op_plus
l_int|1
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strbuf_read_file
c_func
(paren
op_amp
id|buf
comma
id|read_from
comma
id|st.st_size
)paren
op_ne
id|st.st_size
)paren
id|die_errno
c_func
(paren
l_string|&quot;cannot open or read &squot;%s&squot;&quot;
comma
id|read_from
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_IFLNK
suffix:colon
r_if
c_cond
(paren
id|strbuf_readlink
c_func
(paren
op_amp
id|buf
comma
id|read_from
comma
id|st.st_size
)paren
OL
l_int|0
)paren
id|die_errno
c_func
(paren
l_string|&quot;cannot readlink &squot;%s&squot;&quot;
comma
id|read_from
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|die
c_func
(paren
l_string|&quot;unsupported file type %s&quot;
comma
id|read_from
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Reading from stdin */
id|mode
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|strbuf_read
c_func
(paren
op_amp
id|buf
comma
l_int|0
comma
l_int|0
)paren
OL
l_int|0
)paren
id|die_errno
c_func
(paren
l_string|&quot;failed to read from stdin&quot;
)paren
suffix:semicolon
)brace
id|convert_to_git
c_func
(paren
id|path
comma
id|buf.buf
comma
id|buf.len
comma
op_amp
id|buf
comma
l_int|0
)paren
suffix:semicolon
id|origin-&gt;file.ptr
op_assign
id|buf.buf
suffix:semicolon
id|origin-&gt;file.size
op_assign
id|buf.len
suffix:semicolon
id|pretend_sha1_file
c_func
(paren
id|buf.buf
comma
id|buf.len
comma
id|OBJ_BLOB
comma
id|origin-&gt;blob_sha1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Read the current index, replace the path entry with&n;&t; * origin-&gt;blob_sha1 without mucking with its mode or type&n;&t; * bits; we are not going to write this index out -- we just&n;&t; * want to run &quot;diff-index --cached&quot;.&n;&t; */
id|discard_cache
c_func
(paren
)paren
suffix:semicolon
id|read_cache
c_func
(paren
)paren
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mode
)paren
(brace
r_int
id|pos
op_assign
id|cache_name_pos
c_func
(paren
id|path
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_le
id|pos
)paren
id|mode
op_assign
id|active_cache
(braket
id|pos
)braket
op_member_access_from_pointer
id|ce_mode
suffix:semicolon
r_else
multiline_comment|/* Let&squot;s not bother reading from HEAD tree */
id|mode
op_assign
id|S_IFREG
op_or
l_int|0644
suffix:semicolon
)brace
id|size
op_assign
id|cache_entry_size
c_func
(paren
id|len
)paren
suffix:semicolon
id|ce
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
id|size
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|ce-&gt;sha1
comma
id|origin-&gt;blob_sha1
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ce-&gt;name
comma
id|path
comma
id|len
)paren
suffix:semicolon
id|ce-&gt;ce_flags
op_assign
id|create_ce_flags
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|ce-&gt;ce_namelen
op_assign
id|len
suffix:semicolon
id|ce-&gt;ce_mode
op_assign
id|create_ce_mode
c_func
(paren
id|mode
)paren
suffix:semicolon
id|add_cache_entry
c_func
(paren
id|ce
comma
id|ADD_CACHE_OK_TO_ADD
op_or
id|ADD_CACHE_OK_TO_REPLACE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We are not going to write this out, so this does not matter&n;&t; * right now, but someday we might optimize diff-index --cached&n;&t; * with cache-tree information.&n;&t; */
id|cache_tree_invalidate_path
c_func
(paren
op_amp
id|the_index
comma
id|path
)paren
suffix:semicolon
r_return
id|commit
suffix:semicolon
)brace
DECL|function|find_single_final
r_static
r_struct
id|object_array_entry
op_star
id|find_single_final
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|object_array_entry
op_star
id|found
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|revs-&gt;pending.nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|object
op_star
id|obj
op_assign
id|revs-&gt;pending.objects
(braket
id|i
)braket
dot
id|item
suffix:semicolon
r_if
c_cond
(paren
id|obj-&gt;flags
op_amp
id|UNINTERESTING
)paren
r_continue
suffix:semicolon
r_while
c_loop
(paren
id|obj-&gt;type
op_eq
id|OBJ_TAG
)paren
id|obj
op_assign
id|deref_tag
c_func
(paren
id|obj
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|obj-&gt;type
op_ne
id|OBJ_COMMIT
)paren
id|die
c_func
(paren
l_string|&quot;Non commit %s?&quot;
comma
id|revs-&gt;pending.objects
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|found
)paren
id|die
c_func
(paren
l_string|&quot;More than one commit to dig from %s and %s?&quot;
comma
id|revs-&gt;pending.objects
(braket
id|i
)braket
dot
id|name
comma
id|found-&gt;name
)paren
suffix:semicolon
id|found
op_assign
op_amp
(paren
id|revs-&gt;pending.objects
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_return
id|found
suffix:semicolon
)brace
DECL|function|prepare_final
r_static
r_char
op_star
id|prepare_final
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
)paren
(brace
r_struct
id|object_array_entry
op_star
id|found
op_assign
id|find_single_final
c_func
(paren
id|sb-&gt;revs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|found
)paren
(brace
id|sb-&gt;final
op_assign
(paren
r_struct
id|commit
op_star
)paren
id|found-&gt;item
suffix:semicolon
r_return
id|xstrdup
c_func
(paren
id|found-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
DECL|function|prepare_initial
r_static
r_char
op_star
id|prepare_initial
c_func
(paren
r_struct
id|scoreboard
op_star
id|sb
)paren
(brace
r_int
id|i
suffix:semicolon
r_const
r_char
op_star
id|final_commit_name
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|rev_info
op_star
id|revs
op_assign
id|sb-&gt;revs
suffix:semicolon
multiline_comment|/*&n;&t; * There must be one and only one negative commit, and it must be&n;&t; * the boundary.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|revs-&gt;pending.nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|object
op_star
id|obj
op_assign
id|revs-&gt;pending.objects
(braket
id|i
)braket
dot
id|item
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|obj-&gt;flags
op_amp
id|UNINTERESTING
)paren
)paren
r_continue
suffix:semicolon
r_while
c_loop
(paren
id|obj-&gt;type
op_eq
id|OBJ_TAG
)paren
id|obj
op_assign
id|deref_tag
c_func
(paren
id|obj
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|obj-&gt;type
op_ne
id|OBJ_COMMIT
)paren
id|die
c_func
(paren
l_string|&quot;Non commit %s?&quot;
comma
id|revs-&gt;pending.objects
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;final
)paren
id|die
c_func
(paren
l_string|&quot;More than one commit to dig down to %s and %s?&quot;
comma
id|revs-&gt;pending.objects
(braket
id|i
)braket
dot
id|name
comma
id|final_commit_name
)paren
suffix:semicolon
id|sb-&gt;final
op_assign
(paren
r_struct
id|commit
op_star
)paren
id|obj
suffix:semicolon
id|final_commit_name
op_assign
id|revs-&gt;pending.objects
(braket
id|i
)braket
dot
id|name
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|final_commit_name
)paren
id|die
c_func
(paren
l_string|&quot;No commit to dig down to?&quot;
)paren
suffix:semicolon
r_return
id|xstrdup
c_func
(paren
id|final_commit_name
)paren
suffix:semicolon
)brace
DECL|function|blame_copy_callback
r_static
r_int
id|blame_copy_callback
c_func
(paren
r_const
r_struct
id|option
op_star
id|option
comma
r_const
r_char
op_star
id|arg
comma
r_int
id|unset
)paren
(brace
r_int
op_star
id|opt
op_assign
id|option-&gt;value
suffix:semicolon
multiline_comment|/*&n;&t; * -C enables copy from removed files;&n;&t; * -C -C enables copy from existing files, but only&n;&t; *       when blaming a new file;&n;&t; * -C -C -C enables copy from existing files for&n;&t; *          everybody&n;&t; */
r_if
c_cond
(paren
op_star
id|opt
op_amp
id|PICKAXE_BLAME_COPY_HARDER
)paren
op_star
id|opt
op_or_assign
id|PICKAXE_BLAME_COPY_HARDEST
suffix:semicolon
r_if
c_cond
(paren
op_star
id|opt
op_amp
id|PICKAXE_BLAME_COPY
)paren
op_star
id|opt
op_or_assign
id|PICKAXE_BLAME_COPY_HARDER
suffix:semicolon
op_star
id|opt
op_or_assign
id|PICKAXE_BLAME_COPY
op_or
id|PICKAXE_BLAME_MOVE
suffix:semicolon
r_if
c_cond
(paren
id|arg
)paren
id|blame_copy_score
op_assign
id|parse_score
c_func
(paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|blame_move_callback
r_static
r_int
id|blame_move_callback
c_func
(paren
r_const
r_struct
id|option
op_star
id|option
comma
r_const
r_char
op_star
id|arg
comma
r_int
id|unset
)paren
(brace
r_int
op_star
id|opt
op_assign
id|option-&gt;value
suffix:semicolon
op_star
id|opt
op_or_assign
id|PICKAXE_BLAME_MOVE
suffix:semicolon
r_if
c_cond
(paren
id|arg
)paren
id|blame_move_score
op_assign
id|parse_score
c_func
(paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cmd_blame
r_int
id|cmd_blame
c_func
(paren
r_int
id|argc
comma
r_const
r_char
op_star
op_star
id|argv
comma
r_const
r_char
op_star
id|prefix
)paren
(brace
r_struct
id|rev_info
id|revs
suffix:semicolon
r_const
r_char
op_star
id|path
suffix:semicolon
r_struct
id|scoreboard
id|sb
suffix:semicolon
r_struct
id|origin
op_star
id|o
suffix:semicolon
r_struct
id|blame_entry
op_star
id|ent
op_assign
l_int|NULL
suffix:semicolon
r_int
id|dashdash_pos
comma
id|lno
suffix:semicolon
r_char
op_star
id|final_commit_name
op_assign
l_int|NULL
suffix:semicolon
r_enum
id|object_type
id|type
suffix:semicolon
r_struct
id|commit
op_star
id|final_commit
op_assign
l_int|NULL
suffix:semicolon
r_static
r_struct
id|string_list
id|range_list
suffix:semicolon
r_static
r_int
id|output_option
op_assign
l_int|0
comma
id|opt
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|show_stats
op_assign
l_int|0
suffix:semicolon
r_static
r_const
r_char
op_star
id|revs_file
op_assign
l_int|NULL
suffix:semicolon
r_static
r_const
r_char
op_star
id|contents_from
op_assign
l_int|NULL
suffix:semicolon
r_static
r_const
r_struct
id|option
id|options
(braket
)braket
op_assign
(brace
id|OPT_BOOL
c_func
(paren
l_int|0
comma
l_string|&quot;incremental&quot;
comma
op_amp
id|incremental
comma
id|N_
c_func
(paren
l_string|&quot;Show blame entries as we find them, incrementally&quot;
)paren
)paren
comma
id|OPT_BOOL
c_func
(paren
l_char|&squot;b&squot;
comma
l_int|NULL
comma
op_amp
id|blank_boundary
comma
id|N_
c_func
(paren
l_string|&quot;Show blank SHA-1 for boundary commits (Default: off)&quot;
)paren
)paren
comma
id|OPT_BOOL
c_func
(paren
l_int|0
comma
l_string|&quot;root&quot;
comma
op_amp
id|show_root
comma
id|N_
c_func
(paren
l_string|&quot;Do not treat root commits as boundaries (Default: off)&quot;
)paren
)paren
comma
id|OPT_BOOL
c_func
(paren
l_int|0
comma
l_string|&quot;show-stats&quot;
comma
op_amp
id|show_stats
comma
id|N_
c_func
(paren
l_string|&quot;Show work cost statistics&quot;
)paren
)paren
comma
id|OPT_BIT
c_func
(paren
l_int|0
comma
l_string|&quot;score-debug&quot;
comma
op_amp
id|output_option
comma
id|N_
c_func
(paren
l_string|&quot;Show output score for blame entries&quot;
)paren
comma
id|OUTPUT_SHOW_SCORE
)paren
comma
id|OPT_BIT
c_func
(paren
l_char|&squot;f&squot;
comma
l_string|&quot;show-name&quot;
comma
op_amp
id|output_option
comma
id|N_
c_func
(paren
l_string|&quot;Show original filename (Default: auto)&quot;
)paren
comma
id|OUTPUT_SHOW_NAME
)paren
comma
id|OPT_BIT
c_func
(paren
l_char|&squot;n&squot;
comma
l_string|&quot;show-number&quot;
comma
op_amp
id|output_option
comma
id|N_
c_func
(paren
l_string|&quot;Show original linenumber (Default: off)&quot;
)paren
comma
id|OUTPUT_SHOW_NUMBER
)paren
comma
id|OPT_BIT
c_func
(paren
l_char|&squot;p&squot;
comma
l_string|&quot;porcelain&quot;
comma
op_amp
id|output_option
comma
id|N_
c_func
(paren
l_string|&quot;Show in a format designed for machine consumption&quot;
)paren
comma
id|OUTPUT_PORCELAIN
)paren
comma
id|OPT_BIT
c_func
(paren
l_int|0
comma
l_string|&quot;line-porcelain&quot;
comma
op_amp
id|output_option
comma
id|N_
c_func
(paren
l_string|&quot;Show porcelain format with per-line commit information&quot;
)paren
comma
id|OUTPUT_PORCELAIN
op_or
id|OUTPUT_LINE_PORCELAIN
)paren
comma
id|OPT_BIT
c_func
(paren
l_char|&squot;c&squot;
comma
l_int|NULL
comma
op_amp
id|output_option
comma
id|N_
c_func
(paren
l_string|&quot;Use the same output mode as git-annotate (Default: off)&quot;
)paren
comma
id|OUTPUT_ANNOTATE_COMPAT
)paren
comma
id|OPT_BIT
c_func
(paren
l_char|&squot;t&squot;
comma
l_int|NULL
comma
op_amp
id|output_option
comma
id|N_
c_func
(paren
l_string|&quot;Show raw timestamp (Default: off)&quot;
)paren
comma
id|OUTPUT_RAW_TIMESTAMP
)paren
comma
id|OPT_BIT
c_func
(paren
l_char|&squot;l&squot;
comma
l_int|NULL
comma
op_amp
id|output_option
comma
id|N_
c_func
(paren
l_string|&quot;Show long commit SHA1 (Default: off)&quot;
)paren
comma
id|OUTPUT_LONG_OBJECT_NAME
)paren
comma
id|OPT_BIT
c_func
(paren
l_char|&squot;s&squot;
comma
l_int|NULL
comma
op_amp
id|output_option
comma
id|N_
c_func
(paren
l_string|&quot;Suppress author name and timestamp (Default: off)&quot;
)paren
comma
id|OUTPUT_NO_AUTHOR
)paren
comma
id|OPT_BIT
c_func
(paren
l_char|&squot;e&squot;
comma
l_string|&quot;show-email&quot;
comma
op_amp
id|output_option
comma
id|N_
c_func
(paren
l_string|&quot;Show author email instead of name (Default: off)&quot;
)paren
comma
id|OUTPUT_SHOW_EMAIL
)paren
comma
id|OPT_BIT
c_func
(paren
l_char|&squot;w&squot;
comma
l_int|NULL
comma
op_amp
id|xdl_opts
comma
id|N_
c_func
(paren
l_string|&quot;Ignore whitespace differences&quot;
)paren
comma
id|XDF_IGNORE_WHITESPACE
)paren
comma
id|OPT_BIT
c_func
(paren
l_int|0
comma
l_string|&quot;minimal&quot;
comma
op_amp
id|xdl_opts
comma
id|N_
c_func
(paren
l_string|&quot;Spend extra cycles to find better match&quot;
)paren
comma
id|XDF_NEED_MINIMAL
)paren
comma
id|OPT_STRING
c_func
(paren
l_char|&squot;S&squot;
comma
l_int|NULL
comma
op_amp
id|revs_file
comma
id|N_
c_func
(paren
l_string|&quot;file&quot;
)paren
comma
id|N_
c_func
(paren
l_string|&quot;Use revisions from &lt;file&gt; instead of calling git-rev-list&quot;
)paren
)paren
comma
id|OPT_STRING
c_func
(paren
l_int|0
comma
l_string|&quot;contents&quot;
comma
op_amp
id|contents_from
comma
id|N_
c_func
(paren
l_string|&quot;file&quot;
)paren
comma
id|N_
c_func
(paren
l_string|&quot;Use &lt;file&gt;&squot;s contents as the final image&quot;
)paren
)paren
comma
(brace
id|OPTION_CALLBACK
comma
l_char|&squot;C&squot;
comma
l_int|NULL
comma
op_amp
id|opt
comma
id|N_
c_func
(paren
l_string|&quot;score&quot;
)paren
comma
id|N_
c_func
(paren
l_string|&quot;Find line copies within and across files&quot;
)paren
comma
id|PARSE_OPT_OPTARG
comma
id|blame_copy_callback
)brace
comma
(brace
id|OPTION_CALLBACK
comma
l_char|&squot;M&squot;
comma
l_int|NULL
comma
op_amp
id|opt
comma
id|N_
c_func
(paren
l_string|&quot;score&quot;
)paren
comma
id|N_
c_func
(paren
l_string|&quot;Find line movements within and across files&quot;
)paren
comma
id|PARSE_OPT_OPTARG
comma
id|blame_move_callback
)brace
comma
id|OPT_STRING_LIST
c_func
(paren
l_char|&squot;L&squot;
comma
l_int|NULL
comma
op_amp
id|range_list
comma
id|N_
c_func
(paren
l_string|&quot;n,m&quot;
)paren
comma
id|N_
c_func
(paren
l_string|&quot;Process only line range n,m, counting from 1&quot;
)paren
)paren
comma
id|OPT__ABBREV
c_func
(paren
op_amp
id|abbrev
)paren
comma
id|OPT_END
c_func
(paren
)paren
)brace
suffix:semicolon
r_struct
id|parse_opt_ctx_t
id|ctx
suffix:semicolon
r_int
id|cmd_is_annotate
op_assign
op_logical_neg
id|strcmp
c_func
(paren
id|argv
(braket
l_int|0
)braket
comma
l_string|&quot;annotate&quot;
)paren
suffix:semicolon
r_struct
id|range_set
id|ranges
suffix:semicolon
r_int
r_int
id|range_i
suffix:semicolon
r_int
id|anchor
suffix:semicolon
id|git_config
c_func
(paren
id|git_blame_config
comma
op_amp
id|output_option
)paren
suffix:semicolon
id|init_revisions
c_func
(paren
op_amp
id|revs
comma
l_int|NULL
)paren
suffix:semicolon
id|revs.date_mode
op_assign
id|blame_date_mode
suffix:semicolon
id|DIFF_OPT_SET
c_func
(paren
op_amp
id|revs.diffopt
comma
id|ALLOW_TEXTCONV
)paren
suffix:semicolon
id|DIFF_OPT_SET
c_func
(paren
op_amp
id|revs.diffopt
comma
id|FOLLOW_RENAMES
)paren
suffix:semicolon
id|save_commit_buffer
op_assign
l_int|0
suffix:semicolon
id|dashdash_pos
op_assign
l_int|0
suffix:semicolon
id|parse_options_start
c_func
(paren
op_amp
id|ctx
comma
id|argc
comma
id|argv
comma
id|prefix
comma
id|options
comma
id|PARSE_OPT_KEEP_DASHDASH
op_or
id|PARSE_OPT_KEEP_ARGV0
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_switch
c_cond
(paren
id|parse_options_step
c_func
(paren
op_amp
id|ctx
comma
id|options
comma
id|blame_opt_usage
)paren
)paren
(brace
r_case
id|PARSE_OPT_HELP
suffix:colon
m_exit
(paren
l_int|129
)paren
suffix:semicolon
r_case
id|PARSE_OPT_DONE
suffix:colon
r_if
c_cond
(paren
id|ctx.argv
(braket
l_int|0
)braket
)paren
id|dashdash_pos
op_assign
id|ctx.cpidx
suffix:semicolon
r_goto
id|parse_done
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|ctx.argv
(braket
l_int|0
)braket
comma
l_string|&quot;--reverse&quot;
)paren
)paren
(brace
id|ctx.argv
(braket
l_int|0
)braket
op_assign
l_string|&quot;--children&quot;
suffix:semicolon
id|reverse
op_assign
l_int|1
suffix:semicolon
)brace
id|parse_revision_opt
c_func
(paren
op_amp
id|revs
comma
op_amp
id|ctx
comma
id|options
comma
id|blame_opt_usage
)paren
suffix:semicolon
)brace
id|parse_done
suffix:colon
id|no_whole_file_rename
op_assign
op_logical_neg
id|DIFF_OPT_TST
c_func
(paren
op_amp
id|revs.diffopt
comma
id|FOLLOW_RENAMES
)paren
suffix:semicolon
id|DIFF_OPT_CLR
c_func
(paren
op_amp
id|revs.diffopt
comma
id|FOLLOW_RENAMES
)paren
suffix:semicolon
id|argc
op_assign
id|parse_options_end
c_func
(paren
op_amp
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
OL
id|abbrev
)paren
multiline_comment|/* one more abbrev length is needed for the boundary commit */
id|abbrev
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|revs_file
op_logical_and
id|read_ancestry
c_func
(paren
id|revs_file
)paren
)paren
id|die_errno
c_func
(paren
l_string|&quot;reading graft file &squot;%s&squot; failed&quot;
comma
id|revs_file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd_is_annotate
)paren
(brace
id|output_option
op_or_assign
id|OUTPUT_ANNOTATE_COMPAT
suffix:semicolon
id|blame_date_mode.type
op_assign
id|DATE_ISO8601
suffix:semicolon
)brace
r_else
(brace
id|blame_date_mode
op_assign
id|revs.date_mode
suffix:semicolon
)brace
multiline_comment|/* The maximum width used to show the dates */
r_switch
c_cond
(paren
id|blame_date_mode.type
)paren
(brace
r_case
id|DATE_RFC2822
suffix:colon
id|blame_date_width
op_assign
r_sizeof
(paren
l_string|&quot;Thu, 19 Oct 2006 16:00:04 -0700&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DATE_ISO8601_STRICT
suffix:colon
id|blame_date_width
op_assign
r_sizeof
(paren
l_string|&quot;2006-10-19T16:00:04-07:00&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DATE_ISO8601
suffix:colon
id|blame_date_width
op_assign
r_sizeof
(paren
l_string|&quot;2006-10-19 16:00:04 -0700&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DATE_RAW
suffix:colon
id|blame_date_width
op_assign
r_sizeof
(paren
l_string|&quot;1161298804 -0700&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DATE_SHORT
suffix:colon
id|blame_date_width
op_assign
r_sizeof
(paren
l_string|&quot;2006-10-19&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DATE_RELATIVE
suffix:colon
multiline_comment|/* TRANSLATORS: This string is used to tell us the maximum&n;&t;&t;   display width for a relative timestamp in &quot;git blame&quot;&n;&t;&t;   output.  For C locale, &quot;4 years, 11 months ago&quot;, which&n;&t;&t;   takes 22 places, is the longest among various forms of&n;&t;&t;   relative timestamps, but your language may need more or&n;&t;&t;   fewer display columns. */
id|blame_date_width
op_assign
id|utf8_strwidth
c_func
(paren
id|_
c_func
(paren
l_string|&quot;4 years, 11 months ago&quot;
)paren
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* add the null */
r_break
suffix:semicolon
r_case
id|DATE_NORMAL
suffix:colon
id|blame_date_width
op_assign
r_sizeof
(paren
l_string|&quot;Thu Oct 19 16:00:04 2006 -0700&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DATE_STRFTIME
suffix:colon
id|blame_date_width
op_assign
id|strlen
c_func
(paren
id|show_date
c_func
(paren
l_int|0
comma
l_int|0
comma
op_amp
id|blame_date_mode
)paren
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* add the null */
r_break
suffix:semicolon
)brace
id|blame_date_width
op_sub_assign
l_int|1
suffix:semicolon
multiline_comment|/* strip the null */
r_if
c_cond
(paren
id|DIFF_OPT_TST
c_func
(paren
op_amp
id|revs.diffopt
comma
id|FIND_COPIES_HARDER
)paren
)paren
id|opt
op_or_assign
(paren
id|PICKAXE_BLAME_COPY
op_or
id|PICKAXE_BLAME_MOVE
op_or
id|PICKAXE_BLAME_COPY_HARDER
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|blame_move_score
)paren
id|blame_move_score
op_assign
id|BLAME_DEFAULT_MOVE_SCORE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|blame_copy_score
)paren
id|blame_copy_score
op_assign
id|BLAME_DEFAULT_COPY_SCORE
suffix:semicolon
multiline_comment|/*&n;&t; * We have collected options unknown to us in argv[1..unk]&n;&t; * which are to be passed to revision machinery if we are&n;&t; * going to do the &quot;bottom&quot; processing.&n;&t; *&n;&t; * The remaining are:&n;&t; *&n;&t; * (1) if dashdash_pos != 0, it is either&n;&t; *     &quot;blame [revisions] -- &lt;path&gt;&quot; or&n;&t; *     &quot;blame -- &lt;path&gt; &lt;rev&gt;&quot;&n;&t; *&n;&t; * (2) otherwise, it is one of the two:&n;&t; *     &quot;blame [revisions] &lt;path&gt;&quot;&n;&t; *     &quot;blame &lt;path&gt; &lt;rev&gt;&quot;&n;&t; *&n;&t; * Note that we must strip out &lt;path&gt; from the arguments: we do not&n;&t; * want the path pruning but we may want &quot;bottom&quot; processing.&n;&t; */
r_if
c_cond
(paren
id|dashdash_pos
)paren
(brace
r_switch
c_cond
(paren
id|argc
id|dashdash_pos
l_int|1
)paren
(brace
r_case
l_int|2
suffix:colon
multiline_comment|/* (1b) */
r_if
c_cond
(paren
id|argc
op_ne
l_int|4
)paren
id|usage_with_options
c_func
(paren
id|blame_opt_usage
comma
id|options
)paren
suffix:semicolon
multiline_comment|/* reorder for the new way: &lt;rev&gt; -- &lt;path&gt; */
id|argv
(braket
l_int|1
)braket
op_assign
id|argv
(braket
l_int|3
)braket
suffix:semicolon
id|argv
(braket
l_int|3
)braket
op_assign
id|argv
(braket
l_int|2
)braket
suffix:semicolon
id|argv
(braket
l_int|2
)braket
op_assign
l_string|&quot;--&quot;
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
r_case
l_int|1
suffix:colon
multiline_comment|/* (1a) */
id|path
op_assign
id|add_prefix
c_func
(paren
id|prefix
comma
id|argv
(braket
op_decrement
id|argc
)braket
)paren
suffix:semicolon
id|argv
(braket
id|argc
)braket
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|usage_with_options
c_func
(paren
id|blame_opt_usage
comma
id|options
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|argc
OL
l_int|2
)paren
id|usage_with_options
c_func
(paren
id|blame_opt_usage
comma
id|options
)paren
suffix:semicolon
id|path
op_assign
id|add_prefix
c_func
(paren
id|prefix
comma
id|argv
(braket
id|argc
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|argc
op_eq
l_int|3
op_logical_and
op_logical_neg
id|file_exists
c_func
(paren
id|path
)paren
)paren
(brace
multiline_comment|/* (2b) */
id|path
op_assign
id|add_prefix
c_func
(paren
id|prefix
comma
id|argv
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|argv
(braket
l_int|1
)braket
op_assign
id|argv
(braket
l_int|2
)braket
suffix:semicolon
)brace
id|argv
(braket
id|argc
l_int|1
)braket
op_assign
l_string|&quot;--&quot;
suffix:semicolon
id|setup_work_tree
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file_exists
c_func
(paren
id|path
)paren
)paren
id|die_errno
c_func
(paren
l_string|&quot;cannot stat path &squot;%s&squot;&quot;
comma
id|path
)paren
suffix:semicolon
)brace
id|revs.disable_stdin
op_assign
l_int|1
suffix:semicolon
id|setup_revisions
c_func
(paren
id|argc
comma
id|argv
comma
op_amp
id|revs
comma
l_int|NULL
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|sb
comma
l_int|0
comma
r_sizeof
(paren
id|sb
)paren
)paren
suffix:semicolon
id|sb.revs
op_assign
op_amp
id|revs
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|reverse
)paren
(brace
id|final_commit_name
op_assign
id|prepare_final
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
id|sb.commits.compare
op_assign
id|compare_commits_by_commit_date
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|contents_from
)paren
id|die
c_func
(paren
l_string|&quot;--contents and --reverse do not blend well.&quot;
)paren
suffix:semicolon
r_else
(brace
id|final_commit_name
op_assign
id|prepare_initial
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
id|sb.commits.compare
op_assign
id|compare_commits_by_reverse_commit_date
suffix:semicolon
r_if
c_cond
(paren
id|revs.first_parent_only
)paren
id|revs.children.name
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sb.final
)paren
(brace
multiline_comment|/*&n;&t;&t; * &quot;--not A B -- path&quot; without anything positive;&n;&t;&t; * do not default to HEAD, but use the working tree&n;&t;&t; * or &quot;--contents&quot;.&n;&t;&t; */
id|setup_work_tree
c_func
(paren
)paren
suffix:semicolon
id|sb.final
op_assign
id|fake_working_tree_commit
c_func
(paren
op_amp
id|sb.revs-&gt;diffopt
comma
id|path
comma
id|contents_from
)paren
suffix:semicolon
id|add_pending_object
c_func
(paren
op_amp
id|revs
comma
op_amp
(paren
id|sb.final-&gt;object
)paren
comma
l_string|&quot;:&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|contents_from
)paren
id|die
c_func
(paren
l_string|&quot;Cannot use --contents with final commit object name&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reverse
op_logical_and
id|revs.first_parent_only
)paren
(brace
r_struct
id|object_array_entry
op_star
id|entry
op_assign
id|find_single_final
c_func
(paren
id|sb.revs
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
)paren
id|die
c_func
(paren
l_string|&quot;--reverse and --first-parent together require specified latest commit&quot;
)paren
suffix:semicolon
r_else
id|final_commit
op_assign
(paren
r_struct
id|commit
op_star
)paren
id|entry-&gt;item
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we have bottom, this will mark the ancestors of the&n;&t; * bottom commits we would reach while traversing as&n;&t; * uninteresting.&n;&t; */
r_if
c_cond
(paren
id|prepare_revision_walk
c_func
(paren
op_amp
id|revs
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;revision walk setup failed&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reverse
op_logical_and
id|revs.first_parent_only
)paren
(brace
r_struct
id|commit
op_star
id|c
op_assign
id|final_commit
suffix:semicolon
id|sb.revs-&gt;children.name
op_assign
l_string|&quot;children&quot;
suffix:semicolon
r_while
c_loop
(paren
id|c-&gt;parents
op_logical_and
id|oidcmp
c_func
(paren
op_amp
id|c-&gt;object.oid
comma
op_amp
id|sb.final-&gt;object.oid
)paren
)paren
(brace
r_struct
id|commit_list
op_star
id|l
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|l
)paren
)paren
suffix:semicolon
id|l-&gt;item
op_assign
id|c
suffix:semicolon
r_if
c_cond
(paren
id|add_decoration
c_func
(paren
op_amp
id|sb.revs-&gt;children
comma
op_amp
id|c-&gt;parents-&gt;item-&gt;object
comma
id|l
)paren
)paren
id|die
c_func
(paren
l_string|&quot;BUG: not unique item in first-parent chain&quot;
)paren
suffix:semicolon
id|c
op_assign
id|c-&gt;parents-&gt;item
suffix:semicolon
)brace
r_if
c_cond
(paren
id|oidcmp
c_func
(paren
op_amp
id|c-&gt;object.oid
comma
op_amp
id|sb.final-&gt;object.oid
)paren
)paren
id|die
c_func
(paren
l_string|&quot;--reverse --first-parent together require range along first-parent chain&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_null_oid
c_func
(paren
op_amp
id|sb.final-&gt;object.oid
)paren
)paren
(brace
id|o
op_assign
id|sb.final-&gt;util
suffix:semicolon
id|sb.final_buf
op_assign
id|xmemdupz
c_func
(paren
id|o-&gt;file.ptr
comma
id|o-&gt;file.size
)paren
suffix:semicolon
id|sb.final_buf_size
op_assign
id|o-&gt;file.size
suffix:semicolon
)brace
r_else
(brace
id|o
op_assign
id|get_origin
c_func
(paren
op_amp
id|sb
comma
id|sb.final
comma
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fill_blob_sha1_and_mode
c_func
(paren
id|o
)paren
)paren
id|die
c_func
(paren
l_string|&quot;no such path %s in %s&quot;
comma
id|path
comma
id|final_commit_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DIFF_OPT_TST
c_func
(paren
op_amp
id|sb.revs-&gt;diffopt
comma
id|ALLOW_TEXTCONV
)paren
op_logical_and
id|textconv_object
c_func
(paren
id|path
comma
id|o-&gt;mode
comma
id|o-&gt;blob_sha1
comma
l_int|1
comma
(paren
r_char
op_star
op_star
)paren
op_amp
id|sb.final_buf
comma
op_amp
id|sb.final_buf_size
)paren
)paren
suffix:semicolon
r_else
id|sb.final_buf
op_assign
id|read_sha1_file
c_func
(paren
id|o-&gt;blob_sha1
comma
op_amp
id|type
comma
op_amp
id|sb.final_buf_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sb.final_buf
)paren
id|die
c_func
(paren
l_string|&quot;Cannot read blob %s for path %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|o-&gt;blob_sha1
)paren
comma
id|path
)paren
suffix:semicolon
)brace
id|num_read_blob
op_increment
suffix:semicolon
id|lno
op_assign
id|prepare_lines
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lno
op_logical_and
op_logical_neg
id|range_list.nr
)paren
id|string_list_append
c_func
(paren
op_amp
id|range_list
comma
id|xstrdup
c_func
(paren
l_string|&quot;1&quot;
)paren
)paren
suffix:semicolon
id|anchor
op_assign
l_int|1
suffix:semicolon
id|range_set_init
c_func
(paren
op_amp
id|ranges
comma
id|range_list.nr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|range_i
op_assign
l_int|0
suffix:semicolon
id|range_i
OL
id|range_list.nr
suffix:semicolon
op_increment
id|range_i
)paren
(brace
r_int
id|bottom
comma
id|top
suffix:semicolon
r_if
c_cond
(paren
id|parse_range_arg
c_func
(paren
id|range_list.items
(braket
id|range_i
)braket
dot
id|string
comma
id|nth_line_cb
comma
op_amp
id|sb
comma
id|lno
comma
id|anchor
comma
op_amp
id|bottom
comma
op_amp
id|top
comma
id|sb.path
)paren
)paren
id|usage
c_func
(paren
id|blame_usage
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lno
OL
id|top
op_logical_or
(paren
(paren
id|lno
op_logical_or
id|bottom
)paren
op_logical_and
id|lno
OL
id|bottom
)paren
)paren
id|die
c_func
(paren
l_string|&quot;file %s has only %lu lines&quot;
comma
id|path
comma
id|lno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bottom
OL
l_int|1
)paren
id|bottom
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|top
OL
l_int|1
)paren
id|top
op_assign
id|lno
suffix:semicolon
id|bottom
op_decrement
suffix:semicolon
id|range_set_append_unsafe
c_func
(paren
op_amp
id|ranges
comma
id|bottom
comma
id|top
)paren
suffix:semicolon
id|anchor
op_assign
id|top
op_plus
l_int|1
suffix:semicolon
)brace
id|sort_and_merge_range_set
c_func
(paren
op_amp
id|ranges
)paren
suffix:semicolon
r_for
c_loop
(paren
id|range_i
op_assign
id|ranges.nr
suffix:semicolon
id|range_i
OG
l_int|0
suffix:semicolon
op_decrement
id|range_i
)paren
(brace
r_const
r_struct
id|range
op_star
id|r
op_assign
op_amp
id|ranges.ranges
(braket
id|range_i
l_int|1
)braket
suffix:semicolon
r_int
id|bottom
op_assign
id|r-&gt;start
suffix:semicolon
r_int
id|top
op_assign
id|r-&gt;end
suffix:semicolon
r_struct
id|blame_entry
op_star
id|next
op_assign
id|ent
suffix:semicolon
id|ent
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|ent
)paren
)paren
suffix:semicolon
id|ent-&gt;lno
op_assign
id|bottom
suffix:semicolon
id|ent-&gt;num_lines
op_assign
id|top
id|bottom
suffix:semicolon
id|ent-&gt;suspect
op_assign
id|o
suffix:semicolon
id|ent-&gt;s_lno
op_assign
id|bottom
suffix:semicolon
id|ent-&gt;next
op_assign
id|next
suffix:semicolon
id|origin_incref
c_func
(paren
id|o
)paren
suffix:semicolon
)brace
id|o-&gt;suspects
op_assign
id|ent
suffix:semicolon
id|prio_queue_put
c_func
(paren
op_amp
id|sb.commits
comma
id|o-&gt;commit
)paren
suffix:semicolon
id|origin_decref
c_func
(paren
id|o
)paren
suffix:semicolon
id|range_set_release
c_func
(paren
op_amp
id|ranges
)paren
suffix:semicolon
id|string_list_clear
c_func
(paren
op_amp
id|range_list
comma
l_int|0
)paren
suffix:semicolon
id|sb.ent
op_assign
l_int|NULL
suffix:semicolon
id|sb.path
op_assign
id|path
suffix:semicolon
id|read_mailmap
c_func
(paren
op_amp
id|mailmap
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|incremental
)paren
id|setup_pager
c_func
(paren
)paren
suffix:semicolon
id|assign_blame
c_func
(paren
op_amp
id|sb
comma
id|opt
)paren
suffix:semicolon
id|free
c_func
(paren
id|final_commit_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|incremental
)paren
r_return
l_int|0
suffix:semicolon
id|sb.ent
op_assign
id|blame_sort
c_func
(paren
id|sb.ent
comma
id|compare_blame_final
)paren
suffix:semicolon
id|coalesce
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|output_option
op_amp
id|OUTPUT_PORCELAIN
)paren
)paren
id|find_alignment
c_func
(paren
op_amp
id|sb
comma
op_amp
id|output_option
)paren
suffix:semicolon
id|output
c_func
(paren
op_amp
id|sb
comma
id|output_option
)paren
suffix:semicolon
id|free
c_func
(paren
(paren
r_void
op_star
)paren
id|sb.final_buf
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ent
op_assign
id|sb.ent
suffix:semicolon
id|ent
suffix:semicolon
)paren
(brace
r_struct
id|blame_entry
op_star
id|e
op_assign
id|ent-&gt;next
suffix:semicolon
id|free
c_func
(paren
id|ent
)paren
suffix:semicolon
id|ent
op_assign
id|e
suffix:semicolon
)brace
r_if
c_cond
(paren
id|show_stats
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;num read blob: %d&bslash;n&quot;
comma
id|num_read_blob
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;num get patch: %d&bslash;n&quot;
comma
id|num_get_patch
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;num commits: %d&bslash;n&quot;
comma
id|num_commits
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
