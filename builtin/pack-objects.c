macro_line|#include &quot;builtin.h&quot;
macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;attr.h&quot;
macro_line|#include &quot;object.h&quot;
macro_line|#include &quot;blob.h&quot;
macro_line|#include &quot;commit.h&quot;
macro_line|#include &quot;tag.h&quot;
macro_line|#include &quot;tree.h&quot;
macro_line|#include &quot;delta.h&quot;
macro_line|#include &quot;pack.h&quot;
macro_line|#include &quot;pack-revindex.h&quot;
macro_line|#include &quot;csum-file.h&quot;
macro_line|#include &quot;tree-walk.h&quot;
macro_line|#include &quot;diff.h&quot;
macro_line|#include &quot;revision.h&quot;
macro_line|#include &quot;list-objects.h&quot;
macro_line|#include &quot;pack-objects.h&quot;
macro_line|#include &quot;progress.h&quot;
macro_line|#include &quot;refs.h&quot;
macro_line|#include &quot;streaming.h&quot;
macro_line|#include &quot;thread-utils.h&quot;
macro_line|#include &quot;pack-bitmap.h&quot;
macro_line|#include &quot;reachable.h&quot;
macro_line|#include &quot;sha1-array.h&quot;
macro_line|#include &quot;argv-array.h&quot;
DECL|variable|pack_usage
r_static
r_const
r_char
op_star
id|pack_usage
(braket
)braket
op_assign
(brace
id|N_
c_func
(paren
l_string|&quot;git pack-objects --stdout [options...] [&lt; ref-list | &lt; object-list]&quot;
)paren
comma
id|N_
c_func
(paren
l_string|&quot;git pack-objects [options...] base-name [&lt; ref-list | &lt; object-list]&quot;
)paren
comma
l_int|NULL
)brace
suffix:semicolon
multiline_comment|/*&n; * Objects we are going to pack are collected in the `to_pack` structure.&n; * It contains an array (dynamically expanded) of the object data, and a map&n; * that can resolve SHA1s to their position in the array.&n; */
DECL|variable|to_pack
r_static
r_struct
id|packing_data
id|to_pack
suffix:semicolon
DECL|variable|written_list
r_static
r_struct
id|pack_idx_entry
op_star
op_star
id|written_list
suffix:semicolon
DECL|variable|nr_result
DECL|variable|nr_written
r_static
r_uint32
id|nr_result
comma
id|nr_written
suffix:semicolon
DECL|variable|non_empty
r_static
r_int
id|non_empty
suffix:semicolon
DECL|variable|reuse_delta
DECL|variable|reuse_object
r_static
r_int
id|reuse_delta
op_assign
l_int|1
comma
id|reuse_object
op_assign
l_int|1
suffix:semicolon
DECL|variable|keep_unreachable
DECL|variable|unpack_unreachable
DECL|variable|include_tag
r_static
r_int
id|keep_unreachable
comma
id|unpack_unreachable
comma
id|include_tag
suffix:semicolon
DECL|variable|unpack_unreachable_expiration
r_static
r_int
r_int
id|unpack_unreachable_expiration
suffix:semicolon
DECL|variable|local
r_static
r_int
id|local
suffix:semicolon
DECL|variable|incremental
r_static
r_int
id|incremental
suffix:semicolon
DECL|variable|ignore_packed_keep
r_static
r_int
id|ignore_packed_keep
suffix:semicolon
DECL|variable|allow_ofs_delta
r_static
r_int
id|allow_ofs_delta
suffix:semicolon
DECL|variable|pack_idx_opts
r_static
r_struct
id|pack_idx_option
id|pack_idx_opts
suffix:semicolon
DECL|variable|base_name
r_static
r_const
r_char
op_star
id|base_name
suffix:semicolon
DECL|variable|progress
r_static
r_int
id|progress
op_assign
l_int|1
suffix:semicolon
DECL|variable|window
r_static
r_int
id|window
op_assign
l_int|10
suffix:semicolon
DECL|variable|pack_size_limit
r_static
r_int
r_int
id|pack_size_limit
suffix:semicolon
DECL|variable|depth
r_static
r_int
id|depth
op_assign
l_int|50
suffix:semicolon
DECL|variable|delta_search_threads
r_static
r_int
id|delta_search_threads
suffix:semicolon
DECL|variable|pack_to_stdout
r_static
r_int
id|pack_to_stdout
suffix:semicolon
DECL|variable|num_preferred_base
r_static
r_int
id|num_preferred_base
suffix:semicolon
DECL|variable|progress_state
r_static
r_struct
id|progress
op_star
id|progress_state
suffix:semicolon
DECL|variable|pack_compression_level
r_static
r_int
id|pack_compression_level
op_assign
id|Z_DEFAULT_COMPRESSION
suffix:semicolon
DECL|variable|pack_compression_seen
r_static
r_int
id|pack_compression_seen
suffix:semicolon
DECL|variable|reuse_packfile
r_static
r_struct
id|packed_git
op_star
id|reuse_packfile
suffix:semicolon
DECL|variable|reuse_packfile_objects
r_static
r_uint32
id|reuse_packfile_objects
suffix:semicolon
DECL|variable|reuse_packfile_offset
r_static
id|off_t
id|reuse_packfile_offset
suffix:semicolon
DECL|variable|use_bitmap_index
r_static
r_int
id|use_bitmap_index
op_assign
l_int|1
suffix:semicolon
DECL|variable|write_bitmap_index
r_static
r_int
id|write_bitmap_index
suffix:semicolon
DECL|variable|write_bitmap_options
r_static
r_uint16
id|write_bitmap_options
suffix:semicolon
DECL|variable|delta_cache_size
r_static
r_int
r_int
id|delta_cache_size
op_assign
l_int|0
suffix:semicolon
DECL|variable|max_delta_cache_size
r_static
r_int
r_int
id|max_delta_cache_size
op_assign
l_int|256
op_star
l_int|1024
op_star
l_int|1024
suffix:semicolon
DECL|variable|cache_max_small_delta_size
r_static
r_int
r_int
id|cache_max_small_delta_size
op_assign
l_int|1000
suffix:semicolon
DECL|variable|window_memory_limit
r_static
r_int
r_int
id|window_memory_limit
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * stats&n; */
DECL|variable|written
DECL|variable|written_delta
r_static
r_uint32
id|written
comma
id|written_delta
suffix:semicolon
DECL|variable|reused
DECL|variable|reused_delta
r_static
r_uint32
id|reused
comma
id|reused_delta
suffix:semicolon
multiline_comment|/*&n; * Indexed commits&n; */
DECL|variable|indexed_commits
r_static
r_struct
id|commit
op_star
op_star
id|indexed_commits
suffix:semicolon
DECL|variable|indexed_commits_nr
r_static
r_int
r_int
id|indexed_commits_nr
suffix:semicolon
DECL|variable|indexed_commits_alloc
r_static
r_int
r_int
id|indexed_commits_alloc
suffix:semicolon
DECL|function|index_commit_for_bitmap
r_static
r_void
id|index_commit_for_bitmap
c_func
(paren
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_if
c_cond
(paren
id|indexed_commits_nr
op_ge
id|indexed_commits_alloc
)paren
(brace
id|indexed_commits_alloc
op_assign
(paren
id|indexed_commits_alloc
op_plus
l_int|32
)paren
op_star
l_int|2
suffix:semicolon
id|REALLOC_ARRAY
c_func
(paren
id|indexed_commits
comma
id|indexed_commits_alloc
)paren
suffix:semicolon
)brace
id|indexed_commits
(braket
id|indexed_commits_nr
op_increment
)braket
op_assign
id|commit
suffix:semicolon
)brace
DECL|function|get_delta
r_static
r_void
op_star
id|get_delta
c_func
(paren
r_struct
id|object_entry
op_star
id|entry
)paren
(brace
r_int
r_int
id|size
comma
id|base_size
comma
id|delta_size
suffix:semicolon
r_void
op_star
id|buf
comma
op_star
id|base_buf
comma
op_star
id|delta_buf
suffix:semicolon
r_enum
id|object_type
id|type
suffix:semicolon
id|buf
op_assign
id|read_sha1_file
c_func
(paren
id|entry-&gt;idx.sha1
comma
op_amp
id|type
comma
op_amp
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
id|die
c_func
(paren
l_string|&quot;unable to read %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|entry-&gt;idx.sha1
)paren
)paren
suffix:semicolon
id|base_buf
op_assign
id|read_sha1_file
c_func
(paren
id|entry-&gt;delta-&gt;idx.sha1
comma
op_amp
id|type
comma
op_amp
id|base_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|base_buf
)paren
id|die
c_func
(paren
l_string|&quot;unable to read %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|entry-&gt;delta-&gt;idx.sha1
)paren
)paren
suffix:semicolon
id|delta_buf
op_assign
id|diff_delta
c_func
(paren
id|base_buf
comma
id|base_size
comma
id|buf
comma
id|size
comma
op_amp
id|delta_size
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|delta_buf
op_logical_or
id|delta_size
op_ne
id|entry-&gt;delta_size
)paren
id|die
c_func
(paren
l_string|&quot;delta size changed&quot;
)paren
suffix:semicolon
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
id|free
c_func
(paren
id|base_buf
)paren
suffix:semicolon
r_return
id|delta_buf
suffix:semicolon
)brace
DECL|function|do_compress
r_static
r_int
r_int
id|do_compress
c_func
(paren
r_void
op_star
op_star
id|pptr
comma
r_int
r_int
id|size
)paren
(brace
id|git_zstream
id|stream
suffix:semicolon
r_void
op_star
id|in
comma
op_star
id|out
suffix:semicolon
r_int
r_int
id|maxsize
suffix:semicolon
id|git_deflate_init
c_func
(paren
op_amp
id|stream
comma
id|pack_compression_level
)paren
suffix:semicolon
id|maxsize
op_assign
id|git_deflate_bound
c_func
(paren
op_amp
id|stream
comma
id|size
)paren
suffix:semicolon
id|in
op_assign
op_star
id|pptr
suffix:semicolon
id|out
op_assign
id|xmalloc
c_func
(paren
id|maxsize
)paren
suffix:semicolon
op_star
id|pptr
op_assign
id|out
suffix:semicolon
id|stream.next_in
op_assign
id|in
suffix:semicolon
id|stream.avail_in
op_assign
id|size
suffix:semicolon
id|stream.next_out
op_assign
id|out
suffix:semicolon
id|stream.avail_out
op_assign
id|maxsize
suffix:semicolon
r_while
c_loop
(paren
id|git_deflate
c_func
(paren
op_amp
id|stream
comma
id|Z_FINISH
)paren
op_eq
id|Z_OK
)paren
suffix:semicolon
multiline_comment|/* nothing */
id|git_deflate_end
c_func
(paren
op_amp
id|stream
)paren
suffix:semicolon
id|free
c_func
(paren
id|in
)paren
suffix:semicolon
r_return
id|stream.total_out
suffix:semicolon
)brace
DECL|function|write_large_blob_data
r_static
r_int
r_int
id|write_large_blob_data
c_func
(paren
r_struct
id|git_istream
op_star
id|st
comma
r_struct
id|sha1file
op_star
id|f
comma
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
id|git_zstream
id|stream
suffix:semicolon
r_int
r_char
id|ibuf
(braket
l_int|1024
op_star
l_int|16
)braket
suffix:semicolon
r_int
r_char
id|obuf
(braket
l_int|1024
op_star
l_int|16
)braket
suffix:semicolon
r_int
r_int
id|olen
op_assign
l_int|0
suffix:semicolon
id|git_deflate_init
c_func
(paren
op_amp
id|stream
comma
id|pack_compression_level
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|ssize_t
id|readlen
suffix:semicolon
r_int
id|zret
op_assign
id|Z_OK
suffix:semicolon
id|readlen
op_assign
id|read_istream
c_func
(paren
id|st
comma
id|ibuf
comma
r_sizeof
(paren
id|ibuf
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|readlen
op_eq
l_int|1
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;unable to read %s&quot;
)paren
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
id|stream.next_in
op_assign
id|ibuf
suffix:semicolon
id|stream.avail_in
op_assign
id|readlen
suffix:semicolon
r_while
c_loop
(paren
(paren
id|stream.avail_in
op_logical_or
id|readlen
op_eq
l_int|0
)paren
op_logical_and
(paren
id|zret
op_eq
id|Z_OK
op_logical_or
id|zret
op_eq
id|Z_BUF_ERROR
)paren
)paren
(brace
id|stream.next_out
op_assign
id|obuf
suffix:semicolon
id|stream.avail_out
op_assign
r_sizeof
(paren
id|obuf
)paren
suffix:semicolon
id|zret
op_assign
id|git_deflate
c_func
(paren
op_amp
id|stream
comma
id|readlen
ques
c_cond
l_int|0
suffix:colon
id|Z_FINISH
)paren
suffix:semicolon
id|sha1write
c_func
(paren
id|f
comma
id|obuf
comma
id|stream.next_out
id|obuf
)paren
suffix:semicolon
id|olen
op_add_assign
id|stream.next_out
id|obuf
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stream.avail_in
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;deflate error (%d)&quot;
)paren
comma
id|zret
)paren
suffix:semicolon
r_if
c_cond
(paren
id|readlen
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|zret
op_ne
id|Z_STREAM_END
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;deflate error (%d)&quot;
)paren
comma
id|zret
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|git_deflate_end
c_func
(paren
op_amp
id|stream
)paren
suffix:semicolon
r_return
id|olen
suffix:semicolon
)brace
multiline_comment|/*&n; * we are going to reuse the existing object data as is.  make&n; * sure it is not corrupt.&n; */
DECL|function|check_pack_inflate
r_static
r_int
id|check_pack_inflate
c_func
(paren
r_struct
id|packed_git
op_star
id|p
comma
r_struct
id|pack_window
op_star
op_star
id|w_curs
comma
id|off_t
id|offset
comma
id|off_t
id|len
comma
r_int
r_int
id|expect
)paren
(brace
id|git_zstream
id|stream
suffix:semicolon
r_int
r_char
id|fakebuf
(braket
l_int|4096
)braket
comma
op_star
id|in
suffix:semicolon
r_int
id|st
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|stream
comma
l_int|0
comma
r_sizeof
(paren
id|stream
)paren
)paren
suffix:semicolon
id|git_inflate_init
c_func
(paren
op_amp
id|stream
)paren
suffix:semicolon
r_do
(brace
id|in
op_assign
id|use_pack
c_func
(paren
id|p
comma
id|w_curs
comma
id|offset
comma
op_amp
id|stream.avail_in
)paren
suffix:semicolon
id|stream.next_in
op_assign
id|in
suffix:semicolon
id|stream.next_out
op_assign
id|fakebuf
suffix:semicolon
id|stream.avail_out
op_assign
r_sizeof
(paren
id|fakebuf
)paren
suffix:semicolon
id|st
op_assign
id|git_inflate
c_func
(paren
op_amp
id|stream
comma
id|Z_FINISH
)paren
suffix:semicolon
id|offset
op_add_assign
id|stream.next_in
id|in
suffix:semicolon
)brace
r_while
c_loop
(paren
id|st
op_eq
id|Z_OK
op_logical_or
id|st
op_eq
id|Z_BUF_ERROR
)paren
suffix:semicolon
id|git_inflate_end
c_func
(paren
op_amp
id|stream
)paren
suffix:semicolon
r_return
(paren
id|st
op_eq
id|Z_STREAM_END
op_logical_and
id|stream.total_out
op_eq
id|expect
op_logical_and
id|stream.total_in
op_eq
id|len
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
)brace
DECL|function|copy_pack_data
r_static
r_void
id|copy_pack_data
c_func
(paren
r_struct
id|sha1file
op_star
id|f
comma
r_struct
id|packed_git
op_star
id|p
comma
r_struct
id|pack_window
op_star
op_star
id|w_curs
comma
id|off_t
id|offset
comma
id|off_t
id|len
)paren
(brace
r_int
r_char
op_star
id|in
suffix:semicolon
r_int
r_int
id|avail
suffix:semicolon
r_while
c_loop
(paren
id|len
)paren
(brace
id|in
op_assign
id|use_pack
c_func
(paren
id|p
comma
id|w_curs
comma
id|offset
comma
op_amp
id|avail
)paren
suffix:semicolon
r_if
c_cond
(paren
id|avail
OG
id|len
)paren
id|avail
op_assign
(paren
r_int
r_int
)paren
id|len
suffix:semicolon
id|sha1write
c_func
(paren
id|f
comma
id|in
comma
id|avail
)paren
suffix:semicolon
id|offset
op_add_assign
id|avail
suffix:semicolon
id|len
op_sub_assign
id|avail
suffix:semicolon
)brace
)brace
multiline_comment|/* Return 0 if we will bust the pack-size limit */
DECL|function|write_no_reuse_object
r_static
r_int
r_int
id|write_no_reuse_object
c_func
(paren
r_struct
id|sha1file
op_star
id|f
comma
r_struct
id|object_entry
op_star
id|entry
comma
r_int
r_int
id|limit
comma
r_int
id|usable_delta
)paren
(brace
r_int
r_int
id|size
comma
id|datalen
suffix:semicolon
r_int
r_char
id|header
(braket
l_int|10
)braket
comma
id|dheader
(braket
l_int|10
)braket
suffix:semicolon
r_int
id|hdrlen
suffix:semicolon
r_enum
id|object_type
id|type
suffix:semicolon
r_void
op_star
id|buf
suffix:semicolon
r_struct
id|git_istream
op_star
id|st
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|usable_delta
)paren
(brace
r_if
c_cond
(paren
id|entry-&gt;type
op_eq
id|OBJ_BLOB
op_logical_and
id|entry-&gt;size
OG
id|big_file_threshold
op_logical_and
(paren
id|st
op_assign
id|open_istream
c_func
(paren
id|entry-&gt;idx.sha1
comma
op_amp
id|type
comma
op_amp
id|size
comma
l_int|NULL
)paren
)paren
op_ne
l_int|NULL
)paren
id|buf
op_assign
l_int|NULL
suffix:semicolon
r_else
(brace
id|buf
op_assign
id|read_sha1_file
c_func
(paren
id|entry-&gt;idx.sha1
comma
op_amp
id|type
comma
op_amp
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;unable to read %s&quot;
)paren
comma
id|sha1_to_hex
c_func
(paren
id|entry-&gt;idx.sha1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * make sure no cached delta data remains from a&n;&t;&t; * previous attempt before a pack split occurred.&n;&t;&t; */
id|free
c_func
(paren
id|entry-&gt;delta_data
)paren
suffix:semicolon
id|entry-&gt;delta_data
op_assign
l_int|NULL
suffix:semicolon
id|entry-&gt;z_delta_size
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|entry-&gt;delta_data
)paren
(brace
id|size
op_assign
id|entry-&gt;delta_size
suffix:semicolon
id|buf
op_assign
id|entry-&gt;delta_data
suffix:semicolon
id|entry-&gt;delta_data
op_assign
l_int|NULL
suffix:semicolon
id|type
op_assign
(paren
id|allow_ofs_delta
op_logical_and
id|entry-&gt;delta-&gt;idx.offset
)paren
ques
c_cond
id|OBJ_OFS_DELTA
suffix:colon
id|OBJ_REF_DELTA
suffix:semicolon
)brace
r_else
(brace
id|buf
op_assign
id|get_delta
c_func
(paren
id|entry
)paren
suffix:semicolon
id|size
op_assign
id|entry-&gt;delta_size
suffix:semicolon
id|type
op_assign
(paren
id|allow_ofs_delta
op_logical_and
id|entry-&gt;delta-&gt;idx.offset
)paren
ques
c_cond
id|OBJ_OFS_DELTA
suffix:colon
id|OBJ_REF_DELTA
suffix:semicolon
)brace
r_if
c_cond
(paren
id|st
)paren
multiline_comment|/* large blob case, just assume we don&squot;t compress well */
id|datalen
op_assign
id|size
suffix:semicolon
r_else
r_if
c_cond
(paren
id|entry-&gt;z_delta_size
)paren
id|datalen
op_assign
id|entry-&gt;z_delta_size
suffix:semicolon
r_else
id|datalen
op_assign
id|do_compress
c_func
(paren
op_amp
id|buf
comma
id|size
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The object header is a byte of &squot;type&squot; followed by zero or&n;&t; * more bytes of length.&n;&t; */
id|hdrlen
op_assign
id|encode_in_pack_object_header
c_func
(paren
id|type
comma
id|size
comma
id|header
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|OBJ_OFS_DELTA
)paren
(brace
multiline_comment|/*&n;&t;&t; * Deltas with relative base contain an additional&n;&t;&t; * encoding of the relative offset for the delta&n;&t;&t; * base from this object&squot;s position in the pack.&n;&t;&t; */
id|off_t
id|ofs
op_assign
id|entry-&gt;idx.offset
id|entry-&gt;delta-&gt;idx.offset
suffix:semicolon
r_int
id|pos
op_assign
r_sizeof
(paren
id|dheader
)paren
l_int|1
suffix:semicolon
id|dheader
(braket
id|pos
)braket
op_assign
id|ofs
op_amp
l_int|127
suffix:semicolon
r_while
c_loop
(paren
id|ofs
op_rshift_assign
l_int|7
)paren
id|dheader
(braket
op_decrement
id|pos
)braket
op_assign
l_int|128
op_or
(paren
op_decrement
id|ofs
op_amp
l_int|127
)paren
suffix:semicolon
r_if
c_cond
(paren
id|limit
op_logical_and
id|hdrlen
op_plus
r_sizeof
(paren
id|dheader
)paren
id|pos
op_plus
id|datalen
op_plus
l_int|20
op_ge
id|limit
)paren
(brace
r_if
c_cond
(paren
id|st
)paren
id|close_istream
c_func
(paren
id|st
)paren
suffix:semicolon
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|sha1write
c_func
(paren
id|f
comma
id|header
comma
id|hdrlen
)paren
suffix:semicolon
id|sha1write
c_func
(paren
id|f
comma
id|dheader
op_plus
id|pos
comma
r_sizeof
(paren
id|dheader
)paren
id|pos
)paren
suffix:semicolon
id|hdrlen
op_add_assign
r_sizeof
(paren
id|dheader
)paren
id|pos
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|type
op_eq
id|OBJ_REF_DELTA
)paren
(brace
multiline_comment|/*&n;&t;&t; * Deltas with a base reference contain&n;&t;&t; * an additional 20 bytes for the base sha1.&n;&t;&t; */
r_if
c_cond
(paren
id|limit
op_logical_and
id|hdrlen
op_plus
l_int|20
op_plus
id|datalen
op_plus
l_int|20
op_ge
id|limit
)paren
(brace
r_if
c_cond
(paren
id|st
)paren
id|close_istream
c_func
(paren
id|st
)paren
suffix:semicolon
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|sha1write
c_func
(paren
id|f
comma
id|header
comma
id|hdrlen
)paren
suffix:semicolon
id|sha1write
c_func
(paren
id|f
comma
id|entry-&gt;delta-&gt;idx.sha1
comma
l_int|20
)paren
suffix:semicolon
id|hdrlen
op_add_assign
l_int|20
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|limit
op_logical_and
id|hdrlen
op_plus
id|datalen
op_plus
l_int|20
op_ge
id|limit
)paren
(brace
r_if
c_cond
(paren
id|st
)paren
id|close_istream
c_func
(paren
id|st
)paren
suffix:semicolon
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|sha1write
c_func
(paren
id|f
comma
id|header
comma
id|hdrlen
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|st
)paren
(brace
id|datalen
op_assign
id|write_large_blob_data
c_func
(paren
id|st
comma
id|f
comma
id|entry-&gt;idx.sha1
)paren
suffix:semicolon
id|close_istream
c_func
(paren
id|st
)paren
suffix:semicolon
)brace
r_else
(brace
id|sha1write
c_func
(paren
id|f
comma
id|buf
comma
id|datalen
)paren
suffix:semicolon
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
r_return
id|hdrlen
op_plus
id|datalen
suffix:semicolon
)brace
multiline_comment|/* Return 0 if we will bust the pack-size limit */
DECL|function|write_reuse_object
r_static
r_int
r_int
id|write_reuse_object
c_func
(paren
r_struct
id|sha1file
op_star
id|f
comma
r_struct
id|object_entry
op_star
id|entry
comma
r_int
r_int
id|limit
comma
r_int
id|usable_delta
)paren
(brace
r_struct
id|packed_git
op_star
id|p
op_assign
id|entry-&gt;in_pack
suffix:semicolon
r_struct
id|pack_window
op_star
id|w_curs
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|revindex_entry
op_star
id|revidx
suffix:semicolon
id|off_t
id|offset
suffix:semicolon
r_enum
id|object_type
id|type
op_assign
id|entry-&gt;type
suffix:semicolon
r_int
r_int
id|datalen
suffix:semicolon
r_int
r_char
id|header
(braket
l_int|10
)braket
comma
id|dheader
(braket
l_int|10
)braket
suffix:semicolon
r_int
id|hdrlen
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;delta
)paren
id|type
op_assign
(paren
id|allow_ofs_delta
op_logical_and
id|entry-&gt;delta-&gt;idx.offset
)paren
ques
c_cond
id|OBJ_OFS_DELTA
suffix:colon
id|OBJ_REF_DELTA
suffix:semicolon
id|hdrlen
op_assign
id|encode_in_pack_object_header
c_func
(paren
id|type
comma
id|entry-&gt;size
comma
id|header
)paren
suffix:semicolon
id|offset
op_assign
id|entry-&gt;in_pack_offset
suffix:semicolon
id|revidx
op_assign
id|find_pack_revindex
c_func
(paren
id|p
comma
id|offset
)paren
suffix:semicolon
id|datalen
op_assign
id|revidx
(braket
l_int|1
)braket
dot
id|offset
id|offset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pack_to_stdout
op_logical_and
id|p-&gt;index_version
OG
l_int|1
op_logical_and
id|check_pack_crc
c_func
(paren
id|p
comma
op_amp
id|w_curs
comma
id|offset
comma
id|datalen
comma
id|revidx-&gt;nr
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;bad packed object CRC for %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|entry-&gt;idx.sha1
)paren
)paren
suffix:semicolon
id|unuse_pack
c_func
(paren
op_amp
id|w_curs
)paren
suffix:semicolon
r_return
id|write_no_reuse_object
c_func
(paren
id|f
comma
id|entry
comma
id|limit
comma
id|usable_delta
)paren
suffix:semicolon
)brace
id|offset
op_add_assign
id|entry-&gt;in_pack_header_size
suffix:semicolon
id|datalen
op_sub_assign
id|entry-&gt;in_pack_header_size
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pack_to_stdout
op_logical_and
id|p-&gt;index_version
op_eq
l_int|1
op_logical_and
id|check_pack_inflate
c_func
(paren
id|p
comma
op_amp
id|w_curs
comma
id|offset
comma
id|datalen
comma
id|entry-&gt;size
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;corrupt packed object for %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|entry-&gt;idx.sha1
)paren
)paren
suffix:semicolon
id|unuse_pack
c_func
(paren
op_amp
id|w_curs
)paren
suffix:semicolon
r_return
id|write_no_reuse_object
c_func
(paren
id|f
comma
id|entry
comma
id|limit
comma
id|usable_delta
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|type
op_eq
id|OBJ_OFS_DELTA
)paren
(brace
id|off_t
id|ofs
op_assign
id|entry-&gt;idx.offset
id|entry-&gt;delta-&gt;idx.offset
suffix:semicolon
r_int
id|pos
op_assign
r_sizeof
(paren
id|dheader
)paren
l_int|1
suffix:semicolon
id|dheader
(braket
id|pos
)braket
op_assign
id|ofs
op_amp
l_int|127
suffix:semicolon
r_while
c_loop
(paren
id|ofs
op_rshift_assign
l_int|7
)paren
id|dheader
(braket
op_decrement
id|pos
)braket
op_assign
l_int|128
op_or
(paren
op_decrement
id|ofs
op_amp
l_int|127
)paren
suffix:semicolon
r_if
c_cond
(paren
id|limit
op_logical_and
id|hdrlen
op_plus
r_sizeof
(paren
id|dheader
)paren
id|pos
op_plus
id|datalen
op_plus
l_int|20
op_ge
id|limit
)paren
(brace
id|unuse_pack
c_func
(paren
op_amp
id|w_curs
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|sha1write
c_func
(paren
id|f
comma
id|header
comma
id|hdrlen
)paren
suffix:semicolon
id|sha1write
c_func
(paren
id|f
comma
id|dheader
op_plus
id|pos
comma
r_sizeof
(paren
id|dheader
)paren
id|pos
)paren
suffix:semicolon
id|hdrlen
op_add_assign
r_sizeof
(paren
id|dheader
)paren
id|pos
suffix:semicolon
id|reused_delta
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|type
op_eq
id|OBJ_REF_DELTA
)paren
(brace
r_if
c_cond
(paren
id|limit
op_logical_and
id|hdrlen
op_plus
l_int|20
op_plus
id|datalen
op_plus
l_int|20
op_ge
id|limit
)paren
(brace
id|unuse_pack
c_func
(paren
op_amp
id|w_curs
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|sha1write
c_func
(paren
id|f
comma
id|header
comma
id|hdrlen
)paren
suffix:semicolon
id|sha1write
c_func
(paren
id|f
comma
id|entry-&gt;delta-&gt;idx.sha1
comma
l_int|20
)paren
suffix:semicolon
id|hdrlen
op_add_assign
l_int|20
suffix:semicolon
id|reused_delta
op_increment
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|limit
op_logical_and
id|hdrlen
op_plus
id|datalen
op_plus
l_int|20
op_ge
id|limit
)paren
(brace
id|unuse_pack
c_func
(paren
op_amp
id|w_curs
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|sha1write
c_func
(paren
id|f
comma
id|header
comma
id|hdrlen
)paren
suffix:semicolon
)brace
id|copy_pack_data
c_func
(paren
id|f
comma
id|p
comma
op_amp
id|w_curs
comma
id|offset
comma
id|datalen
)paren
suffix:semicolon
id|unuse_pack
c_func
(paren
op_amp
id|w_curs
)paren
suffix:semicolon
id|reused
op_increment
suffix:semicolon
r_return
id|hdrlen
op_plus
id|datalen
suffix:semicolon
)brace
multiline_comment|/* Return 0 if we will bust the pack-size limit */
DECL|function|write_object
r_static
r_int
r_int
id|write_object
c_func
(paren
r_struct
id|sha1file
op_star
id|f
comma
r_struct
id|object_entry
op_star
id|entry
comma
id|off_t
id|write_offset
)paren
(brace
r_int
r_int
id|limit
comma
id|len
suffix:semicolon
r_int
id|usable_delta
comma
id|to_reuse
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pack_to_stdout
)paren
id|crc32_begin
c_func
(paren
id|f
)paren
suffix:semicolon
multiline_comment|/* apply size limit if limited packsize and not first object */
r_if
c_cond
(paren
op_logical_neg
id|pack_size_limit
op_logical_or
op_logical_neg
id|nr_written
)paren
id|limit
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|pack_size_limit
op_le
id|write_offset
)paren
multiline_comment|/*&n;&t;&t; * the earlier object did not fit the limit; avoid&n;&t;&t; * mistaking this with unlimited (i.e. limit = 0).&n;&t;&t; */
id|limit
op_assign
l_int|1
suffix:semicolon
r_else
id|limit
op_assign
id|pack_size_limit
id|write_offset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;delta
)paren
id|usable_delta
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* no delta */
r_else
r_if
c_cond
(paren
op_logical_neg
id|pack_size_limit
)paren
id|usable_delta
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* unlimited packfile */
r_else
r_if
c_cond
(paren
id|entry-&gt;delta-&gt;idx.offset
op_eq
(paren
id|off_t
)paren
op_minus
l_int|1
)paren
id|usable_delta
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* base was written to another pack */
r_else
r_if
c_cond
(paren
id|entry-&gt;delta-&gt;idx.offset
)paren
id|usable_delta
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* base already exists in this pack */
r_else
id|usable_delta
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* base could end up in another pack */
r_if
c_cond
(paren
op_logical_neg
id|reuse_object
)paren
id|to_reuse
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* explicit */
r_else
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;in_pack
)paren
id|to_reuse
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* can&squot;t reuse what we don&squot;t have */
r_else
r_if
c_cond
(paren
id|entry-&gt;type
op_eq
id|OBJ_REF_DELTA
op_logical_or
id|entry-&gt;type
op_eq
id|OBJ_OFS_DELTA
)paren
multiline_comment|/* check_object() decided it for us ... */
id|to_reuse
op_assign
id|usable_delta
suffix:semicolon
multiline_comment|/* ... but pack split may override that */
r_else
r_if
c_cond
(paren
id|entry-&gt;type
op_ne
id|entry-&gt;in_pack_type
)paren
id|to_reuse
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* pack has delta which is unusable */
r_else
r_if
c_cond
(paren
id|entry-&gt;delta
)paren
id|to_reuse
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* we want to pack afresh */
r_else
id|to_reuse
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* we have it in-pack undeltified,&n;&t;&t;&t;&t; * and we do not need to deltify it.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|to_reuse
)paren
id|len
op_assign
id|write_no_reuse_object
c_func
(paren
id|f
comma
id|entry
comma
id|limit
comma
id|usable_delta
)paren
suffix:semicolon
r_else
id|len
op_assign
id|write_reuse_object
c_func
(paren
id|f
comma
id|entry
comma
id|limit
comma
id|usable_delta
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|usable_delta
)paren
id|written_delta
op_increment
suffix:semicolon
id|written
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pack_to_stdout
)paren
id|entry-&gt;idx.crc32
op_assign
id|crc32_end
c_func
(paren
id|f
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
DECL|enum|write_one_status
r_enum
id|write_one_status
(brace
DECL|enumerator|WRITE_ONE_SKIP
id|WRITE_ONE_SKIP
op_assign
l_int|1
comma
multiline_comment|/* already written */
DECL|enumerator|WRITE_ONE_BREAK
id|WRITE_ONE_BREAK
op_assign
l_int|0
comma
multiline_comment|/* writing this will bust the limit; not written */
DECL|enumerator|WRITE_ONE_WRITTEN
id|WRITE_ONE_WRITTEN
op_assign
l_int|1
comma
multiline_comment|/* normal */
DECL|enumerator|WRITE_ONE_RECURSIVE
id|WRITE_ONE_RECURSIVE
op_assign
l_int|2
multiline_comment|/* already scheduled to be written */
)brace
suffix:semicolon
DECL|function|write_one
r_static
r_enum
id|write_one_status
id|write_one
c_func
(paren
r_struct
id|sha1file
op_star
id|f
comma
r_struct
id|object_entry
op_star
id|e
comma
id|off_t
op_star
id|offset
)paren
(brace
r_int
r_int
id|size
suffix:semicolon
r_int
id|recursing
suffix:semicolon
multiline_comment|/*&n;&t; * we set offset to 1 (which is an impossible value) to mark&n;&t; * the fact that this object is involved in &quot;write its base&n;&t; * first before writing a deltified object&quot; recursion.&n;&t; */
id|recursing
op_assign
(paren
id|e-&gt;idx.offset
op_eq
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|recursing
)paren
(brace
id|warning
c_func
(paren
l_string|&quot;recursive delta detected for object %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|e-&gt;idx.sha1
)paren
)paren
suffix:semicolon
r_return
id|WRITE_ONE_RECURSIVE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|e-&gt;idx.offset
op_logical_or
id|e-&gt;preferred_base
)paren
(brace
multiline_comment|/* offset is non zero if object is written already. */
r_return
id|WRITE_ONE_SKIP
suffix:semicolon
)brace
multiline_comment|/* if we are deltified, write out base object first. */
r_if
c_cond
(paren
id|e-&gt;delta
)paren
(brace
id|e-&gt;idx.offset
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* now recurse */
r_switch
c_cond
(paren
id|write_one
c_func
(paren
id|f
comma
id|e-&gt;delta
comma
id|offset
)paren
)paren
(brace
r_case
id|WRITE_ONE_RECURSIVE
suffix:colon
multiline_comment|/* we cannot depend on this one */
id|e-&gt;delta
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
r_case
id|WRITE_ONE_BREAK
suffix:colon
id|e-&gt;idx.offset
op_assign
id|recursing
suffix:semicolon
r_return
id|WRITE_ONE_BREAK
suffix:semicolon
)brace
)brace
id|e-&gt;idx.offset
op_assign
op_star
id|offset
suffix:semicolon
id|size
op_assign
id|write_object
c_func
(paren
id|f
comma
id|e
comma
op_star
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|size
)paren
(brace
id|e-&gt;idx.offset
op_assign
id|recursing
suffix:semicolon
r_return
id|WRITE_ONE_BREAK
suffix:semicolon
)brace
id|written_list
(braket
id|nr_written
op_increment
)braket
op_assign
op_amp
id|e-&gt;idx
suffix:semicolon
multiline_comment|/* make sure off_t is sufficiently large not to wrap */
r_if
c_cond
(paren
id|signed_add_overflows
c_func
(paren
op_star
id|offset
comma
id|size
)paren
)paren
id|die
c_func
(paren
l_string|&quot;pack too large for current definition of off_t&quot;
)paren
suffix:semicolon
op_star
id|offset
op_add_assign
id|size
suffix:semicolon
r_return
id|WRITE_ONE_WRITTEN
suffix:semicolon
)brace
DECL|function|mark_tagged
r_static
r_int
id|mark_tagged
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_const
r_struct
id|object_id
op_star
id|oid
comma
r_int
id|flag
comma
r_void
op_star
id|cb_data
)paren
(brace
r_int
r_char
id|peeled
(braket
l_int|20
)braket
suffix:semicolon
r_struct
id|object_entry
op_star
id|entry
op_assign
id|packlist_find
c_func
(paren
op_amp
id|to_pack
comma
id|oid-&gt;hash
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
)paren
id|entry-&gt;tagged
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|peel_ref
c_func
(paren
id|path
comma
id|peeled
)paren
)paren
(brace
id|entry
op_assign
id|packlist_find
c_func
(paren
op_amp
id|to_pack
comma
id|peeled
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
)paren
id|entry-&gt;tagged
op_assign
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|add_to_write_order
r_static
r_inline
r_void
id|add_to_write_order
c_func
(paren
r_struct
id|object_entry
op_star
op_star
id|wo
comma
r_int
r_int
op_star
id|endp
comma
r_struct
id|object_entry
op_star
id|e
)paren
(brace
r_if
c_cond
(paren
id|e-&gt;filled
)paren
r_return
suffix:semicolon
id|wo
(braket
(paren
op_star
id|endp
)paren
op_increment
)braket
op_assign
id|e
suffix:semicolon
id|e-&gt;filled
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|add_descendants_to_write_order
r_static
r_void
id|add_descendants_to_write_order
c_func
(paren
r_struct
id|object_entry
op_star
op_star
id|wo
comma
r_int
r_int
op_star
id|endp
comma
r_struct
id|object_entry
op_star
id|e
)paren
(brace
r_int
id|add_to_order
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|e
)paren
(brace
r_if
c_cond
(paren
id|add_to_order
)paren
(brace
r_struct
id|object_entry
op_star
id|s
suffix:semicolon
multiline_comment|/* add this node... */
id|add_to_write_order
c_func
(paren
id|wo
comma
id|endp
comma
id|e
)paren
suffix:semicolon
multiline_comment|/* all its siblings... */
r_for
c_loop
(paren
id|s
op_assign
id|e-&gt;delta_sibling
suffix:semicolon
id|s
suffix:semicolon
id|s
op_assign
id|s-&gt;delta_sibling
)paren
(brace
id|add_to_write_order
c_func
(paren
id|wo
comma
id|endp
comma
id|s
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* drop down a level to add left subtree nodes if possible */
r_if
c_cond
(paren
id|e-&gt;delta_child
)paren
(brace
id|add_to_order
op_assign
l_int|1
suffix:semicolon
id|e
op_assign
id|e-&gt;delta_child
suffix:semicolon
)brace
r_else
(brace
id|add_to_order
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* our sibling might have some children, it is next */
r_if
c_cond
(paren
id|e-&gt;delta_sibling
)paren
(brace
id|e
op_assign
id|e-&gt;delta_sibling
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* go back to our parent node */
id|e
op_assign
id|e-&gt;delta
suffix:semicolon
r_while
c_loop
(paren
id|e
op_logical_and
op_logical_neg
id|e-&gt;delta_sibling
)paren
(brace
multiline_comment|/* we&squot;re on the right side of a subtree, keep&n;&t;&t;&t;&t; * going up until we can go right again */
id|e
op_assign
id|e-&gt;delta
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|e
)paren
(brace
multiline_comment|/* done- we hit our original root node */
r_return
suffix:semicolon
)brace
multiline_comment|/* pass it off to sibling at this level */
id|e
op_assign
id|e-&gt;delta_sibling
suffix:semicolon
)brace
)brace
suffix:semicolon
)brace
DECL|function|add_family_to_write_order
r_static
r_void
id|add_family_to_write_order
c_func
(paren
r_struct
id|object_entry
op_star
op_star
id|wo
comma
r_int
r_int
op_star
id|endp
comma
r_struct
id|object_entry
op_star
id|e
)paren
(brace
r_struct
id|object_entry
op_star
id|root
suffix:semicolon
r_for
c_loop
(paren
id|root
op_assign
id|e
suffix:semicolon
id|root-&gt;delta
suffix:semicolon
id|root
op_assign
id|root-&gt;delta
)paren
suffix:semicolon
multiline_comment|/* nothing */
id|add_descendants_to_write_order
c_func
(paren
id|wo
comma
id|endp
comma
id|root
)paren
suffix:semicolon
)brace
DECL|function|compute_write_order
r_static
r_struct
id|object_entry
op_star
op_star
id|compute_write_order
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|i
comma
id|wo_end
comma
id|last_untagged
suffix:semicolon
r_struct
id|object_entry
op_star
op_star
id|wo
op_assign
id|xmalloc
c_func
(paren
id|to_pack.nr_objects
op_star
r_sizeof
(paren
op_star
id|wo
)paren
)paren
suffix:semicolon
r_struct
id|object_entry
op_star
id|objects
op_assign
id|to_pack.objects
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|to_pack.nr_objects
suffix:semicolon
id|i
op_increment
)paren
(brace
id|objects
(braket
id|i
)braket
dot
id|tagged
op_assign
l_int|0
suffix:semicolon
id|objects
(braket
id|i
)braket
dot
id|filled
op_assign
l_int|0
suffix:semicolon
id|objects
(braket
id|i
)braket
dot
id|delta_child
op_assign
l_int|NULL
suffix:semicolon
id|objects
(braket
id|i
)braket
dot
id|delta_sibling
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Fully connect delta_child/delta_sibling network.&n;&t; * Make sure delta_sibling is sorted in the original&n;&t; * recency order.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
id|to_pack.nr_objects
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
)paren
(brace
r_struct
id|object_entry
op_star
id|e
op_assign
op_amp
id|objects
(braket
op_decrement
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|e-&gt;delta
)paren
r_continue
suffix:semicolon
multiline_comment|/* Mark me as the first child */
id|e-&gt;delta_sibling
op_assign
id|e-&gt;delta-&gt;delta_child
suffix:semicolon
id|e-&gt;delta-&gt;delta_child
op_assign
id|e
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Mark objects that are at the tip of tags.&n;&t; */
id|for_each_tag_ref
c_func
(paren
id|mark_tagged
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Give the objects in the original recency order until&n;&t; * we see a tagged tip.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
id|wo_end
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|to_pack.nr_objects
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|objects
(braket
id|i
)braket
dot
id|tagged
)paren
r_break
suffix:semicolon
id|add_to_write_order
c_func
(paren
id|wo
comma
op_amp
id|wo_end
comma
op_amp
id|objects
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|last_untagged
op_assign
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * Then fill all the tagged tips.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
id|to_pack.nr_objects
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|objects
(braket
id|i
)braket
dot
id|tagged
)paren
id|add_to_write_order
c_func
(paren
id|wo
comma
op_amp
id|wo_end
comma
op_amp
id|objects
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * And then all remaining commits and tags.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
id|last_untagged
suffix:semicolon
id|i
OL
id|to_pack.nr_objects
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|objects
(braket
id|i
)braket
dot
id|type
op_ne
id|OBJ_COMMIT
op_logical_and
id|objects
(braket
id|i
)braket
dot
id|type
op_ne
id|OBJ_TAG
)paren
r_continue
suffix:semicolon
id|add_to_write_order
c_func
(paren
id|wo
comma
op_amp
id|wo_end
comma
op_amp
id|objects
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * And then all the trees.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
id|last_untagged
suffix:semicolon
id|i
OL
id|to_pack.nr_objects
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|objects
(braket
id|i
)braket
dot
id|type
op_ne
id|OBJ_TREE
)paren
r_continue
suffix:semicolon
id|add_to_write_order
c_func
(paren
id|wo
comma
op_amp
id|wo_end
comma
op_amp
id|objects
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Finally all the rest in really tight order&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
id|last_untagged
suffix:semicolon
id|i
OL
id|to_pack.nr_objects
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|objects
(braket
id|i
)braket
dot
id|filled
)paren
id|add_family_to_write_order
c_func
(paren
id|wo
comma
op_amp
id|wo_end
comma
op_amp
id|objects
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wo_end
op_ne
id|to_pack.nr_objects
)paren
id|die
c_func
(paren
l_string|&quot;ordered %u objects, expected %&quot;
id|PRIu32
comma
id|wo_end
comma
id|to_pack.nr_objects
)paren
suffix:semicolon
r_return
id|wo
suffix:semicolon
)brace
DECL|function|write_reused_pack
r_static
id|off_t
id|write_reused_pack
c_func
(paren
r_struct
id|sha1file
op_star
id|f
)paren
(brace
r_int
r_char
id|buffer
(braket
l_int|8192
)braket
suffix:semicolon
id|off_t
id|to_write
comma
id|total
suffix:semicolon
r_int
id|fd
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_pack_valid
c_func
(paren
id|reuse_packfile
)paren
)paren
id|die
c_func
(paren
l_string|&quot;packfile is invalid: %s&quot;
comma
id|reuse_packfile-&gt;pack_name
)paren
suffix:semicolon
id|fd
op_assign
id|git_open_noatime
c_func
(paren
id|reuse_packfile-&gt;pack_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
id|die_errno
c_func
(paren
l_string|&quot;unable to open packfile for reuse: %s&quot;
comma
id|reuse_packfile-&gt;pack_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lseek
c_func
(paren
id|fd
comma
r_sizeof
(paren
r_struct
id|pack_header
)paren
comma
id|SEEK_SET
)paren
op_eq
l_int|1
)paren
id|die_errno
c_func
(paren
l_string|&quot;unable to seek in reused packfile&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reuse_packfile_offset
OL
l_int|0
)paren
id|reuse_packfile_offset
op_assign
id|reuse_packfile-&gt;pack_size
l_int|20
suffix:semicolon
id|total
op_assign
id|to_write
op_assign
id|reuse_packfile_offset
r_sizeof
(paren
r_struct
id|pack_header
)paren
suffix:semicolon
r_while
c_loop
(paren
id|to_write
)paren
(brace
r_int
id|read_pack
op_assign
id|xread
c_func
(paren
id|fd
comma
id|buffer
comma
r_sizeof
(paren
id|buffer
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_pack
op_le
l_int|0
)paren
id|die_errno
c_func
(paren
l_string|&quot;unable to read from reused packfile&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_pack
OG
id|to_write
)paren
id|read_pack
op_assign
id|to_write
suffix:semicolon
id|sha1write
c_func
(paren
id|f
comma
id|buffer
comma
id|read_pack
)paren
suffix:semicolon
id|to_write
op_sub_assign
id|read_pack
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We don&squot;t know the actual number of objects written,&n;&t;&t; * only how many bytes written, how many bytes total, and&n;&t;&t; * how many objects total. So we can fake it by pretending all&n;&t;&t; * objects we are writing are the same size. This gives us a&n;&t;&t; * smooth progress meter, and at the end it matches the true&n;&t;&t; * answer.&n;&t;&t; */
id|written
op_assign
id|reuse_packfile_objects
op_star
(paren
(paren
(paren
r_float
)paren
(paren
id|total
id|to_write
)paren
)paren
op_div
id|total
)paren
suffix:semicolon
id|display_progress
c_func
(paren
id|progress_state
comma
id|written
)paren
suffix:semicolon
)brace
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
id|written
op_assign
id|reuse_packfile_objects
suffix:semicolon
id|display_progress
c_func
(paren
id|progress_state
comma
id|written
)paren
suffix:semicolon
r_return
id|reuse_packfile_offset
r_sizeof
(paren
r_struct
id|pack_header
)paren
suffix:semicolon
)brace
DECL|function|write_pack_file
r_static
r_void
id|write_pack_file
c_func
(paren
r_void
)paren
(brace
r_uint32
id|i
op_assign
l_int|0
comma
id|j
suffix:semicolon
r_struct
id|sha1file
op_star
id|f
suffix:semicolon
id|off_t
id|offset
suffix:semicolon
r_uint32
id|nr_remaining
op_assign
id|nr_result
suffix:semicolon
id|time_t
id|last_mtime
op_assign
l_int|0
suffix:semicolon
r_struct
id|object_entry
op_star
op_star
id|write_order
suffix:semicolon
r_if
c_cond
(paren
id|progress
OG
id|pack_to_stdout
)paren
id|progress_state
op_assign
id|start_progress
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Writing objects&quot;
)paren
comma
id|nr_result
)paren
suffix:semicolon
id|written_list
op_assign
id|xmalloc
c_func
(paren
id|to_pack.nr_objects
op_star
r_sizeof
(paren
op_star
id|written_list
)paren
)paren
suffix:semicolon
id|write_order
op_assign
id|compute_write_order
c_func
(paren
)paren
suffix:semicolon
r_do
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_char
op_star
id|pack_tmp_name
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|pack_to_stdout
)paren
id|f
op_assign
id|sha1fd_throughput
c_func
(paren
l_int|1
comma
l_string|&quot;&lt;stdout&gt;&quot;
comma
id|progress_state
)paren
suffix:semicolon
r_else
id|f
op_assign
id|create_tmp_packfile
c_func
(paren
op_amp
id|pack_tmp_name
)paren
suffix:semicolon
id|offset
op_assign
id|write_pack_header
c_func
(paren
id|f
comma
id|nr_remaining
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reuse_packfile
)paren
(brace
id|off_t
id|packfile_size
suffix:semicolon
m_assert
(paren
id|pack_to_stdout
)paren
suffix:semicolon
id|packfile_size
op_assign
id|write_reused_pack
c_func
(paren
id|f
)paren
suffix:semicolon
id|offset
op_add_assign
id|packfile_size
suffix:semicolon
)brace
id|nr_written
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
id|to_pack.nr_objects
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|object_entry
op_star
id|e
op_assign
id|write_order
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|write_one
c_func
(paren
id|f
comma
id|e
comma
op_amp
id|offset
)paren
op_eq
id|WRITE_ONE_BREAK
)paren
r_break
suffix:semicolon
id|display_progress
c_func
(paren
id|progress_state
comma
id|written
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Did we write the wrong # entries in the header?&n;&t;&t; * If so, rewrite it like in fast-import&n;&t;&t; */
r_if
c_cond
(paren
id|pack_to_stdout
)paren
(brace
id|sha1close
c_func
(paren
id|f
comma
id|sha1
comma
id|CSUM_CLOSE
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|nr_written
op_eq
id|nr_remaining
)paren
(brace
id|sha1close
c_func
(paren
id|f
comma
id|sha1
comma
id|CSUM_FSYNC
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|fd
op_assign
id|sha1close
c_func
(paren
id|f
comma
id|sha1
comma
l_int|0
)paren
suffix:semicolon
id|fixup_pack_header_footer
c_func
(paren
id|fd
comma
id|sha1
comma
id|pack_tmp_name
comma
id|nr_written
comma
id|sha1
comma
id|offset
)paren
suffix:semicolon
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
id|write_bitmap_index
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|pack_to_stdout
)paren
(brace
r_struct
id|stat
id|st
suffix:semicolon
r_struct
id|strbuf
id|tmpname
op_assign
id|STRBUF_INIT
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Packs are runtime accessed in their mtime&n;&t;&t;&t; * order since newer packs are more likely to contain&n;&t;&t;&t; * younger objects.  So if we are creating multiple&n;&t;&t;&t; * packs then we should modify the mtime of later ones&n;&t;&t;&t; * to preserve this property.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|stat
c_func
(paren
id|pack_tmp_name
comma
op_amp
id|st
)paren
OL
l_int|0
)paren
(brace
id|warning
c_func
(paren
l_string|&quot;failed to stat %s: %s&quot;
comma
id|pack_tmp_name
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|last_mtime
)paren
(brace
id|last_mtime
op_assign
id|st.st_mtime
suffix:semicolon
)brace
r_else
(brace
r_struct
id|utimbuf
id|utb
suffix:semicolon
id|utb.actime
op_assign
id|st.st_atime
suffix:semicolon
id|utb.modtime
op_assign
op_decrement
id|last_mtime
suffix:semicolon
r_if
c_cond
(paren
id|utime
c_func
(paren
id|pack_tmp_name
comma
op_amp
id|utb
)paren
OL
l_int|0
)paren
id|warning
c_func
(paren
l_string|&quot;failed utime() on %s: %s&quot;
comma
id|pack_tmp_name
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
)brace
id|strbuf_addf
c_func
(paren
op_amp
id|tmpname
comma
l_string|&quot;%s-&quot;
comma
id|base_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write_bitmap_index
)paren
(brace
id|bitmap_writer_set_checksum
c_func
(paren
id|sha1
)paren
suffix:semicolon
id|bitmap_writer_build_type_index
c_func
(paren
id|written_list
comma
id|nr_written
)paren
suffix:semicolon
)brace
id|finish_tmp_packfile
c_func
(paren
op_amp
id|tmpname
comma
id|pack_tmp_name
comma
id|written_list
comma
id|nr_written
comma
op_amp
id|pack_idx_opts
comma
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write_bitmap_index
)paren
(brace
id|strbuf_addf
c_func
(paren
op_amp
id|tmpname
comma
l_string|&quot;%s.bitmap&quot;
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
id|stop_progress
c_func
(paren
op_amp
id|progress_state
)paren
suffix:semicolon
id|bitmap_writer_show_progress
c_func
(paren
id|progress
)paren
suffix:semicolon
id|bitmap_writer_reuse_bitmaps
c_func
(paren
op_amp
id|to_pack
)paren
suffix:semicolon
id|bitmap_writer_select_commits
c_func
(paren
id|indexed_commits
comma
id|indexed_commits_nr
comma
l_int|1
)paren
suffix:semicolon
id|bitmap_writer_build
c_func
(paren
op_amp
id|to_pack
)paren
suffix:semicolon
id|bitmap_writer_finish
c_func
(paren
id|written_list
comma
id|nr_written
comma
id|tmpname.buf
comma
id|write_bitmap_options
)paren
suffix:semicolon
id|write_bitmap_index
op_assign
l_int|0
suffix:semicolon
)brace
id|strbuf_release
c_func
(paren
op_amp
id|tmpname
)paren
suffix:semicolon
id|free
c_func
(paren
id|pack_tmp_name
)paren
suffix:semicolon
id|puts
c_func
(paren
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* mark written objects as written to previous pack */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|nr_written
suffix:semicolon
id|j
op_increment
)paren
(brace
id|written_list
(braket
id|j
)braket
op_member_access_from_pointer
id|offset
op_assign
(paren
id|off_t
)paren
op_minus
l_int|1
suffix:semicolon
)brace
id|nr_remaining
op_sub_assign
id|nr_written
suffix:semicolon
)brace
r_while
c_loop
(paren
id|nr_remaining
op_logical_and
id|i
OL
id|to_pack.nr_objects
)paren
suffix:semicolon
id|free
c_func
(paren
id|written_list
)paren
suffix:semicolon
id|free
c_func
(paren
id|write_order
)paren
suffix:semicolon
id|stop_progress
c_func
(paren
op_amp
id|progress_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|written
op_ne
id|nr_result
)paren
id|die
c_func
(paren
l_string|&quot;wrote %&quot;
id|PRIu32
l_string|&quot; objects while expecting %&quot;
id|PRIu32
comma
id|written
comma
id|nr_result
)paren
suffix:semicolon
)brace
DECL|function|setup_delta_attr_check
r_static
r_void
id|setup_delta_attr_check
c_func
(paren
r_struct
id|git_attr_check
op_star
id|check
)paren
(brace
r_static
r_struct
id|git_attr
op_star
id|attr_delta
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|attr_delta
)paren
id|attr_delta
op_assign
id|git_attr
c_func
(paren
l_string|&quot;delta&quot;
)paren
suffix:semicolon
id|check
(braket
l_int|0
)braket
dot
id|attr
op_assign
id|attr_delta
suffix:semicolon
)brace
DECL|function|no_try_delta
r_static
r_int
id|no_try_delta
c_func
(paren
r_const
r_char
op_star
id|path
)paren
(brace
r_struct
id|git_attr_check
id|check
(braket
l_int|1
)braket
suffix:semicolon
id|setup_delta_attr_check
c_func
(paren
id|check
)paren
suffix:semicolon
r_if
c_cond
(paren
id|git_check_attr
c_func
(paren
id|path
comma
id|ARRAY_SIZE
c_func
(paren
id|check
)paren
comma
id|check
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ATTR_FALSE
c_func
(paren
id|check-&gt;value
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * When adding an object, check whether we have already added it&n; * to our packing list. If so, we can skip. However, if we are&n; * being asked to excludei t, but the previous mention was to include&n; * it, make sure to adjust its flags and tweak our numbers accordingly.&n; *&n; * As an optimization, we pass out the index position where we would have&n; * found the item, since that saves us from having to look it up again a&n; * few lines later when we want to add the new entry.&n; */
DECL|function|have_duplicate_entry
r_static
r_int
id|have_duplicate_entry
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
id|exclude
comma
r_uint32
op_star
id|index_pos
)paren
(brace
r_struct
id|object_entry
op_star
id|entry
suffix:semicolon
id|entry
op_assign
id|packlist_find
c_func
(paren
op_amp
id|to_pack
comma
id|sha1
comma
id|index_pos
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|exclude
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;preferred_base
)paren
id|nr_result
op_decrement
suffix:semicolon
id|entry-&gt;preferred_base
op_assign
l_int|1
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Check whether we want the object in the pack (e.g., we do not want&n; * objects found in non-local stores if the &quot;--local&quot; option was used).&n; *&n; * As a side effect of this check, we will find the packed version of this&n; * object, if any. We therefore pass out the pack information to avoid having&n; * to look it up again later.&n; */
DECL|function|want_object_in_pack
r_static
r_int
id|want_object_in_pack
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
id|exclude
comma
r_struct
id|packed_git
op_star
op_star
id|found_pack
comma
id|off_t
op_star
id|found_offset
)paren
(brace
r_struct
id|packed_git
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|exclude
op_logical_and
id|local
op_logical_and
id|has_loose_object_nonlocal
c_func
(paren
id|sha1
)paren
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|found_pack
op_assign
l_int|NULL
suffix:semicolon
op_star
id|found_offset
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|packed_git
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
id|off_t
id|offset
op_assign
id|find_pack_entry_one
c_func
(paren
id|sha1
comma
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|found_pack
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|is_pack_valid
c_func
(paren
id|p
)paren
)paren
r_continue
suffix:semicolon
op_star
id|found_offset
op_assign
id|offset
suffix:semicolon
op_star
id|found_pack
op_assign
id|p
suffix:semicolon
)brace
r_if
c_cond
(paren
id|exclude
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|incremental
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|local
op_logical_and
op_logical_neg
id|p-&gt;pack_local
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ignore_packed_keep
op_logical_and
id|p-&gt;pack_local
op_logical_and
id|p-&gt;pack_keep
)paren
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|create_object_entry
r_static
r_void
id|create_object_entry
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
comma
r_enum
id|object_type
id|type
comma
r_uint32
id|hash
comma
r_int
id|exclude
comma
r_int
id|no_try_delta
comma
r_uint32
id|index_pos
comma
r_struct
id|packed_git
op_star
id|found_pack
comma
id|off_t
id|found_offset
)paren
(brace
r_struct
id|object_entry
op_star
id|entry
suffix:semicolon
id|entry
op_assign
id|packlist_alloc
c_func
(paren
op_amp
id|to_pack
comma
id|sha1
comma
id|index_pos
)paren
suffix:semicolon
id|entry-&gt;hash
op_assign
id|hash
suffix:semicolon
r_if
c_cond
(paren
id|type
)paren
id|entry-&gt;type
op_assign
id|type
suffix:semicolon
r_if
c_cond
(paren
id|exclude
)paren
id|entry-&gt;preferred_base
op_assign
l_int|1
suffix:semicolon
r_else
id|nr_result
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|found_pack
)paren
(brace
id|entry-&gt;in_pack
op_assign
id|found_pack
suffix:semicolon
id|entry-&gt;in_pack_offset
op_assign
id|found_offset
suffix:semicolon
)brace
id|entry-&gt;no_try_delta
op_assign
id|no_try_delta
suffix:semicolon
)brace
DECL|variable|no_closure_warning
r_static
r_const
r_char
id|no_closure_warning
(braket
)braket
op_assign
id|N_
c_func
(paren
l_string|&quot;disabling bitmap writing, as some objects are not being packed&quot;
)paren
suffix:semicolon
DECL|function|add_object_entry
r_static
r_int
id|add_object_entry
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
comma
r_enum
id|object_type
id|type
comma
r_const
r_char
op_star
id|name
comma
r_int
id|exclude
)paren
(brace
r_struct
id|packed_git
op_star
id|found_pack
suffix:semicolon
id|off_t
id|found_offset
suffix:semicolon
r_uint32
id|index_pos
suffix:semicolon
r_if
c_cond
(paren
id|have_duplicate_entry
c_func
(paren
id|sha1
comma
id|exclude
comma
op_amp
id|index_pos
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|want_object_in_pack
c_func
(paren
id|sha1
comma
id|exclude
comma
op_amp
id|found_pack
comma
op_amp
id|found_offset
)paren
)paren
(brace
multiline_comment|/* The pack is missing an object, so it will not have closure */
r_if
c_cond
(paren
id|write_bitmap_index
)paren
(brace
id|warning
c_func
(paren
id|_
c_func
(paren
id|no_closure_warning
)paren
)paren
suffix:semicolon
id|write_bitmap_index
op_assign
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|create_object_entry
c_func
(paren
id|sha1
comma
id|type
comma
id|pack_name_hash
c_func
(paren
id|name
)paren
comma
id|exclude
comma
id|name
op_logical_and
id|no_try_delta
c_func
(paren
id|name
)paren
comma
id|index_pos
comma
id|found_pack
comma
id|found_offset
)paren
suffix:semicolon
id|display_progress
c_func
(paren
id|progress_state
comma
id|nr_result
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|add_object_entry_from_bitmap
r_static
r_int
id|add_object_entry_from_bitmap
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
comma
r_enum
id|object_type
id|type
comma
r_int
id|flags
comma
r_uint32
id|name_hash
comma
r_struct
id|packed_git
op_star
id|pack
comma
id|off_t
id|offset
)paren
(brace
r_uint32
id|index_pos
suffix:semicolon
r_if
c_cond
(paren
id|have_duplicate_entry
c_func
(paren
id|sha1
comma
l_int|0
comma
op_amp
id|index_pos
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|create_object_entry
c_func
(paren
id|sha1
comma
id|type
comma
id|name_hash
comma
l_int|0
comma
l_int|0
comma
id|index_pos
comma
id|pack
comma
id|offset
)paren
suffix:semicolon
id|display_progress
c_func
(paren
id|progress_state
comma
id|nr_result
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|struct|pbase_tree_cache
r_struct
id|pbase_tree_cache
(brace
DECL|member|sha1
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
DECL|member|ref
r_int
id|ref
suffix:semicolon
DECL|member|temporary
r_int
id|temporary
suffix:semicolon
DECL|member|tree_data
r_void
op_star
id|tree_data
suffix:semicolon
DECL|member|tree_size
r_int
r_int
id|tree_size
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|pbase_tree_cache
r_static
r_struct
id|pbase_tree_cache
op_star
(paren
id|pbase_tree_cache
(braket
l_int|256
)braket
)paren
suffix:semicolon
DECL|function|pbase_tree_cache_ix
r_static
r_int
id|pbase_tree_cache_ix
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_return
id|sha1
(braket
l_int|0
)braket
op_mod
id|ARRAY_SIZE
c_func
(paren
id|pbase_tree_cache
)paren
suffix:semicolon
)brace
DECL|function|pbase_tree_cache_ix_incr
r_static
r_int
id|pbase_tree_cache_ix_incr
c_func
(paren
r_int
id|ix
)paren
(brace
r_return
(paren
id|ix
op_plus
l_int|1
)paren
op_mod
id|ARRAY_SIZE
c_func
(paren
id|pbase_tree_cache
)paren
suffix:semicolon
)brace
DECL|struct|pbase_tree
r_static
r_struct
id|pbase_tree
(brace
DECL|member|next
r_struct
id|pbase_tree
op_star
id|next
suffix:semicolon
multiline_comment|/* This is a phony &quot;cache&quot; entry; we are not&n;&t; * going to evict it or find it through _get()&n;&t; * mechanism -- this is for the toplevel node that&n;&t; * would almost always change with any commit.&n;&t; */
DECL|member|pcache
r_struct
id|pbase_tree_cache
id|pcache
suffix:semicolon
DECL|variable|pbase_tree
)brace
op_star
id|pbase_tree
suffix:semicolon
DECL|function|pbase_tree_get
r_static
r_struct
id|pbase_tree_cache
op_star
id|pbase_tree_get
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_struct
id|pbase_tree_cache
op_star
id|ent
comma
op_star
id|nent
suffix:semicolon
r_void
op_star
id|data
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_enum
id|object_type
id|type
suffix:semicolon
r_int
id|neigh
suffix:semicolon
r_int
id|my_ix
op_assign
id|pbase_tree_cache_ix
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_int
id|available_ix
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* pbase-tree-cache acts as a limited hashtable.&n;&t; * your object will be found at your index or within a few&n;&t; * slots after that slot if it is cached.&n;&t; */
r_for
c_loop
(paren
id|neigh
op_assign
l_int|0
suffix:semicolon
id|neigh
OL
l_int|8
suffix:semicolon
id|neigh
op_increment
)paren
(brace
id|ent
op_assign
id|pbase_tree_cache
(braket
id|my_ix
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ent
op_logical_and
op_logical_neg
id|hashcmp
c_func
(paren
id|ent-&gt;sha1
comma
id|sha1
)paren
)paren
(brace
id|ent-&gt;ref
op_increment
suffix:semicolon
r_return
id|ent
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
(paren
id|available_ix
OL
l_int|0
)paren
op_logical_and
(paren
op_logical_neg
id|ent
op_logical_or
op_logical_neg
id|ent-&gt;ref
)paren
)paren
op_logical_or
(paren
(paren
l_int|0
op_le
id|available_ix
)paren
op_logical_and
(paren
op_logical_neg
id|ent
op_logical_and
id|pbase_tree_cache
(braket
id|available_ix
)braket
)paren
)paren
)paren
id|available_ix
op_assign
id|my_ix
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ent
)paren
r_break
suffix:semicolon
id|my_ix
op_assign
id|pbase_tree_cache_ix_incr
c_func
(paren
id|my_ix
)paren
suffix:semicolon
)brace
multiline_comment|/* Did not find one.  Either we got a bogus request or&n;&t; * we need to read and perhaps cache.&n;&t; */
id|data
op_assign
id|read_sha1_file
c_func
(paren
id|sha1
comma
op_amp
id|type
comma
op_amp
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
id|OBJ_TREE
)paren
(brace
id|free
c_func
(paren
id|data
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* We need to either cache or return a throwaway copy */
r_if
c_cond
(paren
id|available_ix
OL
l_int|0
)paren
id|ent
op_assign
l_int|NULL
suffix:semicolon
r_else
(brace
id|ent
op_assign
id|pbase_tree_cache
(braket
id|available_ix
)braket
suffix:semicolon
id|my_ix
op_assign
id|available_ix
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ent
)paren
(brace
id|nent
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|nent
)paren
)paren
suffix:semicolon
id|nent-&gt;temporary
op_assign
(paren
id|available_ix
OL
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* evict and reuse */
id|free
c_func
(paren
id|ent-&gt;tree_data
)paren
suffix:semicolon
id|nent
op_assign
id|ent
suffix:semicolon
)brace
id|hashcpy
c_func
(paren
id|nent-&gt;sha1
comma
id|sha1
)paren
suffix:semicolon
id|nent-&gt;tree_data
op_assign
id|data
suffix:semicolon
id|nent-&gt;tree_size
op_assign
id|size
suffix:semicolon
id|nent-&gt;ref
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nent-&gt;temporary
)paren
id|pbase_tree_cache
(braket
id|my_ix
)braket
op_assign
id|nent
suffix:semicolon
r_return
id|nent
suffix:semicolon
)brace
DECL|function|pbase_tree_put
r_static
r_void
id|pbase_tree_put
c_func
(paren
r_struct
id|pbase_tree_cache
op_star
id|cache
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cache-&gt;temporary
)paren
(brace
id|cache-&gt;ref
op_decrement
suffix:semicolon
r_return
suffix:semicolon
)brace
id|free
c_func
(paren
id|cache-&gt;tree_data
)paren
suffix:semicolon
id|free
c_func
(paren
id|cache
)paren
suffix:semicolon
)brace
DECL|function|name_cmp_len
r_static
r_int
id|name_cmp_len
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|name
(braket
id|i
)braket
op_logical_and
id|name
(braket
id|i
)braket
op_ne
l_char|&squot;&bslash;n&squot;
op_logical_and
id|name
(braket
id|i
)braket
op_ne
l_char|&squot;/&squot;
suffix:semicolon
id|i
op_increment
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
DECL|function|add_pbase_object
r_static
r_void
id|add_pbase_object
c_func
(paren
r_struct
id|tree_desc
op_star
id|tree
comma
r_const
r_char
op_star
id|name
comma
r_int
id|cmplen
comma
r_const
r_char
op_star
id|fullname
)paren
(brace
r_struct
id|name_entry
id|entry
suffix:semicolon
r_int
id|cmp
suffix:semicolon
r_while
c_loop
(paren
id|tree_entry
c_func
(paren
id|tree
comma
op_amp
id|entry
)paren
)paren
(brace
r_if
c_cond
(paren
id|S_ISGITLINK
c_func
(paren
id|entry.mode
)paren
)paren
r_continue
suffix:semicolon
id|cmp
op_assign
id|tree_entry_len
c_func
(paren
op_amp
id|entry
)paren
op_ne
id|cmplen
ques
c_cond
l_int|1
suffix:colon
id|memcmp
c_func
(paren
id|name
comma
id|entry.path
comma
id|cmplen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmp
OG
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|cmp
OL
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|name
(braket
id|cmplen
)braket
op_ne
l_char|&squot;/&squot;
)paren
(brace
id|add_object_entry
c_func
(paren
id|entry.sha1
comma
id|object_type
c_func
(paren
id|entry.mode
)paren
comma
id|fullname
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|entry.mode
)paren
)paren
(brace
r_struct
id|tree_desc
id|sub
suffix:semicolon
r_struct
id|pbase_tree_cache
op_star
id|tree
suffix:semicolon
r_const
r_char
op_star
id|down
op_assign
id|name
op_plus
id|cmplen
op_plus
l_int|1
suffix:semicolon
r_int
id|downlen
op_assign
id|name_cmp_len
c_func
(paren
id|down
)paren
suffix:semicolon
id|tree
op_assign
id|pbase_tree_get
c_func
(paren
id|entry.sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tree
)paren
r_return
suffix:semicolon
id|init_tree_desc
c_func
(paren
op_amp
id|sub
comma
id|tree-&gt;tree_data
comma
id|tree-&gt;tree_size
)paren
suffix:semicolon
id|add_pbase_object
c_func
(paren
op_amp
id|sub
comma
id|down
comma
id|downlen
comma
id|fullname
)paren
suffix:semicolon
id|pbase_tree_put
c_func
(paren
id|tree
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|variable|done_pbase_paths
r_static
r_int
op_star
id|done_pbase_paths
suffix:semicolon
DECL|variable|done_pbase_paths_num
r_static
r_int
id|done_pbase_paths_num
suffix:semicolon
DECL|variable|done_pbase_paths_alloc
r_static
r_int
id|done_pbase_paths_alloc
suffix:semicolon
DECL|function|done_pbase_path_pos
r_static
r_int
id|done_pbase_path_pos
c_func
(paren
r_int
id|hash
)paren
(brace
r_int
id|lo
op_assign
l_int|0
suffix:semicolon
r_int
id|hi
op_assign
id|done_pbase_paths_num
suffix:semicolon
r_while
c_loop
(paren
id|lo
OL
id|hi
)paren
(brace
r_int
id|mi
op_assign
(paren
id|hi
op_plus
id|lo
)paren
op_div
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|done_pbase_paths
(braket
id|mi
)braket
op_eq
id|hash
)paren
r_return
id|mi
suffix:semicolon
r_if
c_cond
(paren
id|done_pbase_paths
(braket
id|mi
)braket
OL
id|hash
)paren
id|hi
op_assign
id|mi
suffix:semicolon
r_else
id|lo
op_assign
id|mi
op_plus
l_int|1
suffix:semicolon
)brace
r_return
id|lo
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|check_pbase_path
r_static
r_int
id|check_pbase_path
c_func
(paren
r_int
id|hash
)paren
(brace
r_int
id|pos
op_assign
(paren
op_logical_neg
id|done_pbase_paths
)paren
ques
c_cond
l_int|1
suffix:colon
id|done_pbase_path_pos
c_func
(paren
id|hash
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_le
id|pos
)paren
r_return
l_int|1
suffix:semicolon
id|pos
op_assign
id|pos
l_int|1
suffix:semicolon
id|ALLOC_GROW
c_func
(paren
id|done_pbase_paths
comma
id|done_pbase_paths_num
op_plus
l_int|1
comma
id|done_pbase_paths_alloc
)paren
suffix:semicolon
id|done_pbase_paths_num
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
id|done_pbase_paths_num
)paren
id|memmove
c_func
(paren
id|done_pbase_paths
op_plus
id|pos
op_plus
l_int|1
comma
id|done_pbase_paths
op_plus
id|pos
comma
(paren
id|done_pbase_paths_num
id|pos
l_int|1
)paren
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
id|done_pbase_paths
(braket
id|pos
)braket
op_assign
id|hash
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|add_preferred_base_object
r_static
r_void
id|add_preferred_base_object
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|pbase_tree
op_star
id|it
suffix:semicolon
r_int
id|cmplen
suffix:semicolon
r_int
id|hash
op_assign
id|pack_name_hash
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|num_preferred_base
op_logical_or
id|check_pbase_path
c_func
(paren
id|hash
)paren
)paren
r_return
suffix:semicolon
id|cmplen
op_assign
id|name_cmp_len
c_func
(paren
id|name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|it
op_assign
id|pbase_tree
suffix:semicolon
id|it
suffix:semicolon
id|it
op_assign
id|it-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|cmplen
op_eq
l_int|0
)paren
(brace
id|add_object_entry
c_func
(paren
id|it-&gt;pcache.sha1
comma
id|OBJ_TREE
comma
l_int|NULL
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|tree_desc
id|tree
suffix:semicolon
id|init_tree_desc
c_func
(paren
op_amp
id|tree
comma
id|it-&gt;pcache.tree_data
comma
id|it-&gt;pcache.tree_size
)paren
suffix:semicolon
id|add_pbase_object
c_func
(paren
op_amp
id|tree
comma
id|name
comma
id|cmplen
comma
id|name
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|add_preferred_base
r_static
r_void
id|add_preferred_base
c_func
(paren
r_int
r_char
op_star
id|sha1
)paren
(brace
r_struct
id|pbase_tree
op_star
id|it
suffix:semicolon
r_void
op_star
id|data
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_int
r_char
id|tree_sha1
(braket
l_int|20
)braket
suffix:semicolon
r_if
c_cond
(paren
id|window
op_le
id|num_preferred_base
op_increment
)paren
r_return
suffix:semicolon
id|data
op_assign
id|read_object_with_reference
c_func
(paren
id|sha1
comma
id|tree_type
comma
op_amp
id|size
comma
id|tree_sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|it
op_assign
id|pbase_tree
suffix:semicolon
id|it
suffix:semicolon
id|it
op_assign
id|it-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|hashcmp
c_func
(paren
id|it-&gt;pcache.sha1
comma
id|tree_sha1
)paren
)paren
(brace
id|free
c_func
(paren
id|data
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|it
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|it
)paren
)paren
suffix:semicolon
id|it-&gt;next
op_assign
id|pbase_tree
suffix:semicolon
id|pbase_tree
op_assign
id|it
suffix:semicolon
id|hashcpy
c_func
(paren
id|it-&gt;pcache.sha1
comma
id|tree_sha1
)paren
suffix:semicolon
id|it-&gt;pcache.tree_data
op_assign
id|data
suffix:semicolon
id|it-&gt;pcache.tree_size
op_assign
id|size
suffix:semicolon
)brace
DECL|function|cleanup_preferred_base
r_static
r_void
id|cleanup_preferred_base
c_func
(paren
r_void
)paren
(brace
r_struct
id|pbase_tree
op_star
id|it
suffix:semicolon
r_int
id|i
suffix:semicolon
id|it
op_assign
id|pbase_tree
suffix:semicolon
id|pbase_tree
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|it
)paren
(brace
r_struct
id|pbase_tree
op_star
id|this
op_assign
id|it
suffix:semicolon
id|it
op_assign
id|this-&gt;next
suffix:semicolon
id|free
c_func
(paren
id|this-&gt;pcache.tree_data
)paren
suffix:semicolon
id|free
c_func
(paren
id|this
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|pbase_tree_cache
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pbase_tree_cache
(braket
id|i
)braket
)paren
r_continue
suffix:semicolon
id|free
c_func
(paren
id|pbase_tree_cache
(braket
id|i
)braket
op_member_access_from_pointer
id|tree_data
)paren
suffix:semicolon
id|free
c_func
(paren
id|pbase_tree_cache
(braket
id|i
)braket
)paren
suffix:semicolon
id|pbase_tree_cache
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
id|free
c_func
(paren
id|done_pbase_paths
)paren
suffix:semicolon
id|done_pbase_paths
op_assign
l_int|NULL
suffix:semicolon
id|done_pbase_paths_num
op_assign
id|done_pbase_paths_alloc
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|check_object
r_static
r_void
id|check_object
c_func
(paren
r_struct
id|object_entry
op_star
id|entry
)paren
(brace
r_if
c_cond
(paren
id|entry-&gt;in_pack
)paren
(brace
r_struct
id|packed_git
op_star
id|p
op_assign
id|entry-&gt;in_pack
suffix:semicolon
r_struct
id|pack_window
op_star
id|w_curs
op_assign
l_int|NULL
suffix:semicolon
r_const
r_int
r_char
op_star
id|base_ref
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|object_entry
op_star
id|base_entry
suffix:semicolon
r_int
r_int
id|used
comma
id|used_0
suffix:semicolon
r_int
r_int
id|avail
suffix:semicolon
id|off_t
id|ofs
suffix:semicolon
r_int
r_char
op_star
id|buf
comma
id|c
suffix:semicolon
id|buf
op_assign
id|use_pack
c_func
(paren
id|p
comma
op_amp
id|w_curs
comma
id|entry-&gt;in_pack_offset
comma
op_amp
id|avail
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We want in_pack_type even if we do not reuse delta&n;&t;&t; * since non-delta representations could still be reused.&n;&t;&t; */
id|used
op_assign
id|unpack_object_header_buffer
c_func
(paren
id|buf
comma
id|avail
comma
op_amp
id|entry-&gt;in_pack_type
comma
op_amp
id|entry-&gt;size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|used
op_eq
l_int|0
)paren
r_goto
id|give_up
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Determine if this is a delta and if so whether we can&n;&t;&t; * reuse it or not.  Otherwise let&squot;s find out as cheaply as&n;&t;&t; * possible what the actual type and size for this object is.&n;&t;&t; */
r_switch
c_cond
(paren
id|entry-&gt;in_pack_type
)paren
(brace
r_default
suffix:colon
multiline_comment|/* Not a delta hence we&squot;ve already got all we need. */
id|entry-&gt;type
op_assign
id|entry-&gt;in_pack_type
suffix:semicolon
id|entry-&gt;in_pack_header_size
op_assign
id|used
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;type
template_param
id|OBJ_BLOB
)paren
r_goto
id|give_up
suffix:semicolon
id|unuse_pack
c_func
(paren
op_amp
id|w_curs
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|OBJ_REF_DELTA
suffix:colon
r_if
c_cond
(paren
id|reuse_delta
op_logical_and
op_logical_neg
id|entry-&gt;preferred_base
)paren
id|base_ref
op_assign
id|use_pack
c_func
(paren
id|p
comma
op_amp
id|w_curs
comma
id|entry-&gt;in_pack_offset
op_plus
id|used
comma
l_int|NULL
)paren
suffix:semicolon
id|entry-&gt;in_pack_header_size
op_assign
id|used
op_plus
l_int|20
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OBJ_OFS_DELTA
suffix:colon
id|buf
op_assign
id|use_pack
c_func
(paren
id|p
comma
op_amp
id|w_curs
comma
id|entry-&gt;in_pack_offset
op_plus
id|used
comma
l_int|NULL
)paren
suffix:semicolon
id|used_0
op_assign
l_int|0
suffix:semicolon
id|c
op_assign
id|buf
(braket
id|used_0
op_increment
)braket
suffix:semicolon
id|ofs
op_assign
id|c
op_amp
l_int|127
suffix:semicolon
r_while
c_loop
(paren
id|c
op_amp
l_int|128
)paren
(brace
id|ofs
op_add_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ofs
op_logical_or
id|MSB
c_func
(paren
id|ofs
comma
l_int|7
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;delta base offset overflow in pack for %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|entry-&gt;idx.sha1
)paren
)paren
suffix:semicolon
r_goto
id|give_up
suffix:semicolon
)brace
id|c
op_assign
id|buf
(braket
id|used_0
op_increment
)braket
suffix:semicolon
id|ofs
op_assign
(paren
id|ofs
op_lshift
l_int|7
)paren
op_plus
(paren
id|c
op_amp
l_int|127
)paren
suffix:semicolon
)brace
id|ofs
op_assign
id|entry-&gt;in_pack_offset
id|ofs
suffix:semicolon
r_if
c_cond
(paren
id|ofs
op_le
l_int|0
op_logical_or
id|ofs
op_ge
id|entry-&gt;in_pack_offset
)paren
(brace
id|error
c_func
(paren
l_string|&quot;delta base offset out of bound for %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|entry-&gt;idx.sha1
)paren
)paren
suffix:semicolon
r_goto
id|give_up
suffix:semicolon
)brace
r_if
c_cond
(paren
id|reuse_delta
op_logical_and
op_logical_neg
id|entry-&gt;preferred_base
)paren
(brace
r_struct
id|revindex_entry
op_star
id|revidx
suffix:semicolon
id|revidx
op_assign
id|find_pack_revindex
c_func
(paren
id|p
comma
id|ofs
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|revidx
)paren
r_goto
id|give_up
suffix:semicolon
id|base_ref
op_assign
id|nth_packed_object_sha1
c_func
(paren
id|p
comma
id|revidx-&gt;nr
)paren
suffix:semicolon
)brace
id|entry-&gt;in_pack_header_size
op_assign
id|used
op_plus
id|used_0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|base_ref
op_logical_and
(paren
id|base_entry
op_assign
id|packlist_find
c_func
(paren
op_amp
id|to_pack
comma
id|base_ref
comma
l_int|NULL
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If base_ref was set above that means we wish to&n;&t;&t;&t; * reuse delta data, and we even found that base&n;&t;&t;&t; * in the list of objects we want to pack. Goodie!&n;&t;&t;&t; *&n;&t;&t;&t; * Depth value does not matter - find_deltas() will&n;&t;&t;&t; * never consider reused delta as the base object to&n;&t;&t;&t; * deltify other objects against, in order to avoid&n;&t;&t;&t; * circular deltas.&n;&t;&t;&t; */
id|entry-&gt;type
op_assign
id|entry-&gt;in_pack_type
suffix:semicolon
id|entry-&gt;delta
op_assign
id|base_entry
suffix:semicolon
id|entry-&gt;delta_size
op_assign
id|entry-&gt;size
suffix:semicolon
id|entry-&gt;delta_sibling
op_assign
id|base_entry-&gt;delta_child
suffix:semicolon
id|base_entry-&gt;delta_child
op_assign
id|entry
suffix:semicolon
id|unuse_pack
c_func
(paren
op_amp
id|w_curs
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|entry-&gt;type
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * This must be a delta and we already know what the&n;&t;&t;&t; * final object type is.  Let&squot;s extract the actual&n;&t;&t;&t; * object size from the delta header.&n;&t;&t;&t; */
id|entry-&gt;size
op_assign
id|get_size_from_delta
c_func
(paren
id|p
comma
op_amp
id|w_curs
comma
id|entry-&gt;in_pack_offset
op_plus
id|entry-&gt;in_pack_header_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;size
op_eq
l_int|0
)paren
r_goto
id|give_up
suffix:semicolon
id|unuse_pack
c_func
(paren
op_amp
id|w_curs
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * No choice but to fall back to the recursive delta walk&n;&t;&t; * with sha1_object_info() to find about the object type&n;&t;&t; * at this point...&n;&t;&t; */
id|give_up
suffix:colon
id|unuse_pack
c_func
(paren
op_amp
id|w_curs
)paren
suffix:semicolon
)brace
id|entry-&gt;type
op_assign
id|sha1_object_info
c_func
(paren
id|entry-&gt;idx.sha1
comma
op_amp
id|entry-&gt;size
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The error condition is checked in prepare_pack().  This is&n;&t; * to permit a missing preferred base object to be ignored&n;&t; * as a preferred base.  Doing so can result in a larger&n;&t; * pack file, but the transfer will still take place.&n;&t; */
)brace
DECL|function|pack_offset_sort
r_static
r_int
id|pack_offset_sort
c_func
(paren
r_const
r_void
op_star
id|_a
comma
r_const
r_void
op_star
id|_b
)paren
(brace
r_const
r_struct
id|object_entry
op_star
id|a
op_assign
op_star
(paren
r_struct
id|object_entry
op_star
op_star
)paren
id|_a
suffix:semicolon
r_const
r_struct
id|object_entry
op_star
id|b
op_assign
op_star
(paren
r_struct
id|object_entry
op_star
op_star
)paren
id|_b
suffix:semicolon
multiline_comment|/* avoid filesystem trashing with loose objects */
r_if
c_cond
(paren
op_logical_neg
id|a-&gt;in_pack
op_logical_and
op_logical_neg
id|b-&gt;in_pack
)paren
r_return
id|hashcmp
c_func
(paren
id|a-&gt;idx.sha1
comma
id|b-&gt;idx.sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;in_pack
OL
id|b-&gt;in_pack
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;in_pack
OG
id|b-&gt;in_pack
)paren
r_return
l_int|1
suffix:semicolon
r_return
id|a-&gt;in_pack_offset
OL
id|b-&gt;in_pack_offset
ques
c_cond
l_int|1
suffix:colon
(paren
id|a-&gt;in_pack_offset
OG
id|b-&gt;in_pack_offset
)paren
suffix:semicolon
)brace
DECL|function|get_object_details
r_static
r_void
id|get_object_details
c_func
(paren
r_void
)paren
(brace
r_uint32
id|i
suffix:semicolon
r_struct
id|object_entry
op_star
op_star
id|sorted_by_offset
suffix:semicolon
id|sorted_by_offset
op_assign
id|xcalloc
c_func
(paren
id|to_pack.nr_objects
comma
r_sizeof
(paren
r_struct
id|object_entry
op_star
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|to_pack.nr_objects
suffix:semicolon
id|i
op_increment
)paren
id|sorted_by_offset
(braket
id|i
)braket
op_assign
id|to_pack.objects
op_plus
id|i
suffix:semicolon
id|qsort
c_func
(paren
id|sorted_by_offset
comma
id|to_pack.nr_objects
comma
r_sizeof
(paren
op_star
id|sorted_by_offset
)paren
comma
id|pack_offset_sort
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|to_pack.nr_objects
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|object_entry
op_star
id|entry
op_assign
id|sorted_by_offset
(braket
id|i
)braket
suffix:semicolon
id|check_object
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|big_file_threshold
OL
id|entry-&gt;size
)paren
id|entry-&gt;no_try_delta
op_assign
l_int|1
suffix:semicolon
)brace
id|free
c_func
(paren
id|sorted_by_offset
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * We search for deltas in a list sorted by type, by filename hash, and then&n; * by size, so that we see progressively smaller and smaller files.&n; * That&squot;s because we prefer deltas to be from the bigger file&n; * to the smaller -- deletes are potentially cheaper, but perhaps&n; * more importantly, the bigger file is likely the more recent&n; * one.  The deepest deltas are therefore the oldest objects which are&n; * less susceptible to be accessed often.&n; */
DECL|function|type_size_sort
r_static
r_int
id|type_size_sort
c_func
(paren
r_const
r_void
op_star
id|_a
comma
r_const
r_void
op_star
id|_b
)paren
(brace
r_const
r_struct
id|object_entry
op_star
id|a
op_assign
op_star
(paren
r_struct
id|object_entry
op_star
op_star
)paren
id|_a
suffix:semicolon
r_const
r_struct
id|object_entry
op_star
id|b
op_assign
op_star
(paren
r_struct
id|object_entry
op_star
op_star
)paren
id|_b
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;type
OG
id|b-&gt;type
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;type
OL
id|b-&gt;type
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;hash
OG
id|b-&gt;hash
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;hash
OL
id|b-&gt;hash
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;preferred_base
OG
id|b-&gt;preferred_base
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;preferred_base
OL
id|b-&gt;preferred_base
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;size
OG
id|b-&gt;size
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;size
OL
id|b-&gt;size
)paren
r_return
l_int|1
suffix:semicolon
r_return
id|a
OL
id|b
ques
c_cond
l_int|1
suffix:colon
(paren
id|a
OG
id|b
)paren
suffix:semicolon
multiline_comment|/* newest first */
)brace
DECL|struct|unpacked
r_struct
id|unpacked
(brace
DECL|member|entry
r_struct
id|object_entry
op_star
id|entry
suffix:semicolon
DECL|member|data
r_void
op_star
id|data
suffix:semicolon
DECL|member|index
r_struct
id|delta_index
op_star
id|index
suffix:semicolon
DECL|member|depth
r_int
id|depth
suffix:semicolon
)brace
suffix:semicolon
DECL|function|delta_cacheable
r_static
r_int
id|delta_cacheable
c_func
(paren
r_int
r_int
id|src_size
comma
r_int
r_int
id|trg_size
comma
r_int
r_int
id|delta_size
)paren
(brace
r_if
c_cond
(paren
id|max_delta_cache_size
op_logical_and
id|delta_cache_size
op_plus
id|delta_size
OG
id|max_delta_cache_size
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|delta_size
OL
id|cache_max_small_delta_size
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* cache delta, if objects are large enough compared to delta size */
r_if
c_cond
(paren
(paren
id|src_size
op_rshift
l_int|20
)paren
op_plus
(paren
id|trg_size
op_rshift
l_int|21
)paren
OG
(paren
id|delta_size
op_rshift
l_int|10
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifndef NO_PTHREADS
DECL|variable|read_mutex
r_static
id|pthread_mutex_t
id|read_mutex
suffix:semicolon
DECL|macro|read_lock
mdefine_line|#define read_lock()&t;&t;pthread_mutex_lock(&amp;read_mutex)
DECL|macro|read_unlock
mdefine_line|#define read_unlock()&t;&t;pthread_mutex_unlock(&amp;read_mutex)
DECL|variable|cache_mutex
r_static
id|pthread_mutex_t
id|cache_mutex
suffix:semicolon
DECL|macro|cache_lock
mdefine_line|#define cache_lock()&t;&t;pthread_mutex_lock(&amp;cache_mutex)
DECL|macro|cache_unlock
mdefine_line|#define cache_unlock()&t;&t;pthread_mutex_unlock(&amp;cache_mutex)
DECL|variable|progress_mutex
r_static
id|pthread_mutex_t
id|progress_mutex
suffix:semicolon
DECL|macro|progress_lock
mdefine_line|#define progress_lock()&t;&t;pthread_mutex_lock(&amp;progress_mutex)
DECL|macro|progress_unlock
mdefine_line|#define progress_unlock()&t;pthread_mutex_unlock(&amp;progress_mutex)
macro_line|#else
DECL|macro|read_lock
mdefine_line|#define read_lock()&t;&t;(void)0
DECL|macro|read_unlock
mdefine_line|#define read_unlock()&t;&t;(void)0
DECL|macro|cache_lock
mdefine_line|#define cache_lock()&t;&t;(void)0
DECL|macro|cache_unlock
mdefine_line|#define cache_unlock()&t;&t;(void)0
DECL|macro|progress_lock
mdefine_line|#define progress_lock()&t;&t;(void)0
DECL|macro|progress_unlock
mdefine_line|#define progress_unlock()&t;(void)0
macro_line|#endif
DECL|function|try_delta
r_static
r_int
id|try_delta
c_func
(paren
r_struct
id|unpacked
op_star
id|trg
comma
r_struct
id|unpacked
op_star
id|src
comma
r_int
id|max_depth
comma
r_int
r_int
op_star
id|mem_usage
)paren
(brace
r_struct
id|object_entry
op_star
id|trg_entry
op_assign
id|trg-&gt;entry
suffix:semicolon
r_struct
id|object_entry
op_star
id|src_entry
op_assign
id|src-&gt;entry
suffix:semicolon
r_int
r_int
id|trg_size
comma
id|src_size
comma
id|delta_size
comma
id|sizediff
comma
id|max_size
comma
id|sz
suffix:semicolon
r_int
id|ref_depth
suffix:semicolon
r_enum
id|object_type
id|type
suffix:semicolon
r_void
op_star
id|delta_buf
suffix:semicolon
multiline_comment|/* Don&squot;t bother doing diffs between different types */
r_if
c_cond
(paren
id|trg_entry-&gt;type
op_ne
id|src_entry-&gt;type
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * We do not bother to try a delta that we discarded on an&n;&t; * earlier try, but only when reusing delta data.  Note that&n;&t; * src_entry that is marked as the preferred_base should always&n;&t; * be considered, as even if we produce a suboptimal delta against&n;&t; * it, we will still save the transfer cost, as we already know&n;&t; * the other side has it and we won&squot;t send src_entry at all.&n;&t; */
r_if
c_cond
(paren
id|reuse_delta
op_logical_and
id|trg_entry-&gt;in_pack
op_logical_and
id|trg_entry-&gt;in_pack
op_eq
id|src_entry-&gt;in_pack
op_logical_and
op_logical_neg
id|src_entry-&gt;preferred_base
op_logical_and
id|trg_entry-&gt;in_pack_type
op_ne
id|OBJ_REF_DELTA
op_logical_and
id|trg_entry-&gt;in_pack_type
op_ne
id|OBJ_OFS_DELTA
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Let&squot;s not bust the allowed depth. */
r_if
c_cond
(paren
id|src-&gt;depth
op_ge
id|max_depth
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Now some size filtering heuristics. */
id|trg_size
op_assign
id|trg_entry-&gt;size
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|trg_entry-&gt;delta
)paren
(brace
id|max_size
op_assign
id|trg_size
op_div
l_int|2
l_int|20
suffix:semicolon
id|ref_depth
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|max_size
op_assign
id|trg_entry-&gt;delta_size
suffix:semicolon
id|ref_depth
op_assign
id|trg-&gt;depth
suffix:semicolon
)brace
id|max_size
op_assign
(paren
r_uint64
)paren
id|max_size
op_star
(paren
id|max_depth
id|src-&gt;depth
)paren
op_div
(paren
id|max_depth
id|ref_depth
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|max_size
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|src_size
op_assign
id|src_entry-&gt;size
suffix:semicolon
id|sizediff
op_assign
id|src_size
OL
id|trg_size
ques
c_cond
id|trg_size
id|src_size
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sizediff
op_ge
id|max_size
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|trg_size
OL
id|src_size
op_div
l_int|32
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Load data if not already done */
r_if
c_cond
(paren
op_logical_neg
id|trg-&gt;data
)paren
(brace
id|read_lock
c_func
(paren
)paren
suffix:semicolon
id|trg-&gt;data
op_assign
id|read_sha1_file
c_func
(paren
id|trg_entry-&gt;idx.sha1
comma
op_amp
id|type
comma
op_amp
id|sz
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|trg-&gt;data
)paren
id|die
c_func
(paren
l_string|&quot;object %s cannot be read&quot;
comma
id|sha1_to_hex
c_func
(paren
id|trg_entry-&gt;idx.sha1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sz
op_ne
id|trg_size
)paren
id|die
c_func
(paren
l_string|&quot;object %s inconsistent object length (%lu vs %lu)&quot;
comma
id|sha1_to_hex
c_func
(paren
id|trg_entry-&gt;idx.sha1
)paren
comma
id|sz
comma
id|trg_size
)paren
suffix:semicolon
op_star
id|mem_usage
op_add_assign
id|sz
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|src-&gt;data
)paren
(brace
id|read_lock
c_func
(paren
)paren
suffix:semicolon
id|src-&gt;data
op_assign
id|read_sha1_file
c_func
(paren
id|src_entry-&gt;idx.sha1
comma
op_amp
id|type
comma
op_amp
id|sz
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|src-&gt;data
)paren
(brace
r_if
c_cond
(paren
id|src_entry-&gt;preferred_base
)paren
(brace
r_static
r_int
id|warned
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|warned
op_increment
)paren
id|warning
c_func
(paren
l_string|&quot;object %s cannot be read&quot;
comma
id|sha1_to_hex
c_func
(paren
id|src_entry-&gt;idx.sha1
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Those objects are not included in the&n;&t;&t;&t;&t; * resulting pack.  Be resilient and ignore&n;&t;&t;&t;&t; * them if they can&squot;t be read, in case the&n;&t;&t;&t;&t; * pack could be created nevertheless.&n;&t;&t;&t;&t; */
r_return
l_int|0
suffix:semicolon
)brace
id|die
c_func
(paren
l_string|&quot;object %s cannot be read&quot;
comma
id|sha1_to_hex
c_func
(paren
id|src_entry-&gt;idx.sha1
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sz
op_ne
id|src_size
)paren
id|die
c_func
(paren
l_string|&quot;object %s inconsistent object length (%lu vs %lu)&quot;
comma
id|sha1_to_hex
c_func
(paren
id|src_entry-&gt;idx.sha1
)paren
comma
id|sz
comma
id|src_size
)paren
suffix:semicolon
op_star
id|mem_usage
op_add_assign
id|sz
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|src-&gt;index
)paren
(brace
id|src-&gt;index
op_assign
id|create_delta_index
c_func
(paren
id|src-&gt;data
comma
id|src_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|src-&gt;index
)paren
(brace
r_static
r_int
id|warned
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|warned
op_increment
)paren
id|warning
c_func
(paren
l_string|&quot;suboptimal pack - out of memory&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
op_star
id|mem_usage
op_add_assign
id|sizeof_delta_index
c_func
(paren
id|src-&gt;index
)paren
suffix:semicolon
)brace
id|delta_buf
op_assign
id|create_delta
c_func
(paren
id|src-&gt;index
comma
id|trg-&gt;data
comma
id|trg_size
comma
op_amp
id|delta_size
comma
id|max_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|delta_buf
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|trg_entry-&gt;delta
)paren
(brace
multiline_comment|/* Prefer only shallower same-sized deltas. */
r_if
c_cond
(paren
id|delta_size
op_eq
id|trg_entry-&gt;delta_size
op_logical_and
id|src-&gt;depth
op_plus
l_int|1
op_ge
id|trg-&gt;depth
)paren
(brace
id|free
c_func
(paren
id|delta_buf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Handle memory allocation outside of the cache&n;&t; * accounting lock.  Compiler will optimize the strangeness&n;&t; * away when NO_PTHREADS is defined.&n;&t; */
id|free
c_func
(paren
id|trg_entry-&gt;delta_data
)paren
suffix:semicolon
id|cache_lock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|trg_entry-&gt;delta_data
)paren
(brace
id|delta_cache_size
op_sub_assign
id|trg_entry-&gt;delta_size
suffix:semicolon
id|trg_entry-&gt;delta_data
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|delta_cacheable
c_func
(paren
id|src_size
comma
id|trg_size
comma
id|delta_size
)paren
)paren
(brace
id|delta_cache_size
op_add_assign
id|delta_size
suffix:semicolon
id|cache_unlock
c_func
(paren
)paren
suffix:semicolon
id|trg_entry-&gt;delta_data
op_assign
id|xrealloc
c_func
(paren
id|delta_buf
comma
id|delta_size
)paren
suffix:semicolon
)brace
r_else
(brace
id|cache_unlock
c_func
(paren
)paren
suffix:semicolon
id|free
c_func
(paren
id|delta_buf
)paren
suffix:semicolon
)brace
id|trg_entry-&gt;delta
op_assign
id|src_entry
suffix:semicolon
id|trg_entry-&gt;delta_size
op_assign
id|delta_size
suffix:semicolon
id|trg-&gt;depth
op_assign
id|src-&gt;depth
op_plus
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|check_delta_limit
r_static
r_int
r_int
id|check_delta_limit
c_func
(paren
r_struct
id|object_entry
op_star
id|me
comma
r_int
r_int
id|n
)paren
(brace
r_struct
id|object_entry
op_star
id|child
op_assign
id|me-&gt;delta_child
suffix:semicolon
r_int
r_int
id|m
op_assign
id|n
suffix:semicolon
r_while
c_loop
(paren
id|child
)paren
(brace
r_int
r_int
id|c
op_assign
id|check_delta_limit
c_func
(paren
id|child
comma
id|n
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
OL
id|c
)paren
id|m
op_assign
id|c
suffix:semicolon
id|child
op_assign
id|child-&gt;delta_sibling
suffix:semicolon
)brace
r_return
id|m
suffix:semicolon
)brace
DECL|function|free_unpacked
r_static
r_int
r_int
id|free_unpacked
c_func
(paren
r_struct
id|unpacked
op_star
id|n
)paren
(brace
r_int
r_int
id|freed_mem
op_assign
id|sizeof_delta_index
c_func
(paren
id|n-&gt;index
)paren
suffix:semicolon
id|free_delta_index
c_func
(paren
id|n-&gt;index
)paren
suffix:semicolon
id|n-&gt;index
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|n-&gt;data
)paren
(brace
id|freed_mem
op_add_assign
id|n-&gt;entry-&gt;size
suffix:semicolon
id|free
c_func
(paren
id|n-&gt;data
)paren
suffix:semicolon
id|n-&gt;data
op_assign
l_int|NULL
suffix:semicolon
)brace
id|n-&gt;entry
op_assign
l_int|NULL
suffix:semicolon
id|n-&gt;depth
op_assign
l_int|0
suffix:semicolon
r_return
id|freed_mem
suffix:semicolon
)brace
DECL|function|find_deltas
r_static
r_void
id|find_deltas
c_func
(paren
r_struct
id|object_entry
op_star
op_star
id|list
comma
r_int
op_star
id|list_size
comma
r_int
id|window
comma
r_int
id|depth
comma
r_int
op_star
id|processed
)paren
(brace
r_uint32
id|i
comma
id|idx
op_assign
l_int|0
comma
id|count
op_assign
l_int|0
suffix:semicolon
r_struct
id|unpacked
op_star
id|array
suffix:semicolon
r_int
r_int
id|mem_usage
op_assign
l_int|0
suffix:semicolon
id|array
op_assign
id|xcalloc
c_func
(paren
id|window
comma
r_sizeof
(paren
r_struct
id|unpacked
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|object_entry
op_star
id|entry
suffix:semicolon
r_struct
id|unpacked
op_star
id|n
op_assign
id|array
op_plus
id|idx
suffix:semicolon
r_int
id|j
comma
id|max_depth
comma
id|best_base
op_assign
l_int|1
suffix:semicolon
id|progress_lock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|list_size
)paren
(brace
id|progress_unlock
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|entry
op_assign
op_star
id|list
op_increment
suffix:semicolon
(paren
op_star
id|list_size
)paren
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;preferred_base
)paren
(brace
(paren
op_star
id|processed
)paren
op_increment
suffix:semicolon
id|display_progress
c_func
(paren
id|progress_state
comma
op_star
id|processed
)paren
suffix:semicolon
)brace
id|progress_unlock
c_func
(paren
)paren
suffix:semicolon
id|mem_usage
op_sub_assign
id|free_unpacked
c_func
(paren
id|n
)paren
suffix:semicolon
id|n-&gt;entry
op_assign
id|entry
suffix:semicolon
r_while
c_loop
(paren
id|window_memory_limit
op_logical_and
id|mem_usage
OG
id|window_memory_limit
op_logical_and
id|count
OG
l_int|1
)paren
(brace
r_uint32
id|tail
op_assign
(paren
id|idx
op_plus
id|window
id|count
)paren
op_mod
id|window
suffix:semicolon
id|mem_usage
op_sub_assign
id|free_unpacked
c_func
(paren
id|array
op_plus
id|tail
)paren
suffix:semicolon
id|count
op_decrement
suffix:semicolon
)brace
multiline_comment|/* We do not compute delta to *create* objects we are not&n;&t;&t; * going to pack.&n;&t;&t; */
r_if
c_cond
(paren
id|entry-&gt;preferred_base
)paren
r_goto
id|next
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the current object is at pack edge, take the depth the&n;&t;&t; * objects that depend on the current object into account&n;&t;&t; * otherwise they would become too deep.&n;&t;&t; */
id|max_depth
op_assign
id|depth
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;delta_child
)paren
(brace
id|max_depth
op_sub_assign
id|check_delta_limit
c_func
(paren
id|entry
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|max_depth
op_le
l_int|0
)paren
r_goto
id|next
suffix:semicolon
)brace
id|j
op_assign
id|window
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|j
OG
l_int|0
)paren
(brace
r_int
id|ret
suffix:semicolon
r_uint32
id|other_idx
op_assign
id|idx
op_plus
id|j
suffix:semicolon
r_struct
id|unpacked
op_star
id|m
suffix:semicolon
r_if
c_cond
(paren
id|other_idx
op_ge
id|window
)paren
id|other_idx
op_sub_assign
id|window
suffix:semicolon
id|m
op_assign
id|array
op_plus
id|other_idx
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|m-&gt;entry
)paren
r_break
suffix:semicolon
id|ret
op_assign
id|try_delta
c_func
(paren
id|n
comma
id|m
comma
id|max_depth
comma
op_amp
id|mem_usage
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_break
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ret
OG
l_int|0
)paren
id|best_base
op_assign
id|other_idx
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If we decided to cache the delta data, then it is best&n;&t;&t; * to compress it right away.  First because we have to do&n;&t;&t; * it anyway, and doing it here while we&squot;re threaded will&n;&t;&t; * save a lot of time in the non threaded write phase,&n;&t;&t; * as well as allow for caching more deltas within&n;&t;&t; * the same cache size limit.&n;&t;&t; * ...&n;&t;&t; * But only if not writing to stdout, since in that case&n;&t;&t; * the network is most likely throttling writes anyway,&n;&t;&t; * and therefore it is best to go to the write phase ASAP&n;&t;&t; * instead, as we can afford spending more time compressing&n;&t;&t; * between writes at that moment.&n;&t;&t; */
r_if
c_cond
(paren
id|entry-&gt;delta_data
op_logical_and
op_logical_neg
id|pack_to_stdout
)paren
(brace
id|entry-&gt;z_delta_size
op_assign
id|do_compress
c_func
(paren
op_amp
id|entry-&gt;delta_data
comma
id|entry-&gt;delta_size
)paren
suffix:semicolon
id|cache_lock
c_func
(paren
)paren
suffix:semicolon
id|delta_cache_size
op_sub_assign
id|entry-&gt;delta_size
suffix:semicolon
id|delta_cache_size
op_add_assign
id|entry-&gt;z_delta_size
suffix:semicolon
id|cache_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* if we made n a delta, and if n is already at max&n;&t;&t; * depth, leaving it in the window is pointless.  we&n;&t;&t; * should evict it first.&n;&t;&t; */
r_if
c_cond
(paren
id|entry-&gt;delta
op_logical_and
id|max_depth
op_le
id|n-&gt;depth
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Move the best delta base up in the window, after the&n;&t;&t; * currently deltified object, to keep it longer.  It will&n;&t;&t; * be the first base object to be attempted next.&n;&t;&t; */
r_if
c_cond
(paren
id|entry-&gt;delta
)paren
(brace
r_struct
id|unpacked
id|swap
op_assign
id|array
(braket
id|best_base
)braket
suffix:semicolon
r_int
id|dist
op_assign
(paren
id|window
op_plus
id|idx
id|best_base
)paren
op_mod
id|window
suffix:semicolon
r_int
id|dst
op_assign
id|best_base
suffix:semicolon
r_while
c_loop
(paren
id|dist
op_decrement
)paren
(brace
r_int
id|src
op_assign
(paren
id|dst
op_plus
l_int|1
)paren
op_mod
id|window
suffix:semicolon
id|array
(braket
id|dst
)braket
op_assign
id|array
(braket
id|src
)braket
suffix:semicolon
id|dst
op_assign
id|src
suffix:semicolon
)brace
id|array
(braket
id|dst
)braket
op_assign
id|swap
suffix:semicolon
)brace
id|next
suffix:colon
id|idx
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|count
op_plus
l_int|1
OL
id|window
)paren
id|count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|idx
op_ge
id|window
)paren
id|idx
op_assign
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|window
suffix:semicolon
op_increment
id|i
)paren
(brace
id|free_delta_index
c_func
(paren
id|array
(braket
id|i
)braket
dot
id|index
)paren
suffix:semicolon
id|free
c_func
(paren
id|array
(braket
id|i
)braket
dot
id|data
)paren
suffix:semicolon
)brace
id|free
c_func
(paren
id|array
)paren
suffix:semicolon
)brace
macro_line|#ifndef NO_PTHREADS
DECL|function|try_to_free_from_threads
r_static
r_void
id|try_to_free_from_threads
c_func
(paren
r_int
id|size
)paren
(brace
id|read_lock
c_func
(paren
)paren
suffix:semicolon
id|release_pack_memory
c_func
(paren
id|size
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|old_try_to_free_routine
r_static
id|try_to_free_t
id|old_try_to_free_routine
suffix:semicolon
multiline_comment|/*&n; * The main thread waits on the condition that (at least) one of the workers&n; * has stopped working (which is indicated in the .working member of&n; * struct thread_params).&n; * When a work thread has completed its work, it sets .working to 0 and&n; * signals the main thread and waits on the condition that .data_ready&n; * becomes 1.&n; */
DECL|struct|thread_params
r_struct
id|thread_params
(brace
DECL|member|thread
id|pthread_t
id|thread
suffix:semicolon
DECL|member|list
r_struct
id|object_entry
op_star
op_star
id|list
suffix:semicolon
DECL|member|list_size
r_int
id|list_size
suffix:semicolon
DECL|member|remaining
r_int
id|remaining
suffix:semicolon
DECL|member|window
r_int
id|window
suffix:semicolon
DECL|member|depth
r_int
id|depth
suffix:semicolon
DECL|member|working
r_int
id|working
suffix:semicolon
DECL|member|data_ready
r_int
id|data_ready
suffix:semicolon
DECL|member|mutex
id|pthread_mutex_t
id|mutex
suffix:semicolon
DECL|member|cond
id|pthread_cond_t
id|cond
suffix:semicolon
DECL|member|processed
r_int
op_star
id|processed
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|progress_cond
r_static
id|pthread_cond_t
id|progress_cond
suffix:semicolon
multiline_comment|/*&n; * Mutex and conditional variable can&squot;t be statically-initialized on Windows.&n; */
DECL|function|init_threaded_search
r_static
r_void
id|init_threaded_search
c_func
(paren
r_void
)paren
(brace
id|init_recursive_mutex
c_func
(paren
op_amp
id|read_mutex
)paren
suffix:semicolon
id|pthread_mutex_init
c_func
(paren
op_amp
id|cache_mutex
comma
l_int|NULL
)paren
suffix:semicolon
id|pthread_mutex_init
c_func
(paren
op_amp
id|progress_mutex
comma
l_int|NULL
)paren
suffix:semicolon
id|pthread_cond_init
c_func
(paren
op_amp
id|progress_cond
comma
l_int|NULL
)paren
suffix:semicolon
id|old_try_to_free_routine
op_assign
id|set_try_to_free_routine
c_func
(paren
id|try_to_free_from_threads
)paren
suffix:semicolon
)brace
DECL|function|cleanup_threaded_search
r_static
r_void
id|cleanup_threaded_search
c_func
(paren
r_void
)paren
(brace
id|set_try_to_free_routine
c_func
(paren
id|old_try_to_free_routine
)paren
suffix:semicolon
id|pthread_cond_destroy
c_func
(paren
op_amp
id|progress_cond
)paren
suffix:semicolon
id|pthread_mutex_destroy
c_func
(paren
op_amp
id|read_mutex
)paren
suffix:semicolon
id|pthread_mutex_destroy
c_func
(paren
op_amp
id|cache_mutex
)paren
suffix:semicolon
id|pthread_mutex_destroy
c_func
(paren
op_amp
id|progress_mutex
)paren
suffix:semicolon
)brace
DECL|function|threaded_find_deltas
r_static
r_void
op_star
id|threaded_find_deltas
c_func
(paren
r_void
op_star
id|arg
)paren
(brace
r_struct
id|thread_params
op_star
id|me
op_assign
id|arg
suffix:semicolon
r_while
c_loop
(paren
id|me-&gt;remaining
)paren
(brace
id|find_deltas
c_func
(paren
id|me-&gt;list
comma
op_amp
id|me-&gt;remaining
comma
id|me-&gt;window
comma
id|me-&gt;depth
comma
id|me-&gt;processed
)paren
suffix:semicolon
id|progress_lock
c_func
(paren
)paren
suffix:semicolon
id|me-&gt;working
op_assign
l_int|0
suffix:semicolon
id|pthread_cond_signal
c_func
(paren
op_amp
id|progress_cond
)paren
suffix:semicolon
id|progress_unlock
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We must not set -&gt;data_ready before we wait on the&n;&t;&t; * condition because the main thread may have set it to 1&n;&t;&t; * before we get here. In order to be sure that new&n;&t;&t; * work is available if we see 1 in -&gt;data_ready, it&n;&t;&t; * was initialized to 0 before this thread was spawned&n;&t;&t; * and we reset it to 0 right away.&n;&t;&t; */
id|pthread_mutex_lock
c_func
(paren
op_amp
id|me-&gt;mutex
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|me-&gt;data_ready
)paren
id|pthread_cond_wait
c_func
(paren
op_amp
id|me-&gt;cond
comma
op_amp
id|me-&gt;mutex
)paren
suffix:semicolon
id|me-&gt;data_ready
op_assign
l_int|0
suffix:semicolon
id|pthread_mutex_unlock
c_func
(paren
op_amp
id|me-&gt;mutex
)paren
suffix:semicolon
)brace
multiline_comment|/* leave -&gt;working 1 so that this doesn&squot;t get more work assigned */
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|ll_find_deltas
r_static
r_void
id|ll_find_deltas
c_func
(paren
r_struct
id|object_entry
op_star
op_star
id|list
comma
r_int
id|list_size
comma
r_int
id|window
comma
r_int
id|depth
comma
r_int
op_star
id|processed
)paren
(brace
r_struct
id|thread_params
op_star
id|p
suffix:semicolon
r_int
id|i
comma
id|ret
comma
id|active_threads
op_assign
l_int|0
suffix:semicolon
id|init_threaded_search
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|delta_search_threads
op_le
l_int|1
)paren
(brace
id|find_deltas
c_func
(paren
id|list
comma
op_amp
id|list_size
comma
id|window
comma
id|depth
comma
id|processed
)paren
suffix:semicolon
id|cleanup_threaded_search
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|progress
OG
id|pack_to_stdout
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Delta compression using up to %d threads.&bslash;n&quot;
comma
id|delta_search_threads
)paren
suffix:semicolon
id|p
op_assign
id|xcalloc
c_func
(paren
id|delta_search_threads
comma
r_sizeof
(paren
op_star
id|p
)paren
)paren
suffix:semicolon
multiline_comment|/* Partition the work amongst work threads. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|delta_search_threads
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|sub_size
op_assign
id|list_size
op_div
(paren
id|delta_search_threads
id|i
)paren
suffix:semicolon
multiline_comment|/* don&squot;t use too small segments or no deltas will be found */
r_if
c_cond
(paren
id|sub_size
OL
l_int|2
op_star
id|window
op_logical_and
id|i
op_plus
l_int|1
OL
id|delta_search_threads
)paren
id|sub_size
op_assign
l_int|0
suffix:semicolon
id|p
(braket
id|i
)braket
dot
id|window
op_assign
id|window
suffix:semicolon
id|p
(braket
id|i
)braket
dot
id|depth
op_assign
id|depth
suffix:semicolon
id|p
(braket
id|i
)braket
dot
id|processed
op_assign
id|processed
suffix:semicolon
id|p
(braket
id|i
)braket
dot
id|working
op_assign
l_int|1
suffix:semicolon
id|p
(braket
id|i
)braket
dot
id|data_ready
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* try to split chunks on &quot;path&quot; boundaries */
r_while
c_loop
(paren
id|sub_size
op_logical_and
id|sub_size
OL
id|list_size
op_logical_and
id|list
(braket
id|sub_size
)braket
op_member_access_from_pointer
id|hash
op_logical_and
id|list
(braket
id|sub_size
)braket
op_member_access_from_pointer
id|hash
op_eq
id|list
(braket
id|sub_size
op_minus
l_int|1
)braket
op_member_access_from_pointer
id|hash
)paren
id|sub_size
op_increment
suffix:semicolon
id|p
(braket
id|i
)braket
dot
id|list
op_assign
id|list
suffix:semicolon
id|p
(braket
id|i
)braket
dot
id|list_size
op_assign
id|sub_size
suffix:semicolon
id|p
(braket
id|i
)braket
dot
id|remaining
op_assign
id|sub_size
suffix:semicolon
id|list
op_add_assign
id|sub_size
suffix:semicolon
id|list_size
op_sub_assign
id|sub_size
suffix:semicolon
)brace
multiline_comment|/* Start work threads. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|delta_search_threads
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|p
(braket
id|i
)braket
dot
id|list_size
)paren
r_continue
suffix:semicolon
id|pthread_mutex_init
c_func
(paren
op_amp
id|p
(braket
id|i
)braket
dot
id|mutex
comma
l_int|NULL
)paren
suffix:semicolon
id|pthread_cond_init
c_func
(paren
op_amp
id|p
(braket
id|i
)braket
dot
id|cond
comma
l_int|NULL
)paren
suffix:semicolon
id|ret
op_assign
id|pthread_create
c_func
(paren
op_amp
id|p
(braket
id|i
)braket
dot
id|thread
comma
l_int|NULL
comma
id|threaded_find_deltas
comma
op_amp
id|p
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
id|die
c_func
(paren
l_string|&quot;unable to create thread: %s&quot;
comma
id|strerror
c_func
(paren
id|ret
)paren
)paren
suffix:semicolon
id|active_threads
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now let&squot;s wait for work completion.  Each time a thread is done&n;&t; * with its work, we steal half of the remaining work from the&n;&t; * thread with the largest number of unprocessed objects and give&n;&t; * it to that newly idle thread.  This ensure good load balancing&n;&t; * until the remaining object list segments are simply too short&n;&t; * to be worth splitting anymore.&n;&t; */
r_while
c_loop
(paren
id|active_threads
)paren
(brace
r_struct
id|thread_params
op_star
id|target
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|thread_params
op_star
id|victim
op_assign
l_int|NULL
suffix:semicolon
r_int
id|sub_size
op_assign
l_int|0
suffix:semicolon
id|progress_lock
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|target
op_logical_and
id|i
OL
id|delta_search_threads
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|p
(braket
id|i
)braket
dot
id|working
)paren
id|target
op_assign
op_amp
id|p
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|target
)paren
r_break
suffix:semicolon
id|pthread_cond_wait
c_func
(paren
op_amp
id|progress_cond
comma
op_amp
id|progress_mutex
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|delta_search_threads
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|p
(braket
id|i
)braket
dot
id|remaining
OG
l_int|2
op_star
id|window
op_logical_and
(paren
op_logical_neg
id|victim
op_logical_or
id|victim-&gt;remaining
OL
id|p
(braket
id|i
)braket
dot
id|remaining
)paren
)paren
id|victim
op_assign
op_amp
id|p
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|victim
)paren
(brace
id|sub_size
op_assign
id|victim-&gt;remaining
op_div
l_int|2
suffix:semicolon
id|list
op_assign
id|victim-&gt;list
op_plus
id|victim-&gt;list_size
id|sub_size
suffix:semicolon
r_while
c_loop
(paren
id|sub_size
op_logical_and
id|list
(braket
l_int|0
)braket
op_member_access_from_pointer
id|hash
op_logical_and
id|list
(braket
l_int|0
)braket
op_member_access_from_pointer
id|hash
op_eq
id|list
(braket
l_int|1
)braket
op_member_access_from_pointer
id|hash
)paren
(brace
id|list
op_increment
suffix:semicolon
id|sub_size
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sub_size
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * It is possible for some &quot;paths&quot; to have&n;&t;&t;&t;&t; * so many objects that no hash boundary&n;&t;&t;&t;&t; * might be found.  Let&squot;s just steal the&n;&t;&t;&t;&t; * exact half in that case.&n;&t;&t;&t;&t; */
id|sub_size
op_assign
id|victim-&gt;remaining
op_div
l_int|2
suffix:semicolon
id|list
op_sub_assign
id|sub_size
suffix:semicolon
)brace
id|target-&gt;list
op_assign
id|list
suffix:semicolon
id|victim-&gt;list_size
op_sub_assign
id|sub_size
suffix:semicolon
id|victim-&gt;remaining
op_sub_assign
id|sub_size
suffix:semicolon
)brace
id|target-&gt;list_size
op_assign
id|sub_size
suffix:semicolon
id|target-&gt;remaining
op_assign
id|sub_size
suffix:semicolon
id|target-&gt;working
op_assign
l_int|1
suffix:semicolon
id|progress_unlock
c_func
(paren
)paren
suffix:semicolon
id|pthread_mutex_lock
c_func
(paren
op_amp
id|target-&gt;mutex
)paren
suffix:semicolon
id|target-&gt;data_ready
op_assign
l_int|1
suffix:semicolon
id|pthread_cond_signal
c_func
(paren
op_amp
id|target-&gt;cond
)paren
suffix:semicolon
id|pthread_mutex_unlock
c_func
(paren
op_amp
id|target-&gt;mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sub_size
)paren
(brace
id|pthread_join
c_func
(paren
id|target-&gt;thread
comma
l_int|NULL
)paren
suffix:semicolon
id|pthread_cond_destroy
c_func
(paren
op_amp
id|target-&gt;cond
)paren
suffix:semicolon
id|pthread_mutex_destroy
c_func
(paren
op_amp
id|target-&gt;mutex
)paren
suffix:semicolon
id|active_threads
op_decrement
suffix:semicolon
)brace
)brace
id|cleanup_threaded_search
c_func
(paren
)paren
suffix:semicolon
id|free
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|macro|ll_find_deltas
mdefine_line|#define ll_find_deltas(l, s, w, d, p)&t;find_deltas(l, &amp;s, w, d, p)
macro_line|#endif
DECL|function|add_ref_tag
r_static
r_int
id|add_ref_tag
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_const
r_struct
id|object_id
op_star
id|oid
comma
r_int
id|flag
comma
r_void
op_star
id|cb_data
)paren
(brace
r_struct
id|object_id
id|peeled
suffix:semicolon
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|path
comma
l_string|&quot;refs/tags/&quot;
)paren
op_logical_and
multiline_comment|/* is a tag? */
op_logical_neg
id|peel_ref
c_func
(paren
id|path
comma
id|peeled.hash
)paren
op_logical_and
multiline_comment|/* peelable? */
id|packlist_find
c_func
(paren
op_amp
id|to_pack
comma
id|peeled.hash
comma
l_int|NULL
)paren
)paren
multiline_comment|/* object packed? */
id|add_object_entry
c_func
(paren
id|oid-&gt;hash
comma
id|OBJ_TAG
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|prepare_pack
r_static
r_void
id|prepare_pack
c_func
(paren
r_int
id|window
comma
r_int
id|depth
)paren
(brace
r_struct
id|object_entry
op_star
op_star
id|delta_list
suffix:semicolon
r_uint32
id|i
comma
id|nr_deltas
suffix:semicolon
r_int
id|n
suffix:semicolon
id|get_object_details
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we&squot;re locally repacking then we need to be doubly careful&n;&t; * from now on in order to make sure no stealth corruption gets&n;&t; * propagated to the new pack.  Clients receiving streamed packs&n;&t; * should validate everything they get anyway so no need to incur&n;&t; * the additional cost here in that case.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|pack_to_stdout
)paren
id|do_check_packed_object_crc
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|to_pack.nr_objects
op_logical_or
op_logical_neg
id|window
op_logical_or
op_logical_neg
id|depth
)paren
r_return
suffix:semicolon
id|delta_list
op_assign
id|xmalloc
c_func
(paren
id|to_pack.nr_objects
op_star
r_sizeof
(paren
op_star
id|delta_list
)paren
)paren
suffix:semicolon
id|nr_deltas
op_assign
id|n
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|to_pack.nr_objects
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|object_entry
op_star
id|entry
op_assign
id|to_pack.objects
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;delta
)paren
multiline_comment|/* This happens if we decided to reuse existing&n;&t;&t;&t; * delta from a pack.  &quot;reuse_delta &amp;&amp;&quot; is implied.&n;&t;&t;&t; */
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;size
OL
l_int|50
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;no_try_delta
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;preferred_base
)paren
(brace
id|nr_deltas
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;type
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;unable to get type of object %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|entry-&gt;idx.sha1
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|entry-&gt;type
OL
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * This object is not found, but we&n;&t;&t;&t;&t; * don&squot;t have to include it anyway.&n;&t;&t;&t;&t; */
r_continue
suffix:semicolon
)brace
)brace
id|delta_list
(braket
id|n
op_increment
)braket
op_assign
id|entry
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nr_deltas
op_logical_and
id|n
OG
l_int|1
)paren
(brace
r_int
id|nr_done
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|progress
)paren
id|progress_state
op_assign
id|start_progress
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Compressing objects&quot;
)paren
comma
id|nr_deltas
)paren
suffix:semicolon
id|qsort
c_func
(paren
id|delta_list
comma
id|n
comma
r_sizeof
(paren
op_star
id|delta_list
)paren
comma
id|type_size_sort
)paren
suffix:semicolon
id|ll_find_deltas
c_func
(paren
id|delta_list
comma
id|n
comma
id|window
op_plus
l_int|1
comma
id|depth
comma
op_amp
id|nr_done
)paren
suffix:semicolon
id|stop_progress
c_func
(paren
op_amp
id|progress_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr_done
op_ne
id|nr_deltas
)paren
id|die
c_func
(paren
l_string|&quot;inconsistency with delta count&quot;
)paren
suffix:semicolon
)brace
id|free
c_func
(paren
id|delta_list
)paren
suffix:semicolon
)brace
DECL|function|git_pack_config
r_static
r_int
id|git_pack_config
c_func
(paren
r_const
r_char
op_star
id|k
comma
r_const
r_char
op_star
id|v
comma
r_void
op_star
id|cb
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|k
comma
l_string|&quot;pack.window&quot;
)paren
)paren
(brace
id|window
op_assign
id|git_config_int
c_func
(paren
id|k
comma
id|v
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|k
comma
l_string|&quot;pack.windowmemory&quot;
)paren
)paren
(brace
id|window_memory_limit
op_assign
id|git_config_ulong
c_func
(paren
id|k
comma
id|v
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|k
comma
l_string|&quot;pack.depth&quot;
)paren
)paren
(brace
id|depth
op_assign
id|git_config_int
c_func
(paren
id|k
comma
id|v
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|k
comma
l_string|&quot;pack.compression&quot;
)paren
)paren
(brace
r_int
id|level
op_assign
id|git_config_int
c_func
(paren
id|k
comma
id|v
)paren
suffix:semicolon
r_if
c_cond
(paren
id|level
op_eq
l_int|1
)paren
id|level
op_assign
id|Z_DEFAULT_COMPRESSION
suffix:semicolon
r_else
r_if
c_cond
(paren
id|level
template_param
id|Z_BEST_COMPRESSION
)paren
id|die
c_func
(paren
l_string|&quot;bad pack compression level %d&quot;
comma
id|level
)paren
suffix:semicolon
id|pack_compression_level
op_assign
id|level
suffix:semicolon
id|pack_compression_seen
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|k
comma
l_string|&quot;pack.deltacachesize&quot;
)paren
)paren
(brace
id|max_delta_cache_size
op_assign
id|git_config_int
c_func
(paren
id|k
comma
id|v
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|k
comma
l_string|&quot;pack.deltacachelimit&quot;
)paren
)paren
(brace
id|cache_max_small_delta_size
op_assign
id|git_config_int
c_func
(paren
id|k
comma
id|v
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|k
comma
l_string|&quot;pack.writebitmaphashcache&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|git_config_bool
c_func
(paren
id|k
comma
id|v
)paren
)paren
id|write_bitmap_options
op_or_assign
id|BITMAP_OPT_HASH_CACHE
suffix:semicolon
r_else
id|write_bitmap_options
op_and_assign
op_complement
id|BITMAP_OPT_HASH_CACHE
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|k
comma
l_string|&quot;pack.usebitmaps&quot;
)paren
)paren
(brace
id|use_bitmap_index
op_assign
id|git_config_bool
c_func
(paren
id|k
comma
id|v
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|k
comma
l_string|&quot;pack.threads&quot;
)paren
)paren
(brace
id|delta_search_threads
op_assign
id|git_config_int
c_func
(paren
id|k
comma
id|v
)paren
suffix:semicolon
r_if
c_cond
(paren
id|delta_search_threads
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;invalid number of threads specified (%d)&quot;
comma
id|delta_search_threads
)paren
suffix:semicolon
macro_line|#ifdef NO_PTHREADS
r_if
c_cond
(paren
id|delta_search_threads
op_ne
l_int|1
)paren
id|warning
c_func
(paren
l_string|&quot;no threads support, ignoring %s&quot;
comma
id|k
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|k
comma
l_string|&quot;pack.indexversion&quot;
)paren
)paren
(brace
id|pack_idx_opts.version
op_assign
id|git_config_int
c_func
(paren
id|k
comma
id|v
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pack_idx_opts.version
OG
l_int|2
)paren
id|die
c_func
(paren
l_string|&quot;bad pack.indexversion=%&quot;
id|PRIu32
comma
id|pack_idx_opts.version
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|git_default_config
c_func
(paren
id|k
comma
id|v
comma
id|cb
)paren
suffix:semicolon
)brace
DECL|function|read_object_list_from_stdin
r_static
r_void
id|read_object_list_from_stdin
c_func
(paren
r_void
)paren
(brace
r_char
id|line
(braket
l_int|40
op_plus
l_int|1
op_plus
id|PATH_MAX
op_plus
l_int|2
)braket
suffix:semicolon
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|fgets
c_func
(paren
id|line
comma
r_sizeof
(paren
id|line
)paren
comma
id|stdin
)paren
)paren
(brace
r_if
c_cond
(paren
id|feof
c_func
(paren
id|stdin
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ferror
c_func
(paren
id|stdin
)paren
)paren
id|die
c_func
(paren
l_string|&quot;fgets returned NULL, not EOF, not error!&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|errno
op_ne
id|EINTR
)paren
id|die_errno
c_func
(paren
l_string|&quot;fgets&quot;
)paren
suffix:semicolon
id|clearerr
c_func
(paren
id|stdin
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|line
(braket
l_int|0
)braket
op_eq
l_char|&squot;-&squot;
)paren
(brace
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|line
op_plus
l_int|1
comma
id|sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;expected edge sha1, got garbage:&bslash;n %s&quot;
comma
id|line
)paren
suffix:semicolon
id|add_preferred_base
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|line
comma
id|sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;expected sha1, got garbage:&bslash;n %s&quot;
comma
id|line
)paren
suffix:semicolon
id|add_preferred_base_object
c_func
(paren
id|line
op_plus
l_int|41
)paren
suffix:semicolon
id|add_object_entry
c_func
(paren
id|sha1
comma
l_int|0
comma
id|line
op_plus
l_int|41
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
DECL|macro|OBJECT_ADDED
mdefine_line|#define OBJECT_ADDED (1u&lt;&lt;20)
DECL|function|show_commit
r_static
r_void
id|show_commit
c_func
(paren
r_struct
id|commit
op_star
id|commit
comma
r_void
op_star
id|data
)paren
(brace
id|add_object_entry
c_func
(paren
id|commit-&gt;object.sha1
comma
id|OBJ_COMMIT
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|commit-&gt;object.flags
op_or_assign
id|OBJECT_ADDED
suffix:semicolon
r_if
c_cond
(paren
id|write_bitmap_index
)paren
id|index_commit_for_bitmap
c_func
(paren
id|commit
)paren
suffix:semicolon
)brace
DECL|function|show_object
r_static
r_void
id|show_object
c_func
(paren
r_struct
id|object
op_star
id|obj
comma
r_const
r_struct
id|name_path
op_star
id|path
comma
r_const
r_char
op_star
id|last
comma
r_void
op_star
id|data
)paren
(brace
r_char
op_star
id|name
op_assign
id|path_name
c_func
(paren
id|path
comma
id|last
)paren
suffix:semicolon
id|add_preferred_base_object
c_func
(paren
id|name
)paren
suffix:semicolon
id|add_object_entry
c_func
(paren
id|obj-&gt;sha1
comma
id|obj-&gt;type
comma
id|name
comma
l_int|0
)paren
suffix:semicolon
id|obj-&gt;flags
op_or_assign
id|OBJECT_ADDED
suffix:semicolon
multiline_comment|/*&n;&t; * We will have generated the hash from the name,&n;&t; * but not saved a pointer to it - we can free it&n;&t; */
id|free
c_func
(paren
(paren
r_char
op_star
)paren
id|name
)paren
suffix:semicolon
)brace
DECL|function|show_edge
r_static
r_void
id|show_edge
c_func
(paren
r_struct
id|commit
op_star
id|commit
)paren
(brace
id|add_preferred_base
c_func
(paren
id|commit-&gt;object.sha1
)paren
suffix:semicolon
)brace
DECL|struct|in_pack_object
r_struct
id|in_pack_object
(brace
DECL|member|offset
id|off_t
id|offset
suffix:semicolon
DECL|member|object
r_struct
id|object
op_star
id|object
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|in_pack
r_struct
id|in_pack
(brace
DECL|member|alloc
r_int
id|alloc
suffix:semicolon
DECL|member|nr
r_int
id|nr
suffix:semicolon
DECL|member|array
r_struct
id|in_pack_object
op_star
id|array
suffix:semicolon
)brace
suffix:semicolon
DECL|function|mark_in_pack_object
r_static
r_void
id|mark_in_pack_object
c_func
(paren
r_struct
id|object
op_star
id|object
comma
r_struct
id|packed_git
op_star
id|p
comma
r_struct
id|in_pack
op_star
id|in_pack
)paren
(brace
id|in_pack-&gt;array
(braket
id|in_pack-&gt;nr
)braket
dot
id|offset
op_assign
id|find_pack_entry_one
c_func
(paren
id|object-&gt;sha1
comma
id|p
)paren
suffix:semicolon
id|in_pack-&gt;array
(braket
id|in_pack-&gt;nr
)braket
dot
id|object
op_assign
id|object
suffix:semicolon
id|in_pack-&gt;nr
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; * Compare the objects in the offset order, in order to emulate the&n; * &quot;git rev-list --objects&quot; output that produced the pack originally.&n; */
DECL|function|ofscmp
r_static
r_int
id|ofscmp
c_func
(paren
r_const
r_void
op_star
id|a_
comma
r_const
r_void
op_star
id|b_
)paren
(brace
r_struct
id|in_pack_object
op_star
id|a
op_assign
(paren
r_struct
id|in_pack_object
op_star
)paren
id|a_
suffix:semicolon
r_struct
id|in_pack_object
op_star
id|b
op_assign
(paren
r_struct
id|in_pack_object
op_star
)paren
id|b_
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;offset
OL
id|b-&gt;offset
)paren
r_return
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|a-&gt;offset
OG
id|b-&gt;offset
)paren
r_return
l_int|1
suffix:semicolon
r_else
r_return
id|hashcmp
c_func
(paren
id|a-&gt;object-&gt;sha1
comma
id|b-&gt;object-&gt;sha1
)paren
suffix:semicolon
)brace
DECL|function|add_objects_in_unpacked_packs
r_static
r_void
id|add_objects_in_unpacked_packs
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
)paren
(brace
r_struct
id|packed_git
op_star
id|p
suffix:semicolon
r_struct
id|in_pack
id|in_pack
suffix:semicolon
r_uint32
id|i
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|in_pack
comma
l_int|0
comma
r_sizeof
(paren
id|in_pack
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|packed_git
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_const
r_int
r_char
op_star
id|sha1
suffix:semicolon
r_struct
id|object
op_star
id|o
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;pack_local
op_logical_or
id|p-&gt;pack_keep
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|open_pack_index
c_func
(paren
id|p
)paren
)paren
id|die
c_func
(paren
l_string|&quot;cannot open pack index&quot;
)paren
suffix:semicolon
id|ALLOC_GROW
c_func
(paren
id|in_pack.array
comma
id|in_pack.nr
op_plus
id|p-&gt;num_objects
comma
id|in_pack.alloc
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|p-&gt;num_objects
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sha1
op_assign
id|nth_packed_object_sha1
c_func
(paren
id|p
comma
id|i
)paren
suffix:semicolon
id|o
op_assign
id|lookup_unknown_object
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|o-&gt;flags
op_amp
id|OBJECT_ADDED
)paren
)paren
id|mark_in_pack_object
c_func
(paren
id|o
comma
id|p
comma
op_amp
id|in_pack
)paren
suffix:semicolon
id|o-&gt;flags
op_or_assign
id|OBJECT_ADDED
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|in_pack.nr
)paren
(brace
id|qsort
c_func
(paren
id|in_pack.array
comma
id|in_pack.nr
comma
r_sizeof
(paren
id|in_pack.array
(braket
l_int|0
)braket
)paren
comma
id|ofscmp
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|in_pack.nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|object
op_star
id|o
op_assign
id|in_pack.array
(braket
id|i
)braket
dot
id|object
suffix:semicolon
id|add_object_entry
c_func
(paren
id|o-&gt;sha1
comma
id|o-&gt;type
comma
l_string|&quot;&quot;
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
id|free
c_func
(paren
id|in_pack.array
)paren
suffix:semicolon
)brace
DECL|function|has_sha1_pack_kept_or_nonlocal
r_static
r_int
id|has_sha1_pack_kept_or_nonlocal
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_static
r_struct
id|packed_git
op_star
id|last_found
op_assign
(paren
r_void
op_star
)paren
l_int|1
suffix:semicolon
r_struct
id|packed_git
op_star
id|p
suffix:semicolon
id|p
op_assign
(paren
id|last_found
op_ne
(paren
r_void
op_star
)paren
l_int|1
)paren
ques
c_cond
id|last_found
suffix:colon
id|packed_git
suffix:semicolon
r_while
c_loop
(paren
id|p
)paren
(brace
r_if
c_cond
(paren
(paren
op_logical_neg
id|p-&gt;pack_local
op_logical_or
id|p-&gt;pack_keep
)paren
op_logical_and
id|find_pack_entry_one
c_func
(paren
id|sha1
comma
id|p
)paren
)paren
(brace
id|last_found
op_assign
id|p
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p
op_eq
id|last_found
)paren
id|p
op_assign
id|packed_git
suffix:semicolon
r_else
id|p
op_assign
id|p-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
id|last_found
)paren
id|p
op_assign
id|p-&gt;next
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Store a list of sha1s that are should not be discarded&n; * because they are either written too recently, or are&n; * reachable from another object that was.&n; *&n; * This is filled by get_object_list.&n; */
DECL|variable|recent_objects
r_static
r_struct
id|sha1_array
id|recent_objects
suffix:semicolon
DECL|function|loosened_object_can_be_discarded
r_static
r_int
id|loosened_object_can_be_discarded
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
r_int
id|mtime
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|unpack_unreachable_expiration
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|mtime
OG
id|unpack_unreachable_expiration
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sha1_array_lookup
c_func
(paren
op_amp
id|recent_objects
comma
id|sha1
)paren
op_ge
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|loosen_unused_packed_objects
r_static
r_void
id|loosen_unused_packed_objects
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
)paren
(brace
r_struct
id|packed_git
op_star
id|p
suffix:semicolon
r_uint32
id|i
suffix:semicolon
r_const
r_int
r_char
op_star
id|sha1
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|packed_git
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;pack_local
op_logical_or
id|p-&gt;pack_keep
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|open_pack_index
c_func
(paren
id|p
)paren
)paren
id|die
c_func
(paren
l_string|&quot;cannot open pack index&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|p-&gt;num_objects
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sha1
op_assign
id|nth_packed_object_sha1
c_func
(paren
id|p
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|packlist_find
c_func
(paren
op_amp
id|to_pack
comma
id|sha1
comma
l_int|NULL
)paren
op_logical_and
op_logical_neg
id|has_sha1_pack_kept_or_nonlocal
c_func
(paren
id|sha1
)paren
op_logical_and
op_logical_neg
id|loosened_object_can_be_discarded
c_func
(paren
id|sha1
comma
id|p-&gt;mtime
)paren
)paren
r_if
c_cond
(paren
id|force_object_loose
c_func
(paren
id|sha1
comma
id|p-&gt;mtime
)paren
)paren
id|die
c_func
(paren
l_string|&quot;unable to force loose object&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * This tracks any options which a reader of the pack might&n; * not understand, and which would therefore prevent blind reuse&n; * of what we have on disk.&n; */
DECL|function|pack_options_allow_reuse
r_static
r_int
id|pack_options_allow_reuse
c_func
(paren
r_void
)paren
(brace
r_return
id|allow_ofs_delta
suffix:semicolon
)brace
DECL|function|get_object_list_from_bitmap
r_static
r_int
id|get_object_list_from_bitmap
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
)paren
(brace
r_if
c_cond
(paren
id|prepare_bitmap_walk
c_func
(paren
id|revs
)paren
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|pack_options_allow_reuse
c_func
(paren
)paren
op_logical_and
op_logical_neg
id|reuse_partial_packfile_from_bitmap
c_func
(paren
op_amp
id|reuse_packfile
comma
op_amp
id|reuse_packfile_objects
comma
op_amp
id|reuse_packfile_offset
)paren
)paren
(brace
m_assert
(paren
id|reuse_packfile_objects
)paren
suffix:semicolon
id|nr_result
op_add_assign
id|reuse_packfile_objects
suffix:semicolon
id|display_progress
c_func
(paren
id|progress_state
comma
id|nr_result
)paren
suffix:semicolon
)brace
id|traverse_bitmap_commit_list
c_func
(paren
op_amp
id|add_object_entry_from_bitmap
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|record_recent_object
r_static
r_void
id|record_recent_object
c_func
(paren
r_struct
id|object
op_star
id|obj
comma
r_const
r_struct
id|name_path
op_star
id|path
comma
r_const
r_char
op_star
id|last
comma
r_void
op_star
id|data
)paren
(brace
id|sha1_array_append
c_func
(paren
op_amp
id|recent_objects
comma
id|obj-&gt;sha1
)paren
suffix:semicolon
)brace
DECL|function|record_recent_commit
r_static
r_void
id|record_recent_commit
c_func
(paren
r_struct
id|commit
op_star
id|commit
comma
r_void
op_star
id|data
)paren
(brace
id|sha1_array_append
c_func
(paren
op_amp
id|recent_objects
comma
id|commit-&gt;object.sha1
)paren
suffix:semicolon
)brace
DECL|function|get_object_list
r_static
r_void
id|get_object_list
c_func
(paren
r_int
id|ac
comma
r_const
r_char
op_star
op_star
id|av
)paren
(brace
r_struct
id|rev_info
id|revs
suffix:semicolon
r_char
id|line
(braket
l_int|1000
)braket
suffix:semicolon
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
id|init_revisions
c_func
(paren
op_amp
id|revs
comma
l_int|NULL
)paren
suffix:semicolon
id|save_commit_buffer
op_assign
l_int|0
suffix:semicolon
id|setup_revisions
c_func
(paren
id|ac
comma
id|av
comma
op_amp
id|revs
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* make sure shallows are read */
id|is_repository_shallow
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|fgets
c_func
(paren
id|line
comma
r_sizeof
(paren
id|line
)paren
comma
id|stdin
)paren
op_ne
l_int|NULL
)paren
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|line
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_logical_and
id|line
(braket
id|len
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|line
(braket
op_decrement
id|len
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_star
id|line
op_eq
l_char|&squot;-&squot;
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|line
comma
l_string|&quot;--not&quot;
)paren
)paren
(brace
id|flags
op_xor_assign
id|UNINTERESTING
suffix:semicolon
id|write_bitmap_index
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|line
comma
l_string|&quot;--shallow &quot;
)paren
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|line
op_plus
l_int|10
comma
id|sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;not an SHA-1 &squot;%s&squot;&quot;
comma
id|line
op_plus
l_int|10
)paren
suffix:semicolon
id|register_shallow
c_func
(paren
id|sha1
)paren
suffix:semicolon
id|use_bitmap_index
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|die
c_func
(paren
l_string|&quot;not a rev &squot;%s&squot;&quot;
comma
id|line
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|handle_revision_arg
c_func
(paren
id|line
comma
op_amp
id|revs
comma
id|flags
comma
id|REVARG_CANNOT_BE_FILENAME
)paren
)paren
id|die
c_func
(paren
l_string|&quot;bad revision &squot;%s&squot;&quot;
comma
id|line
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|use_bitmap_index
op_logical_and
op_logical_neg
id|get_object_list_from_bitmap
c_func
(paren
op_amp
id|revs
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|prepare_revision_walk
c_func
(paren
op_amp
id|revs
)paren
)paren
id|die
c_func
(paren
l_string|&quot;revision walk setup failed&quot;
)paren
suffix:semicolon
id|mark_edges_uninteresting
c_func
(paren
op_amp
id|revs
comma
id|show_edge
)paren
suffix:semicolon
id|traverse_commit_list
c_func
(paren
op_amp
id|revs
comma
id|show_commit
comma
id|show_object
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unpack_unreachable_expiration
)paren
(brace
id|revs.ignore_missing_links
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|add_unseen_recent_objects_to_traversal
c_func
(paren
op_amp
id|revs
comma
id|unpack_unreachable_expiration
)paren
)paren
id|die
c_func
(paren
l_string|&quot;unable to add recent objects&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prepare_revision_walk
c_func
(paren
op_amp
id|revs
)paren
)paren
id|die
c_func
(paren
l_string|&quot;revision walk setup failed&quot;
)paren
suffix:semicolon
id|traverse_commit_list
c_func
(paren
op_amp
id|revs
comma
id|record_recent_commit
comma
id|record_recent_object
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|keep_unreachable
)paren
id|add_objects_in_unpacked_packs
c_func
(paren
op_amp
id|revs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unpack_unreachable
)paren
id|loosen_unused_packed_objects
c_func
(paren
op_amp
id|revs
)paren
suffix:semicolon
id|sha1_array_clear
c_func
(paren
op_amp
id|recent_objects
)paren
suffix:semicolon
)brace
DECL|function|option_parse_index_version
r_static
r_int
id|option_parse_index_version
c_func
(paren
r_const
r_struct
id|option
op_star
id|opt
comma
r_const
r_char
op_star
id|arg
comma
r_int
id|unset
)paren
(brace
r_char
op_star
id|c
suffix:semicolon
r_const
r_char
op_star
id|val
op_assign
id|arg
suffix:semicolon
id|pack_idx_opts.version
op_assign
id|strtoul
c_func
(paren
id|val
comma
op_amp
id|c
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pack_idx_opts.version
OG
l_int|2
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;unsupported index version %s&quot;
)paren
comma
id|val
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|c
op_eq
l_char|&squot;,&squot;
op_logical_and
id|c
(braket
l_int|1
)braket
)paren
id|pack_idx_opts.off32_limit
op_assign
id|strtoul
c_func
(paren
id|c
op_plus
l_int|1
comma
op_amp
id|c
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|c
op_logical_or
id|pack_idx_opts.off32_limit
op_amp
l_int|0x80000000
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;bad index version &squot;%s&squot;&quot;
)paren
comma
id|val
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|option_parse_unpack_unreachable
r_static
r_int
id|option_parse_unpack_unreachable
c_func
(paren
r_const
r_struct
id|option
op_star
id|opt
comma
r_const
r_char
op_star
id|arg
comma
r_int
id|unset
)paren
(brace
r_if
c_cond
(paren
id|unset
)paren
(brace
id|unpack_unreachable
op_assign
l_int|0
suffix:semicolon
id|unpack_unreachable_expiration
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|unpack_unreachable
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|arg
)paren
id|unpack_unreachable_expiration
op_assign
id|approxidate
c_func
(paren
id|arg
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cmd_pack_objects
r_int
id|cmd_pack_objects
c_func
(paren
r_int
id|argc
comma
r_const
r_char
op_star
op_star
id|argv
comma
r_const
r_char
op_star
id|prefix
)paren
(brace
r_int
id|use_internal_rev_list
op_assign
l_int|0
suffix:semicolon
r_int
id|thin
op_assign
l_int|0
suffix:semicolon
r_int
id|shallow
op_assign
l_int|0
suffix:semicolon
r_int
id|all_progress_implied
op_assign
l_int|0
suffix:semicolon
r_struct
id|argv_array
id|rp
op_assign
id|ARGV_ARRAY_INIT
suffix:semicolon
r_int
id|rev_list_unpacked
op_assign
l_int|0
comma
id|rev_list_all
op_assign
l_int|0
comma
id|rev_list_reflog
op_assign
l_int|0
suffix:semicolon
r_int
id|rev_list_index
op_assign
l_int|0
suffix:semicolon
r_struct
id|option
id|pack_objects_options
(braket
)braket
op_assign
(brace
id|OPT_SET_INT
c_func
(paren
l_char|&squot;q&squot;
comma
l_string|&quot;quiet&quot;
comma
op_amp
id|progress
comma
id|N_
c_func
(paren
l_string|&quot;do not show progress meter&quot;
)paren
comma
l_int|0
)paren
comma
id|OPT_SET_INT
c_func
(paren
l_int|0
comma
l_string|&quot;progress&quot;
comma
op_amp
id|progress
comma
id|N_
c_func
(paren
l_string|&quot;show progress meter&quot;
)paren
comma
l_int|1
)paren
comma
id|OPT_SET_INT
c_func
(paren
l_int|0
comma
l_string|&quot;all-progress&quot;
comma
op_amp
id|progress
comma
id|N_
c_func
(paren
l_string|&quot;show progress meter during object writing phase&quot;
)paren
comma
l_int|2
)paren
comma
id|OPT_BOOL
c_func
(paren
l_int|0
comma
l_string|&quot;all-progress-implied&quot;
comma
op_amp
id|all_progress_implied
comma
id|N_
c_func
(paren
l_string|&quot;similar to --all-progress when progress meter is shown&quot;
)paren
)paren
comma
(brace
id|OPTION_CALLBACK
comma
l_int|0
comma
l_string|&quot;index-version&quot;
comma
l_int|NULL
comma
id|N_
c_func
(paren
l_string|&quot;version[,offset]&quot;
)paren
comma
id|N_
c_func
(paren
l_string|&quot;write the pack index file in the specified idx format version&quot;
)paren
comma
l_int|0
comma
id|option_parse_index_version
)brace
comma
id|OPT_MAGNITUDE
c_func
(paren
l_int|0
comma
l_string|&quot;max-pack-size&quot;
comma
op_amp
id|pack_size_limit
comma
id|N_
c_func
(paren
l_string|&quot;maximum size of each output pack file&quot;
)paren
)paren
comma
id|OPT_BOOL
c_func
(paren
l_int|0
comma
l_string|&quot;local&quot;
comma
op_amp
id|local
comma
id|N_
c_func
(paren
l_string|&quot;ignore borrowed objects from alternate object store&quot;
)paren
)paren
comma
id|OPT_BOOL
c_func
(paren
l_int|0
comma
l_string|&quot;incremental&quot;
comma
op_amp
id|incremental
comma
id|N_
c_func
(paren
l_string|&quot;ignore packed objects&quot;
)paren
)paren
comma
id|OPT_INTEGER
c_func
(paren
l_int|0
comma
l_string|&quot;window&quot;
comma
op_amp
id|window
comma
id|N_
c_func
(paren
l_string|&quot;limit pack window by objects&quot;
)paren
)paren
comma
id|OPT_MAGNITUDE
c_func
(paren
l_int|0
comma
l_string|&quot;window-memory&quot;
comma
op_amp
id|window_memory_limit
comma
id|N_
c_func
(paren
l_string|&quot;limit pack window by memory in addition to object limit&quot;
)paren
)paren
comma
id|OPT_INTEGER
c_func
(paren
l_int|0
comma
l_string|&quot;depth&quot;
comma
op_amp
id|depth
comma
id|N_
c_func
(paren
l_string|&quot;maximum length of delta chain allowed in the resulting pack&quot;
)paren
)paren
comma
id|OPT_BOOL
c_func
(paren
l_int|0
comma
l_string|&quot;reuse-delta&quot;
comma
op_amp
id|reuse_delta
comma
id|N_
c_func
(paren
l_string|&quot;reuse existing deltas&quot;
)paren
)paren
comma
id|OPT_BOOL
c_func
(paren
l_int|0
comma
l_string|&quot;reuse-object&quot;
comma
op_amp
id|reuse_object
comma
id|N_
c_func
(paren
l_string|&quot;reuse existing objects&quot;
)paren
)paren
comma
id|OPT_BOOL
c_func
(paren
l_int|0
comma
l_string|&quot;delta-base-offset&quot;
comma
op_amp
id|allow_ofs_delta
comma
id|N_
c_func
(paren
l_string|&quot;use OFS_DELTA objects&quot;
)paren
)paren
comma
id|OPT_INTEGER
c_func
(paren
l_int|0
comma
l_string|&quot;threads&quot;
comma
op_amp
id|delta_search_threads
comma
id|N_
c_func
(paren
l_string|&quot;use threads when searching for best delta matches&quot;
)paren
)paren
comma
id|OPT_BOOL
c_func
(paren
l_int|0
comma
l_string|&quot;non-empty&quot;
comma
op_amp
id|non_empty
comma
id|N_
c_func
(paren
l_string|&quot;do not create an empty pack output&quot;
)paren
)paren
comma
id|OPT_BOOL
c_func
(paren
l_int|0
comma
l_string|&quot;revs&quot;
comma
op_amp
id|use_internal_rev_list
comma
id|N_
c_func
(paren
l_string|&quot;read revision arguments from standard input&quot;
)paren
)paren
comma
(brace
id|OPTION_SET_INT
comma
l_int|0
comma
l_string|&quot;unpacked&quot;
comma
op_amp
id|rev_list_unpacked
comma
l_int|NULL
comma
id|N_
c_func
(paren
l_string|&quot;limit the objects to those that are not yet packed&quot;
)paren
comma
id|PARSE_OPT_NOARG
op_or
id|PARSE_OPT_NONEG
comma
l_int|NULL
comma
l_int|1
)brace
comma
(brace
id|OPTION_SET_INT
comma
l_int|0
comma
l_string|&quot;all&quot;
comma
op_amp
id|rev_list_all
comma
l_int|NULL
comma
id|N_
c_func
(paren
l_string|&quot;include objects reachable from any reference&quot;
)paren
comma
id|PARSE_OPT_NOARG
op_or
id|PARSE_OPT_NONEG
comma
l_int|NULL
comma
l_int|1
)brace
comma
(brace
id|OPTION_SET_INT
comma
l_int|0
comma
l_string|&quot;reflog&quot;
comma
op_amp
id|rev_list_reflog
comma
l_int|NULL
comma
id|N_
c_func
(paren
l_string|&quot;include objects referred by reflog entries&quot;
)paren
comma
id|PARSE_OPT_NOARG
op_or
id|PARSE_OPT_NONEG
comma
l_int|NULL
comma
l_int|1
)brace
comma
(brace
id|OPTION_SET_INT
comma
l_int|0
comma
l_string|&quot;indexed-objects&quot;
comma
op_amp
id|rev_list_index
comma
l_int|NULL
comma
id|N_
c_func
(paren
l_string|&quot;include objects referred to by the index&quot;
)paren
comma
id|PARSE_OPT_NOARG
op_or
id|PARSE_OPT_NONEG
comma
l_int|NULL
comma
l_int|1
)brace
comma
id|OPT_BOOL
c_func
(paren
l_int|0
comma
l_string|&quot;stdout&quot;
comma
op_amp
id|pack_to_stdout
comma
id|N_
c_func
(paren
l_string|&quot;output pack to stdout&quot;
)paren
)paren
comma
id|OPT_BOOL
c_func
(paren
l_int|0
comma
l_string|&quot;include-tag&quot;
comma
op_amp
id|include_tag
comma
id|N_
c_func
(paren
l_string|&quot;include tag objects that refer to objects to be packed&quot;
)paren
)paren
comma
id|OPT_BOOL
c_func
(paren
l_int|0
comma
l_string|&quot;keep-unreachable&quot;
comma
op_amp
id|keep_unreachable
comma
id|N_
c_func
(paren
l_string|&quot;keep unreachable objects&quot;
)paren
)paren
comma
(brace
id|OPTION_CALLBACK
comma
l_int|0
comma
l_string|&quot;unpack-unreachable&quot;
comma
l_int|NULL
comma
id|N_
c_func
(paren
l_string|&quot;time&quot;
)paren
comma
id|N_
c_func
(paren
l_string|&quot;unpack unreachable objects newer than &lt;time&gt;&quot;
)paren
comma
id|PARSE_OPT_OPTARG
comma
id|option_parse_unpack_unreachable
)brace
comma
id|OPT_BOOL
c_func
(paren
l_int|0
comma
l_string|&quot;thin&quot;
comma
op_amp
id|thin
comma
id|N_
c_func
(paren
l_string|&quot;create thin packs&quot;
)paren
)paren
comma
id|OPT_BOOL
c_func
(paren
l_int|0
comma
l_string|&quot;shallow&quot;
comma
op_amp
id|shallow
comma
id|N_
c_func
(paren
l_string|&quot;create packs suitable for shallow fetches&quot;
)paren
)paren
comma
id|OPT_BOOL
c_func
(paren
l_int|0
comma
l_string|&quot;honor-pack-keep&quot;
comma
op_amp
id|ignore_packed_keep
comma
id|N_
c_func
(paren
l_string|&quot;ignore packs that have companion .keep file&quot;
)paren
)paren
comma
id|OPT_INTEGER
c_func
(paren
l_int|0
comma
l_string|&quot;compression&quot;
comma
op_amp
id|pack_compression_level
comma
id|N_
c_func
(paren
l_string|&quot;pack compression level&quot;
)paren
)paren
comma
id|OPT_SET_INT
c_func
(paren
l_int|0
comma
l_string|&quot;keep-true-parents&quot;
comma
op_amp
id|grafts_replace_parents
comma
id|N_
c_func
(paren
l_string|&quot;do not hide commits by grafts&quot;
)paren
comma
l_int|0
)paren
comma
id|OPT_BOOL
c_func
(paren
l_int|0
comma
l_string|&quot;use-bitmap-index&quot;
comma
op_amp
id|use_bitmap_index
comma
id|N_
c_func
(paren
l_string|&quot;use a bitmap index if available to speed up counting objects&quot;
)paren
)paren
comma
id|OPT_BOOL
c_func
(paren
l_int|0
comma
l_string|&quot;write-bitmap-index&quot;
comma
op_amp
id|write_bitmap_index
comma
id|N_
c_func
(paren
l_string|&quot;write a bitmap index together with the pack index&quot;
)paren
)paren
comma
id|OPT_END
c_func
(paren
)paren
comma
)brace
suffix:semicolon
id|check_replace_refs
op_assign
l_int|0
suffix:semicolon
id|reset_pack_idx_option
c_func
(paren
op_amp
id|pack_idx_opts
)paren
suffix:semicolon
id|git_config
c_func
(paren
id|git_pack_config
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pack_compression_seen
op_logical_and
id|core_compression_seen
)paren
id|pack_compression_level
op_assign
id|core_compression_level
suffix:semicolon
id|progress
op_assign
id|isatty
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|argc
op_assign
id|parse_options
c_func
(paren
id|argc
comma
id|argv
comma
id|prefix
comma
id|pack_objects_options
comma
id|pack_usage
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|argc
)paren
(brace
id|base_name
op_assign
id|argv
(braket
l_int|0
)braket
suffix:semicolon
id|argc
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pack_to_stdout
op_ne
op_logical_neg
id|base_name
op_logical_or
id|argc
)paren
id|usage_with_options
c_func
(paren
id|pack_usage
comma
id|pack_objects_options
)paren
suffix:semicolon
id|argv_array_push
c_func
(paren
op_amp
id|rp
comma
l_string|&quot;pack-objects&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|thin
)paren
(brace
id|use_internal_rev_list
op_assign
l_int|1
suffix:semicolon
id|argv_array_push
c_func
(paren
op_amp
id|rp
comma
id|shallow
ques
c_cond
l_string|&quot;--objects-edge-aggressive&quot;
suffix:colon
l_string|&quot;--objects-edge&quot;
)paren
suffix:semicolon
)brace
r_else
id|argv_array_push
c_func
(paren
op_amp
id|rp
comma
l_string|&quot;--objects&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rev_list_all
)paren
(brace
id|use_internal_rev_list
op_assign
l_int|1
suffix:semicolon
id|argv_array_push
c_func
(paren
op_amp
id|rp
comma
l_string|&quot;--all&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rev_list_reflog
)paren
(brace
id|use_internal_rev_list
op_assign
l_int|1
suffix:semicolon
id|argv_array_push
c_func
(paren
op_amp
id|rp
comma
l_string|&quot;--reflog&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rev_list_index
)paren
(brace
id|use_internal_rev_list
op_assign
l_int|1
suffix:semicolon
id|argv_array_push
c_func
(paren
op_amp
id|rp
comma
l_string|&quot;--indexed-objects&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rev_list_unpacked
)paren
(brace
id|use_internal_rev_list
op_assign
l_int|1
suffix:semicolon
id|argv_array_push
c_func
(paren
op_amp
id|rp
comma
l_string|&quot;--unpacked&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|reuse_object
)paren
id|reuse_delta
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pack_compression_level
op_eq
l_int|1
)paren
id|pack_compression_level
op_assign
id|Z_DEFAULT_COMPRESSION
suffix:semicolon
r_else
r_if
c_cond
(paren
id|pack_compression_level
template_param
id|Z_BEST_COMPRESSION
)paren
id|die
c_func
(paren
l_string|&quot;bad pack compression level %d&quot;
comma
id|pack_compression_level
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|delta_search_threads
)paren
multiline_comment|/* --threads=0 means autodetect */
id|delta_search_threads
op_assign
id|online_cpus
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef NO_PTHREADS
r_if
c_cond
(paren
id|delta_search_threads
op_ne
l_int|1
)paren
id|warning
c_func
(paren
l_string|&quot;no threads support, ignoring --threads&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|pack_to_stdout
op_logical_and
op_logical_neg
id|pack_size_limit
)paren
id|pack_size_limit
op_assign
id|pack_size_limit_cfg
suffix:semicolon
r_if
c_cond
(paren
id|pack_to_stdout
op_logical_and
id|pack_size_limit
)paren
id|die
c_func
(paren
l_string|&quot;--max-pack-size cannot be used to build a pack for transfer.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pack_size_limit
op_logical_and
id|pack_size_limit
OL
l_int|1024
op_star
l_int|1024
)paren
(brace
id|warning
c_func
(paren
l_string|&quot;minimum pack size limit is 1 MiB&quot;
)paren
suffix:semicolon
id|pack_size_limit
op_assign
l_int|1024
op_star
l_int|1024
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|pack_to_stdout
op_logical_and
id|thin
)paren
id|die
c_func
(paren
l_string|&quot;--thin cannot be used to build an indexable pack.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|keep_unreachable
op_logical_and
id|unpack_unreachable
)paren
id|die
c_func
(paren
l_string|&quot;--keep-unreachable and --unpack-unreachable are incompatible.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rev_list_all
op_logical_or
op_logical_neg
id|rev_list_reflog
op_logical_or
op_logical_neg
id|rev_list_index
)paren
id|unpack_unreachable_expiration
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|use_internal_rev_list
op_logical_or
op_logical_neg
id|pack_to_stdout
op_logical_or
id|is_repository_shallow
c_func
(paren
)paren
)paren
id|use_bitmap_index
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pack_to_stdout
op_logical_or
op_logical_neg
id|rev_list_all
)paren
id|write_bitmap_index
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|progress
op_logical_and
id|all_progress_implied
)paren
id|progress
op_assign
l_int|2
suffix:semicolon
id|prepare_packed_git
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|progress
)paren
id|progress_state
op_assign
id|start_progress
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Counting objects&quot;
)paren
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|use_internal_rev_list
)paren
id|read_object_list_from_stdin
c_func
(paren
)paren
suffix:semicolon
r_else
(brace
id|get_object_list
c_func
(paren
id|rp.argc
comma
id|rp.argv
)paren
suffix:semicolon
id|argv_array_clear
c_func
(paren
op_amp
id|rp
)paren
suffix:semicolon
)brace
id|cleanup_preferred_base
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|include_tag
op_logical_and
id|nr_result
)paren
id|for_each_ref
c_func
(paren
id|add_ref_tag
comma
l_int|NULL
)paren
suffix:semicolon
id|stop_progress
c_func
(paren
op_amp
id|progress_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|non_empty
op_logical_and
op_logical_neg
id|nr_result
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|nr_result
)paren
id|prepare_pack
c_func
(paren
id|window
comma
id|depth
)paren
suffix:semicolon
id|write_pack_file
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|progress
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Total %&quot;
id|PRIu32
l_string|&quot; (delta %&quot;
id|PRIu32
l_string|&quot;),&quot;
l_string|&quot; reused %&quot;
id|PRIu32
l_string|&quot; (delta %&quot;
id|PRIu32
l_string|&quot;)&bslash;n&quot;
comma
id|written
comma
id|written_delta
comma
id|reused
comma
id|reused_delta
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
