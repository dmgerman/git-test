macro_line|#include &quot;builtin.h&quot;
macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;attr.h&quot;
macro_line|#include &quot;object.h&quot;
macro_line|#include &quot;blob.h&quot;
macro_line|#include &quot;commit.h&quot;
macro_line|#include &quot;tag.h&quot;
macro_line|#include &quot;tree.h&quot;
macro_line|#include &quot;delta.h&quot;
macro_line|#include &quot;pack.h&quot;
macro_line|#include &quot;pack-revindex.h&quot;
macro_line|#include &quot;csum-file.h&quot;
macro_line|#include &quot;tree-walk.h&quot;
macro_line|#include &quot;diff.h&quot;
macro_line|#include &quot;revision.h&quot;
macro_line|#include &quot;list-objects.h&quot;
macro_line|#include &quot;progress.h&quot;
macro_line|#include &quot;refs.h&quot;
macro_line|#include &quot;thread-utils.h&quot;
DECL|variable|pack_usage
r_static
r_const
r_char
id|pack_usage
(braket
)braket
op_assign
l_string|&quot;git pack-objects [ -q | --progress | --all-progress ]&bslash;n&quot;
l_string|&quot;        [--all-progress-implied]&bslash;n&quot;
l_string|&quot;        [--max-pack-size=&lt;n&gt;] [--local] [--incremental]&bslash;n&quot;
l_string|&quot;        [--window=&lt;n&gt;] [--window-memory=&lt;n&gt;] [--depth=&lt;n&gt;]&bslash;n&quot;
l_string|&quot;        [--no-reuse-delta] [--no-reuse-object] [--delta-base-offset]&bslash;n&quot;
l_string|&quot;        [--threads=&lt;n&gt;] [--non-empty] [--revs [--unpacked | --all]]&bslash;n&quot;
l_string|&quot;        [--reflog] [--stdout | base-name] [--include-tag]&bslash;n&quot;
l_string|&quot;        [--keep-unreachable | --unpack-unreachable]&bslash;n&quot;
l_string|&quot;        [&lt; ref-list | &lt; object-list]&quot;
suffix:semicolon
DECL|struct|object_entry
r_struct
id|object_entry
(brace
DECL|member|idx
r_struct
id|pack_idx_entry
id|idx
suffix:semicolon
DECL|member|size
r_int
r_int
id|size
suffix:semicolon
multiline_comment|/* uncompressed size */
DECL|member|in_pack
r_struct
id|packed_git
op_star
id|in_pack
suffix:semicolon
multiline_comment|/* already in pack */
DECL|member|in_pack_offset
id|off_t
id|in_pack_offset
suffix:semicolon
DECL|member|delta
r_struct
id|object_entry
op_star
id|delta
suffix:semicolon
multiline_comment|/* delta base object */
DECL|member|delta_child
r_struct
id|object_entry
op_star
id|delta_child
suffix:semicolon
multiline_comment|/* deltified objects who bases me */
DECL|member|delta_sibling
r_struct
id|object_entry
op_star
id|delta_sibling
suffix:semicolon
multiline_comment|/* other deltified objects who&n;&t;&t;&t;&t;&t;     * uses the same base as me&n;&t;&t;&t;&t;&t;     */
DECL|member|delta_data
r_void
op_star
id|delta_data
suffix:semicolon
multiline_comment|/* cached delta (uncompressed) */
DECL|member|delta_size
r_int
r_int
id|delta_size
suffix:semicolon
multiline_comment|/* delta data size (uncompressed) */
DECL|member|z_delta_size
r_int
r_int
id|z_delta_size
suffix:semicolon
multiline_comment|/* delta data size (compressed) */
DECL|member|hash
r_int
r_int
id|hash
suffix:semicolon
multiline_comment|/* name hint hash */
DECL|member|type
r_enum
id|object_type
id|type
suffix:semicolon
DECL|member|in_pack_type
r_enum
id|object_type
id|in_pack_type
suffix:semicolon
multiline_comment|/* could be delta */
DECL|member|in_pack_header_size
r_int
r_char
id|in_pack_header_size
suffix:semicolon
DECL|member|preferred_base
r_int
r_char
id|preferred_base
suffix:semicolon
multiline_comment|/* we do not pack this, but is available&n;&t;&t;&t;&t;       * to be used as the base object to delta&n;&t;&t;&t;&t;       * objects against.&n;&t;&t;&t;&t;       */
DECL|member|no_try_delta
r_int
r_char
id|no_try_delta
suffix:semicolon
DECL|member|tagged
r_int
r_char
id|tagged
suffix:semicolon
multiline_comment|/* near the very tip of refs */
DECL|member|filled
r_int
r_char
id|filled
suffix:semicolon
multiline_comment|/* assigned write-order */
)brace
suffix:semicolon
multiline_comment|/*&n; * Objects we are going to pack are collected in objects array (dynamically&n; * expanded).  nr_objects &amp; nr_alloc controls this array.  They are stored&n; * in the order we see -- typically rev-list --objects order that gives us&n; * nice &quot;minimum seek&quot; order.&n; */
DECL|variable|objects
r_static
r_struct
id|object_entry
op_star
id|objects
suffix:semicolon
DECL|variable|written_list
r_static
r_struct
id|pack_idx_entry
op_star
op_star
id|written_list
suffix:semicolon
DECL|variable|nr_objects
DECL|variable|nr_alloc
DECL|variable|nr_result
DECL|variable|nr_written
r_static
r_uint32
id|nr_objects
comma
id|nr_alloc
comma
id|nr_result
comma
id|nr_written
suffix:semicolon
DECL|variable|non_empty
r_static
r_int
id|non_empty
suffix:semicolon
DECL|variable|reuse_delta
DECL|variable|reuse_object
r_static
r_int
id|reuse_delta
op_assign
l_int|1
comma
id|reuse_object
op_assign
l_int|1
suffix:semicolon
DECL|variable|keep_unreachable
DECL|variable|unpack_unreachable
DECL|variable|include_tag
r_static
r_int
id|keep_unreachable
comma
id|unpack_unreachable
comma
id|include_tag
suffix:semicolon
DECL|variable|local
r_static
r_int
id|local
suffix:semicolon
DECL|variable|incremental
r_static
r_int
id|incremental
suffix:semicolon
DECL|variable|ignore_packed_keep
r_static
r_int
id|ignore_packed_keep
suffix:semicolon
DECL|variable|allow_ofs_delta
r_static
r_int
id|allow_ofs_delta
suffix:semicolon
DECL|variable|pack_idx_opts
r_static
r_struct
id|pack_idx_option
id|pack_idx_opts
suffix:semicolon
DECL|variable|base_name
r_static
r_const
r_char
op_star
id|base_name
suffix:semicolon
DECL|variable|progress
r_static
r_int
id|progress
op_assign
l_int|1
suffix:semicolon
DECL|variable|window
r_static
r_int
id|window
op_assign
l_int|10
suffix:semicolon
DECL|variable|pack_size_limit
DECL|variable|pack_size_limit_cfg
r_static
r_int
r_int
id|pack_size_limit
comma
id|pack_size_limit_cfg
suffix:semicolon
DECL|variable|depth
r_static
r_int
id|depth
op_assign
l_int|50
suffix:semicolon
DECL|variable|delta_search_threads
r_static
r_int
id|delta_search_threads
suffix:semicolon
DECL|variable|pack_to_stdout
r_static
r_int
id|pack_to_stdout
suffix:semicolon
DECL|variable|num_preferred_base
r_static
r_int
id|num_preferred_base
suffix:semicolon
DECL|variable|progress_state
r_static
r_struct
id|progress
op_star
id|progress_state
suffix:semicolon
DECL|variable|pack_compression_level
r_static
r_int
id|pack_compression_level
op_assign
id|Z_DEFAULT_COMPRESSION
suffix:semicolon
DECL|variable|pack_compression_seen
r_static
r_int
id|pack_compression_seen
suffix:semicolon
DECL|variable|delta_cache_size
r_static
r_int
r_int
id|delta_cache_size
op_assign
l_int|0
suffix:semicolon
DECL|variable|max_delta_cache_size
r_static
r_int
r_int
id|max_delta_cache_size
op_assign
l_int|256
op_star
l_int|1024
op_star
l_int|1024
suffix:semicolon
DECL|variable|cache_max_small_delta_size
r_static
r_int
r_int
id|cache_max_small_delta_size
op_assign
l_int|1000
suffix:semicolon
DECL|variable|window_memory_limit
r_static
r_int
r_int
id|window_memory_limit
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * The object names in objects array are hashed with this hashtable,&n; * to help looking up the entry by object name.&n; * This hashtable is built after all the objects are seen.&n; */
DECL|variable|object_ix
r_static
r_int
op_star
id|object_ix
suffix:semicolon
DECL|variable|object_ix_hashsz
r_static
r_int
id|object_ix_hashsz
suffix:semicolon
r_static
r_struct
id|object_entry
op_star
id|locate_object_entry
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
)paren
suffix:semicolon
multiline_comment|/*&n; * stats&n; */
DECL|variable|written
DECL|variable|written_delta
r_static
r_uint32
id|written
comma
id|written_delta
suffix:semicolon
DECL|variable|reused
DECL|variable|reused_delta
r_static
r_uint32
id|reused
comma
id|reused_delta
suffix:semicolon
DECL|function|get_delta
r_static
r_void
op_star
id|get_delta
c_func
(paren
r_struct
id|object_entry
op_star
id|entry
)paren
(brace
r_int
r_int
id|size
comma
id|base_size
comma
id|delta_size
suffix:semicolon
r_void
op_star
id|buf
comma
op_star
id|base_buf
comma
op_star
id|delta_buf
suffix:semicolon
r_enum
id|object_type
id|type
suffix:semicolon
id|buf
op_assign
id|read_sha1_file
c_func
(paren
id|entry-&gt;idx.sha1
comma
op_amp
id|type
comma
op_amp
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
id|die
c_func
(paren
l_string|&quot;unable to read %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|entry-&gt;idx.sha1
)paren
)paren
suffix:semicolon
id|base_buf
op_assign
id|read_sha1_file
c_func
(paren
id|entry-&gt;delta-&gt;idx.sha1
comma
op_amp
id|type
comma
op_amp
id|base_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|base_buf
)paren
id|die
c_func
(paren
l_string|&quot;unable to read %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|entry-&gt;delta-&gt;idx.sha1
)paren
)paren
suffix:semicolon
id|delta_buf
op_assign
id|diff_delta
c_func
(paren
id|base_buf
comma
id|base_size
comma
id|buf
comma
id|size
comma
op_amp
id|delta_size
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|delta_buf
op_logical_or
id|delta_size
op_ne
id|entry-&gt;delta_size
)paren
id|die
c_func
(paren
l_string|&quot;delta size changed&quot;
)paren
suffix:semicolon
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
id|free
c_func
(paren
id|base_buf
)paren
suffix:semicolon
r_return
id|delta_buf
suffix:semicolon
)brace
DECL|function|do_compress
r_static
r_int
r_int
id|do_compress
c_func
(paren
r_void
op_star
op_star
id|pptr
comma
r_int
r_int
id|size
)paren
(brace
id|git_zstream
id|stream
suffix:semicolon
r_void
op_star
id|in
comma
op_star
id|out
suffix:semicolon
r_int
r_int
id|maxsize
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|stream
comma
l_int|0
comma
r_sizeof
(paren
id|stream
)paren
)paren
suffix:semicolon
id|git_deflate_init
c_func
(paren
op_amp
id|stream
comma
id|pack_compression_level
)paren
suffix:semicolon
id|maxsize
op_assign
id|git_deflate_bound
c_func
(paren
op_amp
id|stream
comma
id|size
)paren
suffix:semicolon
id|in
op_assign
op_star
id|pptr
suffix:semicolon
id|out
op_assign
id|xmalloc
c_func
(paren
id|maxsize
)paren
suffix:semicolon
op_star
id|pptr
op_assign
id|out
suffix:semicolon
id|stream.next_in
op_assign
id|in
suffix:semicolon
id|stream.avail_in
op_assign
id|size
suffix:semicolon
id|stream.next_out
op_assign
id|out
suffix:semicolon
id|stream.avail_out
op_assign
id|maxsize
suffix:semicolon
r_while
c_loop
(paren
id|git_deflate
c_func
(paren
op_amp
id|stream
comma
id|Z_FINISH
)paren
op_eq
id|Z_OK
)paren
suffix:semicolon
multiline_comment|/* nothing */
id|git_deflate_end
c_func
(paren
op_amp
id|stream
)paren
suffix:semicolon
id|free
c_func
(paren
id|in
)paren
suffix:semicolon
r_return
id|stream.total_out
suffix:semicolon
)brace
multiline_comment|/*&n; * we are going to reuse the existing object data as is.  make&n; * sure it is not corrupt.&n; */
DECL|function|check_pack_inflate
r_static
r_int
id|check_pack_inflate
c_func
(paren
r_struct
id|packed_git
op_star
id|p
comma
r_struct
id|pack_window
op_star
op_star
id|w_curs
comma
id|off_t
id|offset
comma
id|off_t
id|len
comma
r_int
r_int
id|expect
)paren
(brace
id|git_zstream
id|stream
suffix:semicolon
r_int
r_char
id|fakebuf
(braket
l_int|4096
)braket
comma
op_star
id|in
suffix:semicolon
r_int
id|st
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|stream
comma
l_int|0
comma
r_sizeof
(paren
id|stream
)paren
)paren
suffix:semicolon
id|git_inflate_init
c_func
(paren
op_amp
id|stream
)paren
suffix:semicolon
r_do
(brace
id|in
op_assign
id|use_pack
c_func
(paren
id|p
comma
id|w_curs
comma
id|offset
comma
op_amp
id|stream.avail_in
)paren
suffix:semicolon
id|stream.next_in
op_assign
id|in
suffix:semicolon
id|stream.next_out
op_assign
id|fakebuf
suffix:semicolon
id|stream.avail_out
op_assign
r_sizeof
(paren
id|fakebuf
)paren
suffix:semicolon
id|st
op_assign
id|git_inflate
c_func
(paren
op_amp
id|stream
comma
id|Z_FINISH
)paren
suffix:semicolon
id|offset
op_add_assign
id|stream.next_in
id|in
suffix:semicolon
)brace
r_while
c_loop
(paren
id|st
op_eq
id|Z_OK
op_logical_or
id|st
op_eq
id|Z_BUF_ERROR
)paren
suffix:semicolon
id|git_inflate_end
c_func
(paren
op_amp
id|stream
)paren
suffix:semicolon
r_return
(paren
id|st
op_eq
id|Z_STREAM_END
op_logical_and
id|stream.total_out
op_eq
id|expect
op_logical_and
id|stream.total_in
op_eq
id|len
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
)brace
DECL|function|copy_pack_data
r_static
r_void
id|copy_pack_data
c_func
(paren
r_struct
id|sha1file
op_star
id|f
comma
r_struct
id|packed_git
op_star
id|p
comma
r_struct
id|pack_window
op_star
op_star
id|w_curs
comma
id|off_t
id|offset
comma
id|off_t
id|len
)paren
(brace
r_int
r_char
op_star
id|in
suffix:semicolon
r_int
r_int
id|avail
suffix:semicolon
r_while
c_loop
(paren
id|len
)paren
(brace
id|in
op_assign
id|use_pack
c_func
(paren
id|p
comma
id|w_curs
comma
id|offset
comma
op_amp
id|avail
)paren
suffix:semicolon
r_if
c_cond
(paren
id|avail
OG
id|len
)paren
id|avail
op_assign
(paren
r_int
r_int
)paren
id|len
suffix:semicolon
id|sha1write
c_func
(paren
id|f
comma
id|in
comma
id|avail
)paren
suffix:semicolon
id|offset
op_add_assign
id|avail
suffix:semicolon
id|len
op_sub_assign
id|avail
suffix:semicolon
)brace
)brace
multiline_comment|/* Return 0 if we will bust the pack-size limit */
DECL|function|write_object
r_static
r_int
r_int
id|write_object
c_func
(paren
r_struct
id|sha1file
op_star
id|f
comma
r_struct
id|object_entry
op_star
id|entry
comma
id|off_t
id|write_offset
)paren
(brace
r_int
r_int
id|size
comma
id|limit
comma
id|datalen
suffix:semicolon
r_void
op_star
id|buf
suffix:semicolon
r_int
r_char
id|header
(braket
l_int|10
)braket
comma
id|dheader
(braket
l_int|10
)braket
suffix:semicolon
r_int
id|hdrlen
suffix:semicolon
r_enum
id|object_type
id|type
suffix:semicolon
r_int
id|usable_delta
comma
id|to_reuse
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pack_to_stdout
)paren
id|crc32_begin
c_func
(paren
id|f
)paren
suffix:semicolon
id|type
op_assign
id|entry-&gt;type
suffix:semicolon
multiline_comment|/* apply size limit if limited packsize and not first object */
r_if
c_cond
(paren
op_logical_neg
id|pack_size_limit
op_logical_or
op_logical_neg
id|nr_written
)paren
id|limit
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|pack_size_limit
op_le
id|write_offset
)paren
multiline_comment|/*&n;&t;&t; * the earlier object did not fit the limit; avoid&n;&t;&t; * mistaking this with unlimited (i.e. limit = 0).&n;&t;&t; */
id|limit
op_assign
l_int|1
suffix:semicolon
r_else
id|limit
op_assign
id|pack_size_limit
id|write_offset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;delta
)paren
id|usable_delta
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* no delta */
r_else
r_if
c_cond
(paren
op_logical_neg
id|pack_size_limit
)paren
id|usable_delta
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* unlimited packfile */
r_else
r_if
c_cond
(paren
id|entry-&gt;delta-&gt;idx.offset
op_eq
(paren
id|off_t
)paren
op_minus
l_int|1
)paren
id|usable_delta
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* base was written to another pack */
r_else
r_if
c_cond
(paren
id|entry-&gt;delta-&gt;idx.offset
)paren
id|usable_delta
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* base already exists in this pack */
r_else
id|usable_delta
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* base could end up in another pack */
r_if
c_cond
(paren
op_logical_neg
id|reuse_object
)paren
id|to_reuse
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* explicit */
r_else
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;in_pack
)paren
id|to_reuse
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* can&squot;t reuse what we don&squot;t have */
r_else
r_if
c_cond
(paren
id|type
op_eq
id|OBJ_REF_DELTA
op_logical_or
id|type
op_eq
id|OBJ_OFS_DELTA
)paren
multiline_comment|/* check_object() decided it for us ... */
id|to_reuse
op_assign
id|usable_delta
suffix:semicolon
multiline_comment|/* ... but pack split may override that */
r_else
r_if
c_cond
(paren
id|type
op_ne
id|entry-&gt;in_pack_type
)paren
id|to_reuse
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* pack has delta which is unusable */
r_else
r_if
c_cond
(paren
id|entry-&gt;delta
)paren
id|to_reuse
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* we want to pack afresh */
r_else
id|to_reuse
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* we have it in-pack undeltified,&n;&t;&t;&t;&t; * and we do not need to deltify it.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|to_reuse
)paren
(brace
id|no_reuse
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|usable_delta
)paren
(brace
id|buf
op_assign
id|read_sha1_file
c_func
(paren
id|entry-&gt;idx.sha1
comma
op_amp
id|type
comma
op_amp
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
id|die
c_func
(paren
l_string|&quot;unable to read %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|entry-&gt;idx.sha1
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * make sure no cached delta data remains from a&n;&t;&t;&t; * previous attempt before a pack split occurred.&n;&t;&t;&t; */
id|free
c_func
(paren
id|entry-&gt;delta_data
)paren
suffix:semicolon
id|entry-&gt;delta_data
op_assign
l_int|NULL
suffix:semicolon
id|entry-&gt;z_delta_size
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|entry-&gt;delta_data
)paren
(brace
id|size
op_assign
id|entry-&gt;delta_size
suffix:semicolon
id|buf
op_assign
id|entry-&gt;delta_data
suffix:semicolon
id|entry-&gt;delta_data
op_assign
l_int|NULL
suffix:semicolon
id|type
op_assign
(paren
id|allow_ofs_delta
op_logical_and
id|entry-&gt;delta-&gt;idx.offset
)paren
ques
c_cond
id|OBJ_OFS_DELTA
suffix:colon
id|OBJ_REF_DELTA
suffix:semicolon
)brace
r_else
(brace
id|buf
op_assign
id|get_delta
c_func
(paren
id|entry
)paren
suffix:semicolon
id|size
op_assign
id|entry-&gt;delta_size
suffix:semicolon
id|type
op_assign
(paren
id|allow_ofs_delta
op_logical_and
id|entry-&gt;delta-&gt;idx.offset
)paren
ques
c_cond
id|OBJ_OFS_DELTA
suffix:colon
id|OBJ_REF_DELTA
suffix:semicolon
)brace
r_if
c_cond
(paren
id|entry-&gt;z_delta_size
)paren
id|datalen
op_assign
id|entry-&gt;z_delta_size
suffix:semicolon
r_else
id|datalen
op_assign
id|do_compress
c_func
(paren
op_amp
id|buf
comma
id|size
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The object header is a byte of &squot;type&squot; followed by zero or&n;&t;&t; * more bytes of length.&n;&t;&t; */
id|hdrlen
op_assign
id|encode_in_pack_object_header
c_func
(paren
id|type
comma
id|size
comma
id|header
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|OBJ_OFS_DELTA
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Deltas with relative base contain an additional&n;&t;&t;&t; * encoding of the relative offset for the delta&n;&t;&t;&t; * base from this object&squot;s position in the pack.&n;&t;&t;&t; */
id|off_t
id|ofs
op_assign
id|entry-&gt;idx.offset
id|entry-&gt;delta-&gt;idx.offset
suffix:semicolon
r_int
id|pos
op_assign
r_sizeof
(paren
id|dheader
)paren
l_int|1
suffix:semicolon
id|dheader
(braket
id|pos
)braket
op_assign
id|ofs
op_amp
l_int|127
suffix:semicolon
r_while
c_loop
(paren
id|ofs
op_rshift_assign
l_int|7
)paren
id|dheader
(braket
op_decrement
id|pos
)braket
op_assign
l_int|128
op_or
(paren
op_decrement
id|ofs
op_amp
l_int|127
)paren
suffix:semicolon
r_if
c_cond
(paren
id|limit
op_logical_and
id|hdrlen
op_plus
r_sizeof
(paren
id|dheader
)paren
id|pos
op_plus
id|datalen
op_plus
l_int|20
op_ge
id|limit
)paren
(brace
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|sha1write
c_func
(paren
id|f
comma
id|header
comma
id|hdrlen
)paren
suffix:semicolon
id|sha1write
c_func
(paren
id|f
comma
id|dheader
op_plus
id|pos
comma
r_sizeof
(paren
id|dheader
)paren
id|pos
)paren
suffix:semicolon
id|hdrlen
op_add_assign
r_sizeof
(paren
id|dheader
)paren
id|pos
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|type
op_eq
id|OBJ_REF_DELTA
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Deltas with a base reference contain&n;&t;&t;&t; * an additional 20 bytes for the base sha1.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|limit
op_logical_and
id|hdrlen
op_plus
l_int|20
op_plus
id|datalen
op_plus
l_int|20
op_ge
id|limit
)paren
(brace
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|sha1write
c_func
(paren
id|f
comma
id|header
comma
id|hdrlen
)paren
suffix:semicolon
id|sha1write
c_func
(paren
id|f
comma
id|entry-&gt;delta-&gt;idx.sha1
comma
l_int|20
)paren
suffix:semicolon
id|hdrlen
op_add_assign
l_int|20
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|limit
op_logical_and
id|hdrlen
op_plus
id|datalen
op_plus
l_int|20
op_ge
id|limit
)paren
(brace
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|sha1write
c_func
(paren
id|f
comma
id|header
comma
id|hdrlen
)paren
suffix:semicolon
)brace
id|sha1write
c_func
(paren
id|f
comma
id|buf
comma
id|datalen
)paren
suffix:semicolon
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|packed_git
op_star
id|p
op_assign
id|entry-&gt;in_pack
suffix:semicolon
r_struct
id|pack_window
op_star
id|w_curs
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|revindex_entry
op_star
id|revidx
suffix:semicolon
id|off_t
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;delta
)paren
id|type
op_assign
(paren
id|allow_ofs_delta
op_logical_and
id|entry-&gt;delta-&gt;idx.offset
)paren
ques
c_cond
id|OBJ_OFS_DELTA
suffix:colon
id|OBJ_REF_DELTA
suffix:semicolon
id|hdrlen
op_assign
id|encode_in_pack_object_header
c_func
(paren
id|type
comma
id|entry-&gt;size
comma
id|header
)paren
suffix:semicolon
id|offset
op_assign
id|entry-&gt;in_pack_offset
suffix:semicolon
id|revidx
op_assign
id|find_pack_revindex
c_func
(paren
id|p
comma
id|offset
)paren
suffix:semicolon
id|datalen
op_assign
id|revidx
(braket
l_int|1
)braket
dot
id|offset
id|offset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pack_to_stdout
op_logical_and
id|p-&gt;index_version
OG
l_int|1
op_logical_and
id|check_pack_crc
c_func
(paren
id|p
comma
op_amp
id|w_curs
comma
id|offset
comma
id|datalen
comma
id|revidx-&gt;nr
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;bad packed object CRC for %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|entry-&gt;idx.sha1
)paren
)paren
suffix:semicolon
id|unuse_pack
c_func
(paren
op_amp
id|w_curs
)paren
suffix:semicolon
r_goto
id|no_reuse
suffix:semicolon
)brace
id|offset
op_add_assign
id|entry-&gt;in_pack_header_size
suffix:semicolon
id|datalen
op_sub_assign
id|entry-&gt;in_pack_header_size
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pack_to_stdout
op_logical_and
id|p-&gt;index_version
op_eq
l_int|1
op_logical_and
id|check_pack_inflate
c_func
(paren
id|p
comma
op_amp
id|w_curs
comma
id|offset
comma
id|datalen
comma
id|entry-&gt;size
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;corrupt packed object for %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|entry-&gt;idx.sha1
)paren
)paren
suffix:semicolon
id|unuse_pack
c_func
(paren
op_amp
id|w_curs
)paren
suffix:semicolon
r_goto
id|no_reuse
suffix:semicolon
)brace
r_if
c_cond
(paren
id|type
op_eq
id|OBJ_OFS_DELTA
)paren
(brace
id|off_t
id|ofs
op_assign
id|entry-&gt;idx.offset
id|entry-&gt;delta-&gt;idx.offset
suffix:semicolon
r_int
id|pos
op_assign
r_sizeof
(paren
id|dheader
)paren
l_int|1
suffix:semicolon
id|dheader
(braket
id|pos
)braket
op_assign
id|ofs
op_amp
l_int|127
suffix:semicolon
r_while
c_loop
(paren
id|ofs
op_rshift_assign
l_int|7
)paren
id|dheader
(braket
op_decrement
id|pos
)braket
op_assign
l_int|128
op_or
(paren
op_decrement
id|ofs
op_amp
l_int|127
)paren
suffix:semicolon
r_if
c_cond
(paren
id|limit
op_logical_and
id|hdrlen
op_plus
r_sizeof
(paren
id|dheader
)paren
id|pos
op_plus
id|datalen
op_plus
l_int|20
op_ge
id|limit
)paren
(brace
id|unuse_pack
c_func
(paren
op_amp
id|w_curs
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|sha1write
c_func
(paren
id|f
comma
id|header
comma
id|hdrlen
)paren
suffix:semicolon
id|sha1write
c_func
(paren
id|f
comma
id|dheader
op_plus
id|pos
comma
r_sizeof
(paren
id|dheader
)paren
id|pos
)paren
suffix:semicolon
id|hdrlen
op_add_assign
r_sizeof
(paren
id|dheader
)paren
id|pos
suffix:semicolon
id|reused_delta
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|type
op_eq
id|OBJ_REF_DELTA
)paren
(brace
r_if
c_cond
(paren
id|limit
op_logical_and
id|hdrlen
op_plus
l_int|20
op_plus
id|datalen
op_plus
l_int|20
op_ge
id|limit
)paren
(brace
id|unuse_pack
c_func
(paren
op_amp
id|w_curs
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|sha1write
c_func
(paren
id|f
comma
id|header
comma
id|hdrlen
)paren
suffix:semicolon
id|sha1write
c_func
(paren
id|f
comma
id|entry-&gt;delta-&gt;idx.sha1
comma
l_int|20
)paren
suffix:semicolon
id|hdrlen
op_add_assign
l_int|20
suffix:semicolon
id|reused_delta
op_increment
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|limit
op_logical_and
id|hdrlen
op_plus
id|datalen
op_plus
l_int|20
op_ge
id|limit
)paren
(brace
id|unuse_pack
c_func
(paren
op_amp
id|w_curs
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|sha1write
c_func
(paren
id|f
comma
id|header
comma
id|hdrlen
)paren
suffix:semicolon
)brace
id|copy_pack_data
c_func
(paren
id|f
comma
id|p
comma
op_amp
id|w_curs
comma
id|offset
comma
id|datalen
)paren
suffix:semicolon
id|unuse_pack
c_func
(paren
op_amp
id|w_curs
)paren
suffix:semicolon
id|reused
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|usable_delta
)paren
id|written_delta
op_increment
suffix:semicolon
id|written
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pack_to_stdout
)paren
id|entry-&gt;idx.crc32
op_assign
id|crc32_end
c_func
(paren
id|f
)paren
suffix:semicolon
r_return
id|hdrlen
op_plus
id|datalen
suffix:semicolon
)brace
DECL|enum|write_one_status
r_enum
id|write_one_status
(brace
DECL|enumerator|WRITE_ONE_SKIP
id|WRITE_ONE_SKIP
op_assign
l_int|1
comma
multiline_comment|/* already written */
DECL|enumerator|WRITE_ONE_BREAK
id|WRITE_ONE_BREAK
op_assign
l_int|0
comma
multiline_comment|/* writing this will bust the limit; not written */
DECL|enumerator|WRITE_ONE_WRITTEN
id|WRITE_ONE_WRITTEN
op_assign
l_int|1
comma
multiline_comment|/* normal */
DECL|enumerator|WRITE_ONE_RECURSIVE
id|WRITE_ONE_RECURSIVE
op_assign
l_int|2
multiline_comment|/* already scheduled to be written */
)brace
suffix:semicolon
DECL|function|write_one
r_static
r_enum
id|write_one_status
id|write_one
c_func
(paren
r_struct
id|sha1file
op_star
id|f
comma
r_struct
id|object_entry
op_star
id|e
comma
id|off_t
op_star
id|offset
)paren
(brace
r_int
r_int
id|size
suffix:semicolon
r_int
id|recursing
suffix:semicolon
multiline_comment|/*&n;&t; * we set offset to 1 (which is an impossible value) to mark&n;&t; * the fact that this object is involved in &quot;write its base&n;&t; * first before writing a deltified object&quot; recursion.&n;&t; */
id|recursing
op_assign
(paren
id|e-&gt;idx.offset
op_eq
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|recursing
)paren
(brace
id|warning
c_func
(paren
l_string|&quot;recursive delta detected for object %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|e-&gt;idx.sha1
)paren
)paren
suffix:semicolon
r_return
id|WRITE_ONE_RECURSIVE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|e-&gt;idx.offset
op_logical_or
id|e-&gt;preferred_base
)paren
(brace
multiline_comment|/* offset is non zero if object is written already. */
r_return
id|WRITE_ONE_SKIP
suffix:semicolon
)brace
multiline_comment|/* if we are deltified, write out base object first. */
r_if
c_cond
(paren
id|e-&gt;delta
)paren
(brace
id|e-&gt;idx.offset
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* now recurse */
r_switch
c_cond
(paren
id|write_one
c_func
(paren
id|f
comma
id|e-&gt;delta
comma
id|offset
)paren
)paren
(brace
r_case
id|WRITE_ONE_RECURSIVE
suffix:colon
multiline_comment|/* we cannot depend on this one */
id|e-&gt;delta
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
r_case
id|WRITE_ONE_BREAK
suffix:colon
id|e-&gt;idx.offset
op_assign
id|recursing
suffix:semicolon
r_return
id|WRITE_ONE_BREAK
suffix:semicolon
)brace
)brace
id|e-&gt;idx.offset
op_assign
op_star
id|offset
suffix:semicolon
id|size
op_assign
id|write_object
c_func
(paren
id|f
comma
id|e
comma
op_star
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|size
)paren
(brace
id|e-&gt;idx.offset
op_assign
id|recursing
suffix:semicolon
r_return
id|WRITE_ONE_BREAK
suffix:semicolon
)brace
id|written_list
(braket
id|nr_written
op_increment
)braket
op_assign
op_amp
id|e-&gt;idx
suffix:semicolon
multiline_comment|/* make sure off_t is sufficiently large not to wrap */
r_if
c_cond
(paren
id|signed_add_overflows
c_func
(paren
op_star
id|offset
comma
id|size
)paren
)paren
id|die
c_func
(paren
l_string|&quot;pack too large for current definition of off_t&quot;
)paren
suffix:semicolon
op_star
id|offset
op_add_assign
id|size
suffix:semicolon
r_return
id|WRITE_ONE_WRITTEN
suffix:semicolon
)brace
DECL|function|mark_tagged
r_static
r_int
id|mark_tagged
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
id|flag
comma
r_void
op_star
id|cb_data
)paren
(brace
r_int
r_char
id|peeled
(braket
l_int|20
)braket
suffix:semicolon
r_struct
id|object_entry
op_star
id|entry
op_assign
id|locate_object_entry
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
)paren
id|entry-&gt;tagged
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|peel_ref
c_func
(paren
id|path
comma
id|peeled
)paren
)paren
(brace
id|entry
op_assign
id|locate_object_entry
c_func
(paren
id|peeled
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
)paren
id|entry-&gt;tagged
op_assign
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|add_to_write_order
r_static
r_inline
r_void
id|add_to_write_order
c_func
(paren
r_struct
id|object_entry
op_star
op_star
id|wo
comma
r_int
r_int
op_star
id|endp
comma
r_struct
id|object_entry
op_star
id|e
)paren
(brace
r_if
c_cond
(paren
id|e-&gt;filled
)paren
r_return
suffix:semicolon
id|wo
(braket
(paren
op_star
id|endp
)paren
op_increment
)braket
op_assign
id|e
suffix:semicolon
id|e-&gt;filled
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|add_descendants_to_write_order
r_static
r_void
id|add_descendants_to_write_order
c_func
(paren
r_struct
id|object_entry
op_star
op_star
id|wo
comma
r_int
r_int
op_star
id|endp
comma
r_struct
id|object_entry
op_star
id|e
)paren
(brace
r_int
id|add_to_order
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|e
)paren
(brace
r_if
c_cond
(paren
id|add_to_order
)paren
(brace
r_struct
id|object_entry
op_star
id|s
suffix:semicolon
multiline_comment|/* add this node... */
id|add_to_write_order
c_func
(paren
id|wo
comma
id|endp
comma
id|e
)paren
suffix:semicolon
multiline_comment|/* all its siblings... */
r_for
c_loop
(paren
id|s
op_assign
id|e-&gt;delta_sibling
suffix:semicolon
id|s
suffix:semicolon
id|s
op_assign
id|s-&gt;delta_sibling
)paren
(brace
id|add_to_write_order
c_func
(paren
id|wo
comma
id|endp
comma
id|s
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* drop down a level to add left subtree nodes if possible */
r_if
c_cond
(paren
id|e-&gt;delta_child
)paren
(brace
id|add_to_order
op_assign
l_int|1
suffix:semicolon
id|e
op_assign
id|e-&gt;delta_child
suffix:semicolon
)brace
r_else
(brace
id|add_to_order
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* our sibling might have some children, it is next */
r_if
c_cond
(paren
id|e-&gt;delta_sibling
)paren
(brace
id|e
op_assign
id|e-&gt;delta_sibling
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* go back to our parent node */
id|e
op_assign
id|e-&gt;delta
suffix:semicolon
r_while
c_loop
(paren
id|e
op_logical_and
op_logical_neg
id|e-&gt;delta_sibling
)paren
(brace
multiline_comment|/* we&squot;re on the right side of a subtree, keep&n;&t;&t;&t;&t; * going up until we can go right again */
id|e
op_assign
id|e-&gt;delta
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|e
)paren
(brace
multiline_comment|/* done- we hit our original root node */
r_return
suffix:semicolon
)brace
multiline_comment|/* pass it off to sibling at this level */
id|e
op_assign
id|e-&gt;delta_sibling
suffix:semicolon
)brace
)brace
suffix:semicolon
)brace
DECL|function|add_family_to_write_order
r_static
r_void
id|add_family_to_write_order
c_func
(paren
r_struct
id|object_entry
op_star
op_star
id|wo
comma
r_int
r_int
op_star
id|endp
comma
r_struct
id|object_entry
op_star
id|e
)paren
(brace
r_struct
id|object_entry
op_star
id|root
suffix:semicolon
r_for
c_loop
(paren
id|root
op_assign
id|e
suffix:semicolon
id|root-&gt;delta
suffix:semicolon
id|root
op_assign
id|root-&gt;delta
)paren
suffix:semicolon
multiline_comment|/* nothing */
id|add_descendants_to_write_order
c_func
(paren
id|wo
comma
id|endp
comma
id|root
)paren
suffix:semicolon
)brace
DECL|function|compute_write_order
r_static
r_struct
id|object_entry
op_star
op_star
id|compute_write_order
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|i
comma
id|wo_end
comma
id|last_untagged
suffix:semicolon
r_struct
id|object_entry
op_star
op_star
id|wo
op_assign
id|xmalloc
c_func
(paren
id|nr_objects
op_star
r_sizeof
(paren
op_star
id|wo
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_objects
suffix:semicolon
id|i
op_increment
)paren
(brace
id|objects
(braket
id|i
)braket
dot
id|tagged
op_assign
l_int|0
suffix:semicolon
id|objects
(braket
id|i
)braket
dot
id|filled
op_assign
l_int|0
suffix:semicolon
id|objects
(braket
id|i
)braket
dot
id|delta_child
op_assign
l_int|NULL
suffix:semicolon
id|objects
(braket
id|i
)braket
dot
id|delta_sibling
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Fully connect delta_child/delta_sibling network.&n;&t; * Make sure delta_sibling is sorted in the original&n;&t; * recency order.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
id|nr_objects
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
)paren
(brace
r_struct
id|object_entry
op_star
id|e
op_assign
op_amp
id|objects
(braket
op_decrement
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|e-&gt;delta
)paren
r_continue
suffix:semicolon
multiline_comment|/* Mark me as the first child */
id|e-&gt;delta_sibling
op_assign
id|e-&gt;delta-&gt;delta_child
suffix:semicolon
id|e-&gt;delta-&gt;delta_child
op_assign
id|e
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Mark objects that are at the tip of tags.&n;&t; */
id|for_each_tag_ref
c_func
(paren
id|mark_tagged
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Give the objects in the original recency order until&n;&t; * we see a tagged tip.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
id|wo_end
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_objects
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|objects
(braket
id|i
)braket
dot
id|tagged
)paren
r_break
suffix:semicolon
id|add_to_write_order
c_func
(paren
id|wo
comma
op_amp
id|wo_end
comma
op_amp
id|objects
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|last_untagged
op_assign
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * Then fill all the tagged tips.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
id|nr_objects
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|objects
(braket
id|i
)braket
dot
id|tagged
)paren
id|add_to_write_order
c_func
(paren
id|wo
comma
op_amp
id|wo_end
comma
op_amp
id|objects
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * And then all remaining commits and tags.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
id|last_untagged
suffix:semicolon
id|i
OL
id|nr_objects
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|objects
(braket
id|i
)braket
dot
id|type
op_ne
id|OBJ_COMMIT
op_logical_and
id|objects
(braket
id|i
)braket
dot
id|type
op_ne
id|OBJ_TAG
)paren
r_continue
suffix:semicolon
id|add_to_write_order
c_func
(paren
id|wo
comma
op_amp
id|wo_end
comma
op_amp
id|objects
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * And then all the trees.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
id|last_untagged
suffix:semicolon
id|i
OL
id|nr_objects
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|objects
(braket
id|i
)braket
dot
id|type
op_ne
id|OBJ_TREE
)paren
r_continue
suffix:semicolon
id|add_to_write_order
c_func
(paren
id|wo
comma
op_amp
id|wo_end
comma
op_amp
id|objects
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Finally all the rest in really tight order&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
id|last_untagged
suffix:semicolon
id|i
OL
id|nr_objects
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|objects
(braket
id|i
)braket
dot
id|filled
)paren
id|add_family_to_write_order
c_func
(paren
id|wo
comma
op_amp
id|wo_end
comma
op_amp
id|objects
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wo_end
op_ne
id|nr_objects
)paren
id|die
c_func
(paren
l_string|&quot;ordered %u objects, expected %&quot;
id|PRIu32
comma
id|wo_end
comma
id|nr_objects
)paren
suffix:semicolon
r_return
id|wo
suffix:semicolon
)brace
DECL|function|write_pack_file
r_static
r_void
id|write_pack_file
c_func
(paren
r_void
)paren
(brace
r_uint32
id|i
op_assign
l_int|0
comma
id|j
suffix:semicolon
r_struct
id|sha1file
op_star
id|f
suffix:semicolon
id|off_t
id|offset
suffix:semicolon
r_struct
id|pack_header
id|hdr
suffix:semicolon
r_uint32
id|nr_remaining
op_assign
id|nr_result
suffix:semicolon
id|time_t
id|last_mtime
op_assign
l_int|0
suffix:semicolon
r_struct
id|object_entry
op_star
op_star
id|write_order
suffix:semicolon
r_if
c_cond
(paren
id|progress
OG
id|pack_to_stdout
)paren
id|progress_state
op_assign
id|start_progress
c_func
(paren
l_string|&quot;Writing objects&quot;
comma
id|nr_result
)paren
suffix:semicolon
id|written_list
op_assign
id|xmalloc
c_func
(paren
id|nr_objects
op_star
r_sizeof
(paren
op_star
id|written_list
)paren
)paren
suffix:semicolon
id|write_order
op_assign
id|compute_write_order
c_func
(paren
)paren
suffix:semicolon
r_do
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_char
op_star
id|pack_tmp_name
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|pack_to_stdout
)paren
(brace
id|f
op_assign
id|sha1fd_throughput
c_func
(paren
l_int|1
comma
l_string|&quot;&lt;stdout&gt;&quot;
comma
id|progress_state
)paren
suffix:semicolon
)brace
r_else
(brace
r_char
id|tmpname
(braket
id|PATH_MAX
)braket
suffix:semicolon
r_int
id|fd
suffix:semicolon
id|fd
op_assign
id|odb_mkstemp
c_func
(paren
id|tmpname
comma
r_sizeof
(paren
id|tmpname
)paren
comma
l_string|&quot;pack/tmp_pack_XXXXXX&quot;
)paren
suffix:semicolon
id|pack_tmp_name
op_assign
id|xstrdup
c_func
(paren
id|tmpname
)paren
suffix:semicolon
id|f
op_assign
id|sha1fd
c_func
(paren
id|fd
comma
id|pack_tmp_name
)paren
suffix:semicolon
)brace
id|hdr.hdr_signature
op_assign
id|htonl
c_func
(paren
id|PACK_SIGNATURE
)paren
suffix:semicolon
id|hdr.hdr_version
op_assign
id|htonl
c_func
(paren
id|PACK_VERSION
)paren
suffix:semicolon
id|hdr.hdr_entries
op_assign
id|htonl
c_func
(paren
id|nr_remaining
)paren
suffix:semicolon
id|sha1write
c_func
(paren
id|f
comma
op_amp
id|hdr
comma
r_sizeof
(paren
id|hdr
)paren
)paren
suffix:semicolon
id|offset
op_assign
r_sizeof
(paren
id|hdr
)paren
suffix:semicolon
id|nr_written
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
id|nr_objects
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|object_entry
op_star
id|e
op_assign
id|write_order
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|write_one
c_func
(paren
id|f
comma
id|e
comma
op_amp
id|offset
)paren
op_eq
id|WRITE_ONE_BREAK
)paren
r_break
suffix:semicolon
id|display_progress
c_func
(paren
id|progress_state
comma
id|written
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Did we write the wrong # entries in the header?&n;&t;&t; * If so, rewrite it like in fast-import&n;&t;&t; */
r_if
c_cond
(paren
id|pack_to_stdout
)paren
(brace
id|sha1close
c_func
(paren
id|f
comma
id|sha1
comma
id|CSUM_CLOSE
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|nr_written
op_eq
id|nr_remaining
)paren
(brace
id|sha1close
c_func
(paren
id|f
comma
id|sha1
comma
id|CSUM_FSYNC
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|fd
op_assign
id|sha1close
c_func
(paren
id|f
comma
id|sha1
comma
l_int|0
)paren
suffix:semicolon
id|fixup_pack_header_footer
c_func
(paren
id|fd
comma
id|sha1
comma
id|pack_tmp_name
comma
id|nr_written
comma
id|sha1
comma
id|offset
)paren
suffix:semicolon
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|pack_to_stdout
)paren
(brace
r_struct
id|stat
id|st
suffix:semicolon
r_const
r_char
op_star
id|idx_tmp_name
suffix:semicolon
r_char
id|tmpname
(braket
id|PATH_MAX
)braket
suffix:semicolon
id|idx_tmp_name
op_assign
id|write_idx_file
c_func
(paren
l_int|NULL
comma
id|written_list
comma
id|nr_written
comma
op_amp
id|pack_idx_opts
comma
id|sha1
)paren
suffix:semicolon
id|snprintf
c_func
(paren
id|tmpname
comma
r_sizeof
(paren
id|tmpname
)paren
comma
l_string|&quot;%s-%s.pack&quot;
comma
id|base_name
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
id|free_pack_by_name
c_func
(paren
id|tmpname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|adjust_shared_perm
c_func
(paren
id|pack_tmp_name
)paren
)paren
id|die_errno
c_func
(paren
l_string|&quot;unable to make temporary pack file readable&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rename
c_func
(paren
id|pack_tmp_name
comma
id|tmpname
)paren
)paren
id|die_errno
c_func
(paren
l_string|&quot;unable to rename temporary pack file&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Packs are runtime accessed in their mtime&n;&t;&t;&t; * order since newer packs are more likely to contain&n;&t;&t;&t; * younger objects.  So if we are creating multiple&n;&t;&t;&t; * packs then we should modify the mtime of later ones&n;&t;&t;&t; * to preserve this property.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|stat
c_func
(paren
id|tmpname
comma
op_amp
id|st
)paren
OL
l_int|0
)paren
(brace
id|warning
c_func
(paren
l_string|&quot;failed to stat %s: %s&quot;
comma
id|tmpname
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|last_mtime
)paren
(brace
id|last_mtime
op_assign
id|st.st_mtime
suffix:semicolon
)brace
r_else
(brace
r_struct
id|utimbuf
id|utb
suffix:semicolon
id|utb.actime
op_assign
id|st.st_atime
suffix:semicolon
id|utb.modtime
op_assign
op_decrement
id|last_mtime
suffix:semicolon
r_if
c_cond
(paren
id|utime
c_func
(paren
id|tmpname
comma
op_amp
id|utb
)paren
OL
l_int|0
)paren
id|warning
c_func
(paren
l_string|&quot;failed utime() on %s: %s&quot;
comma
id|tmpname
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
)brace
id|snprintf
c_func
(paren
id|tmpname
comma
r_sizeof
(paren
id|tmpname
)paren
comma
l_string|&quot;%s-%s.idx&quot;
comma
id|base_name
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|adjust_shared_perm
c_func
(paren
id|idx_tmp_name
)paren
)paren
id|die_errno
c_func
(paren
l_string|&quot;unable to make temporary index file readable&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rename
c_func
(paren
id|idx_tmp_name
comma
id|tmpname
)paren
)paren
id|die_errno
c_func
(paren
l_string|&quot;unable to rename temporary index file&quot;
)paren
suffix:semicolon
id|free
c_func
(paren
(paren
r_void
op_star
)paren
id|idx_tmp_name
)paren
suffix:semicolon
id|free
c_func
(paren
id|pack_tmp_name
)paren
suffix:semicolon
id|puts
c_func
(paren
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* mark written objects as written to previous pack */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|nr_written
suffix:semicolon
id|j
op_increment
)paren
(brace
id|written_list
(braket
id|j
)braket
op_member_access_from_pointer
id|offset
op_assign
(paren
id|off_t
)paren
op_minus
l_int|1
suffix:semicolon
)brace
id|nr_remaining
op_sub_assign
id|nr_written
suffix:semicolon
)brace
r_while
c_loop
(paren
id|nr_remaining
op_logical_and
id|i
OL
id|nr_objects
)paren
suffix:semicolon
id|free
c_func
(paren
id|written_list
)paren
suffix:semicolon
id|free
c_func
(paren
id|write_order
)paren
suffix:semicolon
id|stop_progress
c_func
(paren
op_amp
id|progress_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|written
op_ne
id|nr_result
)paren
id|die
c_func
(paren
l_string|&quot;wrote %&quot;
id|PRIu32
l_string|&quot; objects while expecting %&quot;
id|PRIu32
comma
id|written
comma
id|nr_result
)paren
suffix:semicolon
)brace
DECL|function|locate_object_entry_hash
r_static
r_int
id|locate_object_entry_hash
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|ui
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|ui
comma
id|sha1
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
id|i
op_assign
id|ui
op_mod
id|object_ix_hashsz
suffix:semicolon
r_while
c_loop
(paren
l_int|0
OL
id|object_ix
(braket
id|i
)braket
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|hashcmp
c_func
(paren
id|sha1
comma
id|objects
(braket
id|object_ix
(braket
id|i
)braket
l_int|1
)braket
dot
id|idx.sha1
)paren
)paren
r_return
id|i
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|i
op_eq
id|object_ix_hashsz
)paren
id|i
op_assign
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
id|i
suffix:semicolon
)brace
DECL|function|locate_object_entry
r_static
r_struct
id|object_entry
op_star
id|locate_object_entry
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|object_ix_hashsz
)paren
r_return
l_int|NULL
suffix:semicolon
id|i
op_assign
id|locate_object_entry_hash
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_le
id|i
)paren
r_return
op_amp
id|objects
(braket
id|object_ix
(braket
id|i
)braket
l_int|1
)braket
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|rehash_objects
r_static
r_void
id|rehash_objects
c_func
(paren
r_void
)paren
(brace
r_uint32
id|i
suffix:semicolon
r_struct
id|object_entry
op_star
id|oe
suffix:semicolon
id|object_ix_hashsz
op_assign
id|nr_objects
op_star
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|object_ix_hashsz
OL
l_int|1024
)paren
id|object_ix_hashsz
op_assign
l_int|1024
suffix:semicolon
id|object_ix
op_assign
id|xrealloc
c_func
(paren
id|object_ix
comma
r_sizeof
(paren
r_int
)paren
op_star
id|object_ix_hashsz
)paren
suffix:semicolon
id|memset
c_func
(paren
id|object_ix
comma
l_int|0
comma
r_sizeof
(paren
r_int
)paren
op_star
id|object_ix_hashsz
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|oe
op_assign
id|objects
suffix:semicolon
id|i
OL
id|nr_objects
suffix:semicolon
id|i
op_increment
comma
id|oe
op_increment
)paren
(brace
r_int
id|ix
op_assign
id|locate_object_entry_hash
c_func
(paren
id|oe-&gt;idx.sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_le
id|ix
)paren
r_continue
suffix:semicolon
id|ix
op_assign
l_int|1
id|ix
suffix:semicolon
id|object_ix
(braket
id|ix
)braket
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
)brace
)brace
DECL|function|name_hash
r_static
r_int
id|name_hash
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_int
id|c
comma
id|hash
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * This effectively just creates a sortable number from the&n;&t; * last sixteen non-whitespace characters. Last characters&n;&t; * count &quot;most&quot;, so things that end in &quot;.c&quot; sort together.&n;&t; */
r_while
c_loop
(paren
(paren
id|c
op_assign
op_star
id|name
op_increment
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|isspace
c_func
(paren
id|c
)paren
)paren
r_continue
suffix:semicolon
id|hash
op_assign
(paren
id|hash
op_rshift
l_int|2
)paren
op_plus
(paren
id|c
op_lshift
l_int|24
)paren
suffix:semicolon
)brace
r_return
id|hash
suffix:semicolon
)brace
DECL|function|setup_delta_attr_check
r_static
r_void
id|setup_delta_attr_check
c_func
(paren
r_struct
id|git_attr_check
op_star
id|check
)paren
(brace
r_static
r_struct
id|git_attr
op_star
id|attr_delta
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|attr_delta
)paren
id|attr_delta
op_assign
id|git_attr
c_func
(paren
l_string|&quot;delta&quot;
)paren
suffix:semicolon
id|check
(braket
l_int|0
)braket
dot
id|attr
op_assign
id|attr_delta
suffix:semicolon
)brace
DECL|function|no_try_delta
r_static
r_int
id|no_try_delta
c_func
(paren
r_const
r_char
op_star
id|path
)paren
(brace
r_struct
id|git_attr_check
id|check
(braket
l_int|1
)braket
suffix:semicolon
id|setup_delta_attr_check
c_func
(paren
id|check
)paren
suffix:semicolon
r_if
c_cond
(paren
id|git_check_attr
c_func
(paren
id|path
comma
id|ARRAY_SIZE
c_func
(paren
id|check
)paren
comma
id|check
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ATTR_FALSE
c_func
(paren
id|check-&gt;value
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|add_object_entry
r_static
r_int
id|add_object_entry
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
comma
r_enum
id|object_type
id|type
comma
r_const
r_char
op_star
id|name
comma
r_int
id|exclude
)paren
(brace
r_struct
id|object_entry
op_star
id|entry
suffix:semicolon
r_struct
id|packed_git
op_star
id|p
comma
op_star
id|found_pack
op_assign
l_int|NULL
suffix:semicolon
id|off_t
id|found_offset
op_assign
l_int|0
suffix:semicolon
r_int
id|ix
suffix:semicolon
r_int
id|hash
op_assign
id|name_hash
c_func
(paren
id|name
)paren
suffix:semicolon
id|ix
op_assign
id|nr_objects
ques
c_cond
id|locate_object_entry_hash
c_func
(paren
id|sha1
)paren
suffix:colon
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ix
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|exclude
)paren
(brace
id|entry
op_assign
id|objects
op_plus
id|object_ix
(braket
id|ix
)braket
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;preferred_base
)paren
id|nr_result
op_decrement
suffix:semicolon
id|entry-&gt;preferred_base
op_assign
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|exclude
op_logical_and
id|local
op_logical_and
id|has_loose_object_nonlocal
c_func
(paren
id|sha1
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|packed_git
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
id|off_t
id|offset
op_assign
id|find_pack_entry_one
c_func
(paren
id|sha1
comma
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|found_pack
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|is_pack_valid
c_func
(paren
id|p
)paren
)paren
(brace
id|warning
c_func
(paren
l_string|&quot;packfile %s cannot be accessed&quot;
comma
id|p-&gt;pack_name
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|found_offset
op_assign
id|offset
suffix:semicolon
id|found_pack
op_assign
id|p
suffix:semicolon
)brace
r_if
c_cond
(paren
id|exclude
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|incremental
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|local
op_logical_and
op_logical_neg
id|p-&gt;pack_local
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ignore_packed_keep
op_logical_and
id|p-&gt;pack_local
op_logical_and
id|p-&gt;pack_keep
)paren
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|nr_objects
op_ge
id|nr_alloc
)paren
(brace
id|nr_alloc
op_assign
(paren
id|nr_alloc
op_plus
l_int|1024
)paren
op_star
l_int|3
op_div
l_int|2
suffix:semicolon
id|objects
op_assign
id|xrealloc
c_func
(paren
id|objects
comma
id|nr_alloc
op_star
r_sizeof
(paren
op_star
id|entry
)paren
)paren
suffix:semicolon
)brace
id|entry
op_assign
id|objects
op_plus
id|nr_objects
op_increment
suffix:semicolon
id|memset
c_func
(paren
id|entry
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|entry
)paren
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|entry-&gt;idx.sha1
comma
id|sha1
)paren
suffix:semicolon
id|entry-&gt;hash
op_assign
id|hash
suffix:semicolon
r_if
c_cond
(paren
id|type
)paren
id|entry-&gt;type
op_assign
id|type
suffix:semicolon
r_if
c_cond
(paren
id|exclude
)paren
id|entry-&gt;preferred_base
op_assign
l_int|1
suffix:semicolon
r_else
id|nr_result
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|found_pack
)paren
(brace
id|entry-&gt;in_pack
op_assign
id|found_pack
suffix:semicolon
id|entry-&gt;in_pack_offset
op_assign
id|found_offset
suffix:semicolon
)brace
r_if
c_cond
(paren
id|object_ix_hashsz
op_star
l_int|3
op_le
id|nr_objects
op_star
l_int|4
)paren
id|rehash_objects
c_func
(paren
)paren
suffix:semicolon
r_else
id|object_ix
(braket
l_int|1
id|ix
)braket
op_assign
id|nr_objects
suffix:semicolon
id|display_progress
c_func
(paren
id|progress_state
comma
id|nr_objects
)paren
suffix:semicolon
r_if
c_cond
(paren
id|name
op_logical_and
id|no_try_delta
c_func
(paren
id|name
)paren
)paren
id|entry-&gt;no_try_delta
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|struct|pbase_tree_cache
r_struct
id|pbase_tree_cache
(brace
DECL|member|sha1
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
DECL|member|ref
r_int
id|ref
suffix:semicolon
DECL|member|temporary
r_int
id|temporary
suffix:semicolon
DECL|member|tree_data
r_void
op_star
id|tree_data
suffix:semicolon
DECL|member|tree_size
r_int
r_int
id|tree_size
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|pbase_tree_cache
r_static
r_struct
id|pbase_tree_cache
op_star
(paren
id|pbase_tree_cache
(braket
l_int|256
)braket
)paren
suffix:semicolon
DECL|function|pbase_tree_cache_ix
r_static
r_int
id|pbase_tree_cache_ix
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_return
id|sha1
(braket
l_int|0
)braket
op_mod
id|ARRAY_SIZE
c_func
(paren
id|pbase_tree_cache
)paren
suffix:semicolon
)brace
DECL|function|pbase_tree_cache_ix_incr
r_static
r_int
id|pbase_tree_cache_ix_incr
c_func
(paren
r_int
id|ix
)paren
(brace
r_return
(paren
id|ix
op_plus
l_int|1
)paren
op_mod
id|ARRAY_SIZE
c_func
(paren
id|pbase_tree_cache
)paren
suffix:semicolon
)brace
DECL|struct|pbase_tree
r_static
r_struct
id|pbase_tree
(brace
DECL|member|next
r_struct
id|pbase_tree
op_star
id|next
suffix:semicolon
multiline_comment|/* This is a phony &quot;cache&quot; entry; we are not&n;&t; * going to evict it nor find it through _get()&n;&t; * mechanism -- this is for the toplevel node that&n;&t; * would almost always change with any commit.&n;&t; */
DECL|member|pcache
r_struct
id|pbase_tree_cache
id|pcache
suffix:semicolon
DECL|variable|pbase_tree
)brace
op_star
id|pbase_tree
suffix:semicolon
DECL|function|pbase_tree_get
r_static
r_struct
id|pbase_tree_cache
op_star
id|pbase_tree_get
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_struct
id|pbase_tree_cache
op_star
id|ent
comma
op_star
id|nent
suffix:semicolon
r_void
op_star
id|data
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_enum
id|object_type
id|type
suffix:semicolon
r_int
id|neigh
suffix:semicolon
r_int
id|my_ix
op_assign
id|pbase_tree_cache_ix
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_int
id|available_ix
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* pbase-tree-cache acts as a limited hashtable.&n;&t; * your object will be found at your index or within a few&n;&t; * slots after that slot if it is cached.&n;&t; */
r_for
c_loop
(paren
id|neigh
op_assign
l_int|0
suffix:semicolon
id|neigh
OL
l_int|8
suffix:semicolon
id|neigh
op_increment
)paren
(brace
id|ent
op_assign
id|pbase_tree_cache
(braket
id|my_ix
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ent
op_logical_and
op_logical_neg
id|hashcmp
c_func
(paren
id|ent-&gt;sha1
comma
id|sha1
)paren
)paren
(brace
id|ent-&gt;ref
op_increment
suffix:semicolon
r_return
id|ent
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
(paren
id|available_ix
OL
l_int|0
)paren
op_logical_and
(paren
op_logical_neg
id|ent
op_logical_or
op_logical_neg
id|ent-&gt;ref
)paren
)paren
op_logical_or
(paren
(paren
l_int|0
op_le
id|available_ix
)paren
op_logical_and
(paren
op_logical_neg
id|ent
op_logical_and
id|pbase_tree_cache
(braket
id|available_ix
)braket
)paren
)paren
)paren
id|available_ix
op_assign
id|my_ix
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ent
)paren
r_break
suffix:semicolon
id|my_ix
op_assign
id|pbase_tree_cache_ix_incr
c_func
(paren
id|my_ix
)paren
suffix:semicolon
)brace
multiline_comment|/* Did not find one.  Either we got a bogus request or&n;&t; * we need to read and perhaps cache.&n;&t; */
id|data
op_assign
id|read_sha1_file
c_func
(paren
id|sha1
comma
op_amp
id|type
comma
op_amp
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
id|OBJ_TREE
)paren
(brace
id|free
c_func
(paren
id|data
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* We need to either cache or return a throwaway copy */
r_if
c_cond
(paren
id|available_ix
OL
l_int|0
)paren
id|ent
op_assign
l_int|NULL
suffix:semicolon
r_else
(brace
id|ent
op_assign
id|pbase_tree_cache
(braket
id|available_ix
)braket
suffix:semicolon
id|my_ix
op_assign
id|available_ix
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ent
)paren
(brace
id|nent
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|nent
)paren
)paren
suffix:semicolon
id|nent-&gt;temporary
op_assign
(paren
id|available_ix
OL
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* evict and reuse */
id|free
c_func
(paren
id|ent-&gt;tree_data
)paren
suffix:semicolon
id|nent
op_assign
id|ent
suffix:semicolon
)brace
id|hashcpy
c_func
(paren
id|nent-&gt;sha1
comma
id|sha1
)paren
suffix:semicolon
id|nent-&gt;tree_data
op_assign
id|data
suffix:semicolon
id|nent-&gt;tree_size
op_assign
id|size
suffix:semicolon
id|nent-&gt;ref
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nent-&gt;temporary
)paren
id|pbase_tree_cache
(braket
id|my_ix
)braket
op_assign
id|nent
suffix:semicolon
r_return
id|nent
suffix:semicolon
)brace
DECL|function|pbase_tree_put
r_static
r_void
id|pbase_tree_put
c_func
(paren
r_struct
id|pbase_tree_cache
op_star
id|cache
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cache-&gt;temporary
)paren
(brace
id|cache-&gt;ref
op_decrement
suffix:semicolon
r_return
suffix:semicolon
)brace
id|free
c_func
(paren
id|cache-&gt;tree_data
)paren
suffix:semicolon
id|free
c_func
(paren
id|cache
)paren
suffix:semicolon
)brace
DECL|function|name_cmp_len
r_static
r_int
id|name_cmp_len
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|name
(braket
id|i
)braket
op_logical_and
id|name
(braket
id|i
)braket
op_ne
l_char|&squot;&bslash;n&squot;
op_logical_and
id|name
(braket
id|i
)braket
op_ne
l_char|&squot;/&squot;
suffix:semicolon
id|i
op_increment
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
DECL|function|add_pbase_object
r_static
r_void
id|add_pbase_object
c_func
(paren
r_struct
id|tree_desc
op_star
id|tree
comma
r_const
r_char
op_star
id|name
comma
r_int
id|cmplen
comma
r_const
r_char
op_star
id|fullname
)paren
(brace
r_struct
id|name_entry
id|entry
suffix:semicolon
r_int
id|cmp
suffix:semicolon
r_while
c_loop
(paren
id|tree_entry
c_func
(paren
id|tree
comma
op_amp
id|entry
)paren
)paren
(brace
r_if
c_cond
(paren
id|S_ISGITLINK
c_func
(paren
id|entry.mode
)paren
)paren
r_continue
suffix:semicolon
id|cmp
op_assign
id|tree_entry_len
c_func
(paren
op_amp
id|entry
)paren
op_ne
id|cmplen
ques
c_cond
l_int|1
suffix:colon
id|memcmp
c_func
(paren
id|name
comma
id|entry.path
comma
id|cmplen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmp
OG
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|cmp
OL
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|name
(braket
id|cmplen
)braket
op_ne
l_char|&squot;/&squot;
)paren
(brace
id|add_object_entry
c_func
(paren
id|entry.sha1
comma
id|object_type
c_func
(paren
id|entry.mode
)paren
comma
id|fullname
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|entry.mode
)paren
)paren
(brace
r_struct
id|tree_desc
id|sub
suffix:semicolon
r_struct
id|pbase_tree_cache
op_star
id|tree
suffix:semicolon
r_const
r_char
op_star
id|down
op_assign
id|name
op_plus
id|cmplen
op_plus
l_int|1
suffix:semicolon
r_int
id|downlen
op_assign
id|name_cmp_len
c_func
(paren
id|down
)paren
suffix:semicolon
id|tree
op_assign
id|pbase_tree_get
c_func
(paren
id|entry.sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tree
)paren
r_return
suffix:semicolon
id|init_tree_desc
c_func
(paren
op_amp
id|sub
comma
id|tree-&gt;tree_data
comma
id|tree-&gt;tree_size
)paren
suffix:semicolon
id|add_pbase_object
c_func
(paren
op_amp
id|sub
comma
id|down
comma
id|downlen
comma
id|fullname
)paren
suffix:semicolon
id|pbase_tree_put
c_func
(paren
id|tree
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|variable|done_pbase_paths
r_static
r_int
op_star
id|done_pbase_paths
suffix:semicolon
DECL|variable|done_pbase_paths_num
r_static
r_int
id|done_pbase_paths_num
suffix:semicolon
DECL|variable|done_pbase_paths_alloc
r_static
r_int
id|done_pbase_paths_alloc
suffix:semicolon
DECL|function|done_pbase_path_pos
r_static
r_int
id|done_pbase_path_pos
c_func
(paren
r_int
id|hash
)paren
(brace
r_int
id|lo
op_assign
l_int|0
suffix:semicolon
r_int
id|hi
op_assign
id|done_pbase_paths_num
suffix:semicolon
r_while
c_loop
(paren
id|lo
OL
id|hi
)paren
(brace
r_int
id|mi
op_assign
(paren
id|hi
op_plus
id|lo
)paren
op_div
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|done_pbase_paths
(braket
id|mi
)braket
op_eq
id|hash
)paren
r_return
id|mi
suffix:semicolon
r_if
c_cond
(paren
id|done_pbase_paths
(braket
id|mi
)braket
OL
id|hash
)paren
id|hi
op_assign
id|mi
suffix:semicolon
r_else
id|lo
op_assign
id|mi
op_plus
l_int|1
suffix:semicolon
)brace
r_return
id|lo
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|check_pbase_path
r_static
r_int
id|check_pbase_path
c_func
(paren
r_int
id|hash
)paren
(brace
r_int
id|pos
op_assign
(paren
op_logical_neg
id|done_pbase_paths
)paren
ques
c_cond
l_int|1
suffix:colon
id|done_pbase_path_pos
c_func
(paren
id|hash
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_le
id|pos
)paren
r_return
l_int|1
suffix:semicolon
id|pos
op_assign
id|pos
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|done_pbase_paths_alloc
op_le
id|done_pbase_paths_num
)paren
(brace
id|done_pbase_paths_alloc
op_assign
id|alloc_nr
c_func
(paren
id|done_pbase_paths_alloc
)paren
suffix:semicolon
id|done_pbase_paths
op_assign
id|xrealloc
c_func
(paren
id|done_pbase_paths
comma
id|done_pbase_paths_alloc
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
)brace
id|done_pbase_paths_num
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
id|done_pbase_paths_num
)paren
id|memmove
c_func
(paren
id|done_pbase_paths
op_plus
id|pos
op_plus
l_int|1
comma
id|done_pbase_paths
op_plus
id|pos
comma
(paren
id|done_pbase_paths_num
id|pos
l_int|1
)paren
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
id|done_pbase_paths
(braket
id|pos
)braket
op_assign
id|hash
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|add_preferred_base_object
r_static
r_void
id|add_preferred_base_object
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|pbase_tree
op_star
id|it
suffix:semicolon
r_int
id|cmplen
suffix:semicolon
r_int
id|hash
op_assign
id|name_hash
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|num_preferred_base
op_logical_or
id|check_pbase_path
c_func
(paren
id|hash
)paren
)paren
r_return
suffix:semicolon
id|cmplen
op_assign
id|name_cmp_len
c_func
(paren
id|name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|it
op_assign
id|pbase_tree
suffix:semicolon
id|it
suffix:semicolon
id|it
op_assign
id|it-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|cmplen
op_eq
l_int|0
)paren
(brace
id|add_object_entry
c_func
(paren
id|it-&gt;pcache.sha1
comma
id|OBJ_TREE
comma
l_int|NULL
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|tree_desc
id|tree
suffix:semicolon
id|init_tree_desc
c_func
(paren
op_amp
id|tree
comma
id|it-&gt;pcache.tree_data
comma
id|it-&gt;pcache.tree_size
)paren
suffix:semicolon
id|add_pbase_object
c_func
(paren
op_amp
id|tree
comma
id|name
comma
id|cmplen
comma
id|name
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|add_preferred_base
r_static
r_void
id|add_preferred_base
c_func
(paren
r_int
r_char
op_star
id|sha1
)paren
(brace
r_struct
id|pbase_tree
op_star
id|it
suffix:semicolon
r_void
op_star
id|data
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_int
r_char
id|tree_sha1
(braket
l_int|20
)braket
suffix:semicolon
r_if
c_cond
(paren
id|window
op_le
id|num_preferred_base
op_increment
)paren
r_return
suffix:semicolon
id|data
op_assign
id|read_object_with_reference
c_func
(paren
id|sha1
comma
id|tree_type
comma
op_amp
id|size
comma
id|tree_sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|it
op_assign
id|pbase_tree
suffix:semicolon
id|it
suffix:semicolon
id|it
op_assign
id|it-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|hashcmp
c_func
(paren
id|it-&gt;pcache.sha1
comma
id|tree_sha1
)paren
)paren
(brace
id|free
c_func
(paren
id|data
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|it
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|it
)paren
)paren
suffix:semicolon
id|it-&gt;next
op_assign
id|pbase_tree
suffix:semicolon
id|pbase_tree
op_assign
id|it
suffix:semicolon
id|hashcpy
c_func
(paren
id|it-&gt;pcache.sha1
comma
id|tree_sha1
)paren
suffix:semicolon
id|it-&gt;pcache.tree_data
op_assign
id|data
suffix:semicolon
id|it-&gt;pcache.tree_size
op_assign
id|size
suffix:semicolon
)brace
DECL|function|cleanup_preferred_base
r_static
r_void
id|cleanup_preferred_base
c_func
(paren
r_void
)paren
(brace
r_struct
id|pbase_tree
op_star
id|it
suffix:semicolon
r_int
id|i
suffix:semicolon
id|it
op_assign
id|pbase_tree
suffix:semicolon
id|pbase_tree
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|it
)paren
(brace
r_struct
id|pbase_tree
op_star
id|this
op_assign
id|it
suffix:semicolon
id|it
op_assign
id|this-&gt;next
suffix:semicolon
id|free
c_func
(paren
id|this-&gt;pcache.tree_data
)paren
suffix:semicolon
id|free
c_func
(paren
id|this
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|pbase_tree_cache
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pbase_tree_cache
(braket
id|i
)braket
)paren
r_continue
suffix:semicolon
id|free
c_func
(paren
id|pbase_tree_cache
(braket
id|i
)braket
op_member_access_from_pointer
id|tree_data
)paren
suffix:semicolon
id|free
c_func
(paren
id|pbase_tree_cache
(braket
id|i
)braket
)paren
suffix:semicolon
id|pbase_tree_cache
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
id|free
c_func
(paren
id|done_pbase_paths
)paren
suffix:semicolon
id|done_pbase_paths
op_assign
l_int|NULL
suffix:semicolon
id|done_pbase_paths_num
op_assign
id|done_pbase_paths_alloc
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|check_object
r_static
r_void
id|check_object
c_func
(paren
r_struct
id|object_entry
op_star
id|entry
)paren
(brace
r_if
c_cond
(paren
id|entry-&gt;in_pack
)paren
(brace
r_struct
id|packed_git
op_star
id|p
op_assign
id|entry-&gt;in_pack
suffix:semicolon
r_struct
id|pack_window
op_star
id|w_curs
op_assign
l_int|NULL
suffix:semicolon
r_const
r_int
r_char
op_star
id|base_ref
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|object_entry
op_star
id|base_entry
suffix:semicolon
r_int
r_int
id|used
comma
id|used_0
suffix:semicolon
r_int
r_int
id|avail
suffix:semicolon
id|off_t
id|ofs
suffix:semicolon
r_int
r_char
op_star
id|buf
comma
id|c
suffix:semicolon
id|buf
op_assign
id|use_pack
c_func
(paren
id|p
comma
op_amp
id|w_curs
comma
id|entry-&gt;in_pack_offset
comma
op_amp
id|avail
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We want in_pack_type even if we do not reuse delta&n;&t;&t; * since non-delta representations could still be reused.&n;&t;&t; */
id|used
op_assign
id|unpack_object_header_buffer
c_func
(paren
id|buf
comma
id|avail
comma
op_amp
id|entry-&gt;in_pack_type
comma
op_amp
id|entry-&gt;size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|used
op_eq
l_int|0
)paren
r_goto
id|give_up
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Determine if this is a delta and if so whether we can&n;&t;&t; * reuse it or not.  Otherwise let&squot;s find out as cheaply as&n;&t;&t; * possible what the actual type and size for this object is.&n;&t;&t; */
r_switch
c_cond
(paren
id|entry-&gt;in_pack_type
)paren
(brace
r_default
suffix:colon
multiline_comment|/* Not a delta hence we&squot;ve already got all we need. */
id|entry-&gt;type
op_assign
id|entry-&gt;in_pack_type
suffix:semicolon
id|entry-&gt;in_pack_header_size
op_assign
id|used
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;type
template_param
id|OBJ_BLOB
)paren
r_goto
id|give_up
suffix:semicolon
id|unuse_pack
c_func
(paren
op_amp
id|w_curs
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|OBJ_REF_DELTA
suffix:colon
r_if
c_cond
(paren
id|reuse_delta
op_logical_and
op_logical_neg
id|entry-&gt;preferred_base
)paren
id|base_ref
op_assign
id|use_pack
c_func
(paren
id|p
comma
op_amp
id|w_curs
comma
id|entry-&gt;in_pack_offset
op_plus
id|used
comma
l_int|NULL
)paren
suffix:semicolon
id|entry-&gt;in_pack_header_size
op_assign
id|used
op_plus
l_int|20
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OBJ_OFS_DELTA
suffix:colon
id|buf
op_assign
id|use_pack
c_func
(paren
id|p
comma
op_amp
id|w_curs
comma
id|entry-&gt;in_pack_offset
op_plus
id|used
comma
l_int|NULL
)paren
suffix:semicolon
id|used_0
op_assign
l_int|0
suffix:semicolon
id|c
op_assign
id|buf
(braket
id|used_0
op_increment
)braket
suffix:semicolon
id|ofs
op_assign
id|c
op_amp
l_int|127
suffix:semicolon
r_while
c_loop
(paren
id|c
op_amp
l_int|128
)paren
(brace
id|ofs
op_add_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ofs
op_logical_or
id|MSB
c_func
(paren
id|ofs
comma
l_int|7
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;delta base offset overflow in pack for %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|entry-&gt;idx.sha1
)paren
)paren
suffix:semicolon
r_goto
id|give_up
suffix:semicolon
)brace
id|c
op_assign
id|buf
(braket
id|used_0
op_increment
)braket
suffix:semicolon
id|ofs
op_assign
(paren
id|ofs
op_lshift
l_int|7
)paren
op_plus
(paren
id|c
op_amp
l_int|127
)paren
suffix:semicolon
)brace
id|ofs
op_assign
id|entry-&gt;in_pack_offset
id|ofs
suffix:semicolon
r_if
c_cond
(paren
id|ofs
op_le
l_int|0
op_logical_or
id|ofs
op_ge
id|entry-&gt;in_pack_offset
)paren
(brace
id|error
c_func
(paren
l_string|&quot;delta base offset out of bound for %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|entry-&gt;idx.sha1
)paren
)paren
suffix:semicolon
r_goto
id|give_up
suffix:semicolon
)brace
r_if
c_cond
(paren
id|reuse_delta
op_logical_and
op_logical_neg
id|entry-&gt;preferred_base
)paren
(brace
r_struct
id|revindex_entry
op_star
id|revidx
suffix:semicolon
id|revidx
op_assign
id|find_pack_revindex
c_func
(paren
id|p
comma
id|ofs
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|revidx
)paren
r_goto
id|give_up
suffix:semicolon
id|base_ref
op_assign
id|nth_packed_object_sha1
c_func
(paren
id|p
comma
id|revidx-&gt;nr
)paren
suffix:semicolon
)brace
id|entry-&gt;in_pack_header_size
op_assign
id|used
op_plus
id|used_0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|base_ref
op_logical_and
(paren
id|base_entry
op_assign
id|locate_object_entry
c_func
(paren
id|base_ref
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If base_ref was set above that means we wish to&n;&t;&t;&t; * reuse delta data, and we even found that base&n;&t;&t;&t; * in the list of objects we want to pack. Goodie!&n;&t;&t;&t; *&n;&t;&t;&t; * Depth value does not matter - find_deltas() will&n;&t;&t;&t; * never consider reused delta as the base object to&n;&t;&t;&t; * deltify other objects against, in order to avoid&n;&t;&t;&t; * circular deltas.&n;&t;&t;&t; */
id|entry-&gt;type
op_assign
id|entry-&gt;in_pack_type
suffix:semicolon
id|entry-&gt;delta
op_assign
id|base_entry
suffix:semicolon
id|entry-&gt;delta_size
op_assign
id|entry-&gt;size
suffix:semicolon
id|entry-&gt;delta_sibling
op_assign
id|base_entry-&gt;delta_child
suffix:semicolon
id|base_entry-&gt;delta_child
op_assign
id|entry
suffix:semicolon
id|unuse_pack
c_func
(paren
op_amp
id|w_curs
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|entry-&gt;type
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * This must be a delta and we already know what the&n;&t;&t;&t; * final object type is.  Let&squot;s extract the actual&n;&t;&t;&t; * object size from the delta header.&n;&t;&t;&t; */
id|entry-&gt;size
op_assign
id|get_size_from_delta
c_func
(paren
id|p
comma
op_amp
id|w_curs
comma
id|entry-&gt;in_pack_offset
op_plus
id|entry-&gt;in_pack_header_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;size
op_eq
l_int|0
)paren
r_goto
id|give_up
suffix:semicolon
id|unuse_pack
c_func
(paren
op_amp
id|w_curs
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * No choice but to fall back to the recursive delta walk&n;&t;&t; * with sha1_object_info() to find about the object type&n;&t;&t; * at this point...&n;&t;&t; */
id|give_up
suffix:colon
id|unuse_pack
c_func
(paren
op_amp
id|w_curs
)paren
suffix:semicolon
)brace
id|entry-&gt;type
op_assign
id|sha1_object_info
c_func
(paren
id|entry-&gt;idx.sha1
comma
op_amp
id|entry-&gt;size
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The error condition is checked in prepare_pack().  This is&n;&t; * to permit a missing preferred base object to be ignored&n;&t; * as a preferred base.  Doing so can result in a larger&n;&t; * pack file, but the transfer will still take place.&n;&t; */
)brace
DECL|function|pack_offset_sort
r_static
r_int
id|pack_offset_sort
c_func
(paren
r_const
r_void
op_star
id|_a
comma
r_const
r_void
op_star
id|_b
)paren
(brace
r_const
r_struct
id|object_entry
op_star
id|a
op_assign
op_star
(paren
r_struct
id|object_entry
op_star
op_star
)paren
id|_a
suffix:semicolon
r_const
r_struct
id|object_entry
op_star
id|b
op_assign
op_star
(paren
r_struct
id|object_entry
op_star
op_star
)paren
id|_b
suffix:semicolon
multiline_comment|/* avoid filesystem trashing with loose objects */
r_if
c_cond
(paren
op_logical_neg
id|a-&gt;in_pack
op_logical_and
op_logical_neg
id|b-&gt;in_pack
)paren
r_return
id|hashcmp
c_func
(paren
id|a-&gt;idx.sha1
comma
id|b-&gt;idx.sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;in_pack
OL
id|b-&gt;in_pack
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;in_pack
OG
id|b-&gt;in_pack
)paren
r_return
l_int|1
suffix:semicolon
r_return
id|a-&gt;in_pack_offset
OL
id|b-&gt;in_pack_offset
ques
c_cond
l_int|1
suffix:colon
(paren
id|a-&gt;in_pack_offset
OG
id|b-&gt;in_pack_offset
)paren
suffix:semicolon
)brace
DECL|function|get_object_details
r_static
r_void
id|get_object_details
c_func
(paren
r_void
)paren
(brace
r_uint32
id|i
suffix:semicolon
r_struct
id|object_entry
op_star
op_star
id|sorted_by_offset
suffix:semicolon
id|sorted_by_offset
op_assign
id|xcalloc
c_func
(paren
id|nr_objects
comma
r_sizeof
(paren
r_struct
id|object_entry
op_star
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_objects
suffix:semicolon
id|i
op_increment
)paren
id|sorted_by_offset
(braket
id|i
)braket
op_assign
id|objects
op_plus
id|i
suffix:semicolon
id|qsort
c_func
(paren
id|sorted_by_offset
comma
id|nr_objects
comma
r_sizeof
(paren
op_star
id|sorted_by_offset
)paren
comma
id|pack_offset_sort
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_objects
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|object_entry
op_star
id|entry
op_assign
id|sorted_by_offset
(braket
id|i
)braket
suffix:semicolon
id|check_object
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|big_file_threshold
op_le
id|entry-&gt;size
)paren
id|entry-&gt;no_try_delta
op_assign
l_int|1
suffix:semicolon
)brace
id|free
c_func
(paren
id|sorted_by_offset
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * We search for deltas in a list sorted by type, by filename hash, and then&n; * by size, so that we see progressively smaller and smaller files.&n; * That&squot;s because we prefer deltas to be from the bigger file&n; * to the smaller -- deletes are potentially cheaper, but perhaps&n; * more importantly, the bigger file is likely the more recent&n; * one.  The deepest deltas are therefore the oldest objects which are&n; * less susceptible to be accessed often.&n; */
DECL|function|type_size_sort
r_static
r_int
id|type_size_sort
c_func
(paren
r_const
r_void
op_star
id|_a
comma
r_const
r_void
op_star
id|_b
)paren
(brace
r_const
r_struct
id|object_entry
op_star
id|a
op_assign
op_star
(paren
r_struct
id|object_entry
op_star
op_star
)paren
id|_a
suffix:semicolon
r_const
r_struct
id|object_entry
op_star
id|b
op_assign
op_star
(paren
r_struct
id|object_entry
op_star
op_star
)paren
id|_b
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;type
OG
id|b-&gt;type
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;type
OL
id|b-&gt;type
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;hash
OG
id|b-&gt;hash
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;hash
OL
id|b-&gt;hash
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;preferred_base
OG
id|b-&gt;preferred_base
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;preferred_base
OL
id|b-&gt;preferred_base
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;size
OG
id|b-&gt;size
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;size
OL
id|b-&gt;size
)paren
r_return
l_int|1
suffix:semicolon
r_return
id|a
OL
id|b
ques
c_cond
l_int|1
suffix:colon
(paren
id|a
OG
id|b
)paren
suffix:semicolon
multiline_comment|/* newest first */
)brace
DECL|struct|unpacked
r_struct
id|unpacked
(brace
DECL|member|entry
r_struct
id|object_entry
op_star
id|entry
suffix:semicolon
DECL|member|data
r_void
op_star
id|data
suffix:semicolon
DECL|member|index
r_struct
id|delta_index
op_star
id|index
suffix:semicolon
DECL|member|depth
r_int
id|depth
suffix:semicolon
)brace
suffix:semicolon
DECL|function|delta_cacheable
r_static
r_int
id|delta_cacheable
c_func
(paren
r_int
r_int
id|src_size
comma
r_int
r_int
id|trg_size
comma
r_int
r_int
id|delta_size
)paren
(brace
r_if
c_cond
(paren
id|max_delta_cache_size
op_logical_and
id|delta_cache_size
op_plus
id|delta_size
OG
id|max_delta_cache_size
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|delta_size
OL
id|cache_max_small_delta_size
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* cache delta, if objects are large enough compared to delta size */
r_if
c_cond
(paren
(paren
id|src_size
op_rshift
l_int|20
)paren
op_plus
(paren
id|trg_size
op_rshift
l_int|21
)paren
OG
(paren
id|delta_size
op_rshift
l_int|10
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifndef NO_PTHREADS
DECL|variable|read_mutex
r_static
id|pthread_mutex_t
id|read_mutex
suffix:semicolon
DECL|macro|read_lock
mdefine_line|#define read_lock()&t;&t;pthread_mutex_lock(&amp;read_mutex)
DECL|macro|read_unlock
mdefine_line|#define read_unlock()&t;&t;pthread_mutex_unlock(&amp;read_mutex)
DECL|variable|cache_mutex
r_static
id|pthread_mutex_t
id|cache_mutex
suffix:semicolon
DECL|macro|cache_lock
mdefine_line|#define cache_lock()&t;&t;pthread_mutex_lock(&amp;cache_mutex)
DECL|macro|cache_unlock
mdefine_line|#define cache_unlock()&t;&t;pthread_mutex_unlock(&amp;cache_mutex)
DECL|variable|progress_mutex
r_static
id|pthread_mutex_t
id|progress_mutex
suffix:semicolon
DECL|macro|progress_lock
mdefine_line|#define progress_lock()&t;&t;pthread_mutex_lock(&amp;progress_mutex)
DECL|macro|progress_unlock
mdefine_line|#define progress_unlock()&t;pthread_mutex_unlock(&amp;progress_mutex)
macro_line|#else
DECL|macro|read_lock
mdefine_line|#define read_lock()&t;&t;(void)0
DECL|macro|read_unlock
mdefine_line|#define read_unlock()&t;&t;(void)0
DECL|macro|cache_lock
mdefine_line|#define cache_lock()&t;&t;(void)0
DECL|macro|cache_unlock
mdefine_line|#define cache_unlock()&t;&t;(void)0
DECL|macro|progress_lock
mdefine_line|#define progress_lock()&t;&t;(void)0
DECL|macro|progress_unlock
mdefine_line|#define progress_unlock()&t;(void)0
macro_line|#endif
DECL|function|try_delta
r_static
r_int
id|try_delta
c_func
(paren
r_struct
id|unpacked
op_star
id|trg
comma
r_struct
id|unpacked
op_star
id|src
comma
r_int
id|max_depth
comma
r_int
r_int
op_star
id|mem_usage
)paren
(brace
r_struct
id|object_entry
op_star
id|trg_entry
op_assign
id|trg-&gt;entry
suffix:semicolon
r_struct
id|object_entry
op_star
id|src_entry
op_assign
id|src-&gt;entry
suffix:semicolon
r_int
r_int
id|trg_size
comma
id|src_size
comma
id|delta_size
comma
id|sizediff
comma
id|max_size
comma
id|sz
suffix:semicolon
r_int
id|ref_depth
suffix:semicolon
r_enum
id|object_type
id|type
suffix:semicolon
r_void
op_star
id|delta_buf
suffix:semicolon
multiline_comment|/* Don&squot;t bother doing diffs between different types */
r_if
c_cond
(paren
id|trg_entry-&gt;type
op_ne
id|src_entry-&gt;type
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * We do not bother to try a delta that we discarded on an&n;&t; * earlier try, but only when reusing delta data.  Note that&n;&t; * src_entry that is marked as the preferred_base should always&n;&t; * be considered, as even if we produce a suboptimal delta against&n;&t; * it, we will still save the transfer cost, as we already know&n;&t; * the other side has it and we won&squot;t send src_entry at all.&n;&t; */
r_if
c_cond
(paren
id|reuse_delta
op_logical_and
id|trg_entry-&gt;in_pack
op_logical_and
id|trg_entry-&gt;in_pack
op_eq
id|src_entry-&gt;in_pack
op_logical_and
op_logical_neg
id|src_entry-&gt;preferred_base
op_logical_and
id|trg_entry-&gt;in_pack_type
op_ne
id|OBJ_REF_DELTA
op_logical_and
id|trg_entry-&gt;in_pack_type
op_ne
id|OBJ_OFS_DELTA
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Let&squot;s not bust the allowed depth. */
r_if
c_cond
(paren
id|src-&gt;depth
op_ge
id|max_depth
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Now some size filtering heuristics. */
id|trg_size
op_assign
id|trg_entry-&gt;size
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|trg_entry-&gt;delta
)paren
(brace
id|max_size
op_assign
id|trg_size
op_div
l_int|2
l_int|20
suffix:semicolon
id|ref_depth
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|max_size
op_assign
id|trg_entry-&gt;delta_size
suffix:semicolon
id|ref_depth
op_assign
id|trg-&gt;depth
suffix:semicolon
)brace
id|max_size
op_assign
(paren
r_uint64
)paren
id|max_size
op_star
(paren
id|max_depth
id|src-&gt;depth
)paren
op_div
(paren
id|max_depth
id|ref_depth
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|max_size
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|src_size
op_assign
id|src_entry-&gt;size
suffix:semicolon
id|sizediff
op_assign
id|src_size
OL
id|trg_size
ques
c_cond
id|trg_size
id|src_size
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sizediff
op_ge
id|max_size
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|trg_size
OL
id|src_size
op_div
l_int|32
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Load data if not already done */
r_if
c_cond
(paren
op_logical_neg
id|trg-&gt;data
)paren
(brace
id|read_lock
c_func
(paren
)paren
suffix:semicolon
id|trg-&gt;data
op_assign
id|read_sha1_file
c_func
(paren
id|trg_entry-&gt;idx.sha1
comma
op_amp
id|type
comma
op_amp
id|sz
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|trg-&gt;data
)paren
id|die
c_func
(paren
l_string|&quot;object %s cannot be read&quot;
comma
id|sha1_to_hex
c_func
(paren
id|trg_entry-&gt;idx.sha1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sz
op_ne
id|trg_size
)paren
id|die
c_func
(paren
l_string|&quot;object %s inconsistent object length (%lu vs %lu)&quot;
comma
id|sha1_to_hex
c_func
(paren
id|trg_entry-&gt;idx.sha1
)paren
comma
id|sz
comma
id|trg_size
)paren
suffix:semicolon
op_star
id|mem_usage
op_add_assign
id|sz
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|src-&gt;data
)paren
(brace
id|read_lock
c_func
(paren
)paren
suffix:semicolon
id|src-&gt;data
op_assign
id|read_sha1_file
c_func
(paren
id|src_entry-&gt;idx.sha1
comma
op_amp
id|type
comma
op_amp
id|sz
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|src-&gt;data
)paren
(brace
r_if
c_cond
(paren
id|src_entry-&gt;preferred_base
)paren
(brace
r_static
r_int
id|warned
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|warned
op_increment
)paren
id|warning
c_func
(paren
l_string|&quot;object %s cannot be read&quot;
comma
id|sha1_to_hex
c_func
(paren
id|src_entry-&gt;idx.sha1
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Those objects are not included in the&n;&t;&t;&t;&t; * resulting pack.  Be resilient and ignore&n;&t;&t;&t;&t; * them if they can&squot;t be read, in case the&n;&t;&t;&t;&t; * pack could be created nevertheless.&n;&t;&t;&t;&t; */
r_return
l_int|0
suffix:semicolon
)brace
id|die
c_func
(paren
l_string|&quot;object %s cannot be read&quot;
comma
id|sha1_to_hex
c_func
(paren
id|src_entry-&gt;idx.sha1
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sz
op_ne
id|src_size
)paren
id|die
c_func
(paren
l_string|&quot;object %s inconsistent object length (%lu vs %lu)&quot;
comma
id|sha1_to_hex
c_func
(paren
id|src_entry-&gt;idx.sha1
)paren
comma
id|sz
comma
id|src_size
)paren
suffix:semicolon
op_star
id|mem_usage
op_add_assign
id|sz
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|src-&gt;index
)paren
(brace
id|src-&gt;index
op_assign
id|create_delta_index
c_func
(paren
id|src-&gt;data
comma
id|src_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|src-&gt;index
)paren
(brace
r_static
r_int
id|warned
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|warned
op_increment
)paren
id|warning
c_func
(paren
l_string|&quot;suboptimal pack - out of memory&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
op_star
id|mem_usage
op_add_assign
id|sizeof_delta_index
c_func
(paren
id|src-&gt;index
)paren
suffix:semicolon
)brace
id|delta_buf
op_assign
id|create_delta
c_func
(paren
id|src-&gt;index
comma
id|trg-&gt;data
comma
id|trg_size
comma
op_amp
id|delta_size
comma
id|max_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|delta_buf
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|trg_entry-&gt;delta
)paren
(brace
multiline_comment|/* Prefer only shallower same-sized deltas. */
r_if
c_cond
(paren
id|delta_size
op_eq
id|trg_entry-&gt;delta_size
op_logical_and
id|src-&gt;depth
op_plus
l_int|1
op_ge
id|trg-&gt;depth
)paren
(brace
id|free
c_func
(paren
id|delta_buf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Handle memory allocation outside of the cache&n;&t; * accounting lock.  Compiler will optimize the strangeness&n;&t; * away when NO_PTHREADS is defined.&n;&t; */
id|free
c_func
(paren
id|trg_entry-&gt;delta_data
)paren
suffix:semicolon
id|cache_lock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|trg_entry-&gt;delta_data
)paren
(brace
id|delta_cache_size
op_sub_assign
id|trg_entry-&gt;delta_size
suffix:semicolon
id|trg_entry-&gt;delta_data
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|delta_cacheable
c_func
(paren
id|src_size
comma
id|trg_size
comma
id|delta_size
)paren
)paren
(brace
id|delta_cache_size
op_add_assign
id|delta_size
suffix:semicolon
id|cache_unlock
c_func
(paren
)paren
suffix:semicolon
id|trg_entry-&gt;delta_data
op_assign
id|xrealloc
c_func
(paren
id|delta_buf
comma
id|delta_size
)paren
suffix:semicolon
)brace
r_else
(brace
id|cache_unlock
c_func
(paren
)paren
suffix:semicolon
id|free
c_func
(paren
id|delta_buf
)paren
suffix:semicolon
)brace
id|trg_entry-&gt;delta
op_assign
id|src_entry
suffix:semicolon
id|trg_entry-&gt;delta_size
op_assign
id|delta_size
suffix:semicolon
id|trg-&gt;depth
op_assign
id|src-&gt;depth
op_plus
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|check_delta_limit
r_static
r_int
r_int
id|check_delta_limit
c_func
(paren
r_struct
id|object_entry
op_star
id|me
comma
r_int
r_int
id|n
)paren
(brace
r_struct
id|object_entry
op_star
id|child
op_assign
id|me-&gt;delta_child
suffix:semicolon
r_int
r_int
id|m
op_assign
id|n
suffix:semicolon
r_while
c_loop
(paren
id|child
)paren
(brace
r_int
r_int
id|c
op_assign
id|check_delta_limit
c_func
(paren
id|child
comma
id|n
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
OL
id|c
)paren
id|m
op_assign
id|c
suffix:semicolon
id|child
op_assign
id|child-&gt;delta_sibling
suffix:semicolon
)brace
r_return
id|m
suffix:semicolon
)brace
DECL|function|free_unpacked
r_static
r_int
r_int
id|free_unpacked
c_func
(paren
r_struct
id|unpacked
op_star
id|n
)paren
(brace
r_int
r_int
id|freed_mem
op_assign
id|sizeof_delta_index
c_func
(paren
id|n-&gt;index
)paren
suffix:semicolon
id|free_delta_index
c_func
(paren
id|n-&gt;index
)paren
suffix:semicolon
id|n-&gt;index
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|n-&gt;data
)paren
(brace
id|freed_mem
op_add_assign
id|n-&gt;entry-&gt;size
suffix:semicolon
id|free
c_func
(paren
id|n-&gt;data
)paren
suffix:semicolon
id|n-&gt;data
op_assign
l_int|NULL
suffix:semicolon
)brace
id|n-&gt;entry
op_assign
l_int|NULL
suffix:semicolon
id|n-&gt;depth
op_assign
l_int|0
suffix:semicolon
r_return
id|freed_mem
suffix:semicolon
)brace
DECL|function|find_deltas
r_static
r_void
id|find_deltas
c_func
(paren
r_struct
id|object_entry
op_star
op_star
id|list
comma
r_int
op_star
id|list_size
comma
r_int
id|window
comma
r_int
id|depth
comma
r_int
op_star
id|processed
)paren
(brace
r_uint32
id|i
comma
id|idx
op_assign
l_int|0
comma
id|count
op_assign
l_int|0
suffix:semicolon
r_struct
id|unpacked
op_star
id|array
suffix:semicolon
r_int
r_int
id|mem_usage
op_assign
l_int|0
suffix:semicolon
id|array
op_assign
id|xcalloc
c_func
(paren
id|window
comma
r_sizeof
(paren
r_struct
id|unpacked
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|object_entry
op_star
id|entry
suffix:semicolon
r_struct
id|unpacked
op_star
id|n
op_assign
id|array
op_plus
id|idx
suffix:semicolon
r_int
id|j
comma
id|max_depth
comma
id|best_base
op_assign
l_int|1
suffix:semicolon
id|progress_lock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|list_size
)paren
(brace
id|progress_unlock
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|entry
op_assign
op_star
id|list
op_increment
suffix:semicolon
(paren
op_star
id|list_size
)paren
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;preferred_base
)paren
(brace
(paren
op_star
id|processed
)paren
op_increment
suffix:semicolon
id|display_progress
c_func
(paren
id|progress_state
comma
op_star
id|processed
)paren
suffix:semicolon
)brace
id|progress_unlock
c_func
(paren
)paren
suffix:semicolon
id|mem_usage
op_sub_assign
id|free_unpacked
c_func
(paren
id|n
)paren
suffix:semicolon
id|n-&gt;entry
op_assign
id|entry
suffix:semicolon
r_while
c_loop
(paren
id|window_memory_limit
op_logical_and
id|mem_usage
OG
id|window_memory_limit
op_logical_and
id|count
OG
l_int|1
)paren
(brace
r_uint32
id|tail
op_assign
(paren
id|idx
op_plus
id|window
id|count
)paren
op_mod
id|window
suffix:semicolon
id|mem_usage
op_sub_assign
id|free_unpacked
c_func
(paren
id|array
op_plus
id|tail
)paren
suffix:semicolon
id|count
op_decrement
suffix:semicolon
)brace
multiline_comment|/* We do not compute delta to *create* objects we are not&n;&t;&t; * going to pack.&n;&t;&t; */
r_if
c_cond
(paren
id|entry-&gt;preferred_base
)paren
r_goto
id|next
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the current object is at pack edge, take the depth the&n;&t;&t; * objects that depend on the current object into account&n;&t;&t; * otherwise they would become too deep.&n;&t;&t; */
id|max_depth
op_assign
id|depth
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;delta_child
)paren
(brace
id|max_depth
op_sub_assign
id|check_delta_limit
c_func
(paren
id|entry
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|max_depth
op_le
l_int|0
)paren
r_goto
id|next
suffix:semicolon
)brace
id|j
op_assign
id|window
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|j
OG
l_int|0
)paren
(brace
r_int
id|ret
suffix:semicolon
r_uint32
id|other_idx
op_assign
id|idx
op_plus
id|j
suffix:semicolon
r_struct
id|unpacked
op_star
id|m
suffix:semicolon
r_if
c_cond
(paren
id|other_idx
op_ge
id|window
)paren
id|other_idx
op_sub_assign
id|window
suffix:semicolon
id|m
op_assign
id|array
op_plus
id|other_idx
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|m-&gt;entry
)paren
r_break
suffix:semicolon
id|ret
op_assign
id|try_delta
c_func
(paren
id|n
comma
id|m
comma
id|max_depth
comma
op_amp
id|mem_usage
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_break
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ret
OG
l_int|0
)paren
id|best_base
op_assign
id|other_idx
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If we decided to cache the delta data, then it is best&n;&t;&t; * to compress it right away.  First because we have to do&n;&t;&t; * it anyway, and doing it here while we&squot;re threaded will&n;&t;&t; * save a lot of time in the non threaded write phase,&n;&t;&t; * as well as allow for caching more deltas within&n;&t;&t; * the same cache size limit.&n;&t;&t; * ...&n;&t;&t; * But only if not writing to stdout, since in that case&n;&t;&t; * the network is most likely throttling writes anyway,&n;&t;&t; * and therefore it is best to go to the write phase ASAP&n;&t;&t; * instead, as we can afford spending more time compressing&n;&t;&t; * between writes at that moment.&n;&t;&t; */
r_if
c_cond
(paren
id|entry-&gt;delta_data
op_logical_and
op_logical_neg
id|pack_to_stdout
)paren
(brace
id|entry-&gt;z_delta_size
op_assign
id|do_compress
c_func
(paren
op_amp
id|entry-&gt;delta_data
comma
id|entry-&gt;delta_size
)paren
suffix:semicolon
id|cache_lock
c_func
(paren
)paren
suffix:semicolon
id|delta_cache_size
op_sub_assign
id|entry-&gt;delta_size
suffix:semicolon
id|delta_cache_size
op_add_assign
id|entry-&gt;z_delta_size
suffix:semicolon
id|cache_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* if we made n a delta, and if n is already at max&n;&t;&t; * depth, leaving it in the window is pointless.  we&n;&t;&t; * should evict it first.&n;&t;&t; */
r_if
c_cond
(paren
id|entry-&gt;delta
op_logical_and
id|max_depth
op_le
id|n-&gt;depth
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Move the best delta base up in the window, after the&n;&t;&t; * currently deltified object, to keep it longer.  It will&n;&t;&t; * be the first base object to be attempted next.&n;&t;&t; */
r_if
c_cond
(paren
id|entry-&gt;delta
)paren
(brace
r_struct
id|unpacked
id|swap
op_assign
id|array
(braket
id|best_base
)braket
suffix:semicolon
r_int
id|dist
op_assign
(paren
id|window
op_plus
id|idx
id|best_base
)paren
op_mod
id|window
suffix:semicolon
r_int
id|dst
op_assign
id|best_base
suffix:semicolon
r_while
c_loop
(paren
id|dist
op_decrement
)paren
(brace
r_int
id|src
op_assign
(paren
id|dst
op_plus
l_int|1
)paren
op_mod
id|window
suffix:semicolon
id|array
(braket
id|dst
)braket
op_assign
id|array
(braket
id|src
)braket
suffix:semicolon
id|dst
op_assign
id|src
suffix:semicolon
)brace
id|array
(braket
id|dst
)braket
op_assign
id|swap
suffix:semicolon
)brace
id|next
suffix:colon
id|idx
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|count
op_plus
l_int|1
OL
id|window
)paren
id|count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|idx
op_ge
id|window
)paren
id|idx
op_assign
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|window
suffix:semicolon
op_increment
id|i
)paren
(brace
id|free_delta_index
c_func
(paren
id|array
(braket
id|i
)braket
dot
id|index
)paren
suffix:semicolon
id|free
c_func
(paren
id|array
(braket
id|i
)braket
dot
id|data
)paren
suffix:semicolon
)brace
id|free
c_func
(paren
id|array
)paren
suffix:semicolon
)brace
macro_line|#ifndef NO_PTHREADS
DECL|function|try_to_free_from_threads
r_static
r_void
id|try_to_free_from_threads
c_func
(paren
r_int
id|size
)paren
(brace
id|read_lock
c_func
(paren
)paren
suffix:semicolon
id|release_pack_memory
c_func
(paren
id|size
comma
l_int|1
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|old_try_to_free_routine
r_static
id|try_to_free_t
id|old_try_to_free_routine
suffix:semicolon
multiline_comment|/*&n; * The main thread waits on the condition that (at least) one of the workers&n; * has stopped working (which is indicated in the .working member of&n; * struct thread_params).&n; * When a work thread has completed its work, it sets .working to 0 and&n; * signals the main thread and waits on the condition that .data_ready&n; * becomes 1.&n; */
DECL|struct|thread_params
r_struct
id|thread_params
(brace
DECL|member|thread
id|pthread_t
id|thread
suffix:semicolon
DECL|member|list
r_struct
id|object_entry
op_star
op_star
id|list
suffix:semicolon
DECL|member|list_size
r_int
id|list_size
suffix:semicolon
DECL|member|remaining
r_int
id|remaining
suffix:semicolon
DECL|member|window
r_int
id|window
suffix:semicolon
DECL|member|depth
r_int
id|depth
suffix:semicolon
DECL|member|working
r_int
id|working
suffix:semicolon
DECL|member|data_ready
r_int
id|data_ready
suffix:semicolon
DECL|member|mutex
id|pthread_mutex_t
id|mutex
suffix:semicolon
DECL|member|cond
id|pthread_cond_t
id|cond
suffix:semicolon
DECL|member|processed
r_int
op_star
id|processed
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|progress_cond
r_static
id|pthread_cond_t
id|progress_cond
suffix:semicolon
multiline_comment|/*&n; * Mutex and conditional variable can&squot;t be statically-initialized on Windows.&n; */
DECL|function|init_threaded_search
r_static
r_void
id|init_threaded_search
c_func
(paren
r_void
)paren
(brace
id|init_recursive_mutex
c_func
(paren
op_amp
id|read_mutex
)paren
suffix:semicolon
id|pthread_mutex_init
c_func
(paren
op_amp
id|cache_mutex
comma
l_int|NULL
)paren
suffix:semicolon
id|pthread_mutex_init
c_func
(paren
op_amp
id|progress_mutex
comma
l_int|NULL
)paren
suffix:semicolon
id|pthread_cond_init
c_func
(paren
op_amp
id|progress_cond
comma
l_int|NULL
)paren
suffix:semicolon
id|old_try_to_free_routine
op_assign
id|set_try_to_free_routine
c_func
(paren
id|try_to_free_from_threads
)paren
suffix:semicolon
)brace
DECL|function|cleanup_threaded_search
r_static
r_void
id|cleanup_threaded_search
c_func
(paren
r_void
)paren
(brace
id|set_try_to_free_routine
c_func
(paren
id|old_try_to_free_routine
)paren
suffix:semicolon
id|pthread_cond_destroy
c_func
(paren
op_amp
id|progress_cond
)paren
suffix:semicolon
id|pthread_mutex_destroy
c_func
(paren
op_amp
id|read_mutex
)paren
suffix:semicolon
id|pthread_mutex_destroy
c_func
(paren
op_amp
id|cache_mutex
)paren
suffix:semicolon
id|pthread_mutex_destroy
c_func
(paren
op_amp
id|progress_mutex
)paren
suffix:semicolon
)brace
DECL|function|threaded_find_deltas
r_static
r_void
op_star
id|threaded_find_deltas
c_func
(paren
r_void
op_star
id|arg
)paren
(brace
r_struct
id|thread_params
op_star
id|me
op_assign
id|arg
suffix:semicolon
r_while
c_loop
(paren
id|me-&gt;remaining
)paren
(brace
id|find_deltas
c_func
(paren
id|me-&gt;list
comma
op_amp
id|me-&gt;remaining
comma
id|me-&gt;window
comma
id|me-&gt;depth
comma
id|me-&gt;processed
)paren
suffix:semicolon
id|progress_lock
c_func
(paren
)paren
suffix:semicolon
id|me-&gt;working
op_assign
l_int|0
suffix:semicolon
id|pthread_cond_signal
c_func
(paren
op_amp
id|progress_cond
)paren
suffix:semicolon
id|progress_unlock
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We must not set -&gt;data_ready before we wait on the&n;&t;&t; * condition because the main thread may have set it to 1&n;&t;&t; * before we get here. In order to be sure that new&n;&t;&t; * work is available if we see 1 in -&gt;data_ready, it&n;&t;&t; * was initialized to 0 before this thread was spawned&n;&t;&t; * and we reset it to 0 right away.&n;&t;&t; */
id|pthread_mutex_lock
c_func
(paren
op_amp
id|me-&gt;mutex
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|me-&gt;data_ready
)paren
id|pthread_cond_wait
c_func
(paren
op_amp
id|me-&gt;cond
comma
op_amp
id|me-&gt;mutex
)paren
suffix:semicolon
id|me-&gt;data_ready
op_assign
l_int|0
suffix:semicolon
id|pthread_mutex_unlock
c_func
(paren
op_amp
id|me-&gt;mutex
)paren
suffix:semicolon
)brace
multiline_comment|/* leave -&gt;working 1 so that this doesn&squot;t get more work assigned */
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|ll_find_deltas
r_static
r_void
id|ll_find_deltas
c_func
(paren
r_struct
id|object_entry
op_star
op_star
id|list
comma
r_int
id|list_size
comma
r_int
id|window
comma
r_int
id|depth
comma
r_int
op_star
id|processed
)paren
(brace
r_struct
id|thread_params
op_star
id|p
suffix:semicolon
r_int
id|i
comma
id|ret
comma
id|active_threads
op_assign
l_int|0
suffix:semicolon
id|init_threaded_search
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|delta_search_threads
)paren
multiline_comment|/* --threads=0 means autodetect */
id|delta_search_threads
op_assign
id|online_cpus
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|delta_search_threads
op_le
l_int|1
)paren
(brace
id|find_deltas
c_func
(paren
id|list
comma
op_amp
id|list_size
comma
id|window
comma
id|depth
comma
id|processed
)paren
suffix:semicolon
id|cleanup_threaded_search
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|progress
OG
id|pack_to_stdout
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Delta compression using up to %d threads.&bslash;n&quot;
comma
id|delta_search_threads
)paren
suffix:semicolon
id|p
op_assign
id|xcalloc
c_func
(paren
id|delta_search_threads
comma
r_sizeof
(paren
op_star
id|p
)paren
)paren
suffix:semicolon
multiline_comment|/* Partition the work amongst work threads. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|delta_search_threads
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|sub_size
op_assign
id|list_size
op_div
(paren
id|delta_search_threads
id|i
)paren
suffix:semicolon
multiline_comment|/* don&squot;t use too small segments or no deltas will be found */
r_if
c_cond
(paren
id|sub_size
OL
l_int|2
op_star
id|window
op_logical_and
id|i
op_plus
l_int|1
OL
id|delta_search_threads
)paren
id|sub_size
op_assign
l_int|0
suffix:semicolon
id|p
(braket
id|i
)braket
dot
id|window
op_assign
id|window
suffix:semicolon
id|p
(braket
id|i
)braket
dot
id|depth
op_assign
id|depth
suffix:semicolon
id|p
(braket
id|i
)braket
dot
id|processed
op_assign
id|processed
suffix:semicolon
id|p
(braket
id|i
)braket
dot
id|working
op_assign
l_int|1
suffix:semicolon
id|p
(braket
id|i
)braket
dot
id|data_ready
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* try to split chunks on &quot;path&quot; boundaries */
r_while
c_loop
(paren
id|sub_size
op_logical_and
id|sub_size
OL
id|list_size
op_logical_and
id|list
(braket
id|sub_size
)braket
op_member_access_from_pointer
id|hash
op_logical_and
id|list
(braket
id|sub_size
)braket
op_member_access_from_pointer
id|hash
op_eq
id|list
(braket
id|sub_size
op_minus
l_int|1
)braket
op_member_access_from_pointer
id|hash
)paren
id|sub_size
op_increment
suffix:semicolon
id|p
(braket
id|i
)braket
dot
id|list
op_assign
id|list
suffix:semicolon
id|p
(braket
id|i
)braket
dot
id|list_size
op_assign
id|sub_size
suffix:semicolon
id|p
(braket
id|i
)braket
dot
id|remaining
op_assign
id|sub_size
suffix:semicolon
id|list
op_add_assign
id|sub_size
suffix:semicolon
id|list_size
op_sub_assign
id|sub_size
suffix:semicolon
)brace
multiline_comment|/* Start work threads. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|delta_search_threads
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|p
(braket
id|i
)braket
dot
id|list_size
)paren
r_continue
suffix:semicolon
id|pthread_mutex_init
c_func
(paren
op_amp
id|p
(braket
id|i
)braket
dot
id|mutex
comma
l_int|NULL
)paren
suffix:semicolon
id|pthread_cond_init
c_func
(paren
op_amp
id|p
(braket
id|i
)braket
dot
id|cond
comma
l_int|NULL
)paren
suffix:semicolon
id|ret
op_assign
id|pthread_create
c_func
(paren
op_amp
id|p
(braket
id|i
)braket
dot
id|thread
comma
l_int|NULL
comma
id|threaded_find_deltas
comma
op_amp
id|p
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
id|die
c_func
(paren
l_string|&quot;unable to create thread: %s&quot;
comma
id|strerror
c_func
(paren
id|ret
)paren
)paren
suffix:semicolon
id|active_threads
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now let&squot;s wait for work completion.  Each time a thread is done&n;&t; * with its work, we steal half of the remaining work from the&n;&t; * thread with the largest number of unprocessed objects and give&n;&t; * it to that newly idle thread.  This ensure good load balancing&n;&t; * until the remaining object list segments are simply too short&n;&t; * to be worth splitting anymore.&n;&t; */
r_while
c_loop
(paren
id|active_threads
)paren
(brace
r_struct
id|thread_params
op_star
id|target
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|thread_params
op_star
id|victim
op_assign
l_int|NULL
suffix:semicolon
r_int
id|sub_size
op_assign
l_int|0
suffix:semicolon
id|progress_lock
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|target
op_logical_and
id|i
OL
id|delta_search_threads
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|p
(braket
id|i
)braket
dot
id|working
)paren
id|target
op_assign
op_amp
id|p
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|target
)paren
r_break
suffix:semicolon
id|pthread_cond_wait
c_func
(paren
op_amp
id|progress_cond
comma
op_amp
id|progress_mutex
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|delta_search_threads
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|p
(braket
id|i
)braket
dot
id|remaining
OG
l_int|2
op_star
id|window
op_logical_and
(paren
op_logical_neg
id|victim
op_logical_or
id|victim-&gt;remaining
OL
id|p
(braket
id|i
)braket
dot
id|remaining
)paren
)paren
id|victim
op_assign
op_amp
id|p
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|victim
)paren
(brace
id|sub_size
op_assign
id|victim-&gt;remaining
op_div
l_int|2
suffix:semicolon
id|list
op_assign
id|victim-&gt;list
op_plus
id|victim-&gt;list_size
id|sub_size
suffix:semicolon
r_while
c_loop
(paren
id|sub_size
op_logical_and
id|list
(braket
l_int|0
)braket
op_member_access_from_pointer
id|hash
op_logical_and
id|list
(braket
l_int|0
)braket
op_member_access_from_pointer
id|hash
op_eq
id|list
(braket
l_int|1
)braket
op_member_access_from_pointer
id|hash
)paren
(brace
id|list
op_increment
suffix:semicolon
id|sub_size
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sub_size
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * It is possible for some &quot;paths&quot; to have&n;&t;&t;&t;&t; * so many objects that no hash boundary&n;&t;&t;&t;&t; * might be found.  Let&squot;s just steal the&n;&t;&t;&t;&t; * exact half in that case.&n;&t;&t;&t;&t; */
id|sub_size
op_assign
id|victim-&gt;remaining
op_div
l_int|2
suffix:semicolon
id|list
op_sub_assign
id|sub_size
suffix:semicolon
)brace
id|target-&gt;list
op_assign
id|list
suffix:semicolon
id|victim-&gt;list_size
op_sub_assign
id|sub_size
suffix:semicolon
id|victim-&gt;remaining
op_sub_assign
id|sub_size
suffix:semicolon
)brace
id|target-&gt;list_size
op_assign
id|sub_size
suffix:semicolon
id|target-&gt;remaining
op_assign
id|sub_size
suffix:semicolon
id|target-&gt;working
op_assign
l_int|1
suffix:semicolon
id|progress_unlock
c_func
(paren
)paren
suffix:semicolon
id|pthread_mutex_lock
c_func
(paren
op_amp
id|target-&gt;mutex
)paren
suffix:semicolon
id|target-&gt;data_ready
op_assign
l_int|1
suffix:semicolon
id|pthread_cond_signal
c_func
(paren
op_amp
id|target-&gt;cond
)paren
suffix:semicolon
id|pthread_mutex_unlock
c_func
(paren
op_amp
id|target-&gt;mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sub_size
)paren
(brace
id|pthread_join
c_func
(paren
id|target-&gt;thread
comma
l_int|NULL
)paren
suffix:semicolon
id|pthread_cond_destroy
c_func
(paren
op_amp
id|target-&gt;cond
)paren
suffix:semicolon
id|pthread_mutex_destroy
c_func
(paren
op_amp
id|target-&gt;mutex
)paren
suffix:semicolon
id|active_threads
op_decrement
suffix:semicolon
)brace
)brace
id|cleanup_threaded_search
c_func
(paren
)paren
suffix:semicolon
id|free
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|macro|ll_find_deltas
mdefine_line|#define ll_find_deltas(l, s, w, d, p)&t;find_deltas(l, &amp;s, w, d, p)
macro_line|#endif
DECL|function|add_ref_tag
r_static
r_int
id|add_ref_tag
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
id|flag
comma
r_void
op_star
id|cb_data
)paren
(brace
r_int
r_char
id|peeled
(braket
l_int|20
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|path
comma
l_string|&quot;refs/tags/&quot;
)paren
op_logical_and
multiline_comment|/* is a tag? */
op_logical_neg
id|peel_ref
c_func
(paren
id|path
comma
id|peeled
)paren
op_logical_and
multiline_comment|/* peelable? */
op_logical_neg
id|is_null_sha1
c_func
(paren
id|peeled
)paren
op_logical_and
multiline_comment|/* annotated tag? */
id|locate_object_entry
c_func
(paren
id|peeled
)paren
)paren
multiline_comment|/* object packed? */
id|add_object_entry
c_func
(paren
id|sha1
comma
id|OBJ_TAG
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|prepare_pack
r_static
r_void
id|prepare_pack
c_func
(paren
r_int
id|window
comma
r_int
id|depth
)paren
(brace
r_struct
id|object_entry
op_star
op_star
id|delta_list
suffix:semicolon
r_uint32
id|i
comma
id|nr_deltas
suffix:semicolon
r_int
id|n
suffix:semicolon
id|get_object_details
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we&squot;re locally repacking then we need to be doubly careful&n;&t; * from now on in order to make sure no stealth corruption gets&n;&t; * propagated to the new pack.  Clients receiving streamed packs&n;&t; * should validate everything they get anyway so no need to incur&n;&t; * the additional cost here in that case.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|pack_to_stdout
)paren
id|do_check_packed_object_crc
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nr_objects
op_logical_or
op_logical_neg
id|window
op_logical_or
op_logical_neg
id|depth
)paren
r_return
suffix:semicolon
id|delta_list
op_assign
id|xmalloc
c_func
(paren
id|nr_objects
op_star
r_sizeof
(paren
op_star
id|delta_list
)paren
)paren
suffix:semicolon
id|nr_deltas
op_assign
id|n
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_objects
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|object_entry
op_star
id|entry
op_assign
id|objects
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;delta
)paren
multiline_comment|/* This happens if we decided to reuse existing&n;&t;&t;&t; * delta from a pack.  &quot;reuse_delta &amp;&amp;&quot; is implied.&n;&t;&t;&t; */
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;size
OL
l_int|50
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;no_try_delta
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;preferred_base
)paren
(brace
id|nr_deltas
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;type
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;unable to get type of object %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|entry-&gt;idx.sha1
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|entry-&gt;type
OL
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * This object is not found, but we&n;&t;&t;&t;&t; * don&squot;t have to include it anyway.&n;&t;&t;&t;&t; */
r_continue
suffix:semicolon
)brace
)brace
id|delta_list
(braket
id|n
op_increment
)braket
op_assign
id|entry
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nr_deltas
op_logical_and
id|n
OG
l_int|1
)paren
(brace
r_int
id|nr_done
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|progress
)paren
id|progress_state
op_assign
id|start_progress
c_func
(paren
l_string|&quot;Compressing objects&quot;
comma
id|nr_deltas
)paren
suffix:semicolon
id|qsort
c_func
(paren
id|delta_list
comma
id|n
comma
r_sizeof
(paren
op_star
id|delta_list
)paren
comma
id|type_size_sort
)paren
suffix:semicolon
id|ll_find_deltas
c_func
(paren
id|delta_list
comma
id|n
comma
id|window
op_plus
l_int|1
comma
id|depth
comma
op_amp
id|nr_done
)paren
suffix:semicolon
id|stop_progress
c_func
(paren
op_amp
id|progress_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr_done
op_ne
id|nr_deltas
)paren
id|die
c_func
(paren
l_string|&quot;inconsistency with delta count&quot;
)paren
suffix:semicolon
)brace
id|free
c_func
(paren
id|delta_list
)paren
suffix:semicolon
)brace
DECL|function|git_pack_config
r_static
r_int
id|git_pack_config
c_func
(paren
r_const
r_char
op_star
id|k
comma
r_const
r_char
op_star
id|v
comma
r_void
op_star
id|cb
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|k
comma
l_string|&quot;pack.window&quot;
)paren
)paren
(brace
id|window
op_assign
id|git_config_int
c_func
(paren
id|k
comma
id|v
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|k
comma
l_string|&quot;pack.windowmemory&quot;
)paren
)paren
(brace
id|window_memory_limit
op_assign
id|git_config_ulong
c_func
(paren
id|k
comma
id|v
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|k
comma
l_string|&quot;pack.depth&quot;
)paren
)paren
(brace
id|depth
op_assign
id|git_config_int
c_func
(paren
id|k
comma
id|v
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|k
comma
l_string|&quot;pack.compression&quot;
)paren
)paren
(brace
r_int
id|level
op_assign
id|git_config_int
c_func
(paren
id|k
comma
id|v
)paren
suffix:semicolon
r_if
c_cond
(paren
id|level
op_eq
l_int|1
)paren
id|level
op_assign
id|Z_DEFAULT_COMPRESSION
suffix:semicolon
r_else
r_if
c_cond
(paren
id|level
template_param
id|Z_BEST_COMPRESSION
)paren
id|die
c_func
(paren
l_string|&quot;bad pack compression level %d&quot;
comma
id|level
)paren
suffix:semicolon
id|pack_compression_level
op_assign
id|level
suffix:semicolon
id|pack_compression_seen
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|k
comma
l_string|&quot;pack.deltacachesize&quot;
)paren
)paren
(brace
id|max_delta_cache_size
op_assign
id|git_config_int
c_func
(paren
id|k
comma
id|v
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|k
comma
l_string|&quot;pack.deltacachelimit&quot;
)paren
)paren
(brace
id|cache_max_small_delta_size
op_assign
id|git_config_int
c_func
(paren
id|k
comma
id|v
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|k
comma
l_string|&quot;pack.threads&quot;
)paren
)paren
(brace
id|delta_search_threads
op_assign
id|git_config_int
c_func
(paren
id|k
comma
id|v
)paren
suffix:semicolon
r_if
c_cond
(paren
id|delta_search_threads
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;invalid number of threads specified (%d)&quot;
comma
id|delta_search_threads
)paren
suffix:semicolon
macro_line|#ifdef NO_PTHREADS
r_if
c_cond
(paren
id|delta_search_threads
op_ne
l_int|1
)paren
id|warning
c_func
(paren
l_string|&quot;no threads support, ignoring %s&quot;
comma
id|k
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|k
comma
l_string|&quot;pack.indexversion&quot;
)paren
)paren
(brace
id|pack_idx_opts.version
op_assign
id|git_config_int
c_func
(paren
id|k
comma
id|v
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pack_idx_opts.version
OG
l_int|2
)paren
id|die
c_func
(paren
l_string|&quot;bad pack.indexversion=%&quot;
id|PRIu32
comma
id|pack_idx_opts.version
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|k
comma
l_string|&quot;pack.packsizelimit&quot;
)paren
)paren
(brace
id|pack_size_limit_cfg
op_assign
id|git_config_ulong
c_func
(paren
id|k
comma
id|v
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|git_default_config
c_func
(paren
id|k
comma
id|v
comma
id|cb
)paren
suffix:semicolon
)brace
DECL|function|read_object_list_from_stdin
r_static
r_void
id|read_object_list_from_stdin
c_func
(paren
r_void
)paren
(brace
r_char
id|line
(braket
l_int|40
op_plus
l_int|1
op_plus
id|PATH_MAX
op_plus
l_int|2
)braket
suffix:semicolon
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|fgets
c_func
(paren
id|line
comma
r_sizeof
(paren
id|line
)paren
comma
id|stdin
)paren
)paren
(brace
r_if
c_cond
(paren
id|feof
c_func
(paren
id|stdin
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ferror
c_func
(paren
id|stdin
)paren
)paren
id|die
c_func
(paren
l_string|&quot;fgets returned NULL, not EOF, not error!&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|errno
op_ne
id|EINTR
)paren
id|die_errno
c_func
(paren
l_string|&quot;fgets&quot;
)paren
suffix:semicolon
id|clearerr
c_func
(paren
id|stdin
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|line
(braket
l_int|0
)braket
op_eq
l_char|&squot;-&squot;
)paren
(brace
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|line
op_plus
l_int|1
comma
id|sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;expected edge sha1, got garbage:&bslash;n %s&quot;
comma
id|line
)paren
suffix:semicolon
id|add_preferred_base
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|line
comma
id|sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;expected sha1, got garbage:&bslash;n %s&quot;
comma
id|line
)paren
suffix:semicolon
id|add_preferred_base_object
c_func
(paren
id|line
op_plus
l_int|41
)paren
suffix:semicolon
id|add_object_entry
c_func
(paren
id|sha1
comma
l_int|0
comma
id|line
op_plus
l_int|41
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
DECL|macro|OBJECT_ADDED
mdefine_line|#define OBJECT_ADDED (1u&lt;&lt;20)
DECL|function|show_commit
r_static
r_void
id|show_commit
c_func
(paren
r_struct
id|commit
op_star
id|commit
comma
r_void
op_star
id|data
)paren
(brace
id|add_object_entry
c_func
(paren
id|commit-&gt;object.sha1
comma
id|OBJ_COMMIT
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|commit-&gt;object.flags
op_or_assign
id|OBJECT_ADDED
suffix:semicolon
)brace
DECL|function|show_object
r_static
r_void
id|show_object
c_func
(paren
r_struct
id|object
op_star
id|obj
comma
r_const
r_struct
id|name_path
op_star
id|path
comma
r_const
r_char
op_star
id|last
comma
r_void
op_star
id|data
)paren
(brace
r_char
op_star
id|name
op_assign
id|path_name
c_func
(paren
id|path
comma
id|last
)paren
suffix:semicolon
id|add_preferred_base_object
c_func
(paren
id|name
)paren
suffix:semicolon
id|add_object_entry
c_func
(paren
id|obj-&gt;sha1
comma
id|obj-&gt;type
comma
id|name
comma
l_int|0
)paren
suffix:semicolon
id|obj-&gt;flags
op_or_assign
id|OBJECT_ADDED
suffix:semicolon
multiline_comment|/*&n;&t; * We will have generated the hash from the name,&n;&t; * but not saved a pointer to it - we can free it&n;&t; */
id|free
c_func
(paren
(paren
r_char
op_star
)paren
id|name
)paren
suffix:semicolon
)brace
DECL|function|show_edge
r_static
r_void
id|show_edge
c_func
(paren
r_struct
id|commit
op_star
id|commit
)paren
(brace
id|add_preferred_base
c_func
(paren
id|commit-&gt;object.sha1
)paren
suffix:semicolon
)brace
DECL|struct|in_pack_object
r_struct
id|in_pack_object
(brace
DECL|member|offset
id|off_t
id|offset
suffix:semicolon
DECL|member|object
r_struct
id|object
op_star
id|object
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|in_pack
r_struct
id|in_pack
(brace
DECL|member|alloc
r_int
id|alloc
suffix:semicolon
DECL|member|nr
r_int
id|nr
suffix:semicolon
DECL|member|array
r_struct
id|in_pack_object
op_star
id|array
suffix:semicolon
)brace
suffix:semicolon
DECL|function|mark_in_pack_object
r_static
r_void
id|mark_in_pack_object
c_func
(paren
r_struct
id|object
op_star
id|object
comma
r_struct
id|packed_git
op_star
id|p
comma
r_struct
id|in_pack
op_star
id|in_pack
)paren
(brace
id|in_pack-&gt;array
(braket
id|in_pack-&gt;nr
)braket
dot
id|offset
op_assign
id|find_pack_entry_one
c_func
(paren
id|object-&gt;sha1
comma
id|p
)paren
suffix:semicolon
id|in_pack-&gt;array
(braket
id|in_pack-&gt;nr
)braket
dot
id|object
op_assign
id|object
suffix:semicolon
id|in_pack-&gt;nr
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; * Compare the objects in the offset order, in order to emulate the&n; * &quot;git rev-list --objects&quot; output that produced the pack originally.&n; */
DECL|function|ofscmp
r_static
r_int
id|ofscmp
c_func
(paren
r_const
r_void
op_star
id|a_
comma
r_const
r_void
op_star
id|b_
)paren
(brace
r_struct
id|in_pack_object
op_star
id|a
op_assign
(paren
r_struct
id|in_pack_object
op_star
)paren
id|a_
suffix:semicolon
r_struct
id|in_pack_object
op_star
id|b
op_assign
(paren
r_struct
id|in_pack_object
op_star
)paren
id|b_
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;offset
OL
id|b-&gt;offset
)paren
r_return
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|a-&gt;offset
OG
id|b-&gt;offset
)paren
r_return
l_int|1
suffix:semicolon
r_else
r_return
id|hashcmp
c_func
(paren
id|a-&gt;object-&gt;sha1
comma
id|b-&gt;object-&gt;sha1
)paren
suffix:semicolon
)brace
DECL|function|add_objects_in_unpacked_packs
r_static
r_void
id|add_objects_in_unpacked_packs
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
)paren
(brace
r_struct
id|packed_git
op_star
id|p
suffix:semicolon
r_struct
id|in_pack
id|in_pack
suffix:semicolon
r_uint32
id|i
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|in_pack
comma
l_int|0
comma
r_sizeof
(paren
id|in_pack
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|packed_git
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_const
r_int
r_char
op_star
id|sha1
suffix:semicolon
r_struct
id|object
op_star
id|o
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;pack_local
op_logical_or
id|p-&gt;pack_keep
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|open_pack_index
c_func
(paren
id|p
)paren
)paren
id|die
c_func
(paren
l_string|&quot;cannot open pack index&quot;
)paren
suffix:semicolon
id|ALLOC_GROW
c_func
(paren
id|in_pack.array
comma
id|in_pack.nr
op_plus
id|p-&gt;num_objects
comma
id|in_pack.alloc
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|p-&gt;num_objects
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sha1
op_assign
id|nth_packed_object_sha1
c_func
(paren
id|p
comma
id|i
)paren
suffix:semicolon
id|o
op_assign
id|lookup_unknown_object
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|o-&gt;flags
op_amp
id|OBJECT_ADDED
)paren
)paren
id|mark_in_pack_object
c_func
(paren
id|o
comma
id|p
comma
op_amp
id|in_pack
)paren
suffix:semicolon
id|o-&gt;flags
op_or_assign
id|OBJECT_ADDED
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|in_pack.nr
)paren
(brace
id|qsort
c_func
(paren
id|in_pack.array
comma
id|in_pack.nr
comma
r_sizeof
(paren
id|in_pack.array
(braket
l_int|0
)braket
)paren
comma
id|ofscmp
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|in_pack.nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|object
op_star
id|o
op_assign
id|in_pack.array
(braket
id|i
)braket
dot
id|object
suffix:semicolon
id|add_object_entry
c_func
(paren
id|o-&gt;sha1
comma
id|o-&gt;type
comma
l_string|&quot;&quot;
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
id|free
c_func
(paren
id|in_pack.array
)paren
suffix:semicolon
)brace
DECL|function|has_sha1_pack_kept_or_nonlocal
r_static
r_int
id|has_sha1_pack_kept_or_nonlocal
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_static
r_struct
id|packed_git
op_star
id|last_found
op_assign
(paren
r_void
op_star
)paren
l_int|1
suffix:semicolon
r_struct
id|packed_git
op_star
id|p
suffix:semicolon
id|p
op_assign
(paren
id|last_found
op_ne
(paren
r_void
op_star
)paren
l_int|1
)paren
ques
c_cond
id|last_found
suffix:colon
id|packed_git
suffix:semicolon
r_while
c_loop
(paren
id|p
)paren
(brace
r_if
c_cond
(paren
(paren
op_logical_neg
id|p-&gt;pack_local
op_logical_or
id|p-&gt;pack_keep
)paren
op_logical_and
id|find_pack_entry_one
c_func
(paren
id|sha1
comma
id|p
)paren
)paren
(brace
id|last_found
op_assign
id|p
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p
op_eq
id|last_found
)paren
id|p
op_assign
id|packed_git
suffix:semicolon
r_else
id|p
op_assign
id|p-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
id|last_found
)paren
id|p
op_assign
id|p-&gt;next
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|loosen_unused_packed_objects
r_static
r_void
id|loosen_unused_packed_objects
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
)paren
(brace
r_struct
id|packed_git
op_star
id|p
suffix:semicolon
r_uint32
id|i
suffix:semicolon
r_const
r_int
r_char
op_star
id|sha1
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|packed_git
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;pack_local
op_logical_or
id|p-&gt;pack_keep
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|open_pack_index
c_func
(paren
id|p
)paren
)paren
id|die
c_func
(paren
l_string|&quot;cannot open pack index&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|p-&gt;num_objects
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sha1
op_assign
id|nth_packed_object_sha1
c_func
(paren
id|p
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|locate_object_entry
c_func
(paren
id|sha1
)paren
op_logical_and
op_logical_neg
id|has_sha1_pack_kept_or_nonlocal
c_func
(paren
id|sha1
)paren
)paren
r_if
c_cond
(paren
id|force_object_loose
c_func
(paren
id|sha1
comma
id|p-&gt;mtime
)paren
)paren
id|die
c_func
(paren
l_string|&quot;unable to force loose object&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|get_object_list
r_static
r_void
id|get_object_list
c_func
(paren
r_int
id|ac
comma
r_const
r_char
op_star
op_star
id|av
)paren
(brace
r_struct
id|rev_info
id|revs
suffix:semicolon
r_char
id|line
(braket
l_int|1000
)braket
suffix:semicolon
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
id|init_revisions
c_func
(paren
op_amp
id|revs
comma
l_int|NULL
)paren
suffix:semicolon
id|save_commit_buffer
op_assign
l_int|0
suffix:semicolon
id|setup_revisions
c_func
(paren
id|ac
comma
id|av
comma
op_amp
id|revs
comma
l_int|NULL
)paren
suffix:semicolon
r_while
c_loop
(paren
id|fgets
c_func
(paren
id|line
comma
r_sizeof
(paren
id|line
)paren
comma
id|stdin
)paren
op_ne
l_int|NULL
)paren
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|line
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_logical_and
id|line
(braket
id|len
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|line
(braket
op_decrement
id|len
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_star
id|line
op_eq
l_char|&squot;-&squot;
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|line
comma
l_string|&quot;--not&quot;
)paren
)paren
(brace
id|flags
op_xor_assign
id|UNINTERESTING
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|die
c_func
(paren
l_string|&quot;not a rev &squot;%s&squot;&quot;
comma
id|line
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|handle_revision_arg
c_func
(paren
id|line
comma
op_amp
id|revs
comma
id|flags
comma
l_int|1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;bad revision &squot;%s&squot;&quot;
comma
id|line
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|prepare_revision_walk
c_func
(paren
op_amp
id|revs
)paren
)paren
id|die
c_func
(paren
l_string|&quot;revision walk setup failed&quot;
)paren
suffix:semicolon
id|mark_edges_uninteresting
c_func
(paren
id|revs.commits
comma
op_amp
id|revs
comma
id|show_edge
)paren
suffix:semicolon
id|traverse_commit_list
c_func
(paren
op_amp
id|revs
comma
id|show_commit
comma
id|show_object
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|keep_unreachable
)paren
id|add_objects_in_unpacked_packs
c_func
(paren
op_amp
id|revs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unpack_unreachable
)paren
id|loosen_unused_packed_objects
c_func
(paren
op_amp
id|revs
)paren
suffix:semicolon
)brace
DECL|function|cmd_pack_objects
r_int
id|cmd_pack_objects
c_func
(paren
r_int
id|argc
comma
r_const
r_char
op_star
op_star
id|argv
comma
r_const
r_char
op_star
id|prefix
)paren
(brace
r_int
id|use_internal_rev_list
op_assign
l_int|0
suffix:semicolon
r_int
id|thin
op_assign
l_int|0
suffix:semicolon
r_int
id|all_progress_implied
op_assign
l_int|0
suffix:semicolon
r_uint32
id|i
suffix:semicolon
r_const
r_char
op_star
op_star
id|rp_av
suffix:semicolon
r_int
id|rp_ac_alloc
op_assign
l_int|64
suffix:semicolon
r_int
id|rp_ac
suffix:semicolon
id|read_replace_refs
op_assign
l_int|0
suffix:semicolon
id|rp_av
op_assign
id|xcalloc
c_func
(paren
id|rp_ac_alloc
comma
r_sizeof
(paren
op_star
id|rp_av
)paren
)paren
suffix:semicolon
id|rp_av
(braket
l_int|0
)braket
op_assign
l_string|&quot;pack-objects&quot;
suffix:semicolon
id|rp_av
(braket
l_int|1
)braket
op_assign
l_string|&quot;--objects&quot;
suffix:semicolon
multiline_comment|/* --thin will make it --objects-edge */
id|rp_ac
op_assign
l_int|2
suffix:semicolon
id|reset_pack_idx_option
c_func
(paren
op_amp
id|pack_idx_opts
)paren
suffix:semicolon
id|git_config
c_func
(paren
id|git_pack_config
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pack_compression_seen
op_logical_and
id|core_compression_seen
)paren
id|pack_compression_level
op_assign
id|core_compression_level
suffix:semicolon
id|progress
op_assign
id|isatty
c_func
(paren
l_int|2
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|argc
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_char
op_star
id|arg
op_assign
id|argv
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_star
id|arg
op_ne
l_char|&squot;-&squot;
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--non-empty&quot;
comma
id|arg
)paren
)paren
(brace
id|non_empty
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--local&quot;
comma
id|arg
)paren
)paren
(brace
id|local
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--incremental&quot;
comma
id|arg
)paren
)paren
(brace
id|incremental
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--honor-pack-keep&quot;
comma
id|arg
)paren
)paren
(brace
id|ignore_packed_keep
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;--compression=&quot;
)paren
)paren
(brace
r_char
op_star
id|end
suffix:semicolon
r_int
id|level
op_assign
id|strtoul
c_func
(paren
id|arg
op_plus
l_int|14
comma
op_amp
id|end
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
(braket
l_int|14
)braket
op_logical_or
op_star
id|end
)paren
id|usage
c_func
(paren
id|pack_usage
)paren
suffix:semicolon
r_if
c_cond
(paren
id|level
op_eq
l_int|1
)paren
id|level
op_assign
id|Z_DEFAULT_COMPRESSION
suffix:semicolon
r_else
r_if
c_cond
(paren
id|level
template_param
id|Z_BEST_COMPRESSION
)paren
id|die
c_func
(paren
l_string|&quot;bad pack compression level %d&quot;
comma
id|level
)paren
suffix:semicolon
id|pack_compression_level
op_assign
id|level
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;--max-pack-size=&quot;
)paren
)paren
(brace
id|pack_size_limit_cfg
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|git_parse_ulong
c_func
(paren
id|arg
op_plus
l_int|16
comma
op_amp
id|pack_size_limit
)paren
)paren
id|usage
c_func
(paren
id|pack_usage
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;--window=&quot;
)paren
)paren
(brace
r_char
op_star
id|end
suffix:semicolon
id|window
op_assign
id|strtoul
c_func
(paren
id|arg
op_plus
l_int|9
comma
op_amp
id|end
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
(braket
l_int|9
)braket
op_logical_or
op_star
id|end
)paren
id|usage
c_func
(paren
id|pack_usage
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;--window-memory=&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|git_parse_ulong
c_func
(paren
id|arg
op_plus
l_int|16
comma
op_amp
id|window_memory_limit
)paren
)paren
id|usage
c_func
(paren
id|pack_usage
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;--threads=&quot;
)paren
)paren
(brace
r_char
op_star
id|end
suffix:semicolon
id|delta_search_threads
op_assign
id|strtoul
c_func
(paren
id|arg
op_plus
l_int|10
comma
op_amp
id|end
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
(braket
l_int|10
)braket
op_logical_or
op_star
id|end
op_logical_or
id|delta_search_threads
OL
l_int|0
)paren
id|usage
c_func
(paren
id|pack_usage
)paren
suffix:semicolon
macro_line|#ifdef NO_PTHREADS
r_if
c_cond
(paren
id|delta_search_threads
op_ne
l_int|1
)paren
id|warning
c_func
(paren
l_string|&quot;no threads support, &quot;
l_string|&quot;ignoring %s&quot;
comma
id|arg
)paren
suffix:semicolon
macro_line|#endif
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;--depth=&quot;
)paren
)paren
(brace
r_char
op_star
id|end
suffix:semicolon
id|depth
op_assign
id|strtoul
c_func
(paren
id|arg
op_plus
l_int|8
comma
op_amp
id|end
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
(braket
l_int|8
)braket
op_logical_or
op_star
id|end
)paren
id|usage
c_func
(paren
id|pack_usage
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--progress&quot;
comma
id|arg
)paren
)paren
(brace
id|progress
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--all-progress&quot;
comma
id|arg
)paren
)paren
(brace
id|progress
op_assign
l_int|2
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--all-progress-implied&quot;
comma
id|arg
)paren
)paren
(brace
id|all_progress_implied
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;-q&quot;
comma
id|arg
)paren
)paren
(brace
id|progress
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--no-reuse-delta&quot;
comma
id|arg
)paren
)paren
(brace
id|reuse_delta
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--no-reuse-object&quot;
comma
id|arg
)paren
)paren
(brace
id|reuse_object
op_assign
id|reuse_delta
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--delta-base-offset&quot;
comma
id|arg
)paren
)paren
(brace
id|allow_ofs_delta
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--stdout&quot;
comma
id|arg
)paren
)paren
(brace
id|pack_to_stdout
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--revs&quot;
comma
id|arg
)paren
)paren
(brace
id|use_internal_rev_list
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--keep-unreachable&quot;
comma
id|arg
)paren
)paren
(brace
id|keep_unreachable
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--unpack-unreachable&quot;
comma
id|arg
)paren
)paren
(brace
id|unpack_unreachable
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--include-tag&quot;
comma
id|arg
)paren
)paren
(brace
id|include_tag
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--unpacked&quot;
comma
id|arg
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--reflog&quot;
comma
id|arg
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--all&quot;
comma
id|arg
)paren
)paren
(brace
id|use_internal_rev_list
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|rp_ac
op_ge
id|rp_ac_alloc
l_int|1
)paren
(brace
id|rp_ac_alloc
op_assign
id|alloc_nr
c_func
(paren
id|rp_ac_alloc
)paren
suffix:semicolon
id|rp_av
op_assign
id|xrealloc
c_func
(paren
id|rp_av
comma
id|rp_ac_alloc
op_star
r_sizeof
(paren
op_star
id|rp_av
)paren
)paren
suffix:semicolon
)brace
id|rp_av
(braket
id|rp_ac
op_increment
)braket
op_assign
id|arg
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;--thin&quot;
comma
id|arg
)paren
)paren
(brace
id|use_internal_rev_list
op_assign
l_int|1
suffix:semicolon
id|thin
op_assign
l_int|1
suffix:semicolon
id|rp_av
(braket
l_int|1
)braket
op_assign
l_string|&quot;--objects-edge&quot;
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;--index-version=&quot;
)paren
)paren
(brace
r_char
op_star
id|c
suffix:semicolon
id|pack_idx_opts.version
op_assign
id|strtoul
c_func
(paren
id|arg
op_plus
l_int|16
comma
op_amp
id|c
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pack_idx_opts.version
OG
l_int|2
)paren
id|die
c_func
(paren
l_string|&quot;bad %s&quot;
comma
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|c
op_eq
l_char|&squot;,&squot;
)paren
id|pack_idx_opts.off32_limit
op_assign
id|strtoul
c_func
(paren
id|c
op_plus
l_int|1
comma
op_amp
id|c
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|c
op_logical_or
id|pack_idx_opts.off32_limit
op_amp
l_int|0x80000000
)paren
id|die
c_func
(paren
l_string|&quot;bad %s&quot;
comma
id|arg
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--keep-true-parents&quot;
)paren
)paren
(brace
id|grafts_replace_parents
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|usage
c_func
(paren
id|pack_usage
)paren
suffix:semicolon
)brace
multiline_comment|/* Traditionally &quot;pack-objects [options] base extra&quot; failed;&n;&t; * we would however want to take refs parameter that would&n;&t; * have been given to upstream rev-list ourselves, which means&n;&t; * we somehow want to say what the base name is.  So the&n;&t; * syntax would be:&n;&t; *&n;&t; * pack-objects [options] base &lt;refs...&gt;&n;&t; *&n;&t; * in other words, we would treat the first non-option as the&n;&t; * base_name and send everything else to the internal revision&n;&t; * walker.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|pack_to_stdout
)paren
id|base_name
op_assign
id|argv
(braket
id|i
op_increment
)braket
suffix:semicolon
r_if
c_cond
(paren
id|pack_to_stdout
op_ne
op_logical_neg
id|base_name
)paren
id|usage
c_func
(paren
id|pack_usage
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pack_to_stdout
op_logical_and
op_logical_neg
id|pack_size_limit
)paren
id|pack_size_limit
op_assign
id|pack_size_limit_cfg
suffix:semicolon
r_if
c_cond
(paren
id|pack_to_stdout
op_logical_and
id|pack_size_limit
)paren
id|die
c_func
(paren
l_string|&quot;--max-pack-size cannot be used to build a pack for transfer.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pack_size_limit
op_logical_and
id|pack_size_limit
OL
l_int|1024
op_star
l_int|1024
)paren
(brace
id|warning
c_func
(paren
l_string|&quot;minimum pack size limit is 1 MiB&quot;
)paren
suffix:semicolon
id|pack_size_limit
op_assign
l_int|1024
op_star
l_int|1024
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|pack_to_stdout
op_logical_and
id|thin
)paren
id|die
c_func
(paren
l_string|&quot;--thin cannot be used to build an indexable pack.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|keep_unreachable
op_logical_and
id|unpack_unreachable
)paren
id|die
c_func
(paren
l_string|&quot;--keep-unreachable and --unpack-unreachable are incompatible.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|progress
op_logical_and
id|all_progress_implied
)paren
id|progress
op_assign
l_int|2
suffix:semicolon
id|prepare_packed_git
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|progress
)paren
id|progress_state
op_assign
id|start_progress
c_func
(paren
l_string|&quot;Counting objects&quot;
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|use_internal_rev_list
)paren
id|read_object_list_from_stdin
c_func
(paren
)paren
suffix:semicolon
r_else
(brace
id|rp_av
(braket
id|rp_ac
)braket
op_assign
l_int|NULL
suffix:semicolon
id|get_object_list
c_func
(paren
id|rp_ac
comma
id|rp_av
)paren
suffix:semicolon
)brace
id|cleanup_preferred_base
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|include_tag
op_logical_and
id|nr_result
)paren
id|for_each_ref
c_func
(paren
id|add_ref_tag
comma
l_int|NULL
)paren
suffix:semicolon
id|stop_progress
c_func
(paren
op_amp
id|progress_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|non_empty
op_logical_and
op_logical_neg
id|nr_result
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|nr_result
)paren
id|prepare_pack
c_func
(paren
id|window
comma
id|depth
)paren
suffix:semicolon
id|write_pack_file
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|progress
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Total %&quot;
id|PRIu32
l_string|&quot; (delta %&quot;
id|PRIu32
l_string|&quot;),&quot;
l_string|&quot; reused %&quot;
id|PRIu32
l_string|&quot; (delta %&quot;
id|PRIu32
l_string|&quot;)&bslash;n&quot;
comma
id|written
comma
id|written_delta
comma
id|reused
comma
id|reused_delta
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
