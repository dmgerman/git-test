macro_line|#include &quot;builtin.h&quot;
macro_line|#include &quot;delta.h&quot;
macro_line|#include &quot;pack.h&quot;
macro_line|#include &quot;csum-file.h&quot;
macro_line|#include &quot;blob.h&quot;
macro_line|#include &quot;commit.h&quot;
macro_line|#include &quot;tag.h&quot;
macro_line|#include &quot;tree.h&quot;
macro_line|#include &quot;progress.h&quot;
macro_line|#include &quot;fsck.h&quot;
macro_line|#include &quot;exec_cmd.h&quot;
macro_line|#include &quot;streaming.h&quot;
macro_line|#include &quot;thread-utils.h&quot;
DECL|variable|index_pack_usage
r_static
r_const
r_char
id|index_pack_usage
(braket
)braket
op_assign
l_string|&quot;git index-pack [-v] [-o &lt;index-file&gt;] [--keep | --keep=&lt;msg&gt;] [--verify] [--strict] (&lt;pack-file&gt; | --stdin [--fix-thin] [&lt;pack-file&gt;])&quot;
suffix:semicolon
DECL|struct|object_entry
r_struct
id|object_entry
(brace
DECL|member|idx
r_struct
id|pack_idx_entry
id|idx
suffix:semicolon
DECL|member|size
r_int
r_int
id|size
suffix:semicolon
DECL|member|hdr_size
r_int
r_int
id|hdr_size
suffix:semicolon
DECL|member|type
r_enum
id|object_type
id|type
suffix:semicolon
DECL|member|real_type
r_enum
id|object_type
id|real_type
suffix:semicolon
DECL|member|delta_depth
r_int
id|delta_depth
suffix:semicolon
DECL|member|base_object_no
r_int
id|base_object_no
suffix:semicolon
)brace
suffix:semicolon
DECL|union|delta_base
r_union
id|delta_base
(brace
DECL|member|sha1
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
DECL|member|offset
id|off_t
id|offset
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|base_data
r_struct
id|base_data
(brace
DECL|member|base
r_struct
id|base_data
op_star
id|base
suffix:semicolon
DECL|member|child
r_struct
id|base_data
op_star
id|child
suffix:semicolon
DECL|member|obj
r_struct
id|object_entry
op_star
id|obj
suffix:semicolon
DECL|member|data
r_void
op_star
id|data
suffix:semicolon
DECL|member|size
r_int
r_int
id|size
suffix:semicolon
DECL|member|ref_first
DECL|member|ref_last
r_int
id|ref_first
comma
id|ref_last
suffix:semicolon
DECL|member|ofs_first
DECL|member|ofs_last
r_int
id|ofs_first
comma
id|ofs_last
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|thread_local
r_struct
id|thread_local
(brace
macro_line|#ifndef NO_PTHREADS
DECL|member|thread
id|pthread_t
id|thread
suffix:semicolon
macro_line|#endif
DECL|member|base_cache
r_struct
id|base_data
op_star
id|base_cache
suffix:semicolon
DECL|member|base_cache_used
r_int
id|base_cache_used
suffix:semicolon
DECL|member|pack_fd
r_int
id|pack_fd
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Even if sizeof(union delta_base) == 24 on 64-bit archs, we really want&n; * to memcmp() only the first 20 bytes.&n; */
DECL|macro|UNION_BASE_SZ
mdefine_line|#define UNION_BASE_SZ&t;20
DECL|macro|FLAG_LINK
mdefine_line|#define FLAG_LINK (1u&lt;&lt;20)
DECL|macro|FLAG_CHECKED
mdefine_line|#define FLAG_CHECKED (1u&lt;&lt;21)
DECL|struct|delta_entry
r_struct
id|delta_entry
(brace
DECL|member|base
r_union
id|delta_base
id|base
suffix:semicolon
DECL|member|obj_no
r_int
id|obj_no
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|objects
r_static
r_struct
id|object_entry
op_star
id|objects
suffix:semicolon
DECL|variable|deltas
r_static
r_struct
id|delta_entry
op_star
id|deltas
suffix:semicolon
DECL|variable|nothread_data
r_static
r_struct
id|thread_local
id|nothread_data
suffix:semicolon
DECL|variable|nr_objects
r_static
r_int
id|nr_objects
suffix:semicolon
DECL|variable|nr_deltas
r_static
r_int
id|nr_deltas
suffix:semicolon
DECL|variable|nr_resolved_deltas
r_static
r_int
id|nr_resolved_deltas
suffix:semicolon
DECL|variable|nr_threads
r_static
r_int
id|nr_threads
suffix:semicolon
DECL|variable|from_stdin
r_static
r_int
id|from_stdin
suffix:semicolon
DECL|variable|strict
r_static
r_int
id|strict
suffix:semicolon
DECL|variable|do_fsck_object
r_static
r_int
id|do_fsck_object
suffix:semicolon
DECL|variable|verbose
r_static
r_int
id|verbose
suffix:semicolon
DECL|variable|show_stat
r_static
r_int
id|show_stat
suffix:semicolon
DECL|variable|check_self_contained_and_connected
r_static
r_int
id|check_self_contained_and_connected
suffix:semicolon
DECL|variable|progress
r_static
r_struct
id|progress
op_star
id|progress
suffix:semicolon
multiline_comment|/* We always read in 4kB chunks. */
DECL|variable|input_buffer
r_static
r_int
r_char
id|input_buffer
(braket
l_int|4096
)braket
suffix:semicolon
DECL|variable|input_offset
DECL|variable|input_len
r_static
r_int
r_int
id|input_offset
comma
id|input_len
suffix:semicolon
DECL|variable|consumed_bytes
r_static
id|off_t
id|consumed_bytes
suffix:semicolon
DECL|variable|deepest_delta
r_static
r_int
id|deepest_delta
suffix:semicolon
DECL|variable|input_ctx
r_static
id|git_SHA_CTX
id|input_ctx
suffix:semicolon
DECL|variable|input_crc32
r_static
r_uint32
id|input_crc32
suffix:semicolon
DECL|variable|input_fd
DECL|variable|output_fd
r_static
r_int
id|input_fd
comma
id|output_fd
suffix:semicolon
DECL|variable|curr_pack
r_static
r_const
r_char
op_star
id|curr_pack
suffix:semicolon
macro_line|#ifndef NO_PTHREADS
DECL|variable|thread_data
r_static
r_struct
id|thread_local
op_star
id|thread_data
suffix:semicolon
DECL|variable|nr_dispatched
r_static
r_int
id|nr_dispatched
suffix:semicolon
DECL|variable|threads_active
r_static
r_int
id|threads_active
suffix:semicolon
DECL|variable|read_mutex
r_static
id|pthread_mutex_t
id|read_mutex
suffix:semicolon
DECL|macro|read_lock
mdefine_line|#define read_lock()&t;&t;lock_mutex(&amp;read_mutex)
DECL|macro|read_unlock
mdefine_line|#define read_unlock()&t;&t;unlock_mutex(&amp;read_mutex)
DECL|variable|counter_mutex
r_static
id|pthread_mutex_t
id|counter_mutex
suffix:semicolon
DECL|macro|counter_lock
mdefine_line|#define counter_lock()&t;&t;lock_mutex(&amp;counter_mutex)
DECL|macro|counter_unlock
mdefine_line|#define counter_unlock()&t;unlock_mutex(&amp;counter_mutex)
DECL|variable|work_mutex
r_static
id|pthread_mutex_t
id|work_mutex
suffix:semicolon
DECL|macro|work_lock
mdefine_line|#define work_lock()&t;&t;lock_mutex(&amp;work_mutex)
DECL|macro|work_unlock
mdefine_line|#define work_unlock()&t;&t;unlock_mutex(&amp;work_mutex)
DECL|variable|deepest_delta_mutex
r_static
id|pthread_mutex_t
id|deepest_delta_mutex
suffix:semicolon
DECL|macro|deepest_delta_lock
mdefine_line|#define deepest_delta_lock()&t;lock_mutex(&amp;deepest_delta_mutex)
DECL|macro|deepest_delta_unlock
mdefine_line|#define deepest_delta_unlock()&t;unlock_mutex(&amp;deepest_delta_mutex)
DECL|variable|type_cas_mutex
r_static
id|pthread_mutex_t
id|type_cas_mutex
suffix:semicolon
DECL|macro|type_cas_lock
mdefine_line|#define type_cas_lock()&t;&t;lock_mutex(&amp;type_cas_mutex)
DECL|macro|type_cas_unlock
mdefine_line|#define type_cas_unlock()&t;unlock_mutex(&amp;type_cas_mutex)
DECL|variable|key
r_static
id|pthread_key_t
id|key
suffix:semicolon
DECL|function|lock_mutex
r_static
r_inline
r_void
id|lock_mutex
c_func
(paren
id|pthread_mutex_t
op_star
id|mutex
)paren
(brace
r_if
c_cond
(paren
id|threads_active
)paren
id|pthread_mutex_lock
c_func
(paren
id|mutex
)paren
suffix:semicolon
)brace
DECL|function|unlock_mutex
r_static
r_inline
r_void
id|unlock_mutex
c_func
(paren
id|pthread_mutex_t
op_star
id|mutex
)paren
(brace
r_if
c_cond
(paren
id|threads_active
)paren
id|pthread_mutex_unlock
c_func
(paren
id|mutex
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Mutex and conditional variable can&squot;t be statically-initialized on Windows.&n; */
DECL|function|init_thread
r_static
r_void
id|init_thread
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|init_recursive_mutex
c_func
(paren
op_amp
id|read_mutex
)paren
suffix:semicolon
id|pthread_mutex_init
c_func
(paren
op_amp
id|counter_mutex
comma
l_int|NULL
)paren
suffix:semicolon
id|pthread_mutex_init
c_func
(paren
op_amp
id|work_mutex
comma
l_int|NULL
)paren
suffix:semicolon
id|pthread_mutex_init
c_func
(paren
op_amp
id|type_cas_mutex
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|show_stat
)paren
id|pthread_mutex_init
c_func
(paren
op_amp
id|deepest_delta_mutex
comma
l_int|NULL
)paren
suffix:semicolon
id|pthread_key_create
c_func
(paren
op_amp
id|key
comma
l_int|NULL
)paren
suffix:semicolon
id|thread_data
op_assign
id|xcalloc
c_func
(paren
id|nr_threads
comma
r_sizeof
(paren
op_star
id|thread_data
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_threads
suffix:semicolon
id|i
op_increment
)paren
(brace
id|thread_data
(braket
id|i
)braket
dot
id|pack_fd
op_assign
id|open
c_func
(paren
id|curr_pack
comma
id|O_RDONLY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|thread_data
(braket
id|i
)braket
dot
id|pack_fd
op_eq
l_int|1
)paren
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;unable to open %s&quot;
)paren
comma
id|curr_pack
)paren
suffix:semicolon
)brace
id|threads_active
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|cleanup_thread
r_static
r_void
id|cleanup_thread
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|threads_active
)paren
r_return
suffix:semicolon
id|threads_active
op_assign
l_int|0
suffix:semicolon
id|pthread_mutex_destroy
c_func
(paren
op_amp
id|read_mutex
)paren
suffix:semicolon
id|pthread_mutex_destroy
c_func
(paren
op_amp
id|counter_mutex
)paren
suffix:semicolon
id|pthread_mutex_destroy
c_func
(paren
op_amp
id|work_mutex
)paren
suffix:semicolon
id|pthread_mutex_destroy
c_func
(paren
op_amp
id|type_cas_mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|show_stat
)paren
id|pthread_mutex_destroy
c_func
(paren
op_amp
id|deepest_delta_mutex
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_threads
suffix:semicolon
id|i
op_increment
)paren
id|close
c_func
(paren
id|thread_data
(braket
id|i
)braket
dot
id|pack_fd
)paren
suffix:semicolon
id|pthread_key_delete
c_func
(paren
id|key
)paren
suffix:semicolon
id|free
c_func
(paren
id|thread_data
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|macro|read_lock
mdefine_line|#define read_lock()
DECL|macro|read_unlock
mdefine_line|#define read_unlock()
DECL|macro|counter_lock
mdefine_line|#define counter_lock()
DECL|macro|counter_unlock
mdefine_line|#define counter_unlock()
DECL|macro|work_lock
mdefine_line|#define work_lock()
DECL|macro|work_unlock
mdefine_line|#define work_unlock()
DECL|macro|deepest_delta_lock
mdefine_line|#define deepest_delta_lock()
DECL|macro|deepest_delta_unlock
mdefine_line|#define deepest_delta_unlock()
macro_line|#endif
DECL|function|mark_link
r_static
r_int
id|mark_link
c_func
(paren
r_struct
id|object
op_star
id|obj
comma
r_int
id|type
comma
r_void
op_star
id|data
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|obj
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
id|OBJ_ANY
op_logical_and
id|obj-&gt;type
op_ne
id|type
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;object type mismatch at %s&quot;
)paren
comma
id|sha1_to_hex
c_func
(paren
id|obj-&gt;sha1
)paren
)paren
suffix:semicolon
id|obj-&gt;flags
op_or_assign
id|FLAG_LINK
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* The content of each linked object must have been checked&n;   or it must be already present in the object database */
DECL|function|check_object
r_static
r_int
id|check_object
c_func
(paren
r_struct
id|object
op_star
id|obj
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|obj
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|obj-&gt;flags
op_amp
id|FLAG_LINK
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|obj-&gt;flags
op_amp
id|FLAG_CHECKED
)paren
)paren
(brace
r_int
r_int
id|size
suffix:semicolon
r_int
id|type
op_assign
id|sha1_object_info
c_func
(paren
id|obj-&gt;sha1
comma
op_amp
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_le
l_int|0
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;did not receive expected object %s&quot;
)paren
comma
id|sha1_to_hex
c_func
(paren
id|obj-&gt;sha1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
id|obj-&gt;type
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;object %s: expected type %s, found %s&quot;
)paren
comma
id|sha1_to_hex
c_func
(paren
id|obj-&gt;sha1
)paren
comma
r_typename
(paren
id|obj-&gt;type
)paren
comma
r_typename
(paren
id|type
)paren
)paren
suffix:semicolon
id|obj-&gt;flags
op_or_assign
id|FLAG_CHECKED
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|check_objects
r_static
r_int
id|check_objects
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|max
comma
id|foreign_nr
op_assign
l_int|0
suffix:semicolon
id|max
op_assign
id|get_max_object_index
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max
suffix:semicolon
id|i
op_increment
)paren
id|foreign_nr
op_add_assign
id|check_object
c_func
(paren
id|get_indexed_object
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
r_return
id|foreign_nr
suffix:semicolon
)brace
multiline_comment|/* Discard current buffer used content. */
DECL|function|flush
r_static
r_void
id|flush
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|input_offset
)paren
(brace
r_if
c_cond
(paren
id|output_fd
op_ge
l_int|0
)paren
id|write_or_die
c_func
(paren
id|output_fd
comma
id|input_buffer
comma
id|input_offset
)paren
suffix:semicolon
id|git_SHA1_Update
c_func
(paren
op_amp
id|input_ctx
comma
id|input_buffer
comma
id|input_offset
)paren
suffix:semicolon
id|memmove
c_func
(paren
id|input_buffer
comma
id|input_buffer
op_plus
id|input_offset
comma
id|input_len
)paren
suffix:semicolon
id|input_offset
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Make sure at least &quot;min&quot; bytes are available in the buffer, and&n; * return the pointer to the buffer.&n; */
DECL|function|fill
r_static
r_void
op_star
id|fill
c_func
(paren
r_int
id|min
)paren
(brace
r_if
c_cond
(paren
id|min
op_le
id|input_len
)paren
r_return
id|input_buffer
op_plus
id|input_offset
suffix:semicolon
r_if
c_cond
(paren
id|min
OG
r_sizeof
(paren
id|input_buffer
)paren
)paren
id|die
c_func
(paren
id|Q_
c_func
(paren
l_string|&quot;cannot fill %d byte&quot;
comma
l_string|&quot;cannot fill %d bytes&quot;
comma
id|min
)paren
comma
id|min
)paren
suffix:semicolon
id|flush
c_func
(paren
)paren
suffix:semicolon
r_do
(brace
id|ssize_t
id|ret
op_assign
id|xread
c_func
(paren
id|input_fd
comma
id|input_buffer
op_plus
id|input_len
comma
r_sizeof
(paren
id|input_buffer
)paren
id|input_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_le
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;early EOF&quot;
)paren
)paren
suffix:semicolon
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;read error on input&quot;
)paren
)paren
suffix:semicolon
)brace
id|input_len
op_add_assign
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|from_stdin
)paren
id|display_throughput
c_func
(paren
id|progress
comma
id|consumed_bytes
op_plus
id|input_len
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|input_len
OL
id|min
)paren
suffix:semicolon
r_return
id|input_buffer
suffix:semicolon
)brace
DECL|function|use
r_static
r_void
id|use
c_func
(paren
r_int
id|bytes
)paren
(brace
r_if
c_cond
(paren
id|bytes
OG
id|input_len
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;used more bytes than were available&quot;
)paren
)paren
suffix:semicolon
id|input_crc32
op_assign
id|crc32
c_func
(paren
id|input_crc32
comma
id|input_buffer
op_plus
id|input_offset
comma
id|bytes
)paren
suffix:semicolon
id|input_len
op_sub_assign
id|bytes
suffix:semicolon
id|input_offset
op_add_assign
id|bytes
suffix:semicolon
multiline_comment|/* make sure off_t is sufficiently large not to wrap */
r_if
c_cond
(paren
id|signed_add_overflows
c_func
(paren
id|consumed_bytes
comma
id|bytes
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;pack too large for current definition of off_t&quot;
)paren
)paren
suffix:semicolon
id|consumed_bytes
op_add_assign
id|bytes
suffix:semicolon
)brace
DECL|function|open_pack_file
r_static
r_const
r_char
op_star
id|open_pack_file
c_func
(paren
r_const
r_char
op_star
id|pack_name
)paren
(brace
r_if
c_cond
(paren
id|from_stdin
)paren
(brace
id|input_fd
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pack_name
)paren
(brace
r_static
r_char
id|tmp_file
(braket
id|PATH_MAX
)braket
suffix:semicolon
id|output_fd
op_assign
id|odb_mkstemp
c_func
(paren
id|tmp_file
comma
r_sizeof
(paren
id|tmp_file
)paren
comma
l_string|&quot;pack/tmp_pack_XXXXXX&quot;
)paren
suffix:semicolon
id|pack_name
op_assign
id|xstrdup
c_func
(paren
id|tmp_file
)paren
suffix:semicolon
)brace
r_else
id|output_fd
op_assign
id|open
c_func
(paren
id|pack_name
comma
id|O_CREAT
op_or
id|O_EXCL
op_or
id|O_RDWR
comma
l_int|0600
)paren
suffix:semicolon
r_if
c_cond
(paren
id|output_fd
OL
l_int|0
)paren
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;unable to create &squot;%s&squot;&quot;
)paren
comma
id|pack_name
)paren
suffix:semicolon
id|nothread_data.pack_fd
op_assign
id|output_fd
suffix:semicolon
)brace
r_else
(brace
id|input_fd
op_assign
id|open
c_func
(paren
id|pack_name
comma
id|O_RDONLY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|input_fd
OL
l_int|0
)paren
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;cannot open packfile &squot;%s&squot;&quot;
)paren
comma
id|pack_name
)paren
suffix:semicolon
id|output_fd
op_assign
l_int|1
suffix:semicolon
id|nothread_data.pack_fd
op_assign
id|input_fd
suffix:semicolon
)brace
id|git_SHA1_Init
c_func
(paren
op_amp
id|input_ctx
)paren
suffix:semicolon
r_return
id|pack_name
suffix:semicolon
)brace
DECL|function|parse_pack_header
r_static
r_void
id|parse_pack_header
c_func
(paren
r_void
)paren
(brace
r_struct
id|pack_header
op_star
id|hdr
op_assign
id|fill
c_func
(paren
r_sizeof
(paren
r_struct
id|pack_header
)paren
)paren
suffix:semicolon
multiline_comment|/* Header consistency check */
r_if
c_cond
(paren
id|hdr-&gt;hdr_signature
op_ne
id|htonl
c_func
(paren
id|PACK_SIGNATURE
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;pack signature mismatch&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pack_version_ok
c_func
(paren
id|hdr-&gt;hdr_version
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;pack version %&quot;
id|PRIu32
l_string|&quot; unsupported&quot;
)paren
comma
id|ntohl
c_func
(paren
id|hdr-&gt;hdr_version
)paren
)paren
suffix:semicolon
id|nr_objects
op_assign
id|ntohl
c_func
(paren
id|hdr-&gt;hdr_entries
)paren
suffix:semicolon
id|use
c_func
(paren
r_sizeof
(paren
r_struct
id|pack_header
)paren
)paren
suffix:semicolon
)brace
r_static
id|NORETURN
r_void
id|bad_object
c_func
(paren
r_int
r_int
id|offset
comma
r_const
r_char
op_star
id|format
comma
dot
dot
dot
)paren
id|__attribute__
c_func
(paren
(paren
id|format
(paren
id|printf
comma
l_int|2
comma
l_int|3
)paren
)paren
)paren
suffix:semicolon
DECL|function|bad_object
r_static
id|NORETURN
r_void
id|bad_object
c_func
(paren
r_int
r_int
id|offset
comma
r_const
r_char
op_star
id|format
comma
dot
dot
dot
)paren
(brace
id|va_list
id|params
suffix:semicolon
r_char
id|buf
(braket
l_int|1024
)braket
suffix:semicolon
id|va_start
c_func
(paren
id|params
comma
id|format
)paren
suffix:semicolon
id|vsnprintf
c_func
(paren
id|buf
comma
r_sizeof
(paren
id|buf
)paren
comma
id|format
comma
id|params
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|params
)paren
suffix:semicolon
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;pack has bad object at offset %lu: %s&quot;
)paren
comma
id|offset
comma
id|buf
)paren
suffix:semicolon
)brace
DECL|function|get_thread_data
r_static
r_inline
r_struct
id|thread_local
op_star
id|get_thread_data
c_func
(paren
r_void
)paren
(brace
macro_line|#ifndef NO_PTHREADS
r_if
c_cond
(paren
id|threads_active
)paren
r_return
id|pthread_getspecific
c_func
(paren
id|key
)paren
suffix:semicolon
m_assert
(paren
op_logical_neg
id|threads_active
op_logical_and
l_string|&quot;This should only be reached when all threads are gone&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
op_amp
id|nothread_data
suffix:semicolon
)brace
macro_line|#ifndef NO_PTHREADS
DECL|function|set_thread_data
r_static
r_void
id|set_thread_data
c_func
(paren
r_struct
id|thread_local
op_star
id|data
)paren
(brace
r_if
c_cond
(paren
id|threads_active
)paren
id|pthread_setspecific
c_func
(paren
id|key
comma
id|data
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|alloc_base_data
r_static
r_struct
id|base_data
op_star
id|alloc_base_data
c_func
(paren
r_void
)paren
(brace
r_struct
id|base_data
op_star
id|base
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|base_data
)paren
)paren
suffix:semicolon
id|base-&gt;ref_last
op_assign
l_int|1
suffix:semicolon
id|base-&gt;ofs_last
op_assign
l_int|1
suffix:semicolon
r_return
id|base
suffix:semicolon
)brace
DECL|function|free_base_data
r_static
r_void
id|free_base_data
c_func
(paren
r_struct
id|base_data
op_star
id|c
)paren
(brace
r_if
c_cond
(paren
id|c-&gt;data
)paren
(brace
id|free
c_func
(paren
id|c-&gt;data
)paren
suffix:semicolon
id|c-&gt;data
op_assign
l_int|NULL
suffix:semicolon
id|get_thread_data
c_func
(paren
)paren
op_member_access_from_pointer
id|base_cache_used
op_sub_assign
id|c-&gt;size
suffix:semicolon
)brace
)brace
DECL|function|prune_base_data
r_static
r_void
id|prune_base_data
c_func
(paren
r_struct
id|base_data
op_star
id|retain
)paren
(brace
r_struct
id|base_data
op_star
id|b
suffix:semicolon
r_struct
id|thread_local
op_star
id|data
op_assign
id|get_thread_data
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|b
op_assign
id|data-&gt;base_cache
suffix:semicolon
id|data-&gt;base_cache_used
OG
id|delta_base_cache_limit
op_logical_and
id|b
suffix:semicolon
id|b
op_assign
id|b-&gt;child
)paren
(brace
r_if
c_cond
(paren
id|b-&gt;data
op_logical_and
id|b
op_ne
id|retain
)paren
id|free_base_data
c_func
(paren
id|b
)paren
suffix:semicolon
)brace
)brace
DECL|function|link_base_data
r_static
r_void
id|link_base_data
c_func
(paren
r_struct
id|base_data
op_star
id|base
comma
r_struct
id|base_data
op_star
id|c
)paren
(brace
r_if
c_cond
(paren
id|base
)paren
id|base-&gt;child
op_assign
id|c
suffix:semicolon
r_else
id|get_thread_data
c_func
(paren
)paren
op_member_access_from_pointer
id|base_cache
op_assign
id|c
suffix:semicolon
id|c-&gt;base
op_assign
id|base
suffix:semicolon
id|c-&gt;child
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;data
)paren
id|get_thread_data
c_func
(paren
)paren
op_member_access_from_pointer
id|base_cache_used
op_add_assign
id|c-&gt;size
suffix:semicolon
id|prune_base_data
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
DECL|function|unlink_base_data
r_static
r_void
id|unlink_base_data
c_func
(paren
r_struct
id|base_data
op_star
id|c
)paren
(brace
r_struct
id|base_data
op_star
id|base
op_assign
id|c-&gt;base
suffix:semicolon
r_if
c_cond
(paren
id|base
)paren
id|base-&gt;child
op_assign
l_int|NULL
suffix:semicolon
r_else
id|get_thread_data
c_func
(paren
)paren
op_member_access_from_pointer
id|base_cache
op_assign
l_int|NULL
suffix:semicolon
id|free_base_data
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
DECL|function|is_delta_type
r_static
r_int
id|is_delta_type
c_func
(paren
r_enum
id|object_type
id|type
)paren
(brace
r_return
(paren
id|type
op_eq
id|OBJ_REF_DELTA
op_logical_or
id|type
op_eq
id|OBJ_OFS_DELTA
)paren
suffix:semicolon
)brace
DECL|function|unpack_entry_data
r_static
r_void
op_star
id|unpack_entry_data
c_func
(paren
r_int
r_int
id|offset
comma
r_int
r_int
id|size
comma
r_enum
id|object_type
id|type
comma
r_int
r_char
op_star
id|sha1
)paren
(brace
r_static
r_char
id|fixed_buf
(braket
l_int|8192
)braket
suffix:semicolon
r_int
id|status
suffix:semicolon
id|git_zstream
id|stream
suffix:semicolon
r_void
op_star
id|buf
suffix:semicolon
id|git_SHA_CTX
id|c
suffix:semicolon
r_char
id|hdr
(braket
l_int|32
)braket
suffix:semicolon
r_int
id|hdrlen
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_delta_type
c_func
(paren
id|type
)paren
)paren
(brace
id|hdrlen
op_assign
id|sprintf
c_func
(paren
id|hdr
comma
l_string|&quot;%s %lu&quot;
comma
r_typename
(paren
id|type
)paren
comma
id|size
)paren
op_plus
l_int|1
suffix:semicolon
id|git_SHA1_Init
c_func
(paren
op_amp
id|c
)paren
suffix:semicolon
id|git_SHA1_Update
c_func
(paren
op_amp
id|c
comma
id|hdr
comma
id|hdrlen
)paren
suffix:semicolon
)brace
r_else
id|sha1
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|OBJ_BLOB
op_logical_and
id|size
OG
id|big_file_threshold
)paren
id|buf
op_assign
id|fixed_buf
suffix:semicolon
r_else
id|buf
op_assign
id|xmalloc
c_func
(paren
id|size
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|stream
comma
l_int|0
comma
r_sizeof
(paren
id|stream
)paren
)paren
suffix:semicolon
id|git_inflate_init
c_func
(paren
op_amp
id|stream
)paren
suffix:semicolon
id|stream.next_out
op_assign
id|buf
suffix:semicolon
id|stream.avail_out
op_assign
id|buf
op_eq
id|fixed_buf
ques
c_cond
r_sizeof
(paren
id|fixed_buf
)paren
suffix:colon
id|size
suffix:semicolon
r_do
(brace
r_int
r_char
op_star
id|last_out
op_assign
id|stream.next_out
suffix:semicolon
id|stream.next_in
op_assign
id|fill
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|stream.avail_in
op_assign
id|input_len
suffix:semicolon
id|status
op_assign
id|git_inflate
c_func
(paren
op_amp
id|stream
comma
l_int|0
)paren
suffix:semicolon
id|use
c_func
(paren
id|input_len
id|stream.avail_in
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sha1
)paren
id|git_SHA1_Update
c_func
(paren
op_amp
id|c
comma
id|last_out
comma
id|stream.next_out
id|last_out
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf
op_eq
id|fixed_buf
)paren
(brace
id|stream.next_out
op_assign
id|buf
suffix:semicolon
id|stream.avail_out
op_assign
r_sizeof
(paren
id|fixed_buf
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|status
op_eq
id|Z_OK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stream.total_out
op_ne
id|size
op_logical_or
id|status
op_ne
id|Z_STREAM_END
)paren
id|bad_object
c_func
(paren
id|offset
comma
id|_
c_func
(paren
l_string|&quot;inflate returned %d&quot;
)paren
comma
id|status
)paren
suffix:semicolon
id|git_inflate_end
c_func
(paren
op_amp
id|stream
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sha1
)paren
id|git_SHA1_Final
c_func
(paren
id|sha1
comma
op_amp
id|c
)paren
suffix:semicolon
r_return
id|buf
op_eq
id|fixed_buf
ques
c_cond
l_int|NULL
suffix:colon
id|buf
suffix:semicolon
)brace
DECL|function|unpack_raw_entry
r_static
r_void
op_star
id|unpack_raw_entry
c_func
(paren
r_struct
id|object_entry
op_star
id|obj
comma
r_union
id|delta_base
op_star
id|delta_base
comma
r_int
r_char
op_star
id|sha1
)paren
(brace
r_int
r_char
op_star
id|p
suffix:semicolon
r_int
r_int
id|size
comma
id|c
suffix:semicolon
id|off_t
id|base_offset
suffix:semicolon
r_int
id|shift
suffix:semicolon
r_void
op_star
id|data
suffix:semicolon
id|obj-&gt;idx.offset
op_assign
id|consumed_bytes
suffix:semicolon
id|input_crc32
op_assign
id|crc32
c_func
(paren
l_int|0
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|p
op_assign
id|fill
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|c
op_assign
op_star
id|p
suffix:semicolon
id|use
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|obj-&gt;type
op_assign
(paren
id|c
op_rshift
l_int|4
)paren
op_amp
l_int|7
suffix:semicolon
id|size
op_assign
(paren
id|c
op_amp
l_int|15
)paren
suffix:semicolon
id|shift
op_assign
l_int|4
suffix:semicolon
r_while
c_loop
(paren
id|c
op_amp
l_int|0x80
)paren
(brace
id|p
op_assign
id|fill
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|c
op_assign
op_star
id|p
suffix:semicolon
id|use
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|size
op_add_assign
(paren
id|c
op_amp
l_int|0x7f
)paren
op_lshift
id|shift
suffix:semicolon
id|shift
op_add_assign
l_int|7
suffix:semicolon
)brace
id|obj-&gt;size
op_assign
id|size
suffix:semicolon
r_switch
c_cond
(paren
id|obj-&gt;type
)paren
(brace
r_case
id|OBJ_REF_DELTA
suffix:colon
id|hashcpy
c_func
(paren
id|delta_base-&gt;sha1
comma
id|fill
c_func
(paren
l_int|20
)paren
)paren
suffix:semicolon
id|use
c_func
(paren
l_int|20
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OBJ_OFS_DELTA
suffix:colon
id|memset
c_func
(paren
id|delta_base
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|delta_base
)paren
)paren
suffix:semicolon
id|p
op_assign
id|fill
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|c
op_assign
op_star
id|p
suffix:semicolon
id|use
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|base_offset
op_assign
id|c
op_amp
l_int|127
suffix:semicolon
r_while
c_loop
(paren
id|c
op_amp
l_int|128
)paren
(brace
id|base_offset
op_add_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|base_offset
op_logical_or
id|MSB
c_func
(paren
id|base_offset
comma
l_int|7
)paren
)paren
id|bad_object
c_func
(paren
id|obj-&gt;idx.offset
comma
id|_
c_func
(paren
l_string|&quot;offset value overflow for delta base object&quot;
)paren
)paren
suffix:semicolon
id|p
op_assign
id|fill
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|c
op_assign
op_star
id|p
suffix:semicolon
id|use
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|base_offset
op_assign
(paren
id|base_offset
op_lshift
l_int|7
)paren
op_plus
(paren
id|c
op_amp
l_int|127
)paren
suffix:semicolon
)brace
id|delta_base-&gt;offset
op_assign
id|obj-&gt;idx.offset
id|base_offset
suffix:semicolon
r_if
c_cond
(paren
id|delta_base-&gt;offset
op_le
l_int|0
op_logical_or
id|delta_base-&gt;offset
op_ge
id|obj-&gt;idx.offset
)paren
id|bad_object
c_func
(paren
id|obj-&gt;idx.offset
comma
id|_
c_func
(paren
l_string|&quot;delta base offset is out of bound&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OBJ_COMMIT
suffix:colon
r_case
id|OBJ_TREE
suffix:colon
r_case
id|OBJ_BLOB
suffix:colon
r_case
id|OBJ_TAG
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|bad_object
c_func
(paren
id|obj-&gt;idx.offset
comma
id|_
c_func
(paren
l_string|&quot;unknown object type %d&quot;
)paren
comma
id|obj-&gt;type
)paren
suffix:semicolon
)brace
id|obj-&gt;hdr_size
op_assign
id|consumed_bytes
id|obj-&gt;idx.offset
suffix:semicolon
id|data
op_assign
id|unpack_entry_data
c_func
(paren
id|obj-&gt;idx.offset
comma
id|obj-&gt;size
comma
id|obj-&gt;type
comma
id|sha1
)paren
suffix:semicolon
id|obj-&gt;idx.crc32
op_assign
id|input_crc32
suffix:semicolon
r_return
id|data
suffix:semicolon
)brace
DECL|function|unpack_data
r_static
r_void
op_star
id|unpack_data
c_func
(paren
r_struct
id|object_entry
op_star
id|obj
comma
r_int
(paren
op_star
id|consume
)paren
(paren
r_const
r_int
r_char
op_star
comma
r_int
r_int
comma
r_void
op_star
)paren
comma
r_void
op_star
id|cb_data
)paren
(brace
id|off_t
id|from
op_assign
id|obj
(braket
l_int|0
)braket
dot
id|idx.offset
op_plus
id|obj
(braket
l_int|0
)braket
dot
id|hdr_size
suffix:semicolon
r_int
r_int
id|len
op_assign
id|obj
(braket
l_int|1
)braket
dot
id|idx.offset
id|from
suffix:semicolon
r_int
r_char
op_star
id|data
comma
op_star
id|inbuf
suffix:semicolon
id|git_zstream
id|stream
suffix:semicolon
r_int
id|status
suffix:semicolon
id|data
op_assign
id|xmalloc
c_func
(paren
id|consume
ques
c_cond
l_int|64
op_star
l_int|1024
suffix:colon
id|obj-&gt;size
)paren
suffix:semicolon
id|inbuf
op_assign
id|xmalloc
c_func
(paren
(paren
id|len
OL
l_int|64
op_star
l_int|1024
)paren
ques
c_cond
id|len
suffix:colon
l_int|64
op_star
l_int|1024
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|stream
comma
l_int|0
comma
r_sizeof
(paren
id|stream
)paren
)paren
suffix:semicolon
id|git_inflate_init
c_func
(paren
op_amp
id|stream
)paren
suffix:semicolon
id|stream.next_out
op_assign
id|data
suffix:semicolon
id|stream.avail_out
op_assign
id|consume
ques
c_cond
l_int|64
op_star
l_int|1024
suffix:colon
id|obj-&gt;size
suffix:semicolon
r_do
(brace
id|ssize_t
id|n
op_assign
(paren
id|len
OL
l_int|64
op_star
l_int|1024
)paren
ques
c_cond
id|len
suffix:colon
l_int|64
op_star
l_int|1024
suffix:semicolon
id|n
op_assign
id|xpread
c_func
(paren
id|get_thread_data
c_func
(paren
)paren
op_member_access_from_pointer
id|pack_fd
comma
id|inbuf
comma
id|n
comma
id|from
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
OL
l_int|0
)paren
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;cannot pread pack file&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n
)paren
id|die
c_func
(paren
id|Q_
c_func
(paren
l_string|&quot;premature end of pack file, %lu byte missing&quot;
comma
l_string|&quot;premature end of pack file, %lu bytes missing&quot;
comma
id|len
)paren
comma
id|len
)paren
suffix:semicolon
id|from
op_add_assign
id|n
suffix:semicolon
id|len
op_sub_assign
id|n
suffix:semicolon
id|stream.next_in
op_assign
id|inbuf
suffix:semicolon
id|stream.avail_in
op_assign
id|n
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|consume
)paren
id|status
op_assign
id|git_inflate
c_func
(paren
op_amp
id|stream
comma
l_int|0
)paren
suffix:semicolon
r_else
(brace
r_do
(brace
id|status
op_assign
id|git_inflate
c_func
(paren
op_amp
id|stream
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|consume
c_func
(paren
id|data
comma
id|stream.next_out
id|data
comma
id|cb_data
)paren
)paren
(brace
id|free
c_func
(paren
id|inbuf
)paren
suffix:semicolon
id|free
c_func
(paren
id|data
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|stream.next_out
op_assign
id|data
suffix:semicolon
id|stream.avail_out
op_assign
l_int|64
op_star
l_int|1024
suffix:semicolon
)brace
r_while
c_loop
(paren
id|status
op_eq
id|Z_OK
op_logical_and
id|stream.avail_in
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|len
op_logical_and
id|status
op_eq
id|Z_OK
op_logical_and
op_logical_neg
id|stream.avail_in
)paren
suffix:semicolon
multiline_comment|/* This has been inflated OK when first encountered, so... */
r_if
c_cond
(paren
id|status
op_ne
id|Z_STREAM_END
op_logical_or
id|stream.total_out
op_ne
id|obj-&gt;size
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;serious inflate inconsistency&quot;
)paren
)paren
suffix:semicolon
id|git_inflate_end
c_func
(paren
op_amp
id|stream
)paren
suffix:semicolon
id|free
c_func
(paren
id|inbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|consume
)paren
(brace
id|free
c_func
(paren
id|data
)paren
suffix:semicolon
id|data
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|data
suffix:semicolon
)brace
DECL|function|get_data_from_pack
r_static
r_void
op_star
id|get_data_from_pack
c_func
(paren
r_struct
id|object_entry
op_star
id|obj
)paren
(brace
r_return
id|unpack_data
c_func
(paren
id|obj
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|compare_delta_bases
r_static
r_int
id|compare_delta_bases
c_func
(paren
r_const
r_union
id|delta_base
op_star
id|base1
comma
r_const
r_union
id|delta_base
op_star
id|base2
comma
r_enum
id|object_type
id|type1
comma
r_enum
id|object_type
id|type2
)paren
(brace
r_int
id|cmp
op_assign
id|type1
id|type2
suffix:semicolon
r_if
c_cond
(paren
id|cmp
)paren
r_return
id|cmp
suffix:semicolon
r_return
id|memcmp
c_func
(paren
id|base1
comma
id|base2
comma
id|UNION_BASE_SZ
)paren
suffix:semicolon
)brace
DECL|function|find_delta
r_static
r_int
id|find_delta
c_func
(paren
r_const
r_union
id|delta_base
op_star
id|base
comma
r_enum
id|object_type
id|type
)paren
(brace
r_int
id|first
op_assign
l_int|0
comma
id|last
op_assign
id|nr_deltas
suffix:semicolon
r_while
c_loop
(paren
id|first
OL
id|last
)paren
(brace
r_int
id|next
op_assign
(paren
id|first
op_plus
id|last
)paren
op_div
l_int|2
suffix:semicolon
r_struct
id|delta_entry
op_star
id|delta
op_assign
op_amp
id|deltas
(braket
id|next
)braket
suffix:semicolon
r_int
id|cmp
suffix:semicolon
id|cmp
op_assign
id|compare_delta_bases
c_func
(paren
id|base
comma
op_amp
id|delta-&gt;base
comma
id|type
comma
id|objects
(braket
id|delta-&gt;obj_no
)braket
dot
id|type
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmp
)paren
r_return
id|next
suffix:semicolon
r_if
c_cond
(paren
id|cmp
OL
l_int|0
)paren
(brace
id|last
op_assign
id|next
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|first
op_assign
id|next
op_plus
l_int|1
suffix:semicolon
)brace
r_return
id|first
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|find_delta_children
r_static
r_void
id|find_delta_children
c_func
(paren
r_const
r_union
id|delta_base
op_star
id|base
comma
r_int
op_star
id|first_index
comma
r_int
op_star
id|last_index
comma
r_enum
id|object_type
id|type
)paren
(brace
r_int
id|first
op_assign
id|find_delta
c_func
(paren
id|base
comma
id|type
)paren
suffix:semicolon
r_int
id|last
op_assign
id|first
suffix:semicolon
r_int
id|end
op_assign
id|nr_deltas
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|first
OL
l_int|0
)paren
(brace
op_star
id|first_index
op_assign
l_int|0
suffix:semicolon
op_star
id|last_index
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
r_while
c_loop
(paren
id|first
OG
l_int|0
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
op_amp
id|deltas
(braket
id|first
l_int|1
)braket
dot
id|base
comma
id|base
comma
id|UNION_BASE_SZ
)paren
)paren
op_decrement
id|first
suffix:semicolon
r_while
c_loop
(paren
id|last
OL
id|end
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
op_amp
id|deltas
(braket
id|last
op_plus
l_int|1
)braket
dot
id|base
comma
id|base
comma
id|UNION_BASE_SZ
)paren
)paren
op_increment
id|last
suffix:semicolon
op_star
id|first_index
op_assign
id|first
suffix:semicolon
op_star
id|last_index
op_assign
id|last
suffix:semicolon
)brace
DECL|struct|compare_data
r_struct
id|compare_data
(brace
DECL|member|entry
r_struct
id|object_entry
op_star
id|entry
suffix:semicolon
DECL|member|st
r_struct
id|git_istream
op_star
id|st
suffix:semicolon
DECL|member|buf
r_int
r_char
op_star
id|buf
suffix:semicolon
DECL|member|buf_size
r_int
r_int
id|buf_size
suffix:semicolon
)brace
suffix:semicolon
DECL|function|compare_objects
r_static
r_int
id|compare_objects
c_func
(paren
r_const
r_int
r_char
op_star
id|buf
comma
r_int
r_int
id|size
comma
r_void
op_star
id|cb_data
)paren
(brace
r_struct
id|compare_data
op_star
id|data
op_assign
id|cb_data
suffix:semicolon
r_if
c_cond
(paren
id|data-&gt;buf_size
OL
id|size
)paren
(brace
id|free
c_func
(paren
id|data-&gt;buf
)paren
suffix:semicolon
id|data-&gt;buf
op_assign
id|xmalloc
c_func
(paren
id|size
)paren
suffix:semicolon
id|data-&gt;buf_size
op_assign
id|size
suffix:semicolon
)brace
r_while
c_loop
(paren
id|size
)paren
(brace
id|ssize_t
id|len
op_assign
id|read_istream
c_func
(paren
id|data-&gt;st
comma
id|data-&gt;buf
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
l_int|0
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;SHA1 COLLISION FOUND WITH %s !&quot;
)paren
comma
id|sha1_to_hex
c_func
(paren
id|data-&gt;entry-&gt;idx.sha1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;unable to read %s&quot;
)paren
comma
id|sha1_to_hex
c_func
(paren
id|data-&gt;entry-&gt;idx.sha1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|buf
comma
id|data-&gt;buf
comma
id|len
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;SHA1 COLLISION FOUND WITH %s !&quot;
)paren
comma
id|sha1_to_hex
c_func
(paren
id|data-&gt;entry-&gt;idx.sha1
)paren
)paren
suffix:semicolon
id|size
op_sub_assign
id|len
suffix:semicolon
id|buf
op_add_assign
id|len
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|check_collison
r_static
r_int
id|check_collison
c_func
(paren
r_struct
id|object_entry
op_star
id|entry
)paren
(brace
r_struct
id|compare_data
id|data
suffix:semicolon
r_enum
id|object_type
id|type
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;size
op_le
id|big_file_threshold
op_logical_or
id|entry-&gt;type
op_ne
id|OBJ_BLOB
)paren
r_return
l_int|1
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|data
comma
l_int|0
comma
r_sizeof
(paren
id|data
)paren
)paren
suffix:semicolon
id|data.entry
op_assign
id|entry
suffix:semicolon
id|data.st
op_assign
id|open_istream
c_func
(paren
id|entry-&gt;idx.sha1
comma
op_amp
id|type
comma
op_amp
id|size
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data.st
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|size
op_ne
id|entry-&gt;size
op_logical_or
id|type
op_ne
id|entry-&gt;type
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;SHA1 COLLISION FOUND WITH %s !&quot;
)paren
comma
id|sha1_to_hex
c_func
(paren
id|entry-&gt;idx.sha1
)paren
)paren
suffix:semicolon
id|unpack_data
c_func
(paren
id|entry
comma
id|compare_objects
comma
op_amp
id|data
)paren
suffix:semicolon
id|close_istream
c_func
(paren
id|data.st
)paren
suffix:semicolon
id|free
c_func
(paren
id|data.buf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sha1_object
r_static
r_void
id|sha1_object
c_func
(paren
r_const
r_void
op_star
id|data
comma
r_struct
id|object_entry
op_star
id|obj_entry
comma
r_int
r_int
id|size
comma
r_enum
id|object_type
id|type
comma
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_void
op_star
id|new_data
op_assign
l_int|NULL
suffix:semicolon
r_int
id|collision_test_needed
suffix:semicolon
m_assert
(paren
id|data
op_logical_or
id|obj_entry
)paren
suffix:semicolon
id|read_lock
c_func
(paren
)paren
suffix:semicolon
id|collision_test_needed
op_assign
id|has_sha1_file
c_func
(paren
id|sha1
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|collision_test_needed
op_logical_and
op_logical_neg
id|data
)paren
(brace
id|read_lock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|check_collison
c_func
(paren
id|obj_entry
)paren
)paren
id|collision_test_needed
op_assign
l_int|0
suffix:semicolon
id|read_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|collision_test_needed
)paren
(brace
r_void
op_star
id|has_data
suffix:semicolon
r_enum
id|object_type
id|has_type
suffix:semicolon
r_int
r_int
id|has_size
suffix:semicolon
id|read_lock
c_func
(paren
)paren
suffix:semicolon
id|has_type
op_assign
id|sha1_object_info
c_func
(paren
id|sha1
comma
op_amp
id|has_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|has_type
op_ne
id|type
op_logical_or
id|has_size
op_ne
id|size
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;SHA1 COLLISION FOUND WITH %s !&quot;
)paren
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
id|has_data
op_assign
id|read_sha1_file
c_func
(paren
id|sha1
comma
op_amp
id|has_type
comma
op_amp
id|has_size
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
id|data
op_assign
id|new_data
op_assign
id|get_data_from_pack
c_func
(paren
id|obj_entry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|has_data
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;cannot read existing object %s&quot;
)paren
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_ne
id|has_size
op_logical_or
id|type
op_ne
id|has_type
op_logical_or
id|memcmp
c_func
(paren
id|data
comma
id|has_data
comma
id|size
)paren
op_ne
l_int|0
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;SHA1 COLLISION FOUND WITH %s !&quot;
)paren
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
id|free
c_func
(paren
id|has_data
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strict
)paren
(brace
id|read_lock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|OBJ_BLOB
)paren
(brace
r_struct
id|blob
op_star
id|blob
op_assign
id|lookup_blob
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blob
)paren
id|blob-&gt;object.flags
op_or_assign
id|FLAG_CHECKED
suffix:semicolon
r_else
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;invalid blob object %s&quot;
)paren
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|object
op_star
id|obj
suffix:semicolon
r_int
id|eaten
suffix:semicolon
r_void
op_star
id|buf
op_assign
(paren
r_void
op_star
)paren
id|data
suffix:semicolon
m_assert
(paren
id|data
op_logical_and
l_string|&quot;data can only be NULL for large _blobs_&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * we do not need to free the memory here, as the&n;&t;&t;&t; * buf is deleted by the caller.&n;&t;&t;&t; */
id|obj
op_assign
id|parse_object_buffer
c_func
(paren
id|sha1
comma
id|type
comma
id|size
comma
id|buf
comma
op_amp
id|eaten
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|obj
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;invalid %s&quot;
)paren
comma
r_typename
(paren
id|type
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|do_fsck_object
op_logical_and
id|fsck_object
c_func
(paren
id|obj
comma
id|buf
comma
id|size
comma
l_int|1
comma
id|fsck_error_function
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Error in object&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fsck_walk
c_func
(paren
id|obj
comma
id|mark_link
comma
l_int|NULL
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Not all child objects of %s are reachable&quot;
)paren
comma
id|sha1_to_hex
c_func
(paren
id|obj-&gt;sha1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|obj-&gt;type
op_eq
id|OBJ_TREE
)paren
(brace
r_struct
id|tree
op_star
id|item
op_assign
(paren
r_struct
id|tree
op_star
)paren
id|obj
suffix:semicolon
id|item-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
id|obj-&gt;parsed
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|obj-&gt;type
op_eq
id|OBJ_COMMIT
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
(paren
r_struct
id|commit
op_star
)paren
id|obj
suffix:semicolon
r_if
c_cond
(paren
id|detach_commit_buffer
c_func
(paren
id|commit
comma
l_int|NULL
)paren
op_ne
id|data
)paren
id|die
c_func
(paren
l_string|&quot;BUG: parse_object_buffer transmogrified our buffer&quot;
)paren
suffix:semicolon
)brace
id|obj-&gt;flags
op_or_assign
id|FLAG_CHECKED
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
id|free
c_func
(paren
id|new_data
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is part of find_unresolved_deltas(). There are two&n; * walkers going in the opposite ways.&n; *&n; * The first one in find_unresolved_deltas() traverses down from&n; * parent node to children, deflating nodes along the way. However,&n; * memory for deflated nodes is limited by delta_base_cache_limit, so&n; * at some point parent node&squot;s deflated content may be freed.&n; *&n; * The second walker is this function, which goes from current node up&n; * to top parent if necessary to deflate the node. In normal&n; * situation, its parent node would be already deflated, so it just&n; * needs to apply delta.&n; *&n; * In the worst case scenario, parent node is no longer deflated because&n; * we&squot;re running out of delta_base_cache_limit; we need to re-deflate&n; * parents, possibly up to the top base.&n; *&n; * All deflated objects here are subject to be freed if we exceed&n; * delta_base_cache_limit, just like in find_unresolved_deltas(), we&n; * just need to make sure the last node is not freed.&n; */
DECL|function|get_base_data
r_static
r_void
op_star
id|get_base_data
c_func
(paren
r_struct
id|base_data
op_star
id|c
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;data
)paren
(brace
r_struct
id|object_entry
op_star
id|obj
op_assign
id|c-&gt;obj
suffix:semicolon
r_struct
id|base_data
op_star
op_star
id|delta
op_assign
l_int|NULL
suffix:semicolon
r_int
id|delta_nr
op_assign
l_int|0
comma
id|delta_alloc
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|is_delta_type
c_func
(paren
id|c-&gt;obj-&gt;type
)paren
op_logical_and
op_logical_neg
id|c-&gt;data
)paren
(brace
id|ALLOC_GROW
c_func
(paren
id|delta
comma
id|delta_nr
op_plus
l_int|1
comma
id|delta_alloc
)paren
suffix:semicolon
id|delta
(braket
id|delta_nr
op_increment
)braket
op_assign
id|c
suffix:semicolon
id|c
op_assign
id|c-&gt;base
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|delta_nr
)paren
(brace
id|c-&gt;data
op_assign
id|get_data_from_pack
c_func
(paren
id|obj
)paren
suffix:semicolon
id|c-&gt;size
op_assign
id|obj-&gt;size
suffix:semicolon
id|get_thread_data
c_func
(paren
)paren
op_member_access_from_pointer
id|base_cache_used
op_add_assign
id|c-&gt;size
suffix:semicolon
id|prune_base_data
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
id|delta_nr
OG
l_int|0
suffix:semicolon
id|delta_nr
op_decrement
)paren
(brace
r_void
op_star
id|base
comma
op_star
id|raw
suffix:semicolon
id|c
op_assign
id|delta
(braket
id|delta_nr
l_int|1
)braket
suffix:semicolon
id|obj
op_assign
id|c-&gt;obj
suffix:semicolon
id|base
op_assign
id|get_base_data
c_func
(paren
id|c-&gt;base
)paren
suffix:semicolon
id|raw
op_assign
id|get_data_from_pack
c_func
(paren
id|obj
)paren
suffix:semicolon
id|c-&gt;data
op_assign
id|patch_delta
c_func
(paren
id|base
comma
id|c-&gt;base-&gt;size
comma
id|raw
comma
id|obj-&gt;size
comma
op_amp
id|c-&gt;size
)paren
suffix:semicolon
id|free
c_func
(paren
id|raw
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;data
)paren
id|bad_object
c_func
(paren
id|obj-&gt;idx.offset
comma
id|_
c_func
(paren
l_string|&quot;failed to apply delta&quot;
)paren
)paren
suffix:semicolon
id|get_thread_data
c_func
(paren
)paren
op_member_access_from_pointer
id|base_cache_used
op_add_assign
id|c-&gt;size
suffix:semicolon
id|prune_base_data
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
id|free
c_func
(paren
id|delta
)paren
suffix:semicolon
)brace
r_return
id|c-&gt;data
suffix:semicolon
)brace
DECL|function|resolve_delta
r_static
r_void
id|resolve_delta
c_func
(paren
r_struct
id|object_entry
op_star
id|delta_obj
comma
r_struct
id|base_data
op_star
id|base
comma
r_struct
id|base_data
op_star
id|result
)paren
(brace
r_void
op_star
id|base_data
comma
op_star
id|delta_data
suffix:semicolon
r_if
c_cond
(paren
id|show_stat
)paren
(brace
id|delta_obj-&gt;delta_depth
op_assign
id|base-&gt;obj-&gt;delta_depth
op_plus
l_int|1
suffix:semicolon
id|deepest_delta_lock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|deepest_delta
OL
id|delta_obj-&gt;delta_depth
)paren
id|deepest_delta
op_assign
id|delta_obj-&gt;delta_depth
suffix:semicolon
id|deepest_delta_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
id|delta_obj-&gt;base_object_no
op_assign
id|base-&gt;obj
id|objects
suffix:semicolon
id|delta_data
op_assign
id|get_data_from_pack
c_func
(paren
id|delta_obj
)paren
suffix:semicolon
id|base_data
op_assign
id|get_base_data
c_func
(paren
id|base
)paren
suffix:semicolon
id|result-&gt;obj
op_assign
id|delta_obj
suffix:semicolon
id|result-&gt;data
op_assign
id|patch_delta
c_func
(paren
id|base_data
comma
id|base-&gt;size
comma
id|delta_data
comma
id|delta_obj-&gt;size
comma
op_amp
id|result-&gt;size
)paren
suffix:semicolon
id|free
c_func
(paren
id|delta_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result-&gt;data
)paren
id|bad_object
c_func
(paren
id|delta_obj-&gt;idx.offset
comma
id|_
c_func
(paren
l_string|&quot;failed to apply delta&quot;
)paren
)paren
suffix:semicolon
id|hash_sha1_file
c_func
(paren
id|result-&gt;data
comma
id|result-&gt;size
comma
r_typename
(paren
id|delta_obj-&gt;real_type
)paren
comma
id|delta_obj-&gt;idx.sha1
)paren
suffix:semicolon
id|sha1_object
c_func
(paren
id|result-&gt;data
comma
l_int|NULL
comma
id|result-&gt;size
comma
id|delta_obj-&gt;real_type
comma
id|delta_obj-&gt;idx.sha1
)paren
suffix:semicolon
id|counter_lock
c_func
(paren
)paren
suffix:semicolon
id|nr_resolved_deltas
op_increment
suffix:semicolon
id|counter_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Standard boolean compare-and-swap: atomically check whether &quot;*type&quot; is&n; * &quot;want&quot;; if so, swap in &quot;set&quot; and return true. Otherwise, leave it untouched&n; * and return false.&n; */
DECL|function|compare_and_swap_type
r_static
r_int
id|compare_and_swap_type
c_func
(paren
r_enum
id|object_type
op_star
id|type
comma
r_enum
id|object_type
id|want
comma
r_enum
id|object_type
id|set
)paren
(brace
r_enum
id|object_type
id|old
suffix:semicolon
id|type_cas_lock
c_func
(paren
)paren
suffix:semicolon
id|old
op_assign
op_star
id|type
suffix:semicolon
r_if
c_cond
(paren
id|old
op_eq
id|want
)paren
op_star
id|type
op_assign
id|set
suffix:semicolon
id|type_cas_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
id|old
op_eq
id|want
suffix:semicolon
)brace
DECL|function|find_unresolved_deltas_1
r_static
r_struct
id|base_data
op_star
id|find_unresolved_deltas_1
c_func
(paren
r_struct
id|base_data
op_star
id|base
comma
r_struct
id|base_data
op_star
id|prev_base
)paren
(brace
r_if
c_cond
(paren
id|base-&gt;ref_last
op_eq
l_int|1
op_logical_and
id|base-&gt;ofs_last
op_eq
l_int|1
)paren
(brace
r_union
id|delta_base
id|base_spec
suffix:semicolon
id|hashcpy
c_func
(paren
id|base_spec.sha1
comma
id|base-&gt;obj-&gt;idx.sha1
)paren
suffix:semicolon
id|find_delta_children
c_func
(paren
op_amp
id|base_spec
comma
op_amp
id|base-&gt;ref_first
comma
op_amp
id|base-&gt;ref_last
comma
id|OBJ_REF_DELTA
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|base_spec
comma
l_int|0
comma
r_sizeof
(paren
id|base_spec
)paren
)paren
suffix:semicolon
id|base_spec.offset
op_assign
id|base-&gt;obj-&gt;idx.offset
suffix:semicolon
id|find_delta_children
c_func
(paren
op_amp
id|base_spec
comma
op_amp
id|base-&gt;ofs_first
comma
op_amp
id|base-&gt;ofs_last
comma
id|OBJ_OFS_DELTA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base-&gt;ref_last
op_eq
l_int|1
op_logical_and
id|base-&gt;ofs_last
op_eq
l_int|1
)paren
(brace
id|free
c_func
(paren
id|base-&gt;data
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|link_base_data
c_func
(paren
id|prev_base
comma
id|base
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|base-&gt;ref_first
op_le
id|base-&gt;ref_last
)paren
(brace
r_struct
id|object_entry
op_star
id|child
op_assign
id|objects
op_plus
id|deltas
(braket
id|base-&gt;ref_first
)braket
dot
id|obj_no
suffix:semicolon
r_struct
id|base_data
op_star
id|result
op_assign
id|alloc_base_data
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|compare_and_swap_type
c_func
(paren
op_amp
id|child-&gt;real_type
comma
id|OBJ_REF_DELTA
comma
id|base-&gt;obj-&gt;real_type
)paren
)paren
id|die
c_func
(paren
l_string|&quot;BUG: child-&gt;real_type != OBJ_REF_DELTA&quot;
)paren
suffix:semicolon
id|resolve_delta
c_func
(paren
id|child
comma
id|base
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base-&gt;ref_first
op_eq
id|base-&gt;ref_last
op_logical_and
id|base-&gt;ofs_last
op_eq
l_int|1
)paren
id|free_base_data
c_func
(paren
id|base
)paren
suffix:semicolon
id|base-&gt;ref_first
op_increment
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
r_if
c_cond
(paren
id|base-&gt;ofs_first
op_le
id|base-&gt;ofs_last
)paren
(brace
r_struct
id|object_entry
op_star
id|child
op_assign
id|objects
op_plus
id|deltas
(braket
id|base-&gt;ofs_first
)braket
dot
id|obj_no
suffix:semicolon
r_struct
id|base_data
op_star
id|result
op_assign
id|alloc_base_data
c_func
(paren
)paren
suffix:semicolon
m_assert
(paren
id|child-&gt;real_type
op_eq
id|OBJ_OFS_DELTA
)paren
suffix:semicolon
id|child-&gt;real_type
op_assign
id|base-&gt;obj-&gt;real_type
suffix:semicolon
id|resolve_delta
c_func
(paren
id|child
comma
id|base
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base-&gt;ofs_first
op_eq
id|base-&gt;ofs_last
)paren
id|free_base_data
c_func
(paren
id|base
)paren
suffix:semicolon
id|base-&gt;ofs_first
op_increment
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
id|unlink_base_data
c_func
(paren
id|base
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|find_unresolved_deltas
r_static
r_void
id|find_unresolved_deltas
c_func
(paren
r_struct
id|base_data
op_star
id|base
)paren
(brace
r_struct
id|base_data
op_star
id|new_base
comma
op_star
id|prev_base
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|new_base
op_assign
id|find_unresolved_deltas_1
c_func
(paren
id|base
comma
id|prev_base
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_base
)paren
(brace
id|prev_base
op_assign
id|base
suffix:semicolon
id|base
op_assign
id|new_base
suffix:semicolon
)brace
r_else
(brace
id|free
c_func
(paren
id|base
)paren
suffix:semicolon
id|base
op_assign
id|prev_base
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|base
)paren
r_return
suffix:semicolon
id|prev_base
op_assign
id|base-&gt;base
suffix:semicolon
)brace
)brace
)brace
DECL|function|compare_delta_entry
r_static
r_int
id|compare_delta_entry
c_func
(paren
r_const
r_void
op_star
id|a
comma
r_const
r_void
op_star
id|b
)paren
(brace
r_const
r_struct
id|delta_entry
op_star
id|delta_a
op_assign
id|a
suffix:semicolon
r_const
r_struct
id|delta_entry
op_star
id|delta_b
op_assign
id|b
suffix:semicolon
multiline_comment|/* group by type (ref vs ofs) and then by value (sha-1 or offset) */
r_return
id|compare_delta_bases
c_func
(paren
op_amp
id|delta_a-&gt;base
comma
op_amp
id|delta_b-&gt;base
comma
id|objects
(braket
id|delta_a-&gt;obj_no
)braket
dot
id|type
comma
id|objects
(braket
id|delta_b-&gt;obj_no
)braket
dot
id|type
)paren
suffix:semicolon
)brace
DECL|function|resolve_base
r_static
r_void
id|resolve_base
c_func
(paren
r_struct
id|object_entry
op_star
id|obj
)paren
(brace
r_struct
id|base_data
op_star
id|base_obj
op_assign
id|alloc_base_data
c_func
(paren
)paren
suffix:semicolon
id|base_obj-&gt;obj
op_assign
id|obj
suffix:semicolon
id|base_obj-&gt;data
op_assign
l_int|NULL
suffix:semicolon
id|find_unresolved_deltas
c_func
(paren
id|base_obj
)paren
suffix:semicolon
)brace
macro_line|#ifndef NO_PTHREADS
DECL|function|threaded_second_pass
r_static
r_void
op_star
id|threaded_second_pass
c_func
(paren
r_void
op_star
id|data
)paren
(brace
id|set_thread_data
c_func
(paren
id|data
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|i
suffix:semicolon
id|counter_lock
c_func
(paren
)paren
suffix:semicolon
id|display_progress
c_func
(paren
id|progress
comma
id|nr_resolved_deltas
)paren
suffix:semicolon
id|counter_unlock
c_func
(paren
)paren
suffix:semicolon
id|work_lock
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|nr_dispatched
OL
id|nr_objects
op_logical_and
id|is_delta_type
c_func
(paren
id|objects
(braket
id|nr_dispatched
)braket
dot
id|type
)paren
)paren
id|nr_dispatched
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|nr_dispatched
op_ge
id|nr_objects
)paren
(brace
id|work_unlock
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|i
op_assign
id|nr_dispatched
op_increment
suffix:semicolon
id|work_unlock
c_func
(paren
)paren
suffix:semicolon
id|resolve_base
c_func
(paren
op_amp
id|objects
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * First pass:&n; * - find locations of all objects;&n; * - calculate SHA1 of all non-delta objects;&n; * - remember base (SHA1 or offset) for all deltas.&n; */
DECL|function|parse_pack_objects
r_static
r_void
id|parse_pack_objects
c_func
(paren
r_int
r_char
op_star
id|sha1
)paren
(brace
r_int
id|i
comma
id|nr_delays
op_assign
l_int|0
suffix:semicolon
r_struct
id|delta_entry
op_star
id|delta
op_assign
id|deltas
suffix:semicolon
r_struct
id|stat
id|st
suffix:semicolon
r_if
c_cond
(paren
id|verbose
)paren
id|progress
op_assign
id|start_progress
c_func
(paren
id|from_stdin
ques
c_cond
id|_
c_func
(paren
l_string|&quot;Receiving objects&quot;
)paren
suffix:colon
id|_
c_func
(paren
l_string|&quot;Indexing objects&quot;
)paren
comma
id|nr_objects
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_objects
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|object_entry
op_star
id|obj
op_assign
op_amp
id|objects
(braket
id|i
)braket
suffix:semicolon
r_void
op_star
id|data
op_assign
id|unpack_raw_entry
c_func
(paren
id|obj
comma
op_amp
id|delta-&gt;base
comma
id|obj-&gt;idx.sha1
)paren
suffix:semicolon
id|obj-&gt;real_type
op_assign
id|obj-&gt;type
suffix:semicolon
r_if
c_cond
(paren
id|is_delta_type
c_func
(paren
id|obj-&gt;type
)paren
)paren
(brace
id|nr_deltas
op_increment
suffix:semicolon
id|delta-&gt;obj_no
op_assign
id|i
suffix:semicolon
id|delta
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
(brace
multiline_comment|/* large blobs, check later */
id|obj-&gt;real_type
op_assign
id|OBJ_BAD
suffix:semicolon
id|nr_delays
op_increment
suffix:semicolon
)brace
r_else
id|sha1_object
c_func
(paren
id|data
comma
l_int|NULL
comma
id|obj-&gt;size
comma
id|obj-&gt;type
comma
id|obj-&gt;idx.sha1
)paren
suffix:semicolon
id|free
c_func
(paren
id|data
)paren
suffix:semicolon
id|display_progress
c_func
(paren
id|progress
comma
id|i
op_plus
l_int|1
)paren
suffix:semicolon
)brace
id|objects
(braket
id|i
)braket
dot
id|idx.offset
op_assign
id|consumed_bytes
suffix:semicolon
id|stop_progress
c_func
(paren
op_amp
id|progress
)paren
suffix:semicolon
multiline_comment|/* Check pack integrity */
id|flush
c_func
(paren
)paren
suffix:semicolon
id|git_SHA1_Final
c_func
(paren
id|sha1
comma
op_amp
id|input_ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hashcmp
c_func
(paren
id|fill
c_func
(paren
l_int|20
)paren
comma
id|sha1
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;pack is corrupted (SHA1 mismatch)&quot;
)paren
)paren
suffix:semicolon
id|use
c_func
(paren
l_int|20
)paren
suffix:semicolon
multiline_comment|/* If input_fd is a file, we should have reached its end now. */
r_if
c_cond
(paren
id|fstat
c_func
(paren
id|input_fd
comma
op_amp
id|st
)paren
)paren
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;cannot fstat packfile&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|st.st_mode
)paren
op_logical_and
id|lseek
c_func
(paren
id|input_fd
comma
l_int|0
comma
id|SEEK_CUR
)paren
id|input_len
op_ne
id|st.st_size
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;pack has junk at the end&quot;
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_objects
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|object_entry
op_star
id|obj
op_assign
op_amp
id|objects
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|obj-&gt;real_type
op_ne
id|OBJ_BAD
)paren
r_continue
suffix:semicolon
id|obj-&gt;real_type
op_assign
id|obj-&gt;type
suffix:semicolon
id|sha1_object
c_func
(paren
l_int|NULL
comma
id|obj
comma
id|obj-&gt;size
comma
id|obj-&gt;type
comma
id|obj-&gt;idx.sha1
)paren
suffix:semicolon
id|nr_delays
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nr_delays
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;confusion beyond insanity in parse_pack_objects()&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Second pass:&n; * - for all non-delta objects, look if it is used as a base for&n; *   deltas;&n; * - if used as a base, uncompress the object and apply all deltas,&n; *   recursively checking if the resulting object is used as a base&n; *   for some more deltas.&n; */
DECL|function|resolve_deltas
r_static
r_void
id|resolve_deltas
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nr_deltas
)paren
r_return
suffix:semicolon
multiline_comment|/* Sort deltas by base SHA1/offset for fast searching */
id|qsort
c_func
(paren
id|deltas
comma
id|nr_deltas
comma
r_sizeof
(paren
r_struct
id|delta_entry
)paren
comma
id|compare_delta_entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|verbose
)paren
id|progress
op_assign
id|start_progress
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Resolving deltas&quot;
)paren
comma
id|nr_deltas
)paren
suffix:semicolon
macro_line|#ifndef NO_PTHREADS
id|nr_dispatched
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|nr_threads
OG
l_int|1
op_logical_or
id|getenv
c_func
(paren
l_string|&quot;GIT_FORCE_THREADS&quot;
)paren
)paren
(brace
id|init_thread
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_threads
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|ret
op_assign
id|pthread_create
c_func
(paren
op_amp
id|thread_data
(braket
id|i
)braket
dot
id|thread
comma
l_int|NULL
comma
id|threaded_second_pass
comma
id|thread_data
op_plus
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;unable to create thread: %s&quot;
)paren
comma
id|strerror
c_func
(paren
id|ret
)paren
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_threads
suffix:semicolon
id|i
op_increment
)paren
id|pthread_join
c_func
(paren
id|thread_data
(braket
id|i
)braket
dot
id|thread
comma
l_int|NULL
)paren
suffix:semicolon
id|cleanup_thread
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_objects
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|object_entry
op_star
id|obj
op_assign
op_amp
id|objects
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|is_delta_type
c_func
(paren
id|obj-&gt;type
)paren
)paren
r_continue
suffix:semicolon
id|resolve_base
c_func
(paren
id|obj
)paren
suffix:semicolon
id|display_progress
c_func
(paren
id|progress
comma
id|nr_resolved_deltas
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Third pass:&n; * - append objects to convert thin pack to full pack if required&n; * - write the final 20-byte SHA-1&n; */
r_static
r_void
id|fix_unresolved_deltas
c_func
(paren
r_struct
id|sha1file
op_star
id|f
comma
r_int
id|nr_unresolved
)paren
suffix:semicolon
DECL|function|conclude_pack
r_static
r_void
id|conclude_pack
c_func
(paren
r_int
id|fix_thin_pack
comma
r_const
r_char
op_star
id|curr_pack
comma
r_int
r_char
op_star
id|pack_sha1
)paren
(brace
r_if
c_cond
(paren
id|nr_deltas
op_eq
id|nr_resolved_deltas
)paren
(brace
id|stop_progress
c_func
(paren
op_amp
id|progress
)paren
suffix:semicolon
multiline_comment|/* Flush remaining pack final 20-byte SHA1. */
id|flush
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fix_thin_pack
)paren
(brace
r_struct
id|sha1file
op_star
id|f
suffix:semicolon
r_int
r_char
id|read_sha1
(braket
l_int|20
)braket
comma
id|tail_sha1
(braket
l_int|20
)braket
suffix:semicolon
r_struct
id|strbuf
id|msg
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|nr_unresolved
op_assign
id|nr_deltas
id|nr_resolved_deltas
suffix:semicolon
r_int
id|nr_objects_initial
op_assign
id|nr_objects
suffix:semicolon
r_if
c_cond
(paren
id|nr_unresolved
op_le
l_int|0
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;confusion beyond insanity&quot;
)paren
)paren
suffix:semicolon
id|REALLOC_ARRAY
c_func
(paren
id|objects
comma
id|nr_objects
op_plus
id|nr_unresolved
op_plus
l_int|1
)paren
suffix:semicolon
id|memset
c_func
(paren
id|objects
op_plus
id|nr_objects
op_plus
l_int|1
comma
l_int|0
comma
id|nr_unresolved
op_star
r_sizeof
(paren
op_star
id|objects
)paren
)paren
suffix:semicolon
id|f
op_assign
id|sha1fd
c_func
(paren
id|output_fd
comma
id|curr_pack
)paren
suffix:semicolon
id|fix_unresolved_deltas
c_func
(paren
id|f
comma
id|nr_unresolved
)paren
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
id|msg
comma
id|_
c_func
(paren
l_string|&quot;completed with %d local objects&quot;
)paren
comma
id|nr_objects
id|nr_objects_initial
)paren
suffix:semicolon
id|stop_progress_msg
c_func
(paren
op_amp
id|progress
comma
id|msg.buf
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|msg
)paren
suffix:semicolon
id|sha1close
c_func
(paren
id|f
comma
id|tail_sha1
comma
l_int|0
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|read_sha1
comma
id|pack_sha1
)paren
suffix:semicolon
id|fixup_pack_header_footer
c_func
(paren
id|output_fd
comma
id|pack_sha1
comma
id|curr_pack
comma
id|nr_objects
comma
id|read_sha1
comma
id|consumed_bytes
op_minus
l_int|20
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hashcmp
c_func
(paren
id|read_sha1
comma
id|tail_sha1
)paren
op_ne
l_int|0
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Unexpected tail checksum for %s &quot;
l_string|&quot;(disk corruption?)&quot;
)paren
comma
id|curr_pack
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nr_deltas
op_ne
id|nr_resolved_deltas
)paren
id|die
c_func
(paren
id|Q_
c_func
(paren
l_string|&quot;pack has %d unresolved delta&quot;
comma
l_string|&quot;pack has %d unresolved deltas&quot;
comma
id|nr_deltas
id|nr_resolved_deltas
)paren
comma
id|nr_deltas
id|nr_resolved_deltas
)paren
suffix:semicolon
)brace
DECL|function|write_compressed
r_static
r_int
id|write_compressed
c_func
(paren
r_struct
id|sha1file
op_star
id|f
comma
r_void
op_star
id|in
comma
r_int
r_int
id|size
)paren
(brace
id|git_zstream
id|stream
suffix:semicolon
r_int
id|status
suffix:semicolon
r_int
r_char
id|outbuf
(braket
l_int|4096
)braket
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|stream
comma
l_int|0
comma
r_sizeof
(paren
id|stream
)paren
)paren
suffix:semicolon
id|git_deflate_init
c_func
(paren
op_amp
id|stream
comma
id|zlib_compression_level
)paren
suffix:semicolon
id|stream.next_in
op_assign
id|in
suffix:semicolon
id|stream.avail_in
op_assign
id|size
suffix:semicolon
r_do
(brace
id|stream.next_out
op_assign
id|outbuf
suffix:semicolon
id|stream.avail_out
op_assign
r_sizeof
(paren
id|outbuf
)paren
suffix:semicolon
id|status
op_assign
id|git_deflate
c_func
(paren
op_amp
id|stream
comma
id|Z_FINISH
)paren
suffix:semicolon
id|sha1write
c_func
(paren
id|f
comma
id|outbuf
comma
r_sizeof
(paren
id|outbuf
)paren
id|stream.avail_out
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|status
op_eq
id|Z_OK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
id|Z_STREAM_END
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;unable to deflate appended object (%d)&quot;
)paren
comma
id|status
)paren
suffix:semicolon
id|size
op_assign
id|stream.total_out
suffix:semicolon
id|git_deflate_end
c_func
(paren
op_amp
id|stream
)paren
suffix:semicolon
r_return
id|size
suffix:semicolon
)brace
DECL|function|append_obj_to_pack
r_static
r_struct
id|object_entry
op_star
id|append_obj_to_pack
c_func
(paren
r_struct
id|sha1file
op_star
id|f
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_void
op_star
id|buf
comma
r_int
r_int
id|size
comma
r_enum
id|object_type
id|type
)paren
(brace
r_struct
id|object_entry
op_star
id|obj
op_assign
op_amp
id|objects
(braket
id|nr_objects
op_increment
)braket
suffix:semicolon
r_int
r_char
id|header
(braket
l_int|10
)braket
suffix:semicolon
r_int
r_int
id|s
op_assign
id|size
suffix:semicolon
r_int
id|n
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|c
op_assign
(paren
id|type
op_lshift
l_int|4
)paren
op_or
(paren
id|s
op_amp
l_int|15
)paren
suffix:semicolon
id|s
op_rshift_assign
l_int|4
suffix:semicolon
r_while
c_loop
(paren
id|s
)paren
(brace
id|header
(braket
id|n
op_increment
)braket
op_assign
id|c
op_or
l_int|0x80
suffix:semicolon
id|c
op_assign
id|s
op_amp
l_int|0x7f
suffix:semicolon
id|s
op_rshift_assign
l_int|7
suffix:semicolon
)brace
id|header
(braket
id|n
op_increment
)braket
op_assign
id|c
suffix:semicolon
id|crc32_begin
c_func
(paren
id|f
)paren
suffix:semicolon
id|sha1write
c_func
(paren
id|f
comma
id|header
comma
id|n
)paren
suffix:semicolon
id|obj
(braket
l_int|0
)braket
dot
id|size
op_assign
id|size
suffix:semicolon
id|obj
(braket
l_int|0
)braket
dot
id|hdr_size
op_assign
id|n
suffix:semicolon
id|obj
(braket
l_int|0
)braket
dot
id|type
op_assign
id|type
suffix:semicolon
id|obj
(braket
l_int|0
)braket
dot
id|real_type
op_assign
id|type
suffix:semicolon
id|obj
(braket
l_int|1
)braket
dot
id|idx.offset
op_assign
id|obj
(braket
l_int|0
)braket
dot
id|idx.offset
op_plus
id|n
suffix:semicolon
id|obj
(braket
l_int|1
)braket
dot
id|idx.offset
op_add_assign
id|write_compressed
c_func
(paren
id|f
comma
id|buf
comma
id|size
)paren
suffix:semicolon
id|obj
(braket
l_int|0
)braket
dot
id|idx.crc32
op_assign
id|crc32_end
c_func
(paren
id|f
)paren
suffix:semicolon
id|sha1flush
c_func
(paren
id|f
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|obj-&gt;idx.sha1
comma
id|sha1
)paren
suffix:semicolon
r_return
id|obj
suffix:semicolon
)brace
DECL|function|delta_pos_compare
r_static
r_int
id|delta_pos_compare
c_func
(paren
r_const
r_void
op_star
id|_a
comma
r_const
r_void
op_star
id|_b
)paren
(brace
r_struct
id|delta_entry
op_star
id|a
op_assign
op_star
(paren
r_struct
id|delta_entry
op_star
op_star
)paren
id|_a
suffix:semicolon
r_struct
id|delta_entry
op_star
id|b
op_assign
op_star
(paren
r_struct
id|delta_entry
op_star
op_star
)paren
id|_b
suffix:semicolon
r_return
id|a-&gt;obj_no
id|b-&gt;obj_no
suffix:semicolon
)brace
DECL|function|fix_unresolved_deltas
r_static
r_void
id|fix_unresolved_deltas
c_func
(paren
r_struct
id|sha1file
op_star
id|f
comma
r_int
id|nr_unresolved
)paren
(brace
r_struct
id|delta_entry
op_star
op_star
id|sorted_by_pos
suffix:semicolon
r_int
id|i
comma
id|n
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Since many unresolved deltas may well be themselves base objects&n;&t; * for more unresolved deltas, we really want to include the&n;&t; * smallest number of base objects that would cover as much delta&n;&t; * as possible by picking the&n;&t; * trunc deltas first, allowing for other deltas to resolve without&n;&t; * additional base objects.  Since most base objects are to be found&n;&t; * before deltas depending on them, a good heuristic is to start&n;&t; * resolving deltas in the same order as their position in the pack.&n;&t; */
id|sorted_by_pos
op_assign
id|xmalloc
c_func
(paren
id|nr_unresolved
op_star
r_sizeof
(paren
op_star
id|sorted_by_pos
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_deltas
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|objects
(braket
id|deltas
(braket
id|i
)braket
dot
id|obj_no
)braket
dot
id|real_type
op_ne
id|OBJ_REF_DELTA
)paren
r_continue
suffix:semicolon
id|sorted_by_pos
(braket
id|n
op_increment
)braket
op_assign
op_amp
id|deltas
(braket
id|i
)braket
suffix:semicolon
)brace
id|qsort
c_func
(paren
id|sorted_by_pos
comma
id|n
comma
r_sizeof
(paren
op_star
id|sorted_by_pos
)paren
comma
id|delta_pos_compare
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|delta_entry
op_star
id|d
op_assign
id|sorted_by_pos
(braket
id|i
)braket
suffix:semicolon
r_enum
id|object_type
id|type
suffix:semicolon
r_struct
id|base_data
op_star
id|base_obj
op_assign
id|alloc_base_data
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|objects
(braket
id|d-&gt;obj_no
)braket
dot
id|real_type
op_ne
id|OBJ_REF_DELTA
)paren
r_continue
suffix:semicolon
id|base_obj-&gt;data
op_assign
id|read_sha1_file
c_func
(paren
id|d-&gt;base.sha1
comma
op_amp
id|type
comma
op_amp
id|base_obj-&gt;size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|base_obj-&gt;data
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|check_sha1_signature
c_func
(paren
id|d-&gt;base.sha1
comma
id|base_obj-&gt;data
comma
id|base_obj-&gt;size
comma
r_typename
(paren
id|type
)paren
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;local object %s is corrupt&quot;
)paren
comma
id|sha1_to_hex
c_func
(paren
id|d-&gt;base.sha1
)paren
)paren
suffix:semicolon
id|base_obj-&gt;obj
op_assign
id|append_obj_to_pack
c_func
(paren
id|f
comma
id|d-&gt;base.sha1
comma
id|base_obj-&gt;data
comma
id|base_obj-&gt;size
comma
id|type
)paren
suffix:semicolon
id|find_unresolved_deltas
c_func
(paren
id|base_obj
)paren
suffix:semicolon
id|display_progress
c_func
(paren
id|progress
comma
id|nr_resolved_deltas
)paren
suffix:semicolon
)brace
id|free
c_func
(paren
id|sorted_by_pos
)paren
suffix:semicolon
)brace
DECL|function|final
r_static
r_void
id|final
c_func
(paren
r_const
r_char
op_star
id|final_pack_name
comma
r_const
r_char
op_star
id|curr_pack_name
comma
r_const
r_char
op_star
id|final_index_name
comma
r_const
r_char
op_star
id|curr_index_name
comma
r_const
r_char
op_star
id|keep_name
comma
r_const
r_char
op_star
id|keep_msg
comma
r_int
r_char
op_star
id|sha1
)paren
(brace
r_const
r_char
op_star
id|report
op_assign
l_string|&quot;pack&quot;
suffix:semicolon
r_char
id|name
(braket
id|PATH_MAX
)braket
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|from_stdin
)paren
(brace
id|close
c_func
(paren
id|input_fd
)paren
suffix:semicolon
)brace
r_else
(brace
id|fsync_or_die
c_func
(paren
id|output_fd
comma
id|curr_pack_name
)paren
suffix:semicolon
id|err
op_assign
id|close
c_func
(paren
id|output_fd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;error while closing pack file&quot;
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|keep_msg
)paren
(brace
r_int
id|keep_fd
comma
id|keep_msg_len
op_assign
id|strlen
c_func
(paren
id|keep_msg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|keep_name
)paren
id|keep_fd
op_assign
id|odb_pack_keep
c_func
(paren
id|name
comma
r_sizeof
(paren
id|name
)paren
comma
id|sha1
)paren
suffix:semicolon
r_else
id|keep_fd
op_assign
id|open
c_func
(paren
id|keep_name
comma
id|O_RDWR
op_or
id|O_CREAT
op_or
id|O_EXCL
comma
l_int|0600
)paren
suffix:semicolon
r_if
c_cond
(paren
id|keep_fd
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|errno
op_ne
id|EEXIST
)paren
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;cannot write keep file &squot;%s&squot;&quot;
)paren
comma
id|keep_name
ques
c_cond
id|keep_name
suffix:colon
id|name
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|keep_msg_len
OG
l_int|0
)paren
(brace
id|write_or_die
c_func
(paren
id|keep_fd
comma
id|keep_msg
comma
id|keep_msg_len
)paren
suffix:semicolon
id|write_or_die
c_func
(paren
id|keep_fd
comma
l_string|&quot;&bslash;n&quot;
comma
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|close
c_func
(paren
id|keep_fd
)paren
op_ne
l_int|0
)paren
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;cannot close written keep file &squot;%s&squot;&quot;
)paren
comma
id|keep_name
ques
c_cond
id|keep_name
suffix:colon
id|name
)paren
suffix:semicolon
id|report
op_assign
l_string|&quot;keep&quot;
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|final_pack_name
op_ne
id|curr_pack_name
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|final_pack_name
)paren
(brace
id|snprintf
c_func
(paren
id|name
comma
r_sizeof
(paren
id|name
)paren
comma
l_string|&quot;%s/pack/pack-%s.pack&quot;
comma
id|get_object_directory
c_func
(paren
)paren
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
id|final_pack_name
op_assign
id|name
suffix:semicolon
)brace
r_if
c_cond
(paren
id|move_temp_to_file
c_func
(paren
id|curr_pack_name
comma
id|final_pack_name
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;cannot store pack file&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|from_stdin
)paren
id|chmod
c_func
(paren
id|final_pack_name
comma
l_int|0444
)paren
suffix:semicolon
r_if
c_cond
(paren
id|final_index_name
op_ne
id|curr_index_name
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|final_index_name
)paren
(brace
id|snprintf
c_func
(paren
id|name
comma
r_sizeof
(paren
id|name
)paren
comma
l_string|&quot;%s/pack/pack-%s.idx&quot;
comma
id|get_object_directory
c_func
(paren
)paren
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
id|final_index_name
op_assign
id|name
suffix:semicolon
)brace
r_if
c_cond
(paren
id|move_temp_to_file
c_func
(paren
id|curr_index_name
comma
id|final_index_name
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;cannot store index file&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
id|chmod
c_func
(paren
id|final_index_name
comma
l_int|0444
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|from_stdin
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_char
id|buf
(braket
l_int|48
)braket
suffix:semicolon
r_int
id|len
op_assign
id|snprintf
c_func
(paren
id|buf
comma
r_sizeof
(paren
id|buf
)paren
comma
l_string|&quot;%s&bslash;t%s&bslash;n&quot;
comma
id|report
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
id|write_or_die
c_func
(paren
l_int|1
comma
id|buf
comma
id|len
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Let&squot;s just mimic git-unpack-objects here and write&n;&t;&t; * the last part of the input buffer to stdout.&n;&t;&t; */
r_while
c_loop
(paren
id|input_len
)paren
(brace
id|err
op_assign
id|xwrite
c_func
(paren
l_int|1
comma
id|input_buffer
op_plus
id|input_offset
comma
id|input_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_le
l_int|0
)paren
r_break
suffix:semicolon
id|input_len
op_sub_assign
id|err
suffix:semicolon
id|input_offset
op_add_assign
id|err
suffix:semicolon
)brace
)brace
)brace
DECL|function|git_index_pack_config
r_static
r_int
id|git_index_pack_config
c_func
(paren
r_const
r_char
op_star
id|k
comma
r_const
r_char
op_star
id|v
comma
r_void
op_star
id|cb
)paren
(brace
r_struct
id|pack_idx_option
op_star
id|opts
op_assign
id|cb
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|k
comma
l_string|&quot;pack.indexversion&quot;
)paren
)paren
(brace
id|opts-&gt;version
op_assign
id|git_config_int
c_func
(paren
id|k
comma
id|v
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opts-&gt;version
OG
l_int|2
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;bad pack.indexversion=%&quot;
id|PRIu32
)paren
comma
id|opts-&gt;version
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|k
comma
l_string|&quot;pack.threads&quot;
)paren
)paren
(brace
id|nr_threads
op_assign
id|git_config_int
c_func
(paren
id|k
comma
id|v
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr_threads
OL
l_int|0
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;invalid number of threads specified (%d)&quot;
)paren
comma
id|nr_threads
)paren
suffix:semicolon
macro_line|#ifdef NO_PTHREADS
r_if
c_cond
(paren
id|nr_threads
op_ne
l_int|1
)paren
id|warning
c_func
(paren
id|_
c_func
(paren
l_string|&quot;no threads support, ignoring %s&quot;
)paren
comma
id|k
)paren
suffix:semicolon
id|nr_threads
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|git_default_config
c_func
(paren
id|k
comma
id|v
comma
id|cb
)paren
suffix:semicolon
)brace
DECL|function|cmp_uint32
r_static
r_int
id|cmp_uint32
c_func
(paren
r_const
r_void
op_star
id|a_
comma
r_const
r_void
op_star
id|b_
)paren
(brace
r_uint32
id|a
op_assign
op_star
(paren
(paren
r_uint32
op_star
)paren
id|a_
)paren
suffix:semicolon
r_uint32
id|b
op_assign
op_star
(paren
(paren
r_uint32
op_star
)paren
id|b_
)paren
suffix:semicolon
r_return
(paren
id|a
OL
id|b
)paren
ques
c_cond
l_int|1
suffix:colon
(paren
id|a
op_ne
id|b
)paren
suffix:semicolon
)brace
DECL|function|read_v2_anomalous_offsets
r_static
r_void
id|read_v2_anomalous_offsets
c_func
(paren
r_struct
id|packed_git
op_star
id|p
comma
r_struct
id|pack_idx_option
op_star
id|opts
)paren
(brace
r_const
r_uint32
op_star
id|idx1
comma
op_star
id|idx2
suffix:semicolon
r_uint32
id|i
suffix:semicolon
multiline_comment|/* The address of the 4-byte offset table */
id|idx1
op_assign
(paren
(paren
(paren
r_const
r_uint32
op_star
)paren
id|p-&gt;index_data
)paren
op_plus
l_int|2
multiline_comment|/* 8-byte header */
op_plus
l_int|256
multiline_comment|/* fan out */
op_plus
l_int|5
op_star
id|p-&gt;num_objects
multiline_comment|/* 20-byte SHA-1 table */
op_plus
id|p-&gt;num_objects
multiline_comment|/* CRC32 table */
)paren
suffix:semicolon
multiline_comment|/* The address of the 8-byte offset table */
id|idx2
op_assign
id|idx1
op_plus
id|p-&gt;num_objects
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|p-&gt;num_objects
suffix:semicolon
id|i
op_increment
)paren
(brace
r_uint32
id|off
op_assign
id|ntohl
c_func
(paren
id|idx1
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|off
op_amp
l_int|0x80000000
)paren
)paren
r_continue
suffix:semicolon
id|off
op_assign
id|off
op_amp
l_int|0x7fffffff
suffix:semicolon
r_if
c_cond
(paren
id|idx2
(braket
id|off
op_star
l_int|2
)braket
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The real offset is ntohl(idx2[off * 2]) in high 4&n;&t;&t; * octets, and ntohl(idx2[off * 2 + 1]) in low 4&n;&t;&t; * octets.  But idx2[off * 2] is Zero!!!&n;&t;&t; */
id|ALLOC_GROW
c_func
(paren
id|opts-&gt;anomaly
comma
id|opts-&gt;anomaly_nr
op_plus
l_int|1
comma
id|opts-&gt;anomaly_alloc
)paren
suffix:semicolon
id|opts-&gt;anomaly
(braket
id|opts-&gt;anomaly_nr
op_increment
)braket
op_assign
id|ntohl
c_func
(paren
id|idx2
(braket
id|off
op_star
l_int|2
op_plus
l_int|1
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
l_int|1
OL
id|opts-&gt;anomaly_nr
)paren
id|qsort
c_func
(paren
id|opts-&gt;anomaly
comma
id|opts-&gt;anomaly_nr
comma
r_sizeof
(paren
r_uint32
)paren
comma
id|cmp_uint32
)paren
suffix:semicolon
)brace
DECL|function|read_idx_option
r_static
r_void
id|read_idx_option
c_func
(paren
r_struct
id|pack_idx_option
op_star
id|opts
comma
r_const
r_char
op_star
id|pack_name
)paren
(brace
r_struct
id|packed_git
op_star
id|p
op_assign
id|add_packed_git
c_func
(paren
id|pack_name
comma
id|strlen
c_func
(paren
id|pack_name
)paren
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Cannot open existing pack file &squot;%s&squot;&quot;
)paren
comma
id|pack_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|open_pack_index
c_func
(paren
id|p
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Cannot open existing pack idx file for &squot;%s&squot;&quot;
)paren
comma
id|pack_name
)paren
suffix:semicolon
multiline_comment|/* Read the attributes from the existing idx file */
id|opts-&gt;version
op_assign
id|p-&gt;index_version
suffix:semicolon
r_if
c_cond
(paren
id|opts-&gt;version
op_eq
l_int|2
)paren
id|read_v2_anomalous_offsets
c_func
(paren
id|p
comma
id|opts
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get rid of the idx file as we do not need it anymore.&n;&t; * NEEDSWORK: extract this bit from free_pack_by_name() in&n;&t; * sha1_file.c, perhaps?  It shouldn&squot;t matter very much as we&n;&t; * know we haven&squot;t installed this pack (hence we never have&n;&t; * read anything from it).&n;&t; */
id|close_pack_index
c_func
(paren
id|p
)paren
suffix:semicolon
id|free
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
DECL|function|show_pack_info
r_static
r_void
id|show_pack_info
c_func
(paren
r_int
id|stat_only
)paren
(brace
r_int
id|i
comma
id|baseobjects
op_assign
id|nr_objects
id|nr_deltas
suffix:semicolon
r_int
r_int
op_star
id|chain_histogram
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|deepest_delta
)paren
id|chain_histogram
op_assign
id|xcalloc
c_func
(paren
id|deepest_delta
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_objects
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|object_entry
op_star
id|obj
op_assign
op_amp
id|objects
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|is_delta_type
c_func
(paren
id|obj-&gt;type
)paren
)paren
id|chain_histogram
(braket
id|obj-&gt;delta_depth
l_int|1
)braket
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|stat_only
)paren
r_continue
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s %-6s %lu %lu %&quot;
id|PRIuMAX
comma
id|sha1_to_hex
c_func
(paren
id|obj-&gt;idx.sha1
)paren
comma
r_typename
(paren
id|obj-&gt;real_type
)paren
comma
id|obj-&gt;size
comma
(paren
r_int
r_int
)paren
(paren
id|obj
(braket
l_int|1
)braket
dot
id|idx.offset
id|obj-&gt;idx.offset
)paren
comma
(paren
r_uintmax
)paren
id|obj-&gt;idx.offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_delta_type
c_func
(paren
id|obj-&gt;type
)paren
)paren
(brace
r_struct
id|object_entry
op_star
id|bobj
op_assign
op_amp
id|objects
(braket
id|obj-&gt;base_object_no
)braket
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot; %u %s&quot;
comma
id|obj-&gt;delta_depth
comma
id|sha1_to_hex
c_func
(paren
id|bobj-&gt;idx.sha1
)paren
)paren
suffix:semicolon
)brace
id|putchar
c_func
(paren
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|baseobjects
)paren
id|printf_ln
c_func
(paren
id|Q_
c_func
(paren
l_string|&quot;non delta: %d object&quot;
comma
l_string|&quot;non delta: %d objects&quot;
comma
id|baseobjects
)paren
comma
id|baseobjects
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|deepest_delta
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|chain_histogram
(braket
id|i
)braket
)paren
r_continue
suffix:semicolon
id|printf_ln
c_func
(paren
id|Q_
c_func
(paren
l_string|&quot;chain length = %d: %lu object&quot;
comma
l_string|&quot;chain length = %d: %lu objects&quot;
comma
id|chain_histogram
(braket
id|i
)braket
)paren
comma
id|i
op_plus
l_int|1
comma
id|chain_histogram
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
DECL|function|cmd_index_pack
r_int
id|cmd_index_pack
c_func
(paren
r_int
id|argc
comma
r_const
r_char
op_star
op_star
id|argv
comma
r_const
r_char
op_star
id|prefix
)paren
(brace
r_int
id|i
comma
id|fix_thin_pack
op_assign
l_int|0
comma
id|verify
op_assign
l_int|0
comma
id|stat_only
op_assign
l_int|0
suffix:semicolon
r_const
r_char
op_star
id|curr_index
suffix:semicolon
r_const
r_char
op_star
id|index_name
op_assign
l_int|NULL
comma
op_star
id|pack_name
op_assign
l_int|NULL
suffix:semicolon
r_const
r_char
op_star
id|keep_name
op_assign
l_int|NULL
comma
op_star
id|keep_msg
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|strbuf
id|index_name_buf
op_assign
id|STRBUF_INIT
comma
id|keep_name_buf
op_assign
id|STRBUF_INIT
suffix:semicolon
r_struct
id|pack_idx_entry
op_star
op_star
id|idx_objects
suffix:semicolon
r_struct
id|pack_idx_option
id|opts
suffix:semicolon
r_int
r_char
id|pack_sha1
(braket
l_int|20
)braket
suffix:semicolon
r_int
id|foreign_nr
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* zero is a &quot;good&quot; value, assume bad */
r_if
c_cond
(paren
id|argc
op_eq
l_int|2
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
l_string|&quot;-h&quot;
)paren
)paren
id|usage
c_func
(paren
id|index_pack_usage
)paren
suffix:semicolon
id|check_replace_refs
op_assign
l_int|0
suffix:semicolon
id|reset_pack_idx_option
c_func
(paren
op_amp
id|opts
)paren
suffix:semicolon
id|git_config
c_func
(paren
id|git_index_pack_config
comma
op_amp
id|opts
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prefix
op_logical_and
id|chdir
c_func
(paren
id|prefix
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Cannot come back to cwd&quot;
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|argc
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_char
op_star
id|arg
op_assign
id|argv
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_star
id|arg
op_eq
l_char|&squot;-&squot;
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--stdin&quot;
)paren
)paren
(brace
id|from_stdin
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--fix-thin&quot;
)paren
)paren
(brace
id|fix_thin_pack
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--strict&quot;
)paren
)paren
(brace
id|strict
op_assign
l_int|1
suffix:semicolon
id|do_fsck_object
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--check-self-contained-and-connected&quot;
)paren
)paren
(brace
id|strict
op_assign
l_int|1
suffix:semicolon
id|check_self_contained_and_connected
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--verify&quot;
)paren
)paren
(brace
id|verify
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--verify-stat&quot;
)paren
)paren
(brace
id|verify
op_assign
l_int|1
suffix:semicolon
id|show_stat
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--verify-stat-only&quot;
)paren
)paren
(brace
id|verify
op_assign
l_int|1
suffix:semicolon
id|show_stat
op_assign
l_int|1
suffix:semicolon
id|stat_only
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--keep&quot;
)paren
)paren
(brace
id|keep_msg
op_assign
l_string|&quot;&quot;
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|arg
comma
l_string|&quot;--keep=&quot;
)paren
)paren
(brace
id|keep_msg
op_assign
id|arg
op_plus
l_int|7
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|arg
comma
l_string|&quot;--threads=&quot;
)paren
)paren
(brace
r_char
op_star
id|end
suffix:semicolon
id|nr_threads
op_assign
id|strtoul
c_func
(paren
id|arg
op_plus
l_int|10
comma
op_amp
id|end
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
(braket
l_int|10
)braket
op_logical_or
op_star
id|end
op_logical_or
id|nr_threads
OL
l_int|0
)paren
id|usage
c_func
(paren
id|index_pack_usage
)paren
suffix:semicolon
macro_line|#ifdef NO_PTHREADS
r_if
c_cond
(paren
id|nr_threads
op_ne
l_int|1
)paren
id|warning
c_func
(paren
id|_
c_func
(paren
l_string|&quot;no threads support, &quot;
l_string|&quot;ignoring %s&quot;
)paren
comma
id|arg
)paren
suffix:semicolon
id|nr_threads
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
)brace
r_else
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|arg
comma
l_string|&quot;--pack_header=&quot;
)paren
)paren
(brace
r_struct
id|pack_header
op_star
id|hdr
suffix:semicolon
r_char
op_star
id|c
suffix:semicolon
id|hdr
op_assign
(paren
r_struct
id|pack_header
op_star
)paren
id|input_buffer
suffix:semicolon
id|hdr-&gt;hdr_signature
op_assign
id|htonl
c_func
(paren
id|PACK_SIGNATURE
)paren
suffix:semicolon
id|hdr-&gt;hdr_version
op_assign
id|htonl
c_func
(paren
id|strtoul
c_func
(paren
id|arg
op_plus
l_int|14
comma
op_amp
id|c
comma
l_int|10
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|c
op_ne
l_char|&squot;,&squot;
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;bad %s&quot;
)paren
comma
id|arg
)paren
suffix:semicolon
id|hdr-&gt;hdr_entries
op_assign
id|htonl
c_func
(paren
id|strtoul
c_func
(paren
id|c
op_plus
l_int|1
comma
op_amp
id|c
comma
l_int|10
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|c
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;bad %s&quot;
)paren
comma
id|arg
)paren
suffix:semicolon
id|input_len
op_assign
r_sizeof
(paren
op_star
id|hdr
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;-v&quot;
)paren
)paren
(brace
id|verbose
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;-o&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|index_name
op_logical_or
(paren
id|i
op_plus
l_int|1
)paren
op_ge
id|argc
)paren
id|usage
c_func
(paren
id|index_pack_usage
)paren
suffix:semicolon
id|index_name
op_assign
id|argv
(braket
op_increment
id|i
)braket
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|arg
comma
l_string|&quot;--index-version=&quot;
)paren
)paren
(brace
r_char
op_star
id|c
suffix:semicolon
id|opts.version
op_assign
id|strtoul
c_func
(paren
id|arg
op_plus
l_int|16
comma
op_amp
id|c
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opts.version
OG
l_int|2
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;bad %s&quot;
)paren
comma
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|c
op_eq
l_char|&squot;,&squot;
)paren
id|opts.off32_limit
op_assign
id|strtoul
c_func
(paren
id|c
op_plus
l_int|1
comma
op_amp
id|c
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|c
op_logical_or
id|opts.off32_limit
op_amp
l_int|0x80000000
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;bad %s&quot;
)paren
comma
id|arg
)paren
suffix:semicolon
)brace
r_else
id|usage
c_func
(paren
id|index_pack_usage
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pack_name
)paren
id|usage
c_func
(paren
id|index_pack_usage
)paren
suffix:semicolon
id|pack_name
op_assign
id|arg
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|pack_name
op_logical_and
op_logical_neg
id|from_stdin
)paren
id|usage
c_func
(paren
id|index_pack_usage
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fix_thin_pack
op_logical_and
op_logical_neg
id|from_stdin
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;--fix-thin cannot be used without --stdin&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|index_name
op_logical_and
id|pack_name
)paren
(brace
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strip_suffix
c_func
(paren
id|pack_name
comma
l_string|&quot;.pack&quot;
comma
op_amp
id|len
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;packfile name &squot;%s&squot; does not end with &squot;.pack&squot;&quot;
)paren
comma
id|pack_name
)paren
suffix:semicolon
id|strbuf_add
c_func
(paren
op_amp
id|index_name_buf
comma
id|pack_name
comma
id|len
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|index_name_buf
comma
l_string|&quot;.idx&quot;
)paren
suffix:semicolon
id|index_name
op_assign
id|index_name_buf.buf
suffix:semicolon
)brace
r_if
c_cond
(paren
id|keep_msg
op_logical_and
op_logical_neg
id|keep_name
op_logical_and
id|pack_name
)paren
(brace
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strip_suffix
c_func
(paren
id|pack_name
comma
l_string|&quot;.pack&quot;
comma
op_amp
id|len
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;packfile name &squot;%s&squot; does not end with &squot;.pack&squot;&quot;
)paren
comma
id|pack_name
)paren
suffix:semicolon
id|strbuf_add
c_func
(paren
op_amp
id|keep_name_buf
comma
id|pack_name
comma
id|len
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|keep_name_buf
comma
l_string|&quot;.idx&quot;
)paren
suffix:semicolon
id|keep_name
op_assign
id|keep_name_buf.buf
suffix:semicolon
)brace
r_if
c_cond
(paren
id|verify
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|index_name
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;--verify with no packfile name given&quot;
)paren
)paren
suffix:semicolon
id|read_idx_option
c_func
(paren
op_amp
id|opts
comma
id|index_name
)paren
suffix:semicolon
id|opts.flags
op_or_assign
id|WRITE_IDX_VERIFY
op_or
id|WRITE_IDX_STRICT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strict
)paren
id|opts.flags
op_or_assign
id|WRITE_IDX_STRICT
suffix:semicolon
macro_line|#ifndef NO_PTHREADS
r_if
c_cond
(paren
op_logical_neg
id|nr_threads
)paren
(brace
id|nr_threads
op_assign
id|online_cpus
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* An experiment showed that more threads does not mean faster */
r_if
c_cond
(paren
id|nr_threads
OG
l_int|3
)paren
id|nr_threads
op_assign
l_int|3
suffix:semicolon
)brace
macro_line|#endif
id|curr_pack
op_assign
id|open_pack_file
c_func
(paren
id|pack_name
)paren
suffix:semicolon
id|parse_pack_header
c_func
(paren
)paren
suffix:semicolon
id|objects
op_assign
id|xcalloc
c_func
(paren
id|nr_objects
op_plus
l_int|1
comma
r_sizeof
(paren
r_struct
id|object_entry
)paren
)paren
suffix:semicolon
id|deltas
op_assign
id|xcalloc
c_func
(paren
id|nr_objects
comma
r_sizeof
(paren
r_struct
id|delta_entry
)paren
)paren
suffix:semicolon
id|parse_pack_objects
c_func
(paren
id|pack_sha1
)paren
suffix:semicolon
id|resolve_deltas
c_func
(paren
)paren
suffix:semicolon
id|conclude_pack
c_func
(paren
id|fix_thin_pack
comma
id|curr_pack
comma
id|pack_sha1
)paren
suffix:semicolon
id|free
c_func
(paren
id|deltas
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strict
)paren
id|foreign_nr
op_assign
id|check_objects
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|show_stat
)paren
id|show_pack_info
c_func
(paren
id|stat_only
)paren
suffix:semicolon
id|idx_objects
op_assign
id|xmalloc
c_func
(paren
(paren
id|nr_objects
)paren
op_star
r_sizeof
(paren
r_struct
id|pack_idx_entry
op_star
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_objects
suffix:semicolon
id|i
op_increment
)paren
id|idx_objects
(braket
id|i
)braket
op_assign
op_amp
id|objects
(braket
id|i
)braket
dot
id|idx
suffix:semicolon
id|curr_index
op_assign
id|write_idx_file
c_func
(paren
id|index_name
comma
id|idx_objects
comma
id|nr_objects
comma
op_amp
id|opts
comma
id|pack_sha1
)paren
suffix:semicolon
id|free
c_func
(paren
id|idx_objects
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|verify
)paren
id|final
c_func
(paren
id|pack_name
comma
id|curr_pack
comma
id|index_name
comma
id|curr_index
comma
id|keep_name
comma
id|keep_msg
comma
id|pack_sha1
)paren
suffix:semicolon
r_else
id|close
c_func
(paren
id|input_fd
)paren
suffix:semicolon
id|free
c_func
(paren
id|objects
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|index_name_buf
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|keep_name_buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pack_name
op_eq
l_int|NULL
)paren
id|free
c_func
(paren
(paren
r_void
op_star
)paren
id|curr_pack
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index_name
op_eq
l_int|NULL
)paren
id|free
c_func
(paren
(paren
r_void
op_star
)paren
id|curr_index
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Let the caller know this pack is not self contained&n;&t; */
r_if
c_cond
(paren
id|check_self_contained_and_connected
op_logical_and
id|foreign_nr
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
