macro_line|#include &quot;builtin.h&quot;
macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;dir.h&quot;
macro_line|#include &quot;quote.h&quot;
macro_line|#include &quot;pathspec.h&quot;
macro_line|#include &quot;parse-options.h&quot;
DECL|variable|quiet
DECL|variable|verbose
DECL|variable|stdin_paths
r_static
r_int
id|quiet
comma
id|verbose
comma
id|stdin_paths
suffix:semicolon
DECL|variable|check_ignore_usage
r_static
r_const
r_char
op_star
r_const
id|check_ignore_usage
(braket
)braket
op_assign
(brace
l_string|&quot;git check-ignore [options] pathname...&quot;
comma
l_string|&quot;git check-ignore [options] --stdin &lt; &lt;list-of-paths&gt;&quot;
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|null_term_line
r_static
r_int
id|null_term_line
suffix:semicolon
DECL|variable|check_ignore_options
r_static
r_const
r_struct
id|option
id|check_ignore_options
(braket
)braket
op_assign
(brace
id|OPT__QUIET
c_func
(paren
op_amp
id|quiet
comma
id|N_
c_func
(paren
l_string|&quot;suppress progress reporting&quot;
)paren
)paren
comma
id|OPT__VERBOSE
c_func
(paren
op_amp
id|verbose
comma
id|N_
c_func
(paren
l_string|&quot;be verbose&quot;
)paren
)paren
comma
id|OPT_GROUP
c_func
(paren
l_string|&quot;&quot;
)paren
comma
id|OPT_BOOLEAN
c_func
(paren
l_int|0
comma
l_string|&quot;stdin&quot;
comma
op_amp
id|stdin_paths
comma
id|N_
c_func
(paren
l_string|&quot;read file names from stdin&quot;
)paren
)paren
comma
id|OPT_BOOLEAN
c_func
(paren
l_char|&squot;z&squot;
comma
l_int|NULL
comma
op_amp
id|null_term_line
comma
id|N_
c_func
(paren
l_string|&quot;input paths are terminated by a null character&quot;
)paren
)paren
comma
id|OPT_END
c_func
(paren
)paren
)brace
suffix:semicolon
DECL|function|output_exclude
r_static
r_void
id|output_exclude
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_struct
id|exclude
op_star
id|exclude
)paren
(brace
r_char
op_star
id|bang
op_assign
id|exclude-&gt;flags
op_amp
id|EXC_FLAG_NEGATIVE
ques
c_cond
l_string|&quot;!&quot;
suffix:colon
l_string|&quot;&quot;
suffix:semicolon
r_char
op_star
id|slash
op_assign
id|exclude-&gt;flags
op_amp
id|EXC_FLAG_MUSTBEDIR
ques
c_cond
l_string|&quot;/&quot;
suffix:colon
l_string|&quot;&quot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|null_term_line
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|verbose
)paren
(brace
id|write_name_quoted
c_func
(paren
id|path
comma
id|stdout
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|quote_c_style
c_func
(paren
id|exclude-&gt;el-&gt;src
comma
l_int|NULL
comma
id|stdout
comma
l_int|0
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;:%d:%s%s%s&bslash;t&quot;
comma
id|exclude-&gt;srcpos
comma
id|bang
comma
id|exclude-&gt;pattern
comma
id|slash
)paren
suffix:semicolon
id|quote_c_style
c_func
(paren
id|path
comma
l_int|NULL
comma
id|stdout
comma
l_int|0
)paren
suffix:semicolon
id|fputc
c_func
(paren
l_char|&squot;&bslash;n&squot;
comma
id|stdout
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|verbose
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s%c&quot;
comma
id|path
comma
l_char|&squot;&bslash;0&squot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|printf
c_func
(paren
l_string|&quot;%s%c%d%c%s%s%s%c%s%c&quot;
comma
id|exclude-&gt;el-&gt;src
comma
l_char|&squot;&bslash;0&squot;
comma
id|exclude-&gt;srcpos
comma
l_char|&squot;&bslash;0&squot;
comma
id|bang
comma
id|exclude-&gt;pattern
comma
id|slash
comma
l_char|&squot;&bslash;0&squot;
comma
id|path
comma
l_char|&squot;&bslash;0&squot;
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|check_ignore
r_static
r_int
id|check_ignore
c_func
(paren
r_const
r_char
op_star
id|prefix
comma
r_const
r_char
op_star
op_star
id|pathspec
)paren
(brace
r_struct
id|dir_struct
id|dir
suffix:semicolon
r_const
r_char
op_star
id|path
comma
op_star
id|full_path
suffix:semicolon
r_char
op_star
id|seen
suffix:semicolon
r_int
id|num_ignored
op_assign
l_int|0
comma
id|dtype
op_assign
id|DT_UNKNOWN
comma
id|i
suffix:semicolon
r_struct
id|exclude
op_star
id|exclude
suffix:semicolon
multiline_comment|/* read_cache() is only necessary so we can watch out for submodules. */
r_if
c_cond
(paren
id|read_cache
c_func
(paren
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;index file corrupt&quot;
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|dir
comma
l_int|0
comma
r_sizeof
(paren
id|dir
)paren
)paren
suffix:semicolon
id|dir.flags
op_or_assign
id|DIR_COLLECT_IGNORED
suffix:semicolon
id|setup_standard_excludes
c_func
(paren
op_amp
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pathspec
op_logical_or
op_logical_neg
op_star
id|pathspec
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|quiet
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;no pathspec given.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * look for pathspecs matching entries in the index, since these&n;&t; * should not be ignored, in order to be consistent with&n;&t; * &squot;git status&squot;, &squot;git add&squot; etc.&n;&t; */
id|seen
op_assign
id|find_pathspecs_matching_against_index
c_func
(paren
id|pathspec
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|pathspec
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
id|path
op_assign
id|pathspec
(braket
id|i
)braket
suffix:semicolon
id|full_path
op_assign
id|prefix_path
c_func
(paren
id|prefix
comma
id|prefix
ques
c_cond
id|strlen
c_func
(paren
id|prefix
)paren
suffix:colon
l_int|0
comma
id|path
)paren
suffix:semicolon
id|full_path
op_assign
id|check_path_for_gitlink
c_func
(paren
id|full_path
)paren
suffix:semicolon
id|die_if_path_beyond_symlink
c_func
(paren
id|full_path
comma
id|prefix
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|seen
(braket
id|i
)braket
)paren
(brace
id|exclude
op_assign
id|last_exclude_matching
c_func
(paren
op_amp
id|dir
comma
id|full_path
comma
op_amp
id|dtype
)paren
suffix:semicolon
r_if
c_cond
(paren
id|exclude
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|quiet
)paren
id|output_exclude
c_func
(paren
id|path
comma
id|exclude
)paren
suffix:semicolon
id|num_ignored
op_increment
suffix:semicolon
)brace
)brace
)brace
id|free
c_func
(paren
id|seen
)paren
suffix:semicolon
id|clear_directory
c_func
(paren
op_amp
id|dir
)paren
suffix:semicolon
r_return
id|num_ignored
suffix:semicolon
)brace
DECL|function|check_ignore_stdin_paths
r_static
r_int
id|check_ignore_stdin_paths
c_func
(paren
r_const
r_char
op_star
id|prefix
)paren
(brace
r_struct
id|strbuf
id|buf
comma
id|nbuf
suffix:semicolon
r_char
op_star
op_star
id|pathspec
op_assign
l_int|NULL
suffix:semicolon
r_int
id|nr
op_assign
l_int|0
comma
id|alloc
op_assign
l_int|0
suffix:semicolon
r_int
id|line_termination
op_assign
id|null_term_line
ques
c_cond
l_int|0
suffix:colon
l_char|&squot;&bslash;n&squot;
suffix:semicolon
r_int
id|num_ignored
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|buf
comma
l_int|0
)paren
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|nbuf
comma
l_int|0
)paren
suffix:semicolon
r_while
c_loop
(paren
id|strbuf_getline
c_func
(paren
op_amp
id|buf
comma
id|stdin
comma
id|line_termination
)paren
op_ne
id|EOF
)paren
(brace
r_if
c_cond
(paren
id|line_termination
op_logical_and
id|buf.buf
(braket
l_int|0
)braket
op_eq
l_char|&squot;&quot;&squot;
)paren
(brace
id|strbuf_reset
c_func
(paren
op_amp
id|nbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unquote_c_style
c_func
(paren
op_amp
id|nbuf
comma
id|buf.buf
comma
l_int|NULL
)paren
)paren
id|die
c_func
(paren
l_string|&quot;line is badly quoted&quot;
)paren
suffix:semicolon
id|strbuf_swap
c_func
(paren
op_amp
id|buf
comma
op_amp
id|nbuf
)paren
suffix:semicolon
)brace
id|ALLOC_GROW
c_func
(paren
id|pathspec
comma
id|nr
op_plus
l_int|1
comma
id|alloc
)paren
suffix:semicolon
id|pathspec
(braket
id|nr
)braket
op_assign
id|xcalloc
c_func
(paren
id|strlen
c_func
(paren
id|buf.buf
)paren
op_plus
l_int|1
comma
r_sizeof
(paren
op_star
id|buf.buf
)paren
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|pathspec
(braket
id|nr
op_increment
)braket
comma
id|buf.buf
)paren
suffix:semicolon
)brace
id|ALLOC_GROW
c_func
(paren
id|pathspec
comma
id|nr
op_plus
l_int|1
comma
id|alloc
)paren
suffix:semicolon
id|pathspec
(braket
id|nr
)braket
op_assign
l_int|NULL
suffix:semicolon
id|num_ignored
op_assign
id|check_ignore
c_func
(paren
id|prefix
comma
(paren
r_const
r_char
op_star
op_star
)paren
id|pathspec
)paren
suffix:semicolon
id|maybe_flush_or_die
c_func
(paren
id|stdout
comma
l_string|&quot;attribute to stdout&quot;
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|buf
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|nbuf
)paren
suffix:semicolon
id|free
c_func
(paren
id|pathspec
)paren
suffix:semicolon
r_return
id|num_ignored
suffix:semicolon
)brace
DECL|function|cmd_check_ignore
r_int
id|cmd_check_ignore
c_func
(paren
r_int
id|argc
comma
r_const
r_char
op_star
op_star
id|argv
comma
r_const
r_char
op_star
id|prefix
)paren
(brace
r_int
id|num_ignored
suffix:semicolon
id|git_config
c_func
(paren
id|git_default_config
comma
l_int|NULL
)paren
suffix:semicolon
id|argc
op_assign
id|parse_options
c_func
(paren
id|argc
comma
id|argv
comma
id|prefix
comma
id|check_ignore_options
comma
id|check_ignore_usage
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stdin_paths
)paren
(brace
r_if
c_cond
(paren
id|argc
OG
l_int|0
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;cannot specify pathnames with --stdin&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|null_term_line
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;-z only makes sense with --stdin&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|argc
op_eq
l_int|0
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;no path specified&quot;
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|quiet
)paren
(brace
r_if
c_cond
(paren
id|argc
OG
l_int|1
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;--quiet is only valid with a single pathname&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|verbose
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;cannot have both --quiet and --verbose&quot;
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stdin_paths
)paren
(brace
id|num_ignored
op_assign
id|check_ignore_stdin_paths
c_func
(paren
id|prefix
)paren
suffix:semicolon
)brace
r_else
(brace
id|num_ignored
op_assign
id|check_ignore
c_func
(paren
id|prefix
comma
id|argv
)paren
suffix:semicolon
id|maybe_flush_or_die
c_func
(paren
id|stdout
comma
l_string|&quot;ignore to stdout&quot;
)paren
suffix:semicolon
)brace
r_return
op_logical_neg
id|num_ignored
suffix:semicolon
)brace
eof
