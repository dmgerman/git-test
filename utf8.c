macro_line|#include &quot;git-compat-util.h&quot;
macro_line|#include &quot;strbuf.h&quot;
macro_line|#include &quot;utf8.h&quot;
multiline_comment|/* This code is originally from http://www.cl.cam.ac.uk/~mgk25/ucs/ */
DECL|struct|interval
r_struct
id|interval
(brace
DECL|member|first
id|ucs_char_t
id|first
suffix:semicolon
DECL|member|last
id|ucs_char_t
id|last
suffix:semicolon
)brace
suffix:semicolon
DECL|function|display_mode_esc_sequence_len
r_int
id|display_mode_esc_sequence_len
c_func
(paren
r_const
r_char
op_star
id|s
)paren
(brace
r_const
r_char
op_star
id|p
op_assign
id|s
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p
op_increment
op_ne
l_char|&squot;&bslash;033&squot;
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p
op_increment
op_ne
l_char|&squot;[&squot;
)paren
r_return
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|isdigit
c_func
(paren
op_star
id|p
)paren
op_logical_or
op_star
id|p
op_eq
l_char|&squot;;&squot;
)paren
id|p
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p
op_increment
op_ne
l_char|&squot;m&squot;
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|p
id|s
suffix:semicolon
)brace
multiline_comment|/* auxiliary function for binary search in interval table */
DECL|function|bisearch
r_static
r_int
id|bisearch
c_func
(paren
id|ucs_char_t
id|ucs
comma
r_const
r_struct
id|interval
op_star
id|table
comma
r_int
id|max
)paren
(brace
r_int
id|min
op_assign
l_int|0
suffix:semicolon
r_int
id|mid
suffix:semicolon
r_if
c_cond
(paren
id|ucs
template_param
id|table
(braket
id|max
)braket
dot
id|last
)paren
r_return
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|max
op_ge
id|min
)paren
(brace
id|mid
op_assign
(paren
id|min
op_plus
id|max
)paren
op_div
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|ucs
OG
id|table
(braket
id|mid
)braket
dot
id|last
)paren
id|min
op_assign
id|mid
op_plus
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ucs
OL
id|table
(braket
id|mid
)braket
dot
id|first
)paren
id|max
op_assign
id|mid
l_int|1
suffix:semicolon
r_else
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* The following two functions define the column width of an ISO 10646&n; * character as follows:&n; *&n; *    - The null character (U+0000) has a column width of 0.&n; *&n; *    - Other C0/C1 control characters and DEL will lead to a return&n; *      value of -1.&n; *&n; *    - Non-spacing and enclosing combining characters (general&n; *      category code Mn or Me in the Unicode database) have a&n; *      column width of 0.&n; *&n; *    - SOFT HYPHEN (U+00AD) has a column width of 1.&n; *&n; *    - Other format characters (general category code Cf in the Unicode&n; *      database) and ZERO WIDTH SPACE (U+200B) have a column width of 0.&n; *&n; *    - Hangul Jamo medial vowels and final consonants (U+1160-U+11FF)&n; *      have a column width of 0.&n; *&n; *    - Spacing characters in the East Asian Wide (W) or East Asian&n; *      Full-width (F) category as defined in Unicode Technical&n; *      Report #11 have a column width of 2.&n; *&n; *    - All remaining characters (including all printable&n; *      ISO 8859-1 and WGL4 characters, Unicode control characters,&n; *      etc.) have a column width of 1.&n; *&n; * This implementation assumes that ucs_char_t characters are encoded&n; * in ISO 10646.&n; */
DECL|function|git_wcwidth
r_static
r_int
id|git_wcwidth
c_func
(paren
id|ucs_char_t
id|ch
)paren
(brace
multiline_comment|/*&n;&t; * Sorted list of non-overlapping intervals of non-spacing characters,&n;&t; */
macro_line|#include &quot;unicode_width.h&quot;
multiline_comment|/* test for 8-bit control characters */
r_if
c_cond
(paren
id|ch
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ch
OL
l_int|32
op_logical_or
(paren
id|ch
op_ge
l_int|0x7f
op_logical_and
id|ch
OL
l_int|0xa0
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* binary search in table of non-spacing characters */
r_if
c_cond
(paren
id|bisearch
c_func
(paren
id|ch
comma
id|zero_width
comma
r_sizeof
(paren
id|zero_width
)paren
op_div
r_sizeof
(paren
r_struct
id|interval
)paren
l_int|1
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* binary search in table of double width characters */
r_if
c_cond
(paren
id|bisearch
c_func
(paren
id|ch
comma
id|double_width
comma
r_sizeof
(paren
id|double_width
)paren
op_div
r_sizeof
(paren
r_struct
id|interval
)paren
l_int|1
)paren
)paren
r_return
l_int|2
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Pick one ucs character starting from the location *start points at,&n; * and return it, while updating the *start pointer to point at the&n; * end of that character.  When remainder_p is not NULL, the location&n; * holds the number of bytes remaining in the string that we are allowed&n; * to pick from.  Otherwise we are allowed to pick up to the NUL that&n; * would eventually appear in the string.  *remainder_p is also reduced&n; * by the number of bytes we have consumed.&n; *&n; * If the string was not a valid UTF-8, *start pointer is set to NULL&n; * and the return value is undefined.&n; */
DECL|function|pick_one_utf8_char
r_static
id|ucs_char_t
id|pick_one_utf8_char
c_func
(paren
r_const
r_char
op_star
op_star
id|start
comma
r_int
op_star
id|remainder_p
)paren
(brace
r_int
r_char
op_star
id|s
op_assign
(paren
r_int
r_char
op_star
)paren
op_star
id|start
suffix:semicolon
id|ucs_char_t
id|ch
suffix:semicolon
r_int
id|remainder
comma
id|incr
suffix:semicolon
multiline_comment|/*&n;&t; * A caller that assumes NUL terminated text can choose&n;&t; * not to bother with the remainder length.  We will&n;&t; * stop at the first NUL.&n;&t; */
id|remainder
op_assign
(paren
id|remainder_p
ques
c_cond
op_star
id|remainder_p
suffix:colon
l_int|999
)paren
suffix:semicolon
r_if
c_cond
(paren
id|remainder
OL
l_int|1
)paren
(brace
r_goto
id|invalid
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_star
id|s
OL
l_int|0x80
)paren
(brace
multiline_comment|/* 0xxxxxxx */
id|ch
op_assign
op_star
id|s
suffix:semicolon
id|incr
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|s
(braket
l_int|0
)braket
op_amp
l_int|0xe0
)paren
op_eq
l_int|0xc0
)paren
(brace
multiline_comment|/* 110XXXXx 10xxxxxx */
r_if
c_cond
(paren
id|remainder
OL
l_int|2
op_logical_or
(paren
id|s
(braket
l_int|1
)braket
op_amp
l_int|0xc0
)paren
op_ne
l_int|0x80
op_logical_or
(paren
id|s
(braket
l_int|0
)braket
op_amp
l_int|0xfe
)paren
op_eq
l_int|0xc0
)paren
r_goto
id|invalid
suffix:semicolon
id|ch
op_assign
(paren
(paren
id|s
(braket
l_int|0
)braket
op_amp
l_int|0x1f
)paren
op_lshift
l_int|6
)paren
op_or
(paren
id|s
(braket
l_int|1
)braket
op_amp
l_int|0x3f
)paren
suffix:semicolon
id|incr
op_assign
l_int|2
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|s
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_eq
l_int|0xe0
)paren
(brace
multiline_comment|/* 1110XXXX 10Xxxxxx 10xxxxxx */
r_if
c_cond
(paren
id|remainder
OL
l_int|3
op_logical_or
(paren
id|s
(braket
l_int|1
)braket
op_amp
l_int|0xc0
)paren
op_ne
l_int|0x80
op_logical_or
(paren
id|s
(braket
l_int|2
)braket
op_amp
l_int|0xc0
)paren
op_ne
l_int|0x80
op_logical_or
multiline_comment|/* overlong? */
(paren
id|s
(braket
l_int|0
)braket
op_eq
l_int|0xe0
op_logical_and
(paren
id|s
(braket
l_int|1
)braket
op_amp
l_int|0xe0
)paren
op_eq
l_int|0x80
)paren
op_logical_or
multiline_comment|/* surrogate? */
(paren
id|s
(braket
l_int|0
)braket
op_eq
l_int|0xed
op_logical_and
(paren
id|s
(braket
l_int|1
)braket
op_amp
l_int|0xe0
)paren
op_eq
l_int|0xa0
)paren
op_logical_or
multiline_comment|/* U+FFFE or U+FFFF? */
(paren
id|s
(braket
l_int|0
)braket
op_eq
l_int|0xef
op_logical_and
id|s
(braket
l_int|1
)braket
op_eq
l_int|0xbf
op_logical_and
(paren
id|s
(braket
l_int|2
)braket
op_amp
l_int|0xfe
)paren
op_eq
l_int|0xbe
)paren
)paren
r_goto
id|invalid
suffix:semicolon
id|ch
op_assign
(paren
(paren
id|s
(braket
l_int|0
)braket
op_amp
l_int|0x0f
)paren
op_lshift
l_int|12
)paren
op_or
(paren
(paren
id|s
(braket
l_int|1
)braket
op_amp
l_int|0x3f
)paren
op_lshift
l_int|6
)paren
op_or
(paren
id|s
(braket
l_int|2
)braket
op_amp
l_int|0x3f
)paren
suffix:semicolon
id|incr
op_assign
l_int|3
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|s
(braket
l_int|0
)braket
op_amp
l_int|0xf8
)paren
op_eq
l_int|0xf0
)paren
(brace
multiline_comment|/* 11110XXX 10XXxxxx 10xxxxxx 10xxxxxx */
r_if
c_cond
(paren
id|remainder
template_param
l_int|0xf4
)paren
r_goto
id|invalid
suffix:semicolon
id|ch
op_assign
(paren
(paren
id|s
(braket
l_int|0
)braket
op_amp
l_int|0x07
)paren
op_lshift
l_int|18
)paren
op_or
(paren
(paren
id|s
(braket
l_int|1
)braket
op_amp
l_int|0x3f
)paren
op_lshift
l_int|12
)paren
op_or
(paren
(paren
id|s
(braket
l_int|2
)braket
op_amp
l_int|0x3f
)paren
op_lshift
l_int|6
)paren
op_or
(paren
id|s
(braket
l_int|3
)braket
op_amp
l_int|0x3f
)paren
suffix:semicolon
id|incr
op_assign
l_int|4
suffix:semicolon
)brace
r_else
(brace
id|invalid
suffix:colon
op_star
id|start
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
op_star
id|start
op_add_assign
id|incr
suffix:semicolon
r_if
c_cond
(paren
id|remainder_p
)paren
op_star
id|remainder_p
op_assign
id|remainder
id|incr
suffix:semicolon
r_return
id|ch
suffix:semicolon
)brace
multiline_comment|/*&n; * This function returns the number of columns occupied by the character&n; * pointed to by the variable start. The pointer is updated to point at&n; * the next character. When remainder_p is not NULL, it points at the&n; * location that stores the number of remaining bytes we can use to pick&n; * a character (see pick_one_utf8_char() above).&n; */
DECL|function|utf8_width
r_int
id|utf8_width
c_func
(paren
r_const
r_char
op_star
op_star
id|start
comma
r_int
op_star
id|remainder_p
)paren
(brace
id|ucs_char_t
id|ch
op_assign
id|pick_one_utf8_char
c_func
(paren
id|start
comma
id|remainder_p
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|start
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|git_wcwidth
c_func
(paren
id|ch
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Returns the total number of columns required by a null-terminated&n; * string, assuming that the string is utf8.  Returns strlen() instead&n; * if the string does not look like a valid utf8 string.&n; */
DECL|function|utf8_strnwidth
r_int
id|utf8_strnwidth
c_func
(paren
r_const
r_char
op_star
id|string
comma
r_int
id|len
comma
r_int
id|skip_ansi
)paren
(brace
r_int
id|width
op_assign
l_int|0
suffix:semicolon
r_const
r_char
op_star
id|orig
op_assign
id|string
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
l_int|1
)paren
id|len
op_assign
id|strlen
c_func
(paren
id|string
)paren
suffix:semicolon
r_while
c_loop
(paren
id|string
op_logical_and
id|string
OL
id|orig
op_plus
id|len
)paren
(brace
r_int
id|skip
suffix:semicolon
r_while
c_loop
(paren
id|skip_ansi
op_logical_and
(paren
id|skip
op_assign
id|display_mode_esc_sequence_len
c_func
(paren
id|string
)paren
)paren
op_ne
l_int|0
)paren
id|string
op_add_assign
id|skip
suffix:semicolon
id|width
op_add_assign
id|utf8_width
c_func
(paren
op_amp
id|string
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_return
id|string
ques
c_cond
id|width
suffix:colon
id|len
suffix:semicolon
)brace
DECL|function|utf8_strwidth
r_int
id|utf8_strwidth
c_func
(paren
r_const
r_char
op_star
id|string
)paren
(brace
r_return
id|utf8_strnwidth
c_func
(paren
id|string
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|is_utf8
r_int
id|is_utf8
c_func
(paren
r_const
r_char
op_star
id|text
)paren
(brace
r_while
c_loop
(paren
op_star
id|text
)paren
(brace
r_if
c_cond
(paren
op_star
id|text
op_eq
l_char|&squot;&bslash;n&squot;
op_logical_or
op_star
id|text
op_eq
l_char|&squot;&bslash;t&squot;
op_logical_or
op_star
id|text
op_eq
l_char|&squot;&bslash;r&squot;
)paren
(brace
id|text
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|utf8_width
c_func
(paren
op_amp
id|text
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|text
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|strbuf_add_indented_text
r_static
r_void
id|strbuf_add_indented_text
c_func
(paren
r_struct
id|strbuf
op_star
id|buf
comma
r_const
r_char
op_star
id|text
comma
r_int
id|indent
comma
r_int
id|indent2
)paren
(brace
r_if
c_cond
(paren
id|indent
OL
l_int|0
)paren
id|indent
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_star
id|text
)paren
(brace
r_const
r_char
op_star
id|eol
op_assign
id|strchrnul
c_func
(paren
id|text
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|eol
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|eol
op_increment
suffix:semicolon
id|strbuf_addchars
c_func
(paren
id|buf
comma
l_char|&squot; &squot;
comma
id|indent
)paren
suffix:semicolon
id|strbuf_add
c_func
(paren
id|buf
comma
id|text
comma
id|eol
id|text
)paren
suffix:semicolon
id|text
op_assign
id|eol
suffix:semicolon
id|indent
op_assign
id|indent2
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Wrap the text, if necessary. The variable indent is the indent for the&n; * first line, indent2 is the indent for all other lines.&n; * If indent is negative, assume that already -indent columns have been&n; * consumed (and no extra indent is necessary for the first line).&n; */
DECL|function|strbuf_add_wrapped_text
r_void
id|strbuf_add_wrapped_text
c_func
(paren
r_struct
id|strbuf
op_star
id|buf
comma
r_const
r_char
op_star
id|text
comma
r_int
id|indent1
comma
r_int
id|indent2
comma
r_int
id|width
)paren
(brace
r_int
id|indent
comma
id|w
comma
id|assume_utf8
op_assign
l_int|1
suffix:semicolon
r_const
r_char
op_star
id|bol
comma
op_star
id|space
comma
op_star
id|start
op_assign
id|text
suffix:semicolon
r_int
id|orig_len
op_assign
id|buf-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|width
op_le
l_int|0
)paren
(brace
id|strbuf_add_indented_text
c_func
(paren
id|buf
comma
id|text
comma
id|indent1
comma
id|indent2
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|retry
suffix:colon
id|bol
op_assign
id|text
suffix:semicolon
id|w
op_assign
id|indent
op_assign
id|indent1
suffix:semicolon
id|space
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|indent
OL
l_int|0
)paren
(brace
id|w
op_assign
id|indent
suffix:semicolon
id|space
op_assign
id|text
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_char
id|c
suffix:semicolon
r_int
id|skip
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skip
op_assign
id|display_mode_esc_sequence_len
c_func
(paren
id|text
)paren
)paren
)paren
id|text
op_add_assign
id|skip
suffix:semicolon
id|c
op_assign
op_star
id|text
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
op_logical_or
id|isspace
c_func
(paren
id|c
)paren
)paren
(brace
r_if
c_cond
(paren
id|w
op_le
id|width
op_logical_or
op_logical_neg
id|space
)paren
(brace
r_const
r_char
op_star
id|start
op_assign
id|bol
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
op_logical_and
id|text
op_eq
id|start
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|space
)paren
id|start
op_assign
id|space
suffix:semicolon
r_else
id|strbuf_addchars
c_func
(paren
id|buf
comma
l_char|&squot; &squot;
comma
id|indent
)paren
suffix:semicolon
id|strbuf_add
c_func
(paren
id|buf
comma
id|start
comma
id|text
id|start
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
r_return
suffix:semicolon
id|space
op_assign
id|text
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;t&squot;
)paren
id|w
op_or_assign
l_int|0x07
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|space
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|space
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|strbuf_addch
c_func
(paren
id|buf
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_goto
id|new_line
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|isalnum
c_func
(paren
op_star
id|space
)paren
)paren
r_goto
id|new_line
suffix:semicolon
r_else
id|strbuf_addch
c_func
(paren
id|buf
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
)brace
id|w
op_increment
suffix:semicolon
id|text
op_increment
suffix:semicolon
)brace
r_else
(brace
id|new_line
suffix:colon
id|strbuf_addch
c_func
(paren
id|buf
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|text
op_assign
id|bol
op_assign
id|space
op_plus
id|isspace
c_func
(paren
op_star
id|space
)paren
suffix:semicolon
id|space
op_assign
l_int|NULL
suffix:semicolon
id|w
op_assign
id|indent
op_assign
id|indent2
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|assume_utf8
)paren
(brace
id|w
op_add_assign
id|utf8_width
c_func
(paren
op_amp
id|text
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|text
)paren
(brace
id|assume_utf8
op_assign
l_int|0
suffix:semicolon
id|text
op_assign
id|start
suffix:semicolon
id|strbuf_setlen
c_func
(paren
id|buf
comma
id|orig_len
)paren
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
)brace
r_else
(brace
id|w
op_increment
suffix:semicolon
id|text
op_increment
suffix:semicolon
)brace
)brace
)brace
DECL|function|strbuf_add_wrapped_bytes
r_void
id|strbuf_add_wrapped_bytes
c_func
(paren
r_struct
id|strbuf
op_star
id|buf
comma
r_const
r_char
op_star
id|data
comma
r_int
id|len
comma
r_int
id|indent
comma
r_int
id|indent2
comma
r_int
id|width
)paren
(brace
r_char
op_star
id|tmp
op_assign
id|xstrndup
c_func
(paren
id|data
comma
id|len
)paren
suffix:semicolon
id|strbuf_add_wrapped_text
c_func
(paren
id|buf
comma
id|tmp
comma
id|indent
comma
id|indent2
comma
id|width
)paren
suffix:semicolon
id|free
c_func
(paren
id|tmp
)paren
suffix:semicolon
)brace
DECL|function|strbuf_utf8_replace
r_void
id|strbuf_utf8_replace
c_func
(paren
r_struct
id|strbuf
op_star
id|sb_src
comma
r_int
id|pos
comma
r_int
id|width
comma
r_const
r_char
op_star
id|subst
)paren
(brace
r_struct
id|strbuf
id|sb_dst
op_assign
id|STRBUF_INIT
suffix:semicolon
r_char
op_star
id|src
op_assign
id|sb_src-&gt;buf
suffix:semicolon
r_char
op_star
id|end
op_assign
id|src
op_plus
id|sb_src-&gt;len
suffix:semicolon
r_char
op_star
id|dst
suffix:semicolon
r_int
id|w
op_assign
l_int|0
comma
id|subst_len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|subst
)paren
id|subst_len
op_assign
id|strlen
c_func
(paren
id|subst
)paren
suffix:semicolon
id|strbuf_grow
c_func
(paren
op_amp
id|sb_dst
comma
id|sb_src-&gt;len
op_plus
id|subst_len
)paren
suffix:semicolon
id|dst
op_assign
id|sb_dst.buf
suffix:semicolon
r_while
c_loop
(paren
id|src
OL
id|end
)paren
(brace
r_char
op_star
id|old
suffix:semicolon
r_int
id|n
suffix:semicolon
r_while
c_loop
(paren
(paren
id|n
op_assign
id|display_mode_esc_sequence_len
c_func
(paren
id|src
)paren
)paren
)paren
(brace
id|memcpy
c_func
(paren
id|dst
comma
id|src
comma
id|n
)paren
suffix:semicolon
id|src
op_add_assign
id|n
suffix:semicolon
id|dst
op_add_assign
id|n
suffix:semicolon
)brace
r_if
c_cond
(paren
id|src
op_ge
id|end
)paren
r_break
suffix:semicolon
id|old
op_assign
id|src
suffix:semicolon
id|n
op_assign
id|utf8_width
c_func
(paren
(paren
r_const
r_char
op_star
op_star
)paren
op_amp
id|src
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|src
)paren
multiline_comment|/* broken utf-8, do nothing */
r_return
suffix:semicolon
r_if
c_cond
(paren
id|n
op_logical_and
id|w
op_ge
id|pos
op_logical_and
id|w
OL
id|pos
op_plus
id|width
)paren
(brace
r_if
c_cond
(paren
id|subst
)paren
(brace
id|memcpy
c_func
(paren
id|dst
comma
id|subst
comma
id|subst_len
)paren
suffix:semicolon
id|dst
op_add_assign
id|subst_len
suffix:semicolon
id|subst
op_assign
l_int|NULL
suffix:semicolon
)brace
id|w
op_add_assign
id|n
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|dst
comma
id|old
comma
id|src
id|old
)paren
suffix:semicolon
id|dst
op_add_assign
id|src
id|old
suffix:semicolon
id|w
op_add_assign
id|n
suffix:semicolon
)brace
id|strbuf_setlen
c_func
(paren
op_amp
id|sb_dst
comma
id|dst
id|sb_dst.buf
)paren
suffix:semicolon
id|strbuf_swap
c_func
(paren
id|sb_src
comma
op_amp
id|sb_dst
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb_dst
)paren
suffix:semicolon
)brace
DECL|function|is_encoding_utf8
r_int
id|is_encoding_utf8
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcasecmp
c_func
(paren
id|name
comma
l_string|&quot;utf-8&quot;
)paren
op_logical_or
op_logical_neg
id|strcasecmp
c_func
(paren
id|name
comma
l_string|&quot;utf8&quot;
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|same_encoding
r_int
id|same_encoding
c_func
(paren
r_const
r_char
op_star
id|src
comma
r_const
r_char
op_star
id|dst
)paren
(brace
r_if
c_cond
(paren
id|is_encoding_utf8
c_func
(paren
id|src
)paren
op_logical_and
id|is_encoding_utf8
c_func
(paren
id|dst
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
op_logical_neg
id|strcasecmp
c_func
(paren
id|src
comma
id|dst
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Wrapper for fprintf and returns the total number of columns required&n; * for the printed string, assuming that the string is utf8.&n; */
DECL|function|utf8_fprintf
r_int
id|utf8_fprintf
c_func
(paren
id|FILE
op_star
id|stream
comma
r_const
r_char
op_star
id|format
comma
dot
dot
dot
)paren
(brace
r_struct
id|strbuf
id|buf
op_assign
id|STRBUF_INIT
suffix:semicolon
id|va_list
id|arg
suffix:semicolon
r_int
id|columns
suffix:semicolon
id|va_start
c_func
(paren
id|arg
comma
id|format
)paren
suffix:semicolon
id|strbuf_vaddf
c_func
(paren
op_amp
id|buf
comma
id|format
comma
id|arg
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|arg
)paren
suffix:semicolon
id|columns
op_assign
id|fputs
c_func
(paren
id|buf.buf
comma
id|stream
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_le
id|columns
)paren
multiline_comment|/* keep the error from the I/O */
id|columns
op_assign
id|utf8_strwidth
c_func
(paren
id|buf.buf
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|buf
)paren
suffix:semicolon
r_return
id|columns
suffix:semicolon
)brace
multiline_comment|/*&n; * Given a buffer and its encoding, return it re-encoded&n; * with iconv.  If the conversion fails, returns NULL.&n; */
macro_line|#ifndef NO_ICONV
macro_line|#if defined(OLD_ICONV) || (defined(__sun__) &amp;&amp; !defined(_XPG6))
DECL|typedef|iconv_ibp
r_typedef
r_const
r_char
op_star
id|iconv_ibp
suffix:semicolon
macro_line|#else
DECL|typedef|iconv_ibp
r_typedef
r_char
op_star
id|iconv_ibp
suffix:semicolon
macro_line|#endif
DECL|function|reencode_string_iconv
r_char
op_star
id|reencode_string_iconv
c_func
(paren
r_const
r_char
op_star
id|in
comma
r_int
id|insz
comma
id|iconv_t
id|conv
comma
r_int
op_star
id|outsz_p
)paren
(brace
r_int
id|outsz
comma
id|outalloc
suffix:semicolon
r_char
op_star
id|out
comma
op_star
id|outpos
suffix:semicolon
id|iconv_ibp
id|cp
suffix:semicolon
id|outsz
op_assign
id|insz
suffix:semicolon
id|outalloc
op_assign
id|outsz
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* for terminating NUL */
id|out
op_assign
id|xmalloc
c_func
(paren
id|outalloc
)paren
suffix:semicolon
id|outpos
op_assign
id|out
suffix:semicolon
id|cp
op_assign
(paren
id|iconv_ibp
)paren
id|in
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_int
id|cnt
op_assign
id|iconv
c_func
(paren
id|conv
comma
op_amp
id|cp
comma
op_amp
id|insz
comma
op_amp
id|outpos
comma
op_amp
id|outsz
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_eq
(paren
r_int
)paren
l_int|1
)paren
(brace
r_int
id|sofar
suffix:semicolon
r_if
c_cond
(paren
id|errno
op_ne
id|E2BIG
)paren
(brace
id|free
c_func
(paren
id|out
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* insz has remaining number of bytes.&n;&t;&t;&t; * since we started outsz the same as insz,&n;&t;&t;&t; * it is likely that insz is not enough for&n;&t;&t;&t; * converting the rest.&n;&t;&t;&t; */
id|sofar
op_assign
id|outpos
id|out
suffix:semicolon
id|outalloc
op_assign
id|sofar
op_plus
id|insz
op_star
l_int|2
op_plus
l_int|32
suffix:semicolon
id|out
op_assign
id|xrealloc
c_func
(paren
id|out
comma
id|outalloc
)paren
suffix:semicolon
id|outpos
op_assign
id|out
op_plus
id|sofar
suffix:semicolon
id|outsz
op_assign
id|outalloc
id|sofar
l_int|1
suffix:semicolon
)brace
r_else
(brace
op_star
id|outpos
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|outsz_p
)paren
op_star
id|outsz_p
op_assign
id|outpos
id|out
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
id|out
suffix:semicolon
)brace
DECL|function|reencode_string_len
r_char
op_star
id|reencode_string_len
c_func
(paren
r_const
r_char
op_star
id|in
comma
r_int
id|insz
comma
r_const
r_char
op_star
id|out_encoding
comma
r_const
r_char
op_star
id|in_encoding
comma
r_int
op_star
id|outsz
)paren
(brace
id|iconv_t
id|conv
suffix:semicolon
r_char
op_star
id|out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|in_encoding
)paren
r_return
l_int|NULL
suffix:semicolon
id|conv
op_assign
id|iconv_open
c_func
(paren
id|out_encoding
comma
id|in_encoding
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conv
op_eq
(paren
id|iconv_t
)paren
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t; * Some platforms do not have the variously spelled variants of&n;&t;&t; * UTF-8, so let&squot;s fall back to trying the most official&n;&t;&t; * spelling. We do so only as a fallback in case the platform&n;&t;&t; * does understand the user&squot;s spelling, but not our official&n;&t;&t; * one.&n;&t;&t; */
r_if
c_cond
(paren
id|is_encoding_utf8
c_func
(paren
id|in_encoding
)paren
)paren
id|in_encoding
op_assign
l_string|&quot;UTF-8&quot;
suffix:semicolon
r_if
c_cond
(paren
id|is_encoding_utf8
c_func
(paren
id|out_encoding
)paren
)paren
id|out_encoding
op_assign
l_string|&quot;UTF-8&quot;
suffix:semicolon
id|conv
op_assign
id|iconv_open
c_func
(paren
id|out_encoding
comma
id|in_encoding
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conv
op_eq
(paren
id|iconv_t
)paren
l_int|1
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
id|out
op_assign
id|reencode_string_iconv
c_func
(paren
id|in
comma
id|insz
comma
id|conv
comma
id|outsz
)paren
suffix:semicolon
id|iconv_close
c_func
(paren
id|conv
)paren
suffix:semicolon
r_return
id|out
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Returns first character length in bytes for multi-byte `text` according to&n; * `encoding`.&n; *&n; * - The `text` pointer is updated to point at the next character.&n; * - When `remainder_p` is not NULL, on entry `*remainder_p` is how much bytes&n; *   we can consume from text, and on exit `*remainder_p` is reduced by returned&n; *   character length. Otherwise `text` is treated as limited by NUL.&n; */
DECL|function|mbs_chrlen
r_int
id|mbs_chrlen
c_func
(paren
r_const
r_char
op_star
op_star
id|text
comma
r_int
op_star
id|remainder_p
comma
r_const
r_char
op_star
id|encoding
)paren
(brace
r_int
id|chrlen
suffix:semicolon
r_const
r_char
op_star
id|p
op_assign
op_star
id|text
suffix:semicolon
r_int
id|r
op_assign
(paren
id|remainder_p
ques
c_cond
op_star
id|remainder_p
suffix:colon
id|SIZE_MAX
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
OL
l_int|1
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|is_encoding_utf8
c_func
(paren
id|encoding
)paren
)paren
(brace
id|pick_one_utf8_char
c_func
(paren
op_amp
id|p
comma
op_amp
id|r
)paren
suffix:semicolon
id|chrlen
op_assign
id|p
ques
c_cond
(paren
id|p
op_star
id|text
)paren
suffix:colon
l_int|1
multiline_comment|/* not valid UTF-8 -&gt; raw byte sequence */
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * TODO use iconv to decode one char and obtain its chrlen&n;&t;&t; * for now, let&squot;s treat encodings != UTF-8 as one-byte&n;&t;&t; */
id|chrlen
op_assign
l_int|1
suffix:semicolon
)brace
op_star
id|text
op_add_assign
id|chrlen
suffix:semicolon
r_if
c_cond
(paren
id|remainder_p
)paren
op_star
id|remainder_p
op_sub_assign
id|chrlen
suffix:semicolon
r_return
id|chrlen
suffix:semicolon
)brace
multiline_comment|/*&n; * Pick the next char from the stream, ignoring codepoints an HFS+ would.&n; * Note that this is _not_ complete by any means. It&squot;s just enough&n; * to make is_hfs_dotgit() work, and should not be used otherwise.&n; */
DECL|function|next_hfs_char
r_static
id|ucs_char_t
id|next_hfs_char
c_func
(paren
r_const
r_char
op_star
op_star
id|in
)paren
(brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|ucs_char_t
id|out
op_assign
id|pick_one_utf8_char
c_func
(paren
id|in
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * check for malformed utf8. Technically this&n;&t;&t; * gets converted to a percent-sequence, but&n;&t;&t; * returning 0 is good enough for is_hfs_dotgit&n;&t;&t; * to realize it cannot be .git&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
op_star
id|in
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* these code points are ignored completely */
r_switch
c_cond
(paren
id|out
)paren
(brace
r_case
l_int|0x200c
suffix:colon
multiline_comment|/* ZERO WIDTH NON-JOINER */
r_case
l_int|0x200d
suffix:colon
multiline_comment|/* ZERO WIDTH JOINER */
r_case
l_int|0x200e
suffix:colon
multiline_comment|/* LEFT-TO-RIGHT MARK */
r_case
l_int|0x200f
suffix:colon
multiline_comment|/* RIGHT-TO-LEFT MARK */
r_case
l_int|0x202a
suffix:colon
multiline_comment|/* LEFT-TO-RIGHT EMBEDDING */
r_case
l_int|0x202b
suffix:colon
multiline_comment|/* RIGHT-TO-LEFT EMBEDDING */
r_case
l_int|0x202c
suffix:colon
multiline_comment|/* POP DIRECTIONAL FORMATTING */
r_case
l_int|0x202d
suffix:colon
multiline_comment|/* LEFT-TO-RIGHT OVERRIDE */
r_case
l_int|0x202e
suffix:colon
multiline_comment|/* RIGHT-TO-LEFT OVERRIDE */
r_case
l_int|0x206a
suffix:colon
multiline_comment|/* INHIBIT SYMMETRIC SWAPPING */
r_case
l_int|0x206b
suffix:colon
multiline_comment|/* ACTIVATE SYMMETRIC SWAPPING */
r_case
l_int|0x206c
suffix:colon
multiline_comment|/* INHIBIT ARABIC FORM SHAPING */
r_case
l_int|0x206d
suffix:colon
multiline_comment|/* ACTIVATE ARABIC FORM SHAPING */
r_case
l_int|0x206e
suffix:colon
multiline_comment|/* NATIONAL DIGIT SHAPES */
r_case
l_int|0x206f
suffix:colon
multiline_comment|/* NOMINAL DIGIT SHAPES */
r_case
l_int|0xfeff
suffix:colon
multiline_comment|/* ZERO WIDTH NO-BREAK SPACE */
r_continue
suffix:semicolon
)brace
r_return
id|out
suffix:semicolon
)brace
)brace
DECL|function|is_hfs_dotgit
r_int
id|is_hfs_dotgit
c_func
(paren
r_const
r_char
op_star
id|path
)paren
(brace
id|ucs_char_t
id|c
suffix:semicolon
id|c
op_assign
id|next_hfs_char
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_ne
l_char|&squot;.&squot;
)paren
r_return
l_int|0
suffix:semicolon
id|c
op_assign
id|next_hfs_char
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * there&squot;s a great deal of other case-folding that occurs&n;&t; * in HFS+, but this is enough to catch anything that will&n;&t; * convert to &quot;.git&quot;&n;&t; */
r_if
c_cond
(paren
id|c
op_ne
l_char|&squot;g&squot;
op_logical_and
id|c
op_ne
l_char|&squot;G&squot;
)paren
r_return
l_int|0
suffix:semicolon
id|c
op_assign
id|next_hfs_char
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_ne
l_char|&squot;i&squot;
op_logical_and
id|c
op_ne
l_char|&squot;I&squot;
)paren
r_return
l_int|0
suffix:semicolon
id|c
op_assign
id|next_hfs_char
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_ne
l_char|&squot;t&squot;
op_logical_and
id|c
op_ne
l_char|&squot;T&squot;
)paren
r_return
l_int|0
suffix:semicolon
id|c
op_assign
id|next_hfs_char
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_logical_and
op_logical_neg
id|is_dir_sep
c_func
(paren
id|c
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|variable|utf8_bom
r_const
r_char
id|utf8_bom
(braket
)braket
op_assign
l_string|&quot;&bslash;357&bslash;273&bslash;277&quot;
suffix:semicolon
DECL|function|skip_utf8_bom
r_int
id|skip_utf8_bom
c_func
(paren
r_char
op_star
op_star
id|text
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|len
OL
id|strlen
c_func
(paren
id|utf8_bom
)paren
op_logical_or
id|memcmp
c_func
(paren
op_star
id|text
comma
id|utf8_bom
comma
id|strlen
c_func
(paren
id|utf8_bom
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|text
op_add_assign
id|strlen
c_func
(paren
id|utf8_bom
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
eof
