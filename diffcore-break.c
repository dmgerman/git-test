multiline_comment|/*&n; * Copyright (C) 2005 Junio C Hamano&n; */
macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;diff.h&quot;
macro_line|#include &quot;diffcore.h&quot;
macro_line|#include &quot;delta.h&quot;
macro_line|#include &quot;count-delta.h&quot;
DECL|function|very_different
r_static
r_int
id|very_different
c_func
(paren
r_struct
id|diff_filespec
op_star
id|src
comma
r_struct
id|diff_filespec
op_star
id|dst
comma
r_int
id|min_score
)paren
(brace
multiline_comment|/* dst is recorded as a modification of src.  Are they so&n;&t; * different that we are better off recording this as a pair&n;&t; * of delete and create?  min_score is the minimum amount of&n;&t; * new material that must exist in the dst and not in src for&n;&t; * the pair to be considered a complete rewrite, and recommended&n;&t; * to be set to a very high value, 99% or so.&n;&t; *&n;&t; * The value we return represents the amount of new material&n;&t; * that is in dst and not in src.  We return 0 when we do not&n;&t; * want to get the filepair broken.&n;&t; */
r_void
op_star
id|delta
suffix:semicolon
r_int
r_int
id|delta_size
comma
id|base_size
comma
id|src_copied
comma
id|literal_added
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISREG
c_func
(paren
id|src-&gt;mode
)paren
op_logical_or
op_logical_neg
id|S_ISREG
c_func
(paren
id|dst-&gt;mode
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* leave symlink rename alone */
r_if
c_cond
(paren
id|diff_populate_filespec
c_func
(paren
id|src
comma
l_int|1
)paren
op_logical_or
id|diff_populate_filespec
c_func
(paren
id|dst
comma
l_int|1
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* error but caught downstream */
id|delta_size
op_assign
(paren
(paren
id|src-&gt;size
OL
id|dst-&gt;size
)paren
ques
c_cond
(paren
id|dst-&gt;size
id|src-&gt;size
)paren
suffix:colon
(paren
id|src-&gt;size
id|dst-&gt;size
)paren
)paren
suffix:semicolon
multiline_comment|/* Notice that we use max of src and dst as the base size,&n;&t; * unlike rename similarity detection.  This is so that we do&n;&t; * not mistake a large addition as a complete rewrite.&n;&t; */
id|base_size
op_assign
(paren
(paren
id|src-&gt;size
OL
id|dst-&gt;size
)paren
ques
c_cond
id|dst-&gt;size
suffix:colon
id|src-&gt;size
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If file size difference is too big compared to the&n;&t; * base_size, we declare this a complete rewrite.&n;&t; */
r_if
c_cond
(paren
id|base_size
op_star
id|min_score
OL
id|delta_size
op_star
id|MAX_SCORE
)paren
r_return
id|MAX_SCORE
suffix:semicolon
r_if
c_cond
(paren
id|diff_populate_filespec
c_func
(paren
id|src
comma
l_int|0
)paren
op_logical_or
id|diff_populate_filespec
c_func
(paren
id|dst
comma
l_int|0
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* error but caught downstream */
id|delta
op_assign
id|diff_delta
c_func
(paren
id|src-&gt;data
comma
id|src-&gt;size
comma
id|dst-&gt;data
comma
id|dst-&gt;size
comma
op_amp
id|delta_size
)paren
suffix:semicolon
multiline_comment|/* A delta that has a lot of literal additions would have&n;&t; * big delta_size no matter what else it does.&n;&t; */
r_if
c_cond
(paren
id|base_size
op_star
id|min_score
OL
id|delta_size
op_star
id|MAX_SCORE
)paren
r_return
id|MAX_SCORE
suffix:semicolon
multiline_comment|/* Estimate the edit size by interpreting delta. */
r_if
c_cond
(paren
id|count_delta
c_func
(paren
id|delta
comma
id|delta_size
comma
op_amp
id|src_copied
comma
op_amp
id|literal_added
)paren
)paren
(brace
id|free
c_func
(paren
id|delta
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|free
c_func
(paren
id|delta
)paren
suffix:semicolon
multiline_comment|/* Extent of damage */
r_if
c_cond
(paren
id|src-&gt;size
op_plus
id|literal_added
OL
id|src_copied
)paren
id|delta_size
op_assign
l_int|0
suffix:semicolon
r_else
id|delta_size
op_assign
(paren
id|src-&gt;size
id|src_copied
)paren
op_plus
id|literal_added
suffix:semicolon
r_if
c_cond
(paren
id|base_size
OL
id|delta_size
)paren
r_return
id|MAX_SCORE
suffix:semicolon
r_return
id|delta_size
op_star
id|MAX_SCORE
op_div
id|base_size
suffix:semicolon
)brace
DECL|function|diffcore_break
r_void
id|diffcore_break
c_func
(paren
r_int
id|min_score
)paren
(brace
r_struct
id|diff_queue_struct
op_star
id|q
op_assign
op_amp
id|diff_queued_diff
suffix:semicolon
r_struct
id|diff_queue_struct
id|outq
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|min_score
)paren
id|min_score
op_assign
id|DEFAULT_BREAK_SCORE
suffix:semicolon
id|outq.nr
op_assign
id|outq.alloc
op_assign
l_int|0
suffix:semicolon
id|outq.queue
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|q-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|diff_filepair
op_star
id|p
op_assign
id|q-&gt;queue
(braket
id|i
)braket
suffix:semicolon
r_int
id|score
suffix:semicolon
multiline_comment|/* We deal only with in-place edit of non directory.&n;&t;&t; * We do not break anything else.&n;&t;&t; */
r_if
c_cond
(paren
id|DIFF_FILE_VALID
c_func
(paren
id|p-&gt;one
)paren
op_logical_and
id|DIFF_FILE_VALID
c_func
(paren
id|p-&gt;two
)paren
op_logical_and
op_logical_neg
id|S_ISDIR
c_func
(paren
id|p-&gt;one-&gt;mode
)paren
op_logical_and
op_logical_neg
id|S_ISDIR
c_func
(paren
id|p-&gt;two-&gt;mode
)paren
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|p-&gt;one-&gt;path
comma
id|p-&gt;two-&gt;path
)paren
)paren
(brace
id|score
op_assign
id|very_different
c_func
(paren
id|p-&gt;one
comma
id|p-&gt;two
comma
id|min_score
)paren
suffix:semicolon
r_if
c_cond
(paren
id|min_score
op_le
id|score
)paren
(brace
multiline_comment|/* Split this into delete and create */
r_struct
id|diff_filespec
op_star
id|null_one
comma
op_star
id|null_two
suffix:semicolon
r_struct
id|diff_filepair
op_star
id|dp
suffix:semicolon
multiline_comment|/* deletion of one */
id|null_one
op_assign
id|alloc_filespec
c_func
(paren
id|p-&gt;one-&gt;path
)paren
suffix:semicolon
id|dp
op_assign
id|diff_queue
c_func
(paren
op_amp
id|outq
comma
id|p-&gt;one
comma
id|null_one
)paren
suffix:semicolon
id|dp-&gt;score
op_assign
id|score
suffix:semicolon
id|dp-&gt;broken_pair
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* creation of two */
id|null_two
op_assign
id|alloc_filespec
c_func
(paren
id|p-&gt;two-&gt;path
)paren
suffix:semicolon
id|dp
op_assign
id|diff_queue
c_func
(paren
op_amp
id|outq
comma
id|null_two
comma
id|p-&gt;two
)paren
suffix:semicolon
id|dp-&gt;score
op_assign
id|score
suffix:semicolon
id|dp-&gt;broken_pair
op_assign
l_int|1
suffix:semicolon
id|free
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/* not diff_free_filepair(), we are&n;&t;&t;&t;&t;&t;  * reusing one and two here.&n;&t;&t;&t;&t;&t;  */
r_continue
suffix:semicolon
)brace
)brace
id|diff_q
c_func
(paren
op_amp
id|outq
comma
id|p
)paren
suffix:semicolon
)brace
id|free
c_func
(paren
id|q-&gt;queue
)paren
suffix:semicolon
op_star
id|q
op_assign
id|outq
suffix:semicolon
r_return
suffix:semicolon
)brace
eof
