macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;attr.h&quot;
multiline_comment|/*&n; * convert.c - convert a file when checking it out and checking it in.&n; *&n; * This should use the pathname to decide on whether it wants to do some&n; * more interesting conversions (automatic gzip/unzip, general format&n; * conversions etc etc), but by default it just does automatic CRLF&lt;-&gt;LF&n; * translation when the &quot;auto_crlf&quot; option is set.&n; */
DECL|macro|CRLF_GUESS
mdefine_line|#define CRLF_GUESS&t;(-1)
DECL|macro|CRLF_BINARY
mdefine_line|#define CRLF_BINARY&t;0
DECL|macro|CRLF_TEXT
mdefine_line|#define CRLF_TEXT&t;1
DECL|macro|CRLF_INPUT
mdefine_line|#define CRLF_INPUT&t;2
DECL|struct|text_stat
r_struct
id|text_stat
(brace
multiline_comment|/* CR, LF and CRLF counts */
DECL|member|cr
DECL|member|lf
DECL|member|crlf
r_int
id|cr
comma
id|lf
comma
id|crlf
suffix:semicolon
multiline_comment|/* These are just approximations! */
DECL|member|printable
DECL|member|nonprintable
r_int
id|printable
comma
id|nonprintable
suffix:semicolon
)brace
suffix:semicolon
DECL|function|gather_stats
r_static
r_void
id|gather_stats
c_func
(paren
r_const
r_char
op_star
id|buf
comma
r_int
r_int
id|size
comma
r_struct
id|text_stat
op_star
id|stats
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
id|memset
c_func
(paren
id|stats
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|stats
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|size
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_char
id|c
op_assign
id|buf
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;r&squot;
)paren
(brace
id|stats-&gt;cr
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|i
op_plus
l_int|1
OL
id|size
op_logical_and
id|buf
(braket
id|i
op_plus
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|stats-&gt;crlf
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|stats-&gt;lf
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
l_int|127
)paren
multiline_comment|/* DEL */
id|stats-&gt;nonprintable
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c
OL
l_int|32
)paren
(brace
r_switch
c_cond
(paren
id|c
)paren
(brace
multiline_comment|/* BS, HT, ESC and FF */
r_case
l_char|&squot;&bslash;b&squot;
suffix:colon
r_case
l_char|&squot;&bslash;t&squot;
suffix:colon
r_case
l_char|&squot;&bslash;033&squot;
suffix:colon
r_case
l_char|&squot;&bslash;014&squot;
suffix:colon
id|stats-&gt;printable
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|stats-&gt;nonprintable
op_increment
suffix:semicolon
)brace
)brace
r_else
id|stats-&gt;printable
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * The same heuristics as diff.c::mmfile_is_binary()&n; */
DECL|function|is_binary
r_static
r_int
id|is_binary
c_func
(paren
r_int
r_int
id|size
comma
r_struct
id|text_stat
op_star
id|stats
)paren
(brace
r_if
c_cond
(paren
(paren
id|stats-&gt;printable
op_rshift
l_int|7
)paren
OL
id|stats-&gt;nonprintable
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Other heuristics? Average line length might be relevant,&n;&t; * as might LF vs CR vs CRLF counts..&n;&t; *&n;&t; * NOTE! It might be normal to have a low ratio of CRLF to LF&n;&t; * (somebody starts with a LF-only file and edits it with an editor&n;&t; * that adds CRLF only to lines that are added..). But do  we&n;&t; * want to support CR-only? Probably not.&n;&t; */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|crlf_to_git
r_static
r_int
id|crlf_to_git
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_char
op_star
op_star
id|bufp
comma
r_int
r_int
op_star
id|sizep
comma
r_int
id|action
)paren
(brace
r_char
op_star
id|buffer
comma
op_star
id|nbuf
suffix:semicolon
r_int
r_int
id|size
comma
id|nsize
suffix:semicolon
r_struct
id|text_stat
id|stats
suffix:semicolon
r_if
c_cond
(paren
(paren
id|action
op_eq
id|CRLF_BINARY
)paren
op_logical_or
(paren
id|action
op_eq
id|CRLF_GUESS
op_logical_and
op_logical_neg
id|auto_crlf
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|size
op_assign
op_star
id|sizep
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|size
)paren
r_return
l_int|0
suffix:semicolon
id|buffer
op_assign
op_star
id|bufp
suffix:semicolon
id|gather_stats
c_func
(paren
id|buffer
comma
id|size
comma
op_amp
id|stats
)paren
suffix:semicolon
multiline_comment|/* No CR? Nothing to convert, regardless. */
r_if
c_cond
(paren
op_logical_neg
id|stats.cr
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|action
op_eq
id|CRLF_GUESS
)paren
(brace
multiline_comment|/*&n;&t;&t; * We&squot;re currently not going to even try to convert stuff&n;&t;&t; * that has bare CR characters. Does anybody do that crazy&n;&t;&t; * stuff?&n;&t;&t; */
r_if
c_cond
(paren
id|stats.cr
op_ne
id|stats.crlf
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * And add some heuristics for binary vs text, of course...&n;&t;&t; */
r_if
c_cond
(paren
id|is_binary
c_func
(paren
id|size
comma
op_amp
id|stats
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Ok, allocate a new buffer, fill it in, and return true&n;&t; * to let the caller know that we switched buffers on it.&n;&t; */
id|nsize
op_assign
id|size
id|stats.crlf
suffix:semicolon
id|nbuf
op_assign
id|xmalloc
c_func
(paren
id|nsize
)paren
suffix:semicolon
op_star
id|bufp
op_assign
id|nbuf
suffix:semicolon
op_star
id|sizep
op_assign
id|nsize
suffix:semicolon
r_if
c_cond
(paren
id|action
op_eq
id|CRLF_GUESS
)paren
(brace
multiline_comment|/*&n;&t;&t; * If we guessed, we already know we rejected a file with&n;&t;&t; * lone CR, and we can strip a CR without looking at what&n;&t;&t; * follow it.&n;&t;&t; */
r_do
(brace
r_int
r_char
id|c
op_assign
op_star
id|buffer
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|c
op_ne
l_char|&squot;&bslash;r&squot;
)paren
op_star
id|nbuf
op_increment
op_assign
id|c
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|size
)paren
suffix:semicolon
)brace
r_else
(brace
r_do
(brace
r_int
r_char
id|c
op_assign
op_star
id|buffer
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|c
op_eq
l_char|&squot;&bslash;r&squot;
op_logical_and
(paren
l_int|1
OL
id|size
op_logical_and
op_star
id|buffer
op_eq
l_char|&squot;&bslash;n&squot;
)paren
)paren
)paren
op_star
id|nbuf
op_increment
op_assign
id|c
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|size
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|crlf_to_worktree
r_static
r_int
id|crlf_to_worktree
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_char
op_star
op_star
id|bufp
comma
r_int
r_int
op_star
id|sizep
comma
r_int
id|action
)paren
(brace
r_char
op_star
id|buffer
comma
op_star
id|nbuf
suffix:semicolon
r_int
r_int
id|size
comma
id|nsize
suffix:semicolon
r_struct
id|text_stat
id|stats
suffix:semicolon
r_int
r_char
id|last
suffix:semicolon
r_if
c_cond
(paren
(paren
id|action
op_eq
id|CRLF_BINARY
)paren
op_logical_or
(paren
id|action
op_eq
id|CRLF_INPUT
)paren
op_logical_or
(paren
id|action
op_eq
id|CRLF_GUESS
op_logical_and
id|auto_crlf
op_le
l_int|0
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|size
op_assign
op_star
id|sizep
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|size
)paren
r_return
l_int|0
suffix:semicolon
id|buffer
op_assign
op_star
id|bufp
suffix:semicolon
id|gather_stats
c_func
(paren
id|buffer
comma
id|size
comma
op_amp
id|stats
)paren
suffix:semicolon
multiline_comment|/* No LF? Nothing to convert, regardless. */
r_if
c_cond
(paren
op_logical_neg
id|stats.lf
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Was it already in CRLF format? */
r_if
c_cond
(paren
id|stats.lf
op_eq
id|stats.crlf
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|action
op_eq
id|CRLF_GUESS
)paren
(brace
multiline_comment|/* If we have any bare CR characters, we&squot;re not going to touch it */
r_if
c_cond
(paren
id|stats.cr
op_ne
id|stats.crlf
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|is_binary
c_func
(paren
id|size
comma
op_amp
id|stats
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Ok, allocate a new buffer, fill it in, and return true&n;&t; * to let the caller know that we switched buffers on it.&n;&t; */
id|nsize
op_assign
id|size
op_plus
id|stats.lf
id|stats.crlf
suffix:semicolon
id|nbuf
op_assign
id|xmalloc
c_func
(paren
id|nsize
)paren
suffix:semicolon
op_star
id|bufp
op_assign
id|nbuf
suffix:semicolon
op_star
id|sizep
op_assign
id|nsize
suffix:semicolon
id|last
op_assign
l_int|0
suffix:semicolon
r_do
(brace
r_int
r_char
id|c
op_assign
op_star
id|buffer
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
op_logical_and
id|last
op_ne
l_char|&squot;&bslash;r&squot;
)paren
op_star
id|nbuf
op_increment
op_assign
l_char|&squot;&bslash;r&squot;
suffix:semicolon
op_star
id|nbuf
op_increment
op_assign
id|c
suffix:semicolon
id|last
op_assign
id|c
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|size
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|setup_crlf_check
r_static
r_void
id|setup_crlf_check
c_func
(paren
r_struct
id|git_attr_check
op_star
id|check
)paren
(brace
r_static
r_struct
id|git_attr
op_star
id|attr_crlf
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|attr_crlf
)paren
id|attr_crlf
op_assign
id|git_attr
c_func
(paren
l_string|&quot;crlf&quot;
comma
l_int|4
)paren
suffix:semicolon
id|check-&gt;attr
op_assign
id|attr_crlf
suffix:semicolon
)brace
DECL|function|git_path_check_crlf
r_static
r_int
id|git_path_check_crlf
c_func
(paren
r_const
r_char
op_star
id|path
)paren
(brace
r_struct
id|git_attr_check
id|attr_crlf_check
suffix:semicolon
id|setup_crlf_check
c_func
(paren
op_amp
id|attr_crlf_check
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|git_checkattr
c_func
(paren
id|path
comma
l_int|1
comma
op_amp
id|attr_crlf_check
)paren
)paren
(brace
r_const
r_char
op_star
id|value
op_assign
id|attr_crlf_check.value
suffix:semicolon
r_if
c_cond
(paren
id|ATTR_TRUE
c_func
(paren
id|value
)paren
)paren
r_return
id|CRLF_TEXT
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ATTR_FALSE
c_func
(paren
id|value
)paren
)paren
r_return
id|CRLF_BINARY
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ATTR_UNSET
c_func
(paren
id|value
)paren
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|value
comma
l_string|&quot;input&quot;
)paren
)paren
r_return
id|CRLF_INPUT
suffix:semicolon
multiline_comment|/* fallthru */
)brace
r_return
id|CRLF_GUESS
suffix:semicolon
)brace
DECL|function|convert_to_git
r_int
id|convert_to_git
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_char
op_star
op_star
id|bufp
comma
r_int
r_int
op_star
id|sizep
)paren
(brace
r_return
id|crlf_to_git
c_func
(paren
id|path
comma
id|bufp
comma
id|sizep
comma
id|git_path_check_crlf
c_func
(paren
id|path
)paren
)paren
suffix:semicolon
)brace
DECL|function|convert_to_working_tree
r_int
id|convert_to_working_tree
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_char
op_star
op_star
id|bufp
comma
r_int
r_int
op_star
id|sizep
)paren
(brace
r_return
id|crlf_to_worktree
c_func
(paren
id|path
comma
id|bufp
comma
id|sizep
comma
id|git_path_check_crlf
c_func
(paren
id|path
)paren
)paren
suffix:semicolon
)brace
eof
