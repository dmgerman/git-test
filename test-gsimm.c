macro_line|#include &lt;unistd.h&gt;
macro_line|#include &lt;stdlib.h&gt;
macro_line|#include &lt;fcntl.h&gt;
macro_line|#include &lt;libgen.h&gt;
macro_line|#include &lt;stdio.h&gt;
macro_line|#include &lt;assert.h&gt;
macro_line|#include &lt;math.h&gt;
macro_line|#include &lt;string.h&gt;
macro_line|#include &lt;sys/types.h&gt;
macro_line|#include &lt;sys/stat.h&gt;
macro_line|#include &lt;sys/mman.h&gt;
macro_line|#include &quot;rabinpoly.h&quot;
macro_line|#include &quot;gsimm.h&quot;
DECL|macro|MIN
mdefine_line|#define MIN(x,y) ((y)&lt;(x) ? (y) : (x))
DECL|macro|MAX
mdefine_line|#define MAX(x,y) ((y)&gt;(x) ? (y) : (x))
multiline_comment|/* The RABIN_WINDOW_SIZE is the size of fingerprint window used by&n;   Rabin algorithm. This is not a modifiable parameter.&n;&n;   The first RABIN_WINDOW_SIZE - 1 bytes are skipped, in order to ensure&n;   fingerprints are good hashes. This does somewhat reduce the&n;   influence of the first few bytes in the file (they&squot;re part of&n;   fewer windows, like the last few bytes), but that actually isn&squot;t&n;   so bad as files often start with fixed content that may bias comparisons.&n;*/
DECL|struct|fileinfo
r_typedef
r_struct
id|fileinfo
DECL|member|name
(brace
r_char
op_star
id|name
suffix:semicolon
DECL|member|length
r_int
id|length
suffix:semicolon
DECL|member|md
id|u_char
id|md
(braket
id|MD_LENGTH
)braket
suffix:semicolon
DECL|member|match
r_int
id|match
suffix:semicolon
DECL|typedef|File
)brace
id|File
suffix:semicolon
DECL|variable|flag_verbose
r_int
id|flag_verbose
op_assign
l_int|0
suffix:semicolon
DECL|variable|flag_debug
r_int
id|flag_debug
op_assign
l_int|0
suffix:semicolon
DECL|variable|flag_relative
r_char
op_star
id|flag_relative
op_assign
l_int|0
suffix:semicolon
DECL|variable|cmd
r_char
id|cmd
(braket
l_int|12
)braket
op_assign
l_string|&quot;        ...&quot;
suffix:semicolon
DECL|variable|md_strbuf
r_char
id|md_strbuf
(braket
id|MD_LENGTH
op_star
l_int|2
op_plus
l_int|1
)braket
suffix:semicolon
DECL|variable|relative_md
id|u_char
id|relative_md
(braket
id|MD_LENGTH
)braket
suffix:semicolon
DECL|variable|file
id|File
op_star
id|file
suffix:semicolon
DECL|variable|file_count
r_int
id|file_count
suffix:semicolon
DECL|variable|file_bytes
r_int
id|file_bytes
suffix:semicolon
DECL|variable|hex
r_char
id|hex
(braket
l_int|17
)braket
op_assign
l_string|&quot;0123456789abcdef&quot;
suffix:semicolon
DECL|function|usage
r_void
id|usage
c_func
(paren
)paren
(brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;usage: %s [-dhvw] [-r fingerprint] file ...&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
id|fprintf
(paren
id|stderr
comma
l_string|&quot; -d&bslash;tdebug output, repeate for more verbosity&bslash;n&quot;
)paren
suffix:semicolon
id|fprintf
(paren
id|stderr
comma
l_string|&quot; -h&bslash;tshow this usage information&bslash;n&quot;
)paren
suffix:semicolon
id|fprintf
(paren
id|stderr
comma
l_string|&quot; -r&bslash;tshow distance relative to fingerprint &quot;
l_string|&quot;(%u hex digits)&bslash;n&quot;
comma
id|MD_LENGTH
op_star
l_int|2
)paren
suffix:semicolon
id|fprintf
(paren
id|stderr
comma
l_string|&quot; -v&bslash;tverbose output, repeat for even more verbosity&bslash;n&quot;
)paren
suffix:semicolon
id|fprintf
(paren
id|stderr
comma
l_string|&quot; -w&bslash;tenable warnings for suspect statistics&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|md_to_str
r_char
op_star
id|md_to_str
c_func
(paren
id|u_char
op_star
id|md
)paren
(brace
r_int
id|j
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|MD_LENGTH
suffix:semicolon
id|j
op_increment
)paren
(brace
id|u_char
id|ch
op_assign
id|md
(braket
id|j
)braket
suffix:semicolon
id|md_strbuf
(braket
id|j
op_star
l_int|2
)braket
op_assign
id|hex
(braket
id|ch
op_rshift
l_int|4
)braket
suffix:semicolon
id|md_strbuf
(braket
id|j
op_star
l_int|2
op_plus
l_int|1
)braket
op_assign
id|hex
(braket
id|ch
op_amp
l_int|0xF
)braket
suffix:semicolon
)brace
id|md_strbuf
(braket
id|j
op_star
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
r_return
id|md_strbuf
suffix:semicolon
)brace
DECL|function|process_file
r_void
id|process_file
(paren
r_char
op_star
id|name
)paren
(brace
r_int
id|fd
suffix:semicolon
r_struct
id|stat
id|fs
suffix:semicolon
id|u_char
op_star
id|data
suffix:semicolon
id|File
op_star
id|fi
op_assign
id|file
op_plus
id|file_count
suffix:semicolon
suffix:semicolon
id|fd
op_assign
id|open
(paren
id|name
comma
id|O_RDONLY
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
(brace
id|perror
(paren
id|name
)paren
suffix:semicolon
m_exit
(paren
l_int|2
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fstat
(paren
id|fd
comma
op_amp
id|fs
)paren
)paren
(brace
id|perror
(paren
id|name
)paren
suffix:semicolon
m_exit
(paren
l_int|2
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fs.st_size
op_ge
id|GB_SIMM_MIN_FILE_SIZE
op_logical_and
id|fs.st_size
op_le
id|GB_SIMM_MAX_FILE_SIZE
)paren
(brace
id|fi-&gt;length
op_assign
id|fs.st_size
suffix:semicolon
id|fi-&gt;name
op_assign
id|name
suffix:semicolon
id|data
op_assign
(paren
id|u_char
op_star
)paren
id|mmap
(paren
l_int|0
comma
id|fs.st_size
comma
id|PROT_READ
comma
id|MAP_PRIVATE
comma
id|fd
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data
op_eq
(paren
id|u_char
op_star
)paren
l_int|1
)paren
(brace
id|perror
(paren
id|name
)paren
suffix:semicolon
m_exit
(paren
l_int|2
)paren
suffix:semicolon
)brace
id|gb_simm_process
(paren
id|data
comma
id|fs.st_size
comma
id|fi-&gt;md
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flag_relative
)paren
id|fprintf
(paren
id|stdout
comma
l_string|&quot;%s %llu %u %s %u %3.1f&bslash;n&quot;
comma
id|md_to_str
(paren
id|fi-&gt;md
)paren
comma
(paren
r_int
r_int
r_int
)paren
l_int|0
comma
(paren
r_int
)paren
id|fs.st_size
comma
id|name
comma
(paren
r_int
)paren
l_int|0
comma
l_float|100.0
op_star
id|gb_simm_score
c_func
(paren
id|fi-&gt;md
comma
id|relative_md
)paren
)paren
suffix:semicolon
r_else
(brace
id|fprintf
(paren
id|stdout
comma
l_string|&quot;%s %llu %u %s&bslash;n&quot;
comma
id|md_to_str
(paren
id|fi-&gt;md
)paren
comma
(paren
r_int
r_int
r_int
)paren
l_int|0
comma
(paren
r_int
)paren
id|fs.st_size
comma
id|name
)paren
suffix:semicolon
)brace
id|munmap
(paren
id|data
comma
id|fs.st_size
)paren
suffix:semicolon
id|file_bytes
op_add_assign
id|fs.st_size
suffix:semicolon
id|file_count
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|flag_verbose
)paren
(brace
id|fprintf
(paren
id|stdout
comma
l_string|&quot;skipping %s (size %llu)&bslash;n&quot;
comma
id|name
comma
(paren
r_int
r_int
r_int
)paren
id|fs.st_size
)paren
suffix:semicolon
)brace
id|close
(paren
id|fd
)paren
suffix:semicolon
)brace
DECL|function|str_to_md
id|u_char
op_star
id|str_to_md
c_func
(paren
r_char
op_star
id|str
comma
id|u_char
op_star
id|md
)paren
(brace
r_int
id|j
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|md
op_logical_or
op_logical_neg
id|str
)paren
r_return
l_int|0
suffix:semicolon
id|bzero
(paren
id|md
comma
id|MD_LENGTH
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|MD_LENGTH
op_star
l_int|2
suffix:semicolon
id|j
op_increment
)paren
(brace
r_char
id|ch
op_assign
id|str
(braket
id|j
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_ge
l_char|&squot;0&squot;
op_logical_and
id|ch
op_le
l_char|&squot;9&squot;
)paren
(brace
id|md
(braket
id|j
op_div
l_int|2
)braket
op_assign
(paren
id|md
(braket
id|j
op_div
l_int|2
)braket
op_lshift
l_int|4
)paren
op_plus
(paren
id|ch
l_char|&squot;0&squot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|ch
op_or_assign
l_int|32
suffix:semicolon
r_if
c_cond
(paren
id|ch
template_param
l_char|&squot;f&squot;
)paren
r_break
suffix:semicolon
id|md
(braket
id|j
op_div
l_int|2
)braket
op_assign
(paren
id|md
(braket
id|j
op_div
l_int|2
)braket
op_lshift
l_int|4
)paren
op_plus
(paren
id|ch
l_char|&squot;a&squot;
op_plus
l_int|10
)paren
suffix:semicolon
)brace
)brace
r_return
(paren
id|j
op_ne
id|MD_LENGTH
op_star
l_int|2
op_logical_or
id|str
(braket
id|j
)braket
op_ne
l_int|0
)paren
ques
c_cond
l_int|0
suffix:colon
id|md
suffix:semicolon
)brace
DECL|function|main
r_int
id|main
(paren
r_int
id|argc
comma
r_char
op_star
id|argv
(braket
)braket
)paren
(brace
r_int
id|ch
comma
id|j
suffix:semicolon
id|strncpy
(paren
id|cmd
comma
id|basename
(paren
id|argv
(braket
l_int|0
)braket
)paren
comma
l_int|8
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ch
op_assign
id|getopt
c_func
(paren
id|argc
comma
id|argv
comma
l_string|&quot;dhr:vw&quot;
)paren
)paren
op_ne
l_int|1
)paren
(brace
r_switch
c_cond
(paren
id|ch
)paren
(brace
r_case
l_char|&squot;d&squot;
suffix:colon
id|flag_debug
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;r&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|optarg
)paren
(brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;%s: missing argument for -r&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|str_to_md
(paren
id|optarg
comma
id|relative_md
)paren
)paren
id|flag_relative
op_assign
id|optarg
suffix:semicolon
r_else
(brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;%s: not a valid fingerprint&bslash;n&quot;
comma
id|optarg
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;v&squot;
suffix:colon
id|flag_verbose
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;w&squot;
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|usage
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
id|ch
op_ne
l_char|&squot;h&squot;
)paren
suffix:semicolon
)brace
)brace
id|argc
op_sub_assign
id|optind
suffix:semicolon
id|argv
op_add_assign
id|optind
suffix:semicolon
r_if
c_cond
(paren
id|argc
op_eq
l_int|0
)paren
id|usage
c_func
(paren
)paren
suffix:semicolon
id|rabin_reset
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flag_verbose
op_logical_and
id|flag_relative
)paren
(brace
id|fprintf
(paren
id|stdout
comma
l_string|&quot;distances are relative to %s&bslash;n&quot;
comma
id|flag_relative
)paren
suffix:semicolon
)brace
id|file
op_assign
(paren
id|File
op_star
)paren
id|calloc
(paren
id|argc
comma
r_sizeof
(paren
id|File
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|argc
suffix:semicolon
id|j
op_increment
)paren
id|process_file
(paren
id|argv
(braket
id|j
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flag_verbose
)paren
(brace
id|fprintf
(paren
id|stdout
comma
l_string|&quot;%li bytes in %i files&bslash;n&quot;
comma
(paren
r_int
)paren
id|file_bytes
comma
id|file_count
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
