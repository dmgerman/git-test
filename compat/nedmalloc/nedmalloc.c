multiline_comment|/* Alternative malloc implementation for multiple threads without&n;lock contention based on dlmalloc. (C) 2005-2006 Niall Douglas&n;&n;Boost Software License - Version 1.0 - August 17th, 2003&n;&n;Permission is hereby granted, free of charge, to any person or organization&n;obtaining a copy of the software and accompanying documentation covered by&n;this license (the &quot;Software&quot;) to use, reproduce, display, distribute,&n;execute, and transmit the Software, and to prepare derivative works of the&n;Software, and to permit third-parties to whom the Software is furnished to&n;do so, all subject to the following:&n;&n;The copyright notices in the Software and this entire statement, including&n;the above license grant, this restriction and the following disclaimer,&n;must be included in all copies of the Software, in whole or in part, and&n;all derivative works of the Software, unless such copies or derivative&n;works are solely in the form of machine-executable object code generated by&n;a source language processor.&n;&n;THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR&n;IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,&n;FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT&n;SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE&n;FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,&n;ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER&n;DEALINGS IN THE SOFTWARE.&n;*/
macro_line|#ifdef _MSC_VER
multiline_comment|/* Enable full aliasing on MSVC */
multiline_comment|/*#pragma optimize(&quot;a&quot;, on)*/
macro_line|#endif
multiline_comment|/*#define FULLSANITYCHECKS*/
macro_line|#include &quot;nedmalloc.h&quot;
macro_line|#if defined(WIN32)
macro_line|#include &lt;malloc.h&gt;
macro_line|#endif
DECL|macro|MSPACES
mdefine_line|#define MSPACES 1
DECL|macro|ONLY_MSPACES
mdefine_line|#define ONLY_MSPACES 1
macro_line|#ifndef USE_LOCKS
DECL|macro|USE_LOCKS
mdefine_line|#define USE_LOCKS 1
macro_line|#endif
DECL|macro|FOOTERS
mdefine_line|#define FOOTERS 1           /* Need to enable footers so frees lock the right mspace */
DECL|macro|DEBUG
macro_line|#undef DEBUG&t;&t;&t;&t;/* dlmalloc wants DEBUG either 0 or 1 */
macro_line|#ifdef _DEBUG
DECL|macro|DEBUG
mdefine_line|#define DEBUG 1
macro_line|#else
DECL|macro|DEBUG
mdefine_line|#define DEBUG 0
macro_line|#endif
macro_line|#ifdef NDEBUG               /* Disable assert checking on release builds */
DECL|macro|DEBUG
macro_line|#undef DEBUG
macro_line|#endif
multiline_comment|/* The default of 64Kb means we spend too much time kernel-side */
macro_line|#ifndef DEFAULT_GRANULARITY
DECL|macro|DEFAULT_GRANULARITY
mdefine_line|#define DEFAULT_GRANULARITY (1*1024*1024)
macro_line|#endif
multiline_comment|/*#define USE_SPIN_LOCKS 0*/
multiline_comment|/*#define FORCEINLINE*/
macro_line|#include &quot;malloc.c.h&quot;
macro_line|#ifdef NDEBUG               /* Disable assert checking on release builds */
DECL|macro|DEBUG
macro_line|#undef DEBUG
macro_line|#endif
multiline_comment|/* The maximum concurrent threads in a pool possible */
macro_line|#ifndef MAXTHREADSINPOOL
DECL|macro|MAXTHREADSINPOOL
mdefine_line|#define MAXTHREADSINPOOL 16
macro_line|#endif
multiline_comment|/* The maximum number of threadcaches which can be allocated */
macro_line|#ifndef THREADCACHEMAXCACHES
DECL|macro|THREADCACHEMAXCACHES
mdefine_line|#define THREADCACHEMAXCACHES 256
macro_line|#endif
multiline_comment|/* The maximum size to be allocated from the thread cache */
macro_line|#ifndef THREADCACHEMAX
DECL|macro|THREADCACHEMAX
mdefine_line|#define THREADCACHEMAX 8192
macro_line|#endif
macro_line|#if 0
multiline_comment|/* The number of cache entries for finer grained bins. This is (topbitpos(THREADCACHEMAX)-4)*2 */
mdefine_line|#define THREADCACHEMAXBINS ((13-4)*2)
macro_line|#else
multiline_comment|/* The number of cache entries. This is (topbitpos(THREADCACHEMAX)-4) */
DECL|macro|THREADCACHEMAXBINS
mdefine_line|#define THREADCACHEMAXBINS (13-4)
macro_line|#endif
multiline_comment|/* Point at which the free space in a thread cache is garbage collected */
macro_line|#ifndef THREADCACHEMAXFREESPACE
DECL|macro|THREADCACHEMAXFREESPACE
mdefine_line|#define THREADCACHEMAXFREESPACE (512*1024)
macro_line|#endif
macro_line|#ifdef WIN32
DECL|macro|TLSVAR
mdefine_line|#define TLSVAR&t;&t;&t;DWORD
DECL|macro|TLSALLOC
mdefine_line|#define TLSALLOC(k)&t;(*(k)=TlsAlloc(), TLS_OUT_OF_INDEXES==*(k))
DECL|macro|TLSFREE
mdefine_line|#define TLSFREE(k)&t;&t;(!TlsFree(k))
DECL|macro|TLSGET
mdefine_line|#define TLSGET(k)&t;&t;TlsGetValue(k)
DECL|macro|TLSSET
mdefine_line|#define TLSSET(k, a)&t;(!TlsSetValue(k, a))
macro_line|#ifdef DEBUG
DECL|function|ChkedTlsGetValue
r_static
id|LPVOID
id|ChkedTlsGetValue
c_func
(paren
id|DWORD
id|idx
)paren
(brace
id|LPVOID
id|ret
op_assign
id|TlsGetValue
c_func
(paren
id|idx
)paren
suffix:semicolon
m_assert
(paren
id|S_OK
op_eq
id|GetLastError
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|macro|TLSGET
macro_line|#undef TLSGET
DECL|macro|TLSGET
mdefine_line|#define TLSGET(k) ChkedTlsGetValue(k)
macro_line|#endif
macro_line|#else
DECL|macro|TLSVAR
mdefine_line|#define TLSVAR&t;&t;&t;pthread_key_t
DECL|macro|TLSALLOC
mdefine_line|#define TLSALLOC(k)&t;pthread_key_create(k, 0)
DECL|macro|TLSFREE
mdefine_line|#define TLSFREE(k)&t;&t;pthread_key_delete(k)
DECL|macro|TLSGET
mdefine_line|#define TLSGET(k)&t;&t;pthread_getspecific(k)
DECL|macro|TLSSET
mdefine_line|#define TLSSET(k, a)&t;pthread_setspecific(k, a)
macro_line|#endif
macro_line|#if 0
multiline_comment|/* Only enable if testing with valgrind. Causes misoperation */
mdefine_line|#define mspace_malloc(p, s) malloc(s)
mdefine_line|#define mspace_realloc(p, m, s) realloc(m, s)
mdefine_line|#define mspace_calloc(p, n, s) calloc(n, s)
mdefine_line|#define mspace_free(p, m) free(m)
macro_line|#endif
macro_line|#if defined(__cplusplus)
macro_line|#if !defined(NO_NED_NAMESPACE)
r_namespace
id|nedalloc
(brace
macro_line|#else
r_extern
l_string|&quot;C&quot;
(brace
macro_line|#endif
macro_line|#endif
r_int
id|nedblksize
c_func
(paren
r_void
op_star
id|mem
)paren
id|THROWSPEC
(brace
macro_line|#if 0
multiline_comment|/* Only enable if testing with valgrind. Causes misoperation */
r_return
id|THREADCACHEMAX
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
id|mem
)paren
(brace
id|mchunkptr
id|p
op_assign
id|mem2chunk
c_func
(paren
id|mem
)paren
suffix:semicolon
m_assert
(paren
id|cinuse
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
multiline_comment|/* If this fails, someone tried to free a block twice */
r_if
c_cond
(paren
id|cinuse
c_func
(paren
id|p
)paren
)paren
(brace
r_return
id|chunksize
c_func
(paren
id|p
)paren
op_minus
id|overhead_for
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
macro_line|#endif
)brace
r_void
id|nedsetvalue
c_func
(paren
r_void
op_star
id|v
)paren
id|THROWSPEC
(brace
id|nedpsetvalue
c_func
(paren
l_int|0
comma
id|v
)paren
suffix:semicolon
)brace
r_void
op_star
id|nedmalloc
c_func
(paren
r_int
id|size
)paren
id|THROWSPEC
(brace
r_return
id|nedpmalloc
c_func
(paren
l_int|0
comma
id|size
)paren
suffix:semicolon
)brace
r_void
op_star
id|nedcalloc
c_func
(paren
r_int
id|no
comma
r_int
id|size
)paren
id|THROWSPEC
(brace
r_return
id|nedpcalloc
c_func
(paren
l_int|0
comma
id|no
comma
id|size
)paren
suffix:semicolon
)brace
r_void
op_star
id|nedrealloc
c_func
(paren
r_void
op_star
id|mem
comma
r_int
id|size
)paren
id|THROWSPEC
(brace
r_return
id|nedprealloc
c_func
(paren
l_int|0
comma
id|mem
comma
id|size
)paren
suffix:semicolon
)brace
r_void
id|nedfree
c_func
(paren
r_void
op_star
id|mem
)paren
id|THROWSPEC
(brace
id|nedpfree
c_func
(paren
l_int|0
comma
id|mem
)paren
suffix:semicolon
)brace
r_void
op_star
id|nedmemalign
c_func
(paren
r_int
id|alignment
comma
r_int
id|bytes
)paren
id|THROWSPEC
(brace
r_return
id|nedpmemalign
c_func
(paren
l_int|0
comma
id|alignment
comma
id|bytes
)paren
suffix:semicolon
)brace
macro_line|#if !NO_MALLINFO
r_struct
id|mallinfo
id|nedmallinfo
c_func
(paren
r_void
)paren
id|THROWSPEC
(brace
r_return
id|nedpmallinfo
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
r_int
id|nedmallopt
c_func
(paren
r_int
id|parno
comma
r_int
id|value
)paren
id|THROWSPEC
(brace
r_return
id|nedpmallopt
c_func
(paren
l_int|0
comma
id|parno
comma
id|value
)paren
suffix:semicolon
)brace
r_int
id|nedmalloc_trim
c_func
(paren
r_int
id|pad
)paren
id|THROWSPEC
(brace
r_return
id|nedpmalloc_trim
c_func
(paren
l_int|0
comma
id|pad
)paren
suffix:semicolon
)brace
r_void
id|nedmalloc_stats
c_func
(paren
)paren
id|THROWSPEC
(brace
id|nedpmalloc_stats
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_int
id|nedmalloc_footprint
c_func
(paren
)paren
id|THROWSPEC
(brace
r_return
id|nedpmalloc_footprint
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_void
op_star
op_star
id|nedindependent_calloc
c_func
(paren
r_int
id|elemsno
comma
r_int
id|elemsize
comma
r_void
op_star
op_star
id|chunks
)paren
id|THROWSPEC
(brace
r_return
id|nedpindependent_calloc
c_func
(paren
l_int|0
comma
id|elemsno
comma
id|elemsize
comma
id|chunks
)paren
suffix:semicolon
)brace
r_void
op_star
op_star
id|nedindependent_comalloc
c_func
(paren
r_int
id|elems
comma
r_int
op_star
id|sizes
comma
r_void
op_star
op_star
id|chunks
)paren
id|THROWSPEC
(brace
r_return
id|nedpindependent_comalloc
c_func
(paren
l_int|0
comma
id|elems
comma
id|sizes
comma
id|chunks
)paren
suffix:semicolon
)brace
r_struct
id|threadcacheblk_t
suffix:semicolon
r_typedef
r_struct
id|threadcacheblk_t
id|threadcacheblk
suffix:semicolon
r_struct
id|threadcacheblk_t
(brace
multiline_comment|/* Keep less than 16 bytes on 32 bit systems and 32 bytes on 64 bit systems */
macro_line|#ifdef FULLSANITYCHECKS
r_int
r_int
id|magic
suffix:semicolon
macro_line|#endif
r_int
r_int
id|lastUsed
comma
id|size
suffix:semicolon
id|threadcacheblk
op_star
id|next
comma
op_star
id|prev
suffix:semicolon
)brace
suffix:semicolon
r_typedef
r_struct
id|threadcache_t
(brace
macro_line|#ifdef FULLSANITYCHECKS
r_int
r_int
id|magic1
suffix:semicolon
macro_line|#endif
r_int
id|mymspace
suffix:semicolon
multiline_comment|/* Last mspace entry this thread used */
r_int
id|threadid
suffix:semicolon
r_int
r_int
id|mallocs
comma
id|frees
comma
id|successes
suffix:semicolon
r_int
id|freeInCache
suffix:semicolon
multiline_comment|/* How much free space is stored in this cache */
id|threadcacheblk
op_star
id|bins
(braket
(paren
id|THREADCACHEMAXBINS
op_plus
l_int|1
)paren
op_star
l_int|2
)braket
suffix:semicolon
macro_line|#ifdef FULLSANITYCHECKS
r_int
r_int
id|magic2
suffix:semicolon
macro_line|#endif
)brace
id|threadcache
suffix:semicolon
r_struct
id|nedpool_t
(brace
id|MLOCK_T
id|mutex
suffix:semicolon
r_void
op_star
id|uservalue
suffix:semicolon
r_int
id|threads
suffix:semicolon
multiline_comment|/* Max entries in m to use */
id|threadcache
op_star
id|caches
(braket
id|THREADCACHEMAXCACHES
)braket
suffix:semicolon
id|TLSVAR
id|mycache
suffix:semicolon
multiline_comment|/* Thread cache for this thread. 0 for unset, negative for use mspace-1 directly, otherwise is cache-1 */
id|mstate
id|m
(braket
id|MAXTHREADSINPOOL
op_plus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* mspace entries for this pool */
)brace
suffix:semicolon
r_static
id|nedpool
id|syspool
suffix:semicolon
r_static
id|FORCEINLINE
r_int
r_int
id|size2binidx
c_func
(paren
r_int
id|_size
)paren
id|THROWSPEC
(brace
multiline_comment|/* 8=1000&t;16=10000&t;20=10100&t;24=11000&t;32=100000&t;48=110000&t;4096=1000000000000 */
r_int
r_int
id|topbit
comma
id|size
op_assign
(paren
r_int
r_int
)paren
(paren
id|_size
op_rshift
l_int|4
)paren
suffix:semicolon
multiline_comment|/* 16=1&t;&t;20=1&t;24=1&t;32=10&t;48=11&t;64=100&t;96=110&t;128=1000&t;4096=100000000 */
macro_line|#if defined(__GNUC__)
id|topbit
op_assign
r_sizeof
(paren
id|size
)paren
op_star
id|__CHAR_BIT__
l_int|1
id|__builtin_clz
c_func
(paren
id|size
)paren
suffix:semicolon
macro_line|#elif defined(_MSC_VER) &amp;&amp; _MSC_VER&gt;=1300
(brace
r_int
r_int
id|bsrTopBit
suffix:semicolon
id|_BitScanReverse
c_func
(paren
op_amp
id|bsrTopBit
comma
id|size
)paren
suffix:semicolon
id|topbit
op_assign
id|bsrTopBit
suffix:semicolon
)brace
macro_line|#else
macro_line|#if 0
r_union
(brace
r_int
id|asInt
(braket
l_int|2
)braket
suffix:semicolon
r_float
id|asDouble
suffix:semicolon
)brace
suffix:semicolon
r_int
id|n
suffix:semicolon
id|asDouble
op_assign
(paren
r_float
)paren
id|size
op_plus
l_float|0.5
suffix:semicolon
id|topbit
op_assign
(paren
id|asInt
(braket
op_logical_neg
id|FOX_BIGENDIAN
)braket
op_rshift
l_int|20
)paren
l_int|1023
suffix:semicolon
macro_line|#else
(brace
r_int
r_int
id|x
op_assign
id|size
suffix:semicolon
id|x
op_assign
id|x
op_or
(paren
id|x
op_rshift
l_int|1
)paren
suffix:semicolon
id|x
op_assign
id|x
op_or
(paren
id|x
op_rshift
l_int|2
)paren
suffix:semicolon
id|x
op_assign
id|x
op_or
(paren
id|x
op_rshift
l_int|4
)paren
suffix:semicolon
id|x
op_assign
id|x
op_or
(paren
id|x
op_rshift
l_int|8
)paren
suffix:semicolon
id|x
op_assign
id|x
op_or
(paren
id|x
op_rshift
l_int|16
)paren
suffix:semicolon
id|x
op_assign
op_complement
id|x
suffix:semicolon
id|x
op_assign
id|x
(paren
(paren
id|x
op_rshift
l_int|1
)paren
op_amp
l_int|0x55555555
)paren
suffix:semicolon
id|x
op_assign
(paren
id|x
op_amp
l_int|0x33333333
)paren
op_plus
(paren
(paren
id|x
op_rshift
l_int|2
)paren
op_amp
l_int|0x33333333
)paren
suffix:semicolon
id|x
op_assign
(paren
id|x
op_plus
(paren
id|x
op_rshift
l_int|4
)paren
)paren
op_amp
l_int|0x0F0F0F0F
suffix:semicolon
id|x
op_assign
id|x
op_plus
(paren
id|x
op_lshift
l_int|8
)paren
suffix:semicolon
id|x
op_assign
id|x
op_plus
(paren
id|x
op_lshift
l_int|16
)paren
suffix:semicolon
id|topbit
op_assign
l_int|31
(paren
id|x
op_rshift
l_int|24
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#endif
r_return
id|topbit
suffix:semicolon
)brace
macro_line|#ifdef FULLSANITYCHECKS
r_static
r_void
id|tcsanitycheck
c_func
(paren
id|threadcacheblk
op_star
op_star
id|ptr
)paren
id|THROWSPEC
(brace
m_assert
(paren
(paren
id|ptr
(braket
l_int|0
)braket
op_logical_and
id|ptr
(braket
l_int|1
)braket
)paren
op_logical_or
(paren
op_logical_neg
id|ptr
(braket
l_int|0
)braket
op_logical_and
op_logical_neg
id|ptr
(braket
l_int|1
)braket
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ptr
(braket
l_int|0
)braket
op_logical_and
id|ptr
(braket
l_int|1
)braket
)paren
(brace
m_assert
(paren
id|nedblksize
c_func
(paren
id|ptr
(braket
l_int|0
)braket
)paren
op_ge
r_sizeof
(paren
id|threadcacheblk
)paren
)paren
suffix:semicolon
m_assert
(paren
id|nedblksize
c_func
(paren
id|ptr
(braket
l_int|1
)braket
)paren
op_ge
r_sizeof
(paren
id|threadcacheblk
)paren
)paren
suffix:semicolon
m_assert
(paren
op_star
(paren
r_int
r_int
op_star
)paren
l_string|&quot;NEDN&quot;
op_eq
id|ptr
(braket
l_int|0
)braket
op_member_access_from_pointer
id|magic
)paren
suffix:semicolon
m_assert
(paren
op_star
(paren
r_int
r_int
op_star
)paren
l_string|&quot;NEDN&quot;
op_eq
id|ptr
(braket
l_int|1
)braket
op_member_access_from_pointer
id|magic
)paren
suffix:semicolon
m_assert
(paren
op_logical_neg
id|ptr
(braket
l_int|0
)braket
op_member_access_from_pointer
id|prev
)paren
suffix:semicolon
m_assert
(paren
op_logical_neg
id|ptr
(braket
l_int|1
)braket
op_member_access_from_pointer
id|next
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ptr
(braket
l_int|0
)braket
op_eq
id|ptr
(braket
l_int|1
)braket
)paren
(brace
m_assert
(paren
op_logical_neg
id|ptr
(braket
l_int|0
)braket
op_member_access_from_pointer
id|next
)paren
suffix:semicolon
m_assert
(paren
op_logical_neg
id|ptr
(braket
l_int|1
)braket
op_member_access_from_pointer
id|prev
)paren
suffix:semicolon
)brace
)brace
)brace
r_static
r_void
id|tcfullsanitycheck
c_func
(paren
id|threadcache
op_star
id|tc
)paren
id|THROWSPEC
(brace
id|threadcacheblk
op_star
op_star
id|tcbptr
op_assign
id|tc-&gt;bins
suffix:semicolon
r_int
id|n
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
op_le
id|THREADCACHEMAXBINS
suffix:semicolon
id|n
op_increment
comma
id|tcbptr
op_add_assign
l_int|2
)paren
(brace
id|threadcacheblk
op_star
id|b
comma
op_star
id|ob
op_assign
l_int|0
suffix:semicolon
id|tcsanitycheck
c_func
(paren
id|tcbptr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|b
op_assign
id|tcbptr
(braket
l_int|0
)braket
suffix:semicolon
id|b
suffix:semicolon
id|ob
op_assign
id|b
comma
id|b
op_assign
id|b-&gt;next
)paren
(brace
m_assert
(paren
op_star
(paren
r_int
r_int
op_star
)paren
l_string|&quot;NEDN&quot;
op_eq
id|b-&gt;magic
)paren
suffix:semicolon
m_assert
(paren
op_logical_neg
id|ob
op_logical_or
id|ob-&gt;next
op_eq
id|b
)paren
suffix:semicolon
m_assert
(paren
op_logical_neg
id|ob
op_logical_or
id|b-&gt;prev
op_eq
id|ob
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
r_static
id|NOINLINE
r_void
id|RemoveCacheEntries
c_func
(paren
id|nedpool
op_star
id|p
comma
id|threadcache
op_star
id|tc
comma
r_int
r_int
id|age
)paren
id|THROWSPEC
(brace
macro_line|#ifdef FULLSANITYCHECKS
id|tcfullsanitycheck
c_func
(paren
id|tc
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|tc-&gt;freeInCache
)paren
(brace
id|threadcacheblk
op_star
op_star
id|tcbptr
op_assign
id|tc-&gt;bins
suffix:semicolon
r_int
id|n
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
op_le
id|THREADCACHEMAXBINS
suffix:semicolon
id|n
op_increment
comma
id|tcbptr
op_add_assign
l_int|2
)paren
(brace
id|threadcacheblk
op_star
op_star
id|tcb
op_assign
id|tcbptr
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* come from oldest end of list */
multiline_comment|/*tcsanitycheck(tcbptr);*/
r_for
c_loop
(paren
suffix:semicolon
op_star
id|tcb
op_logical_and
id|tc-&gt;frees
op_minus
(paren
op_star
id|tcb
)paren
op_member_access_from_pointer
id|lastUsed
op_ge
id|age
suffix:semicolon
)paren
(brace
id|threadcacheblk
op_star
id|f
op_assign
op_star
id|tcb
suffix:semicolon
r_int
id|blksize
op_assign
id|f-&gt;size
suffix:semicolon
multiline_comment|/*nedblksize(f);*/
m_assert
(paren
id|blksize
op_le
id|nedblksize
c_func
(paren
id|f
)paren
)paren
suffix:semicolon
m_assert
(paren
id|blksize
)paren
suffix:semicolon
macro_line|#ifdef FULLSANITYCHECKS
m_assert
(paren
op_star
(paren
r_int
r_int
op_star
)paren
l_string|&quot;NEDN&quot;
op_eq
(paren
op_star
id|tcb
)paren
op_member_access_from_pointer
id|magic
)paren
suffix:semicolon
macro_line|#endif
op_star
id|tcb
op_assign
(paren
op_star
id|tcb
)paren
op_member_access_from_pointer
id|prev
suffix:semicolon
r_if
c_cond
(paren
op_star
id|tcb
)paren
(brace
(paren
op_star
id|tcb
)paren
op_member_access_from_pointer
id|next
op_assign
l_int|0
suffix:semicolon
)brace
r_else
op_star
id|tcbptr
op_assign
l_int|0
suffix:semicolon
id|tc-&gt;freeInCache
op_sub_assign
id|blksize
suffix:semicolon
m_assert
(paren
(paren
r_int
)paren
id|tc-&gt;freeInCache
op_ge
l_int|0
)paren
suffix:semicolon
id|mspace_free
c_func
(paren
l_int|0
comma
id|f
)paren
suffix:semicolon
multiline_comment|/*tcsanitycheck(tcbptr);*/
)brace
)brace
)brace
macro_line|#ifdef FULLSANITYCHECKS
id|tcfullsanitycheck
c_func
(paren
id|tc
)paren
suffix:semicolon
macro_line|#endif
)brace
r_static
r_void
id|DestroyCaches
c_func
(paren
id|nedpool
op_star
id|p
)paren
id|THROWSPEC
(brace
r_if
c_cond
(paren
id|p-&gt;caches
)paren
(brace
id|threadcache
op_star
id|tc
suffix:semicolon
r_int
id|n
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|THREADCACHEMAXCACHES
suffix:semicolon
id|n
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|tc
op_assign
id|p-&gt;caches
(braket
id|n
)braket
)paren
)paren
(brace
id|tc-&gt;frees
op_increment
suffix:semicolon
id|RemoveCacheEntries
c_func
(paren
id|p
comma
id|tc
comma
l_int|0
)paren
suffix:semicolon
m_assert
(paren
op_logical_neg
id|tc-&gt;freeInCache
)paren
suffix:semicolon
id|tc-&gt;mymspace
op_assign
l_int|1
suffix:semicolon
id|tc-&gt;threadid
op_assign
l_int|0
suffix:semicolon
id|mspace_free
c_func
(paren
l_int|0
comma
id|tc
)paren
suffix:semicolon
id|p-&gt;caches
(braket
id|n
)braket
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
)brace
r_static
id|NOINLINE
id|threadcache
op_star
id|AllocCache
c_func
(paren
id|nedpool
op_star
id|p
)paren
id|THROWSPEC
(brace
id|threadcache
op_star
id|tc
op_assign
l_int|0
suffix:semicolon
r_int
id|n
comma
id|end
suffix:semicolon
id|ACQUIRE_LOCK
c_func
(paren
op_amp
id|p-&gt;mutex
)paren
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|THREADCACHEMAXCACHES
op_logical_and
id|p-&gt;caches
(braket
id|n
)braket
suffix:semicolon
id|n
op_increment
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|THREADCACHEMAXCACHES
op_eq
id|n
)paren
(brace
multiline_comment|/* List exhausted, so disable for this thread */
id|RELEASE_LOCK
c_func
(paren
op_amp
id|p-&gt;mutex
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|tc
op_assign
id|p-&gt;caches
(braket
id|n
)braket
op_assign
(paren
id|threadcache
op_star
)paren
id|mspace_calloc
c_func
(paren
id|p-&gt;m
(braket
l_int|0
)braket
comma
l_int|1
comma
r_sizeof
(paren
id|threadcache
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tc
)paren
(brace
id|RELEASE_LOCK
c_func
(paren
op_amp
id|p-&gt;mutex
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef FULLSANITYCHECKS
id|tc-&gt;magic1
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
l_string|&quot;NEDMALC1&quot;
suffix:semicolon
id|tc-&gt;magic2
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
l_string|&quot;NEDMALC2&quot;
suffix:semicolon
macro_line|#endif
id|tc-&gt;threadid
op_assign
(paren
r_int
)paren
(paren
r_int
)paren
id|CURRENT_THREAD
suffix:semicolon
r_for
c_loop
(paren
id|end
op_assign
l_int|0
suffix:semicolon
id|p-&gt;m
(braket
id|end
)braket
suffix:semicolon
id|end
op_increment
)paren
(brace
suffix:semicolon
)brace
id|tc-&gt;mymspace
op_assign
id|tc-&gt;threadid
op_mod
id|end
suffix:semicolon
id|RELEASE_LOCK
c_func
(paren
op_amp
id|p-&gt;mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TLSSET
c_func
(paren
id|p-&gt;mycache
comma
(paren
r_void
op_star
)paren
(paren
r_int
)paren
(paren
id|n
op_plus
l_int|1
)paren
)paren
)paren
(brace
m_abort
(paren
)paren
suffix:semicolon
)brace
r_return
id|tc
suffix:semicolon
)brace
r_static
r_void
op_star
id|threadcache_malloc
c_func
(paren
id|nedpool
op_star
id|p
comma
id|threadcache
op_star
id|tc
comma
r_int
op_star
id|size
)paren
id|THROWSPEC
(brace
r_void
op_star
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|bestsize
suffix:semicolon
r_int
r_int
id|idx
op_assign
id|size2binidx
c_func
(paren
op_star
id|size
)paren
suffix:semicolon
r_int
id|blksize
op_assign
l_int|0
suffix:semicolon
id|threadcacheblk
op_star
id|blk
comma
op_star
op_star
id|binsptr
suffix:semicolon
macro_line|#ifdef FULLSANITYCHECKS
id|tcfullsanitycheck
c_func
(paren
id|tc
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Calculate best fit bin size */
id|bestsize
op_assign
l_int|1
op_lshift
(paren
id|idx
op_plus
l_int|4
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* Finer grained bin fit */
id|idx
op_lshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_star
id|size
OG
id|bestsize
)paren
(brace
id|idx
op_increment
suffix:semicolon
id|bestsize
op_add_assign
id|bestsize
op_rshift
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|size
OG
id|bestsize
)paren
(brace
id|idx
op_increment
suffix:semicolon
id|bestsize
op_assign
l_int|1
op_lshift
(paren
l_int|4
op_plus
(paren
id|idx
op_rshift
l_int|1
)paren
)paren
suffix:semicolon
)brace
macro_line|#else
r_if
c_cond
(paren
op_star
id|size
OG
id|bestsize
)paren
(brace
id|idx
op_increment
suffix:semicolon
id|bestsize
op_lshift_assign
l_int|1
suffix:semicolon
)brace
macro_line|#endif
m_assert
(paren
id|bestsize
op_ge
op_star
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|size
OL
id|bestsize
)paren
(brace
op_star
id|size
op_assign
id|bestsize
suffix:semicolon
)brace
m_assert
(paren
op_star
id|size
op_le
id|THREADCACHEMAX
)paren
suffix:semicolon
m_assert
(paren
id|idx
op_le
id|THREADCACHEMAXBINS
)paren
suffix:semicolon
id|binsptr
op_assign
op_amp
id|tc-&gt;bins
(braket
id|idx
op_star
l_int|2
)braket
suffix:semicolon
multiline_comment|/* Try to match close, but move up a bin if necessary */
id|blk
op_assign
op_star
id|binsptr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|blk
op_logical_or
id|blk-&gt;size
OL
op_star
id|size
)paren
(brace
multiline_comment|/* Bump it up a bin */
r_if
c_cond
(paren
id|idx
OL
id|THREADCACHEMAXBINS
)paren
(brace
id|idx
op_increment
suffix:semicolon
id|binsptr
op_add_assign
l_int|2
suffix:semicolon
id|blk
op_assign
op_star
id|binsptr
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|blk
)paren
(brace
id|blksize
op_assign
id|blk-&gt;size
suffix:semicolon
multiline_comment|/*nedblksize(blk);*/
m_assert
(paren
id|nedblksize
c_func
(paren
id|blk
)paren
op_ge
id|blksize
)paren
suffix:semicolon
m_assert
(paren
id|blksize
op_ge
op_star
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blk-&gt;next
)paren
(brace
id|blk-&gt;next-&gt;prev
op_assign
l_int|0
suffix:semicolon
)brace
op_star
id|binsptr
op_assign
id|blk-&gt;next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|binsptr
)paren
(brace
id|binsptr
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef FULLSANITYCHECKS
id|blk-&gt;magic
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
m_assert
(paren
id|binsptr
(braket
l_int|0
)braket
op_ne
id|blk
op_logical_and
id|binsptr
(braket
l_int|1
)braket
op_ne
id|blk
)paren
suffix:semicolon
m_assert
(paren
id|nedblksize
c_func
(paren
id|blk
)paren
op_ge
r_sizeof
(paren
id|threadcacheblk
)paren
op_logical_and
id|nedblksize
c_func
(paren
id|blk
)paren
op_le
id|THREADCACHEMAX
op_plus
id|CHUNK_OVERHEAD
)paren
suffix:semicolon
multiline_comment|/*printf(&quot;malloc: %p, %p, %p, %lu&bslash;n&quot;, p, tc, blk, (long) size);*/
id|ret
op_assign
(paren
r_void
op_star
)paren
id|blk
suffix:semicolon
)brace
op_increment
id|tc-&gt;mallocs
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
m_assert
(paren
id|blksize
op_ge
op_star
id|size
)paren
suffix:semicolon
op_increment
id|tc-&gt;successes
suffix:semicolon
id|tc-&gt;freeInCache
op_sub_assign
id|blksize
suffix:semicolon
m_assert
(paren
(paren
r_int
)paren
id|tc-&gt;freeInCache
op_ge
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#if defined(DEBUG) &amp;&amp; 0
r_if
c_cond
(paren
op_logical_neg
(paren
id|tc-&gt;mallocs
op_amp
l_int|0xfff
)paren
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;*** threadcache=%u, mallocs=%u (%f), free=%u (%f), freeInCache=%u&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|tc-&gt;threadid
comma
id|tc-&gt;mallocs
comma
(paren
r_float
)paren
id|tc-&gt;successes
op_div
id|tc-&gt;mallocs
comma
id|tc-&gt;frees
comma
(paren
r_float
)paren
id|tc-&gt;successes
op_div
id|tc-&gt;frees
comma
(paren
r_int
r_int
)paren
id|tc-&gt;freeInCache
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef FULLSANITYCHECKS
id|tcfullsanitycheck
c_func
(paren
id|tc
)paren
suffix:semicolon
macro_line|#endif
r_return
id|ret
suffix:semicolon
)brace
r_static
id|NOINLINE
r_void
id|ReleaseFreeInCache
c_func
(paren
id|nedpool
op_star
id|p
comma
id|threadcache
op_star
id|tc
comma
r_int
id|mymspace
)paren
id|THROWSPEC
(brace
r_int
r_int
id|age
op_assign
id|THREADCACHEMAXFREESPACE
op_div
l_int|8192
suffix:semicolon
multiline_comment|/*ACQUIRE_LOCK(&amp;p-&gt;m[mymspace]-&gt;mutex);*/
r_while
c_loop
(paren
id|age
op_logical_and
id|tc-&gt;freeInCache
op_ge
id|THREADCACHEMAXFREESPACE
)paren
(brace
id|RemoveCacheEntries
c_func
(paren
id|p
comma
id|tc
comma
id|age
)paren
suffix:semicolon
multiline_comment|/*printf(&quot;*** Removing cache entries older than %u (%u)&bslash;n&quot;, age, (unsigned int) tc-&gt;freeInCache);*/
id|age
op_rshift_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*RELEASE_LOCK(&amp;p-&gt;m[mymspace]-&gt;mutex);*/
)brace
r_static
r_void
id|threadcache_free
c_func
(paren
id|nedpool
op_star
id|p
comma
id|threadcache
op_star
id|tc
comma
r_int
id|mymspace
comma
r_void
op_star
id|mem
comma
r_int
id|size
)paren
id|THROWSPEC
(brace
r_int
r_int
id|bestsize
suffix:semicolon
r_int
r_int
id|idx
op_assign
id|size2binidx
c_func
(paren
id|size
)paren
suffix:semicolon
id|threadcacheblk
op_star
op_star
id|binsptr
comma
op_star
id|tck
op_assign
(paren
id|threadcacheblk
op_star
)paren
id|mem
suffix:semicolon
m_assert
(paren
id|size
op_ge
r_sizeof
(paren
id|threadcacheblk
)paren
op_logical_and
id|size
op_le
id|THREADCACHEMAX
op_plus
id|CHUNK_OVERHEAD
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
(brace
multiline_comment|/* Make sure this is a valid memory block */
id|mchunkptr
id|p
op_assign
id|mem2chunk
c_func
(paren
id|mem
)paren
suffix:semicolon
id|mstate
id|fm
op_assign
id|get_mstate_for
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ok_magic
c_func
(paren
id|fm
)paren
)paren
(brace
id|USAGE_ERROR_ACTION
c_func
(paren
id|fm
comma
id|p
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
macro_line|#endif
macro_line|#ifdef FULLSANITYCHECKS
id|tcfullsanitycheck
c_func
(paren
id|tc
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Calculate best fit bin size */
id|bestsize
op_assign
l_int|1
op_lshift
(paren
id|idx
op_plus
l_int|4
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* Finer grained bin fit */
id|idx
op_lshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|bestsize
)paren
(brace
r_int
r_int
id|biggerbestsize
op_assign
id|bestsize
op_plus
id|bestsize
op_lshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|size
op_ge
id|biggerbestsize
)paren
(brace
id|idx
op_increment
suffix:semicolon
id|bestsize
op_assign
id|biggerbestsize
suffix:semicolon
)brace
)brace
macro_line|#endif
r_if
c_cond
(paren
id|bestsize
op_ne
id|size
)paren
(brace
multiline_comment|/* dlmalloc can round up, so we round down to preserve indexing */
id|size
op_assign
id|bestsize
suffix:semicolon
)brace
id|binsptr
op_assign
op_amp
id|tc-&gt;bins
(braket
id|idx
op_star
l_int|2
)braket
suffix:semicolon
m_assert
(paren
id|idx
op_le
id|THREADCACHEMAXBINS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tck
op_eq
op_star
id|binsptr
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Attempt to free already freed memory block %p - aborting!&bslash;n&quot;
comma
id|tck
)paren
suffix:semicolon
m_abort
(paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef FULLSANITYCHECKS
id|tck-&gt;magic
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
l_string|&quot;NEDN&quot;
suffix:semicolon
macro_line|#endif
id|tck-&gt;lastUsed
op_assign
op_increment
id|tc-&gt;frees
suffix:semicolon
id|tck-&gt;size
op_assign
(paren
r_int
r_int
)paren
id|size
suffix:semicolon
id|tck-&gt;next
op_assign
op_star
id|binsptr
suffix:semicolon
id|tck-&gt;prev
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tck-&gt;next
)paren
(brace
id|tck-&gt;next-&gt;prev
op_assign
id|tck
suffix:semicolon
)brace
r_else
id|binsptr
(braket
l_int|1
)braket
op_assign
id|tck
suffix:semicolon
m_assert
(paren
op_logical_neg
op_star
id|binsptr
op_logical_or
(paren
op_star
id|binsptr
)paren
op_member_access_from_pointer
id|size
op_eq
id|tck-&gt;size
)paren
suffix:semicolon
op_star
id|binsptr
op_assign
id|tck
suffix:semicolon
m_assert
(paren
id|tck
op_eq
id|tc-&gt;bins
(braket
id|idx
op_star
l_int|2
)braket
)paren
suffix:semicolon
m_assert
(paren
id|tc-&gt;bins
(braket
id|idx
op_star
l_int|2
op_plus
l_int|1
)braket
op_eq
id|tck
op_logical_or
id|binsptr
(braket
l_int|0
)braket
op_member_access_from_pointer
id|next-&gt;prev
op_eq
id|tck
)paren
suffix:semicolon
multiline_comment|/*printf(&quot;free: %p, %p, %p, %lu&bslash;n&quot;, p, tc, mem, (long) size);*/
id|tc-&gt;freeInCache
op_add_assign
id|size
suffix:semicolon
macro_line|#ifdef FULLSANITYCHECKS
id|tcfullsanitycheck
c_func
(paren
id|tc
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if 1
r_if
c_cond
(paren
id|tc-&gt;freeInCache
op_ge
id|THREADCACHEMAXFREESPACE
)paren
(brace
id|ReleaseFreeInCache
c_func
(paren
id|p
comma
id|tc
comma
id|mymspace
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
r_static
id|NOINLINE
r_int
id|InitPool
c_func
(paren
id|nedpool
op_star
id|p
comma
r_int
id|capacity
comma
r_int
id|threads
)paren
id|THROWSPEC
(brace
multiline_comment|/* threads is -1 for system pool */
id|ensure_initialization
c_func
(paren
)paren
suffix:semicolon
id|ACQUIRE_MALLOC_GLOBAL_LOCK
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;threads
)paren
(brace
r_goto
id|done
suffix:semicolon
)brace
r_if
c_cond
(paren
id|INITIAL_LOCK
c_func
(paren
op_amp
id|p-&gt;mutex
)paren
)paren
(brace
r_goto
id|err
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TLSALLOC
c_func
(paren
op_amp
id|p-&gt;mycache
)paren
)paren
(brace
r_goto
id|err
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;m
(braket
l_int|0
)braket
op_assign
(paren
id|mstate
)paren
id|create_mspace
c_func
(paren
id|capacity
comma
l_int|1
)paren
)paren
)paren
(brace
r_goto
id|err
suffix:semicolon
)brace
id|p-&gt;m
(braket
l_int|0
)braket
op_member_access_from_pointer
id|extp
op_assign
id|p
suffix:semicolon
id|p-&gt;threads
op_assign
(paren
id|threads
id|MAXTHREADSINPOOL
)paren
ques
c_cond
id|MAXTHREADSINPOOL
suffix:colon
id|threads
suffix:semicolon
id|done
suffix:colon
id|RELEASE_MALLOC_GLOBAL_LOCK
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
id|err
suffix:colon
r_if
c_cond
(paren
id|threads
OL
l_int|0
)paren
(brace
m_abort
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* If you can&squot;t allocate for system pool, we&squot;re screwed */
id|DestroyCaches
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;m
(braket
l_int|0
)braket
)paren
(brace
id|destroy_mspace
c_func
(paren
id|p-&gt;m
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|p-&gt;m
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;mycache
)paren
(brace
r_if
c_cond
(paren
id|TLSFREE
c_func
(paren
id|p-&gt;mycache
)paren
)paren
(brace
m_abort
(paren
)paren
suffix:semicolon
)brace
id|p-&gt;mycache
op_assign
l_int|0
suffix:semicolon
)brace
id|RELEASE_MALLOC_GLOBAL_LOCK
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
id|NOINLINE
id|mstate
id|FindMSpace
c_func
(paren
id|nedpool
op_star
id|p
comma
id|threadcache
op_star
id|tc
comma
r_int
op_star
id|lastUsed
comma
r_int
id|size
)paren
id|THROWSPEC
(brace
multiline_comment|/* Gets called when thread&squot;s last used mspace is in use. The strategy&n;&t;is to run through the list of all available mspaces looking for an&n;&t;unlocked one and if we fail, we create a new one so long as we don&squot;t&n;&t;exceed p-&gt;threads */
r_int
id|n
comma
id|end
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
id|end
op_assign
op_star
id|lastUsed
op_plus
l_int|1
suffix:semicolon
id|p-&gt;m
(braket
id|n
)braket
suffix:semicolon
id|end
op_assign
op_increment
id|n
)paren
(brace
r_if
c_cond
(paren
id|TRY_LOCK
c_func
(paren
op_amp
id|p-&gt;m
(braket
id|n
)braket
op_member_access_from_pointer
id|mutex
)paren
)paren
(brace
r_goto
id|found
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
op_star
id|lastUsed
op_logical_and
id|p-&gt;m
(braket
id|n
)braket
suffix:semicolon
id|n
op_increment
)paren
(brace
r_if
c_cond
(paren
id|TRY_LOCK
c_func
(paren
op_amp
id|p-&gt;m
(braket
id|n
)braket
op_member_access_from_pointer
id|mutex
)paren
)paren
(brace
r_goto
id|found
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|end
OL
id|p-&gt;threads
)paren
(brace
id|mstate
id|temp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|temp
op_assign
(paren
id|mstate
)paren
id|create_mspace
c_func
(paren
id|size
comma
l_int|1
)paren
)paren
)paren
(brace
r_goto
id|badexit
suffix:semicolon
)brace
multiline_comment|/* Now we&squot;re ready to modify the lists, we lock */
id|ACQUIRE_LOCK
c_func
(paren
op_amp
id|p-&gt;mutex
)paren
suffix:semicolon
r_while
c_loop
(paren
id|p-&gt;m
(braket
id|end
)braket
op_logical_and
id|end
OL
id|p-&gt;threads
)paren
(brace
id|end
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|end
op_ge
id|p-&gt;threads
)paren
(brace
multiline_comment|/* Drat, must destroy it now */
id|RELEASE_LOCK
c_func
(paren
op_amp
id|p-&gt;mutex
)paren
suffix:semicolon
id|destroy_mspace
c_func
(paren
(paren
id|mspace
)paren
id|temp
)paren
suffix:semicolon
r_goto
id|badexit
suffix:semicolon
)brace
multiline_comment|/* We really want to make sure this goes into memory now but we&n;&t;&t;have to be careful of breaking aliasing rules, so write it twice */
op_star
(paren
(paren
r_volatile
r_struct
id|malloc_state
op_star
op_star
)paren
op_amp
id|p-&gt;m
(braket
id|end
)braket
)paren
op_assign
id|p-&gt;m
(braket
id|end
)braket
op_assign
id|temp
suffix:semicolon
id|ACQUIRE_LOCK
c_func
(paren
op_amp
id|p-&gt;m
(braket
id|end
)braket
op_member_access_from_pointer
id|mutex
)paren
suffix:semicolon
multiline_comment|/*printf(&quot;Created mspace idx %d&bslash;n&quot;, end);*/
id|RELEASE_LOCK
c_func
(paren
op_amp
id|p-&gt;mutex
)paren
suffix:semicolon
id|n
op_assign
id|end
suffix:semicolon
r_goto
id|found
suffix:semicolon
)brace
multiline_comment|/* Let it lock on the last one it used */
id|badexit
suffix:colon
id|ACQUIRE_LOCK
c_func
(paren
op_amp
id|p-&gt;m
(braket
op_star
id|lastUsed
)braket
op_member_access_from_pointer
id|mutex
)paren
suffix:semicolon
r_return
id|p-&gt;m
(braket
op_star
id|lastUsed
)braket
suffix:semicolon
id|found
suffix:colon
op_star
id|lastUsed
op_assign
id|n
suffix:semicolon
r_if
c_cond
(paren
id|tc
)paren
(brace
id|tc-&gt;mymspace
op_assign
id|n
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|TLSSET
c_func
(paren
id|p-&gt;mycache
comma
(paren
r_void
op_star
)paren
(paren
r_int
)paren
(paren
(paren
id|n
op_plus
l_int|1
)paren
)paren
)paren
)paren
(brace
m_abort
(paren
)paren
suffix:semicolon
)brace
)brace
r_return
id|p-&gt;m
(braket
id|n
)braket
suffix:semicolon
)brace
id|nedpool
op_star
id|nedcreatepool
c_func
(paren
r_int
id|capacity
comma
r_int
id|threads
)paren
id|THROWSPEC
(brace
id|nedpool
op_star
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ret
op_assign
(paren
id|nedpool
op_star
)paren
id|nedpcalloc
c_func
(paren
l_int|0
comma
l_int|1
comma
r_sizeof
(paren
id|nedpool
)paren
)paren
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|InitPool
c_func
(paren
id|ret
comma
id|capacity
comma
id|threads
)paren
)paren
(brace
id|nedpfree
c_func
(paren
l_int|0
comma
id|ret
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
r_void
id|neddestroypool
c_func
(paren
id|nedpool
op_star
id|p
)paren
id|THROWSPEC
(brace
r_int
id|n
suffix:semicolon
id|ACQUIRE_LOCK
c_func
(paren
op_amp
id|p-&gt;mutex
)paren
suffix:semicolon
id|DestroyCaches
c_func
(paren
id|p
)paren
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|p-&gt;m
(braket
id|n
)braket
suffix:semicolon
id|n
op_increment
)paren
(brace
id|destroy_mspace
c_func
(paren
id|p-&gt;m
(braket
id|n
)braket
)paren
suffix:semicolon
id|p-&gt;m
(braket
id|n
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|RELEASE_LOCK
c_func
(paren
op_amp
id|p-&gt;mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TLSFREE
c_func
(paren
id|p-&gt;mycache
)paren
)paren
(brace
m_abort
(paren
)paren
suffix:semicolon
)brace
id|nedpfree
c_func
(paren
l_int|0
comma
id|p
)paren
suffix:semicolon
)brace
r_void
id|nedpsetvalue
c_func
(paren
id|nedpool
op_star
id|p
comma
r_void
op_star
id|v
)paren
id|THROWSPEC
(brace
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
(brace
id|p
op_assign
op_amp
id|syspool
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|syspool.threads
)paren
(brace
id|InitPool
c_func
(paren
op_amp
id|syspool
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
id|p-&gt;uservalue
op_assign
id|v
suffix:semicolon
)brace
r_void
op_star
id|nedgetvalue
c_func
(paren
id|nedpool
op_star
op_star
id|p
comma
r_void
op_star
id|mem
)paren
id|THROWSPEC
(brace
id|nedpool
op_star
id|np
op_assign
l_int|0
suffix:semicolon
id|mchunkptr
id|mcp
op_assign
id|mem2chunk
c_func
(paren
id|mem
)paren
suffix:semicolon
id|mstate
id|fm
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|is_aligned
c_func
(paren
id|chunk2mem
c_func
(paren
id|mcp
)paren
)paren
)paren
op_logical_and
id|mcp-&gt;head
op_ne
id|FENCEPOST_HEAD
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|cinuse
c_func
(paren
id|mcp
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|next_pinuse
c_func
(paren
id|mcp
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|is_mmapped
c_func
(paren
id|mcp
)paren
op_logical_and
op_logical_neg
id|pinuse
c_func
(paren
id|mcp
)paren
)paren
(brace
r_if
c_cond
(paren
id|next_chunk
c_func
(paren
id|prev_chunk
c_func
(paren
id|mcp
)paren
)paren
op_ne
id|mcp
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|fm
op_assign
id|get_mstate_for
c_func
(paren
id|mcp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ok_magic
c_func
(paren
id|fm
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ok_address
c_func
(paren
id|fm
comma
id|mcp
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|fm-&gt;extp
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|np
op_assign
(paren
id|nedpool
op_star
)paren
id|fm-&gt;extp
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
(brace
op_star
id|p
op_assign
id|np
suffix:semicolon
)brace
r_return
id|np-&gt;uservalue
suffix:semicolon
)brace
r_void
id|neddisablethreadcache
c_func
(paren
id|nedpool
op_star
id|p
)paren
id|THROWSPEC
(brace
r_int
id|mycache
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
(brace
id|p
op_assign
op_amp
id|syspool
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|syspool.threads
)paren
(brace
id|InitPool
c_func
(paren
op_amp
id|syspool
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
id|mycache
op_assign
(paren
r_int
)paren
(paren
r_int
)paren
id|TLSGET
c_func
(paren
id|p-&gt;mycache
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mycache
)paren
(brace
multiline_comment|/* Set to mspace 0 */
r_if
c_cond
(paren
id|TLSSET
c_func
(paren
id|p-&gt;mycache
comma
(paren
r_void
op_star
)paren
op_minus
l_int|1
)paren
)paren
(brace
m_abort
(paren
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|mycache
OG
l_int|0
)paren
(brace
multiline_comment|/* Set to last used mspace */
id|threadcache
op_star
id|tc
op_assign
id|p-&gt;caches
(braket
id|mycache
op_minus
l_int|1
)braket
suffix:semicolon
macro_line|#if defined(DEBUG)
id|printf
c_func
(paren
l_string|&quot;Threadcache utilisation: %lf%% in cache with %lf%% lost to other threads&bslash;n&quot;
comma
l_float|100.0
op_star
id|tc-&gt;successes
op_div
id|tc-&gt;mallocs
comma
l_float|100.0
op_star
(paren
(paren
r_float
)paren
id|tc-&gt;mallocs
op_minus
id|tc-&gt;frees
)paren
op_div
id|tc-&gt;mallocs
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|TLSSET
c_func
(paren
id|p-&gt;mycache
comma
(paren
r_void
op_star
)paren
(paren
r_int
)paren
(paren
id|tc-&gt;mymspace
)paren
)paren
)paren
(brace
m_abort
(paren
)paren
suffix:semicolon
)brace
id|tc-&gt;frees
op_increment
suffix:semicolon
id|RemoveCacheEntries
c_func
(paren
id|p
comma
id|tc
comma
l_int|0
)paren
suffix:semicolon
m_assert
(paren
op_logical_neg
id|tc-&gt;freeInCache
)paren
suffix:semicolon
id|tc-&gt;mymspace
op_assign
l_int|1
suffix:semicolon
id|tc-&gt;threadid
op_assign
l_int|0
suffix:semicolon
id|mspace_free
c_func
(paren
l_int|0
comma
id|p-&gt;caches
(braket
id|mycache
op_minus
l_int|1
)braket
)paren
suffix:semicolon
id|p-&gt;caches
(braket
id|mycache
op_minus
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|macro|GETMSPACE
mdefine_line|#define GETMSPACE(m,p,tc,ms,s,action)           &bslash;&n;  do                                            &bslash;&n;  {                                             &bslash;&n;    mstate m = GetMSpace((p),(tc),(ms),(s));    &bslash;&n;    action;                                     &bslash;&n;    RELEASE_LOCK(&amp;m-&gt;mutex);                    &bslash;&n;  } while (0)
r_static
id|FORCEINLINE
id|mstate
id|GetMSpace
c_func
(paren
id|nedpool
op_star
id|p
comma
id|threadcache
op_star
id|tc
comma
r_int
id|mymspace
comma
r_int
id|size
)paren
id|THROWSPEC
(brace
multiline_comment|/* Returns a locked and ready for use mspace */
id|mstate
id|m
op_assign
id|p-&gt;m
(braket
id|mymspace
)braket
suffix:semicolon
m_assert
(paren
id|m
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|TRY_LOCK
c_func
(paren
op_amp
id|p-&gt;m
(braket
id|mymspace
)braket
op_member_access_from_pointer
id|mutex
)paren
)paren
(brace
id|m
op_assign
id|FindMSpace
c_func
(paren
id|p
comma
id|tc
comma
op_amp
id|mymspace
comma
id|size
)paren
suffix:semicolon
)brace
"&bslash;"
multiline_comment|/*assert(IS_LOCKED(&amp;p-&gt;m[mymspace]-&gt;mutex));*/
r_return
id|m
suffix:semicolon
)brace
r_static
id|FORCEINLINE
r_void
id|GetThreadCache
c_func
(paren
id|nedpool
op_star
op_star
id|p
comma
id|threadcache
op_star
op_star
id|tc
comma
r_int
op_star
id|mymspace
comma
r_int
op_star
id|size
)paren
id|THROWSPEC
(brace
r_int
id|mycache
suffix:semicolon
r_if
c_cond
(paren
id|size
op_logical_and
op_star
id|size
OL
r_sizeof
(paren
id|threadcacheblk
)paren
)paren
(brace
op_star
id|size
op_assign
r_sizeof
(paren
id|threadcacheblk
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|p
)paren
(brace
op_star
id|p
op_assign
op_amp
id|syspool
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|syspool.threads
)paren
(brace
id|InitPool
c_func
(paren
op_amp
id|syspool
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
id|mycache
op_assign
(paren
r_int
)paren
(paren
r_int
)paren
id|TLSGET
c_func
(paren
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|mycache
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mycache
OG
l_int|0
)paren
(brace
op_star
id|tc
op_assign
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|caches
(braket
id|mycache
op_minus
l_int|1
)braket
suffix:semicolon
op_star
id|mymspace
op_assign
(paren
op_star
id|tc
)paren
op_member_access_from_pointer
id|mymspace
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|mycache
)paren
(brace
op_star
id|tc
op_assign
id|AllocCache
c_func
(paren
op_star
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|tc
)paren
(brace
multiline_comment|/* Disable */
r_if
c_cond
(paren
id|TLSSET
c_func
(paren
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|mycache
comma
(paren
r_void
op_star
)paren
op_minus
l_int|1
)paren
)paren
(brace
m_abort
(paren
)paren
suffix:semicolon
)brace
op_star
id|mymspace
op_assign
l_int|0
suffix:semicolon
)brace
r_else
op_star
id|mymspace
op_assign
(paren
op_star
id|tc
)paren
op_member_access_from_pointer
id|mymspace
suffix:semicolon
)brace
r_else
(brace
op_star
id|tc
op_assign
l_int|0
suffix:semicolon
op_star
id|mymspace
op_assign
id|mycache
op_minus
l_int|1
suffix:semicolon
)brace
m_assert
(paren
op_star
id|mymspace
op_ge
l_int|0
)paren
suffix:semicolon
m_assert
(paren
(paren
r_int
)paren
(paren
r_int
)paren
id|CURRENT_THREAD
op_eq
(paren
op_star
id|tc
)paren
op_member_access_from_pointer
id|threadid
)paren
suffix:semicolon
macro_line|#ifdef FULLSANITYCHECKS
r_if
c_cond
(paren
op_star
id|tc
)paren
(brace
r_if
c_cond
(paren
op_star
(paren
r_int
r_int
op_star
)paren
l_string|&quot;NEDMALC1&quot;
op_ne
(paren
op_star
id|tc
)paren
op_member_access_from_pointer
id|magic1
op_logical_or
op_star
(paren
r_int
r_int
op_star
)paren
l_string|&quot;NEDMALC2&quot;
op_ne
(paren
op_star
id|tc
)paren
op_member_access_from_pointer
id|magic2
)paren
(brace
m_abort
(paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
)brace
r_void
op_star
id|nedpmalloc
c_func
(paren
id|nedpool
op_star
id|p
comma
r_int
id|size
)paren
id|THROWSPEC
(brace
r_void
op_star
id|ret
op_assign
l_int|0
suffix:semicolon
id|threadcache
op_star
id|tc
suffix:semicolon
r_int
id|mymspace
suffix:semicolon
id|GetThreadCache
c_func
(paren
op_amp
id|p
comma
op_amp
id|tc
comma
op_amp
id|mymspace
comma
op_amp
id|size
)paren
suffix:semicolon
macro_line|#if THREADCACHEMAX
r_if
c_cond
(paren
id|tc
op_logical_and
id|size
op_le
id|THREADCACHEMAX
)paren
(brace
multiline_comment|/* Use the thread cache */
id|ret
op_assign
id|threadcache_malloc
c_func
(paren
id|p
comma
id|tc
comma
op_amp
id|size
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
multiline_comment|/* Use this thread&squot;s mspace */
id|GETMSPACE
c_func
(paren
id|m
comma
id|p
comma
id|tc
comma
id|mymspace
comma
id|size
comma
id|ret
op_assign
id|mspace_malloc
c_func
(paren
id|m
comma
id|size
)paren
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
r_void
op_star
id|nedpcalloc
c_func
(paren
id|nedpool
op_star
id|p
comma
r_int
id|no
comma
r_int
id|size
)paren
id|THROWSPEC
(brace
r_int
id|rsize
op_assign
id|size
op_star
id|no
suffix:semicolon
r_void
op_star
id|ret
op_assign
l_int|0
suffix:semicolon
id|threadcache
op_star
id|tc
suffix:semicolon
r_int
id|mymspace
suffix:semicolon
id|GetThreadCache
c_func
(paren
op_amp
id|p
comma
op_amp
id|tc
comma
op_amp
id|mymspace
comma
op_amp
id|rsize
)paren
suffix:semicolon
macro_line|#if THREADCACHEMAX
r_if
c_cond
(paren
id|tc
op_logical_and
id|rsize
op_le
id|THREADCACHEMAX
)paren
(brace
multiline_comment|/* Use the thread cache */
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|threadcache_malloc
c_func
(paren
id|p
comma
id|tc
comma
op_amp
id|rsize
)paren
)paren
)paren
(brace
id|memset
c_func
(paren
id|ret
comma
l_int|0
comma
id|rsize
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
multiline_comment|/* Use this thread&squot;s mspace */
id|GETMSPACE
c_func
(paren
id|m
comma
id|p
comma
id|tc
comma
id|mymspace
comma
id|rsize
comma
id|ret
op_assign
id|mspace_calloc
c_func
(paren
id|m
comma
l_int|1
comma
id|rsize
)paren
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
r_void
op_star
id|nedprealloc
c_func
(paren
id|nedpool
op_star
id|p
comma
r_void
op_star
id|mem
comma
r_int
id|size
)paren
id|THROWSPEC
(brace
r_void
op_star
id|ret
op_assign
l_int|0
suffix:semicolon
id|threadcache
op_star
id|tc
suffix:semicolon
r_int
id|mymspace
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mem
)paren
(brace
r_return
id|nedpmalloc
c_func
(paren
id|p
comma
id|size
)paren
suffix:semicolon
)brace
id|GetThreadCache
c_func
(paren
op_amp
id|p
comma
op_amp
id|tc
comma
op_amp
id|mymspace
comma
op_amp
id|size
)paren
suffix:semicolon
macro_line|#if THREADCACHEMAX
r_if
c_cond
(paren
id|tc
op_logical_and
id|size
op_logical_and
id|size
op_le
id|THREADCACHEMAX
)paren
(brace
multiline_comment|/* Use the thread cache */
r_int
id|memsize
op_assign
id|nedblksize
c_func
(paren
id|mem
)paren
suffix:semicolon
m_assert
(paren
id|memsize
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|threadcache_malloc
c_func
(paren
id|p
comma
id|tc
comma
op_amp
id|size
)paren
)paren
)paren
(brace
id|memcpy
c_func
(paren
id|ret
comma
id|mem
comma
id|memsize
OL
id|size
ques
c_cond
id|memsize
suffix:colon
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|memsize
op_le
id|THREADCACHEMAX
)paren
(brace
id|threadcache_free
c_func
(paren
id|p
comma
id|tc
comma
id|mymspace
comma
id|mem
comma
id|memsize
)paren
suffix:semicolon
)brace
r_else
id|mspace_free
c_func
(paren
l_int|0
comma
id|mem
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
multiline_comment|/* Reallocs always happen in the mspace they happened in, so skip&n;&t;&t;locking the preferred mspace for this thread */
id|ret
op_assign
id|mspace_realloc
c_func
(paren
l_int|0
comma
id|mem
comma
id|size
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
r_void
id|nedpfree
c_func
(paren
id|nedpool
op_star
id|p
comma
r_void
op_star
id|mem
)paren
id|THROWSPEC
(brace
multiline_comment|/* Frees always happen in the mspace they happened in, so skip&n;&t;locking the preferred mspace for this thread */
id|threadcache
op_star
id|tc
suffix:semicolon
r_int
id|mymspace
suffix:semicolon
r_int
id|memsize
suffix:semicolon
m_assert
(paren
id|mem
)paren
suffix:semicolon
id|GetThreadCache
c_func
(paren
op_amp
id|p
comma
op_amp
id|tc
comma
op_amp
id|mymspace
comma
l_int|0
)paren
suffix:semicolon
macro_line|#if THREADCACHEMAX
id|memsize
op_assign
id|nedblksize
c_func
(paren
id|mem
)paren
suffix:semicolon
m_assert
(paren
id|memsize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mem
op_logical_and
id|tc
op_logical_and
id|memsize
op_le
(paren
id|THREADCACHEMAX
op_plus
id|CHUNK_OVERHEAD
)paren
)paren
(brace
id|threadcache_free
c_func
(paren
id|p
comma
id|tc
comma
id|mymspace
comma
id|mem
comma
id|memsize
)paren
suffix:semicolon
)brace
r_else
macro_line|#endif
id|mspace_free
c_func
(paren
l_int|0
comma
id|mem
)paren
suffix:semicolon
)brace
r_void
op_star
id|nedpmemalign
c_func
(paren
id|nedpool
op_star
id|p
comma
r_int
id|alignment
comma
r_int
id|bytes
)paren
id|THROWSPEC
(brace
r_void
op_star
id|ret
suffix:semicolon
id|threadcache
op_star
id|tc
suffix:semicolon
r_int
id|mymspace
suffix:semicolon
id|GetThreadCache
c_func
(paren
op_amp
id|p
comma
op_amp
id|tc
comma
op_amp
id|mymspace
comma
op_amp
id|bytes
)paren
suffix:semicolon
(brace
multiline_comment|/* Use this thread&squot;s mspace */
id|GETMSPACE
c_func
(paren
id|m
comma
id|p
comma
id|tc
comma
id|mymspace
comma
id|bytes
comma
id|ret
op_assign
id|mspace_memalign
c_func
(paren
id|m
comma
id|alignment
comma
id|bytes
)paren
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
macro_line|#if !NO_MALLINFO
r_struct
id|mallinfo
id|nedpmallinfo
c_func
(paren
id|nedpool
op_star
id|p
)paren
id|THROWSPEC
(brace
r_int
id|n
suffix:semicolon
r_struct
id|mallinfo
id|ret
op_assign
initialization_block
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
(brace
id|p
op_assign
op_amp
id|syspool
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|syspool.threads
)paren
(brace
id|InitPool
c_func
(paren
op_amp
id|syspool
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|p-&gt;m
(braket
id|n
)braket
suffix:semicolon
id|n
op_increment
)paren
(brace
r_struct
id|mallinfo
id|t
op_assign
id|mspace_mallinfo
c_func
(paren
id|p-&gt;m
(braket
id|n
)braket
)paren
suffix:semicolon
id|ret.arena
op_add_assign
id|t.arena
suffix:semicolon
id|ret.ordblks
op_add_assign
id|t.ordblks
suffix:semicolon
id|ret.hblkhd
op_add_assign
id|t.hblkhd
suffix:semicolon
id|ret.usmblks
op_add_assign
id|t.usmblks
suffix:semicolon
id|ret.uordblks
op_add_assign
id|t.uordblks
suffix:semicolon
id|ret.fordblks
op_add_assign
id|t.fordblks
suffix:semicolon
id|ret.keepcost
op_add_assign
id|t.keepcost
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
macro_line|#endif
r_int
id|nedpmallopt
c_func
(paren
id|nedpool
op_star
id|p
comma
r_int
id|parno
comma
r_int
id|value
)paren
id|THROWSPEC
(brace
r_return
id|mspace_mallopt
c_func
(paren
id|parno
comma
id|value
)paren
suffix:semicolon
)brace
r_int
id|nedpmalloc_trim
c_func
(paren
id|nedpool
op_star
id|p
comma
r_int
id|pad
)paren
id|THROWSPEC
(brace
r_int
id|n
comma
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
(brace
id|p
op_assign
op_amp
id|syspool
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|syspool.threads
)paren
(brace
id|InitPool
c_func
(paren
op_amp
id|syspool
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|p-&gt;m
(braket
id|n
)braket
suffix:semicolon
id|n
op_increment
)paren
(brace
id|ret
op_add_assign
id|mspace_trim
c_func
(paren
id|p-&gt;m
(braket
id|n
)braket
comma
id|pad
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
r_void
id|nedpmalloc_stats
c_func
(paren
id|nedpool
op_star
id|p
)paren
id|THROWSPEC
(brace
r_int
id|n
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
(brace
id|p
op_assign
op_amp
id|syspool
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|syspool.threads
)paren
(brace
id|InitPool
c_func
(paren
op_amp
id|syspool
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|p-&gt;m
(braket
id|n
)braket
suffix:semicolon
id|n
op_increment
)paren
(brace
id|mspace_malloc_stats
c_func
(paren
id|p-&gt;m
(braket
id|n
)braket
)paren
suffix:semicolon
)brace
)brace
r_int
id|nedpmalloc_footprint
c_func
(paren
id|nedpool
op_star
id|p
)paren
id|THROWSPEC
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|n
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
(brace
id|p
op_assign
op_amp
id|syspool
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|syspool.threads
)paren
(brace
id|InitPool
c_func
(paren
op_amp
id|syspool
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|p-&gt;m
(braket
id|n
)braket
suffix:semicolon
id|n
op_increment
)paren
(brace
id|ret
op_add_assign
id|mspace_footprint
c_func
(paren
id|p-&gt;m
(braket
id|n
)braket
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
r_void
op_star
op_star
id|nedpindependent_calloc
c_func
(paren
id|nedpool
op_star
id|p
comma
r_int
id|elemsno
comma
r_int
id|elemsize
comma
r_void
op_star
op_star
id|chunks
)paren
id|THROWSPEC
(brace
r_void
op_star
op_star
id|ret
suffix:semicolon
id|threadcache
op_star
id|tc
suffix:semicolon
r_int
id|mymspace
suffix:semicolon
id|GetThreadCache
c_func
(paren
op_amp
id|p
comma
op_amp
id|tc
comma
op_amp
id|mymspace
comma
op_amp
id|elemsize
)paren
suffix:semicolon
id|GETMSPACE
c_func
(paren
id|m
comma
id|p
comma
id|tc
comma
id|mymspace
comma
id|elemsno
op_star
id|elemsize
comma
id|ret
op_assign
id|mspace_independent_calloc
c_func
(paren
id|m
comma
id|elemsno
comma
id|elemsize
comma
id|chunks
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_void
op_star
op_star
id|nedpindependent_comalloc
c_func
(paren
id|nedpool
op_star
id|p
comma
r_int
id|elems
comma
r_int
op_star
id|sizes
comma
r_void
op_star
op_star
id|chunks
)paren
id|THROWSPEC
(brace
r_void
op_star
op_star
id|ret
suffix:semicolon
id|threadcache
op_star
id|tc
suffix:semicolon
r_int
id|mymspace
suffix:semicolon
r_int
id|i
comma
op_star
id|adjustedsizes
op_assign
(paren
r_int
op_star
)paren
id|alloca
c_func
(paren
id|elems
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|adjustedsizes
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|elems
suffix:semicolon
id|i
op_increment
)paren
(brace
id|adjustedsizes
(braket
id|i
)braket
op_assign
id|sizes
(braket
id|i
)braket
OL
r_sizeof
(paren
id|threadcacheblk
)paren
ques
c_cond
r_sizeof
(paren
id|threadcacheblk
)paren
suffix:colon
id|sizes
(braket
id|i
)braket
suffix:semicolon
)brace
id|GetThreadCache
c_func
(paren
op_amp
id|p
comma
op_amp
id|tc
comma
op_amp
id|mymspace
comma
l_int|0
)paren
suffix:semicolon
id|GETMSPACE
c_func
(paren
id|m
comma
id|p
comma
id|tc
comma
id|mymspace
comma
l_int|0
comma
id|ret
op_assign
id|mspace_independent_comalloc
c_func
(paren
id|m
comma
id|elems
comma
id|adjustedsizes
comma
id|chunks
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#ifdef OVERRIDE_STRDUP
multiline_comment|/*&n; * This implementation is purely there to override the libc version, to&n; * avoid a crash due to allocation and free on different &squot;heaps&squot;.&n; */
r_char
op_star
id|strdup
c_func
(paren
r_const
r_char
op_star
id|s1
)paren
(brace
r_char
op_star
id|s2
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|s1
)paren
(brace
id|s2
op_assign
id|malloc
c_func
(paren
id|strlen
c_func
(paren
id|s1
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|s2
comma
id|s1
)paren
suffix:semicolon
)brace
r_return
id|s2
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if defined(__cplusplus)
)brace
macro_line|#endif
eof
