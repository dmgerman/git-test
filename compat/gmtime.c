macro_line|#include &quot;../git-compat-util.h&quot;
DECL|macro|gmtime
macro_line|#undef gmtime
DECL|macro|gmtime_r
macro_line|#undef gmtime_r
DECL|function|git_gmtime
r_struct
id|tm
op_star
id|git_gmtime
c_func
(paren
r_const
id|time_t
op_star
id|timep
)paren
(brace
r_static
r_struct
id|tm
id|result
suffix:semicolon
r_return
id|git_gmtime_r
c_func
(paren
id|timep
comma
op_amp
id|result
)paren
suffix:semicolon
)brace
DECL|function|git_gmtime_r
r_struct
id|tm
op_star
id|git_gmtime_r
c_func
(paren
r_const
id|time_t
op_star
id|timep
comma
r_struct
id|tm
op_star
id|result
)paren
(brace
r_struct
id|tm
op_star
id|ret
suffix:semicolon
id|memset
c_func
(paren
id|result
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|result
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|gmtime_r
c_func
(paren
id|timep
comma
id|result
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Rather than NULL, FreeBSD gmtime simply leaves the &quot;struct tm&quot;&n;&t; * untouched when it encounters overflow. Since &quot;mday&quot; cannot otherwise&n;&t; * be zero, we can test this very quickly.&n;&t; */
r_if
c_cond
(paren
id|ret
op_logical_and
op_logical_neg
id|ret-&gt;tm_mday
)paren
(brace
id|ret
op_assign
l_int|NULL
suffix:semicolon
id|errno
op_assign
id|EOVERFLOW
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
eof
