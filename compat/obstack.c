multiline_comment|/* obstack.c - subroutines used implicitly by object stack macros&n;   Copyright (C) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1996, 1997, 1998,&n;   1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.&n;   This file is part of the GNU C Library.&n;&n;   The GNU C Library is free software; you can redistribute it and/or&n;   modify it under the terms of the GNU Lesser General Public&n;   License as published by the Free Software Foundation; either&n;   version 2.1 of the License, or (at your option) any later version.&n;&n;   The GNU C Library is distributed in the hope that it will be useful,&n;   but WITHOUT ANY WARRANTY; without even the implied warranty of&n;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n;   Lesser General Public License for more details.&n;&n;   You should have received a copy of the GNU Lesser General Public&n;   License along with the GNU C Library; if not, write to the Free&n;   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,&n;   Boston, MA 02110-1301, USA.  */
macro_line|#ifdef HAVE_CONFIG_H
macro_line|# include &lt;config.h&gt;
macro_line|#endif
macro_line|#ifdef _LIBC
macro_line|# include &lt;obstack.h&gt;
macro_line|# include &lt;shlib-compat.h&gt;
macro_line|#else
macro_line|# include &quot;obstack.h&quot;
macro_line|#endif
multiline_comment|/* NOTE BEFORE MODIFYING THIS FILE: This version number must be&n;   incremented whenever callers compiled using an old obstack.h can no&n;   longer properly call the functions in this obstack.c.  */
DECL|macro|OBSTACK_INTERFACE_VERSION
mdefine_line|#define OBSTACK_INTERFACE_VERSION 1
multiline_comment|/* Comment out all this code if we are using the GNU C Library, and are not&n;   actually compiling the library itself, and the installed library&n;   supports the same library interface we do.  This code is part of the GNU&n;   C Library, but also included in many other GNU distributions.  Compiling&n;   and linking in this code is a waste when using the GNU C library&n;   (especially if it is a shared library).  Rather than having every GNU&n;   program understand `configure --with-gnu-libc&squot; and omit the object&n;   files, it is simpler to just do this in the source for each such file.  */
macro_line|#include &lt;stdio.h&gt;&t;&t;/* Random thing to get __GNU_LIBRARY__.  */
macro_line|#if !defined _LIBC &amp;&amp; defined __GNU_LIBRARY__ &amp;&amp; __GNU_LIBRARY__ &gt; 1
macro_line|# include &lt;gnu-versions.h&gt;
macro_line|# if _GNU_OBSTACK_INTERFACE_VERSION == OBSTACK_INTERFACE_VERSION
DECL|macro|ELIDE_CODE
macro_line|#  define ELIDE_CODE
macro_line|# endif
macro_line|#endif
macro_line|#include &lt;stddef.h&gt;
macro_line|#ifndef ELIDE_CODE
macro_line|# if HAVE_INTTYPES_H
macro_line|#  include &lt;inttypes.h&gt;
macro_line|# endif
macro_line|# if HAVE_STDINT_H || defined _LIBC
macro_line|#  include &lt;stdint.h&gt;
macro_line|# endif
multiline_comment|/* Determine default alignment.  */
DECL|union|fooround
r_union
id|fooround
(brace
DECL|member|i
r_uintmax
id|i
suffix:semicolon
DECL|member|d
r_int
r_float
id|d
suffix:semicolon
DECL|member|p
r_void
op_star
id|p
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|fooalign
r_struct
id|fooalign
(brace
DECL|member|c
r_char
id|c
suffix:semicolon
DECL|member|u
r_union
id|fooround
id|u
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* If malloc were really smart, it would round addresses to DEFAULT_ALIGNMENT.&n;   But in fact it might be less smart and round addresses to as much as&n;   DEFAULT_ROUNDING.  So we prepare for it to do that.  */
r_enum
(brace
DECL|enumerator|DEFAULT_ALIGNMENT
id|DEFAULT_ALIGNMENT
op_assign
m_offsetof
(paren
r_struct
id|fooalign
comma
id|u
)paren
comma
DECL|enumerator|DEFAULT_ROUNDING
id|DEFAULT_ROUNDING
op_assign
r_sizeof
(paren
r_union
id|fooround
)paren
)brace
suffix:semicolon
multiline_comment|/* When we copy a long block of data, this is the unit to do it with.&n;   On some machines, copying successive ints does not work;&n;   in such a case, redefine COPYING_UNIT to `long&squot; (if that works)&n;   or `char&squot; as a last resort.  */
macro_line|# ifndef COPYING_UNIT
DECL|macro|COPYING_UNIT
macro_line|#  define COPYING_UNIT int
macro_line|# endif
multiline_comment|/* The functions allocating more room by calling `obstack_chunk_alloc&squot;&n;   jump to the handler pointed to by `obstack_alloc_failed_handler&squot;.&n;   This can be set to a user defined function which should either&n;   abort gracefully or use longjump - but shouldn&squot;t return.  This&n;   variable by default points to the internal function&n;   `print_and_abort&squot;.  */
r_static
r_void
id|print_and_abort
(paren
r_void
)paren
suffix:semicolon
DECL|variable|obstack_alloc_failed_handler
r_void
(paren
op_star
id|obstack_alloc_failed_handler
)paren
(paren
r_void
)paren
op_assign
id|print_and_abort
suffix:semicolon
multiline_comment|/* Exit value used when `print_and_abort&squot; is used.  */
macro_line|# include &lt;stdlib.h&gt;
macro_line|# ifdef _LIBC
DECL|variable|obstack_exit_failure
r_int
id|obstack_exit_failure
op_assign
id|EXIT_FAILURE
suffix:semicolon
macro_line|# else
macro_line|#  include &quot;exitfail.h&quot;
DECL|macro|obstack_exit_failure
macro_line|#  define obstack_exit_failure exit_failure
macro_line|# endif
macro_line|# ifdef _LIBC
macro_line|#  if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_3_4)
multiline_comment|/* A looong time ago (before 1994, anyway; we&squot;re not sure) this global variable&n;   was used by non-GNU-C macros to avoid multiple evaluation.  The GNU C&n;   library still exports it because somebody might use it.  */
DECL|variable|_obstack_compat
r_struct
id|obstack
op_star
id|_obstack_compat
suffix:semicolon
id|compat_symbol
(paren
id|libc
comma
id|_obstack_compat
comma
id|_obstack
comma
id|GLIBC_2_0
)paren
suffix:semicolon
macro_line|#  endif
macro_line|# endif
multiline_comment|/* Define a macro that either calls functions with the traditional malloc/free&n;   calling interface, or calls functions with the mmalloc/mfree interface&n;   (that adds an extra first argument), based on the state of use_extra_arg.&n;   For free, do not use ?:, since some compilers, like the MIPS compilers,&n;   do not allow (expr) ? void : void.  */
DECL|macro|CALL_CHUNKFUN
macro_line|# define CALL_CHUNKFUN(h, size) &bslash;&n;  (((h) -&gt; use_extra_arg) &bslash;&n;   ? (*(h)-&gt;chunkfun) ((h)-&gt;extra_arg, (size)) &bslash;&n;   : (*(struct _obstack_chunk *(*) (long)) (h)-&gt;chunkfun) ((size)))
DECL|macro|CALL_FREEFUN
macro_line|# define CALL_FREEFUN(h, old_chunk) &bslash;&n;  do { &bslash;&n;    if ((h) -&gt; use_extra_arg) &bslash;&n;      (*(h)-&gt;freefun) ((h)-&gt;extra_arg, (old_chunk)); &bslash;&n;    else &bslash;&n;      (*(void (*) (void *)) (h)-&gt;freefun) ((old_chunk)); &bslash;&n;  } while (0)
"&f;"
multiline_comment|/* Initialize an obstack H for use.  Specify chunk size SIZE (0 means default).&n;   Objects start on multiples of ALIGNMENT (0 means use default).&n;   CHUNKFUN is the function to use to allocate chunks,&n;   and FREEFUN the function to free them.&n;&n;   Return nonzero if successful, calls obstack_alloc_failed_handler if&n;   allocation fails.  */
r_int
DECL|function|_obstack_begin
id|_obstack_begin
(paren
r_struct
id|obstack
op_star
id|h
comma
r_int
id|size
comma
r_int
id|alignment
comma
r_void
op_star
(paren
op_star
id|chunkfun
)paren
(paren
r_int
)paren
comma
r_void
(paren
op_star
id|freefun
)paren
(paren
r_void
op_star
)paren
)paren
(brace
r_register
r_struct
id|_obstack_chunk
op_star
id|chunk
suffix:semicolon
multiline_comment|/* points to new chunk */
r_if
c_cond
(paren
id|alignment
op_eq
l_int|0
)paren
id|alignment
op_assign
id|DEFAULT_ALIGNMENT
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
multiline_comment|/* Default size is what GNU malloc can fit in a 4096-byte block.  */
(brace
multiline_comment|/* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.&n;&t; Use the values for range checking, because if range checking is off,&n;&t; the extra bytes won&squot;t be missed terribly, but if range checking is on&n;&t; and we used a larger request, a whole extra 4096 bytes would be&n;&t; allocated.&n;&n;&t; These number are irrelevant to the new GNU malloc.  I suspect it is&n;&t; less sensitive to the size of the request.  */
r_int
id|extra
op_assign
(paren
(paren
(paren
(paren
l_int|12
op_plus
id|DEFAULT_ROUNDING
l_int|1
)paren
op_amp
op_complement
(paren
id|DEFAULT_ROUNDING
l_int|1
)paren
)paren
op_plus
l_int|4
op_plus
id|DEFAULT_ROUNDING
l_int|1
)paren
op_amp
op_complement
(paren
id|DEFAULT_ROUNDING
l_int|1
)paren
)paren
suffix:semicolon
id|size
op_assign
l_int|4096
id|extra
suffix:semicolon
)brace
id|h-&gt;chunkfun
op_assign
(paren
r_struct
id|_obstack_chunk
op_star
(paren
op_star
)paren
(paren
r_void
op_star
comma
r_int
)paren
)paren
id|chunkfun
suffix:semicolon
id|h-&gt;freefun
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
r_void
op_star
comma
r_struct
id|_obstack_chunk
op_star
)paren
)paren
id|freefun
suffix:semicolon
id|h-&gt;chunk_size
op_assign
id|size
suffix:semicolon
id|h-&gt;alignment_mask
op_assign
id|alignment
l_int|1
suffix:semicolon
id|h-&gt;use_extra_arg
op_assign
l_int|0
suffix:semicolon
id|chunk
op_assign
id|h-&gt;chunk
op_assign
id|CALL_CHUNKFUN
(paren
id|h
comma
id|h
op_member_access_from_pointer
id|chunk_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chunk
)paren
(paren
op_star
id|obstack_alloc_failed_handler
)paren
(paren
)paren
suffix:semicolon
id|h-&gt;next_free
op_assign
id|h-&gt;object_base
op_assign
id|__PTR_ALIGN
(paren
(paren
r_char
op_star
)paren
id|chunk
comma
id|chunk-&gt;contents
comma
id|alignment
l_int|1
)paren
suffix:semicolon
id|h-&gt;chunk_limit
op_assign
id|chunk-&gt;limit
op_assign
(paren
r_char
op_star
)paren
id|chunk
op_plus
id|h-&gt;chunk_size
suffix:semicolon
id|chunk-&gt;prev
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* The initial chunk now contains no empty object.  */
id|h-&gt;maybe_empty_object
op_assign
l_int|0
suffix:semicolon
id|h-&gt;alloc_failed
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_int
DECL|function|_obstack_begin_1
id|_obstack_begin_1
(paren
r_struct
id|obstack
op_star
id|h
comma
r_int
id|size
comma
r_int
id|alignment
comma
r_void
op_star
(paren
op_star
id|chunkfun
)paren
(paren
r_void
op_star
comma
r_int
)paren
comma
r_void
(paren
op_star
id|freefun
)paren
(paren
r_void
op_star
comma
r_void
op_star
)paren
comma
r_void
op_star
id|arg
)paren
(brace
r_register
r_struct
id|_obstack_chunk
op_star
id|chunk
suffix:semicolon
multiline_comment|/* points to new chunk */
r_if
c_cond
(paren
id|alignment
op_eq
l_int|0
)paren
id|alignment
op_assign
id|DEFAULT_ALIGNMENT
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
multiline_comment|/* Default size is what GNU malloc can fit in a 4096-byte block.  */
(brace
multiline_comment|/* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.&n;&t; Use the values for range checking, because if range checking is off,&n;&t; the extra bytes won&squot;t be missed terribly, but if range checking is on&n;&t; and we used a larger request, a whole extra 4096 bytes would be&n;&t; allocated.&n;&n;&t; These number are irrelevant to the new GNU malloc.  I suspect it is&n;&t; less sensitive to the size of the request.  */
r_int
id|extra
op_assign
(paren
(paren
(paren
(paren
l_int|12
op_plus
id|DEFAULT_ROUNDING
l_int|1
)paren
op_amp
op_complement
(paren
id|DEFAULT_ROUNDING
l_int|1
)paren
)paren
op_plus
l_int|4
op_plus
id|DEFAULT_ROUNDING
l_int|1
)paren
op_amp
op_complement
(paren
id|DEFAULT_ROUNDING
l_int|1
)paren
)paren
suffix:semicolon
id|size
op_assign
l_int|4096
id|extra
suffix:semicolon
)brace
id|h-&gt;chunkfun
op_assign
(paren
r_struct
id|_obstack_chunk
op_star
(paren
op_star
)paren
(paren
r_void
op_star
comma
r_int
)paren
)paren
id|chunkfun
suffix:semicolon
id|h-&gt;freefun
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
r_void
op_star
comma
r_struct
id|_obstack_chunk
op_star
)paren
)paren
id|freefun
suffix:semicolon
id|h-&gt;chunk_size
op_assign
id|size
suffix:semicolon
id|h-&gt;alignment_mask
op_assign
id|alignment
l_int|1
suffix:semicolon
id|h-&gt;extra_arg
op_assign
id|arg
suffix:semicolon
id|h-&gt;use_extra_arg
op_assign
l_int|1
suffix:semicolon
id|chunk
op_assign
id|h-&gt;chunk
op_assign
id|CALL_CHUNKFUN
(paren
id|h
comma
id|h
op_member_access_from_pointer
id|chunk_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chunk
)paren
(paren
op_star
id|obstack_alloc_failed_handler
)paren
(paren
)paren
suffix:semicolon
id|h-&gt;next_free
op_assign
id|h-&gt;object_base
op_assign
id|__PTR_ALIGN
(paren
(paren
r_char
op_star
)paren
id|chunk
comma
id|chunk-&gt;contents
comma
id|alignment
l_int|1
)paren
suffix:semicolon
id|h-&gt;chunk_limit
op_assign
id|chunk-&gt;limit
op_assign
(paren
r_char
op_star
)paren
id|chunk
op_plus
id|h-&gt;chunk_size
suffix:semicolon
id|chunk-&gt;prev
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* The initial chunk now contains no empty object.  */
id|h-&gt;maybe_empty_object
op_assign
l_int|0
suffix:semicolon
id|h-&gt;alloc_failed
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Allocate a new current chunk for the obstack *H&n;   on the assumption that LENGTH bytes need to be added&n;   to the current object, or a new object of length LENGTH allocated.&n;   Copies any partial object from the end of the old chunk&n;   to the beginning of the new one.  */
r_void
DECL|function|_obstack_newchunk
id|_obstack_newchunk
(paren
r_struct
id|obstack
op_star
id|h
comma
r_int
id|length
)paren
(brace
r_register
r_struct
id|_obstack_chunk
op_star
id|old_chunk
op_assign
id|h-&gt;chunk
suffix:semicolon
r_register
r_struct
id|_obstack_chunk
op_star
id|new_chunk
suffix:semicolon
r_register
r_int
id|new_size
suffix:semicolon
r_register
r_int
id|obj_size
op_assign
id|h-&gt;next_free
id|h-&gt;object_base
suffix:semicolon
r_register
r_int
id|i
suffix:semicolon
r_int
id|already
suffix:semicolon
r_char
op_star
id|object_base
suffix:semicolon
multiline_comment|/* Compute size for new chunk.  */
id|new_size
op_assign
(paren
id|obj_size
op_plus
id|length
)paren
op_plus
(paren
id|obj_size
op_rshift
l_int|3
)paren
op_plus
id|h-&gt;alignment_mask
op_plus
l_int|100
suffix:semicolon
r_if
c_cond
(paren
id|new_size
OL
id|h-&gt;chunk_size
)paren
id|new_size
op_assign
id|h-&gt;chunk_size
suffix:semicolon
multiline_comment|/* Allocate and initialize the new chunk.  */
id|new_chunk
op_assign
id|CALL_CHUNKFUN
(paren
id|h
comma
id|new_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_chunk
)paren
(paren
op_star
id|obstack_alloc_failed_handler
)paren
(paren
)paren
suffix:semicolon
id|h-&gt;chunk
op_assign
id|new_chunk
suffix:semicolon
id|new_chunk-&gt;prev
op_assign
id|old_chunk
suffix:semicolon
id|new_chunk-&gt;limit
op_assign
id|h-&gt;chunk_limit
op_assign
(paren
r_char
op_star
)paren
id|new_chunk
op_plus
id|new_size
suffix:semicolon
multiline_comment|/* Compute an aligned object_base in the new chunk */
id|object_base
op_assign
id|__PTR_ALIGN
(paren
(paren
r_char
op_star
)paren
id|new_chunk
comma
id|new_chunk-&gt;contents
comma
id|h-&gt;alignment_mask
)paren
suffix:semicolon
multiline_comment|/* Move the existing object to the new chunk.&n;     Word at a time is fast and is safe if the object&n;     is sufficiently aligned.  */
r_if
c_cond
(paren
id|h-&gt;alignment_mask
op_plus
l_int|1
op_ge
id|DEFAULT_ALIGNMENT
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
id|obj_size
op_div
r_sizeof
(paren
id|COPYING_UNIT
)paren
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(paren
(paren
id|COPYING_UNIT
op_star
)paren
id|object_base
)paren
(braket
id|i
)braket
op_assign
(paren
(paren
id|COPYING_UNIT
op_star
)paren
id|h-&gt;object_base
)paren
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* We used to copy the odd few remaining bytes as one extra COPYING_UNIT,&n;&t; but that can cross a page boundary on a machine&n;&t; which does not do strict alignment for COPYING_UNITS.  */
id|already
op_assign
id|obj_size
op_div
r_sizeof
(paren
id|COPYING_UNIT
)paren
op_star
r_sizeof
(paren
id|COPYING_UNIT
)paren
suffix:semicolon
)brace
r_else
id|already
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Copy remaining bytes one by one.  */
r_for
c_loop
(paren
id|i
op_assign
id|already
suffix:semicolon
id|i
OL
id|obj_size
suffix:semicolon
id|i
op_increment
)paren
id|object_base
(braket
id|i
)braket
op_assign
id|h-&gt;object_base
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* If the object just copied was the only data in OLD_CHUNK,&n;     free that chunk and remove it from the chain.&n;     But not if that chunk might contain an empty object.  */
r_if
c_cond
(paren
op_logical_neg
id|h-&gt;maybe_empty_object
op_logical_and
(paren
id|h-&gt;object_base
op_eq
id|__PTR_ALIGN
(paren
(paren
r_char
op_star
)paren
id|old_chunk
comma
id|old_chunk-&gt;contents
comma
id|h-&gt;alignment_mask
)paren
)paren
)paren
(brace
id|new_chunk-&gt;prev
op_assign
id|old_chunk-&gt;prev
suffix:semicolon
id|CALL_FREEFUN
(paren
id|h
comma
id|old_chunk
)paren
suffix:semicolon
)brace
id|h-&gt;object_base
op_assign
id|object_base
suffix:semicolon
id|h-&gt;next_free
op_assign
id|h-&gt;object_base
op_plus
id|obj_size
suffix:semicolon
multiline_comment|/* The new chunk certainly contains no empty object yet.  */
id|h-&gt;maybe_empty_object
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|# ifdef _LIBC
id|libc_hidden_def
(paren
id|_obstack_newchunk
)paren
macro_line|# endif
multiline_comment|/* Return nonzero if object OBJ has been allocated from obstack H.&n;   This is here for debugging.&n;   If you use it in a program, you are probably losing.  */
multiline_comment|/* Suppress -Wmissing-prototypes warning.  We don&squot;t want to declare this in&n;   obstack.h because it is just for debugging.  */
r_int
id|_obstack_allocated_p
(paren
r_struct
id|obstack
op_star
id|h
comma
r_void
op_star
id|obj
)paren
suffix:semicolon
r_int
id|_obstack_allocated_p
(paren
r_struct
id|obstack
op_star
id|h
comma
r_void
op_star
id|obj
)paren
(brace
r_register
r_struct
id|_obstack_chunk
op_star
id|lp
suffix:semicolon
multiline_comment|/* below addr of any objects in this chunk */
r_register
r_struct
id|_obstack_chunk
op_star
id|plp
suffix:semicolon
multiline_comment|/* point to previous chunk if any */
id|lp
op_assign
(paren
id|h
)paren
op_member_access_from_pointer
id|chunk
suffix:semicolon
multiline_comment|/* We use &gt;= rather than &gt; since the object cannot be exactly at&n;     the beginning of the chunk but might be an empty object exactly&n;     at the end of an adjacent chunk.  */
r_while
c_loop
(paren
id|lp
op_ne
l_int|0
op_logical_and
(paren
(paren
r_void
op_star
)paren
id|lp
op_ge
id|obj
op_logical_or
(paren
r_void
op_star
)paren
(paren
id|lp
)paren
op_member_access_from_pointer
id|limit
OL
id|obj
)paren
)paren
(brace
id|plp
op_assign
id|lp-&gt;prev
suffix:semicolon
id|lp
op_assign
id|plp
suffix:semicolon
)brace
r_return
id|lp
op_ne
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/* Free objects in obstack H, including OBJ and everything allocate&n;   more recently than OBJ.  If OBJ is zero, free everything in H.  */
DECL|macro|obstack_free
macro_line|# undef obstack_free
r_void
DECL|function|obstack_free
id|obstack_free
(paren
r_struct
id|obstack
op_star
id|h
comma
r_void
op_star
id|obj
)paren
(brace
r_register
r_struct
id|_obstack_chunk
op_star
id|lp
suffix:semicolon
multiline_comment|/* below addr of any objects in this chunk */
r_register
r_struct
id|_obstack_chunk
op_star
id|plp
suffix:semicolon
multiline_comment|/* point to previous chunk if any */
id|lp
op_assign
id|h-&gt;chunk
suffix:semicolon
multiline_comment|/* We use &gt;= because there cannot be an object at the beginning of a chunk.&n;     But there can be an empty object at that address&n;     at the end of another chunk.  */
r_while
c_loop
(paren
id|lp
op_ne
l_int|0
op_logical_and
(paren
(paren
r_void
op_star
)paren
id|lp
op_ge
id|obj
op_logical_or
(paren
r_void
op_star
)paren
(paren
id|lp
)paren
op_member_access_from_pointer
id|limit
OL
id|obj
)paren
)paren
(brace
id|plp
op_assign
id|lp-&gt;prev
suffix:semicolon
id|CALL_FREEFUN
(paren
id|h
comma
id|lp
)paren
suffix:semicolon
id|lp
op_assign
id|plp
suffix:semicolon
multiline_comment|/* If we switch chunks, we can&squot;t tell whether the new current&n;&t; chunk contains an empty object, so assume that it may.  */
id|h-&gt;maybe_empty_object
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lp
)paren
(brace
id|h-&gt;object_base
op_assign
id|h-&gt;next_free
op_assign
(paren
r_char
op_star
)paren
(paren
id|obj
)paren
suffix:semicolon
id|h-&gt;chunk_limit
op_assign
id|lp-&gt;limit
suffix:semicolon
id|h-&gt;chunk
op_assign
id|lp
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|obj
op_ne
l_int|0
)paren
multiline_comment|/* obj is not in any of the chunks! */
m_abort
(paren
)paren
suffix:semicolon
)brace
macro_line|# ifdef _LIBC
multiline_comment|/* Older versions of libc used a function _obstack_free intended to be&n;   called by non-GCC compilers.  */
DECL|function|strong_alias
id|strong_alias
(paren
id|obstack_free
comma
id|_obstack_free
)paren
macro_line|# endif
"&f;"
r_int
id|_obstack_memory_used
(paren
r_struct
id|obstack
op_star
id|h
)paren
(brace
r_register
r_struct
id|_obstack_chunk
op_star
id|lp
suffix:semicolon
r_register
r_int
id|nbytes
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|lp
op_assign
id|h-&gt;chunk
suffix:semicolon
id|lp
op_ne
l_int|0
suffix:semicolon
id|lp
op_assign
id|lp-&gt;prev
)paren
(brace
id|nbytes
op_add_assign
id|lp-&gt;limit
(paren
r_char
op_star
)paren
id|lp
suffix:semicolon
)brace
r_return
id|nbytes
suffix:semicolon
)brace
"&f;"
multiline_comment|/* Define the error handler.  */
macro_line|# ifdef _LIBC
macro_line|#  include &lt;libintl.h&gt;
macro_line|# else
macro_line|#  include &quot;gettext.h&quot;
macro_line|# endif
macro_line|# ifndef _
DECL|macro|_
macro_line|#  define _(msgid) gettext (msgid)
macro_line|# endif
macro_line|# ifdef _LIBC
macro_line|#  include &lt;libio/iolibio.h&gt;
macro_line|# endif
macro_line|# ifndef __attribute__
multiline_comment|/* This feature is available in gcc versions 2.5 and later.  */
macro_line|#  if __GNUC__ &lt; 2 || (__GNUC__ == 2 &amp;&amp; __GNUC_MINOR__ &lt; 5)
DECL|macro|__attribute__
macro_line|#   define __attribute__(Spec) /* empty */
macro_line|#  endif
macro_line|# endif
r_static
r_void
id|__attribute__
(paren
(paren
id|noreturn
)paren
)paren
DECL|function|print_and_abort
id|print_and_abort
(paren
r_void
)paren
(brace
multiline_comment|/* Don&squot;t change any of these strings.  Yes, it would be possible to add&n;     the newline to the string and use fputs or so.  But this must not&n;     happen because the &quot;memory exhausted&quot; message appears in other places&n;     like this and the translation should be reused instead of creating&n;     a very similar string which requires a separate translation.  */
macro_line|# ifdef _LIBC
(paren
r_void
)paren
id|__fxprintf
(paren
l_int|NULL
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|_
c_func
(paren
l_string|&quot;memory exhausted&quot;
)paren
)paren
suffix:semicolon
macro_line|# else
id|fprintf
(paren
id|stderr
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|_
c_func
(paren
l_string|&quot;memory exhausted&quot;
)paren
)paren
suffix:semicolon
macro_line|# endif
m_exit
(paren
id|obstack_exit_failure
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* !ELIDE_CODE */
eof
