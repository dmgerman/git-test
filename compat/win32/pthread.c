multiline_comment|/*&n; * Copyright (C) 2009 Andrzej K. Haczewski &lt;ahaczewski@gmail.com&gt;&n; *&n; * DISCLAMER: The implementation is Git-specific, it is subset of original&n; * Pthreads API, without lots of other features that Git doesn&squot;t use.&n; * Git also makes sure that the passed arguments are valid, so there&squot;s&n; * no need for double-checking.&n; */
macro_line|#include &quot;../../git-compat-util.h&quot;
macro_line|#include &quot;pthread.h&quot;
macro_line|#include &lt;errno.h&gt;
macro_line|#include &lt;limits.h&gt;
DECL|function|win32_start_routine
r_static
r_int
id|__stdcall
id|win32_start_routine
c_func
(paren
r_void
op_star
id|arg
)paren
(brace
id|pthread_t
op_star
id|thread
op_assign
id|arg
suffix:semicolon
id|thread-&gt;arg
op_assign
id|thread
op_member_access_from_pointer
id|start_routine
c_func
(paren
id|thread-&gt;arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pthread_create
r_int
id|pthread_create
c_func
(paren
id|pthread_t
op_star
id|thread
comma
r_const
r_void
op_star
id|unused
comma
r_void
op_star
(paren
op_star
id|start_routine
)paren
(paren
r_void
op_star
)paren
comma
r_void
op_star
id|arg
)paren
(brace
id|thread-&gt;arg
op_assign
id|arg
suffix:semicolon
id|thread-&gt;start_routine
op_assign
id|start_routine
suffix:semicolon
id|thread-&gt;handle
op_assign
(paren
id|HANDLE
)paren
id|_beginthreadex
c_func
(paren
l_int|NULL
comma
l_int|0
comma
id|win32_start_routine
comma
id|thread
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|thread-&gt;handle
)paren
r_return
id|errno
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|win32_pthread_join
r_int
id|win32_pthread_join
c_func
(paren
id|pthread_t
op_star
id|thread
comma
r_void
op_star
op_star
id|value_ptr
)paren
(brace
id|DWORD
id|result
op_assign
id|WaitForSingleObject
c_func
(paren
id|thread-&gt;handle
comma
id|INFINITE
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|result
)paren
(brace
r_case
id|WAIT_OBJECT_0
suffix:colon
r_if
c_cond
(paren
id|value_ptr
)paren
op_star
id|value_ptr
op_assign
id|thread-&gt;arg
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|WAIT_ABANDONED
suffix:colon
r_return
id|EINVAL
suffix:semicolon
r_default
suffix:colon
r_return
id|err_win_to_posix
c_func
(paren
id|GetLastError
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|pthread_cond_init
r_int
id|pthread_cond_init
c_func
(paren
id|pthread_cond_t
op_star
id|cond
comma
r_const
r_void
op_star
id|unused
)paren
(brace
id|cond-&gt;waiters
op_assign
l_int|0
suffix:semicolon
id|cond-&gt;sema
op_assign
id|CreateSemaphore
c_func
(paren
l_int|NULL
comma
l_int|0
comma
id|LONG_MAX
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cond-&gt;sema
)paren
id|die
c_func
(paren
l_string|&quot;CreateSemaphore() failed&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pthread_cond_destroy
r_int
id|pthread_cond_destroy
c_func
(paren
id|pthread_cond_t
op_star
id|cond
)paren
(brace
id|CloseHandle
c_func
(paren
id|cond-&gt;sema
)paren
suffix:semicolon
id|cond-&gt;sema
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pthread_cond_wait
r_int
id|pthread_cond_wait
c_func
(paren
id|pthread_cond_t
op_star
id|cond
comma
id|CRITICAL_SECTION
op_star
id|mutex
)paren
(brace
id|InterlockedIncrement
c_func
(paren
op_amp
id|cond-&gt;waiters
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Unlock external mutex and wait for signal.&n;&t; * NOTE: we&squot;ve held mutex locked long enough to increment&n;&t; * waiters count above, so there&squot;s no problem with&n;&t; * leaving mutex unlocked before we wait on semaphore.&n;&t; */
id|LeaveCriticalSection
c_func
(paren
id|mutex
)paren
suffix:semicolon
multiline_comment|/* let&squot;s wait - ignore return value */
id|WaitForSingleObject
c_func
(paren
id|cond-&gt;sema
comma
id|INFINITE
)paren
suffix:semicolon
multiline_comment|/* we&squot;re done waiting, so make sure we decrease waiters count */
id|InterlockedDecrement
c_func
(paren
op_amp
id|cond-&gt;waiters
)paren
suffix:semicolon
multiline_comment|/* lock external mutex again */
id|EnterCriticalSection
c_func
(paren
id|mutex
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pthread_cond_signal
r_int
id|pthread_cond_signal
c_func
(paren
id|pthread_cond_t
op_star
id|cond
)paren
(brace
multiline_comment|/*&n;&t; * Access to waiters count is atomic; see &quot;Interlocked Variable Access&quot;&n;&t; * http://msdn.microsoft.com/en-us/library/ms684122(VS.85).aspx&n;&t; */
r_int
id|have_waiters
op_assign
id|cond-&gt;waiters
OG
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Signal only when there are waiters&n;&t; */
r_if
c_cond
(paren
id|have_waiters
)paren
r_return
id|ReleaseSemaphore
c_func
(paren
id|cond-&gt;sema
comma
l_int|1
comma
l_int|NULL
)paren
ques
c_cond
l_int|0
suffix:colon
id|err_win_to_posix
c_func
(paren
id|GetLastError
c_func
(paren
)paren
)paren
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
eof
