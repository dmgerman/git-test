macro_line|#include &quot;../git-compat-util.h&quot;
macro_line|#include &quot;dirent.h&quot;
DECL|struct|DIR
r_struct
id|DIR
(brace
DECL|member|dd_dir
r_struct
id|dirent
id|dd_dir
suffix:semicolon
multiline_comment|/* includes d_type */
DECL|member|dd_handle
id|HANDLE
id|dd_handle
suffix:semicolon
multiline_comment|/* FindFirstFile handle */
DECL|member|dd_stat
r_int
id|dd_stat
suffix:semicolon
multiline_comment|/* 0-based index */
DECL|member|dd_name
r_char
id|dd_name
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* extend struct */
)brace
suffix:semicolon
DECL|function|opendir
id|DIR
op_star
id|opendir
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
id|DWORD
id|attrs
op_assign
id|GetFileAttributesA
c_func
(paren
id|name
)paren
suffix:semicolon
r_int
id|len
suffix:semicolon
id|DIR
op_star
id|p
suffix:semicolon
multiline_comment|/* check for valid path */
r_if
c_cond
(paren
id|attrs
op_eq
id|INVALID_FILE_ATTRIBUTES
)paren
(brace
id|errno
op_assign
id|ENOENT
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* check if it&squot;s a directory */
r_if
c_cond
(paren
op_logical_neg
(paren
id|attrs
op_amp
id|FILE_ATTRIBUTE_DIRECTORY
)paren
)paren
(brace
id|errno
op_assign
id|ENOTDIR
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* check that the pattern won&squot;t be too long for FindFirstFileA */
id|len
op_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_dir_sep
c_func
(paren
id|name
(braket
id|len
l_int|1
)braket
)paren
)paren
id|len
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|len
op_plus
l_int|2
op_ge
id|MAX_PATH
)paren
(brace
id|errno
op_assign
id|ENAMETOOLONG
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|p
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
id|DIR
)paren
op_plus
id|len
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|p
comma
l_int|0
comma
r_sizeof
(paren
id|DIR
)paren
op_plus
id|len
op_plus
l_int|2
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|p-&gt;dd_name
comma
id|name
)paren
suffix:semicolon
id|p-&gt;dd_name
(braket
id|len
)braket
op_assign
l_char|&squot;/&squot;
suffix:semicolon
id|p-&gt;dd_name
(braket
id|len
op_plus
l_int|1
)braket
op_assign
l_char|&squot;*&squot;
suffix:semicolon
id|p-&gt;dd_handle
op_assign
id|INVALID_HANDLE_VALUE
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
DECL|function|readdir
r_struct
id|dirent
op_star
id|readdir
c_func
(paren
id|DIR
op_star
id|dir
)paren
(brace
id|WIN32_FIND_DATAA
id|buf
suffix:semicolon
id|HANDLE
id|handle
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir
op_logical_or
op_logical_neg
id|dir-&gt;dd_handle
)paren
(brace
id|errno
op_assign
id|EBADF
suffix:semicolon
multiline_comment|/* No set_errno for mingw */
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dir-&gt;dd_handle
op_eq
id|INVALID_HANDLE_VALUE
op_logical_and
id|dir-&gt;dd_stat
op_eq
l_int|0
)paren
(brace
id|DWORD
id|lasterr
suffix:semicolon
id|handle
op_assign
id|FindFirstFileA
c_func
(paren
id|dir-&gt;dd_name
comma
op_amp
id|buf
)paren
suffix:semicolon
id|lasterr
op_assign
id|GetLastError
c_func
(paren
)paren
suffix:semicolon
id|dir-&gt;dd_handle
op_assign
id|handle
suffix:semicolon
r_if
c_cond
(paren
id|handle
op_eq
id|INVALID_HANDLE_VALUE
op_logical_and
(paren
id|lasterr
op_ne
id|ERROR_NO_MORE_FILES
)paren
)paren
(brace
id|errno
op_assign
id|err_win_to_posix
c_func
(paren
id|lasterr
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|dir-&gt;dd_handle
op_eq
id|INVALID_HANDLE_VALUE
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|FindNextFileA
c_func
(paren
id|dir-&gt;dd_handle
comma
op_amp
id|buf
)paren
)paren
(brace
id|DWORD
id|lasterr
op_assign
id|GetLastError
c_func
(paren
)paren
suffix:semicolon
id|FindClose
c_func
(paren
id|dir-&gt;dd_handle
)paren
suffix:semicolon
id|dir-&gt;dd_handle
op_assign
id|INVALID_HANDLE_VALUE
suffix:semicolon
multiline_comment|/* POSIX says you shouldn&squot;t set errno when readdir can&squot;t&n;&t;&t;   find any more files; so, if another error we leave it set. */
r_if
c_cond
(paren
id|lasterr
op_ne
id|ERROR_NO_MORE_FILES
)paren
id|errno
op_assign
id|err_win_to_posix
c_func
(paren
id|lasterr
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* We get here if `buf&squot; contains valid data.  */
id|strcpy
c_func
(paren
id|dir-&gt;dd_dir.d_name
comma
id|buf.cFileName
)paren
suffix:semicolon
op_increment
id|dir-&gt;dd_stat
suffix:semicolon
multiline_comment|/* Set file type, based on WIN32_FIND_DATA */
id|dir-&gt;dd_dir.d_type
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|buf.dwFileAttributes
op_amp
id|FILE_ATTRIBUTE_DIRECTORY
)paren
id|dir-&gt;dd_dir.d_type
op_or_assign
id|DT_DIR
suffix:semicolon
r_else
id|dir-&gt;dd_dir.d_type
op_or_assign
id|DT_REG
suffix:semicolon
r_return
op_amp
id|dir-&gt;dd_dir
suffix:semicolon
)brace
DECL|function|closedir
r_int
id|closedir
c_func
(paren
id|DIR
op_star
id|dir
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dir
)paren
(brace
id|errno
op_assign
id|EBADF
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dir-&gt;dd_handle
op_ne
id|INVALID_HANDLE_VALUE
)paren
id|FindClose
c_func
(paren
id|dir-&gt;dd_handle
)paren
suffix:semicolon
id|free
c_func
(paren
id|dir
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
