macro_line|#include &quot;../../git-compat-util.h&quot;
DECL|struct|DIR
r_struct
id|DIR
(brace
DECL|member|dd_dir
r_struct
id|dirent
id|dd_dir
suffix:semicolon
multiline_comment|/* includes d_type */
DECL|member|dd_handle
id|HANDLE
id|dd_handle
suffix:semicolon
multiline_comment|/* FindFirstFile handle */
DECL|member|dd_stat
r_int
id|dd_stat
suffix:semicolon
multiline_comment|/* 0-based index */
)brace
suffix:semicolon
DECL|function|finddata2dirent
r_static
r_inline
r_void
id|finddata2dirent
c_func
(paren
r_struct
id|dirent
op_star
id|ent
comma
id|WIN32_FIND_DATAW
op_star
id|fdata
)paren
(brace
multiline_comment|/* convert UTF-16 name to UTF-8 */
id|xwcstoutf
c_func
(paren
id|ent-&gt;d_name
comma
id|fdata-&gt;cFileName
comma
r_sizeof
(paren
id|ent-&gt;d_name
)paren
)paren
suffix:semicolon
multiline_comment|/* Set file type, based on WIN32_FIND_DATA */
r_if
c_cond
(paren
id|fdata-&gt;dwFileAttributes
op_amp
id|FILE_ATTRIBUTE_DIRECTORY
)paren
id|ent-&gt;d_type
op_assign
id|DT_DIR
suffix:semicolon
r_else
id|ent-&gt;d_type
op_assign
id|DT_REG
suffix:semicolon
)brace
DECL|function|opendir
id|DIR
op_star
id|opendir
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
m_wchar_t
id|pattern
(braket
id|MAX_PATH
op_plus
l_int|2
)braket
suffix:semicolon
multiline_comment|/* + 2 for &squot;/&squot; &squot;*&squot; */
id|WIN32_FIND_DATAW
id|fdata
suffix:semicolon
id|HANDLE
id|h
suffix:semicolon
r_int
id|len
suffix:semicolon
id|DIR
op_star
id|dir
suffix:semicolon
multiline_comment|/* convert name to UTF-16 and check length &lt; MAX_PATH */
r_if
c_cond
(paren
(paren
id|len
op_assign
id|xutftowcs_path
c_func
(paren
id|pattern
comma
id|name
)paren
)paren
OL
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* append optional &squot;/&squot; and wildcard &squot;*&squot; */
r_if
c_cond
(paren
id|len
op_logical_and
op_logical_neg
id|is_dir_sep
c_func
(paren
id|pattern
(braket
id|len
l_int|1
)braket
)paren
)paren
id|pattern
(braket
id|len
op_increment
)braket
op_assign
l_char|&squot;/&squot;
suffix:semicolon
id|pattern
(braket
id|len
op_increment
)braket
op_assign
l_char|&squot;*&squot;
suffix:semicolon
id|pattern
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* open find handle */
id|h
op_assign
id|FindFirstFileW
c_func
(paren
id|pattern
comma
op_amp
id|fdata
)paren
suffix:semicolon
r_if
c_cond
(paren
id|h
op_eq
id|INVALID_HANDLE_VALUE
)paren
(brace
id|DWORD
id|err
op_assign
id|GetLastError
c_func
(paren
)paren
suffix:semicolon
id|errno
op_assign
(paren
id|err
op_eq
id|ERROR_DIRECTORY
)paren
ques
c_cond
id|ENOTDIR
suffix:colon
id|err_win_to_posix
c_func
(paren
id|err
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* initialize DIR structure and copy first dir entry */
id|dir
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
id|DIR
)paren
)paren
suffix:semicolon
id|dir-&gt;dd_handle
op_assign
id|h
suffix:semicolon
id|dir-&gt;dd_stat
op_assign
l_int|0
suffix:semicolon
id|finddata2dirent
c_func
(paren
op_amp
id|dir-&gt;dd_dir
comma
op_amp
id|fdata
)paren
suffix:semicolon
r_return
id|dir
suffix:semicolon
)brace
DECL|function|readdir
r_struct
id|dirent
op_star
id|readdir
c_func
(paren
id|DIR
op_star
id|dir
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dir
)paren
(brace
id|errno
op_assign
id|EBADF
suffix:semicolon
multiline_comment|/* No set_errno for mingw */
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* if first entry, dirent has already been set up by opendir */
r_if
c_cond
(paren
id|dir-&gt;dd_stat
)paren
(brace
multiline_comment|/* get next entry and convert from WIN32_FIND_DATA to dirent */
id|WIN32_FIND_DATAW
id|fdata
suffix:semicolon
r_if
c_cond
(paren
id|FindNextFileW
c_func
(paren
id|dir-&gt;dd_handle
comma
op_amp
id|fdata
)paren
)paren
(brace
id|finddata2dirent
c_func
(paren
op_amp
id|dir-&gt;dd_dir
comma
op_amp
id|fdata
)paren
suffix:semicolon
)brace
r_else
(brace
id|DWORD
id|lasterr
op_assign
id|GetLastError
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* POSIX says you shouldn&squot;t set errno when readdir can&squot;t&n;&t;&t;&t;   find any more files; so, if another error we leave it set. */
r_if
c_cond
(paren
id|lasterr
op_ne
id|ERROR_NO_MORE_FILES
)paren
id|errno
op_assign
id|err_win_to_posix
c_func
(paren
id|lasterr
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
op_increment
id|dir-&gt;dd_stat
suffix:semicolon
r_return
op_amp
id|dir-&gt;dd_dir
suffix:semicolon
)brace
DECL|function|closedir
r_int
id|closedir
c_func
(paren
id|DIR
op_star
id|dir
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dir
)paren
(brace
id|errno
op_assign
id|EBADF
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|FindClose
c_func
(paren
id|dir-&gt;dd_handle
)paren
suffix:semicolon
id|free
c_func
(paren
id|dir
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
