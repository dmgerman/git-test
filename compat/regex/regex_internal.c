multiline_comment|/* Extended regular expression matching and search library.&n;   Copyright (C) 2002-2006, 2010 Free Software Foundation, Inc.&n;   This file is part of the GNU C Library.&n;   Contributed by Isamu Hasegawa &lt;isamu@yamato.ibm.com&gt;.&n;&n;   The GNU C Library is free software; you can redistribute it and/or&n;   modify it under the terms of the GNU Lesser General Public&n;   License as published by the Free Software Foundation; either&n;   version 2.1 of the License, or (at your option) any later version.&n;&n;   The GNU C Library is distributed in the hope that it will be useful,&n;   but WITHOUT ANY WARRANTY; without even the implied warranty of&n;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n;   Lesser General Public License for more details.&n;&n;   You should have received a copy of the GNU Lesser General Public&n;   License along with the GNU C Library; if not, write to the Free&n;   Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA&n;   02110-1301 USA.  */
r_static
r_void
id|re_string_construct_common
(paren
r_const
r_char
op_star
id|str
comma
r_int
id|len
comma
id|re_string_t
op_star
id|pstr
comma
id|RE_TRANSLATE_TYPE
id|trans
comma
r_int
id|icase
comma
r_const
id|re_dfa_t
op_star
id|dfa
)paren
id|internal_function
suffix:semicolon
r_static
id|re_dfastate_t
op_star
id|create_ci_newstate
(paren
r_const
id|re_dfa_t
op_star
id|dfa
comma
r_const
id|re_node_set
op_star
id|nodes
comma
r_int
r_int
id|hash
)paren
id|internal_function
suffix:semicolon
r_static
id|re_dfastate_t
op_star
id|create_cd_newstate
(paren
r_const
id|re_dfa_t
op_star
id|dfa
comma
r_const
id|re_node_set
op_star
id|nodes
comma
r_int
r_int
id|context
comma
r_int
r_int
id|hash
)paren
id|internal_function
suffix:semicolon
macro_line|#ifdef GAWK
DECL|macro|MAX
macro_line|#undef MAX&t;/* safety */
r_static
r_int
DECL|function|MAX
id|MAX
c_func
(paren
r_int
id|a
comma
r_int
id|b
)paren
(brace
r_return
(paren
id|a
OG
id|b
ques
c_cond
id|a
suffix:colon
id|b
)paren
suffix:semicolon
)brace
macro_line|#endif
"&f;"
multiline_comment|/* Functions for string operation.  */
multiline_comment|/* This function allocate the buffers.  It is necessary to call&n;   re_string_reconstruct before using the object.  */
r_static
id|reg_errcode_t
id|internal_function
DECL|function|re_string_allocate
id|re_string_allocate
(paren
id|re_string_t
op_star
id|pstr
comma
r_const
r_char
op_star
id|str
comma
r_int
id|len
comma
r_int
id|init_len
comma
id|RE_TRANSLATE_TYPE
id|trans
comma
r_int
id|icase
comma
r_const
id|re_dfa_t
op_star
id|dfa
)paren
(brace
id|reg_errcode_t
id|ret
suffix:semicolon
r_int
id|init_buf_len
suffix:semicolon
multiline_comment|/* Ensure at least one character fits into the buffers.  */
r_if
c_cond
(paren
id|init_len
OL
id|dfa-&gt;mb_cur_max
)paren
id|init_len
op_assign
id|dfa-&gt;mb_cur_max
suffix:semicolon
id|init_buf_len
op_assign
(paren
id|len
op_plus
l_int|1
OL
id|init_len
)paren
ques
c_cond
id|len
op_plus
l_int|1
suffix:colon
id|init_len
suffix:semicolon
id|re_string_construct_common
(paren
id|str
comma
id|len
comma
id|pstr
comma
id|trans
comma
id|icase
comma
id|dfa
)paren
suffix:semicolon
id|ret
op_assign
id|re_string_realloc_buffers
(paren
id|pstr
comma
id|init_buf_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|ret
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|ret
suffix:semicolon
id|pstr-&gt;word_char
op_assign
id|dfa-&gt;word_char
suffix:semicolon
id|pstr-&gt;word_ops_used
op_assign
id|dfa-&gt;word_ops_used
suffix:semicolon
id|pstr-&gt;mbs
op_assign
id|pstr-&gt;mbs_allocated
ques
c_cond
id|pstr-&gt;mbs
suffix:colon
(paren
r_int
r_char
op_star
)paren
id|str
suffix:semicolon
id|pstr-&gt;valid_len
op_assign
(paren
id|pstr-&gt;mbs_allocated
op_logical_or
id|dfa-&gt;mb_cur_max
OG
l_int|1
)paren
ques
c_cond
l_int|0
suffix:colon
id|len
suffix:semicolon
id|pstr-&gt;valid_raw_len
op_assign
id|pstr-&gt;valid_len
suffix:semicolon
r_return
id|REG_NOERROR
suffix:semicolon
)brace
multiline_comment|/* This function allocate the buffers, and initialize them.  */
r_static
id|reg_errcode_t
id|internal_function
DECL|function|re_string_construct
id|re_string_construct
(paren
id|re_string_t
op_star
id|pstr
comma
r_const
r_char
op_star
id|str
comma
r_int
id|len
comma
id|RE_TRANSLATE_TYPE
id|trans
comma
r_int
id|icase
comma
r_const
id|re_dfa_t
op_star
id|dfa
)paren
(brace
id|reg_errcode_t
id|ret
suffix:semicolon
id|memset
(paren
id|pstr
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|re_string_t
)paren
)paren
suffix:semicolon
id|re_string_construct_common
(paren
id|str
comma
id|len
comma
id|pstr
comma
id|trans
comma
id|icase
comma
id|dfa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
(brace
id|ret
op_assign
id|re_string_realloc_buffers
(paren
id|pstr
comma
id|len
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|ret
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|ret
suffix:semicolon
)brace
id|pstr-&gt;mbs
op_assign
id|pstr-&gt;mbs_allocated
ques
c_cond
id|pstr-&gt;mbs
suffix:colon
(paren
r_int
r_char
op_star
)paren
id|str
suffix:semicolon
r_if
c_cond
(paren
id|icase
)paren
(brace
macro_line|#ifdef RE_ENABLE_I18N
r_if
c_cond
(paren
id|dfa-&gt;mb_cur_max
OG
l_int|1
)paren
(brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|ret
op_assign
id|build_wcs_upper_buffer
(paren
id|pstr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|ret
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|pstr-&gt;valid_raw_len
op_ge
id|len
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|pstr-&gt;bufs_len
OG
id|pstr-&gt;valid_len
op_plus
id|dfa-&gt;mb_cur_max
)paren
r_break
suffix:semicolon
id|ret
op_assign
id|re_string_realloc_buffers
(paren
id|pstr
comma
id|pstr-&gt;bufs_len
op_star
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|ret
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|ret
suffix:semicolon
)brace
)brace
r_else
macro_line|#endif /* RE_ENABLE_I18N  */
id|build_upper_buffer
(paren
id|pstr
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef RE_ENABLE_I18N
r_if
c_cond
(paren
id|dfa-&gt;mb_cur_max
OG
l_int|1
)paren
id|build_wcs_buffer
(paren
id|pstr
)paren
suffix:semicolon
r_else
macro_line|#endif /* RE_ENABLE_I18N  */
(brace
r_if
c_cond
(paren
id|trans
op_ne
l_int|NULL
)paren
id|re_string_translate_buffer
(paren
id|pstr
)paren
suffix:semicolon
r_else
(brace
id|pstr-&gt;valid_len
op_assign
id|pstr-&gt;bufs_len
suffix:semicolon
id|pstr-&gt;valid_raw_len
op_assign
id|pstr-&gt;bufs_len
suffix:semicolon
)brace
)brace
)brace
r_return
id|REG_NOERROR
suffix:semicolon
)brace
multiline_comment|/* Helper functions for re_string_allocate, and re_string_construct.  */
r_static
id|reg_errcode_t
id|internal_function
DECL|function|re_string_realloc_buffers
id|re_string_realloc_buffers
(paren
id|re_string_t
op_star
id|pstr
comma
r_int
id|new_buf_len
)paren
(brace
macro_line|#ifdef RE_ENABLE_I18N
r_if
c_cond
(paren
id|pstr-&gt;mb_cur_max
OG
l_int|1
)paren
(brace
id|wint_t
op_star
id|new_wcs
suffix:semicolon
multiline_comment|/* Avoid overflow in realloc.  */
r_const
r_int
id|max_object_size
op_assign
id|MAX
(paren
r_sizeof
(paren
id|wint_t
)paren
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|SIZE_MAX
op_div
id|max_object_size
OL
id|new_buf_len
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
id|new_wcs
op_assign
id|re_realloc
(paren
id|pstr-&gt;wcs
comma
id|wint_t
comma
id|new_buf_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|new_wcs
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
id|pstr-&gt;wcs
op_assign
id|new_wcs
suffix:semicolon
r_if
c_cond
(paren
id|pstr-&gt;offsets
op_ne
l_int|NULL
)paren
(brace
r_int
op_star
id|new_offsets
op_assign
id|re_realloc
(paren
id|pstr-&gt;offsets
comma
r_int
comma
id|new_buf_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|new_offsets
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
id|pstr-&gt;offsets
op_assign
id|new_offsets
suffix:semicolon
)brace
)brace
macro_line|#endif /* RE_ENABLE_I18N  */
r_if
c_cond
(paren
id|pstr-&gt;mbs_allocated
)paren
(brace
r_int
r_char
op_star
id|new_mbs
op_assign
id|re_realloc
(paren
id|pstr-&gt;mbs
comma
r_int
r_char
comma
id|new_buf_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|new_mbs
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
id|pstr-&gt;mbs
op_assign
id|new_mbs
suffix:semicolon
)brace
id|pstr-&gt;bufs_len
op_assign
id|new_buf_len
suffix:semicolon
r_return
id|REG_NOERROR
suffix:semicolon
)brace
r_static
r_void
id|internal_function
DECL|function|re_string_construct_common
id|re_string_construct_common
(paren
r_const
r_char
op_star
id|str
comma
r_int
id|len
comma
id|re_string_t
op_star
id|pstr
comma
id|RE_TRANSLATE_TYPE
id|trans
comma
r_int
id|icase
comma
r_const
id|re_dfa_t
op_star
id|dfa
)paren
(brace
id|pstr-&gt;raw_mbs
op_assign
(paren
r_const
r_int
r_char
op_star
)paren
id|str
suffix:semicolon
id|pstr-&gt;len
op_assign
id|len
suffix:semicolon
id|pstr-&gt;raw_len
op_assign
id|len
suffix:semicolon
id|pstr-&gt;trans
op_assign
id|trans
suffix:semicolon
id|pstr-&gt;icase
op_assign
id|icase
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|pstr-&gt;mbs_allocated
op_assign
(paren
id|trans
op_ne
l_int|NULL
op_logical_or
id|icase
)paren
suffix:semicolon
id|pstr-&gt;mb_cur_max
op_assign
id|dfa-&gt;mb_cur_max
suffix:semicolon
id|pstr-&gt;is_utf8
op_assign
id|dfa-&gt;is_utf8
suffix:semicolon
id|pstr-&gt;map_notascii
op_assign
id|dfa-&gt;map_notascii
suffix:semicolon
id|pstr-&gt;stop
op_assign
id|pstr-&gt;len
suffix:semicolon
id|pstr-&gt;raw_stop
op_assign
id|pstr-&gt;stop
suffix:semicolon
)brace
macro_line|#ifdef RE_ENABLE_I18N
multiline_comment|/* Build wide character buffer PSTR-&gt;WCS.&n;   If the byte sequence of the string are:&n;     &lt;mb1&gt;(0), &lt;mb1&gt;(1), &lt;mb2&gt;(0), &lt;mb2&gt;(1), &lt;sb3&gt;&n;   Then wide character buffer will be:&n;     &lt;wc1&gt;   , WEOF    , &lt;wc2&gt;   , WEOF    , &lt;wc3&gt;&n;   We use WEOF for padding, they indicate that the position isn&squot;t&n;   a first byte of a multibyte character.&n;&n;   Note that this function assumes PSTR-&gt;VALID_LEN elements are already&n;   built and starts from PSTR-&gt;VALID_LEN.  */
r_static
r_void
id|internal_function
DECL|function|build_wcs_buffer
id|build_wcs_buffer
(paren
id|re_string_t
op_star
id|pstr
)paren
(brace
macro_line|#ifdef _LIBC
r_int
r_char
id|buf
(braket
id|MB_LEN_MAX
)braket
suffix:semicolon
m_assert
(paren
id|MB_LEN_MAX
op_ge
id|pstr-&gt;mb_cur_max
)paren
suffix:semicolon
macro_line|#else
r_int
r_char
id|buf
(braket
l_int|64
)braket
suffix:semicolon
macro_line|#endif
id|mbstate_t
id|prev_st
suffix:semicolon
r_int
id|byte_idx
comma
id|end_idx
comma
id|remain_len
suffix:semicolon
r_int
id|mbclen
suffix:semicolon
multiline_comment|/* Build the buffers from pstr-&gt;valid_len to either pstr-&gt;len or&n;     pstr-&gt;bufs_len.  */
id|end_idx
op_assign
(paren
id|pstr-&gt;bufs_len
OG
id|pstr-&gt;len
)paren
ques
c_cond
id|pstr-&gt;len
suffix:colon
id|pstr-&gt;bufs_len
suffix:semicolon
r_for
c_loop
(paren
id|byte_idx
op_assign
id|pstr-&gt;valid_len
suffix:semicolon
id|byte_idx
OL
id|end_idx
suffix:semicolon
)paren
(brace
m_wchar_t
id|wc
suffix:semicolon
r_const
r_char
op_star
id|p
suffix:semicolon
id|remain_len
op_assign
id|end_idx
id|byte_idx
suffix:semicolon
id|prev_st
op_assign
id|pstr-&gt;cur_state
suffix:semicolon
multiline_comment|/* Apply the translation if we need.  */
r_if
c_cond
(paren
id|BE
(paren
id|pstr-&gt;trans
op_ne
l_int|NULL
comma
l_int|0
)paren
)paren
(brace
r_int
id|i
comma
id|ch
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pstr-&gt;mb_cur_max
op_logical_and
id|i
OL
id|remain_len
suffix:semicolon
op_increment
id|i
)paren
(brace
id|ch
op_assign
id|pstr-&gt;raw_mbs
(braket
id|pstr-&gt;raw_mbs_idx
op_plus
id|byte_idx
op_plus
id|i
)braket
suffix:semicolon
id|buf
(braket
id|i
)braket
op_assign
id|pstr-&gt;mbs
(braket
id|byte_idx
op_plus
id|i
)braket
op_assign
id|pstr-&gt;trans
(braket
id|ch
)braket
suffix:semicolon
)brace
id|p
op_assign
(paren
r_const
r_char
op_star
)paren
id|buf
suffix:semicolon
)brace
r_else
id|p
op_assign
(paren
r_const
r_char
op_star
)paren
id|pstr-&gt;raw_mbs
op_plus
id|pstr-&gt;raw_mbs_idx
op_plus
id|byte_idx
suffix:semicolon
id|mbclen
op_assign
id|__mbrtowc
(paren
op_amp
id|wc
comma
id|p
comma
id|remain_len
comma
op_amp
id|pstr-&gt;cur_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|mbclen
op_eq
(paren
r_int
)paren
l_int|2
comma
l_int|0
)paren
)paren
(brace
multiline_comment|/* The buffer doesn&squot;t have enough space, finish to build.  */
id|pstr-&gt;cur_state
op_assign
id|prev_st
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|BE
(paren
id|mbclen
op_eq
(paren
r_int
)paren
l_int|1
op_logical_or
id|mbclen
op_eq
l_int|0
comma
l_int|0
)paren
)paren
(brace
multiline_comment|/* We treat these cases as a singlebyte character.  */
id|mbclen
op_assign
l_int|1
suffix:semicolon
id|wc
op_assign
(paren
m_wchar_t
)paren
id|pstr-&gt;raw_mbs
(braket
id|pstr-&gt;raw_mbs_idx
op_plus
id|byte_idx
)braket
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|pstr-&gt;trans
op_ne
l_int|NULL
comma
l_int|0
)paren
)paren
id|wc
op_assign
id|pstr-&gt;trans
(braket
id|wc
)braket
suffix:semicolon
id|pstr-&gt;cur_state
op_assign
id|prev_st
suffix:semicolon
)brace
multiline_comment|/* Write wide character and padding.  */
id|pstr-&gt;wcs
(braket
id|byte_idx
op_increment
)braket
op_assign
id|wc
suffix:semicolon
multiline_comment|/* Write paddings.  */
r_for
c_loop
(paren
id|remain_len
op_assign
id|byte_idx
op_plus
id|mbclen
l_int|1
suffix:semicolon
id|byte_idx
OL
id|remain_len
suffix:semicolon
)paren
id|pstr-&gt;wcs
(braket
id|byte_idx
op_increment
)braket
op_assign
id|WEOF
suffix:semicolon
)brace
id|pstr-&gt;valid_len
op_assign
id|byte_idx
suffix:semicolon
id|pstr-&gt;valid_raw_len
op_assign
id|byte_idx
suffix:semicolon
)brace
multiline_comment|/* Build wide character buffer PSTR-&gt;WCS like build_wcs_buffer,&n;   but for REG_ICASE.  */
r_static
id|reg_errcode_t
id|internal_function
DECL|function|build_wcs_upper_buffer
id|build_wcs_upper_buffer
(paren
id|re_string_t
op_star
id|pstr
)paren
(brace
id|mbstate_t
id|prev_st
suffix:semicolon
r_int
id|src_idx
comma
id|byte_idx
comma
id|end_idx
comma
id|remain_len
suffix:semicolon
r_int
id|mbclen
suffix:semicolon
macro_line|#ifdef _LIBC
r_char
id|buf
(braket
id|MB_LEN_MAX
)braket
suffix:semicolon
m_assert
(paren
id|MB_LEN_MAX
op_ge
id|pstr-&gt;mb_cur_max
)paren
suffix:semicolon
macro_line|#else
r_char
id|buf
(braket
l_int|64
)braket
suffix:semicolon
macro_line|#endif
id|byte_idx
op_assign
id|pstr-&gt;valid_len
suffix:semicolon
id|end_idx
op_assign
(paren
id|pstr-&gt;bufs_len
OG
id|pstr-&gt;len
)paren
ques
c_cond
id|pstr-&gt;len
suffix:colon
id|pstr-&gt;bufs_len
suffix:semicolon
multiline_comment|/* The following optimization assumes that ASCII characters can be&n;     mapped to wide characters with a simple cast.  */
r_if
c_cond
(paren
op_logical_neg
id|pstr-&gt;map_notascii
op_logical_and
id|pstr-&gt;trans
op_eq
l_int|NULL
op_logical_and
op_logical_neg
id|pstr-&gt;offsets_needed
)paren
(brace
r_while
c_loop
(paren
id|byte_idx
OL
id|end_idx
)paren
(brace
m_wchar_t
id|wc
suffix:semicolon
r_if
c_cond
(paren
id|isascii
(paren
id|pstr-&gt;raw_mbs
(braket
id|pstr-&gt;raw_mbs_idx
op_plus
id|byte_idx
)braket
)paren
op_logical_and
id|mbsinit
(paren
op_amp
id|pstr-&gt;cur_state
)paren
)paren
(brace
multiline_comment|/* In case of a singlebyte character.  */
id|pstr-&gt;mbs
(braket
id|byte_idx
)braket
op_assign
id|toupper
(paren
id|pstr-&gt;raw_mbs
(braket
id|pstr-&gt;raw_mbs_idx
op_plus
id|byte_idx
)braket
)paren
suffix:semicolon
multiline_comment|/* The next step uses the assumption that wchar_t is encoded&n;&t;&t; ASCII-safe: all ASCII values can be converted like this.  */
id|pstr-&gt;wcs
(braket
id|byte_idx
)braket
op_assign
(paren
m_wchar_t
)paren
id|pstr-&gt;mbs
(braket
id|byte_idx
)braket
suffix:semicolon
op_increment
id|byte_idx
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|remain_len
op_assign
id|end_idx
id|byte_idx
suffix:semicolon
id|prev_st
op_assign
id|pstr-&gt;cur_state
suffix:semicolon
id|mbclen
op_assign
id|__mbrtowc
(paren
op_amp
id|wc
comma
(paren
(paren
r_const
r_char
op_star
)paren
id|pstr-&gt;raw_mbs
op_plus
id|pstr-&gt;raw_mbs_idx
op_plus
id|byte_idx
)paren
comma
id|remain_len
comma
op_amp
id|pstr-&gt;cur_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|mbclen
op_plus
l_int|2
OG
l_int|2
comma
l_int|1
)paren
)paren
(brace
m_wchar_t
id|wcu
op_assign
id|wc
suffix:semicolon
r_if
c_cond
(paren
id|iswlower
(paren
id|wc
)paren
)paren
(brace
r_int
id|mbcdlen
suffix:semicolon
id|wcu
op_assign
id|towupper
(paren
id|wc
)paren
suffix:semicolon
id|mbcdlen
op_assign
id|wcrtomb
(paren
id|buf
comma
id|wcu
comma
op_amp
id|prev_st
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|mbclen
op_eq
id|mbcdlen
comma
l_int|1
)paren
)paren
id|memcpy
(paren
id|pstr-&gt;mbs
op_plus
id|byte_idx
comma
id|buf
comma
id|mbclen
)paren
suffix:semicolon
r_else
(brace
id|src_idx
op_assign
id|byte_idx
suffix:semicolon
r_goto
id|offsets_needed
suffix:semicolon
)brace
)brace
r_else
id|memcpy
(paren
id|pstr-&gt;mbs
op_plus
id|byte_idx
comma
id|pstr-&gt;raw_mbs
op_plus
id|pstr-&gt;raw_mbs_idx
op_plus
id|byte_idx
comma
id|mbclen
)paren
suffix:semicolon
id|pstr-&gt;wcs
(braket
id|byte_idx
op_increment
)braket
op_assign
id|wcu
suffix:semicolon
multiline_comment|/* Write paddings.  */
r_for
c_loop
(paren
id|remain_len
op_assign
id|byte_idx
op_plus
id|mbclen
l_int|1
suffix:semicolon
id|byte_idx
OL
id|remain_len
suffix:semicolon
)paren
id|pstr-&gt;wcs
(braket
id|byte_idx
op_increment
)braket
op_assign
id|WEOF
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|mbclen
op_eq
(paren
r_int
)paren
l_int|1
op_logical_or
id|mbclen
op_eq
l_int|0
)paren
(brace
multiline_comment|/* It is an invalid character or &squot;&bslash;0&squot;.  Just use the byte.  */
r_int
id|ch
op_assign
id|pstr-&gt;raw_mbs
(braket
id|pstr-&gt;raw_mbs_idx
op_plus
id|byte_idx
)braket
suffix:semicolon
id|pstr-&gt;mbs
(braket
id|byte_idx
)braket
op_assign
id|ch
suffix:semicolon
multiline_comment|/* And also cast it to wide char.  */
id|pstr-&gt;wcs
(braket
id|byte_idx
op_increment
)braket
op_assign
(paren
m_wchar_t
)paren
id|ch
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|mbclen
op_eq
(paren
r_int
)paren
l_int|1
comma
l_int|0
)paren
)paren
id|pstr-&gt;cur_state
op_assign
id|prev_st
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* The buffer doesn&squot;t have enough space, finish to build.  */
id|pstr-&gt;cur_state
op_assign
id|prev_st
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|pstr-&gt;valid_len
op_assign
id|byte_idx
suffix:semicolon
id|pstr-&gt;valid_raw_len
op_assign
id|byte_idx
suffix:semicolon
r_return
id|REG_NOERROR
suffix:semicolon
)brace
r_else
r_for
c_loop
(paren
id|src_idx
op_assign
id|pstr-&gt;valid_raw_len
suffix:semicolon
id|byte_idx
OL
id|end_idx
suffix:semicolon
)paren
(brace
m_wchar_t
id|wc
suffix:semicolon
r_const
r_char
op_star
id|p
suffix:semicolon
id|offsets_needed
suffix:colon
id|remain_len
op_assign
id|end_idx
id|byte_idx
suffix:semicolon
id|prev_st
op_assign
id|pstr-&gt;cur_state
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|pstr-&gt;trans
op_ne
l_int|NULL
comma
l_int|0
)paren
)paren
(brace
r_int
id|i
comma
id|ch
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pstr-&gt;mb_cur_max
op_logical_and
id|i
OL
id|remain_len
suffix:semicolon
op_increment
id|i
)paren
(brace
id|ch
op_assign
id|pstr-&gt;raw_mbs
(braket
id|pstr-&gt;raw_mbs_idx
op_plus
id|src_idx
op_plus
id|i
)braket
suffix:semicolon
id|buf
(braket
id|i
)braket
op_assign
id|pstr-&gt;trans
(braket
id|ch
)braket
suffix:semicolon
)brace
id|p
op_assign
(paren
r_const
r_char
op_star
)paren
id|buf
suffix:semicolon
)brace
r_else
id|p
op_assign
(paren
r_const
r_char
op_star
)paren
id|pstr-&gt;raw_mbs
op_plus
id|pstr-&gt;raw_mbs_idx
op_plus
id|src_idx
suffix:semicolon
id|mbclen
op_assign
id|__mbrtowc
(paren
op_amp
id|wc
comma
id|p
comma
id|remain_len
comma
op_amp
id|pstr-&gt;cur_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|mbclen
op_plus
l_int|2
OG
l_int|2
comma
l_int|1
)paren
)paren
(brace
m_wchar_t
id|wcu
op_assign
id|wc
suffix:semicolon
r_if
c_cond
(paren
id|iswlower
(paren
id|wc
)paren
)paren
(brace
r_int
id|mbcdlen
suffix:semicolon
id|wcu
op_assign
id|towupper
(paren
id|wc
)paren
suffix:semicolon
id|mbcdlen
op_assign
id|wcrtomb
(paren
(paren
r_char
op_star
)paren
id|buf
comma
id|wcu
comma
op_amp
id|prev_st
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|mbclen
op_eq
id|mbcdlen
comma
l_int|1
)paren
)paren
id|memcpy
(paren
id|pstr-&gt;mbs
op_plus
id|byte_idx
comma
id|buf
comma
id|mbclen
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|mbcdlen
op_ne
(paren
r_int
)paren
l_int|1
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|byte_idx
op_plus
id|mbcdlen
OG
id|pstr-&gt;bufs_len
)paren
(brace
id|pstr-&gt;cur_state
op_assign
id|prev_st
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pstr-&gt;offsets
op_eq
l_int|NULL
)paren
(brace
id|pstr-&gt;offsets
op_assign
id|re_malloc
(paren
r_int
comma
id|pstr-&gt;bufs_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pstr-&gt;offsets
op_eq
l_int|NULL
)paren
r_return
id|REG_ESPACE
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|pstr-&gt;offsets_needed
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
r_int
)paren
id|byte_idx
suffix:semicolon
op_increment
id|i
)paren
id|pstr-&gt;offsets
(braket
id|i
)braket
op_assign
id|i
suffix:semicolon
id|pstr-&gt;offsets_needed
op_assign
l_int|1
suffix:semicolon
)brace
id|memcpy
(paren
id|pstr-&gt;mbs
op_plus
id|byte_idx
comma
id|buf
comma
id|mbcdlen
)paren
suffix:semicolon
id|pstr-&gt;wcs
(braket
id|byte_idx
)braket
op_assign
id|wcu
suffix:semicolon
id|pstr-&gt;offsets
(braket
id|byte_idx
)braket
op_assign
id|src_idx
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|mbcdlen
suffix:semicolon
op_increment
id|i
)paren
(brace
id|pstr-&gt;offsets
(braket
id|byte_idx
op_plus
id|i
)braket
op_assign
id|src_idx
op_plus
(paren
id|i
OL
id|mbclen
ques
c_cond
id|i
suffix:colon
id|mbclen
l_int|1
)paren
suffix:semicolon
id|pstr-&gt;wcs
(braket
id|byte_idx
op_plus
id|i
)braket
op_assign
id|WEOF
suffix:semicolon
)brace
id|pstr-&gt;len
op_add_assign
id|mbcdlen
id|mbclen
suffix:semicolon
r_if
c_cond
(paren
id|pstr-&gt;raw_stop
OG
id|src_idx
)paren
id|pstr-&gt;stop
op_add_assign
id|mbcdlen
id|mbclen
suffix:semicolon
id|end_idx
op_assign
(paren
id|pstr-&gt;bufs_len
OG
id|pstr-&gt;len
)paren
ques
c_cond
id|pstr-&gt;len
suffix:colon
id|pstr-&gt;bufs_len
suffix:semicolon
id|byte_idx
op_add_assign
id|mbcdlen
suffix:semicolon
id|src_idx
op_add_assign
id|mbclen
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
id|memcpy
(paren
id|pstr-&gt;mbs
op_plus
id|byte_idx
comma
id|p
comma
id|mbclen
)paren
suffix:semicolon
)brace
r_else
id|memcpy
(paren
id|pstr-&gt;mbs
op_plus
id|byte_idx
comma
id|p
comma
id|mbclen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|pstr-&gt;offsets_needed
op_ne
l_int|0
comma
l_int|0
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mbclen
suffix:semicolon
op_increment
id|i
)paren
id|pstr-&gt;offsets
(braket
id|byte_idx
op_plus
id|i
)braket
op_assign
id|src_idx
op_plus
id|i
suffix:semicolon
)brace
id|src_idx
op_add_assign
id|mbclen
suffix:semicolon
id|pstr-&gt;wcs
(braket
id|byte_idx
op_increment
)braket
op_assign
id|wcu
suffix:semicolon
multiline_comment|/* Write paddings.  */
r_for
c_loop
(paren
id|remain_len
op_assign
id|byte_idx
op_plus
id|mbclen
l_int|1
suffix:semicolon
id|byte_idx
OL
id|remain_len
suffix:semicolon
)paren
id|pstr-&gt;wcs
(braket
id|byte_idx
op_increment
)braket
op_assign
id|WEOF
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|mbclen
op_eq
(paren
r_int
)paren
l_int|1
op_logical_or
id|mbclen
op_eq
l_int|0
)paren
(brace
multiline_comment|/* It is an invalid character or &squot;&bslash;0&squot;.  Just use the byte.  */
r_int
id|ch
op_assign
id|pstr-&gt;raw_mbs
(braket
id|pstr-&gt;raw_mbs_idx
op_plus
id|src_idx
)braket
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|pstr-&gt;trans
op_ne
l_int|NULL
comma
l_int|0
)paren
)paren
id|ch
op_assign
id|pstr-&gt;trans
(braket
id|ch
)braket
suffix:semicolon
id|pstr-&gt;mbs
(braket
id|byte_idx
)braket
op_assign
id|ch
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|pstr-&gt;offsets_needed
op_ne
l_int|0
comma
l_int|0
)paren
)paren
id|pstr-&gt;offsets
(braket
id|byte_idx
)braket
op_assign
id|src_idx
suffix:semicolon
op_increment
id|src_idx
suffix:semicolon
multiline_comment|/* And also cast it to wide char.  */
id|pstr-&gt;wcs
(braket
id|byte_idx
op_increment
)braket
op_assign
(paren
m_wchar_t
)paren
id|ch
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|mbclen
op_eq
(paren
r_int
)paren
l_int|1
comma
l_int|0
)paren
)paren
id|pstr-&gt;cur_state
op_assign
id|prev_st
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* The buffer doesn&squot;t have enough space, finish to build.  */
id|pstr-&gt;cur_state
op_assign
id|prev_st
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|pstr-&gt;valid_len
op_assign
id|byte_idx
suffix:semicolon
id|pstr-&gt;valid_raw_len
op_assign
id|src_idx
suffix:semicolon
r_return
id|REG_NOERROR
suffix:semicolon
)brace
multiline_comment|/* Skip characters until the index becomes greater than NEW_RAW_IDX.&n;   Return the index.  */
r_static
r_int
id|internal_function
DECL|function|re_string_skip_chars
id|re_string_skip_chars
(paren
id|re_string_t
op_star
id|pstr
comma
r_int
id|new_raw_idx
comma
id|wint_t
op_star
id|last_wc
)paren
(brace
id|mbstate_t
id|prev_st
suffix:semicolon
r_int
id|rawbuf_idx
suffix:semicolon
r_int
id|mbclen
suffix:semicolon
id|wint_t
id|wc
op_assign
id|WEOF
suffix:semicolon
multiline_comment|/* Skip the characters which are not necessary to check.  */
r_for
c_loop
(paren
id|rawbuf_idx
op_assign
id|pstr-&gt;raw_mbs_idx
op_plus
id|pstr-&gt;valid_raw_len
suffix:semicolon
id|rawbuf_idx
OL
id|new_raw_idx
suffix:semicolon
)paren
(brace
m_wchar_t
id|wc2
suffix:semicolon
r_int
id|remain_len
op_assign
id|pstr-&gt;len
id|rawbuf_idx
suffix:semicolon
id|prev_st
op_assign
id|pstr-&gt;cur_state
suffix:semicolon
id|mbclen
op_assign
id|__mbrtowc
(paren
op_amp
id|wc2
comma
(paren
r_const
r_char
op_star
)paren
id|pstr-&gt;raw_mbs
op_plus
id|rawbuf_idx
comma
id|remain_len
comma
op_amp
id|pstr-&gt;cur_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|mbclen
op_eq
(paren
r_int
)paren
l_int|2
op_logical_or
id|mbclen
op_eq
(paren
r_int
)paren
l_int|1
op_logical_or
id|mbclen
op_eq
l_int|0
comma
l_int|0
)paren
)paren
(brace
multiline_comment|/* We treat these cases as a single byte character.  */
r_if
c_cond
(paren
id|mbclen
op_eq
l_int|0
op_logical_or
id|remain_len
op_eq
l_int|0
)paren
id|wc
op_assign
id|L
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_else
id|wc
op_assign
op_star
(paren
r_int
r_char
op_star
)paren
(paren
id|pstr-&gt;raw_mbs
op_plus
id|rawbuf_idx
)paren
suffix:semicolon
id|mbclen
op_assign
l_int|1
suffix:semicolon
id|pstr-&gt;cur_state
op_assign
id|prev_st
suffix:semicolon
)brace
r_else
id|wc
op_assign
(paren
id|wint_t
)paren
id|wc2
suffix:semicolon
multiline_comment|/* Then proceed the next character.  */
id|rawbuf_idx
op_add_assign
id|mbclen
suffix:semicolon
)brace
op_star
id|last_wc
op_assign
(paren
id|wint_t
)paren
id|wc
suffix:semicolon
r_return
id|rawbuf_idx
suffix:semicolon
)brace
macro_line|#endif /* RE_ENABLE_I18N  */
multiline_comment|/* Build the buffer PSTR-&gt;MBS, and apply the translation if we need.&n;   This function is used in case of REG_ICASE.  */
r_static
r_void
id|internal_function
DECL|function|build_upper_buffer
id|build_upper_buffer
(paren
id|re_string_t
op_star
id|pstr
)paren
(brace
r_int
id|char_idx
comma
id|end_idx
suffix:semicolon
id|end_idx
op_assign
(paren
id|pstr-&gt;bufs_len
OG
id|pstr-&gt;len
)paren
ques
c_cond
id|pstr-&gt;len
suffix:colon
id|pstr-&gt;bufs_len
suffix:semicolon
r_for
c_loop
(paren
id|char_idx
op_assign
id|pstr-&gt;valid_len
suffix:semicolon
id|char_idx
OL
id|end_idx
suffix:semicolon
op_increment
id|char_idx
)paren
(brace
r_int
id|ch
op_assign
id|pstr-&gt;raw_mbs
(braket
id|pstr-&gt;raw_mbs_idx
op_plus
id|char_idx
)braket
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|pstr-&gt;trans
op_ne
l_int|NULL
comma
l_int|0
)paren
)paren
id|ch
op_assign
id|pstr-&gt;trans
(braket
id|ch
)braket
suffix:semicolon
r_if
c_cond
(paren
id|islower
(paren
id|ch
)paren
)paren
id|pstr-&gt;mbs
(braket
id|char_idx
)braket
op_assign
id|toupper
(paren
id|ch
)paren
suffix:semicolon
r_else
id|pstr-&gt;mbs
(braket
id|char_idx
)braket
op_assign
id|ch
suffix:semicolon
)brace
id|pstr-&gt;valid_len
op_assign
id|char_idx
suffix:semicolon
id|pstr-&gt;valid_raw_len
op_assign
id|char_idx
suffix:semicolon
)brace
multiline_comment|/* Apply TRANS to the buffer in PSTR.  */
r_static
r_void
id|internal_function
DECL|function|re_string_translate_buffer
id|re_string_translate_buffer
(paren
id|re_string_t
op_star
id|pstr
)paren
(brace
r_int
id|buf_idx
comma
id|end_idx
suffix:semicolon
id|end_idx
op_assign
(paren
id|pstr-&gt;bufs_len
OG
id|pstr-&gt;len
)paren
ques
c_cond
id|pstr-&gt;len
suffix:colon
id|pstr-&gt;bufs_len
suffix:semicolon
r_for
c_loop
(paren
id|buf_idx
op_assign
id|pstr-&gt;valid_len
suffix:semicolon
id|buf_idx
OL
id|end_idx
suffix:semicolon
op_increment
id|buf_idx
)paren
(brace
r_int
id|ch
op_assign
id|pstr-&gt;raw_mbs
(braket
id|pstr-&gt;raw_mbs_idx
op_plus
id|buf_idx
)braket
suffix:semicolon
id|pstr-&gt;mbs
(braket
id|buf_idx
)braket
op_assign
id|pstr-&gt;trans
(braket
id|ch
)braket
suffix:semicolon
)brace
id|pstr-&gt;valid_len
op_assign
id|buf_idx
suffix:semicolon
id|pstr-&gt;valid_raw_len
op_assign
id|buf_idx
suffix:semicolon
)brace
multiline_comment|/* This function re-construct the buffers.&n;   Concretely, convert to wide character in case of pstr-&gt;mb_cur_max &gt; 1,&n;   convert to upper case in case of REG_ICASE, apply translation.  */
r_static
id|reg_errcode_t
id|internal_function
DECL|function|re_string_reconstruct
id|re_string_reconstruct
(paren
id|re_string_t
op_star
id|pstr
comma
r_int
id|idx
comma
r_int
id|eflags
)paren
(brace
r_int
id|offset
op_assign
id|idx
id|pstr-&gt;raw_mbs_idx
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|offset
OL
l_int|0
comma
l_int|0
)paren
)paren
(brace
multiline_comment|/* Reset buffer.  */
macro_line|#ifdef RE_ENABLE_I18N
r_if
c_cond
(paren
id|pstr-&gt;mb_cur_max
OG
l_int|1
)paren
id|memset
(paren
op_amp
id|pstr-&gt;cur_state
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|mbstate_t
)paren
)paren
suffix:semicolon
macro_line|#endif /* RE_ENABLE_I18N */
id|pstr-&gt;len
op_assign
id|pstr-&gt;raw_len
suffix:semicolon
id|pstr-&gt;stop
op_assign
id|pstr-&gt;raw_stop
suffix:semicolon
id|pstr-&gt;valid_len
op_assign
l_int|0
suffix:semicolon
id|pstr-&gt;raw_mbs_idx
op_assign
l_int|0
suffix:semicolon
id|pstr-&gt;valid_raw_len
op_assign
l_int|0
suffix:semicolon
id|pstr-&gt;offsets_needed
op_assign
l_int|0
suffix:semicolon
id|pstr-&gt;tip_context
op_assign
(paren
(paren
id|eflags
op_amp
id|REG_NOTBOL
)paren
ques
c_cond
id|CONTEXT_BEGBUF
suffix:colon
id|CONTEXT_NEWLINE
op_or
id|CONTEXT_BEGBUF
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pstr-&gt;mbs_allocated
)paren
id|pstr-&gt;mbs
op_assign
(paren
r_int
r_char
op_star
)paren
id|pstr-&gt;raw_mbs
suffix:semicolon
id|offset
op_assign
id|idx
suffix:semicolon
)brace
r_if
c_cond
(paren
id|BE
(paren
id|offset
op_ne
l_int|0
comma
l_int|1
)paren
)paren
(brace
multiline_comment|/* Should the already checked characters be kept?  */
r_if
c_cond
(paren
id|BE
(paren
id|offset
OL
id|pstr-&gt;valid_raw_len
comma
l_int|1
)paren
)paren
(brace
multiline_comment|/* Yes, move them to the front of the buffer.  */
macro_line|#ifdef RE_ENABLE_I18N
r_if
c_cond
(paren
id|BE
(paren
id|pstr-&gt;offsets_needed
comma
l_int|0
)paren
)paren
(brace
r_int
id|low
op_assign
l_int|0
comma
id|high
op_assign
id|pstr-&gt;valid_len
comma
id|mid
suffix:semicolon
r_do
(brace
id|mid
op_assign
(paren
id|high
op_plus
id|low
)paren
op_div
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|pstr-&gt;offsets
(braket
id|mid
)braket
OG
id|offset
)paren
id|high
op_assign
id|mid
suffix:semicolon
r_else
r_if
c_cond
(paren
id|pstr-&gt;offsets
(braket
id|mid
)braket
OL
id|offset
)paren
id|low
op_assign
id|mid
op_plus
l_int|1
suffix:semicolon
r_else
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
id|low
OL
id|high
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pstr-&gt;offsets
(braket
id|mid
)braket
OL
id|offset
)paren
op_increment
id|mid
suffix:semicolon
id|pstr-&gt;tip_context
op_assign
id|re_string_context_at
(paren
id|pstr
comma
id|mid
l_int|1
comma
id|eflags
)paren
suffix:semicolon
multiline_comment|/* This can be quite complicated, so handle specially&n;&t;&t; only the common and easy case where the character with&n;&t;&t; different length representation of lower and upper&n;&t;&t; case is present at or after offset.  */
r_if
c_cond
(paren
id|pstr-&gt;valid_len
OG
id|offset
op_logical_and
id|mid
op_eq
id|offset
op_logical_and
id|pstr-&gt;offsets
(braket
id|mid
)braket
op_eq
id|offset
)paren
(brace
id|memmove
(paren
id|pstr-&gt;wcs
comma
id|pstr-&gt;wcs
op_plus
id|offset
comma
(paren
id|pstr-&gt;valid_len
id|offset
)paren
op_star
r_sizeof
(paren
id|wint_t
)paren
)paren
suffix:semicolon
id|memmove
(paren
id|pstr-&gt;mbs
comma
id|pstr-&gt;mbs
op_plus
id|offset
comma
id|pstr-&gt;valid_len
id|offset
)paren
suffix:semicolon
id|pstr-&gt;valid_len
op_sub_assign
id|offset
suffix:semicolon
id|pstr-&gt;valid_raw_len
op_sub_assign
id|offset
suffix:semicolon
r_for
c_loop
(paren
id|low
op_assign
l_int|0
suffix:semicolon
id|low
OL
id|pstr-&gt;valid_len
suffix:semicolon
id|low
op_increment
)paren
id|pstr-&gt;offsets
(braket
id|low
)braket
op_assign
id|pstr-&gt;offsets
(braket
id|low
op_plus
id|offset
)braket
id|offset
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Otherwise, just find out how long the partial multibyte&n;&t;&t;     character at offset is and fill it with WEOF/255.  */
id|pstr-&gt;len
op_assign
id|pstr-&gt;raw_len
id|idx
op_plus
id|offset
suffix:semicolon
id|pstr-&gt;stop
op_assign
id|pstr-&gt;raw_stop
id|idx
op_plus
id|offset
suffix:semicolon
id|pstr-&gt;offsets_needed
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|mid
OG
l_int|0
op_logical_and
id|pstr-&gt;offsets
(braket
id|mid
l_int|1
)braket
op_eq
id|offset
)paren
op_decrement
id|mid
suffix:semicolon
r_while
c_loop
(paren
id|mid
OL
id|pstr-&gt;valid_len
)paren
r_if
c_cond
(paren
id|pstr-&gt;wcs
(braket
id|mid
)braket
op_ne
id|WEOF
)paren
r_break
suffix:semicolon
r_else
op_increment
id|mid
suffix:semicolon
r_if
c_cond
(paren
id|mid
op_eq
id|pstr-&gt;valid_len
)paren
id|pstr-&gt;valid_len
op_assign
l_int|0
suffix:semicolon
r_else
(brace
id|pstr-&gt;valid_len
op_assign
id|pstr-&gt;offsets
(braket
id|mid
)braket
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|pstr-&gt;valid_len
)paren
(brace
r_for
c_loop
(paren
id|low
op_assign
l_int|0
suffix:semicolon
id|low
OL
id|pstr-&gt;valid_len
suffix:semicolon
op_increment
id|low
)paren
id|pstr-&gt;wcs
(braket
id|low
)braket
op_assign
id|WEOF
suffix:semicolon
id|memset
(paren
id|pstr-&gt;mbs
comma
l_int|255
comma
id|pstr-&gt;valid_len
)paren
suffix:semicolon
)brace
)brace
id|pstr-&gt;valid_raw_len
op_assign
id|pstr-&gt;valid_len
suffix:semicolon
)brace
)brace
r_else
macro_line|#endif
(brace
id|pstr-&gt;tip_context
op_assign
id|re_string_context_at
(paren
id|pstr
comma
id|offset
l_int|1
comma
id|eflags
)paren
suffix:semicolon
macro_line|#ifdef RE_ENABLE_I18N
r_if
c_cond
(paren
id|pstr-&gt;mb_cur_max
OG
l_int|1
)paren
id|memmove
(paren
id|pstr-&gt;wcs
comma
id|pstr-&gt;wcs
op_plus
id|offset
comma
(paren
id|pstr-&gt;valid_len
id|offset
)paren
op_star
r_sizeof
(paren
id|wint_t
)paren
)paren
suffix:semicolon
macro_line|#endif /* RE_ENABLE_I18N */
r_if
c_cond
(paren
id|BE
(paren
id|pstr-&gt;mbs_allocated
comma
l_int|0
)paren
)paren
id|memmove
(paren
id|pstr-&gt;mbs
comma
id|pstr-&gt;mbs
op_plus
id|offset
comma
id|pstr-&gt;valid_len
id|offset
)paren
suffix:semicolon
id|pstr-&gt;valid_len
op_sub_assign
id|offset
suffix:semicolon
id|pstr-&gt;valid_raw_len
op_sub_assign
id|offset
suffix:semicolon
macro_line|#if DEBUG
m_assert
(paren
id|pstr-&gt;valid_len
OG
l_int|0
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
r_else
(brace
macro_line|#ifdef RE_ENABLE_I18N
multiline_comment|/* No, skip all characters until IDX.  */
r_int
id|prev_valid_len
op_assign
id|pstr-&gt;valid_len
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|pstr-&gt;offsets_needed
comma
l_int|0
)paren
)paren
(brace
id|pstr-&gt;len
op_assign
id|pstr-&gt;raw_len
id|idx
op_plus
id|offset
suffix:semicolon
id|pstr-&gt;stop
op_assign
id|pstr-&gt;raw_stop
id|idx
op_plus
id|offset
suffix:semicolon
id|pstr-&gt;offsets_needed
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
id|pstr-&gt;valid_len
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef RE_ENABLE_I18N
r_if
c_cond
(paren
id|pstr-&gt;mb_cur_max
OG
l_int|1
)paren
(brace
r_int
id|wcs_idx
suffix:semicolon
id|wint_t
id|wc
op_assign
id|WEOF
suffix:semicolon
r_if
c_cond
(paren
id|pstr-&gt;is_utf8
)paren
(brace
r_const
r_int
r_char
op_star
id|raw
comma
op_star
id|p
comma
op_star
id|end
suffix:semicolon
multiline_comment|/* Special case UTF-8.  Multi-byte chars start with any&n;&t;&t;     byte other than 0x80 - 0xbf.  */
id|raw
op_assign
id|pstr-&gt;raw_mbs
op_plus
id|pstr-&gt;raw_mbs_idx
suffix:semicolon
id|end
op_assign
id|raw
op_plus
(paren
id|offset
id|pstr-&gt;mb_cur_max
)paren
suffix:semicolon
r_if
c_cond
(paren
id|end
OL
id|pstr-&gt;raw_mbs
)paren
id|end
op_assign
id|pstr-&gt;raw_mbs
suffix:semicolon
id|p
op_assign
id|raw
op_plus
id|offset
l_int|1
suffix:semicolon
macro_line|#ifdef _LIBC
multiline_comment|/* We know the wchar_t encoding is UCS4, so for the simple&n;&t;&t;     case, ASCII characters, skip the conversion step.  */
r_if
c_cond
(paren
id|isascii
(paren
op_star
id|p
)paren
op_logical_and
id|BE
(paren
id|pstr-&gt;trans
op_eq
l_int|NULL
comma
l_int|1
)paren
)paren
(brace
id|memset
(paren
op_amp
id|pstr-&gt;cur_state
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|mbstate_t
)paren
)paren
suffix:semicolon
multiline_comment|/* pstr-&gt;valid_len = 0; */
id|wc
op_assign
(paren
m_wchar_t
)paren
op_star
id|p
suffix:semicolon
)brace
r_else
macro_line|#endif
r_for
c_loop
(paren
suffix:semicolon
id|p
op_ge
id|end
suffix:semicolon
op_decrement
id|p
)paren
r_if
c_cond
(paren
(paren
op_star
id|p
op_amp
l_int|0xc0
)paren
op_ne
l_int|0x80
)paren
(brace
id|mbstate_t
id|cur_state
suffix:semicolon
m_wchar_t
id|wc2
suffix:semicolon
r_int
id|mlen
op_assign
id|raw
op_plus
id|pstr-&gt;len
id|p
suffix:semicolon
r_int
r_char
id|buf
(braket
l_int|6
)braket
suffix:semicolon
r_int
id|mbclen
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|pstr-&gt;trans
op_ne
l_int|NULL
comma
l_int|0
)paren
)paren
(brace
r_int
id|i
op_assign
id|mlen
OL
l_int|6
ques
c_cond
id|mlen
suffix:colon
l_int|6
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|i
op_ge
l_int|0
)paren
id|buf
(braket
id|i
)braket
op_assign
id|pstr-&gt;trans
(braket
id|p
(braket
id|i
)braket
)braket
suffix:semicolon
)brace
multiline_comment|/* XXX Don&squot;t use mbrtowc, we know which conversion&n;&t;&t;&t;     to use (UTF-8 -&gt; UCS4).  */
id|memset
(paren
op_amp
id|cur_state
comma
l_int|0
comma
r_sizeof
(paren
id|cur_state
)paren
)paren
suffix:semicolon
id|mbclen
op_assign
id|__mbrtowc
(paren
op_amp
id|wc2
comma
(paren
r_const
r_char
op_star
)paren
id|p
comma
id|mlen
comma
op_amp
id|cur_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|raw
op_plus
id|offset
id|p
op_le
id|mbclen
op_logical_and
id|mbclen
OL
(paren
r_int
)paren
l_int|2
)paren
(brace
id|memset
(paren
op_amp
id|pstr-&gt;cur_state
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|mbstate_t
)paren
)paren
suffix:semicolon
id|pstr-&gt;valid_len
op_assign
id|mbclen
(paren
id|raw
op_plus
id|offset
id|p
)paren
suffix:semicolon
id|wc
op_assign
id|wc2
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|wc
op_eq
id|WEOF
)paren
id|pstr-&gt;valid_len
op_assign
id|re_string_skip_chars
(paren
id|pstr
comma
id|idx
comma
op_amp
id|wc
)paren
id|idx
suffix:semicolon
r_if
c_cond
(paren
id|wc
op_eq
id|WEOF
)paren
id|pstr-&gt;tip_context
op_assign
id|re_string_context_at
(paren
id|pstr
comma
id|prev_valid_len
l_int|1
comma
id|eflags
)paren
suffix:semicolon
r_else
id|pstr-&gt;tip_context
op_assign
(paren
(paren
id|BE
(paren
id|pstr-&gt;word_ops_used
op_ne
l_int|0
comma
l_int|0
)paren
op_logical_and
id|IS_WIDE_WORD_CHAR
(paren
id|wc
)paren
)paren
ques
c_cond
id|CONTEXT_WORD
suffix:colon
(paren
(paren
id|IS_WIDE_NEWLINE
(paren
id|wc
)paren
op_logical_and
id|pstr-&gt;newline_anchor
)paren
ques
c_cond
id|CONTEXT_NEWLINE
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|pstr-&gt;valid_len
comma
l_int|0
)paren
)paren
(brace
r_for
c_loop
(paren
id|wcs_idx
op_assign
l_int|0
suffix:semicolon
id|wcs_idx
OL
id|pstr-&gt;valid_len
suffix:semicolon
op_increment
id|wcs_idx
)paren
id|pstr-&gt;wcs
(braket
id|wcs_idx
)braket
op_assign
id|WEOF
suffix:semicolon
r_if
c_cond
(paren
id|pstr-&gt;mbs_allocated
)paren
id|memset
(paren
id|pstr-&gt;mbs
comma
l_int|255
comma
id|pstr-&gt;valid_len
)paren
suffix:semicolon
)brace
id|pstr-&gt;valid_raw_len
op_assign
id|pstr-&gt;valid_len
suffix:semicolon
)brace
r_else
macro_line|#endif /* RE_ENABLE_I18N */
(brace
r_int
id|c
op_assign
id|pstr-&gt;raw_mbs
(braket
id|pstr-&gt;raw_mbs_idx
op_plus
id|offset
l_int|1
)braket
suffix:semicolon
id|pstr-&gt;valid_raw_len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pstr-&gt;trans
)paren
id|c
op_assign
id|pstr-&gt;trans
(braket
id|c
)braket
suffix:semicolon
id|pstr-&gt;tip_context
op_assign
(paren
id|bitset_contain
(paren
id|pstr-&gt;word_char
comma
id|c
)paren
ques
c_cond
id|CONTEXT_WORD
suffix:colon
(paren
(paren
id|IS_NEWLINE
(paren
id|c
)paren
op_logical_and
id|pstr-&gt;newline_anchor
)paren
ques
c_cond
id|CONTEXT_NEWLINE
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|BE
(paren
id|pstr-&gt;mbs_allocated
comma
l_int|0
)paren
)paren
id|pstr-&gt;mbs
op_add_assign
id|offset
suffix:semicolon
)brace
id|pstr-&gt;raw_mbs_idx
op_assign
id|idx
suffix:semicolon
id|pstr-&gt;len
op_sub_assign
id|offset
suffix:semicolon
id|pstr-&gt;stop
op_sub_assign
id|offset
suffix:semicolon
multiline_comment|/* Then build the buffers.  */
macro_line|#ifdef RE_ENABLE_I18N
r_if
c_cond
(paren
id|pstr-&gt;mb_cur_max
OG
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|pstr-&gt;icase
)paren
(brace
id|reg_errcode_t
id|ret
op_assign
id|build_wcs_upper_buffer
(paren
id|pstr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|ret
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|ret
suffix:semicolon
)brace
r_else
id|build_wcs_buffer
(paren
id|pstr
)paren
suffix:semicolon
)brace
r_else
macro_line|#endif /* RE_ENABLE_I18N */
r_if
c_cond
(paren
id|BE
(paren
id|pstr-&gt;mbs_allocated
comma
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|pstr-&gt;icase
)paren
id|build_upper_buffer
(paren
id|pstr
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|pstr-&gt;trans
op_ne
l_int|NULL
)paren
id|re_string_translate_buffer
(paren
id|pstr
)paren
suffix:semicolon
)brace
r_else
id|pstr-&gt;valid_len
op_assign
id|pstr-&gt;len
suffix:semicolon
id|pstr-&gt;cur_idx
op_assign
l_int|0
suffix:semicolon
r_return
id|REG_NOERROR
suffix:semicolon
)brace
r_static
r_int
r_char
id|internal_function
id|__attribute
(paren
(paren
id|pure
)paren
)paren
DECL|function|re_string_peek_byte_case
id|re_string_peek_byte_case
(paren
r_const
id|re_string_t
op_star
id|pstr
comma
r_int
id|idx
)paren
(brace
r_int
id|ch
comma
id|off
suffix:semicolon
multiline_comment|/* Handle the common (easiest) cases first.  */
r_if
c_cond
(paren
id|BE
(paren
op_logical_neg
id|pstr-&gt;mbs_allocated
comma
l_int|1
)paren
)paren
r_return
id|re_string_peek_byte
(paren
id|pstr
comma
id|idx
)paren
suffix:semicolon
macro_line|#ifdef RE_ENABLE_I18N
r_if
c_cond
(paren
id|pstr-&gt;mb_cur_max
OG
l_int|1
op_logical_and
op_logical_neg
id|re_string_is_single_byte_char
(paren
id|pstr
comma
id|pstr-&gt;cur_idx
op_plus
id|idx
)paren
)paren
r_return
id|re_string_peek_byte
(paren
id|pstr
comma
id|idx
)paren
suffix:semicolon
macro_line|#endif
id|off
op_assign
id|pstr-&gt;cur_idx
op_plus
id|idx
suffix:semicolon
macro_line|#ifdef RE_ENABLE_I18N
r_if
c_cond
(paren
id|pstr-&gt;offsets_needed
)paren
id|off
op_assign
id|pstr-&gt;offsets
(braket
id|off
)braket
suffix:semicolon
macro_line|#endif
id|ch
op_assign
id|pstr-&gt;raw_mbs
(braket
id|pstr-&gt;raw_mbs_idx
op_plus
id|off
)braket
suffix:semicolon
macro_line|#ifdef RE_ENABLE_I18N
multiline_comment|/* Ensure that e.g. for tr_TR.UTF-8 BACKSLASH DOTLESS SMALL LETTER I&n;     this function returns CAPITAL LETTER I instead of first byte of&n;     DOTLESS SMALL LETTER I.  The latter would confuse the parser,&n;     since peek_byte_case doesn&squot;t advance cur_idx in any way.  */
r_if
c_cond
(paren
id|pstr-&gt;offsets_needed
op_logical_and
op_logical_neg
id|isascii
(paren
id|ch
)paren
)paren
r_return
id|re_string_peek_byte
(paren
id|pstr
comma
id|idx
)paren
suffix:semicolon
macro_line|#endif
r_return
id|ch
suffix:semicolon
)brace
r_static
r_int
r_char
id|internal_function
id|__attribute
(paren
(paren
id|pure
)paren
)paren
DECL|function|re_string_fetch_byte_case
id|re_string_fetch_byte_case
(paren
id|re_string_t
op_star
id|pstr
)paren
(brace
r_if
c_cond
(paren
id|BE
(paren
op_logical_neg
id|pstr-&gt;mbs_allocated
comma
l_int|1
)paren
)paren
r_return
id|re_string_fetch_byte
(paren
id|pstr
)paren
suffix:semicolon
macro_line|#ifdef RE_ENABLE_I18N
r_if
c_cond
(paren
id|pstr-&gt;offsets_needed
)paren
(brace
r_int
id|off
comma
id|ch
suffix:semicolon
multiline_comment|/* For tr_TR.UTF-8 [[:islower:]] there is&n;&t; [[: CAPITAL LETTER I WITH DOT lower:]] in mbs.  Skip&n;&t; in that case the whole multi-byte character and return&n;&t; the original letter.  On the other side, with&n;&t; [[: DOTLESS SMALL LETTER I return [[:I, as doing&n;&t; anything else would complicate things too much.  */
r_if
c_cond
(paren
op_logical_neg
id|re_string_first_byte
(paren
id|pstr
comma
id|pstr-&gt;cur_idx
)paren
)paren
r_return
id|re_string_fetch_byte
(paren
id|pstr
)paren
suffix:semicolon
id|off
op_assign
id|pstr-&gt;offsets
(braket
id|pstr-&gt;cur_idx
)braket
suffix:semicolon
id|ch
op_assign
id|pstr-&gt;raw_mbs
(braket
id|pstr-&gt;raw_mbs_idx
op_plus
id|off
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|isascii
(paren
id|ch
)paren
)paren
r_return
id|re_string_fetch_byte
(paren
id|pstr
)paren
suffix:semicolon
id|re_string_skip_bytes
(paren
id|pstr
comma
id|re_string_char_size_at
(paren
id|pstr
comma
id|pstr-&gt;cur_idx
)paren
)paren
suffix:semicolon
r_return
id|ch
suffix:semicolon
)brace
macro_line|#endif
r_return
id|pstr-&gt;raw_mbs
(braket
id|pstr-&gt;raw_mbs_idx
op_plus
id|pstr-&gt;cur_idx
op_increment
)braket
suffix:semicolon
)brace
r_static
r_void
id|internal_function
DECL|function|re_string_destruct
id|re_string_destruct
(paren
id|re_string_t
op_star
id|pstr
)paren
(brace
macro_line|#ifdef RE_ENABLE_I18N
id|re_free
(paren
id|pstr-&gt;wcs
)paren
suffix:semicolon
id|re_free
(paren
id|pstr-&gt;offsets
)paren
suffix:semicolon
macro_line|#endif /* RE_ENABLE_I18N  */
r_if
c_cond
(paren
id|pstr-&gt;mbs_allocated
)paren
id|re_free
(paren
id|pstr-&gt;mbs
)paren
suffix:semicolon
)brace
multiline_comment|/* Return the context at IDX in INPUT.  */
r_static
r_int
r_int
id|internal_function
DECL|function|re_string_context_at
id|re_string_context_at
(paren
r_const
id|re_string_t
op_star
id|input
comma
r_int
id|idx
comma
r_int
id|eflags
)paren
(brace
r_int
id|c
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|idx
OL
l_int|0
comma
l_int|0
)paren
)paren
multiline_comment|/* In this case, we use the value stored in input-&gt;tip_context,&n;       since we can&squot;t know the character in input-&gt;mbs[-1] here.  */
r_return
id|input-&gt;tip_context
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|idx
op_eq
id|input-&gt;len
comma
l_int|0
)paren
)paren
r_return
(paren
(paren
id|eflags
op_amp
id|REG_NOTEOL
)paren
ques
c_cond
id|CONTEXT_ENDBUF
suffix:colon
id|CONTEXT_NEWLINE
op_or
id|CONTEXT_ENDBUF
)paren
suffix:semicolon
macro_line|#ifdef RE_ENABLE_I18N
r_if
c_cond
(paren
id|input-&gt;mb_cur_max
OG
l_int|1
)paren
(brace
id|wint_t
id|wc
suffix:semicolon
r_int
id|wc_idx
op_assign
id|idx
suffix:semicolon
r_while
c_loop
(paren
id|input-&gt;wcs
(braket
id|wc_idx
)braket
op_eq
id|WEOF
)paren
(brace
macro_line|#ifdef DEBUG
multiline_comment|/* It must not happen.  */
m_assert
(paren
id|wc_idx
op_ge
l_int|0
)paren
suffix:semicolon
macro_line|#endif
op_decrement
id|wc_idx
suffix:semicolon
r_if
c_cond
(paren
id|wc_idx
OL
l_int|0
)paren
r_return
id|input-&gt;tip_context
suffix:semicolon
)brace
id|wc
op_assign
id|input-&gt;wcs
(braket
id|wc_idx
)braket
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|input-&gt;word_ops_used
op_ne
l_int|0
comma
l_int|0
)paren
op_logical_and
id|IS_WIDE_WORD_CHAR
(paren
id|wc
)paren
)paren
r_return
id|CONTEXT_WORD
suffix:semicolon
r_return
(paren
id|IS_WIDE_NEWLINE
(paren
id|wc
)paren
op_logical_and
id|input-&gt;newline_anchor
ques
c_cond
id|CONTEXT_NEWLINE
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
r_else
macro_line|#endif
(brace
id|c
op_assign
id|re_string_byte_at
(paren
id|input
comma
id|idx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bitset_contain
(paren
id|input-&gt;word_char
comma
id|c
)paren
)paren
r_return
id|CONTEXT_WORD
suffix:semicolon
r_return
id|IS_NEWLINE
(paren
id|c
)paren
op_logical_and
id|input-&gt;newline_anchor
ques
c_cond
id|CONTEXT_NEWLINE
suffix:colon
l_int|0
suffix:semicolon
)brace
)brace
"&f;"
multiline_comment|/* Functions for set operation.  */
r_static
id|reg_errcode_t
id|internal_function
DECL|function|re_node_set_alloc
id|re_node_set_alloc
(paren
id|re_node_set
op_star
id|set
comma
r_int
id|size
)paren
(brace
multiline_comment|/*&n;   * ADR: valgrind says size can be 0, which then doesn&squot;t&n;   * free the block of size 0.  Harumph. This seems&n;   * to work ok, though.&n;   */
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
(brace
id|memset
c_func
(paren
id|set
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|set
)paren
)paren
suffix:semicolon
r_return
id|REG_NOERROR
suffix:semicolon
)brace
id|set-&gt;alloc
op_assign
id|size
suffix:semicolon
id|set-&gt;nelem
op_assign
l_int|0
suffix:semicolon
id|set-&gt;elems
op_assign
id|re_malloc
(paren
r_int
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|set-&gt;elems
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
r_return
id|REG_NOERROR
suffix:semicolon
)brace
r_static
id|reg_errcode_t
id|internal_function
DECL|function|re_node_set_init_1
id|re_node_set_init_1
(paren
id|re_node_set
op_star
id|set
comma
r_int
id|elem
)paren
(brace
id|set-&gt;alloc
op_assign
l_int|1
suffix:semicolon
id|set-&gt;nelem
op_assign
l_int|1
suffix:semicolon
id|set-&gt;elems
op_assign
id|re_malloc
(paren
r_int
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|set-&gt;elems
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
(brace
id|set-&gt;alloc
op_assign
id|set-&gt;nelem
op_assign
l_int|0
suffix:semicolon
r_return
id|REG_ESPACE
suffix:semicolon
)brace
id|set-&gt;elems
(braket
l_int|0
)braket
op_assign
id|elem
suffix:semicolon
r_return
id|REG_NOERROR
suffix:semicolon
)brace
r_static
id|reg_errcode_t
id|internal_function
DECL|function|re_node_set_init_2
id|re_node_set_init_2
(paren
id|re_node_set
op_star
id|set
comma
r_int
id|elem1
comma
r_int
id|elem2
)paren
(brace
id|set-&gt;alloc
op_assign
l_int|2
suffix:semicolon
id|set-&gt;elems
op_assign
id|re_malloc
(paren
r_int
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|set-&gt;elems
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
r_if
c_cond
(paren
id|elem1
op_eq
id|elem2
)paren
(brace
id|set-&gt;nelem
op_assign
l_int|1
suffix:semicolon
id|set-&gt;elems
(braket
l_int|0
)braket
op_assign
id|elem1
suffix:semicolon
)brace
r_else
(brace
id|set-&gt;nelem
op_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|elem1
OL
id|elem2
)paren
(brace
id|set-&gt;elems
(braket
l_int|0
)braket
op_assign
id|elem1
suffix:semicolon
id|set-&gt;elems
(braket
l_int|1
)braket
op_assign
id|elem2
suffix:semicolon
)brace
r_else
(brace
id|set-&gt;elems
(braket
l_int|0
)braket
op_assign
id|elem2
suffix:semicolon
id|set-&gt;elems
(braket
l_int|1
)braket
op_assign
id|elem1
suffix:semicolon
)brace
)brace
r_return
id|REG_NOERROR
suffix:semicolon
)brace
r_static
id|reg_errcode_t
id|internal_function
DECL|function|re_node_set_init_copy
id|re_node_set_init_copy
(paren
id|re_node_set
op_star
id|dest
comma
r_const
id|re_node_set
op_star
id|src
)paren
(brace
id|dest-&gt;nelem
op_assign
id|src-&gt;nelem
suffix:semicolon
r_if
c_cond
(paren
id|src-&gt;nelem
OG
l_int|0
)paren
(brace
id|dest-&gt;alloc
op_assign
id|dest-&gt;nelem
suffix:semicolon
id|dest-&gt;elems
op_assign
id|re_malloc
(paren
r_int
comma
id|dest-&gt;alloc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|dest-&gt;elems
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
(brace
id|dest-&gt;alloc
op_assign
id|dest-&gt;nelem
op_assign
l_int|0
suffix:semicolon
r_return
id|REG_ESPACE
suffix:semicolon
)brace
id|memcpy
(paren
id|dest-&gt;elems
comma
id|src-&gt;elems
comma
id|src-&gt;nelem
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
)brace
r_else
id|re_node_set_init_empty
(paren
id|dest
)paren
suffix:semicolon
r_return
id|REG_NOERROR
suffix:semicolon
)brace
multiline_comment|/* Calculate the intersection of the sets SRC1 and SRC2. And merge it to&n;   DEST. Return value indicate the error code or REG_NOERROR if succeeded.&n;   Note: We assume dest-&gt;elems is NULL, when dest-&gt;alloc is 0.  */
r_static
id|reg_errcode_t
id|internal_function
DECL|function|re_node_set_add_intersect
id|re_node_set_add_intersect
(paren
id|re_node_set
op_star
id|dest
comma
r_const
id|re_node_set
op_star
id|src1
comma
r_const
id|re_node_set
op_star
id|src2
)paren
(brace
r_int
id|i1
comma
id|i2
comma
id|is
comma
id|id
comma
id|delta
comma
id|sbase
suffix:semicolon
r_if
c_cond
(paren
id|src1-&gt;nelem
op_eq
l_int|0
op_logical_or
id|src2-&gt;nelem
op_eq
l_int|0
)paren
r_return
id|REG_NOERROR
suffix:semicolon
multiline_comment|/* We need dest-&gt;nelem + 2 * elems_in_intersection; this is a&n;     conservative estimate.  */
r_if
c_cond
(paren
id|src1-&gt;nelem
op_plus
id|src2-&gt;nelem
op_plus
id|dest-&gt;nelem
OG
id|dest-&gt;alloc
)paren
(brace
r_int
id|new_alloc
op_assign
id|src1-&gt;nelem
op_plus
id|src2-&gt;nelem
op_plus
id|dest-&gt;alloc
suffix:semicolon
r_int
op_star
id|new_elems
op_assign
id|re_realloc
(paren
id|dest-&gt;elems
comma
r_int
comma
id|new_alloc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|new_elems
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
id|dest-&gt;elems
op_assign
id|new_elems
suffix:semicolon
id|dest-&gt;alloc
op_assign
id|new_alloc
suffix:semicolon
)brace
multiline_comment|/* Find the items in the intersection of SRC1 and SRC2, and copy&n;     into the top of DEST those that are not already in DEST itself.  */
id|sbase
op_assign
id|dest-&gt;nelem
op_plus
id|src1-&gt;nelem
op_plus
id|src2-&gt;nelem
suffix:semicolon
id|i1
op_assign
id|src1-&gt;nelem
l_int|1
suffix:semicolon
id|i2
op_assign
id|src2-&gt;nelem
l_int|1
suffix:semicolon
id|id
op_assign
id|dest-&gt;nelem
l_int|1
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|src1-&gt;elems
(braket
id|i1
)braket
op_eq
id|src2-&gt;elems
(braket
id|i2
)braket
)paren
(brace
multiline_comment|/* Try to find the item in DEST.  Maybe we could binary search?  */
r_while
c_loop
(paren
id|id
op_ge
l_int|0
op_logical_and
id|dest-&gt;elems
(braket
id|id
)braket
OG
id|src1-&gt;elems
(braket
id|i1
)braket
)paren
op_decrement
id|id
suffix:semicolon
r_if
c_cond
(paren
id|id
OL
l_int|0
op_logical_or
id|dest-&gt;elems
(braket
id|id
)braket
op_ne
id|src1-&gt;elems
(braket
id|i1
)braket
)paren
id|dest-&gt;elems
(braket
op_decrement
id|sbase
)braket
op_assign
id|src1-&gt;elems
(braket
id|i1
)braket
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|i1
OL
l_int|0
op_logical_or
op_decrement
id|i2
OL
l_int|0
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* Lower the highest of the two items.  */
r_else
r_if
c_cond
(paren
id|src1-&gt;elems
(braket
id|i1
)braket
OL
id|src2-&gt;elems
(braket
id|i2
)braket
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|i2
OL
l_int|0
)paren
r_break
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_decrement
id|i1
OL
l_int|0
)paren
r_break
suffix:semicolon
)brace
)brace
id|id
op_assign
id|dest-&gt;nelem
l_int|1
suffix:semicolon
id|is
op_assign
id|dest-&gt;nelem
op_plus
id|src1-&gt;nelem
op_plus
id|src2-&gt;nelem
l_int|1
suffix:semicolon
id|delta
op_assign
id|is
id|sbase
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Now copy.  When DELTA becomes zero, the remaining&n;     DEST elements are already in place; this is more or&n;     less the same loop that is in re_node_set_merge.  */
id|dest-&gt;nelem
op_add_assign
id|delta
suffix:semicolon
r_if
c_cond
(paren
id|delta
OG
l_int|0
op_logical_and
id|id
op_ge
l_int|0
)paren
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|dest-&gt;elems
(braket
id|is
)braket
OG
id|dest-&gt;elems
(braket
id|id
)braket
)paren
(brace
multiline_comment|/* Copy from the top.  */
id|dest-&gt;elems
(braket
id|id
op_plus
id|delta
op_decrement
)braket
op_assign
id|dest-&gt;elems
(braket
id|is
op_decrement
)braket
suffix:semicolon
r_if
c_cond
(paren
id|delta
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Slide from the bottom.  */
id|dest-&gt;elems
(braket
id|id
op_plus
id|delta
)braket
op_assign
id|dest-&gt;elems
(braket
id|id
)braket
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|id
OL
l_int|0
)paren
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Copy remaining SRC elements.  */
id|memcpy
(paren
id|dest-&gt;elems
comma
id|dest-&gt;elems
op_plus
id|sbase
comma
id|delta
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_return
id|REG_NOERROR
suffix:semicolon
)brace
multiline_comment|/* Calculate the union set of the sets SRC1 and SRC2. And store it to&n;   DEST. Return value indicate the error code or REG_NOERROR if succeeded.  */
r_static
id|reg_errcode_t
id|internal_function
DECL|function|re_node_set_init_union
id|re_node_set_init_union
(paren
id|re_node_set
op_star
id|dest
comma
r_const
id|re_node_set
op_star
id|src1
comma
r_const
id|re_node_set
op_star
id|src2
)paren
(brace
r_int
id|i1
comma
id|i2
comma
id|id
suffix:semicolon
r_if
c_cond
(paren
id|src1
op_ne
l_int|NULL
op_logical_and
id|src1-&gt;nelem
OG
l_int|0
op_logical_and
id|src2
op_ne
l_int|NULL
op_logical_and
id|src2-&gt;nelem
OG
l_int|0
)paren
(brace
id|dest-&gt;alloc
op_assign
id|src1-&gt;nelem
op_plus
id|src2-&gt;nelem
suffix:semicolon
id|dest-&gt;elems
op_assign
id|re_malloc
(paren
r_int
comma
id|dest-&gt;alloc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|dest-&gt;elems
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|src1
op_ne
l_int|NULL
op_logical_and
id|src1-&gt;nelem
OG
l_int|0
)paren
r_return
id|re_node_set_init_copy
(paren
id|dest
comma
id|src1
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|src2
op_ne
l_int|NULL
op_logical_and
id|src2-&gt;nelem
OG
l_int|0
)paren
r_return
id|re_node_set_init_copy
(paren
id|dest
comma
id|src2
)paren
suffix:semicolon
r_else
id|re_node_set_init_empty
(paren
id|dest
)paren
suffix:semicolon
r_return
id|REG_NOERROR
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i1
op_assign
id|i2
op_assign
id|id
op_assign
l_int|0
suffix:semicolon
id|i1
OL
id|src1-&gt;nelem
op_logical_and
id|i2
OL
id|src2-&gt;nelem
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|src1-&gt;elems
(braket
id|i1
)braket
OG
id|src2-&gt;elems
(braket
id|i2
)braket
)paren
(brace
id|dest-&gt;elems
(braket
id|id
op_increment
)braket
op_assign
id|src2-&gt;elems
(braket
id|i2
op_increment
)braket
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|src1-&gt;elems
(braket
id|i1
)braket
op_eq
id|src2-&gt;elems
(braket
id|i2
)braket
)paren
op_increment
id|i2
suffix:semicolon
id|dest-&gt;elems
(braket
id|id
op_increment
)braket
op_assign
id|src1-&gt;elems
(braket
id|i1
op_increment
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i1
OL
id|src1-&gt;nelem
)paren
(brace
id|memcpy
(paren
id|dest-&gt;elems
op_plus
id|id
comma
id|src1-&gt;elems
op_plus
id|i1
comma
(paren
id|src1-&gt;nelem
id|i1
)paren
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
id|id
op_add_assign
id|src1-&gt;nelem
id|i1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|i2
OL
id|src2-&gt;nelem
)paren
(brace
id|memcpy
(paren
id|dest-&gt;elems
op_plus
id|id
comma
id|src2-&gt;elems
op_plus
id|i2
comma
(paren
id|src2-&gt;nelem
id|i2
)paren
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
id|id
op_add_assign
id|src2-&gt;nelem
id|i2
suffix:semicolon
)brace
id|dest-&gt;nelem
op_assign
id|id
suffix:semicolon
r_return
id|REG_NOERROR
suffix:semicolon
)brace
multiline_comment|/* Calculate the union set of the sets DEST and SRC. And store it to&n;   DEST. Return value indicate the error code or REG_NOERROR if succeeded.  */
r_static
id|reg_errcode_t
id|internal_function
DECL|function|re_node_set_merge
id|re_node_set_merge
(paren
id|re_node_set
op_star
id|dest
comma
r_const
id|re_node_set
op_star
id|src
)paren
(brace
r_int
id|is
comma
id|id
comma
id|sbase
comma
id|delta
suffix:semicolon
r_if
c_cond
(paren
id|src
op_eq
l_int|NULL
op_logical_or
id|src-&gt;nelem
op_eq
l_int|0
)paren
r_return
id|REG_NOERROR
suffix:semicolon
r_if
c_cond
(paren
id|dest-&gt;alloc
OL
l_int|2
op_star
id|src-&gt;nelem
op_plus
id|dest-&gt;nelem
)paren
(brace
r_int
id|new_alloc
op_assign
l_int|2
op_star
(paren
id|src-&gt;nelem
op_plus
id|dest-&gt;alloc
)paren
suffix:semicolon
r_int
op_star
id|new_buffer
op_assign
id|re_realloc
(paren
id|dest-&gt;elems
comma
r_int
comma
id|new_alloc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|new_buffer
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
id|dest-&gt;elems
op_assign
id|new_buffer
suffix:semicolon
id|dest-&gt;alloc
op_assign
id|new_alloc
suffix:semicolon
)brace
r_if
c_cond
(paren
id|BE
(paren
id|dest-&gt;nelem
op_eq
l_int|0
comma
l_int|0
)paren
)paren
(brace
id|dest-&gt;nelem
op_assign
id|src-&gt;nelem
suffix:semicolon
id|memcpy
(paren
id|dest-&gt;elems
comma
id|src-&gt;elems
comma
id|src-&gt;nelem
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_return
id|REG_NOERROR
suffix:semicolon
)brace
multiline_comment|/* Copy into the top of DEST the items of SRC that are not&n;     found in DEST.  Maybe we could binary search in DEST?  */
r_for
c_loop
(paren
id|sbase
op_assign
id|dest-&gt;nelem
op_plus
l_int|2
op_star
id|src-&gt;nelem
comma
id|is
op_assign
id|src-&gt;nelem
l_int|1
comma
id|id
op_assign
id|dest-&gt;nelem
l_int|1
suffix:semicolon
id|is
op_ge
l_int|0
op_logical_and
id|id
op_ge
l_int|0
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|dest-&gt;elems
(braket
id|id
)braket
op_eq
id|src-&gt;elems
(braket
id|is
)braket
)paren
id|is
op_decrement
comma
id|id
op_decrement
suffix:semicolon
r_else
r_if
c_cond
(paren
id|dest-&gt;elems
(braket
id|id
)braket
OL
id|src-&gt;elems
(braket
id|is
)braket
)paren
id|dest-&gt;elems
(braket
op_decrement
id|sbase
)braket
op_assign
id|src-&gt;elems
(braket
id|is
op_decrement
)braket
suffix:semicolon
r_else
multiline_comment|/* if (dest-&gt;elems[id] &gt; src-&gt;elems[is]) */
op_decrement
id|id
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is
op_ge
l_int|0
)paren
(brace
multiline_comment|/* If DEST is exhausted, the remaining items of SRC must be unique.  */
id|sbase
op_sub_assign
id|is
op_plus
l_int|1
suffix:semicolon
id|memcpy
(paren
id|dest-&gt;elems
op_plus
id|sbase
comma
id|src-&gt;elems
comma
(paren
id|is
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
)brace
id|id
op_assign
id|dest-&gt;nelem
l_int|1
suffix:semicolon
id|is
op_assign
id|dest-&gt;nelem
op_plus
l_int|2
op_star
id|src-&gt;nelem
l_int|1
suffix:semicolon
id|delta
op_assign
id|is
id|sbase
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|delta
op_eq
l_int|0
)paren
r_return
id|REG_NOERROR
suffix:semicolon
multiline_comment|/* Now copy.  When DELTA becomes zero, the remaining&n;     DEST elements are already in place.  */
id|dest-&gt;nelem
op_add_assign
id|delta
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|dest-&gt;elems
(braket
id|is
)braket
OG
id|dest-&gt;elems
(braket
id|id
)braket
)paren
(brace
multiline_comment|/* Copy from the top.  */
id|dest-&gt;elems
(braket
id|id
op_plus
id|delta
op_decrement
)braket
op_assign
id|dest-&gt;elems
(braket
id|is
op_decrement
)braket
suffix:semicolon
r_if
c_cond
(paren
id|delta
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Slide from the bottom.  */
id|dest-&gt;elems
(braket
id|id
op_plus
id|delta
)braket
op_assign
id|dest-&gt;elems
(braket
id|id
)braket
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|id
OL
l_int|0
)paren
(brace
multiline_comment|/* Copy remaining SRC elements.  */
id|memcpy
(paren
id|dest-&gt;elems
comma
id|dest-&gt;elems
op_plus
id|sbase
comma
id|delta
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_return
id|REG_NOERROR
suffix:semicolon
)brace
multiline_comment|/* Insert the new element ELEM to the re_node_set* SET.&n;   SET should not already have ELEM.&n;   return -1 if an error is occured, return 1 otherwise.  */
r_static
r_int
id|internal_function
DECL|function|re_node_set_insert
id|re_node_set_insert
(paren
id|re_node_set
op_star
id|set
comma
r_int
id|elem
)paren
(brace
r_int
id|idx
suffix:semicolon
multiline_comment|/* In case the set is empty.  */
r_if
c_cond
(paren
id|set-&gt;alloc
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|BE
(paren
id|re_node_set_init_1
(paren
id|set
comma
id|elem
)paren
op_eq
id|REG_NOERROR
comma
l_int|1
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_else
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|BE
(paren
id|set-&gt;nelem
comma
l_int|0
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* We already guaranteed above that set-&gt;alloc != 0.  */
id|set-&gt;elems
(braket
l_int|0
)braket
op_assign
id|elem
suffix:semicolon
op_increment
id|set-&gt;nelem
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Realloc if we need.  */
r_if
c_cond
(paren
id|set-&gt;alloc
op_eq
id|set-&gt;nelem
)paren
(brace
r_int
op_star
id|new_elems
suffix:semicolon
id|set-&gt;alloc
op_assign
id|set-&gt;alloc
op_star
l_int|2
suffix:semicolon
id|new_elems
op_assign
id|re_realloc
(paren
id|set-&gt;elems
comma
r_int
comma
id|set-&gt;alloc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|new_elems
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|set-&gt;elems
op_assign
id|new_elems
suffix:semicolon
)brace
multiline_comment|/* Move the elements which follows the new element.  Test the&n;     first element separately to skip a check in the inner loop.  */
r_if
c_cond
(paren
id|elem
OL
id|set-&gt;elems
(braket
l_int|0
)braket
)paren
(brace
id|idx
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|idx
op_assign
id|set-&gt;nelem
suffix:semicolon
id|idx
OG
l_int|0
suffix:semicolon
id|idx
op_decrement
)paren
id|set-&gt;elems
(braket
id|idx
)braket
op_assign
id|set-&gt;elems
(braket
id|idx
l_int|1
)braket
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|idx
op_assign
id|set-&gt;nelem
suffix:semicolon
id|set-&gt;elems
(braket
id|idx
l_int|1
)braket
OG
id|elem
suffix:semicolon
id|idx
op_decrement
)paren
id|set-&gt;elems
(braket
id|idx
)braket
op_assign
id|set-&gt;elems
(braket
id|idx
l_int|1
)braket
suffix:semicolon
)brace
multiline_comment|/* Insert the new element.  */
id|set-&gt;elems
(braket
id|idx
)braket
op_assign
id|elem
suffix:semicolon
op_increment
id|set-&gt;nelem
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Insert the new element ELEM to the re_node_set* SET.&n;   SET should not already have any element greater than or equal to ELEM.&n;   Return -1 if an error is occured, return 1 otherwise.  */
r_static
r_int
id|internal_function
DECL|function|re_node_set_insert_last
id|re_node_set_insert_last
(paren
id|re_node_set
op_star
id|set
comma
r_int
id|elem
)paren
(brace
multiline_comment|/* Realloc if we need.  */
r_if
c_cond
(paren
id|set-&gt;alloc
op_eq
id|set-&gt;nelem
)paren
(brace
r_int
op_star
id|new_elems
suffix:semicolon
id|set-&gt;alloc
op_assign
(paren
id|set-&gt;alloc
op_plus
l_int|1
)paren
op_star
l_int|2
suffix:semicolon
id|new_elems
op_assign
id|re_realloc
(paren
id|set-&gt;elems
comma
r_int
comma
id|set-&gt;alloc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|new_elems
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|set-&gt;elems
op_assign
id|new_elems
suffix:semicolon
)brace
multiline_comment|/* Insert the new element.  */
id|set-&gt;elems
(braket
id|set-&gt;nelem
op_increment
)braket
op_assign
id|elem
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Compare two node sets SET1 and SET2.&n;   return 1 if SET1 and SET2 are equivalent, return 0 otherwise.  */
r_static
r_int
id|internal_function
id|__attribute
(paren
(paren
id|pure
)paren
)paren
DECL|function|re_node_set_compare
id|re_node_set_compare
(paren
r_const
id|re_node_set
op_star
id|set1
comma
r_const
id|re_node_set
op_star
id|set2
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|set1
op_eq
l_int|NULL
op_logical_or
id|set2
op_eq
l_int|NULL
op_logical_or
id|set1-&gt;nelem
op_ne
id|set2-&gt;nelem
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|set1-&gt;nelem
suffix:semicolon
op_decrement
id|i
op_ge
l_int|0
suffix:semicolon
)paren
r_if
c_cond
(paren
id|set1-&gt;elems
(braket
id|i
)braket
op_ne
id|set2-&gt;elems
(braket
id|i
)braket
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Return (idx + 1) if SET contains the element ELEM, return 0 otherwise.  */
r_static
r_int
id|internal_function
id|__attribute
(paren
(paren
id|pure
)paren
)paren
DECL|function|re_node_set_contains
id|re_node_set_contains
(paren
r_const
id|re_node_set
op_star
id|set
comma
r_int
id|elem
)paren
(brace
r_int
r_int
id|idx
comma
id|right
comma
id|mid
suffix:semicolon
r_if
c_cond
(paren
id|set-&gt;nelem
op_le
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Binary search the element.  */
id|idx
op_assign
l_int|0
suffix:semicolon
id|right
op_assign
id|set-&gt;nelem
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|idx
OL
id|right
)paren
(brace
id|mid
op_assign
(paren
id|idx
op_plus
id|right
)paren
op_div
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|set-&gt;elems
(braket
id|mid
)braket
OL
id|elem
)paren
id|idx
op_assign
id|mid
op_plus
l_int|1
suffix:semicolon
r_else
id|right
op_assign
id|mid
suffix:semicolon
)brace
r_return
id|set-&gt;elems
(braket
id|idx
)braket
op_eq
id|elem
ques
c_cond
id|idx
op_plus
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
r_static
r_void
id|internal_function
DECL|function|re_node_set_remove_at
id|re_node_set_remove_at
(paren
id|re_node_set
op_star
id|set
comma
r_int
id|idx
)paren
(brace
r_if
c_cond
(paren
id|idx
OL
l_int|0
op_logical_or
id|idx
op_ge
id|set-&gt;nelem
)paren
r_return
suffix:semicolon
op_decrement
id|set-&gt;nelem
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|idx
OL
id|set-&gt;nelem
suffix:semicolon
id|idx
op_increment
)paren
id|set-&gt;elems
(braket
id|idx
)braket
op_assign
id|set-&gt;elems
(braket
id|idx
op_plus
l_int|1
)braket
suffix:semicolon
)brace
"&f;"
multiline_comment|/* Add the token TOKEN to dfa-&gt;nodes, and return the index of the token.&n;   Or return -1, if an error will be occured.  */
r_static
r_int
id|internal_function
DECL|function|re_dfa_add_node
id|re_dfa_add_node
(paren
id|re_dfa_t
op_star
id|dfa
comma
id|re_token_t
id|token
)paren
(brace
r_if
c_cond
(paren
id|BE
(paren
id|dfa-&gt;nodes_len
op_ge
id|dfa-&gt;nodes_alloc
comma
l_int|0
)paren
)paren
(brace
r_int
id|new_nodes_alloc
op_assign
id|dfa-&gt;nodes_alloc
op_star
l_int|2
suffix:semicolon
r_int
op_star
id|new_nexts
comma
op_star
id|new_indices
suffix:semicolon
id|re_node_set
op_star
id|new_edests
comma
op_star
id|new_eclosures
suffix:semicolon
id|re_token_t
op_star
id|new_nodes
suffix:semicolon
multiline_comment|/* Avoid overflows in realloc.  */
r_const
r_int
id|max_object_size
op_assign
id|MAX
(paren
r_sizeof
(paren
id|re_token_t
)paren
comma
id|MAX
(paren
r_sizeof
(paren
id|re_node_set
)paren
comma
r_sizeof
(paren
r_int
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|SIZE_MAX
op_div
id|max_object_size
OL
id|new_nodes_alloc
comma
l_int|0
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|new_nodes
op_assign
id|re_realloc
(paren
id|dfa-&gt;nodes
comma
id|re_token_t
comma
id|new_nodes_alloc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|new_nodes
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|dfa-&gt;nodes
op_assign
id|new_nodes
suffix:semicolon
id|new_nexts
op_assign
id|re_realloc
(paren
id|dfa-&gt;nexts
comma
r_int
comma
id|new_nodes_alloc
)paren
suffix:semicolon
id|new_indices
op_assign
id|re_realloc
(paren
id|dfa-&gt;org_indices
comma
r_int
comma
id|new_nodes_alloc
)paren
suffix:semicolon
id|new_edests
op_assign
id|re_realloc
(paren
id|dfa-&gt;edests
comma
id|re_node_set
comma
id|new_nodes_alloc
)paren
suffix:semicolon
id|new_eclosures
op_assign
id|re_realloc
(paren
id|dfa-&gt;eclosures
comma
id|re_node_set
comma
id|new_nodes_alloc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|new_nexts
op_eq
l_int|NULL
op_logical_or
id|new_indices
op_eq
l_int|NULL
op_logical_or
id|new_edests
op_eq
l_int|NULL
op_logical_or
id|new_eclosures
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|dfa-&gt;nexts
op_assign
id|new_nexts
suffix:semicolon
id|dfa-&gt;org_indices
op_assign
id|new_indices
suffix:semicolon
id|dfa-&gt;edests
op_assign
id|new_edests
suffix:semicolon
id|dfa-&gt;eclosures
op_assign
id|new_eclosures
suffix:semicolon
id|dfa-&gt;nodes_alloc
op_assign
id|new_nodes_alloc
suffix:semicolon
)brace
id|dfa-&gt;nodes
(braket
id|dfa-&gt;nodes_len
)braket
op_assign
id|token
suffix:semicolon
id|dfa-&gt;nodes
(braket
id|dfa-&gt;nodes_len
)braket
dot
id|constraint
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef RE_ENABLE_I18N
id|dfa-&gt;nodes
(braket
id|dfa-&gt;nodes_len
)braket
dot
id|accept_mb
op_assign
(paren
id|token.type
op_eq
id|OP_PERIOD
op_logical_and
id|dfa-&gt;mb_cur_max
OG
l_int|1
)paren
op_logical_or
id|token.type
op_eq
id|COMPLEX_BRACKET
suffix:semicolon
macro_line|#endif
id|dfa-&gt;nexts
(braket
id|dfa-&gt;nodes_len
)braket
op_assign
l_int|1
suffix:semicolon
id|re_node_set_init_empty
(paren
id|dfa-&gt;edests
op_plus
id|dfa-&gt;nodes_len
)paren
suffix:semicolon
id|re_node_set_init_empty
(paren
id|dfa-&gt;eclosures
op_plus
id|dfa-&gt;nodes_len
)paren
suffix:semicolon
r_return
id|dfa-&gt;nodes_len
op_increment
suffix:semicolon
)brace
r_static
r_inline
r_int
r_int
id|internal_function
DECL|function|calc_state_hash
id|calc_state_hash
(paren
r_const
id|re_node_set
op_star
id|nodes
comma
r_int
r_int
id|context
)paren
(brace
r_int
r_int
id|hash
op_assign
id|nodes-&gt;nelem
op_plus
id|context
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nodes-&gt;nelem
suffix:semicolon
id|i
op_increment
)paren
id|hash
op_add_assign
id|nodes-&gt;elems
(braket
id|i
)braket
suffix:semicolon
r_return
id|hash
suffix:semicolon
)brace
multiline_comment|/* Search for the state whose node_set is equivalent to NODES.&n;   Return the pointer to the state, if we found it in the DFA.&n;   Otherwise create the new one and return it.  In case of an error&n;   return NULL and set the error code in ERR.&n;   Note: - We assume NULL as the invalid state, then it is possible that&n;&t;   return value is NULL and ERR is REG_NOERROR.&n;&t; - We never return non-NULL value in case of any errors, it is for&n;&t;   optimization.  */
r_static
id|re_dfastate_t
op_star
id|internal_function
DECL|function|re_acquire_state
id|re_acquire_state
(paren
id|reg_errcode_t
op_star
id|err
comma
r_const
id|re_dfa_t
op_star
id|dfa
comma
r_const
id|re_node_set
op_star
id|nodes
)paren
(brace
r_int
r_int
id|hash
suffix:semicolon
id|re_dfastate_t
op_star
id|new_state
suffix:semicolon
r_struct
id|re_state_table_entry
op_star
id|spot
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|nodes-&gt;nelem
op_eq
l_int|0
comma
l_int|0
)paren
)paren
(brace
op_star
id|err
op_assign
id|REG_NOERROR
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|hash
op_assign
id|calc_state_hash
(paren
id|nodes
comma
l_int|0
)paren
suffix:semicolon
id|spot
op_assign
id|dfa-&gt;state_table
op_plus
(paren
id|hash
op_amp
id|dfa-&gt;state_hash_mask
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|spot-&gt;num
suffix:semicolon
id|i
op_increment
)paren
(brace
id|re_dfastate_t
op_star
id|state
op_assign
id|spot-&gt;array
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hash
op_ne
id|state-&gt;hash
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|re_node_set_compare
(paren
op_amp
id|state-&gt;nodes
comma
id|nodes
)paren
)paren
r_return
id|state
suffix:semicolon
)brace
multiline_comment|/* There are no appropriate state in the dfa, create the new one.  */
id|new_state
op_assign
id|create_ci_newstate
(paren
id|dfa
comma
id|nodes
comma
id|hash
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|new_state
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
op_star
id|err
op_assign
id|REG_ESPACE
suffix:semicolon
r_return
id|new_state
suffix:semicolon
)brace
multiline_comment|/* Search for the state whose node_set is equivalent to NODES and&n;   whose context is equivalent to CONTEXT.&n;   Return the pointer to the state, if we found it in the DFA.&n;   Otherwise create the new one and return it.  In case of an error&n;   return NULL and set the error code in ERR.&n;   Note: - We assume NULL as the invalid state, then it is possible that&n;&t;   return value is NULL and ERR is REG_NOERROR.&n;&t; - We never return non-NULL value in case of any errors, it is for&n;&t;   optimization.  */
r_static
id|re_dfastate_t
op_star
id|internal_function
DECL|function|re_acquire_state_context
id|re_acquire_state_context
(paren
id|reg_errcode_t
op_star
id|err
comma
r_const
id|re_dfa_t
op_star
id|dfa
comma
r_const
id|re_node_set
op_star
id|nodes
comma
r_int
r_int
id|context
)paren
(brace
r_int
r_int
id|hash
suffix:semicolon
id|re_dfastate_t
op_star
id|new_state
suffix:semicolon
r_struct
id|re_state_table_entry
op_star
id|spot
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|nodes-&gt;nelem
op_eq
l_int|0
)paren
(brace
op_star
id|err
op_assign
id|REG_NOERROR
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|hash
op_assign
id|calc_state_hash
(paren
id|nodes
comma
id|context
)paren
suffix:semicolon
id|spot
op_assign
id|dfa-&gt;state_table
op_plus
(paren
id|hash
op_amp
id|dfa-&gt;state_hash_mask
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|spot-&gt;num
suffix:semicolon
id|i
op_increment
)paren
(brace
id|re_dfastate_t
op_star
id|state
op_assign
id|spot-&gt;array
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;hash
op_eq
id|hash
op_logical_and
id|state-&gt;context
op_eq
id|context
op_logical_and
id|re_node_set_compare
(paren
id|state-&gt;entrance_nodes
comma
id|nodes
)paren
)paren
r_return
id|state
suffix:semicolon
)brace
multiline_comment|/* There are no appropriate state in `dfa&squot;, create the new one.  */
id|new_state
op_assign
id|create_cd_newstate
(paren
id|dfa
comma
id|nodes
comma
id|context
comma
id|hash
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|new_state
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
op_star
id|err
op_assign
id|REG_ESPACE
suffix:semicolon
r_return
id|new_state
suffix:semicolon
)brace
multiline_comment|/* Finish initialization of the new state NEWSTATE, and using its hash value&n;   HASH put in the appropriate bucket of DFA&squot;s state table.  Return value&n;   indicates the error code if failed.  */
r_static
id|reg_errcode_t
DECL|function|register_state
id|register_state
(paren
r_const
id|re_dfa_t
op_star
id|dfa
comma
id|re_dfastate_t
op_star
id|newstate
comma
r_int
r_int
id|hash
)paren
(brace
r_struct
id|re_state_table_entry
op_star
id|spot
suffix:semicolon
id|reg_errcode_t
id|err
suffix:semicolon
r_int
id|i
suffix:semicolon
id|newstate-&gt;hash
op_assign
id|hash
suffix:semicolon
id|err
op_assign
id|re_node_set_alloc
(paren
op_amp
id|newstate-&gt;non_eps_nodes
comma
id|newstate-&gt;nodes.nelem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|newstate-&gt;nodes.nelem
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|elem
op_assign
id|newstate-&gt;nodes.elems
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_EPSILON_NODE
(paren
id|dfa-&gt;nodes
(braket
id|elem
)braket
dot
id|type
)paren
)paren
r_if
c_cond
(paren
id|re_node_set_insert_last
(paren
op_amp
id|newstate-&gt;non_eps_nodes
comma
id|elem
)paren
OL
l_int|0
)paren
r_return
id|REG_ESPACE
suffix:semicolon
)brace
id|spot
op_assign
id|dfa-&gt;state_table
op_plus
(paren
id|hash
op_amp
id|dfa-&gt;state_hash_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|spot-&gt;alloc
op_le
id|spot-&gt;num
comma
l_int|0
)paren
)paren
(brace
r_int
id|new_alloc
op_assign
l_int|2
op_star
id|spot-&gt;num
op_plus
l_int|2
suffix:semicolon
id|re_dfastate_t
op_star
op_star
id|new_array
op_assign
id|re_realloc
(paren
id|spot-&gt;array
comma
id|re_dfastate_t
op_star
comma
id|new_alloc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|new_array
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
id|spot-&gt;array
op_assign
id|new_array
suffix:semicolon
id|spot-&gt;alloc
op_assign
id|new_alloc
suffix:semicolon
)brace
id|spot-&gt;array
(braket
id|spot-&gt;num
op_increment
)braket
op_assign
id|newstate
suffix:semicolon
r_return
id|REG_NOERROR
suffix:semicolon
)brace
r_static
r_void
DECL|function|free_state
id|free_state
(paren
id|re_dfastate_t
op_star
id|state
)paren
(brace
id|re_node_set_free
(paren
op_amp
id|state-&gt;non_eps_nodes
)paren
suffix:semicolon
id|re_node_set_free
(paren
op_amp
id|state-&gt;inveclosure
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;entrance_nodes
op_ne
op_amp
id|state-&gt;nodes
)paren
(brace
id|re_node_set_free
(paren
id|state-&gt;entrance_nodes
)paren
suffix:semicolon
id|re_free
(paren
id|state-&gt;entrance_nodes
)paren
suffix:semicolon
)brace
id|re_node_set_free
(paren
op_amp
id|state-&gt;nodes
)paren
suffix:semicolon
id|re_free
(paren
id|state-&gt;word_trtable
)paren
suffix:semicolon
id|re_free
(paren
id|state-&gt;trtable
)paren
suffix:semicolon
id|re_free
(paren
id|state
)paren
suffix:semicolon
)brace
multiline_comment|/* Create the new state which is independ of contexts.&n;   Return the new state if succeeded, otherwise return NULL.  */
r_static
id|re_dfastate_t
op_star
id|internal_function
DECL|function|create_ci_newstate
id|create_ci_newstate
(paren
r_const
id|re_dfa_t
op_star
id|dfa
comma
r_const
id|re_node_set
op_star
id|nodes
comma
r_int
r_int
id|hash
)paren
(brace
r_int
id|i
suffix:semicolon
id|reg_errcode_t
id|err
suffix:semicolon
id|re_dfastate_t
op_star
id|newstate
suffix:semicolon
id|newstate
op_assign
(paren
id|re_dfastate_t
op_star
)paren
id|calloc
(paren
r_sizeof
(paren
id|re_dfastate_t
)paren
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|newstate
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|err
op_assign
id|re_node_set_init_copy
(paren
op_amp
id|newstate-&gt;nodes
comma
id|nodes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
(brace
id|re_free
(paren
id|newstate
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|newstate-&gt;entrance_nodes
op_assign
op_amp
id|newstate-&gt;nodes
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nodes-&gt;nelem
suffix:semicolon
id|i
op_increment
)paren
(brace
id|re_token_t
op_star
id|node
op_assign
id|dfa-&gt;nodes
op_plus
id|nodes-&gt;elems
(braket
id|i
)braket
suffix:semicolon
id|re_token_type_t
id|type
op_assign
id|node-&gt;type
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|CHARACTER
op_logical_and
op_logical_neg
id|node-&gt;constraint
)paren
r_continue
suffix:semicolon
macro_line|#ifdef RE_ENABLE_I18N
id|newstate-&gt;accept_mb
op_or_assign
id|node-&gt;accept_mb
suffix:semicolon
macro_line|#endif /* RE_ENABLE_I18N */
multiline_comment|/* If the state has the halt node, the state is a halt state.  */
r_if
c_cond
(paren
id|type
op_eq
id|END_OF_RE
)paren
id|newstate-&gt;halt
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|type
op_eq
id|OP_BACK_REF
)paren
id|newstate-&gt;has_backref
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|type
op_eq
id|ANCHOR
op_logical_or
id|node-&gt;constraint
)paren
id|newstate-&gt;has_constraint
op_assign
l_int|1
suffix:semicolon
)brace
id|err
op_assign
id|register_state
(paren
id|dfa
comma
id|newstate
comma
id|hash
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
(brace
id|free_state
(paren
id|newstate
)paren
suffix:semicolon
id|newstate
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|newstate
suffix:semicolon
)brace
multiline_comment|/* Create the new state which is depend on the context CONTEXT.&n;   Return the new state if succeeded, otherwise return NULL.  */
r_static
id|re_dfastate_t
op_star
id|internal_function
DECL|function|create_cd_newstate
id|create_cd_newstate
(paren
r_const
id|re_dfa_t
op_star
id|dfa
comma
r_const
id|re_node_set
op_star
id|nodes
comma
r_int
r_int
id|context
comma
r_int
r_int
id|hash
)paren
(brace
r_int
id|i
comma
id|nctx_nodes
op_assign
l_int|0
suffix:semicolon
id|reg_errcode_t
id|err
suffix:semicolon
id|re_dfastate_t
op_star
id|newstate
suffix:semicolon
id|newstate
op_assign
(paren
id|re_dfastate_t
op_star
)paren
id|calloc
(paren
r_sizeof
(paren
id|re_dfastate_t
)paren
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|newstate
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|err
op_assign
id|re_node_set_init_copy
(paren
op_amp
id|newstate-&gt;nodes
comma
id|nodes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
(brace
id|re_free
(paren
id|newstate
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|newstate-&gt;context
op_assign
id|context
suffix:semicolon
id|newstate-&gt;entrance_nodes
op_assign
op_amp
id|newstate-&gt;nodes
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nodes-&gt;nelem
suffix:semicolon
id|i
op_increment
)paren
(brace
id|re_token_t
op_star
id|node
op_assign
id|dfa-&gt;nodes
op_plus
id|nodes-&gt;elems
(braket
id|i
)braket
suffix:semicolon
id|re_token_type_t
id|type
op_assign
id|node-&gt;type
suffix:semicolon
r_int
r_int
id|constraint
op_assign
id|node-&gt;constraint
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|CHARACTER
op_logical_and
op_logical_neg
id|constraint
)paren
r_continue
suffix:semicolon
macro_line|#ifdef RE_ENABLE_I18N
id|newstate-&gt;accept_mb
op_or_assign
id|node-&gt;accept_mb
suffix:semicolon
macro_line|#endif /* RE_ENABLE_I18N */
multiline_comment|/* If the state has the halt node, the state is a halt state.  */
r_if
c_cond
(paren
id|type
op_eq
id|END_OF_RE
)paren
id|newstate-&gt;halt
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|type
op_eq
id|OP_BACK_REF
)paren
id|newstate-&gt;has_backref
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|constraint
)paren
(brace
r_if
c_cond
(paren
id|newstate-&gt;entrance_nodes
op_eq
op_amp
id|newstate-&gt;nodes
)paren
(brace
id|newstate-&gt;entrance_nodes
op_assign
id|re_malloc
(paren
id|re_node_set
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|newstate-&gt;entrance_nodes
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
(brace
id|free_state
(paren
id|newstate
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|re_node_set_init_copy
(paren
id|newstate-&gt;entrance_nodes
comma
id|nodes
)paren
op_ne
id|REG_NOERROR
)paren
r_return
l_int|NULL
suffix:semicolon
id|nctx_nodes
op_assign
l_int|0
suffix:semicolon
id|newstate-&gt;has_constraint
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|NOT_SATISFY_PREV_CONSTRAINT
(paren
id|constraint
comma
id|context
)paren
)paren
(brace
id|re_node_set_remove_at
(paren
op_amp
id|newstate-&gt;nodes
comma
id|i
id|nctx_nodes
)paren
suffix:semicolon
op_increment
id|nctx_nodes
suffix:semicolon
)brace
)brace
)brace
id|err
op_assign
id|register_state
(paren
id|dfa
comma
id|newstate
comma
id|hash
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
(brace
id|free_state
(paren
id|newstate
)paren
suffix:semicolon
id|newstate
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|newstate
suffix:semicolon
)brace
eof
