multiline_comment|/* Extended regular expression matching and search library.&n;   Copyright (C) 2002-2007,2009,2010 Free Software Foundation, Inc.&n;   This file is part of the GNU C Library.&n;   Contributed by Isamu Hasegawa &lt;isamu@yamato.ibm.com&gt;.&n;&n;   The GNU C Library is free software; you can redistribute it and/or&n;   modify it under the terms of the GNU Lesser General Public&n;   License as published by the Free Software Foundation; either&n;   version 2.1 of the License, or (at your option) any later version.&n;&n;   The GNU C Library is distributed in the hope that it will be useful,&n;   but WITHOUT ANY WARRANTY; without even the implied warranty of&n;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n;   Lesser General Public License for more details.&n;&n;   You should have received a copy of the GNU Lesser General Public&n;   License along with the GNU C Library; if not, write to the Free&n;   Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA&n;   02110-1301 USA.  */
r_static
id|reg_errcode_t
id|re_compile_internal
(paren
id|regex_t
op_star
id|preg
comma
r_const
r_char
op_star
id|pattern
comma
r_int
id|length
comma
id|reg_syntax_t
id|syntax
)paren
suffix:semicolon
r_static
r_void
id|re_compile_fastmap_iter
(paren
id|regex_t
op_star
id|bufp
comma
r_const
id|re_dfastate_t
op_star
id|init_state
comma
r_char
op_star
id|fastmap
)paren
suffix:semicolon
r_static
id|reg_errcode_t
id|init_dfa
(paren
id|re_dfa_t
op_star
id|dfa
comma
r_int
id|pat_len
)paren
suffix:semicolon
macro_line|#ifdef RE_ENABLE_I18N
r_static
r_void
id|free_charset
(paren
id|re_charset_t
op_star
id|cset
)paren
suffix:semicolon
macro_line|#endif /* RE_ENABLE_I18N */
r_static
r_void
id|free_workarea_compile
(paren
id|regex_t
op_star
id|preg
)paren
suffix:semicolon
r_static
id|reg_errcode_t
id|create_initial_state
(paren
id|re_dfa_t
op_star
id|dfa
)paren
suffix:semicolon
macro_line|#ifdef RE_ENABLE_I18N
r_static
r_void
id|optimize_utf8
(paren
id|re_dfa_t
op_star
id|dfa
)paren
suffix:semicolon
macro_line|#endif
r_static
id|reg_errcode_t
id|analyze
(paren
id|regex_t
op_star
id|preg
)paren
suffix:semicolon
r_static
id|reg_errcode_t
id|preorder
(paren
id|bin_tree_t
op_star
id|root
comma
id|reg_errcode_t
(paren
id|fn
(paren
r_void
op_star
comma
id|bin_tree_t
op_star
)paren
)paren
comma
r_void
op_star
id|extra
)paren
suffix:semicolon
r_static
id|reg_errcode_t
id|postorder
(paren
id|bin_tree_t
op_star
id|root
comma
id|reg_errcode_t
(paren
id|fn
(paren
r_void
op_star
comma
id|bin_tree_t
op_star
)paren
)paren
comma
r_void
op_star
id|extra
)paren
suffix:semicolon
r_static
id|reg_errcode_t
id|optimize_subexps
(paren
r_void
op_star
id|extra
comma
id|bin_tree_t
op_star
id|node
)paren
suffix:semicolon
r_static
id|reg_errcode_t
id|lower_subexps
(paren
r_void
op_star
id|extra
comma
id|bin_tree_t
op_star
id|node
)paren
suffix:semicolon
r_static
id|bin_tree_t
op_star
id|lower_subexp
(paren
id|reg_errcode_t
op_star
id|err
comma
id|regex_t
op_star
id|preg
comma
id|bin_tree_t
op_star
id|node
)paren
suffix:semicolon
r_static
id|reg_errcode_t
id|calc_first
(paren
r_void
op_star
id|extra
comma
id|bin_tree_t
op_star
id|node
)paren
suffix:semicolon
r_static
id|reg_errcode_t
id|calc_next
(paren
r_void
op_star
id|extra
comma
id|bin_tree_t
op_star
id|node
)paren
suffix:semicolon
r_static
id|reg_errcode_t
id|link_nfa_nodes
(paren
r_void
op_star
id|extra
comma
id|bin_tree_t
op_star
id|node
)paren
suffix:semicolon
r_static
r_int
id|duplicate_node
(paren
id|re_dfa_t
op_star
id|dfa
comma
r_int
id|org_idx
comma
r_int
r_int
id|constraint
)paren
suffix:semicolon
r_static
r_int
id|search_duplicated_node
(paren
r_const
id|re_dfa_t
op_star
id|dfa
comma
r_int
id|org_node
comma
r_int
r_int
id|constraint
)paren
suffix:semicolon
r_static
id|reg_errcode_t
id|calc_eclosure
(paren
id|re_dfa_t
op_star
id|dfa
)paren
suffix:semicolon
r_static
id|reg_errcode_t
id|calc_eclosure_iter
(paren
id|re_node_set
op_star
id|new_set
comma
id|re_dfa_t
op_star
id|dfa
comma
r_int
id|node
comma
r_int
id|root
)paren
suffix:semicolon
r_static
id|reg_errcode_t
id|calc_inveclosure
(paren
id|re_dfa_t
op_star
id|dfa
)paren
suffix:semicolon
r_static
r_int
id|fetch_number
(paren
id|re_string_t
op_star
id|input
comma
id|re_token_t
op_star
id|token
comma
id|reg_syntax_t
id|syntax
)paren
suffix:semicolon
r_static
r_int
id|peek_token
(paren
id|re_token_t
op_star
id|token
comma
id|re_string_t
op_star
id|input
comma
id|reg_syntax_t
id|syntax
)paren
id|internal_function
suffix:semicolon
r_static
id|bin_tree_t
op_star
id|parse
(paren
id|re_string_t
op_star
id|regexp
comma
id|regex_t
op_star
id|preg
comma
id|reg_syntax_t
id|syntax
comma
id|reg_errcode_t
op_star
id|err
)paren
suffix:semicolon
r_static
id|bin_tree_t
op_star
id|parse_reg_exp
(paren
id|re_string_t
op_star
id|regexp
comma
id|regex_t
op_star
id|preg
comma
id|re_token_t
op_star
id|token
comma
id|reg_syntax_t
id|syntax
comma
r_int
id|nest
comma
id|reg_errcode_t
op_star
id|err
)paren
suffix:semicolon
r_static
id|bin_tree_t
op_star
id|parse_branch
(paren
id|re_string_t
op_star
id|regexp
comma
id|regex_t
op_star
id|preg
comma
id|re_token_t
op_star
id|token
comma
id|reg_syntax_t
id|syntax
comma
r_int
id|nest
comma
id|reg_errcode_t
op_star
id|err
)paren
suffix:semicolon
r_static
id|bin_tree_t
op_star
id|parse_expression
(paren
id|re_string_t
op_star
id|regexp
comma
id|regex_t
op_star
id|preg
comma
id|re_token_t
op_star
id|token
comma
id|reg_syntax_t
id|syntax
comma
r_int
id|nest
comma
id|reg_errcode_t
op_star
id|err
)paren
suffix:semicolon
r_static
id|bin_tree_t
op_star
id|parse_sub_exp
(paren
id|re_string_t
op_star
id|regexp
comma
id|regex_t
op_star
id|preg
comma
id|re_token_t
op_star
id|token
comma
id|reg_syntax_t
id|syntax
comma
r_int
id|nest
comma
id|reg_errcode_t
op_star
id|err
)paren
suffix:semicolon
r_static
id|bin_tree_t
op_star
id|parse_dup_op
(paren
id|bin_tree_t
op_star
id|dup_elem
comma
id|re_string_t
op_star
id|regexp
comma
id|re_dfa_t
op_star
id|dfa
comma
id|re_token_t
op_star
id|token
comma
id|reg_syntax_t
id|syntax
comma
id|reg_errcode_t
op_star
id|err
)paren
suffix:semicolon
r_static
id|bin_tree_t
op_star
id|parse_bracket_exp
(paren
id|re_string_t
op_star
id|regexp
comma
id|re_dfa_t
op_star
id|dfa
comma
id|re_token_t
op_star
id|token
comma
id|reg_syntax_t
id|syntax
comma
id|reg_errcode_t
op_star
id|err
)paren
suffix:semicolon
r_static
id|reg_errcode_t
id|parse_bracket_element
(paren
id|bracket_elem_t
op_star
id|elem
comma
id|re_string_t
op_star
id|regexp
comma
id|re_token_t
op_star
id|token
comma
r_int
id|token_len
comma
id|re_dfa_t
op_star
id|dfa
comma
id|reg_syntax_t
id|syntax
comma
r_int
id|accept_hyphen
)paren
suffix:semicolon
r_static
id|reg_errcode_t
id|parse_bracket_symbol
(paren
id|bracket_elem_t
op_star
id|elem
comma
id|re_string_t
op_star
id|regexp
comma
id|re_token_t
op_star
id|token
)paren
suffix:semicolon
macro_line|#ifdef RE_ENABLE_I18N
r_static
id|reg_errcode_t
id|build_equiv_class
(paren
id|bitset_t
id|sbcset
comma
id|re_charset_t
op_star
id|mbcset
comma
r_int
op_star
id|equiv_class_alloc
comma
r_const
r_int
r_char
op_star
id|name
)paren
suffix:semicolon
r_static
id|reg_errcode_t
id|build_charclass
(paren
id|RE_TRANSLATE_TYPE
id|trans
comma
id|bitset_t
id|sbcset
comma
id|re_charset_t
op_star
id|mbcset
comma
r_int
op_star
id|char_class_alloc
comma
r_const
r_char
op_star
id|class_name
comma
id|reg_syntax_t
id|syntax
)paren
suffix:semicolon
macro_line|#else  /* not RE_ENABLE_I18N */
r_static
id|reg_errcode_t
id|build_equiv_class
(paren
id|bitset_t
id|sbcset
comma
r_const
r_int
r_char
op_star
id|name
)paren
suffix:semicolon
r_static
id|reg_errcode_t
id|build_charclass
(paren
id|RE_TRANSLATE_TYPE
id|trans
comma
id|bitset_t
id|sbcset
comma
r_const
r_char
op_star
id|class_name
comma
id|reg_syntax_t
id|syntax
)paren
suffix:semicolon
macro_line|#endif /* not RE_ENABLE_I18N */
r_static
id|bin_tree_t
op_star
id|build_charclass_op
(paren
id|re_dfa_t
op_star
id|dfa
comma
id|RE_TRANSLATE_TYPE
id|trans
comma
r_const
r_char
op_star
id|class_name
comma
r_const
r_char
op_star
id|extra
comma
r_int
id|non_match
comma
id|reg_errcode_t
op_star
id|err
)paren
suffix:semicolon
r_static
id|bin_tree_t
op_star
id|create_tree
(paren
id|re_dfa_t
op_star
id|dfa
comma
id|bin_tree_t
op_star
id|left
comma
id|bin_tree_t
op_star
id|right
comma
id|re_token_type_t
id|type
)paren
suffix:semicolon
r_static
id|bin_tree_t
op_star
id|create_token_tree
(paren
id|re_dfa_t
op_star
id|dfa
comma
id|bin_tree_t
op_star
id|left
comma
id|bin_tree_t
op_star
id|right
comma
r_const
id|re_token_t
op_star
id|token
)paren
suffix:semicolon
r_static
id|bin_tree_t
op_star
id|duplicate_tree
(paren
r_const
id|bin_tree_t
op_star
id|src
comma
id|re_dfa_t
op_star
id|dfa
)paren
suffix:semicolon
r_static
r_void
id|free_token
(paren
id|re_token_t
op_star
id|node
)paren
suffix:semicolon
r_static
id|reg_errcode_t
id|free_tree
(paren
r_void
op_star
id|extra
comma
id|bin_tree_t
op_star
id|node
)paren
suffix:semicolon
r_static
id|reg_errcode_t
id|mark_opt_subexp
(paren
r_void
op_star
id|extra
comma
id|bin_tree_t
op_star
id|node
)paren
suffix:semicolon
"&f;"
multiline_comment|/* This table gives an error message for each of the error codes listed&n;   in regex.h.  Obviously the order here has to be same as there.&n;   POSIX doesn&squot;t require that we do anything for REG_NOERROR,&n;   but why not be nice?  */
DECL|variable|attribute_hidden
r_const
r_char
id|__re_error_msgid
(braket
)braket
id|attribute_hidden
op_assign
(brace
DECL|macro|REG_NOERROR_IDX
mdefine_line|#define REG_NOERROR_IDX&t;0
id|gettext_noop
(paren
l_string|&quot;Success&quot;
)paren
multiline_comment|/* REG_NOERROR */
l_string|&quot;&bslash;0&quot;
DECL|macro|REG_NOMATCH_IDX
mdefine_line|#define REG_NOMATCH_IDX (REG_NOERROR_IDX + sizeof &quot;Success&quot;)
id|gettext_noop
(paren
l_string|&quot;No match&quot;
)paren
multiline_comment|/* REG_NOMATCH */
l_string|&quot;&bslash;0&quot;
DECL|macro|REG_BADPAT_IDX
mdefine_line|#define REG_BADPAT_IDX&t;(REG_NOMATCH_IDX + sizeof &quot;No match&quot;)
id|gettext_noop
(paren
l_string|&quot;Invalid regular expression&quot;
)paren
multiline_comment|/* REG_BADPAT */
l_string|&quot;&bslash;0&quot;
DECL|macro|REG_ECOLLATE_IDX
mdefine_line|#define REG_ECOLLATE_IDX (REG_BADPAT_IDX + sizeof &quot;Invalid regular expression&quot;)
id|gettext_noop
(paren
l_string|&quot;Invalid collation character&quot;
)paren
multiline_comment|/* REG_ECOLLATE */
l_string|&quot;&bslash;0&quot;
DECL|macro|REG_ECTYPE_IDX
mdefine_line|#define REG_ECTYPE_IDX&t;(REG_ECOLLATE_IDX + sizeof &quot;Invalid collation character&quot;)
id|gettext_noop
(paren
l_string|&quot;Invalid character class name&quot;
)paren
multiline_comment|/* REG_ECTYPE */
l_string|&quot;&bslash;0&quot;
DECL|macro|REG_EESCAPE_IDX
mdefine_line|#define REG_EESCAPE_IDX&t;(REG_ECTYPE_IDX + sizeof &quot;Invalid character class name&quot;)
id|gettext_noop
(paren
l_string|&quot;Trailing backslash&quot;
)paren
multiline_comment|/* REG_EESCAPE */
l_string|&quot;&bslash;0&quot;
DECL|macro|REG_ESUBREG_IDX
mdefine_line|#define REG_ESUBREG_IDX&t;(REG_EESCAPE_IDX + sizeof &quot;Trailing backslash&quot;)
id|gettext_noop
(paren
l_string|&quot;Invalid back reference&quot;
)paren
multiline_comment|/* REG_ESUBREG */
l_string|&quot;&bslash;0&quot;
DECL|macro|REG_EBRACK_IDX
mdefine_line|#define REG_EBRACK_IDX&t;(REG_ESUBREG_IDX + sizeof &quot;Invalid back reference&quot;)
id|gettext_noop
(paren
l_string|&quot;Unmatched [ or [^&quot;
)paren
multiline_comment|/* REG_EBRACK */
l_string|&quot;&bslash;0&quot;
DECL|macro|REG_EPAREN_IDX
mdefine_line|#define REG_EPAREN_IDX&t;(REG_EBRACK_IDX + sizeof &quot;Unmatched [ or [^&quot;)
id|gettext_noop
(paren
l_string|&quot;Unmatched ( or &bslash;&bslash;(&quot;
)paren
multiline_comment|/* REG_EPAREN */
l_string|&quot;&bslash;0&quot;
DECL|macro|REG_EBRACE_IDX
mdefine_line|#define REG_EBRACE_IDX&t;(REG_EPAREN_IDX + sizeof &quot;Unmatched ( or &bslash;&bslash;(&quot;)
id|gettext_noop
(paren
l_string|&quot;Unmatched &bslash;&bslash;{&quot;
)paren
multiline_comment|/* REG_EBRACE */
l_string|&quot;&bslash;0&quot;
DECL|macro|REG_BADBR_IDX
mdefine_line|#define REG_BADBR_IDX&t;(REG_EBRACE_IDX + sizeof &quot;Unmatched &bslash;&bslash;{&quot;)
id|gettext_noop
(paren
l_string|&quot;Invalid content of &bslash;&bslash;{&bslash;&bslash;}&quot;
)paren
multiline_comment|/* REG_BADBR */
l_string|&quot;&bslash;0&quot;
DECL|macro|REG_ERANGE_IDX
mdefine_line|#define REG_ERANGE_IDX&t;(REG_BADBR_IDX + sizeof &quot;Invalid content of &bslash;&bslash;{&bslash;&bslash;}&quot;)
id|gettext_noop
(paren
l_string|&quot;Invalid range end&quot;
)paren
multiline_comment|/* REG_ERANGE */
l_string|&quot;&bslash;0&quot;
DECL|macro|REG_ESPACE_IDX
mdefine_line|#define REG_ESPACE_IDX&t;(REG_ERANGE_IDX + sizeof &quot;Invalid range end&quot;)
id|gettext_noop
(paren
l_string|&quot;Memory exhausted&quot;
)paren
multiline_comment|/* REG_ESPACE */
l_string|&quot;&bslash;0&quot;
DECL|macro|REG_BADRPT_IDX
mdefine_line|#define REG_BADRPT_IDX&t;(REG_ESPACE_IDX + sizeof &quot;Memory exhausted&quot;)
id|gettext_noop
(paren
l_string|&quot;Invalid preceding regular expression&quot;
)paren
multiline_comment|/* REG_BADRPT */
l_string|&quot;&bslash;0&quot;
DECL|macro|REG_EEND_IDX
mdefine_line|#define REG_EEND_IDX&t;(REG_BADRPT_IDX + sizeof &quot;Invalid preceding regular expression&quot;)
id|gettext_noop
(paren
l_string|&quot;Premature end of regular expression&quot;
)paren
multiline_comment|/* REG_EEND */
l_string|&quot;&bslash;0&quot;
DECL|macro|REG_ESIZE_IDX
mdefine_line|#define REG_ESIZE_IDX&t;(REG_EEND_IDX + sizeof &quot;Premature end of regular expression&quot;)
id|gettext_noop
(paren
l_string|&quot;Regular expression too big&quot;
)paren
multiline_comment|/* REG_ESIZE */
l_string|&quot;&bslash;0&quot;
DECL|macro|REG_ERPAREN_IDX
mdefine_line|#define REG_ERPAREN_IDX&t;(REG_ESIZE_IDX + sizeof &quot;Regular expression too big&quot;)
id|gettext_noop
(paren
l_string|&quot;Unmatched ) or &bslash;&bslash;)&quot;
)paren
multiline_comment|/* REG_ERPAREN */
)brace
suffix:semicolon
DECL|variable|attribute_hidden
r_const
r_int
id|__re_error_msgid_idx
(braket
)braket
id|attribute_hidden
op_assign
(brace
id|REG_NOERROR_IDX
comma
id|REG_NOMATCH_IDX
comma
id|REG_BADPAT_IDX
comma
id|REG_ECOLLATE_IDX
comma
id|REG_ECTYPE_IDX
comma
id|REG_EESCAPE_IDX
comma
id|REG_ESUBREG_IDX
comma
id|REG_EBRACK_IDX
comma
id|REG_EPAREN_IDX
comma
id|REG_EBRACE_IDX
comma
id|REG_BADBR_IDX
comma
id|REG_ERANGE_IDX
comma
id|REG_ESPACE_IDX
comma
id|REG_BADRPT_IDX
comma
id|REG_EEND_IDX
comma
id|REG_ESIZE_IDX
comma
id|REG_ERPAREN_IDX
)brace
suffix:semicolon
"&f;"
multiline_comment|/* Entry points for GNU code.  */
macro_line|#ifdef ZOS_USS
multiline_comment|/* For ZOS USS we must define btowc */
m_wchar_t
DECL|function|btowc
id|btowc
(paren
r_int
id|c
)paren
(brace
m_wchar_t
id|wtmp
(braket
l_int|2
)braket
suffix:semicolon
r_char
id|tmp
(braket
l_int|2
)braket
suffix:semicolon
id|tmp
(braket
l_int|0
)braket
op_assign
id|c
suffix:semicolon
id|tmp
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|mbtowc
(paren
id|wtmp
comma
id|tmp
comma
l_int|1
)paren
suffix:semicolon
r_return
id|wtmp
(braket
l_int|0
)braket
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* re_compile_pattern is the GNU regular expression compiler: it&n;   compiles PATTERN (of length LENGTH) and puts the result in BUFP.&n;   Returns 0 if the pattern was valid, otherwise an error string.&n;&n;   Assumes the `allocated&squot; (and perhaps `buffer&squot;) and `translate&squot; fields&n;   are set in BUFP on entry.  */
r_const
r_char
op_star
DECL|function|re_compile_pattern
id|re_compile_pattern
(paren
id|pattern
comma
id|length
comma
id|bufp
)paren
r_const
r_char
op_star
id|pattern
suffix:semicolon
r_int
id|length
suffix:semicolon
r_struct
id|re_pattern_buffer
op_star
id|bufp
suffix:semicolon
(brace
id|reg_errcode_t
id|ret
suffix:semicolon
multiline_comment|/* And GNU code determines whether or not to get register information&n;     by passing null for the REGS argument to re_match, etc., not by&n;     setting no_sub, unless RE_NO_SUB is set.  */
id|bufp-&gt;no_sub
op_assign
op_logical_neg
op_logical_neg
(paren
id|re_syntax_options
op_amp
id|RE_NO_SUB
)paren
suffix:semicolon
multiline_comment|/* Match anchors at newline.  */
id|bufp-&gt;newline_anchor
op_assign
l_int|1
suffix:semicolon
id|ret
op_assign
id|re_compile_internal
(paren
id|bufp
comma
id|pattern
comma
id|length
comma
id|re_syntax_options
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|gettext
(paren
id|__re_error_msgid
op_plus
id|__re_error_msgid_idx
(braket
(paren
r_int
)paren
id|ret
)braket
)paren
suffix:semicolon
)brace
macro_line|#ifdef _LIBC
DECL|function|weak_alias
id|weak_alias
(paren
id|__re_compile_pattern
comma
id|re_compile_pattern
)paren
macro_line|#endif
multiline_comment|/* Set by `re_set_syntax&squot; to the current regexp syntax to recognize.  Can&n;   also be assigned to arbitrarily: each pattern buffer stores its own&n;   syntax, so it can be changed between regex compilations.  */
multiline_comment|/* This has no initializer because initialized variables in Emacs&n;   become read-only after dumping.  */
id|reg_syntax_t
id|re_syntax_options
suffix:semicolon
multiline_comment|/* Specify the precise syntax of regexps for compilation.  This provides&n;   for compatibility for various utilities which historically have&n;   different, incompatible syntaxes.&n;&n;   The argument SYNTAX is a bit mask comprised of the various bits&n;   defined in regex.h.  We return the old syntax.  */
id|reg_syntax_t
id|re_set_syntax
(paren
id|syntax
)paren
id|reg_syntax_t
id|syntax
suffix:semicolon
(brace
id|reg_syntax_t
id|ret
op_assign
id|re_syntax_options
suffix:semicolon
id|re_syntax_options
op_assign
id|syntax
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#ifdef _LIBC
DECL|function|weak_alias
id|weak_alias
(paren
id|__re_set_syntax
comma
id|re_set_syntax
)paren
macro_line|#endif
r_int
id|re_compile_fastmap
(paren
id|bufp
)paren
r_struct
id|re_pattern_buffer
op_star
id|bufp
suffix:semicolon
(brace
id|re_dfa_t
op_star
id|dfa
op_assign
(paren
id|re_dfa_t
op_star
)paren
id|bufp-&gt;buffer
suffix:semicolon
r_char
op_star
id|fastmap
op_assign
id|bufp-&gt;fastmap
suffix:semicolon
id|memset
(paren
id|fastmap
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
r_char
)paren
op_star
id|SBC_MAX
)paren
suffix:semicolon
id|re_compile_fastmap_iter
(paren
id|bufp
comma
id|dfa-&gt;init_state
comma
id|fastmap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dfa-&gt;init_state
op_ne
id|dfa-&gt;init_state_word
)paren
id|re_compile_fastmap_iter
(paren
id|bufp
comma
id|dfa-&gt;init_state_word
comma
id|fastmap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dfa-&gt;init_state
op_ne
id|dfa-&gt;init_state_nl
)paren
id|re_compile_fastmap_iter
(paren
id|bufp
comma
id|dfa-&gt;init_state_nl
comma
id|fastmap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dfa-&gt;init_state
op_ne
id|dfa-&gt;init_state_begbuf
)paren
id|re_compile_fastmap_iter
(paren
id|bufp
comma
id|dfa-&gt;init_state_begbuf
comma
id|fastmap
)paren
suffix:semicolon
id|bufp-&gt;fastmap_accurate
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef _LIBC
id|weak_alias
(paren
id|__re_compile_fastmap
comma
id|re_compile_fastmap
)paren
macro_line|#endif
r_static
r_inline
r_void
id|__attribute
(paren
(paren
id|always_inline
)paren
)paren
DECL|function|re_set_fastmap
id|re_set_fastmap
(paren
r_char
op_star
id|fastmap
comma
r_int
id|icase
comma
r_int
id|ch
)paren
(brace
id|fastmap
(braket
id|ch
)braket
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|icase
)paren
id|fastmap
(braket
id|tolower
(paren
id|ch
)paren
)braket
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Helper function for re_compile_fastmap.&n;   Compile fastmap for the initial_state INIT_STATE.  */
r_static
r_void
DECL|function|re_compile_fastmap_iter
id|re_compile_fastmap_iter
(paren
id|regex_t
op_star
id|bufp
comma
r_const
id|re_dfastate_t
op_star
id|init_state
comma
r_char
op_star
id|fastmap
)paren
(brace
r_volatile
id|re_dfa_t
op_star
id|dfa
op_assign
(paren
id|re_dfa_t
op_star
)paren
id|bufp-&gt;buffer
suffix:semicolon
r_int
id|node_cnt
suffix:semicolon
r_int
id|icase
op_assign
(paren
id|dfa-&gt;mb_cur_max
op_eq
l_int|1
op_logical_and
(paren
id|bufp-&gt;syntax
op_amp
id|RE_ICASE
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|node_cnt
op_assign
l_int|0
suffix:semicolon
id|node_cnt
OL
id|init_state-&gt;nodes.nelem
suffix:semicolon
op_increment
id|node_cnt
)paren
(brace
r_int
id|node
op_assign
id|init_state-&gt;nodes.elems
(braket
id|node_cnt
)braket
suffix:semicolon
id|re_token_type_t
id|type
op_assign
id|dfa-&gt;nodes
(braket
id|node
)braket
dot
id|type
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|CHARACTER
)paren
(brace
id|re_set_fastmap
(paren
id|fastmap
comma
id|icase
comma
id|dfa-&gt;nodes
(braket
id|node
)braket
dot
id|opr.c
)paren
suffix:semicolon
macro_line|#ifdef RE_ENABLE_I18N
r_if
c_cond
(paren
(paren
id|bufp-&gt;syntax
op_amp
id|RE_ICASE
)paren
op_logical_and
id|dfa-&gt;mb_cur_max
OG
l_int|1
)paren
(brace
r_int
r_char
op_star
id|buf
op_assign
id|re_malloc
(paren
r_int
r_char
comma
id|dfa-&gt;mb_cur_max
)paren
comma
op_star
id|p
suffix:semicolon
m_wchar_t
id|wc
suffix:semicolon
id|mbstate_t
id|state
suffix:semicolon
id|p
op_assign
id|buf
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|dfa-&gt;nodes
(braket
id|node
)braket
dot
id|opr.c
suffix:semicolon
r_while
c_loop
(paren
op_increment
id|node
OL
id|dfa-&gt;nodes_len
op_logical_and
id|dfa-&gt;nodes
(braket
id|node
)braket
dot
id|type
op_eq
id|CHARACTER
op_logical_and
id|dfa-&gt;nodes
(braket
id|node
)braket
dot
id|mb_partial
)paren
op_star
id|p
op_increment
op_assign
id|dfa-&gt;nodes
(braket
id|node
)braket
dot
id|opr.c
suffix:semicolon
id|memset
(paren
op_amp
id|state
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|state
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|__mbrtowc
(paren
op_amp
id|wc
comma
(paren
r_const
r_char
op_star
)paren
id|buf
comma
id|p
id|buf
comma
op_amp
id|state
)paren
op_eq
id|p
id|buf
op_logical_and
(paren
id|__wcrtomb
(paren
(paren
r_char
op_star
)paren
id|buf
comma
id|towlower
(paren
id|wc
)paren
comma
op_amp
id|state
)paren
op_ne
(paren
r_int
)paren
l_int|1
)paren
)paren
id|re_set_fastmap
(paren
id|fastmap
comma
l_int|0
comma
id|buf
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|re_free
(paren
id|buf
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
r_else
r_if
c_cond
(paren
id|type
op_eq
id|SIMPLE_BRACKET
)paren
(brace
r_int
id|i
comma
id|ch
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|ch
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|BITSET_WORDS
suffix:semicolon
op_increment
id|i
)paren
(brace
r_int
id|j
suffix:semicolon
id|bitset_word_t
id|w
op_assign
id|dfa-&gt;nodes
(braket
id|node
)braket
dot
id|opr.sbcset
(braket
id|i
)braket
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|BITSET_WORD_BITS
suffix:semicolon
op_increment
id|j
comma
op_increment
id|ch
)paren
r_if
c_cond
(paren
id|w
op_amp
(paren
(paren
id|bitset_word_t
)paren
l_int|1
op_lshift
id|j
)paren
)paren
id|re_set_fastmap
(paren
id|fastmap
comma
id|icase
comma
id|ch
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef RE_ENABLE_I18N
r_else
r_if
c_cond
(paren
id|type
op_eq
id|COMPLEX_BRACKET
)paren
(brace
id|re_charset_t
op_star
id|cset
op_assign
id|dfa-&gt;nodes
(braket
id|node
)braket
dot
id|opr.mbcset
suffix:semicolon
r_int
id|i
suffix:semicolon
macro_line|# ifdef _LIBC
multiline_comment|/* See if we have to try all bytes which start multiple collation&n;&t;     elements.&n;&t;     e.g. In da_DK, we want to catch &squot;a&squot; since &quot;aa&quot; is a valid&n;&t;&t;  collation element, and don&squot;t catch &squot;b&squot; since &squot;b&squot; is&n;&t;&t;  the only collation element which starts from &squot;b&squot; (and&n;&t;&t;  it is caught by SIMPLE_BRACKET).  */
r_if
c_cond
(paren
id|_NL_CURRENT_WORD
(paren
id|LC_COLLATE
comma
id|_NL_COLLATE_NRULES
)paren
op_ne
l_int|0
op_logical_and
(paren
id|cset-&gt;ncoll_syms
op_logical_or
id|cset-&gt;nranges
)paren
)paren
(brace
r_const
r_int32
op_star
id|table
op_assign
(paren
r_const
r_int32
op_star
)paren
id|_NL_CURRENT
(paren
id|LC_COLLATE
comma
id|_NL_COLLATE_TABLEMB
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SBC_MAX
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
id|table
(braket
id|i
)braket
OL
l_int|0
)paren
id|re_set_fastmap
(paren
id|fastmap
comma
id|icase
comma
id|i
)paren
suffix:semicolon
)brace
macro_line|# endif /* _LIBC */
multiline_comment|/* See if we have to start the match at all multibyte characters,&n;&t;     i.e. where we would not find an invalid sequence.  This only&n;&t;     applies to multibyte character sets; for single byte character&n;&t;     sets, the SIMPLE_BRACKET again suffices.  */
r_if
c_cond
(paren
id|dfa-&gt;mb_cur_max
OG
l_int|1
op_logical_and
(paren
id|cset-&gt;nchar_classes
op_logical_or
id|cset-&gt;non_match
op_logical_or
id|cset-&gt;nranges
macro_line|# ifdef _LIBC
op_logical_or
id|cset-&gt;nequiv_classes
macro_line|# endif /* _LIBC */
)paren
)paren
(brace
r_int
r_char
id|c
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|mbstate_t
id|mbs
suffix:semicolon
id|memset
(paren
op_amp
id|mbs
comma
l_int|0
comma
r_sizeof
(paren
id|mbs
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|__mbrtowc
(paren
l_int|NULL
comma
(paren
r_char
op_star
)paren
op_amp
id|c
comma
l_int|1
comma
op_amp
id|mbs
)paren
op_eq
(paren
r_int
)paren
l_int|2
)paren
id|re_set_fastmap
(paren
id|fastmap
comma
l_bool|false
comma
(paren
r_int
)paren
id|c
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_increment
id|c
op_ne
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* ... Else catch all bytes which can start the mbchars.  */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cset-&gt;nmbchars
suffix:semicolon
op_increment
id|i
)paren
(brace
r_char
id|buf
(braket
l_int|256
)braket
suffix:semicolon
id|mbstate_t
id|state
suffix:semicolon
id|memset
(paren
op_amp
id|state
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|state
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|__wcrtomb
(paren
id|buf
comma
id|cset-&gt;mbchars
(braket
id|i
)braket
comma
op_amp
id|state
)paren
op_ne
(paren
r_int
)paren
l_int|1
)paren
id|re_set_fastmap
(paren
id|fastmap
comma
id|icase
comma
op_star
(paren
r_int
r_char
op_star
)paren
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bufp-&gt;syntax
op_amp
id|RE_ICASE
)paren
op_logical_and
id|dfa-&gt;mb_cur_max
OG
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|__wcrtomb
(paren
id|buf
comma
id|towlower
(paren
id|cset-&gt;mbchars
(braket
id|i
)braket
)paren
comma
op_amp
id|state
)paren
op_ne
(paren
r_int
)paren
l_int|1
)paren
id|re_set_fastmap
(paren
id|fastmap
comma
l_bool|false
comma
op_star
(paren
r_int
r_char
op_star
)paren
id|buf
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
macro_line|#endif /* RE_ENABLE_I18N */
r_else
r_if
c_cond
(paren
id|type
op_eq
id|OP_PERIOD
macro_line|#ifdef RE_ENABLE_I18N
op_logical_or
id|type
op_eq
id|OP_UTF8_PERIOD
macro_line|#endif /* RE_ENABLE_I18N */
op_logical_or
id|type
op_eq
id|END_OF_RE
)paren
(brace
id|memset
(paren
id|fastmap
comma
l_char|&squot;&bslash;1&squot;
comma
r_sizeof
(paren
r_char
)paren
op_star
id|SBC_MAX
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|END_OF_RE
)paren
id|bufp-&gt;can_be_null
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
)brace
"&f;"
multiline_comment|/* Entry point for POSIX code.  */
multiline_comment|/* regcomp takes a regular expression as a string and compiles it.&n;&n;   PREG is a regex_t *.  We do not expect any fields to be initialized,&n;   since POSIX says we shouldn&squot;t.  Thus, we set&n;&n;     `buffer&squot; to the compiled pattern;&n;     `used&squot; to the length of the compiled pattern;&n;     `syntax&squot; to RE_SYNTAX_POSIX_EXTENDED if the&n;       REG_EXTENDED bit in CFLAGS is set; otherwise, to&n;       RE_SYNTAX_POSIX_BASIC;&n;     `newline_anchor&squot; to REG_NEWLINE being set in CFLAGS;&n;     `fastmap&squot; to an allocated space for the fastmap;&n;     `fastmap_accurate&squot; to zero;&n;     `re_nsub&squot; to the number of subexpressions in PATTERN.&n;&n;   PATTERN is the address of the pattern string.&n;&n;   CFLAGS is a series of bits which affect compilation.&n;&n;     If REG_EXTENDED is set, we use POSIX extended syntax; otherwise, we&n;     use POSIX basic syntax.&n;&n;     If REG_NEWLINE is set, then . and [^...] don&squot;t match newline.&n;     Also, regexec will try a match beginning after every newline.&n;&n;     If REG_ICASE is set, then we considers upper- and lowercase&n;     versions of letters to be equivalent when matching.&n;&n;     If REG_NOSUB is set, then when PREG is passed to regexec, that&n;     routine will report only success or failure, and nothing about the&n;     registers.&n;&n;   It returns 0 if it succeeds, nonzero if it doesn&squot;t.  (See regex.h for&n;   the return codes and their meanings.)  */
r_int
DECL|function|regcomp
id|regcomp
(paren
id|preg
comma
id|pattern
comma
id|cflags
)paren
id|regex_t
op_star
id|__restrict
id|preg
suffix:semicolon
r_const
r_char
op_star
id|__restrict
id|pattern
suffix:semicolon
r_int
id|cflags
suffix:semicolon
(brace
id|reg_errcode_t
id|ret
suffix:semicolon
id|reg_syntax_t
id|syntax
op_assign
(paren
(paren
id|cflags
op_amp
id|REG_EXTENDED
)paren
ques
c_cond
id|RE_SYNTAX_POSIX_EXTENDED
suffix:colon
id|RE_SYNTAX_POSIX_BASIC
)paren
suffix:semicolon
id|preg-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
id|preg-&gt;allocated
op_assign
l_int|0
suffix:semicolon
id|preg-&gt;used
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Try to allocate space for the fastmap.  */
id|preg-&gt;fastmap
op_assign
id|re_malloc
(paren
r_char
comma
id|SBC_MAX
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|preg-&gt;fastmap
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
id|syntax
op_or_assign
(paren
id|cflags
op_amp
id|REG_ICASE
)paren
ques
c_cond
id|RE_ICASE
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* If REG_NEWLINE is set, newlines are treated differently.  */
r_if
c_cond
(paren
id|cflags
op_amp
id|REG_NEWLINE
)paren
(brace
multiline_comment|/* REG_NEWLINE implies neither . nor [^...] match newline.  */
id|syntax
op_and_assign
op_complement
id|RE_DOT_NEWLINE
suffix:semicolon
id|syntax
op_or_assign
id|RE_HAT_LISTS_NOT_NEWLINE
suffix:semicolon
multiline_comment|/* It also changes the matching behavior.  */
id|preg-&gt;newline_anchor
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|preg-&gt;newline_anchor
op_assign
l_int|0
suffix:semicolon
id|preg-&gt;no_sub
op_assign
op_logical_neg
op_logical_neg
(paren
id|cflags
op_amp
id|REG_NOSUB
)paren
suffix:semicolon
id|preg-&gt;translate
op_assign
l_int|NULL
suffix:semicolon
id|ret
op_assign
id|re_compile_internal
(paren
id|preg
comma
id|pattern
comma
id|strlen
(paren
id|pattern
)paren
comma
id|syntax
)paren
suffix:semicolon
multiline_comment|/* POSIX doesn&squot;t distinguish between an unmatched open-group and an&n;     unmatched close-group: both are REG_EPAREN.  */
r_if
c_cond
(paren
id|ret
op_eq
id|REG_ERPAREN
)paren
id|ret
op_assign
id|REG_EPAREN
suffix:semicolon
multiline_comment|/* We have already checked preg-&gt;fastmap != NULL.  */
r_if
c_cond
(paren
id|BE
(paren
id|ret
op_eq
id|REG_NOERROR
comma
l_int|1
)paren
)paren
multiline_comment|/* Compute the fastmap now, since regexec cannot modify the pattern&n;       buffer.  This function never fails in this implementation.  */
(paren
r_void
)paren
id|re_compile_fastmap
(paren
id|preg
)paren
suffix:semicolon
r_else
(brace
multiline_comment|/* Some error occurred while compiling the expression.  */
id|re_free
(paren
id|preg-&gt;fastmap
)paren
suffix:semicolon
id|preg-&gt;fastmap
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
(paren
r_int
)paren
id|ret
suffix:semicolon
)brace
macro_line|#ifdef _LIBC
id|weak_alias
(paren
id|__regcomp
comma
id|regcomp
)paren
macro_line|#endif
multiline_comment|/* Returns a message corresponding to an error code, ERRCODE, returned&n;   from either regcomp or regexec.   We don&squot;t use PREG here.  */
r_int
id|regerror
(paren
id|errcode
comma
id|preg
comma
id|errbuf
comma
id|errbuf_size
)paren
r_int
id|errcode
suffix:semicolon
r_const
id|regex_t
op_star
id|__restrict
id|preg
suffix:semicolon
DECL|variable|errbuf
r_char
op_star
id|__restrict
id|errbuf
suffix:semicolon
DECL|variable|errbuf_size
r_int
id|errbuf_size
suffix:semicolon
(brace
r_const
r_char
op_star
id|msg
suffix:semicolon
r_int
id|msg_size
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|errcode
OL
l_int|0
op_logical_or
id|errcode
op_ge
(paren
r_int
)paren
(paren
r_sizeof
(paren
id|__re_error_msgid_idx
)paren
op_div
r_sizeof
(paren
id|__re_error_msgid_idx
(braket
l_int|0
)braket
)paren
)paren
comma
l_int|0
)paren
)paren
multiline_comment|/* Only error codes returned by the rest of the code should be passed&n;       to this routine.  If we are given anything else, or if other regex&n;       code generates an invalid error code, then the program has a bug.&n;       Dump core so we can fix it.  */
m_abort
(paren
)paren
suffix:semicolon
id|msg
op_assign
id|gettext
(paren
id|__re_error_msgid
op_plus
id|__re_error_msgid_idx
(braket
id|errcode
)braket
)paren
suffix:semicolon
id|msg_size
op_assign
id|strlen
(paren
id|msg
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Includes the null.  */
r_if
c_cond
(paren
id|BE
(paren
id|errbuf_size
op_ne
l_int|0
comma
l_int|1
)paren
)paren
(brace
r_if
c_cond
(paren
id|BE
(paren
id|msg_size
OG
id|errbuf_size
comma
l_int|0
)paren
)paren
(brace
id|memcpy
(paren
id|errbuf
comma
id|msg
comma
id|errbuf_size
l_int|1
)paren
suffix:semicolon
id|errbuf
(braket
id|errbuf_size
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|memcpy
(paren
id|errbuf
comma
id|msg
comma
id|msg_size
)paren
suffix:semicolon
)brace
r_return
id|msg_size
suffix:semicolon
)brace
macro_line|#ifdef _LIBC
id|weak_alias
(paren
id|__regerror
comma
id|regerror
)paren
macro_line|#endif
macro_line|#ifdef RE_ENABLE_I18N
multiline_comment|/* This static array is used for the map to single-byte characters when&n;   UTF-8 is used.  Otherwise we would allocate memory just to initialize&n;   it the same all the time.  UTF-8 is the preferred encoding so this is&n;   a worthwhile optimization.  */
macro_line|#if __GNUC__ &gt;= 3
DECL|variable|utf8_sb_map
r_static
r_const
id|bitset_t
id|utf8_sb_map
op_assign
(brace
multiline_comment|/* Set the first 128 bits.  */
(braket
l_int|0
dot
dot
dot
l_int|0x80
op_div
id|BITSET_WORD_BITS
l_int|1
)braket
op_assign
id|BITSET_WORD_MAX
)brace
suffix:semicolon
macro_line|#else /* ! (__GNUC__ &gt;= 3) */
r_static
id|bitset_t
id|utf8_sb_map
suffix:semicolon
macro_line|#endif /* __GNUC__ &gt;= 3 */
macro_line|#endif /* RE_ENABLE_I18N */
r_static
r_void
DECL|function|free_dfa_content
id|free_dfa_content
(paren
id|re_dfa_t
op_star
id|dfa
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_if
c_cond
(paren
id|dfa-&gt;nodes
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dfa-&gt;nodes_len
suffix:semicolon
op_increment
id|i
)paren
id|free_token
(paren
id|dfa-&gt;nodes
op_plus
id|i
)paren
suffix:semicolon
id|re_free
(paren
id|dfa-&gt;nexts
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dfa-&gt;nodes_len
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|dfa-&gt;eclosures
op_ne
l_int|NULL
)paren
id|re_node_set_free
(paren
id|dfa-&gt;eclosures
op_plus
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dfa-&gt;inveclosures
op_ne
l_int|NULL
)paren
id|re_node_set_free
(paren
id|dfa-&gt;inveclosures
op_plus
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dfa-&gt;edests
op_ne
l_int|NULL
)paren
id|re_node_set_free
(paren
id|dfa-&gt;edests
op_plus
id|i
)paren
suffix:semicolon
)brace
id|re_free
(paren
id|dfa-&gt;edests
)paren
suffix:semicolon
id|re_free
(paren
id|dfa-&gt;eclosures
)paren
suffix:semicolon
id|re_free
(paren
id|dfa-&gt;inveclosures
)paren
suffix:semicolon
id|re_free
(paren
id|dfa-&gt;nodes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dfa-&gt;state_table
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|dfa-&gt;state_hash_mask
suffix:semicolon
op_increment
id|i
)paren
(brace
r_struct
id|re_state_table_entry
op_star
id|entry
op_assign
id|dfa-&gt;state_table
op_plus
id|i
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|entry-&gt;num
suffix:semicolon
op_increment
id|j
)paren
(brace
id|re_dfastate_t
op_star
id|state
op_assign
id|entry-&gt;array
(braket
id|j
)braket
suffix:semicolon
id|free_state
(paren
id|state
)paren
suffix:semicolon
)brace
id|re_free
(paren
id|entry-&gt;array
)paren
suffix:semicolon
)brace
id|re_free
(paren
id|dfa-&gt;state_table
)paren
suffix:semicolon
macro_line|#ifdef RE_ENABLE_I18N
r_if
c_cond
(paren
id|dfa-&gt;sb_char
op_ne
id|utf8_sb_map
)paren
id|re_free
(paren
id|dfa-&gt;sb_char
)paren
suffix:semicolon
macro_line|#endif
id|re_free
(paren
id|dfa-&gt;subexp_map
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|re_free
(paren
id|dfa-&gt;re_str
)paren
suffix:semicolon
macro_line|#endif
id|re_free
(paren
id|dfa
)paren
suffix:semicolon
)brace
multiline_comment|/* Free dynamically allocated space used by PREG.  */
r_void
DECL|function|regfree
id|regfree
(paren
id|preg
)paren
id|regex_t
op_star
id|preg
suffix:semicolon
(brace
id|re_dfa_t
op_star
id|dfa
op_assign
(paren
id|re_dfa_t
op_star
)paren
id|preg-&gt;buffer
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|dfa
op_ne
l_int|NULL
comma
l_int|1
)paren
)paren
id|free_dfa_content
(paren
id|dfa
)paren
suffix:semicolon
id|preg-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
id|preg-&gt;allocated
op_assign
l_int|0
suffix:semicolon
id|re_free
(paren
id|preg-&gt;fastmap
)paren
suffix:semicolon
id|preg-&gt;fastmap
op_assign
l_int|NULL
suffix:semicolon
id|re_free
(paren
id|preg-&gt;translate
)paren
suffix:semicolon
id|preg-&gt;translate
op_assign
l_int|NULL
suffix:semicolon
)brace
macro_line|#ifdef _LIBC
id|weak_alias
(paren
id|__regfree
comma
id|regfree
)paren
macro_line|#endif
"&f;"
multiline_comment|/* Entry points compatible with 4.2 BSD regex library.  We don&squot;t define&n;   them unless specifically requested.  */
macro_line|#if defined _REGEX_RE_COMP || defined _LIBC
multiline_comment|/* BSD has one and only one pattern buffer.  */
DECL|variable|re_comp_buf
r_static
r_struct
id|re_pattern_buffer
id|re_comp_buf
suffix:semicolon
r_char
op_star
macro_line|# ifdef _LIBC
multiline_comment|/* Make these definitions weak in libc, so POSIX programs can redefine&n;   these names if they don&squot;t use our functions, and still use&n;   regcomp/regexec above without link errors.  */
id|weak_function
macro_line|# endif
DECL|function|re_comp
id|re_comp
(paren
id|s
)paren
r_const
r_char
op_star
id|s
suffix:semicolon
(brace
id|reg_errcode_t
id|ret
suffix:semicolon
r_char
op_star
id|fastmap
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|re_comp_buf.buffer
)paren
r_return
id|gettext
(paren
l_string|&quot;No previous regular expression&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|re_comp_buf.buffer
)paren
(brace
id|fastmap
op_assign
id|re_comp_buf.fastmap
suffix:semicolon
id|re_comp_buf.fastmap
op_assign
l_int|NULL
suffix:semicolon
id|__regfree
(paren
op_amp
id|re_comp_buf
)paren
suffix:semicolon
id|memset
(paren
op_amp
id|re_comp_buf
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|re_comp_buf
)paren
)paren
suffix:semicolon
id|re_comp_buf.fastmap
op_assign
id|fastmap
suffix:semicolon
)brace
r_if
c_cond
(paren
id|re_comp_buf.fastmap
op_eq
l_int|NULL
)paren
(brace
id|re_comp_buf.fastmap
op_assign
(paren
r_char
op_star
)paren
id|malloc
(paren
id|SBC_MAX
)paren
suffix:semicolon
r_if
c_cond
(paren
id|re_comp_buf.fastmap
op_eq
l_int|NULL
)paren
r_return
(paren
r_char
op_star
)paren
id|gettext
(paren
id|__re_error_msgid
op_plus
id|__re_error_msgid_idx
(braket
(paren
r_int
)paren
id|REG_ESPACE
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* Since `re_exec&squot; always passes NULL for the `regs&squot; argument, we&n;     don&squot;t need to initialize the pattern buffer fields which affect it.  */
multiline_comment|/* Match anchors at newlines.  */
id|re_comp_buf.newline_anchor
op_assign
l_int|1
suffix:semicolon
id|ret
op_assign
id|re_compile_internal
(paren
op_amp
id|re_comp_buf
comma
id|s
comma
id|strlen
(paren
id|s
)paren
comma
id|re_syntax_options
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* Yes, we&squot;re discarding `const&squot; here if !HAVE_LIBINTL.  */
r_return
(paren
r_char
op_star
)paren
id|gettext
(paren
id|__re_error_msgid
op_plus
id|__re_error_msgid_idx
(braket
(paren
r_int
)paren
id|ret
)braket
)paren
suffix:semicolon
)brace
macro_line|#ifdef _LIBC
DECL|function|libc_freeres_fn
id|libc_freeres_fn
(paren
id|free_mem
)paren
(brace
id|__regfree
(paren
op_amp
id|re_comp_buf
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#endif /* _REGEX_RE_COMP */
"&f;"
multiline_comment|/* Internal entry point.&n;   Compile the regular expression PATTERN, whose length is LENGTH.&n;   SYNTAX indicate regular expression&squot;s syntax.  */
r_static
id|reg_errcode_t
DECL|function|re_compile_internal
id|re_compile_internal
(paren
id|regex_t
op_star
id|preg
comma
r_const
r_char
op_star
id|pattern
comma
r_int
id|length
comma
id|reg_syntax_t
id|syntax
)paren
(brace
id|reg_errcode_t
id|err
op_assign
id|REG_NOERROR
suffix:semicolon
id|re_dfa_t
op_star
id|dfa
suffix:semicolon
id|re_string_t
id|regexp
suffix:semicolon
multiline_comment|/* Initialize the pattern buffer.  */
id|preg-&gt;fastmap_accurate
op_assign
l_int|0
suffix:semicolon
id|preg-&gt;syntax
op_assign
id|syntax
suffix:semicolon
id|preg-&gt;not_bol
op_assign
id|preg-&gt;not_eol
op_assign
l_int|0
suffix:semicolon
id|preg-&gt;used
op_assign
l_int|0
suffix:semicolon
id|preg-&gt;re_nsub
op_assign
l_int|0
suffix:semicolon
id|preg-&gt;can_be_null
op_assign
l_int|0
suffix:semicolon
id|preg-&gt;regs_allocated
op_assign
id|REGS_UNALLOCATED
suffix:semicolon
multiline_comment|/* Initialize the dfa.  */
id|dfa
op_assign
(paren
id|re_dfa_t
op_star
)paren
id|preg-&gt;buffer
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|preg-&gt;allocated
OL
r_sizeof
(paren
id|re_dfa_t
)paren
comma
l_int|0
)paren
)paren
(brace
multiline_comment|/* If zero allocated, but buffer is non-null, try to realloc&n;&t; enough space.  This loses if buffer&squot;s address is bogus, but&n;&t; that is the user&squot;s responsibility.  If -&gt;buffer is NULL this&n;&t; is a simple allocation.  */
id|dfa
op_assign
id|re_realloc
(paren
id|preg-&gt;buffer
comma
id|re_dfa_t
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dfa
op_eq
l_int|NULL
)paren
r_return
id|REG_ESPACE
suffix:semicolon
id|preg-&gt;allocated
op_assign
r_sizeof
(paren
id|re_dfa_t
)paren
suffix:semicolon
id|preg-&gt;buffer
op_assign
(paren
r_int
r_char
op_star
)paren
id|dfa
suffix:semicolon
)brace
id|preg-&gt;used
op_assign
r_sizeof
(paren
id|re_dfa_t
)paren
suffix:semicolon
id|err
op_assign
id|init_dfa
(paren
id|dfa
comma
id|length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
(brace
id|free_dfa_content
(paren
id|dfa
)paren
suffix:semicolon
id|preg-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
id|preg-&gt;allocated
op_assign
l_int|0
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
multiline_comment|/* Note: length+1 will not overflow since it is checked in init_dfa.  */
id|dfa-&gt;re_str
op_assign
id|re_malloc
(paren
r_char
comma
id|length
op_plus
l_int|1
)paren
suffix:semicolon
id|strncpy
(paren
id|dfa-&gt;re_str
comma
id|pattern
comma
id|length
op_plus
l_int|1
)paren
suffix:semicolon
macro_line|#endif
id|__libc_lock_init
(paren
id|dfa-&gt;lock
)paren
suffix:semicolon
id|err
op_assign
id|re_string_construct
(paren
op_amp
id|regexp
comma
id|pattern
comma
id|length
comma
id|preg-&gt;translate
comma
id|syntax
op_amp
id|RE_ICASE
comma
id|dfa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
(brace
id|re_compile_internal_free_return
suffix:colon
id|free_workarea_compile
(paren
id|preg
)paren
suffix:semicolon
id|re_string_destruct
(paren
op_amp
id|regexp
)paren
suffix:semicolon
id|free_dfa_content
(paren
id|dfa
)paren
suffix:semicolon
id|preg-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
id|preg-&gt;allocated
op_assign
l_int|0
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* Parse the regular expression, and build a structure tree.  */
id|preg-&gt;re_nsub
op_assign
l_int|0
suffix:semicolon
id|dfa-&gt;str_tree
op_assign
id|parse
(paren
op_amp
id|regexp
comma
id|preg
comma
id|syntax
comma
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|dfa-&gt;str_tree
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_goto
id|re_compile_internal_free_return
suffix:semicolon
multiline_comment|/* Analyze the tree and create the nfa.  */
id|err
op_assign
id|analyze
(paren
id|preg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_goto
id|re_compile_internal_free_return
suffix:semicolon
macro_line|#ifdef RE_ENABLE_I18N
multiline_comment|/* If possible, do searching in single byte encoding to speed things up.  */
r_if
c_cond
(paren
id|dfa-&gt;is_utf8
op_logical_and
op_logical_neg
(paren
id|syntax
op_amp
id|RE_ICASE
)paren
op_logical_and
id|preg-&gt;translate
op_eq
l_int|NULL
)paren
id|optimize_utf8
(paren
id|dfa
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Then create the initial state of the dfa.  */
id|err
op_assign
id|create_initial_state
(paren
id|dfa
)paren
suffix:semicolon
multiline_comment|/* Release work areas.  */
id|free_workarea_compile
(paren
id|preg
)paren
suffix:semicolon
id|re_string_destruct
(paren
op_amp
id|regexp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
(brace
id|free_dfa_content
(paren
id|dfa
)paren
suffix:semicolon
id|preg-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
id|preg-&gt;allocated
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* Initialize DFA.  We use the length of the regular expression PAT_LEN&n;   as the initial length of some arrays.  */
r_static
id|reg_errcode_t
DECL|function|init_dfa
id|init_dfa
(paren
id|re_dfa_t
op_star
id|dfa
comma
r_int
id|pat_len
)paren
(brace
r_int
r_int
id|table_size
suffix:semicolon
macro_line|#ifndef _LIBC
r_char
op_star
id|codeset_name
suffix:semicolon
macro_line|#endif
id|memset
(paren
id|dfa
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|re_dfa_t
)paren
)paren
suffix:semicolon
multiline_comment|/* Force allocation of str_tree_storage the first time.  */
id|dfa-&gt;str_tree_storage_idx
op_assign
id|BIN_TREE_STORAGE_SIZE
suffix:semicolon
multiline_comment|/* Avoid overflows.  */
r_if
c_cond
(paren
id|pat_len
op_eq
id|SIZE_MAX
)paren
r_return
id|REG_ESPACE
suffix:semicolon
id|dfa-&gt;nodes_alloc
op_assign
id|pat_len
op_plus
l_int|1
suffix:semicolon
id|dfa-&gt;nodes
op_assign
id|re_malloc
(paren
id|re_token_t
comma
id|dfa-&gt;nodes_alloc
)paren
suffix:semicolon
multiline_comment|/*  table_size = 2 ^ ceil(log pat_len) */
r_for
c_loop
(paren
id|table_size
op_assign
l_int|1
suffix:semicolon
suffix:semicolon
id|table_size
op_lshift_assign
l_int|1
)paren
r_if
c_cond
(paren
id|table_size
OG
id|pat_len
)paren
r_break
suffix:semicolon
id|dfa-&gt;state_table
op_assign
id|calloc
(paren
r_sizeof
(paren
r_struct
id|re_state_table_entry
)paren
comma
id|table_size
)paren
suffix:semicolon
id|dfa-&gt;state_hash_mask
op_assign
id|table_size
l_int|1
suffix:semicolon
id|dfa-&gt;mb_cur_max
op_assign
id|MB_CUR_MAX
suffix:semicolon
macro_line|#ifdef _LIBC
r_if
c_cond
(paren
id|dfa-&gt;mb_cur_max
op_eq
l_int|6
op_logical_and
id|strcmp
(paren
id|_NL_CURRENT
(paren
id|LC_CTYPE
comma
id|_NL_CTYPE_CODESET_NAME
)paren
comma
l_string|&quot;UTF-8&quot;
)paren
op_eq
l_int|0
)paren
id|dfa-&gt;is_utf8
op_assign
l_int|1
suffix:semicolon
id|dfa-&gt;map_notascii
op_assign
(paren
id|_NL_CURRENT_WORD
(paren
id|LC_CTYPE
comma
id|_NL_CTYPE_MAP_TO_NONASCII
)paren
op_ne
l_int|0
)paren
suffix:semicolon
macro_line|#else
macro_line|# ifdef HAVE_LANGINFO_CODESET
id|codeset_name
op_assign
id|nl_langinfo
(paren
id|CODESET
)paren
suffix:semicolon
macro_line|# else
id|codeset_name
op_assign
id|getenv
(paren
l_string|&quot;LC_ALL&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|codeset_name
op_eq
l_int|NULL
op_logical_or
id|codeset_name
(braket
l_int|0
)braket
op_eq
l_char|&squot;&bslash;0&squot;
)paren
id|codeset_name
op_assign
id|getenv
(paren
l_string|&quot;LC_CTYPE&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|codeset_name
op_eq
l_int|NULL
op_logical_or
id|codeset_name
(braket
l_int|0
)braket
op_eq
l_char|&squot;&bslash;0&squot;
)paren
id|codeset_name
op_assign
id|getenv
(paren
l_string|&quot;LANG&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|codeset_name
op_eq
l_int|NULL
)paren
id|codeset_name
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strchr
(paren
id|codeset_name
comma
l_char|&squot;.&squot;
)paren
op_ne
l_int|NULL
)paren
id|codeset_name
op_assign
id|strchr
(paren
id|codeset_name
comma
l_char|&squot;.&squot;
)paren
op_plus
l_int|1
suffix:semicolon
macro_line|# endif
multiline_comment|/* strcasecmp isn&squot;t a standard interface. brute force check */
macro_line|#if 0
r_if
c_cond
(paren
id|strcasecmp
(paren
id|codeset_name
comma
l_string|&quot;UTF-8&quot;
)paren
op_eq
l_int|0
op_logical_or
id|strcasecmp
(paren
id|codeset_name
comma
l_string|&quot;UTF8&quot;
)paren
op_eq
l_int|0
)paren
id|dfa-&gt;is_utf8
op_assign
l_int|1
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
(paren
id|codeset_name
(braket
l_int|0
)braket
op_eq
l_char|&squot;U&squot;
op_logical_or
id|codeset_name
(braket
l_int|0
)braket
op_eq
l_char|&squot;u&squot;
)paren
op_logical_and
(paren
id|codeset_name
(braket
l_int|1
)braket
op_eq
l_char|&squot;T&squot;
op_logical_or
id|codeset_name
(braket
l_int|1
)braket
op_eq
l_char|&squot;t&squot;
)paren
op_logical_and
(paren
id|codeset_name
(braket
l_int|2
)braket
op_eq
l_char|&squot;F&squot;
op_logical_or
id|codeset_name
(braket
l_int|2
)braket
op_eq
l_char|&squot;f&squot;
)paren
op_logical_and
(paren
id|codeset_name
(braket
l_int|3
)braket
op_eq
l_char|&squot;-&squot;
ques
c_cond
id|codeset_name
(braket
l_int|4
)braket
op_eq
l_char|&squot;8&squot;
op_logical_and
id|codeset_name
(braket
l_int|5
)braket
op_eq
l_char|&squot;&bslash;0&squot;
suffix:colon
id|codeset_name
(braket
l_int|3
)braket
op_eq
l_char|&squot;8&squot;
op_logical_and
id|codeset_name
(braket
l_int|4
)braket
op_eq
l_char|&squot;&bslash;0&squot;
)paren
)paren
id|dfa-&gt;is_utf8
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
multiline_comment|/* We check exhaustively in the loop below if this charset is a&n;     superset of ASCII.  */
id|dfa-&gt;map_notascii
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
macro_line|#ifdef RE_ENABLE_I18N
r_if
c_cond
(paren
id|dfa-&gt;mb_cur_max
OG
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|dfa-&gt;is_utf8
)paren
(brace
macro_line|#if !defined(__GNUC__) || __GNUC__ &lt; 3
r_static
r_int
id|utf8_sb_map_inited
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|utf8_sb_map_inited
)paren
(brace
r_int
id|i
suffix:semicolon
id|utf8_sb_map_inited
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
l_int|0x80
op_div
id|BITSET_WORD_BITS
l_int|1
suffix:semicolon
id|i
op_increment
)paren
id|utf8_sb_map
(braket
id|i
)braket
op_assign
id|BITSET_WORD_MAX
suffix:semicolon
)brace
macro_line|#endif
id|dfa-&gt;sb_char
op_assign
(paren
id|re_bitset_ptr_t
)paren
id|utf8_sb_map
suffix:semicolon
)brace
r_else
(brace
r_int
id|i
comma
id|j
comma
id|ch
suffix:semicolon
id|dfa-&gt;sb_char
op_assign
(paren
id|re_bitset_ptr_t
)paren
id|calloc
(paren
r_sizeof
(paren
id|bitset_t
)paren
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|dfa-&gt;sb_char
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
multiline_comment|/* Set the bits corresponding to single byte chars.  */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|ch
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|BITSET_WORDS
suffix:semicolon
op_increment
id|i
)paren
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|BITSET_WORD_BITS
suffix:semicolon
op_increment
id|j
comma
op_increment
id|ch
)paren
(brace
id|wint_t
id|wch
op_assign
id|__btowc
(paren
id|ch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wch
op_ne
id|WEOF
)paren
id|dfa-&gt;sb_char
(braket
id|i
)braket
op_or_assign
(paren
id|bitset_word_t
)paren
l_int|1
op_lshift
id|j
suffix:semicolon
macro_line|# ifndef _LIBC
r_if
c_cond
(paren
id|isascii
(paren
id|ch
)paren
op_logical_and
id|wch
op_ne
id|ch
)paren
id|dfa-&gt;map_notascii
op_assign
l_int|1
suffix:semicolon
macro_line|# endif
)brace
)brace
)brace
macro_line|#endif
r_if
c_cond
(paren
id|BE
(paren
id|dfa-&gt;nodes
op_eq
l_int|NULL
op_logical_or
id|dfa-&gt;state_table
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
r_return
id|REG_NOERROR
suffix:semicolon
)brace
multiline_comment|/* Initialize WORD_CHAR table, which indicate which character is&n;   &quot;word&quot;.  In this case &quot;word&quot; means that it is the word construction&n;   character used by some operators like &quot;&bslash;&lt;&quot;, &quot;&bslash;&gt;&quot;, etc.  */
r_static
r_void
id|internal_function
DECL|function|init_word_char
id|init_word_char
(paren
id|re_dfa_t
op_star
id|dfa
)paren
(brace
r_int
id|i
comma
id|j
comma
id|ch
suffix:semicolon
id|dfa-&gt;word_ops_used
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|ch
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|BITSET_WORDS
suffix:semicolon
op_increment
id|i
)paren
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|BITSET_WORD_BITS
suffix:semicolon
op_increment
id|j
comma
op_increment
id|ch
)paren
r_if
c_cond
(paren
id|isalnum
(paren
id|ch
)paren
op_logical_or
id|ch
op_eq
l_char|&squot;_&squot;
)paren
id|dfa-&gt;word_char
(braket
id|i
)braket
op_or_assign
(paren
id|bitset_word_t
)paren
l_int|1
op_lshift
id|j
suffix:semicolon
)brace
multiline_comment|/* Free the work area which are only used while compiling.  */
r_static
r_void
DECL|function|free_workarea_compile
id|free_workarea_compile
(paren
id|regex_t
op_star
id|preg
)paren
(brace
id|re_dfa_t
op_star
id|dfa
op_assign
(paren
id|re_dfa_t
op_star
)paren
id|preg-&gt;buffer
suffix:semicolon
id|bin_tree_storage_t
op_star
id|storage
comma
op_star
id|next
suffix:semicolon
r_for
c_loop
(paren
id|storage
op_assign
id|dfa-&gt;str_tree_storage
suffix:semicolon
id|storage
suffix:semicolon
id|storage
op_assign
id|next
)paren
(brace
id|next
op_assign
id|storage-&gt;next
suffix:semicolon
id|re_free
(paren
id|storage
)paren
suffix:semicolon
)brace
id|dfa-&gt;str_tree_storage
op_assign
l_int|NULL
suffix:semicolon
id|dfa-&gt;str_tree_storage_idx
op_assign
id|BIN_TREE_STORAGE_SIZE
suffix:semicolon
id|dfa-&gt;str_tree
op_assign
l_int|NULL
suffix:semicolon
id|re_free
(paren
id|dfa-&gt;org_indices
)paren
suffix:semicolon
id|dfa-&gt;org_indices
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Create initial states for all contexts.  */
r_static
id|reg_errcode_t
DECL|function|create_initial_state
id|create_initial_state
(paren
id|re_dfa_t
op_star
id|dfa
)paren
(brace
r_int
id|first
comma
id|i
suffix:semicolon
id|reg_errcode_t
id|err
suffix:semicolon
id|re_node_set
id|init_nodes
suffix:semicolon
multiline_comment|/* Initial states have the epsilon closure of the node which is&n;     the first node of the regular expression.  */
id|first
op_assign
id|dfa-&gt;str_tree-&gt;first-&gt;node_idx
suffix:semicolon
id|dfa-&gt;init_node
op_assign
id|first
suffix:semicolon
id|err
op_assign
id|re_node_set_init_copy
(paren
op_amp
id|init_nodes
comma
id|dfa-&gt;eclosures
op_plus
id|first
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|err
suffix:semicolon
multiline_comment|/* The back-references which are in initial states can epsilon transit,&n;     since in this case all of the subexpressions can be null.&n;     Then we add epsilon closures of the nodes which are the next nodes of&n;     the back-references.  */
r_if
c_cond
(paren
id|dfa-&gt;nbackref
OG
l_int|0
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|init_nodes.nelem
suffix:semicolon
op_increment
id|i
)paren
(brace
r_int
id|node_idx
op_assign
id|init_nodes.elems
(braket
id|i
)braket
suffix:semicolon
id|re_token_type_t
id|type
op_assign
id|dfa-&gt;nodes
(braket
id|node_idx
)braket
dot
id|type
suffix:semicolon
r_int
id|clexp_idx
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
id|OP_BACK_REF
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|clexp_idx
op_assign
l_int|0
suffix:semicolon
id|clexp_idx
OL
id|init_nodes.nelem
suffix:semicolon
op_increment
id|clexp_idx
)paren
(brace
id|re_token_t
op_star
id|clexp_node
suffix:semicolon
id|clexp_node
op_assign
id|dfa-&gt;nodes
op_plus
id|init_nodes.elems
(braket
id|clexp_idx
)braket
suffix:semicolon
r_if
c_cond
(paren
id|clexp_node-&gt;type
op_eq
id|OP_CLOSE_SUBEXP
op_logical_and
id|clexp_node-&gt;opr.idx
op_eq
id|dfa-&gt;nodes
(braket
id|node_idx
)braket
dot
id|opr.idx
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|clexp_idx
op_eq
id|init_nodes.nelem
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|OP_BACK_REF
)paren
(brace
r_int
id|dest_idx
op_assign
id|dfa-&gt;edests
(braket
id|node_idx
)braket
dot
id|elems
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|re_node_set_contains
(paren
op_amp
id|init_nodes
comma
id|dest_idx
)paren
)paren
(brace
id|reg_errcode_t
id|err
op_assign
id|re_node_set_merge
(paren
op_amp
id|init_nodes
comma
id|dfa-&gt;eclosures
op_plus
id|dest_idx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
id|REG_NOERROR
)paren
r_return
id|err
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* It must be the first time to invoke acquire_state.  */
id|dfa-&gt;init_state
op_assign
id|re_acquire_state_context
(paren
op_amp
id|err
comma
id|dfa
comma
op_amp
id|init_nodes
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* We don&squot;t check ERR here, since the initial state must not be NULL.  */
r_if
c_cond
(paren
id|BE
(paren
id|dfa-&gt;init_state
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
id|dfa-&gt;init_state-&gt;has_constraint
)paren
(brace
id|dfa-&gt;init_state_word
op_assign
id|re_acquire_state_context
(paren
op_amp
id|err
comma
id|dfa
comma
op_amp
id|init_nodes
comma
id|CONTEXT_WORD
)paren
suffix:semicolon
id|dfa-&gt;init_state_nl
op_assign
id|re_acquire_state_context
(paren
op_amp
id|err
comma
id|dfa
comma
op_amp
id|init_nodes
comma
id|CONTEXT_NEWLINE
)paren
suffix:semicolon
id|dfa-&gt;init_state_begbuf
op_assign
id|re_acquire_state_context
(paren
op_amp
id|err
comma
id|dfa
comma
op_amp
id|init_nodes
comma
id|CONTEXT_NEWLINE
op_or
id|CONTEXT_BEGBUF
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|dfa-&gt;init_state_word
op_eq
l_int|NULL
op_logical_or
id|dfa-&gt;init_state_nl
op_eq
l_int|NULL
op_logical_or
id|dfa-&gt;init_state_begbuf
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
id|err
suffix:semicolon
)brace
r_else
id|dfa-&gt;init_state_word
op_assign
id|dfa-&gt;init_state_nl
op_assign
id|dfa-&gt;init_state_begbuf
op_assign
id|dfa-&gt;init_state
suffix:semicolon
id|re_node_set_free
(paren
op_amp
id|init_nodes
)paren
suffix:semicolon
r_return
id|REG_NOERROR
suffix:semicolon
)brace
"&f;"
macro_line|#ifdef RE_ENABLE_I18N
multiline_comment|/* If it is possible to do searching in single byte encoding instead of UTF-8&n;   to speed things up, set dfa-&gt;mb_cur_max to 1, clear is_utf8 and change&n;   DFA nodes where needed.  */
r_static
r_void
DECL|function|optimize_utf8
id|optimize_utf8
(paren
id|re_dfa_t
op_star
id|dfa
)paren
(brace
r_int
id|node
comma
id|i
comma
id|mb_chars
op_assign
l_int|0
comma
id|has_period
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|node
op_assign
l_int|0
suffix:semicolon
id|node
OL
id|dfa-&gt;nodes_len
suffix:semicolon
op_increment
id|node
)paren
r_switch
c_cond
(paren
id|dfa-&gt;nodes
(braket
id|node
)braket
dot
id|type
)paren
(brace
r_case
id|CHARACTER
suffix:colon
r_if
c_cond
(paren
id|dfa-&gt;nodes
(braket
id|node
)braket
dot
id|opr.c
op_ge
l_int|0x80
)paren
id|mb_chars
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ANCHOR
suffix:colon
r_switch
c_cond
(paren
id|dfa-&gt;nodes
(braket
id|node
)braket
dot
id|opr.ctx_type
)paren
(brace
r_case
id|LINE_FIRST
suffix:colon
r_case
id|LINE_LAST
suffix:colon
r_case
id|BUF_FIRST
suffix:colon
r_case
id|BUF_LAST
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Word anchors etc. cannot be handled.  It&squot;s okay to test&n;&t;       opr.ctx_type since constraints (for all DFA nodes) are&n;&t;       created by ORing one or more opr.ctx_type values.  */
r_return
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OP_PERIOD
suffix:colon
id|has_period
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OP_BACK_REF
suffix:colon
r_case
id|OP_ALT
suffix:colon
r_case
id|END_OF_RE
suffix:colon
r_case
id|OP_DUP_ASTERISK
suffix:colon
r_case
id|OP_OPEN_SUBEXP
suffix:colon
r_case
id|OP_CLOSE_SUBEXP
suffix:colon
r_break
suffix:semicolon
r_case
id|COMPLEX_BRACKET
suffix:colon
r_return
suffix:semicolon
r_case
id|SIMPLE_BRACKET
suffix:colon
multiline_comment|/* Just double check.  The non-ASCII range starts at 0x80.  */
m_assert
(paren
l_int|0x80
op_mod
id|BITSET_WORD_BITS
op_eq
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0x80
op_div
id|BITSET_WORD_BITS
suffix:semicolon
id|i
OL
id|BITSET_WORDS
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
id|dfa-&gt;nodes
(braket
id|node
)braket
dot
id|opr.sbcset
(braket
id|i
)braket
)paren
r_return
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
m_abort
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mb_chars
op_logical_or
id|has_period
)paren
r_for
c_loop
(paren
id|node
op_assign
l_int|0
suffix:semicolon
id|node
OL
id|dfa-&gt;nodes_len
suffix:semicolon
op_increment
id|node
)paren
(brace
r_if
c_cond
(paren
id|dfa-&gt;nodes
(braket
id|node
)braket
dot
id|type
op_eq
id|CHARACTER
op_logical_and
id|dfa-&gt;nodes
(braket
id|node
)braket
dot
id|opr.c
op_ge
l_int|0x80
)paren
id|dfa-&gt;nodes
(braket
id|node
)braket
dot
id|mb_partial
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|dfa-&gt;nodes
(braket
id|node
)braket
dot
id|type
op_eq
id|OP_PERIOD
)paren
id|dfa-&gt;nodes
(braket
id|node
)braket
dot
id|type
op_assign
id|OP_UTF8_PERIOD
suffix:semicolon
)brace
multiline_comment|/* The search can be in single byte locale.  */
id|dfa-&gt;mb_cur_max
op_assign
l_int|1
suffix:semicolon
id|dfa-&gt;is_utf8
op_assign
l_int|0
suffix:semicolon
id|dfa-&gt;has_mb_node
op_assign
id|dfa-&gt;nbackref
OG
l_int|0
op_logical_or
id|has_period
suffix:semicolon
)brace
macro_line|#endif
"&f;"
multiline_comment|/* Analyze the structure tree, and calculate &quot;first&quot;, &quot;next&quot;, &quot;edest&quot;,&n;   &quot;eclosure&quot;, and &quot;inveclosure&quot;.  */
r_static
id|reg_errcode_t
DECL|function|analyze
id|analyze
(paren
id|regex_t
op_star
id|preg
)paren
(brace
id|re_dfa_t
op_star
id|dfa
op_assign
(paren
id|re_dfa_t
op_star
)paren
id|preg-&gt;buffer
suffix:semicolon
id|reg_errcode_t
id|ret
suffix:semicolon
multiline_comment|/* Allocate arrays.  */
id|dfa-&gt;nexts
op_assign
id|re_malloc
(paren
r_int
comma
id|dfa-&gt;nodes_alloc
)paren
suffix:semicolon
id|dfa-&gt;org_indices
op_assign
id|re_malloc
(paren
r_int
comma
id|dfa-&gt;nodes_alloc
)paren
suffix:semicolon
id|dfa-&gt;edests
op_assign
id|re_malloc
(paren
id|re_node_set
comma
id|dfa-&gt;nodes_alloc
)paren
suffix:semicolon
id|dfa-&gt;eclosures
op_assign
id|re_malloc
(paren
id|re_node_set
comma
id|dfa-&gt;nodes_alloc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|dfa-&gt;nexts
op_eq
l_int|NULL
op_logical_or
id|dfa-&gt;org_indices
op_eq
l_int|NULL
op_logical_or
id|dfa-&gt;edests
op_eq
l_int|NULL
op_logical_or
id|dfa-&gt;eclosures
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
id|dfa-&gt;subexp_map
op_assign
id|re_malloc
(paren
r_int
comma
id|preg-&gt;re_nsub
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dfa-&gt;subexp_map
op_ne
l_int|NULL
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|preg-&gt;re_nsub
suffix:semicolon
id|i
op_increment
)paren
id|dfa-&gt;subexp_map
(braket
id|i
)braket
op_assign
id|i
suffix:semicolon
id|preorder
(paren
id|dfa-&gt;str_tree
comma
id|optimize_subexps
comma
id|dfa
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|preg-&gt;re_nsub
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|dfa-&gt;subexp_map
(braket
id|i
)braket
op_ne
id|i
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|preg-&gt;re_nsub
)paren
(brace
id|free
(paren
id|dfa-&gt;subexp_map
)paren
suffix:semicolon
id|dfa-&gt;subexp_map
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
id|ret
op_assign
id|postorder
(paren
id|dfa-&gt;str_tree
comma
id|lower_subexps
comma
id|preg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|ret
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|ret
suffix:semicolon
id|ret
op_assign
id|postorder
(paren
id|dfa-&gt;str_tree
comma
id|calc_first
comma
id|dfa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|ret
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|ret
suffix:semicolon
id|preorder
(paren
id|dfa-&gt;str_tree
comma
id|calc_next
comma
id|dfa
)paren
suffix:semicolon
id|ret
op_assign
id|preorder
(paren
id|dfa-&gt;str_tree
comma
id|link_nfa_nodes
comma
id|dfa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|ret
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|ret
suffix:semicolon
id|ret
op_assign
id|calc_eclosure
(paren
id|dfa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|ret
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|ret
suffix:semicolon
multiline_comment|/* We only need this during the prune_impossible_nodes pass in regexec.c;&n;     skip it if p_i_n will not run, as calc_inveclosure can be quadratic.  */
r_if
c_cond
(paren
(paren
op_logical_neg
id|preg-&gt;no_sub
op_logical_and
id|preg-&gt;re_nsub
OG
l_int|0
op_logical_and
id|dfa-&gt;has_plural_match
)paren
op_logical_or
id|dfa-&gt;nbackref
)paren
(brace
id|dfa-&gt;inveclosures
op_assign
id|re_malloc
(paren
id|re_node_set
comma
id|dfa-&gt;nodes_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|dfa-&gt;inveclosures
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
id|ret
op_assign
id|calc_inveclosure
(paren
id|dfa
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Our parse trees are very unbalanced, so we cannot use a stack to&n;   implement parse tree visits.  Instead, we use parent pointers and&n;   some hairy code in these two functions.  */
r_static
id|reg_errcode_t
DECL|function|postorder
id|postorder
(paren
id|bin_tree_t
op_star
id|root
comma
id|reg_errcode_t
(paren
id|fn
(paren
r_void
op_star
comma
id|bin_tree_t
op_star
)paren
)paren
comma
r_void
op_star
id|extra
)paren
(brace
id|bin_tree_t
op_star
id|node
comma
op_star
id|prev
suffix:semicolon
r_for
c_loop
(paren
id|node
op_assign
id|root
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* Descend down the tree, preferably to the left (or to the right&n;&t; if that&squot;s the only child).  */
r_while
c_loop
(paren
id|node-&gt;left
op_logical_or
id|node-&gt;right
)paren
r_if
c_cond
(paren
id|node-&gt;left
)paren
id|node
op_assign
id|node-&gt;left
suffix:semicolon
r_else
id|node
op_assign
id|node-&gt;right
suffix:semicolon
r_do
(brace
id|reg_errcode_t
id|err
op_assign
id|fn
(paren
id|extra
comma
id|node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
id|node-&gt;parent
op_eq
l_int|NULL
)paren
r_return
id|REG_NOERROR
suffix:semicolon
id|prev
op_assign
id|node
suffix:semicolon
id|node
op_assign
id|node-&gt;parent
suffix:semicolon
)brace
multiline_comment|/* Go up while we have a node that is reached from the right.  */
r_while
c_loop
(paren
id|node-&gt;right
op_eq
id|prev
op_logical_or
id|node-&gt;right
op_eq
l_int|NULL
)paren
suffix:semicolon
id|node
op_assign
id|node-&gt;right
suffix:semicolon
)brace
)brace
r_static
id|reg_errcode_t
DECL|function|preorder
id|preorder
(paren
id|bin_tree_t
op_star
id|root
comma
id|reg_errcode_t
(paren
id|fn
(paren
r_void
op_star
comma
id|bin_tree_t
op_star
)paren
)paren
comma
r_void
op_star
id|extra
)paren
(brace
id|bin_tree_t
op_star
id|node
suffix:semicolon
r_for
c_loop
(paren
id|node
op_assign
id|root
suffix:semicolon
suffix:semicolon
)paren
(brace
id|reg_errcode_t
id|err
op_assign
id|fn
(paren
id|extra
comma
id|node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|err
suffix:semicolon
multiline_comment|/* Go to the left node, or up and to the right.  */
r_if
c_cond
(paren
id|node-&gt;left
)paren
id|node
op_assign
id|node-&gt;left
suffix:semicolon
r_else
(brace
id|bin_tree_t
op_star
id|prev
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|node-&gt;right
op_eq
id|prev
op_logical_or
id|node-&gt;right
op_eq
l_int|NULL
)paren
(brace
id|prev
op_assign
id|node
suffix:semicolon
id|node
op_assign
id|node-&gt;parent
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|node
)paren
r_return
id|REG_NOERROR
suffix:semicolon
)brace
id|node
op_assign
id|node-&gt;right
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Optimization pass: if a SUBEXP is entirely contained, strip it and tell&n;   re_search_internal to map the inner one&squot;s opr.idx to this one&squot;s.  Adjust&n;   backreferences as well.  Requires a preorder visit.  */
r_static
id|reg_errcode_t
DECL|function|optimize_subexps
id|optimize_subexps
(paren
r_void
op_star
id|extra
comma
id|bin_tree_t
op_star
id|node
)paren
(brace
id|re_dfa_t
op_star
id|dfa
op_assign
(paren
id|re_dfa_t
op_star
)paren
id|extra
suffix:semicolon
r_if
c_cond
(paren
id|node-&gt;token.type
op_eq
id|OP_BACK_REF
op_logical_and
id|dfa-&gt;subexp_map
)paren
(brace
r_int
id|idx
op_assign
id|node-&gt;token.opr.idx
suffix:semicolon
id|node-&gt;token.opr.idx
op_assign
id|dfa-&gt;subexp_map
(braket
id|idx
)braket
suffix:semicolon
id|dfa-&gt;used_bkref_map
op_or_assign
l_int|1
op_lshift
id|node-&gt;token.opr.idx
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|node-&gt;token.type
op_eq
id|SUBEXP
op_logical_and
id|node-&gt;left
op_logical_and
id|node-&gt;left-&gt;token.type
op_eq
id|SUBEXP
)paren
(brace
r_int
id|other_idx
op_assign
id|node-&gt;left-&gt;token.opr.idx
suffix:semicolon
id|node-&gt;left
op_assign
id|node-&gt;left-&gt;left
suffix:semicolon
r_if
c_cond
(paren
id|node-&gt;left
)paren
id|node-&gt;left-&gt;parent
op_assign
id|node
suffix:semicolon
id|dfa-&gt;subexp_map
(braket
id|other_idx
)braket
op_assign
id|dfa-&gt;subexp_map
(braket
id|node-&gt;token.opr.idx
)braket
suffix:semicolon
r_if
c_cond
(paren
id|other_idx
OL
id|BITSET_WORD_BITS
)paren
id|dfa-&gt;used_bkref_map
op_and_assign
op_complement
(paren
(paren
id|bitset_word_t
)paren
l_int|1
op_lshift
id|other_idx
)paren
suffix:semicolon
)brace
r_return
id|REG_NOERROR
suffix:semicolon
)brace
multiline_comment|/* Lowering pass: Turn each SUBEXP node into the appropriate concatenation&n;   of OP_OPEN_SUBEXP, the body of the SUBEXP (if any) and OP_CLOSE_SUBEXP.  */
r_static
id|reg_errcode_t
DECL|function|lower_subexps
id|lower_subexps
(paren
r_void
op_star
id|extra
comma
id|bin_tree_t
op_star
id|node
)paren
(brace
id|regex_t
op_star
id|preg
op_assign
(paren
id|regex_t
op_star
)paren
id|extra
suffix:semicolon
id|reg_errcode_t
id|err
op_assign
id|REG_NOERROR
suffix:semicolon
r_if
c_cond
(paren
id|node-&gt;left
op_logical_and
id|node-&gt;left-&gt;token.type
op_eq
id|SUBEXP
)paren
(brace
id|node-&gt;left
op_assign
id|lower_subexp
(paren
op_amp
id|err
comma
id|preg
comma
id|node-&gt;left
)paren
suffix:semicolon
r_if
c_cond
(paren
id|node-&gt;left
)paren
id|node-&gt;left-&gt;parent
op_assign
id|node
suffix:semicolon
)brace
r_if
c_cond
(paren
id|node-&gt;right
op_logical_and
id|node-&gt;right-&gt;token.type
op_eq
id|SUBEXP
)paren
(brace
id|node-&gt;right
op_assign
id|lower_subexp
(paren
op_amp
id|err
comma
id|preg
comma
id|node-&gt;right
)paren
suffix:semicolon
r_if
c_cond
(paren
id|node-&gt;right
)paren
id|node-&gt;right-&gt;parent
op_assign
id|node
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
r_static
id|bin_tree_t
op_star
DECL|function|lower_subexp
id|lower_subexp
(paren
id|reg_errcode_t
op_star
id|err
comma
id|regex_t
op_star
id|preg
comma
id|bin_tree_t
op_star
id|node
)paren
(brace
id|re_dfa_t
op_star
id|dfa
op_assign
(paren
id|re_dfa_t
op_star
)paren
id|preg-&gt;buffer
suffix:semicolon
id|bin_tree_t
op_star
id|body
op_assign
id|node-&gt;left
suffix:semicolon
id|bin_tree_t
op_star
id|op
comma
op_star
id|cls
comma
op_star
id|tree1
comma
op_star
id|tree
suffix:semicolon
r_if
c_cond
(paren
id|preg-&gt;no_sub
multiline_comment|/* We do not optimize empty subexpressions, because otherwise we may&n;&t; have bad CONCAT nodes with NULL children.  This is obviously not&n;&t; very common, so we do not lose much.  An example that triggers&n;&t; this case is the sed &quot;script&quot; /&bslash;(&bslash;)/x.  */
op_logical_and
id|node-&gt;left
op_ne
l_int|NULL
op_logical_and
(paren
id|node-&gt;token.opr.idx
op_ge
id|BITSET_WORD_BITS
op_logical_or
op_logical_neg
(paren
id|dfa-&gt;used_bkref_map
op_amp
(paren
(paren
id|bitset_word_t
)paren
l_int|1
op_lshift
id|node-&gt;token.opr.idx
)paren
)paren
)paren
)paren
r_return
id|node-&gt;left
suffix:semicolon
multiline_comment|/* Convert the SUBEXP node to the concatenation of an&n;     OP_OPEN_SUBEXP, the contents, and an OP_CLOSE_SUBEXP.  */
id|op
op_assign
id|create_tree
(paren
id|dfa
comma
l_int|NULL
comma
l_int|NULL
comma
id|OP_OPEN_SUBEXP
)paren
suffix:semicolon
id|cls
op_assign
id|create_tree
(paren
id|dfa
comma
l_int|NULL
comma
l_int|NULL
comma
id|OP_CLOSE_SUBEXP
)paren
suffix:semicolon
id|tree1
op_assign
id|body
ques
c_cond
id|create_tree
(paren
id|dfa
comma
id|body
comma
id|cls
comma
id|CONCAT
)paren
suffix:colon
id|cls
suffix:semicolon
id|tree
op_assign
id|create_tree
(paren
id|dfa
comma
id|op
comma
id|tree1
comma
id|CONCAT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|tree
op_eq
l_int|NULL
op_logical_or
id|tree1
op_eq
l_int|NULL
op_logical_or
id|op
op_eq
l_int|NULL
op_logical_or
id|cls
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
(brace
op_star
id|err
op_assign
id|REG_ESPACE
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|op-&gt;token.opr.idx
op_assign
id|cls-&gt;token.opr.idx
op_assign
id|node-&gt;token.opr.idx
suffix:semicolon
id|op-&gt;token.opt_subexp
op_assign
id|cls-&gt;token.opt_subexp
op_assign
id|node-&gt;token.opt_subexp
suffix:semicolon
r_return
id|tree
suffix:semicolon
)brace
multiline_comment|/* Pass 1 in building the NFA: compute FIRST and create unlinked automaton&n;   nodes.  Requires a postorder visit.  */
r_static
id|reg_errcode_t
DECL|function|calc_first
id|calc_first
(paren
r_void
op_star
id|extra
comma
id|bin_tree_t
op_star
id|node
)paren
(brace
id|re_dfa_t
op_star
id|dfa
op_assign
(paren
id|re_dfa_t
op_star
)paren
id|extra
suffix:semicolon
r_if
c_cond
(paren
id|node-&gt;token.type
op_eq
id|CONCAT
)paren
(brace
id|node-&gt;first
op_assign
id|node-&gt;left-&gt;first
suffix:semicolon
id|node-&gt;node_idx
op_assign
id|node-&gt;left-&gt;node_idx
suffix:semicolon
)brace
r_else
(brace
id|node-&gt;first
op_assign
id|node
suffix:semicolon
id|node-&gt;node_idx
op_assign
id|re_dfa_add_node
(paren
id|dfa
comma
id|node-&gt;token
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|node-&gt;node_idx
op_eq
l_int|1
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
r_if
c_cond
(paren
id|node-&gt;token.type
op_eq
id|ANCHOR
)paren
id|dfa-&gt;nodes
(braket
id|node-&gt;node_idx
)braket
dot
id|constraint
op_assign
id|node-&gt;token.opr.ctx_type
suffix:semicolon
)brace
r_return
id|REG_NOERROR
suffix:semicolon
)brace
multiline_comment|/* Pass 2: compute NEXT on the tree.  Preorder visit.  */
r_static
id|reg_errcode_t
DECL|function|calc_next
id|calc_next
(paren
r_void
op_star
id|extra
comma
id|bin_tree_t
op_star
id|node
)paren
(brace
r_switch
c_cond
(paren
id|node-&gt;token.type
)paren
(brace
r_case
id|OP_DUP_ASTERISK
suffix:colon
id|node-&gt;left-&gt;next
op_assign
id|node
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CONCAT
suffix:colon
id|node-&gt;left-&gt;next
op_assign
id|node-&gt;right-&gt;first
suffix:semicolon
id|node-&gt;right-&gt;next
op_assign
id|node-&gt;next
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|node-&gt;left
)paren
id|node-&gt;left-&gt;next
op_assign
id|node-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|node-&gt;right
)paren
id|node-&gt;right-&gt;next
op_assign
id|node-&gt;next
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|REG_NOERROR
suffix:semicolon
)brace
multiline_comment|/* Pass 3: link all DFA nodes to their NEXT node (any order will do).  */
r_static
id|reg_errcode_t
DECL|function|link_nfa_nodes
id|link_nfa_nodes
(paren
r_void
op_star
id|extra
comma
id|bin_tree_t
op_star
id|node
)paren
(brace
id|re_dfa_t
op_star
id|dfa
op_assign
(paren
id|re_dfa_t
op_star
)paren
id|extra
suffix:semicolon
r_int
id|idx
op_assign
id|node-&gt;node_idx
suffix:semicolon
id|reg_errcode_t
id|err
op_assign
id|REG_NOERROR
suffix:semicolon
r_switch
c_cond
(paren
id|node-&gt;token.type
)paren
(brace
r_case
id|CONCAT
suffix:colon
r_break
suffix:semicolon
r_case
id|END_OF_RE
suffix:colon
m_assert
(paren
id|node-&gt;next
op_eq
l_int|NULL
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OP_DUP_ASTERISK
suffix:colon
r_case
id|OP_ALT
suffix:colon
(brace
r_int
id|left
comma
id|right
suffix:semicolon
id|dfa-&gt;has_plural_match
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|node-&gt;left
op_ne
l_int|NULL
)paren
id|left
op_assign
id|node-&gt;left-&gt;first-&gt;node_idx
suffix:semicolon
r_else
id|left
op_assign
id|node-&gt;next-&gt;node_idx
suffix:semicolon
r_if
c_cond
(paren
id|node-&gt;right
op_ne
l_int|NULL
)paren
id|right
op_assign
id|node-&gt;right-&gt;first-&gt;node_idx
suffix:semicolon
r_else
id|right
op_assign
id|node-&gt;next-&gt;node_idx
suffix:semicolon
m_assert
(paren
id|left
OG
l_int|1
)paren
suffix:semicolon
m_assert
(paren
id|right
OG
l_int|1
)paren
suffix:semicolon
id|err
op_assign
id|re_node_set_init_2
(paren
id|dfa-&gt;edests
op_plus
id|idx
comma
id|left
comma
id|right
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|ANCHOR
suffix:colon
r_case
id|OP_OPEN_SUBEXP
suffix:colon
r_case
id|OP_CLOSE_SUBEXP
suffix:colon
id|err
op_assign
id|re_node_set_init_1
(paren
id|dfa-&gt;edests
op_plus
id|idx
comma
id|node-&gt;next-&gt;node_idx
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OP_BACK_REF
suffix:colon
id|dfa-&gt;nexts
(braket
id|idx
)braket
op_assign
id|node-&gt;next-&gt;node_idx
suffix:semicolon
r_if
c_cond
(paren
id|node-&gt;token.type
op_eq
id|OP_BACK_REF
)paren
id|err
op_assign
id|re_node_set_init_1
(paren
id|dfa-&gt;edests
op_plus
id|idx
comma
id|dfa-&gt;nexts
(braket
id|idx
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
m_assert
(paren
op_logical_neg
id|IS_EPSILON_NODE
(paren
id|node-&gt;token.type
)paren
)paren
suffix:semicolon
id|dfa-&gt;nexts
(braket
id|idx
)braket
op_assign
id|node-&gt;next-&gt;node_idx
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* Duplicate the epsilon closure of the node ROOT_NODE.&n;   Note that duplicated nodes have constraint INIT_CONSTRAINT in addition&n;   to their own constraint.  */
r_static
id|reg_errcode_t
id|internal_function
DECL|function|duplicate_node_closure
id|duplicate_node_closure
(paren
id|re_dfa_t
op_star
id|dfa
comma
r_int
id|top_org_node
comma
r_int
id|top_clone_node
comma
r_int
id|root_node
comma
r_int
r_int
id|init_constraint
)paren
(brace
r_int
id|org_node
comma
id|clone_node
comma
id|ret
suffix:semicolon
r_int
r_int
id|constraint
op_assign
id|init_constraint
suffix:semicolon
r_for
c_loop
(paren
id|org_node
op_assign
id|top_org_node
comma
id|clone_node
op_assign
id|top_clone_node
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|org_dest
comma
id|clone_dest
suffix:semicolon
r_if
c_cond
(paren
id|dfa-&gt;nodes
(braket
id|org_node
)braket
dot
id|type
op_eq
id|OP_BACK_REF
)paren
(brace
multiline_comment|/* If the back reference epsilon-transit, its destination must&n;&t;     also have the constraint.  Then duplicate the epsilon closure&n;&t;     of the destination of the back reference, and store it in&n;&t;     edests of the back reference.  */
id|org_dest
op_assign
id|dfa-&gt;nexts
(braket
id|org_node
)braket
suffix:semicolon
id|re_node_set_empty
(paren
id|dfa-&gt;edests
op_plus
id|clone_node
)paren
suffix:semicolon
id|clone_dest
op_assign
id|duplicate_node
(paren
id|dfa
comma
id|org_dest
comma
id|constraint
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|clone_dest
op_eq
l_int|1
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
id|dfa-&gt;nexts
(braket
id|clone_node
)braket
op_assign
id|dfa-&gt;nexts
(braket
id|org_node
)braket
suffix:semicolon
id|ret
op_assign
id|re_node_set_insert
(paren
id|dfa-&gt;edests
op_plus
id|clone_node
comma
id|clone_dest
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|ret
OL
l_int|0
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dfa-&gt;edests
(braket
id|org_node
)braket
dot
id|nelem
op_eq
l_int|0
)paren
(brace
multiline_comment|/* In case of the node can&squot;t epsilon-transit, don&squot;t duplicate the&n;&t;     destination and store the original destination as the&n;&t;     destination of the node.  */
id|dfa-&gt;nexts
(braket
id|clone_node
)braket
op_assign
id|dfa-&gt;nexts
(braket
id|org_node
)braket
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dfa-&gt;edests
(braket
id|org_node
)braket
dot
id|nelem
op_eq
l_int|1
)paren
(brace
multiline_comment|/* In case of the node can epsilon-transit, and it has only one&n;&t;     destination.  */
id|org_dest
op_assign
id|dfa-&gt;edests
(braket
id|org_node
)braket
dot
id|elems
(braket
l_int|0
)braket
suffix:semicolon
id|re_node_set_empty
(paren
id|dfa-&gt;edests
op_plus
id|clone_node
)paren
suffix:semicolon
multiline_comment|/* If the node is root_node itself, it means the epsilon clsoure&n;&t;     has a loop.   Then tie it to the destination of the root_node.  */
r_if
c_cond
(paren
id|org_node
op_eq
id|root_node
op_logical_and
id|clone_node
op_ne
id|org_node
)paren
(brace
id|ret
op_assign
id|re_node_set_insert
(paren
id|dfa-&gt;edests
op_plus
id|clone_node
comma
id|org_dest
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|ret
OL
l_int|0
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* In case of the node has another constraint, add it.  */
id|constraint
op_or_assign
id|dfa-&gt;nodes
(braket
id|org_node
)braket
dot
id|constraint
suffix:semicolon
id|clone_dest
op_assign
id|duplicate_node
(paren
id|dfa
comma
id|org_dest
comma
id|constraint
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|clone_dest
op_eq
l_int|1
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
id|ret
op_assign
id|re_node_set_insert
(paren
id|dfa-&gt;edests
op_plus
id|clone_node
comma
id|clone_dest
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|ret
OL
l_int|0
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
)brace
r_else
multiline_comment|/* dfa-&gt;edests[org_node].nelem == 2 */
(brace
multiline_comment|/* In case of the node can epsilon-transit, and it has two&n;&t;     destinations. In the bin_tree_t and DFA, that&squot;s &squot;|&squot; and &squot;*&squot;.   */
id|org_dest
op_assign
id|dfa-&gt;edests
(braket
id|org_node
)braket
dot
id|elems
(braket
l_int|0
)braket
suffix:semicolon
id|re_node_set_empty
(paren
id|dfa-&gt;edests
op_plus
id|clone_node
)paren
suffix:semicolon
multiline_comment|/* Search for a duplicated node which satisfies the constraint.  */
id|clone_dest
op_assign
id|search_duplicated_node
(paren
id|dfa
comma
id|org_dest
comma
id|constraint
)paren
suffix:semicolon
r_if
c_cond
(paren
id|clone_dest
op_eq
l_int|1
)paren
(brace
multiline_comment|/* There is no such duplicated node, create a new one.  */
id|reg_errcode_t
id|err
suffix:semicolon
id|clone_dest
op_assign
id|duplicate_node
(paren
id|dfa
comma
id|org_dest
comma
id|constraint
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|clone_dest
op_eq
l_int|1
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
id|ret
op_assign
id|re_node_set_insert
(paren
id|dfa-&gt;edests
op_plus
id|clone_node
comma
id|clone_dest
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|ret
OL
l_int|0
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
id|err
op_assign
id|duplicate_node_closure
(paren
id|dfa
comma
id|org_dest
comma
id|clone_dest
comma
id|root_node
comma
id|constraint
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|err
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* There is a duplicated node which satisfies the constraint,&n;&t;&t; use it to avoid infinite loop.  */
id|ret
op_assign
id|re_node_set_insert
(paren
id|dfa-&gt;edests
op_plus
id|clone_node
comma
id|clone_dest
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|ret
OL
l_int|0
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
)brace
id|org_dest
op_assign
id|dfa-&gt;edests
(braket
id|org_node
)braket
dot
id|elems
(braket
l_int|1
)braket
suffix:semicolon
id|clone_dest
op_assign
id|duplicate_node
(paren
id|dfa
comma
id|org_dest
comma
id|constraint
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|clone_dest
op_eq
l_int|1
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
id|ret
op_assign
id|re_node_set_insert
(paren
id|dfa-&gt;edests
op_plus
id|clone_node
comma
id|clone_dest
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|ret
OL
l_int|0
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
)brace
id|org_node
op_assign
id|org_dest
suffix:semicolon
id|clone_node
op_assign
id|clone_dest
suffix:semicolon
)brace
r_return
id|REG_NOERROR
suffix:semicolon
)brace
multiline_comment|/* Search for a node which is duplicated from the node ORG_NODE, and&n;   satisfies the constraint CONSTRAINT.  */
r_static
r_int
DECL|function|search_duplicated_node
id|search_duplicated_node
(paren
r_const
id|re_dfa_t
op_star
id|dfa
comma
r_int
id|org_node
comma
r_int
r_int
id|constraint
)paren
(brace
r_int
id|idx
suffix:semicolon
r_for
c_loop
(paren
id|idx
op_assign
id|dfa-&gt;nodes_len
l_int|1
suffix:semicolon
id|dfa-&gt;nodes
(braket
id|idx
)braket
dot
id|duplicated
op_logical_and
id|idx
OG
l_int|0
suffix:semicolon
op_decrement
id|idx
)paren
(brace
r_if
c_cond
(paren
id|org_node
op_eq
id|dfa-&gt;org_indices
(braket
id|idx
)braket
op_logical_and
id|constraint
op_eq
id|dfa-&gt;nodes
(braket
id|idx
)braket
dot
id|constraint
)paren
r_return
id|idx
suffix:semicolon
multiline_comment|/* Found.  */
)brace
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Not found.  */
)brace
multiline_comment|/* Duplicate the node whose index is ORG_IDX and set the constraint CONSTRAINT.&n;   Return the index of the new node, or -1 if insufficient storage is&n;   available.  */
r_static
r_int
DECL|function|duplicate_node
id|duplicate_node
(paren
id|re_dfa_t
op_star
id|dfa
comma
r_int
id|org_idx
comma
r_int
r_int
id|constraint
)paren
(brace
r_int
id|dup_idx
op_assign
id|re_dfa_add_node
(paren
id|dfa
comma
id|dfa-&gt;nodes
(braket
id|org_idx
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|dup_idx
op_ne
l_int|1
comma
l_int|1
)paren
)paren
(brace
id|dfa-&gt;nodes
(braket
id|dup_idx
)braket
dot
id|constraint
op_assign
id|constraint
suffix:semicolon
id|dfa-&gt;nodes
(braket
id|dup_idx
)braket
dot
id|constraint
op_or_assign
id|dfa-&gt;nodes
(braket
id|org_idx
)braket
dot
id|constraint
suffix:semicolon
id|dfa-&gt;nodes
(braket
id|dup_idx
)braket
dot
id|duplicated
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Store the index of the original node.  */
id|dfa-&gt;org_indices
(braket
id|dup_idx
)braket
op_assign
id|org_idx
suffix:semicolon
)brace
r_return
id|dup_idx
suffix:semicolon
)brace
r_static
id|reg_errcode_t
DECL|function|calc_inveclosure
id|calc_inveclosure
(paren
id|re_dfa_t
op_star
id|dfa
)paren
(brace
r_int
id|src
comma
id|idx
comma
id|ret
suffix:semicolon
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
id|dfa-&gt;nodes_len
suffix:semicolon
op_increment
id|idx
)paren
id|re_node_set_init_empty
(paren
id|dfa-&gt;inveclosures
op_plus
id|idx
)paren
suffix:semicolon
r_for
c_loop
(paren
id|src
op_assign
l_int|0
suffix:semicolon
id|src
OL
id|dfa-&gt;nodes_len
suffix:semicolon
op_increment
id|src
)paren
(brace
r_int
op_star
id|elems
op_assign
id|dfa-&gt;eclosures
(braket
id|src
)braket
dot
id|elems
suffix:semicolon
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
id|dfa-&gt;eclosures
(braket
id|src
)braket
dot
id|nelem
suffix:semicolon
op_increment
id|idx
)paren
(brace
id|ret
op_assign
id|re_node_set_insert_last
(paren
id|dfa-&gt;inveclosures
op_plus
id|elems
(braket
id|idx
)braket
comma
id|src
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|ret
op_eq
l_int|1
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
)brace
)brace
r_return
id|REG_NOERROR
suffix:semicolon
)brace
multiline_comment|/* Calculate &quot;eclosure&quot; for all the node in DFA.  */
r_static
id|reg_errcode_t
DECL|function|calc_eclosure
id|calc_eclosure
(paren
id|re_dfa_t
op_star
id|dfa
)paren
(brace
r_int
id|node_idx
comma
id|incomplete
suffix:semicolon
macro_line|#ifdef DEBUG
m_assert
(paren
id|dfa-&gt;nodes_len
OG
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|incomplete
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* For each nodes, calculate epsilon closure.  */
r_for
c_loop
(paren
id|node_idx
op_assign
l_int|0
suffix:semicolon
suffix:semicolon
op_increment
id|node_idx
)paren
(brace
id|reg_errcode_t
id|err
suffix:semicolon
id|re_node_set
id|eclosure_elem
suffix:semicolon
r_if
c_cond
(paren
id|node_idx
op_eq
id|dfa-&gt;nodes_len
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|incomplete
)paren
r_break
suffix:semicolon
id|incomplete
op_assign
l_int|0
suffix:semicolon
id|node_idx
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
m_assert
(paren
id|dfa-&gt;eclosures
(braket
id|node_idx
)braket
dot
id|nelem
op_ne
l_int|1
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* If we have already calculated, skip it.  */
r_if
c_cond
(paren
id|dfa-&gt;eclosures
(braket
id|node_idx
)braket
dot
id|nelem
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
multiline_comment|/* Calculate epsilon closure of `node_idx&squot;.  */
id|err
op_assign
id|calc_eclosure_iter
(paren
op_amp
id|eclosure_elem
comma
id|dfa
comma
id|node_idx
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
id|dfa-&gt;eclosures
(braket
id|node_idx
)braket
dot
id|nelem
op_eq
l_int|0
)paren
(brace
id|incomplete
op_assign
l_int|1
suffix:semicolon
id|re_node_set_free
(paren
op_amp
id|eclosure_elem
)paren
suffix:semicolon
)brace
)brace
r_return
id|REG_NOERROR
suffix:semicolon
)brace
multiline_comment|/* Calculate epsilon closure of NODE.  */
r_static
id|reg_errcode_t
DECL|function|calc_eclosure_iter
id|calc_eclosure_iter
(paren
id|re_node_set
op_star
id|new_set
comma
id|re_dfa_t
op_star
id|dfa
comma
r_int
id|node
comma
r_int
id|root
)paren
(brace
id|reg_errcode_t
id|err
suffix:semicolon
r_int
id|i
suffix:semicolon
id|re_node_set
id|eclosure
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
id|incomplete
op_assign
l_int|0
suffix:semicolon
id|err
op_assign
id|re_node_set_alloc
(paren
op_amp
id|eclosure
comma
id|dfa-&gt;edests
(braket
id|node
)braket
dot
id|nelem
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|err
suffix:semicolon
multiline_comment|/* This indicates that we are calculating this node now.&n;     We reference this value to avoid infinite loop.  */
id|dfa-&gt;eclosures
(braket
id|node
)braket
dot
id|nelem
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* If the current node has constraints, duplicate all nodes&n;     since they must inherit the constraints.  */
r_if
c_cond
(paren
id|dfa-&gt;nodes
(braket
id|node
)braket
dot
id|constraint
op_logical_and
id|dfa-&gt;edests
(braket
id|node
)braket
dot
id|nelem
op_logical_and
op_logical_neg
id|dfa-&gt;nodes
(braket
id|dfa-&gt;edests
(braket
id|node
)braket
dot
id|elems
(braket
l_int|0
)braket
)braket
dot
id|duplicated
)paren
(brace
id|err
op_assign
id|duplicate_node_closure
(paren
id|dfa
comma
id|node
comma
id|node
comma
id|node
comma
id|dfa-&gt;nodes
(braket
id|node
)braket
dot
id|constraint
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* Expand each epsilon destination nodes.  */
r_if
c_cond
(paren
id|IS_EPSILON_NODE
c_func
(paren
id|dfa-&gt;nodes
(braket
id|node
)braket
dot
id|type
)paren
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dfa-&gt;edests
(braket
id|node
)braket
dot
id|nelem
suffix:semicolon
op_increment
id|i
)paren
(brace
id|re_node_set
id|eclosure_elem
suffix:semicolon
r_int
id|edest
op_assign
id|dfa-&gt;edests
(braket
id|node
)braket
dot
id|elems
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* If calculating the epsilon closure of `edest&squot; is in progress,&n;&t;   return intermediate result.  */
r_if
c_cond
(paren
id|dfa-&gt;eclosures
(braket
id|edest
)braket
dot
id|nelem
op_eq
l_int|1
)paren
(brace
id|incomplete
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* If we haven&squot;t calculated the epsilon closure of `edest&squot; yet,&n;&t;   calculate now. Otherwise use calculated epsilon closure.  */
r_if
c_cond
(paren
id|dfa-&gt;eclosures
(braket
id|edest
)braket
dot
id|nelem
op_eq
l_int|0
)paren
(brace
id|err
op_assign
id|calc_eclosure_iter
(paren
op_amp
id|eclosure_elem
comma
id|dfa
comma
id|edest
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|err
suffix:semicolon
)brace
r_else
id|eclosure_elem
op_assign
id|dfa-&gt;eclosures
(braket
id|edest
)braket
suffix:semicolon
multiline_comment|/* Merge the epsilon closure of `edest&squot;.  */
id|err
op_assign
id|re_node_set_merge
(paren
op_amp
id|eclosure
comma
op_amp
id|eclosure_elem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|err
suffix:semicolon
multiline_comment|/* If the epsilon closure of `edest&squot; is incomplete,&n;&t;   the epsilon closure of this node is also incomplete.  */
r_if
c_cond
(paren
id|dfa-&gt;eclosures
(braket
id|edest
)braket
dot
id|nelem
op_eq
l_int|0
)paren
(brace
id|incomplete
op_assign
l_int|1
suffix:semicolon
id|re_node_set_free
(paren
op_amp
id|eclosure_elem
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* An epsilon closure includes itself.  */
id|ret
op_assign
id|re_node_set_insert
(paren
op_amp
id|eclosure
comma
id|node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|ret
OL
l_int|0
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
r_if
c_cond
(paren
id|incomplete
op_logical_and
op_logical_neg
id|root
)paren
id|dfa-&gt;eclosures
(braket
id|node
)braket
dot
id|nelem
op_assign
l_int|0
suffix:semicolon
r_else
id|dfa-&gt;eclosures
(braket
id|node
)braket
op_assign
id|eclosure
suffix:semicolon
op_star
id|new_set
op_assign
id|eclosure
suffix:semicolon
r_return
id|REG_NOERROR
suffix:semicolon
)brace
"&f;"
multiline_comment|/* Functions for token which are used in the parser.  */
multiline_comment|/* Fetch a token from INPUT.&n;   We must not use this function inside bracket expressions.  */
r_static
r_void
id|internal_function
DECL|function|fetch_token
id|fetch_token
(paren
id|re_token_t
op_star
id|result
comma
id|re_string_t
op_star
id|input
comma
id|reg_syntax_t
id|syntax
)paren
(brace
id|re_string_skip_bytes
(paren
id|input
comma
id|peek_token
(paren
id|result
comma
id|input
comma
id|syntax
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Peek a token from INPUT, and return the length of the token.&n;   We must not use this function inside bracket expressions.  */
r_static
r_int
id|internal_function
DECL|function|peek_token
id|peek_token
(paren
id|re_token_t
op_star
id|token
comma
id|re_string_t
op_star
id|input
comma
id|reg_syntax_t
id|syntax
)paren
(brace
r_int
r_char
id|c
suffix:semicolon
r_if
c_cond
(paren
id|re_string_eoi
(paren
id|input
)paren
)paren
(brace
id|token-&gt;type
op_assign
id|END_OF_RE
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|c
op_assign
id|re_string_peek_byte
(paren
id|input
comma
l_int|0
)paren
suffix:semicolon
id|token-&gt;opr.c
op_assign
id|c
suffix:semicolon
id|token-&gt;word_char
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef RE_ENABLE_I18N
id|token-&gt;mb_partial
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|input-&gt;mb_cur_max
OG
l_int|1
op_logical_and
op_logical_neg
id|re_string_first_byte
(paren
id|input
comma
id|re_string_cur_idx
(paren
id|input
)paren
)paren
)paren
(brace
id|token-&gt;type
op_assign
id|CHARACTER
suffix:semicolon
id|token-&gt;mb_partial
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;&bslash;&squot;
)paren
(brace
r_int
r_char
id|c2
suffix:semicolon
r_if
c_cond
(paren
id|re_string_cur_idx
(paren
id|input
)paren
op_plus
l_int|1
op_ge
id|re_string_length
(paren
id|input
)paren
)paren
(brace
id|token-&gt;type
op_assign
id|BACK_SLASH
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|c2
op_assign
id|re_string_peek_byte_case
(paren
id|input
comma
l_int|1
)paren
suffix:semicolon
id|token-&gt;opr.c
op_assign
id|c2
suffix:semicolon
id|token-&gt;type
op_assign
id|CHARACTER
suffix:semicolon
macro_line|#ifdef RE_ENABLE_I18N
r_if
c_cond
(paren
id|input-&gt;mb_cur_max
OG
l_int|1
)paren
(brace
id|wint_t
id|wc
op_assign
id|re_string_wchar_at
(paren
id|input
comma
id|re_string_cur_idx
(paren
id|input
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|token-&gt;word_char
op_assign
id|IS_WIDE_WORD_CHAR
(paren
id|wc
)paren
op_ne
l_int|0
suffix:semicolon
)brace
r_else
macro_line|#endif
id|token-&gt;word_char
op_assign
id|IS_WORD_CHAR
(paren
id|c2
)paren
op_ne
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|c2
)paren
(brace
r_case
l_char|&squot;|&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|syntax
op_amp
id|RE_LIMITED_OPS
)paren
op_logical_and
op_logical_neg
(paren
id|syntax
op_amp
id|RE_NO_BK_VBAR
)paren
)paren
id|token-&gt;type
op_assign
id|OP_ALT
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;1&squot;
suffix:colon
r_case
l_char|&squot;2&squot;
suffix:colon
r_case
l_char|&squot;3&squot;
suffix:colon
r_case
l_char|&squot;4&squot;
suffix:colon
r_case
l_char|&squot;5&squot;
suffix:colon
r_case
l_char|&squot;6&squot;
suffix:colon
r_case
l_char|&squot;7&squot;
suffix:colon
r_case
l_char|&squot;8&squot;
suffix:colon
r_case
l_char|&squot;9&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|syntax
op_amp
id|RE_NO_BK_REFS
)paren
)paren
(brace
id|token-&gt;type
op_assign
id|OP_BACK_REF
suffix:semicolon
id|token-&gt;opr.idx
op_assign
id|c2
l_char|&squot;1&squot;
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;&lt;&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|syntax
op_amp
id|RE_NO_GNU_OPS
)paren
)paren
(brace
id|token-&gt;type
op_assign
id|ANCHOR
suffix:semicolon
id|token-&gt;opr.ctx_type
op_assign
id|WORD_FIRST
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;&gt;&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|syntax
op_amp
id|RE_NO_GNU_OPS
)paren
)paren
(brace
id|token-&gt;type
op_assign
id|ANCHOR
suffix:semicolon
id|token-&gt;opr.ctx_type
op_assign
id|WORD_LAST
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;b&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|syntax
op_amp
id|RE_NO_GNU_OPS
)paren
)paren
(brace
id|token-&gt;type
op_assign
id|ANCHOR
suffix:semicolon
id|token-&gt;opr.ctx_type
op_assign
id|WORD_DELIM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;B&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|syntax
op_amp
id|RE_NO_GNU_OPS
)paren
)paren
(brace
id|token-&gt;type
op_assign
id|ANCHOR
suffix:semicolon
id|token-&gt;opr.ctx_type
op_assign
id|NOT_WORD_DELIM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;w&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|syntax
op_amp
id|RE_NO_GNU_OPS
)paren
)paren
id|token-&gt;type
op_assign
id|OP_WORD
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;W&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|syntax
op_amp
id|RE_NO_GNU_OPS
)paren
)paren
id|token-&gt;type
op_assign
id|OP_NOTWORD
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;s&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|syntax
op_amp
id|RE_NO_GNU_OPS
)paren
)paren
id|token-&gt;type
op_assign
id|OP_SPACE
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;S&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|syntax
op_amp
id|RE_NO_GNU_OPS
)paren
)paren
id|token-&gt;type
op_assign
id|OP_NOTSPACE
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;`&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|syntax
op_amp
id|RE_NO_GNU_OPS
)paren
)paren
(brace
id|token-&gt;type
op_assign
id|ANCHOR
suffix:semicolon
id|token-&gt;opr.ctx_type
op_assign
id|BUF_FIRST
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;&bslash;&squot;&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|syntax
op_amp
id|RE_NO_GNU_OPS
)paren
)paren
(brace
id|token-&gt;type
op_assign
id|ANCHOR
suffix:semicolon
id|token-&gt;opr.ctx_type
op_assign
id|BUF_LAST
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;(&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|syntax
op_amp
id|RE_NO_BK_PARENS
)paren
)paren
id|token-&gt;type
op_assign
id|OP_OPEN_SUBEXP
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;)&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|syntax
op_amp
id|RE_NO_BK_PARENS
)paren
)paren
id|token-&gt;type
op_assign
id|OP_CLOSE_SUBEXP
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;+&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|syntax
op_amp
id|RE_LIMITED_OPS
)paren
op_logical_and
(paren
id|syntax
op_amp
id|RE_BK_PLUS_QM
)paren
)paren
id|token-&gt;type
op_assign
id|OP_DUP_PLUS
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;?&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|syntax
op_amp
id|RE_LIMITED_OPS
)paren
op_logical_and
(paren
id|syntax
op_amp
id|RE_BK_PLUS_QM
)paren
)paren
id|token-&gt;type
op_assign
id|OP_DUP_QUESTION
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;{&squot;
suffix:colon
r_if
c_cond
(paren
(paren
id|syntax
op_amp
id|RE_INTERVALS
)paren
op_logical_and
(paren
op_logical_neg
(paren
id|syntax
op_amp
id|RE_NO_BK_BRACES
)paren
)paren
)paren
id|token-&gt;type
op_assign
id|OP_OPEN_DUP_NUM
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;}&squot;
suffix:colon
r_if
c_cond
(paren
(paren
id|syntax
op_amp
id|RE_INTERVALS
)paren
op_logical_and
(paren
op_logical_neg
(paren
id|syntax
op_amp
id|RE_NO_BK_BRACES
)paren
)paren
)paren
id|token-&gt;type
op_assign
id|OP_CLOSE_DUP_NUM
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_return
l_int|2
suffix:semicolon
)brace
id|token-&gt;type
op_assign
id|CHARACTER
suffix:semicolon
macro_line|#ifdef RE_ENABLE_I18N
r_if
c_cond
(paren
id|input-&gt;mb_cur_max
OG
l_int|1
)paren
(brace
id|wint_t
id|wc
op_assign
id|re_string_wchar_at
(paren
id|input
comma
id|re_string_cur_idx
(paren
id|input
)paren
)paren
suffix:semicolon
id|token-&gt;word_char
op_assign
id|IS_WIDE_WORD_CHAR
(paren
id|wc
)paren
op_ne
l_int|0
suffix:semicolon
)brace
r_else
macro_line|#endif
id|token-&gt;word_char
op_assign
id|IS_WORD_CHAR
(paren
id|token-&gt;opr.c
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
l_char|&squot;&bslash;n&squot;
suffix:colon
r_if
c_cond
(paren
id|syntax
op_amp
id|RE_NEWLINE_ALT
)paren
id|token-&gt;type
op_assign
id|OP_ALT
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;|&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|syntax
op_amp
id|RE_LIMITED_OPS
)paren
op_logical_and
(paren
id|syntax
op_amp
id|RE_NO_BK_VBAR
)paren
)paren
id|token-&gt;type
op_assign
id|OP_ALT
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;*&squot;
suffix:colon
id|token-&gt;type
op_assign
id|OP_DUP_ASTERISK
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;+&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|syntax
op_amp
id|RE_LIMITED_OPS
)paren
op_logical_and
op_logical_neg
(paren
id|syntax
op_amp
id|RE_BK_PLUS_QM
)paren
)paren
id|token-&gt;type
op_assign
id|OP_DUP_PLUS
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;?&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|syntax
op_amp
id|RE_LIMITED_OPS
)paren
op_logical_and
op_logical_neg
(paren
id|syntax
op_amp
id|RE_BK_PLUS_QM
)paren
)paren
id|token-&gt;type
op_assign
id|OP_DUP_QUESTION
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;{&squot;
suffix:colon
r_if
c_cond
(paren
(paren
id|syntax
op_amp
id|RE_INTERVALS
)paren
op_logical_and
(paren
id|syntax
op_amp
id|RE_NO_BK_BRACES
)paren
)paren
id|token-&gt;type
op_assign
id|OP_OPEN_DUP_NUM
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;}&squot;
suffix:colon
r_if
c_cond
(paren
(paren
id|syntax
op_amp
id|RE_INTERVALS
)paren
op_logical_and
(paren
id|syntax
op_amp
id|RE_NO_BK_BRACES
)paren
)paren
id|token-&gt;type
op_assign
id|OP_CLOSE_DUP_NUM
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;(&squot;
suffix:colon
r_if
c_cond
(paren
id|syntax
op_amp
id|RE_NO_BK_PARENS
)paren
id|token-&gt;type
op_assign
id|OP_OPEN_SUBEXP
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;)&squot;
suffix:colon
r_if
c_cond
(paren
id|syntax
op_amp
id|RE_NO_BK_PARENS
)paren
id|token-&gt;type
op_assign
id|OP_CLOSE_SUBEXP
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;[&squot;
suffix:colon
id|token-&gt;type
op_assign
id|OP_OPEN_BRACKET
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;.&squot;
suffix:colon
id|token-&gt;type
op_assign
id|OP_PERIOD
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;^&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|syntax
op_amp
(paren
id|RE_CONTEXT_INDEP_ANCHORS
op_or
id|RE_CARET_ANCHORS_HERE
)paren
)paren
op_logical_and
id|re_string_cur_idx
(paren
id|input
)paren
op_ne
l_int|0
)paren
(brace
r_char
id|prev
op_assign
id|re_string_peek_byte
(paren
id|input
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|syntax
op_amp
id|RE_NEWLINE_ALT
)paren
op_logical_or
id|prev
op_ne
l_char|&squot;&bslash;n&squot;
)paren
r_break
suffix:semicolon
)brace
id|token-&gt;type
op_assign
id|ANCHOR
suffix:semicolon
id|token-&gt;opr.ctx_type
op_assign
id|LINE_FIRST
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;$&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|syntax
op_amp
id|RE_CONTEXT_INDEP_ANCHORS
)paren
op_logical_and
id|re_string_cur_idx
(paren
id|input
)paren
op_plus
l_int|1
op_ne
id|re_string_length
(paren
id|input
)paren
)paren
(brace
id|re_token_t
id|next
suffix:semicolon
id|re_string_skip_bytes
(paren
id|input
comma
l_int|1
)paren
suffix:semicolon
id|peek_token
(paren
op_amp
id|next
comma
id|input
comma
id|syntax
)paren
suffix:semicolon
id|re_string_skip_bytes
(paren
id|input
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|next.type
op_ne
id|OP_ALT
op_logical_and
id|next.type
op_ne
id|OP_CLOSE_SUBEXP
)paren
r_break
suffix:semicolon
)brace
id|token-&gt;type
op_assign
id|ANCHOR
suffix:semicolon
id|token-&gt;opr.ctx_type
op_assign
id|LINE_LAST
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Peek a token from INPUT, and return the length of the token.&n;   We must not use this function out of bracket expressions.  */
r_static
r_int
id|internal_function
DECL|function|peek_token_bracket
id|peek_token_bracket
(paren
id|re_token_t
op_star
id|token
comma
id|re_string_t
op_star
id|input
comma
id|reg_syntax_t
id|syntax
)paren
(brace
r_int
r_char
id|c
suffix:semicolon
r_if
c_cond
(paren
id|re_string_eoi
(paren
id|input
)paren
)paren
(brace
id|token-&gt;type
op_assign
id|END_OF_RE
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|c
op_assign
id|re_string_peek_byte
(paren
id|input
comma
l_int|0
)paren
suffix:semicolon
id|token-&gt;opr.c
op_assign
id|c
suffix:semicolon
macro_line|#ifdef RE_ENABLE_I18N
r_if
c_cond
(paren
id|input-&gt;mb_cur_max
OG
l_int|1
op_logical_and
op_logical_neg
id|re_string_first_byte
(paren
id|input
comma
id|re_string_cur_idx
(paren
id|input
)paren
)paren
)paren
(brace
id|token-&gt;type
op_assign
id|CHARACTER
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif /* RE_ENABLE_I18N */
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;&bslash;&squot;
op_logical_and
(paren
id|syntax
op_amp
id|RE_BACKSLASH_ESCAPE_IN_LISTS
)paren
op_logical_and
id|re_string_cur_idx
(paren
id|input
)paren
op_plus
l_int|1
OL
id|re_string_length
(paren
id|input
)paren
)paren
(brace
multiline_comment|/* In this case, &squot;&bslash;&squot; escape a character.  */
r_int
r_char
id|c2
suffix:semicolon
id|re_string_skip_bytes
(paren
id|input
comma
l_int|1
)paren
suffix:semicolon
id|c2
op_assign
id|re_string_peek_byte
(paren
id|input
comma
l_int|0
)paren
suffix:semicolon
id|token-&gt;opr.c
op_assign
id|c2
suffix:semicolon
id|token-&gt;type
op_assign
id|CHARACTER
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;[&squot;
)paren
multiline_comment|/* &squot;[&squot; is a special char in a bracket exps.  */
(brace
r_int
r_char
id|c2
suffix:semicolon
r_int
id|token_len
suffix:semicolon
r_if
c_cond
(paren
id|re_string_cur_idx
(paren
id|input
)paren
op_plus
l_int|1
OL
id|re_string_length
(paren
id|input
)paren
)paren
id|c2
op_assign
id|re_string_peek_byte
(paren
id|input
comma
l_int|1
)paren
suffix:semicolon
r_else
id|c2
op_assign
l_int|0
suffix:semicolon
id|token-&gt;opr.c
op_assign
id|c2
suffix:semicolon
id|token_len
op_assign
l_int|2
suffix:semicolon
r_switch
c_cond
(paren
id|c2
)paren
(brace
r_case
l_char|&squot;.&squot;
suffix:colon
id|token-&gt;type
op_assign
id|OP_OPEN_COLL_ELEM
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;=&squot;
suffix:colon
id|token-&gt;type
op_assign
id|OP_OPEN_EQUIV_CLASS
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;:&squot;
suffix:colon
r_if
c_cond
(paren
id|syntax
op_amp
id|RE_CHAR_CLASSES
)paren
(brace
id|token-&gt;type
op_assign
id|OP_OPEN_CHAR_CLASS
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* else fall through.  */
r_default
suffix:colon
id|token-&gt;type
op_assign
id|CHARACTER
suffix:semicolon
id|token-&gt;opr.c
op_assign
id|c
suffix:semicolon
id|token_len
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|token_len
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
l_char|&squot;-&squot;
suffix:colon
id|token-&gt;type
op_assign
id|OP_CHARSET_RANGE
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;]&squot;
suffix:colon
id|token-&gt;type
op_assign
id|OP_CLOSE_BRACKET
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;^&squot;
suffix:colon
id|token-&gt;type
op_assign
id|OP_NON_MATCH_LIST
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|token-&gt;type
op_assign
id|CHARACTER
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
"&f;"
multiline_comment|/* Functions for parser.  */
multiline_comment|/* Entry point of the parser.&n;   Parse the regular expression REGEXP and return the structure tree.&n;   If an error is occured, ERR is set by error code, and return NULL.&n;   This function build the following tree, from regular expression &lt;reg_exp&gt;:&n;&t;   CAT&n;&t;   / &bslash;&n;&t;  /   &bslash;&n;   &lt;reg_exp&gt;  EOR&n;&n;   CAT means concatenation.&n;   EOR means end of regular expression.  */
r_static
id|bin_tree_t
op_star
DECL|function|parse
id|parse
(paren
id|re_string_t
op_star
id|regexp
comma
id|regex_t
op_star
id|preg
comma
id|reg_syntax_t
id|syntax
comma
id|reg_errcode_t
op_star
id|err
)paren
(brace
id|re_dfa_t
op_star
id|dfa
op_assign
(paren
id|re_dfa_t
op_star
)paren
id|preg-&gt;buffer
suffix:semicolon
id|bin_tree_t
op_star
id|tree
comma
op_star
id|eor
comma
op_star
id|root
suffix:semicolon
id|re_token_t
id|current_token
suffix:semicolon
id|dfa-&gt;syntax
op_assign
id|syntax
suffix:semicolon
id|fetch_token
(paren
op_amp
id|current_token
comma
id|regexp
comma
id|syntax
op_or
id|RE_CARET_ANCHORS_HERE
)paren
suffix:semicolon
id|tree
op_assign
id|parse_reg_exp
(paren
id|regexp
comma
id|preg
comma
op_amp
id|current_token
comma
id|syntax
comma
l_int|0
comma
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
op_star
id|err
op_ne
id|REG_NOERROR
op_logical_and
id|tree
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|eor
op_assign
id|create_tree
(paren
id|dfa
comma
l_int|NULL
comma
l_int|NULL
comma
id|END_OF_RE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tree
op_ne
l_int|NULL
)paren
id|root
op_assign
id|create_tree
(paren
id|dfa
comma
id|tree
comma
id|eor
comma
id|CONCAT
)paren
suffix:semicolon
r_else
id|root
op_assign
id|eor
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|eor
op_eq
l_int|NULL
op_logical_or
id|root
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
(brace
op_star
id|err
op_assign
id|REG_ESPACE
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|root
suffix:semicolon
)brace
multiline_comment|/* This function build the following tree, from regular expression&n;   &lt;branch1&gt;|&lt;branch2&gt;:&n;&t;   ALT&n;&t;   / &bslash;&n;&t;  /   &bslash;&n;   &lt;branch1&gt; &lt;branch2&gt;&n;&n;   ALT means alternative, which represents the operator `|&squot;.  */
r_static
id|bin_tree_t
op_star
DECL|function|parse_reg_exp
id|parse_reg_exp
(paren
id|re_string_t
op_star
id|regexp
comma
id|regex_t
op_star
id|preg
comma
id|re_token_t
op_star
id|token
comma
id|reg_syntax_t
id|syntax
comma
r_int
id|nest
comma
id|reg_errcode_t
op_star
id|err
)paren
(brace
id|re_dfa_t
op_star
id|dfa
op_assign
(paren
id|re_dfa_t
op_star
)paren
id|preg-&gt;buffer
suffix:semicolon
id|bin_tree_t
op_star
id|tree
comma
op_star
id|branch
op_assign
l_int|NULL
suffix:semicolon
id|tree
op_assign
id|parse_branch
(paren
id|regexp
comma
id|preg
comma
id|token
comma
id|syntax
comma
id|nest
comma
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
op_star
id|err
op_ne
id|REG_NOERROR
op_logical_and
id|tree
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|token-&gt;type
op_eq
id|OP_ALT
)paren
(brace
id|fetch_token
(paren
id|token
comma
id|regexp
comma
id|syntax
op_or
id|RE_CARET_ANCHORS_HERE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|token-&gt;type
op_ne
id|OP_ALT
op_logical_and
id|token-&gt;type
op_ne
id|END_OF_RE
op_logical_and
(paren
id|nest
op_eq
l_int|0
op_logical_or
id|token-&gt;type
op_ne
id|OP_CLOSE_SUBEXP
)paren
)paren
(brace
id|branch
op_assign
id|parse_branch
(paren
id|regexp
comma
id|preg
comma
id|token
comma
id|syntax
comma
id|nest
comma
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
op_star
id|err
op_ne
id|REG_NOERROR
op_logical_and
id|branch
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
r_else
id|branch
op_assign
l_int|NULL
suffix:semicolon
id|tree
op_assign
id|create_tree
(paren
id|dfa
comma
id|tree
comma
id|branch
comma
id|OP_ALT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|tree
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
(brace
op_star
id|err
op_assign
id|REG_ESPACE
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
r_return
id|tree
suffix:semicolon
)brace
multiline_comment|/* This function build the following tree, from regular expression&n;   &lt;exp1&gt;&lt;exp2&gt;:&n;&t;CAT&n;&t;/ &bslash;&n;       /   &bslash;&n;   &lt;exp1&gt; &lt;exp2&gt;&n;&n;   CAT means concatenation.  */
r_static
id|bin_tree_t
op_star
DECL|function|parse_branch
id|parse_branch
(paren
id|re_string_t
op_star
id|regexp
comma
id|regex_t
op_star
id|preg
comma
id|re_token_t
op_star
id|token
comma
id|reg_syntax_t
id|syntax
comma
r_int
id|nest
comma
id|reg_errcode_t
op_star
id|err
)paren
(brace
id|bin_tree_t
op_star
id|tree
comma
op_star
id|exp
suffix:semicolon
id|re_dfa_t
op_star
id|dfa
op_assign
(paren
id|re_dfa_t
op_star
)paren
id|preg-&gt;buffer
suffix:semicolon
id|tree
op_assign
id|parse_expression
(paren
id|regexp
comma
id|preg
comma
id|token
comma
id|syntax
comma
id|nest
comma
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
op_star
id|err
op_ne
id|REG_NOERROR
op_logical_and
id|tree
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|token-&gt;type
op_ne
id|OP_ALT
op_logical_and
id|token-&gt;type
op_ne
id|END_OF_RE
op_logical_and
(paren
id|nest
op_eq
l_int|0
op_logical_or
id|token-&gt;type
op_ne
id|OP_CLOSE_SUBEXP
)paren
)paren
(brace
id|exp
op_assign
id|parse_expression
(paren
id|regexp
comma
id|preg
comma
id|token
comma
id|syntax
comma
id|nest
comma
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
op_star
id|err
op_ne
id|REG_NOERROR
op_logical_and
id|exp
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tree
op_ne
l_int|NULL
op_logical_and
id|exp
op_ne
l_int|NULL
)paren
(brace
id|tree
op_assign
id|create_tree
(paren
id|dfa
comma
id|tree
comma
id|exp
comma
id|CONCAT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tree
op_eq
l_int|NULL
)paren
(brace
op_star
id|err
op_assign
id|REG_ESPACE
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|tree
op_eq
l_int|NULL
)paren
id|tree
op_assign
id|exp
suffix:semicolon
multiline_comment|/* Otherwise exp == NULL, we don&squot;t need to create new tree.  */
)brace
r_return
id|tree
suffix:semicolon
)brace
multiline_comment|/* This function build the following tree, from regular expression a*:&n;&t; *&n;&t; |&n;&t; a&n;*/
r_static
id|bin_tree_t
op_star
DECL|function|parse_expression
id|parse_expression
(paren
id|re_string_t
op_star
id|regexp
comma
id|regex_t
op_star
id|preg
comma
id|re_token_t
op_star
id|token
comma
id|reg_syntax_t
id|syntax
comma
r_int
id|nest
comma
id|reg_errcode_t
op_star
id|err
)paren
(brace
id|re_dfa_t
op_star
id|dfa
op_assign
(paren
id|re_dfa_t
op_star
)paren
id|preg-&gt;buffer
suffix:semicolon
id|bin_tree_t
op_star
id|tree
suffix:semicolon
r_switch
c_cond
(paren
id|token-&gt;type
)paren
(brace
r_case
id|CHARACTER
suffix:colon
id|tree
op_assign
id|create_token_tree
(paren
id|dfa
comma
l_int|NULL
comma
l_int|NULL
comma
id|token
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|tree
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
(brace
op_star
id|err
op_assign
id|REG_ESPACE
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#ifdef RE_ENABLE_I18N
r_if
c_cond
(paren
id|dfa-&gt;mb_cur_max
OG
l_int|1
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
id|re_string_eoi
(paren
id|regexp
)paren
op_logical_and
op_logical_neg
id|re_string_first_byte
(paren
id|regexp
comma
id|re_string_cur_idx
(paren
id|regexp
)paren
)paren
)paren
(brace
id|bin_tree_t
op_star
id|mbc_remain
suffix:semicolon
id|fetch_token
(paren
id|token
comma
id|regexp
comma
id|syntax
)paren
suffix:semicolon
id|mbc_remain
op_assign
id|create_token_tree
(paren
id|dfa
comma
l_int|NULL
comma
l_int|NULL
comma
id|token
)paren
suffix:semicolon
id|tree
op_assign
id|create_tree
(paren
id|dfa
comma
id|tree
comma
id|mbc_remain
comma
id|CONCAT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|mbc_remain
op_eq
l_int|NULL
op_logical_or
id|tree
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
(brace
op_star
id|err
op_assign
id|REG_ESPACE
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
r_break
suffix:semicolon
r_case
id|OP_OPEN_SUBEXP
suffix:colon
id|tree
op_assign
id|parse_sub_exp
(paren
id|regexp
comma
id|preg
comma
id|token
comma
id|syntax
comma
id|nest
op_plus
l_int|1
comma
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
op_star
id|err
op_ne
id|REG_NOERROR
op_logical_and
id|tree
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OP_OPEN_BRACKET
suffix:colon
id|tree
op_assign
id|parse_bracket_exp
(paren
id|regexp
comma
id|dfa
comma
id|token
comma
id|syntax
comma
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
op_star
id|err
op_ne
id|REG_NOERROR
op_logical_and
id|tree
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OP_BACK_REF
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|BE
(paren
id|dfa-&gt;completed_bkref_map
op_amp
(paren
l_int|1
op_lshift
id|token-&gt;opr.idx
)paren
comma
l_int|1
)paren
)paren
(brace
op_star
id|err
op_assign
id|REG_ESUBREG
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|dfa-&gt;used_bkref_map
op_or_assign
l_int|1
op_lshift
id|token-&gt;opr.idx
suffix:semicolon
id|tree
op_assign
id|create_token_tree
(paren
id|dfa
comma
l_int|NULL
comma
l_int|NULL
comma
id|token
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|tree
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
(brace
op_star
id|err
op_assign
id|REG_ESPACE
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
op_increment
id|dfa-&gt;nbackref
suffix:semicolon
id|dfa-&gt;has_mb_node
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OP_OPEN_DUP_NUM
suffix:colon
r_if
c_cond
(paren
id|syntax
op_amp
id|RE_CONTEXT_INVALID_DUP
)paren
(brace
op_star
id|err
op_assign
id|REG_BADRPT
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* FALLTHROUGH */
r_case
id|OP_DUP_ASTERISK
suffix:colon
r_case
id|OP_DUP_PLUS
suffix:colon
r_case
id|OP_DUP_QUESTION
suffix:colon
r_if
c_cond
(paren
id|syntax
op_amp
id|RE_CONTEXT_INVALID_OPS
)paren
(brace
op_star
id|err
op_assign
id|REG_BADRPT
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|syntax
op_amp
id|RE_CONTEXT_INDEP_OPS
)paren
(brace
id|fetch_token
(paren
id|token
comma
id|regexp
comma
id|syntax
)paren
suffix:semicolon
r_return
id|parse_expression
(paren
id|regexp
comma
id|preg
comma
id|token
comma
id|syntax
comma
id|nest
comma
id|err
)paren
suffix:semicolon
)brace
multiline_comment|/* else fall through  */
r_case
id|OP_CLOSE_SUBEXP
suffix:colon
r_if
c_cond
(paren
(paren
id|token-&gt;type
op_eq
id|OP_CLOSE_SUBEXP
)paren
op_logical_and
op_logical_neg
(paren
id|syntax
op_amp
id|RE_UNMATCHED_RIGHT_PAREN_ORD
)paren
)paren
(brace
op_star
id|err
op_assign
id|REG_ERPAREN
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* else fall through  */
r_case
id|OP_CLOSE_DUP_NUM
suffix:colon
multiline_comment|/* We treat it as a normal character.  */
multiline_comment|/* Then we can these characters as normal characters.  */
id|token-&gt;type
op_assign
id|CHARACTER
suffix:semicolon
multiline_comment|/* mb_partial and word_char bits should be initialized already&n;&t; by peek_token.  */
id|tree
op_assign
id|create_token_tree
(paren
id|dfa
comma
l_int|NULL
comma
l_int|NULL
comma
id|token
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|tree
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
(brace
op_star
id|err
op_assign
id|REG_ESPACE
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|ANCHOR
suffix:colon
r_if
c_cond
(paren
(paren
id|token-&gt;opr.ctx_type
op_amp
(paren
id|WORD_DELIM
op_or
id|NOT_WORD_DELIM
op_or
id|WORD_FIRST
op_or
id|WORD_LAST
)paren
)paren
op_logical_and
id|dfa-&gt;word_ops_used
op_eq
l_int|0
)paren
id|init_word_char
(paren
id|dfa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|token-&gt;opr.ctx_type
op_eq
id|WORD_DELIM
op_logical_or
id|token-&gt;opr.ctx_type
op_eq
id|NOT_WORD_DELIM
)paren
(brace
id|bin_tree_t
op_star
id|tree_first
comma
op_star
id|tree_last
suffix:semicolon
r_if
c_cond
(paren
id|token-&gt;opr.ctx_type
op_eq
id|WORD_DELIM
)paren
(brace
id|token-&gt;opr.ctx_type
op_assign
id|WORD_FIRST
suffix:semicolon
id|tree_first
op_assign
id|create_token_tree
(paren
id|dfa
comma
l_int|NULL
comma
l_int|NULL
comma
id|token
)paren
suffix:semicolon
id|token-&gt;opr.ctx_type
op_assign
id|WORD_LAST
suffix:semicolon
)brace
r_else
(brace
id|token-&gt;opr.ctx_type
op_assign
id|INSIDE_WORD
suffix:semicolon
id|tree_first
op_assign
id|create_token_tree
(paren
id|dfa
comma
l_int|NULL
comma
l_int|NULL
comma
id|token
)paren
suffix:semicolon
id|token-&gt;opr.ctx_type
op_assign
id|INSIDE_NOTWORD
suffix:semicolon
)brace
id|tree_last
op_assign
id|create_token_tree
(paren
id|dfa
comma
l_int|NULL
comma
l_int|NULL
comma
id|token
)paren
suffix:semicolon
id|tree
op_assign
id|create_tree
(paren
id|dfa
comma
id|tree_first
comma
id|tree_last
comma
id|OP_ALT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|tree_first
op_eq
l_int|NULL
op_logical_or
id|tree_last
op_eq
l_int|NULL
op_logical_or
id|tree
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
(brace
op_star
id|err
op_assign
id|REG_ESPACE
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
r_else
(brace
id|tree
op_assign
id|create_token_tree
(paren
id|dfa
comma
l_int|NULL
comma
l_int|NULL
comma
id|token
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|tree
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
(brace
op_star
id|err
op_assign
id|REG_ESPACE
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* We must return here, since ANCHORs can&squot;t be followed&n;&t; by repetition operators.&n;&t; eg. RE&quot;^*&quot; is invalid or &quot;&lt;ANCHOR(^)&gt;&lt;CHAR(*)&gt;&quot;,&n;&t;     it must not be &quot;&lt;ANCHOR(^)&gt;&lt;REPEAT(*)&gt;&quot;.  */
id|fetch_token
(paren
id|token
comma
id|regexp
comma
id|syntax
)paren
suffix:semicolon
r_return
id|tree
suffix:semicolon
r_case
id|OP_PERIOD
suffix:colon
id|tree
op_assign
id|create_token_tree
(paren
id|dfa
comma
l_int|NULL
comma
l_int|NULL
comma
id|token
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|tree
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
(brace
op_star
id|err
op_assign
id|REG_ESPACE
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dfa-&gt;mb_cur_max
OG
l_int|1
)paren
id|dfa-&gt;has_mb_node
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OP_WORD
suffix:colon
r_case
id|OP_NOTWORD
suffix:colon
id|tree
op_assign
id|build_charclass_op
(paren
id|dfa
comma
id|regexp-&gt;trans
comma
l_string|&quot;alnum&quot;
comma
l_string|&quot;_&quot;
comma
id|token-&gt;type
op_eq
id|OP_NOTWORD
comma
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
op_star
id|err
op_ne
id|REG_NOERROR
op_logical_and
id|tree
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OP_SPACE
suffix:colon
r_case
id|OP_NOTSPACE
suffix:colon
id|tree
op_assign
id|build_charclass_op
(paren
id|dfa
comma
id|regexp-&gt;trans
comma
l_string|&quot;space&quot;
comma
l_string|&quot;&quot;
comma
id|token-&gt;type
op_eq
id|OP_NOTSPACE
comma
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
op_star
id|err
op_ne
id|REG_NOERROR
op_logical_and
id|tree
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OP_ALT
suffix:colon
r_case
id|END_OF_RE
suffix:colon
r_return
l_int|NULL
suffix:semicolon
r_case
id|BACK_SLASH
suffix:colon
op_star
id|err
op_assign
id|REG_EESCAPE
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Must not happen?  */
macro_line|#ifdef DEBUG
m_assert
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|NULL
suffix:semicolon
)brace
id|fetch_token
(paren
id|token
comma
id|regexp
comma
id|syntax
)paren
suffix:semicolon
r_while
c_loop
(paren
id|token-&gt;type
op_eq
id|OP_DUP_ASTERISK
op_logical_or
id|token-&gt;type
op_eq
id|OP_DUP_PLUS
op_logical_or
id|token-&gt;type
op_eq
id|OP_DUP_QUESTION
op_logical_or
id|token-&gt;type
op_eq
id|OP_OPEN_DUP_NUM
)paren
(brace
id|tree
op_assign
id|parse_dup_op
(paren
id|tree
comma
id|regexp
comma
id|dfa
comma
id|token
comma
id|syntax
comma
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
op_star
id|err
op_ne
id|REG_NOERROR
op_logical_and
id|tree
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* In BRE consecutive duplications are not allowed.  */
r_if
c_cond
(paren
(paren
id|syntax
op_amp
id|RE_CONTEXT_INVALID_DUP
)paren
op_logical_and
(paren
id|token-&gt;type
op_eq
id|OP_DUP_ASTERISK
op_logical_or
id|token-&gt;type
op_eq
id|OP_OPEN_DUP_NUM
)paren
)paren
(brace
op_star
id|err
op_assign
id|REG_BADRPT
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
r_return
id|tree
suffix:semicolon
)brace
multiline_comment|/* This function build the following tree, from regular expression&n;   (&lt;reg_exp&gt;):&n;&t; SUBEXP&n;&t;    |&n;&t;&lt;reg_exp&gt;&n;*/
r_static
id|bin_tree_t
op_star
DECL|function|parse_sub_exp
id|parse_sub_exp
(paren
id|re_string_t
op_star
id|regexp
comma
id|regex_t
op_star
id|preg
comma
id|re_token_t
op_star
id|token
comma
id|reg_syntax_t
id|syntax
comma
r_int
id|nest
comma
id|reg_errcode_t
op_star
id|err
)paren
(brace
id|re_dfa_t
op_star
id|dfa
op_assign
(paren
id|re_dfa_t
op_star
)paren
id|preg-&gt;buffer
suffix:semicolon
id|bin_tree_t
op_star
id|tree
suffix:semicolon
r_int
id|cur_nsub
suffix:semicolon
id|cur_nsub
op_assign
id|preg-&gt;re_nsub
op_increment
suffix:semicolon
id|fetch_token
(paren
id|token
comma
id|regexp
comma
id|syntax
op_or
id|RE_CARET_ANCHORS_HERE
)paren
suffix:semicolon
multiline_comment|/* The subexpression may be a null string.  */
r_if
c_cond
(paren
id|token-&gt;type
op_eq
id|OP_CLOSE_SUBEXP
)paren
id|tree
op_assign
l_int|NULL
suffix:semicolon
r_else
(brace
id|tree
op_assign
id|parse_reg_exp
(paren
id|regexp
comma
id|preg
comma
id|token
comma
id|syntax
comma
id|nest
comma
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
op_star
id|err
op_eq
id|REG_NOERROR
op_logical_and
id|token-&gt;type
op_ne
id|OP_CLOSE_SUBEXP
comma
l_int|0
)paren
)paren
op_star
id|err
op_assign
id|REG_EPAREN
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
op_star
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cur_nsub
op_le
l_char|&squot;9&squot;
l_char|&squot;1&squot;
)paren
id|dfa-&gt;completed_bkref_map
op_or_assign
l_int|1
op_lshift
id|cur_nsub
suffix:semicolon
id|tree
op_assign
id|create_tree
(paren
id|dfa
comma
id|tree
comma
l_int|NULL
comma
id|SUBEXP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|tree
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
(brace
op_star
id|err
op_assign
id|REG_ESPACE
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|tree-&gt;token.opr.idx
op_assign
id|cur_nsub
suffix:semicolon
r_return
id|tree
suffix:semicolon
)brace
multiline_comment|/* This function parse repetition operators like &quot;*&quot;, &quot;+&quot;, &quot;{1,3}&quot; etc.  */
r_static
id|bin_tree_t
op_star
DECL|function|parse_dup_op
id|parse_dup_op
(paren
id|bin_tree_t
op_star
id|elem
comma
id|re_string_t
op_star
id|regexp
comma
id|re_dfa_t
op_star
id|dfa
comma
id|re_token_t
op_star
id|token
comma
id|reg_syntax_t
id|syntax
comma
id|reg_errcode_t
op_star
id|err
)paren
(brace
id|bin_tree_t
op_star
id|tree
op_assign
l_int|NULL
comma
op_star
id|old_tree
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
comma
id|start
comma
id|end
comma
id|start_idx
op_assign
id|re_string_cur_idx
(paren
id|regexp
)paren
suffix:semicolon
macro_line|#ifndef RE_TOKEN_INIT_BUG
id|re_token_t
id|start_token
op_assign
op_star
id|token
suffix:semicolon
macro_line|#else
id|re_token_t
id|start_token
suffix:semicolon
id|memcpy
(paren
(paren
r_void
op_star
)paren
op_amp
id|start_token
comma
(paren
r_void
op_star
)paren
id|token
comma
r_sizeof
id|start_token
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|token-&gt;type
op_eq
id|OP_OPEN_DUP_NUM
)paren
(brace
id|end
op_assign
l_int|0
suffix:semicolon
id|start
op_assign
id|fetch_number
(paren
id|regexp
comma
id|token
comma
id|syntax
)paren
suffix:semicolon
r_if
c_cond
(paren
id|start
op_eq
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|token-&gt;type
op_eq
id|CHARACTER
op_logical_and
id|token-&gt;opr.c
op_eq
l_char|&squot;,&squot;
)paren
id|start
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We treat &quot;{,m}&quot; as &quot;{0,m}&quot;.  */
r_else
(brace
op_star
id|err
op_assign
id|REG_BADBR
suffix:semicolon
multiline_comment|/* &lt;re&gt;{} is invalid.  */
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|BE
(paren
id|start
op_ne
l_int|2
comma
l_int|1
)paren
)paren
(brace
multiline_comment|/* We treat &quot;{n}&quot; as &quot;{n,n}&quot;.  */
id|end
op_assign
(paren
(paren
id|token-&gt;type
op_eq
id|OP_CLOSE_DUP_NUM
)paren
ques
c_cond
id|start
suffix:colon
(paren
(paren
id|token-&gt;type
op_eq
id|CHARACTER
op_logical_and
id|token-&gt;opr.c
op_eq
l_char|&squot;,&squot;
)paren
ques
c_cond
id|fetch_number
(paren
id|regexp
comma
id|token
comma
id|syntax
)paren
suffix:colon
l_int|2
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|BE
(paren
id|start
op_eq
l_int|2
op_logical_or
id|end
op_eq
l_int|2
comma
l_int|0
)paren
)paren
(brace
multiline_comment|/* Invalid sequence.  */
r_if
c_cond
(paren
id|BE
(paren
op_logical_neg
(paren
id|syntax
op_amp
id|RE_INVALID_INTERVAL_ORD
)paren
comma
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|token-&gt;type
op_eq
id|END_OF_RE
)paren
op_star
id|err
op_assign
id|REG_EBRACE
suffix:semicolon
r_else
op_star
id|err
op_assign
id|REG_BADBR
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* If the syntax bit is set, rollback.  */
id|re_string_set_index
(paren
id|regexp
comma
id|start_idx
)paren
suffix:semicolon
op_star
id|token
op_assign
id|start_token
suffix:semicolon
id|token-&gt;type
op_assign
id|CHARACTER
suffix:semicolon
multiline_comment|/* mb_partial and word_char bits should be already initialized by&n;&t;     peek_token.  */
r_return
id|elem
suffix:semicolon
)brace
r_if
c_cond
(paren
id|BE
(paren
(paren
id|end
op_ne
l_int|1
op_logical_and
id|start
OG
id|end
)paren
op_logical_or
id|token-&gt;type
op_ne
id|OP_CLOSE_DUP_NUM
comma
l_int|0
)paren
)paren
(brace
multiline_comment|/* First number greater than second.  */
op_star
id|err
op_assign
id|REG_BADBR
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
r_else
(brace
id|start
op_assign
(paren
id|token-&gt;type
op_eq
id|OP_DUP_PLUS
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|end
op_assign
(paren
id|token-&gt;type
op_eq
id|OP_DUP_QUESTION
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|1
suffix:semicolon
)brace
id|fetch_token
(paren
id|token
comma
id|regexp
comma
id|syntax
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|elem
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|start
op_eq
l_int|0
op_logical_and
id|end
op_eq
l_int|0
comma
l_int|0
)paren
)paren
(brace
id|postorder
(paren
id|elem
comma
id|free_tree
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Extract &quot;&lt;re&gt;{n,m}&quot; to &quot;&lt;re&gt;&lt;re&gt;...&lt;re&gt;&lt;re&gt;{0,&lt;m-n&gt;}&quot;.  */
r_if
c_cond
(paren
id|BE
(paren
id|start
OG
l_int|0
comma
l_int|0
)paren
)paren
(brace
id|tree
op_assign
id|elem
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|2
suffix:semicolon
id|i
op_le
id|start
suffix:semicolon
op_increment
id|i
)paren
(brace
id|elem
op_assign
id|duplicate_tree
(paren
id|elem
comma
id|dfa
)paren
suffix:semicolon
id|tree
op_assign
id|create_tree
(paren
id|dfa
comma
id|tree
comma
id|elem
comma
id|CONCAT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|elem
op_eq
l_int|NULL
op_logical_or
id|tree
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_goto
id|parse_dup_op_espace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|start
op_eq
id|end
)paren
r_return
id|tree
suffix:semicolon
multiline_comment|/* Duplicate ELEM before it is marked optional.  */
id|elem
op_assign
id|duplicate_tree
(paren
id|elem
comma
id|dfa
)paren
suffix:semicolon
id|old_tree
op_assign
id|tree
suffix:semicolon
)brace
r_else
id|old_tree
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|elem-&gt;token.type
op_eq
id|SUBEXP
)paren
id|postorder
(paren
id|elem
comma
id|mark_opt_subexp
comma
(paren
r_void
op_star
)paren
(paren
r_int
)paren
id|elem-&gt;token.opr.idx
)paren
suffix:semicolon
id|tree
op_assign
id|create_tree
(paren
id|dfa
comma
id|elem
comma
l_int|NULL
comma
(paren
id|end
op_eq
l_int|1
ques
c_cond
id|OP_DUP_ASTERISK
suffix:colon
id|OP_ALT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|tree
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_goto
id|parse_dup_op_espace
suffix:semicolon
multiline_comment|/* This loop is actually executed only when end != -1,&n;     to rewrite &lt;re&gt;{0,n} as (&lt;re&gt;(&lt;re&gt;...&lt;re&gt;?)?)?...  We have&n;     already created the start+1-th copy.  */
r_for
c_loop
(paren
id|i
op_assign
id|start
op_plus
l_int|2
suffix:semicolon
id|i
op_le
id|end
suffix:semicolon
op_increment
id|i
)paren
(brace
id|elem
op_assign
id|duplicate_tree
(paren
id|elem
comma
id|dfa
)paren
suffix:semicolon
id|tree
op_assign
id|create_tree
(paren
id|dfa
comma
id|tree
comma
id|elem
comma
id|CONCAT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|elem
op_eq
l_int|NULL
op_logical_or
id|tree
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_goto
id|parse_dup_op_espace
suffix:semicolon
id|tree
op_assign
id|create_tree
(paren
id|dfa
comma
id|tree
comma
l_int|NULL
comma
id|OP_ALT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|tree
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_goto
id|parse_dup_op_espace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|old_tree
)paren
id|tree
op_assign
id|create_tree
(paren
id|dfa
comma
id|old_tree
comma
id|tree
comma
id|CONCAT
)paren
suffix:semicolon
r_return
id|tree
suffix:semicolon
id|parse_dup_op_espace
suffix:colon
op_star
id|err
op_assign
id|REG_ESPACE
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Size of the names for collating symbol/equivalence_class/character_class.&n;   I&squot;m not sure, but maybe enough.  */
DECL|macro|BRACKET_NAME_BUF_SIZE
mdefine_line|#define BRACKET_NAME_BUF_SIZE 32
macro_line|#ifndef _LIBC
multiline_comment|/* Local function for parse_bracket_exp only used in case of NOT _LIBC.&n;     Build the range expression which starts from START_ELEM, and ends&n;     at END_ELEM.  The result are written to MBCSET and SBCSET.&n;     RANGE_ALLOC is the allocated size of mbcset-&gt;range_starts, and&n;     mbcset-&gt;range_ends, is a pointer argument sinse we may&n;     update it.  */
r_static
id|reg_errcode_t
id|internal_function
macro_line|# ifdef RE_ENABLE_I18N
DECL|function|build_range_exp
id|build_range_exp
(paren
id|bitset_t
id|sbcset
comma
id|re_charset_t
op_star
id|mbcset
comma
r_int
op_star
id|range_alloc
comma
id|bracket_elem_t
op_star
id|start_elem
comma
id|bracket_elem_t
op_star
id|end_elem
)paren
macro_line|# else /* not RE_ENABLE_I18N */
id|build_range_exp
(paren
id|bitset_t
id|sbcset
comma
id|bracket_elem_t
op_star
id|start_elem
comma
id|bracket_elem_t
op_star
id|end_elem
)paren
macro_line|# endif /* not RE_ENABLE_I18N */
(brace
r_int
r_int
id|start_ch
comma
id|end_ch
suffix:semicolon
multiline_comment|/* Equivalence Classes and Character Classes can&squot;t be a range start/end.  */
r_if
c_cond
(paren
id|BE
(paren
id|start_elem-&gt;type
op_eq
id|EQUIV_CLASS
op_logical_or
id|start_elem-&gt;type
op_eq
id|CHAR_CLASS
op_logical_or
id|end_elem-&gt;type
op_eq
id|EQUIV_CLASS
op_logical_or
id|end_elem-&gt;type
op_eq
id|CHAR_CLASS
comma
l_int|0
)paren
)paren
r_return
id|REG_ERANGE
suffix:semicolon
multiline_comment|/* We can handle no multi character collating elements without libc&n;     support.  */
r_if
c_cond
(paren
id|BE
(paren
(paren
id|start_elem-&gt;type
op_eq
id|COLL_SYM
op_logical_and
id|strlen
(paren
(paren
r_char
op_star
)paren
id|start_elem-&gt;opr.name
)paren
OG
l_int|1
)paren
op_logical_or
(paren
id|end_elem-&gt;type
op_eq
id|COLL_SYM
op_logical_and
id|strlen
(paren
(paren
r_char
op_star
)paren
id|end_elem-&gt;opr.name
)paren
OG
l_int|1
)paren
comma
l_int|0
)paren
)paren
r_return
id|REG_ECOLLATE
suffix:semicolon
macro_line|# ifdef RE_ENABLE_I18N
(brace
m_wchar_t
id|wc
suffix:semicolon
id|wint_t
id|start_wc
suffix:semicolon
id|wint_t
id|end_wc
suffix:semicolon
m_wchar_t
id|cmp_buf
(braket
l_int|6
)braket
op_assign
(brace
id|L
l_char|&squot;&bslash;0&squot;
comma
id|L
l_char|&squot;&bslash;0&squot;
comma
id|L
l_char|&squot;&bslash;0&squot;
comma
id|L
l_char|&squot;&bslash;0&squot;
comma
id|L
l_char|&squot;&bslash;0&squot;
comma
id|L
l_char|&squot;&bslash;0&squot;
)brace
suffix:semicolon
id|start_ch
op_assign
(paren
(paren
id|start_elem-&gt;type
op_eq
id|SB_CHAR
)paren
ques
c_cond
id|start_elem-&gt;opr.ch
suffix:colon
(paren
(paren
id|start_elem-&gt;type
op_eq
id|COLL_SYM
)paren
ques
c_cond
id|start_elem-&gt;opr.name
(braket
l_int|0
)braket
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
id|end_ch
op_assign
(paren
(paren
id|end_elem-&gt;type
op_eq
id|SB_CHAR
)paren
ques
c_cond
id|end_elem-&gt;opr.ch
suffix:colon
(paren
(paren
id|end_elem-&gt;type
op_eq
id|COLL_SYM
)paren
ques
c_cond
id|end_elem-&gt;opr.name
(braket
l_int|0
)braket
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
macro_line|#ifdef GAWK
multiline_comment|/*&n;     * Fedora Core 2, maybe others, have broken `btowc&squot; that returns -1&n;     * for any value &gt; 127. Sigh. Note that `start_ch&squot; and `end_ch&squot; are&n;     * unsigned, so we don&squot;t have sign extension problems.&n;     */
id|start_wc
op_assign
(paren
(paren
id|start_elem-&gt;type
op_eq
id|SB_CHAR
op_logical_or
id|start_elem-&gt;type
op_eq
id|COLL_SYM
)paren
ques
c_cond
id|start_ch
suffix:colon
id|start_elem-&gt;opr.wch
)paren
suffix:semicolon
id|end_wc
op_assign
(paren
(paren
id|end_elem-&gt;type
op_eq
id|SB_CHAR
op_logical_or
id|end_elem-&gt;type
op_eq
id|COLL_SYM
)paren
ques
c_cond
id|end_ch
suffix:colon
id|end_elem-&gt;opr.wch
)paren
suffix:semicolon
macro_line|#else
id|start_wc
op_assign
(paren
(paren
id|start_elem-&gt;type
op_eq
id|SB_CHAR
op_logical_or
id|start_elem-&gt;type
op_eq
id|COLL_SYM
)paren
ques
c_cond
id|__btowc
(paren
id|start_ch
)paren
suffix:colon
id|start_elem-&gt;opr.wch
)paren
suffix:semicolon
id|end_wc
op_assign
(paren
(paren
id|end_elem-&gt;type
op_eq
id|SB_CHAR
op_logical_or
id|end_elem-&gt;type
op_eq
id|COLL_SYM
)paren
ques
c_cond
id|__btowc
(paren
id|end_ch
)paren
suffix:colon
id|end_elem-&gt;opr.wch
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|start_wc
op_eq
id|WEOF
op_logical_or
id|end_wc
op_eq
id|WEOF
)paren
r_return
id|REG_ECOLLATE
suffix:semicolon
id|cmp_buf
(braket
l_int|0
)braket
op_assign
id|start_wc
suffix:semicolon
id|cmp_buf
(braket
l_int|4
)braket
op_assign
id|end_wc
suffix:semicolon
r_if
c_cond
(paren
id|wcscoll
(paren
id|cmp_buf
comma
id|cmp_buf
op_plus
l_int|4
)paren
OG
l_int|0
)paren
r_return
id|REG_ERANGE
suffix:semicolon
multiline_comment|/* Got valid collation sequence values, add them as a new entry.&n;       However, for !_LIBC we have no collation elements: if the&n;       character set is single byte, the single byte character set&n;       that we build below suffices.  parse_bracket_exp passes&n;       no MBCSET if dfa-&gt;mb_cur_max == 1.  */
r_if
c_cond
(paren
id|mbcset
)paren
(brace
multiline_comment|/* Check the space of the arrays.  */
r_if
c_cond
(paren
id|BE
(paren
op_star
id|range_alloc
op_eq
id|mbcset-&gt;nranges
comma
l_int|0
)paren
)paren
(brace
multiline_comment|/* There is not enough space, need realloc.  */
m_wchar_t
op_star
id|new_array_start
comma
op_star
id|new_array_end
suffix:semicolon
r_int
id|new_nranges
suffix:semicolon
multiline_comment|/* +1 in case of mbcset-&gt;nranges is 0.  */
id|new_nranges
op_assign
l_int|2
op_star
id|mbcset-&gt;nranges
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Use realloc since mbcset-&gt;range_starts and mbcset-&gt;range_ends&n;&t;       are NULL if *range_alloc == 0.  */
id|new_array_start
op_assign
id|re_realloc
(paren
id|mbcset-&gt;range_starts
comma
m_wchar_t
comma
id|new_nranges
)paren
suffix:semicolon
id|new_array_end
op_assign
id|re_realloc
(paren
id|mbcset-&gt;range_ends
comma
m_wchar_t
comma
id|new_nranges
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|new_array_start
op_eq
l_int|NULL
op_logical_or
id|new_array_end
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
id|mbcset-&gt;range_starts
op_assign
id|new_array_start
suffix:semicolon
id|mbcset-&gt;range_ends
op_assign
id|new_array_end
suffix:semicolon
op_star
id|range_alloc
op_assign
id|new_nranges
suffix:semicolon
)brace
id|mbcset-&gt;range_starts
(braket
id|mbcset-&gt;nranges
)braket
op_assign
id|start_wc
suffix:semicolon
id|mbcset-&gt;range_ends
(braket
id|mbcset-&gt;nranges
op_increment
)braket
op_assign
id|end_wc
suffix:semicolon
)brace
multiline_comment|/* Build the table for single byte characters.  */
r_for
c_loop
(paren
id|wc
op_assign
l_int|0
suffix:semicolon
id|wc
OL
id|SBC_MAX
suffix:semicolon
op_increment
id|wc
)paren
(brace
id|cmp_buf
(braket
l_int|2
)braket
op_assign
id|wc
suffix:semicolon
r_if
c_cond
(paren
id|wcscoll
(paren
id|cmp_buf
comma
id|cmp_buf
op_plus
l_int|2
)paren
op_le
l_int|0
op_logical_and
id|wcscoll
(paren
id|cmp_buf
op_plus
l_int|2
comma
id|cmp_buf
op_plus
l_int|4
)paren
op_le
l_int|0
)paren
id|bitset_set
(paren
id|sbcset
comma
id|wc
)paren
suffix:semicolon
)brace
)brace
macro_line|# else /* not RE_ENABLE_I18N */
(brace
r_int
r_int
id|ch
suffix:semicolon
id|start_ch
op_assign
(paren
(paren
id|start_elem-&gt;type
op_eq
id|SB_CHAR
)paren
ques
c_cond
id|start_elem-&gt;opr.ch
suffix:colon
(paren
(paren
id|start_elem-&gt;type
op_eq
id|COLL_SYM
)paren
ques
c_cond
id|start_elem-&gt;opr.name
(braket
l_int|0
)braket
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
id|end_ch
op_assign
(paren
(paren
id|end_elem-&gt;type
op_eq
id|SB_CHAR
)paren
ques
c_cond
id|end_elem-&gt;opr.ch
suffix:colon
(paren
(paren
id|end_elem-&gt;type
op_eq
id|COLL_SYM
)paren
ques
c_cond
id|end_elem-&gt;opr.name
(braket
l_int|0
)braket
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|start_ch
OG
id|end_ch
)paren
r_return
id|REG_ERANGE
suffix:semicolon
multiline_comment|/* Build the table for single byte characters.  */
r_for
c_loop
(paren
id|ch
op_assign
l_int|0
suffix:semicolon
id|ch
OL
id|SBC_MAX
suffix:semicolon
op_increment
id|ch
)paren
r_if
c_cond
(paren
id|start_ch
op_le
id|ch
op_logical_and
id|ch
op_le
id|end_ch
)paren
id|bitset_set
(paren
id|sbcset
comma
id|ch
)paren
suffix:semicolon
)brace
macro_line|# endif /* not RE_ENABLE_I18N */
r_return
id|REG_NOERROR
suffix:semicolon
)brace
macro_line|#endif /* not _LIBC */
macro_line|#ifndef _LIBC
multiline_comment|/* Helper function for parse_bracket_exp only used in case of NOT _LIBC..&n;   Build the collating element which is represented by NAME.&n;   The result are written to MBCSET and SBCSET.&n;   COLL_SYM_ALLOC is the allocated size of mbcset-&gt;coll_sym, is a&n;   pointer argument since we may update it.  */
r_static
id|reg_errcode_t
id|internal_function
macro_line|# ifdef RE_ENABLE_I18N
DECL|function|build_collating_symbol
id|build_collating_symbol
(paren
id|bitset_t
id|sbcset
comma
id|re_charset_t
op_star
id|mbcset
comma
r_int
op_star
id|coll_sym_alloc
comma
r_const
r_int
r_char
op_star
id|name
)paren
macro_line|# else /* not RE_ENABLE_I18N */
id|build_collating_symbol
(paren
id|bitset_t
id|sbcset
comma
r_const
r_int
r_char
op_star
id|name
)paren
macro_line|# endif /* not RE_ENABLE_I18N */
(brace
r_int
id|name_len
op_assign
id|strlen
(paren
(paren
r_const
r_char
op_star
)paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|name_len
op_ne
l_int|1
comma
l_int|0
)paren
)paren
r_return
id|REG_ECOLLATE
suffix:semicolon
r_else
(brace
id|bitset_set
(paren
id|sbcset
comma
id|name
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_return
id|REG_NOERROR
suffix:semicolon
)brace
)brace
macro_line|#endif /* not _LIBC */
multiline_comment|/* This function parse bracket expression like &quot;[abc]&quot;, &quot;[a-c]&quot;,&n;   &quot;[[.a-a.]]&quot; etc.  */
r_static
id|bin_tree_t
op_star
DECL|function|parse_bracket_exp
id|parse_bracket_exp
(paren
id|re_string_t
op_star
id|regexp
comma
id|re_dfa_t
op_star
id|dfa
comma
id|re_token_t
op_star
id|token
comma
id|reg_syntax_t
id|syntax
comma
id|reg_errcode_t
op_star
id|err
)paren
(brace
macro_line|#ifdef _LIBC
r_const
r_int
r_char
op_star
id|collseqmb
suffix:semicolon
r_const
r_char
op_star
id|collseqwc
suffix:semicolon
r_uint32
id|nrules
suffix:semicolon
r_int32
id|table_size
suffix:semicolon
r_const
r_int32
op_star
id|symb_table
suffix:semicolon
r_const
r_int
r_char
op_star
id|extra
suffix:semicolon
multiline_comment|/* Local function for parse_bracket_exp used in _LIBC environement.&n;     Seek the collating symbol entry correspondings to NAME.&n;     Return the index of the symbol in the SYMB_TABLE.  */
r_auto
r_inline
r_int32
id|__attribute
(paren
(paren
id|always_inline
)paren
)paren
id|seek_collating_symbol_entry
(paren
id|name
comma
id|name_len
)paren
r_const
r_int
r_char
op_star
id|name
suffix:semicolon
r_int
id|name_len
suffix:semicolon
(brace
r_int32
id|hash
op_assign
id|elem_hash
(paren
(paren
r_const
r_char
op_star
)paren
id|name
comma
id|name_len
)paren
suffix:semicolon
r_int32
id|elem
op_assign
id|hash
op_mod
id|table_size
suffix:semicolon
r_if
c_cond
(paren
id|symb_table
(braket
l_int|2
op_star
id|elem
)braket
op_ne
l_int|0
)paren
(brace
r_int32
id|second
op_assign
id|hash
op_mod
(paren
id|table_size
l_int|2
)paren
op_plus
l_int|1
suffix:semicolon
r_do
(brace
multiline_comment|/* First compare the hashing value.  */
r_if
c_cond
(paren
id|symb_table
(braket
l_int|2
op_star
id|elem
)braket
op_eq
id|hash
multiline_comment|/* Compare the length of the name.  */
op_logical_and
id|name_len
op_eq
id|extra
(braket
id|symb_table
(braket
l_int|2
op_star
id|elem
op_plus
l_int|1
)braket
)braket
multiline_comment|/* Compare the name.  */
op_logical_and
id|memcmp
(paren
id|name
comma
op_amp
id|extra
(braket
id|symb_table
(braket
l_int|2
op_star
id|elem
op_plus
l_int|1
)braket
op_plus
l_int|1
)braket
comma
id|name_len
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Yep, this is the entry.  */
r_break
suffix:semicolon
)brace
multiline_comment|/* Next entry.  */
id|elem
op_add_assign
id|second
suffix:semicolon
)brace
r_while
c_loop
(paren
id|symb_table
(braket
l_int|2
op_star
id|elem
)braket
op_ne
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|elem
suffix:semicolon
)brace
multiline_comment|/* Local function for parse_bracket_exp used in _LIBC environment.&n;     Look up the collation sequence value of BR_ELEM.&n;     Return the value if succeeded, UINT_MAX otherwise.  */
r_auto
r_inline
r_int
r_int
id|__attribute
(paren
(paren
id|always_inline
)paren
)paren
id|lookup_collation_sequence_value
(paren
id|br_elem
)paren
id|bracket_elem_t
op_star
id|br_elem
suffix:semicolon
(brace
r_if
c_cond
(paren
id|br_elem-&gt;type
op_eq
id|SB_CHAR
)paren
(brace
multiline_comment|/*&n;&t;  if (MB_CUR_MAX == 1)&n;&t;  */
r_if
c_cond
(paren
id|nrules
op_eq
l_int|0
)paren
r_return
id|collseqmb
(braket
id|br_elem-&gt;opr.ch
)braket
suffix:semicolon
r_else
(brace
id|wint_t
id|wc
op_assign
id|__btowc
(paren
id|br_elem-&gt;opr.ch
)paren
suffix:semicolon
r_return
id|__collseq_table_lookup
(paren
id|collseqwc
comma
id|wc
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|br_elem-&gt;type
op_eq
id|MB_CHAR
)paren
(brace
r_if
c_cond
(paren
id|nrules
op_ne
l_int|0
)paren
r_return
id|__collseq_table_lookup
(paren
id|collseqwc
comma
id|br_elem-&gt;opr.wch
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|br_elem-&gt;type
op_eq
id|COLL_SYM
)paren
(brace
r_int
id|sym_name_len
op_assign
id|strlen
(paren
(paren
r_char
op_star
)paren
id|br_elem-&gt;opr.name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nrules
op_ne
l_int|0
)paren
(brace
r_int32
id|elem
comma
id|idx
suffix:semicolon
id|elem
op_assign
id|seek_collating_symbol_entry
(paren
id|br_elem-&gt;opr.name
comma
id|sym_name_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|symb_table
(braket
l_int|2
op_star
id|elem
)braket
op_ne
l_int|0
)paren
(brace
multiline_comment|/* We found the entry.  */
id|idx
op_assign
id|symb_table
(braket
l_int|2
op_star
id|elem
op_plus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* Skip the name of collating element name.  */
id|idx
op_add_assign
l_int|1
op_plus
id|extra
(braket
id|idx
)braket
suffix:semicolon
multiline_comment|/* Skip the byte sequence of the collating element.  */
id|idx
op_add_assign
l_int|1
op_plus
id|extra
(braket
id|idx
)braket
suffix:semicolon
multiline_comment|/* Adjust for the alignment.  */
id|idx
op_assign
(paren
id|idx
op_plus
l_int|3
)paren
op_amp
op_complement
l_int|3
suffix:semicolon
multiline_comment|/* Skip the multibyte collation sequence value.  */
id|idx
op_add_assign
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/* Skip the wide char sequence of the collating element.  */
id|idx
op_add_assign
r_sizeof
(paren
r_int
r_int
)paren
op_star
(paren
l_int|1
op_plus
op_star
(paren
r_int
r_int
op_star
)paren
(paren
id|extra
op_plus
id|idx
)paren
)paren
suffix:semicolon
multiline_comment|/* Return the collation sequence value.  */
r_return
op_star
(paren
r_int
r_int
op_star
)paren
(paren
id|extra
op_plus
id|idx
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|symb_table
(braket
l_int|2
op_star
id|elem
)braket
op_eq
l_int|0
op_logical_and
id|sym_name_len
op_eq
l_int|1
)paren
(brace
multiline_comment|/* No valid character.  Match it as a single byte&n;&t;&t;     character.  */
r_return
id|collseqmb
(braket
id|br_elem-&gt;opr.name
(braket
l_int|0
)braket
)braket
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|sym_name_len
op_eq
l_int|1
)paren
r_return
id|collseqmb
(braket
id|br_elem-&gt;opr.name
(braket
l_int|0
)braket
)braket
suffix:semicolon
)brace
r_return
id|UINT_MAX
suffix:semicolon
)brace
multiline_comment|/* Local function for parse_bracket_exp used in _LIBC environement.&n;     Build the range expression which starts from START_ELEM, and ends&n;     at END_ELEM.  The result are written to MBCSET and SBCSET.&n;     RANGE_ALLOC is the allocated size of mbcset-&gt;range_starts, and&n;     mbcset-&gt;range_ends, is a pointer argument sinse we may&n;     update it.  */
r_auto
r_inline
id|reg_errcode_t
id|__attribute
(paren
(paren
id|always_inline
)paren
)paren
id|build_range_exp
(paren
id|sbcset
comma
id|mbcset
comma
id|range_alloc
comma
id|start_elem
comma
id|end_elem
)paren
id|re_charset_t
op_star
id|mbcset
suffix:semicolon
r_int
op_star
id|range_alloc
suffix:semicolon
id|bitset_t
id|sbcset
suffix:semicolon
id|bracket_elem_t
op_star
id|start_elem
comma
op_star
id|end_elem
suffix:semicolon
(brace
r_int
r_int
id|ch
suffix:semicolon
r_uint32
id|start_collseq
suffix:semicolon
r_uint32
id|end_collseq
suffix:semicolon
multiline_comment|/* Equivalence Classes and Character Classes can&squot;t be a range&n;&t; start/end.  */
r_if
c_cond
(paren
id|BE
(paren
id|start_elem-&gt;type
op_eq
id|EQUIV_CLASS
op_logical_or
id|start_elem-&gt;type
op_eq
id|CHAR_CLASS
op_logical_or
id|end_elem-&gt;type
op_eq
id|EQUIV_CLASS
op_logical_or
id|end_elem-&gt;type
op_eq
id|CHAR_CLASS
comma
l_int|0
)paren
)paren
r_return
id|REG_ERANGE
suffix:semicolon
id|start_collseq
op_assign
id|lookup_collation_sequence_value
(paren
id|start_elem
)paren
suffix:semicolon
id|end_collseq
op_assign
id|lookup_collation_sequence_value
(paren
id|end_elem
)paren
suffix:semicolon
multiline_comment|/* Check start/end collation sequence values.  */
r_if
c_cond
(paren
id|BE
(paren
id|start_collseq
op_eq
id|UINT_MAX
op_logical_or
id|end_collseq
op_eq
id|UINT_MAX
comma
l_int|0
)paren
)paren
r_return
id|REG_ECOLLATE
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
(paren
id|syntax
op_amp
id|RE_NO_EMPTY_RANGES
)paren
op_logical_and
id|start_collseq
OG
id|end_collseq
comma
l_int|0
)paren
)paren
r_return
id|REG_ERANGE
suffix:semicolon
multiline_comment|/* Got valid collation sequence values, add them as a new entry.&n;&t; However, if we have no collation elements, and the character set&n;&t; is single byte, the single byte character set that we&n;&t; build below suffices. */
r_if
c_cond
(paren
id|nrules
OG
l_int|0
op_logical_or
id|dfa-&gt;mb_cur_max
OG
l_int|1
)paren
(brace
multiline_comment|/* Check the space of the arrays.  */
r_if
c_cond
(paren
id|BE
(paren
op_star
id|range_alloc
op_eq
id|mbcset-&gt;nranges
comma
l_int|0
)paren
)paren
(brace
multiline_comment|/* There is not enough space, need realloc.  */
r_uint32
op_star
id|new_array_start
suffix:semicolon
r_uint32
op_star
id|new_array_end
suffix:semicolon
r_int
id|new_nranges
suffix:semicolon
multiline_comment|/* +1 in case of mbcset-&gt;nranges is 0.  */
id|new_nranges
op_assign
l_int|2
op_star
id|mbcset-&gt;nranges
op_plus
l_int|1
suffix:semicolon
id|new_array_start
op_assign
id|re_realloc
(paren
id|mbcset-&gt;range_starts
comma
r_uint32
comma
id|new_nranges
)paren
suffix:semicolon
id|new_array_end
op_assign
id|re_realloc
(paren
id|mbcset-&gt;range_ends
comma
r_uint32
comma
id|new_nranges
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|new_array_start
op_eq
l_int|NULL
op_logical_or
id|new_array_end
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
id|mbcset-&gt;range_starts
op_assign
id|new_array_start
suffix:semicolon
id|mbcset-&gt;range_ends
op_assign
id|new_array_end
suffix:semicolon
op_star
id|range_alloc
op_assign
id|new_nranges
suffix:semicolon
)brace
id|mbcset-&gt;range_starts
(braket
id|mbcset-&gt;nranges
)braket
op_assign
id|start_collseq
suffix:semicolon
id|mbcset-&gt;range_ends
(braket
id|mbcset-&gt;nranges
op_increment
)braket
op_assign
id|end_collseq
suffix:semicolon
)brace
multiline_comment|/* Build the table for single byte characters.  */
r_for
c_loop
(paren
id|ch
op_assign
l_int|0
suffix:semicolon
id|ch
OL
id|SBC_MAX
suffix:semicolon
id|ch
op_increment
)paren
(brace
r_uint32
id|ch_collseq
suffix:semicolon
multiline_comment|/*&n;&t;  if (MB_CUR_MAX == 1)&n;&t;  */
r_if
c_cond
(paren
id|nrules
op_eq
l_int|0
)paren
id|ch_collseq
op_assign
id|collseqmb
(braket
id|ch
)braket
suffix:semicolon
r_else
id|ch_collseq
op_assign
id|__collseq_table_lookup
(paren
id|collseqwc
comma
id|__btowc
(paren
id|ch
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|start_collseq
op_le
id|ch_collseq
op_logical_and
id|ch_collseq
op_le
id|end_collseq
)paren
id|bitset_set
(paren
id|sbcset
comma
id|ch
)paren
suffix:semicolon
)brace
r_return
id|REG_NOERROR
suffix:semicolon
)brace
multiline_comment|/* Local function for parse_bracket_exp used in _LIBC environement.&n;     Build the collating element which is represented by NAME.&n;     The result are written to MBCSET and SBCSET.&n;     COLL_SYM_ALLOC is the allocated size of mbcset-&gt;coll_sym, is a&n;     pointer argument sinse we may update it.  */
r_auto
r_inline
id|reg_errcode_t
id|__attribute
(paren
(paren
id|always_inline
)paren
)paren
id|build_collating_symbol
(paren
id|sbcset
comma
id|mbcset
comma
id|coll_sym_alloc
comma
id|name
)paren
id|re_charset_t
op_star
id|mbcset
suffix:semicolon
r_int
op_star
id|coll_sym_alloc
suffix:semicolon
id|bitset_t
id|sbcset
suffix:semicolon
r_const
r_int
r_char
op_star
id|name
suffix:semicolon
(brace
r_int32
id|elem
comma
id|idx
suffix:semicolon
r_int
id|name_len
op_assign
id|strlen
(paren
(paren
r_const
r_char
op_star
)paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nrules
op_ne
l_int|0
)paren
(brace
id|elem
op_assign
id|seek_collating_symbol_entry
(paren
id|name
comma
id|name_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|symb_table
(braket
l_int|2
op_star
id|elem
)braket
op_ne
l_int|0
)paren
(brace
multiline_comment|/* We found the entry.  */
id|idx
op_assign
id|symb_table
(braket
l_int|2
op_star
id|elem
op_plus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* Skip the name of collating element name.  */
id|idx
op_add_assign
l_int|1
op_plus
id|extra
(braket
id|idx
)braket
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|symb_table
(braket
l_int|2
op_star
id|elem
)braket
op_eq
l_int|0
op_logical_and
id|name_len
op_eq
l_int|1
)paren
(brace
multiline_comment|/* No valid character, treat it as a normal&n;&t;&t; character.  */
id|bitset_set
(paren
id|sbcset
comma
id|name
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_return
id|REG_NOERROR
suffix:semicolon
)brace
r_else
r_return
id|REG_ECOLLATE
suffix:semicolon
multiline_comment|/* Got valid collation sequence, add it as a new entry.  */
multiline_comment|/* Check the space of the arrays.  */
r_if
c_cond
(paren
id|BE
(paren
op_star
id|coll_sym_alloc
op_eq
id|mbcset-&gt;ncoll_syms
comma
l_int|0
)paren
)paren
(brace
multiline_comment|/* Not enough, realloc it.  */
multiline_comment|/* +1 in case of mbcset-&gt;ncoll_syms is 0.  */
r_int
id|new_coll_sym_alloc
op_assign
l_int|2
op_star
id|mbcset-&gt;ncoll_syms
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Use realloc since mbcset-&gt;coll_syms is NULL&n;&t;&t; if *alloc == 0.  */
r_int32
op_star
id|new_coll_syms
op_assign
id|re_realloc
(paren
id|mbcset-&gt;coll_syms
comma
r_int32
comma
id|new_coll_sym_alloc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|new_coll_syms
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
id|mbcset-&gt;coll_syms
op_assign
id|new_coll_syms
suffix:semicolon
op_star
id|coll_sym_alloc
op_assign
id|new_coll_sym_alloc
suffix:semicolon
)brace
id|mbcset-&gt;coll_syms
(braket
id|mbcset-&gt;ncoll_syms
op_increment
)braket
op_assign
id|idx
suffix:semicolon
r_return
id|REG_NOERROR
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|BE
(paren
id|name_len
op_ne
l_int|1
comma
l_int|0
)paren
)paren
r_return
id|REG_ECOLLATE
suffix:semicolon
r_else
(brace
id|bitset_set
(paren
id|sbcset
comma
id|name
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_return
id|REG_NOERROR
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
id|re_token_t
id|br_token
suffix:semicolon
id|re_bitset_ptr_t
id|sbcset
suffix:semicolon
macro_line|#ifdef RE_ENABLE_I18N
id|re_charset_t
op_star
id|mbcset
suffix:semicolon
r_int
id|coll_sym_alloc
op_assign
l_int|0
comma
id|range_alloc
op_assign
l_int|0
comma
id|mbchar_alloc
op_assign
l_int|0
suffix:semicolon
r_int
id|equiv_class_alloc
op_assign
l_int|0
comma
id|char_class_alloc
op_assign
l_int|0
suffix:semicolon
macro_line|#endif /* not RE_ENABLE_I18N */
r_int
id|non_match
op_assign
l_int|0
suffix:semicolon
id|bin_tree_t
op_star
id|work_tree
suffix:semicolon
r_int
id|token_len
suffix:semicolon
r_int
id|first_round
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef _LIBC
id|collseqmb
op_assign
(paren
r_const
r_int
r_char
op_star
)paren
id|_NL_CURRENT
(paren
id|LC_COLLATE
comma
id|_NL_COLLATE_COLLSEQMB
)paren
suffix:semicolon
id|nrules
op_assign
id|_NL_CURRENT_WORD
(paren
id|LC_COLLATE
comma
id|_NL_COLLATE_NRULES
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nrules
)paren
(brace
multiline_comment|/*&n;      if (MB_CUR_MAX &gt; 1)&n;      */
id|collseqwc
op_assign
id|_NL_CURRENT
(paren
id|LC_COLLATE
comma
id|_NL_COLLATE_COLLSEQWC
)paren
suffix:semicolon
id|table_size
op_assign
id|_NL_CURRENT_WORD
(paren
id|LC_COLLATE
comma
id|_NL_COLLATE_SYMB_HASH_SIZEMB
)paren
suffix:semicolon
id|symb_table
op_assign
(paren
r_const
r_int32
op_star
)paren
id|_NL_CURRENT
(paren
id|LC_COLLATE
comma
id|_NL_COLLATE_SYMB_TABLEMB
)paren
suffix:semicolon
id|extra
op_assign
(paren
r_const
r_int
r_char
op_star
)paren
id|_NL_CURRENT
(paren
id|LC_COLLATE
comma
id|_NL_COLLATE_SYMB_EXTRAMB
)paren
suffix:semicolon
)brace
macro_line|#endif
id|sbcset
op_assign
(paren
id|re_bitset_ptr_t
)paren
id|calloc
(paren
r_sizeof
(paren
id|bitset_t
)paren
comma
l_int|1
)paren
suffix:semicolon
macro_line|#ifdef RE_ENABLE_I18N
id|mbcset
op_assign
(paren
id|re_charset_t
op_star
)paren
id|calloc
(paren
r_sizeof
(paren
id|re_charset_t
)paren
comma
l_int|1
)paren
suffix:semicolon
macro_line|#endif /* RE_ENABLE_I18N */
macro_line|#ifdef RE_ENABLE_I18N
r_if
c_cond
(paren
id|BE
(paren
id|sbcset
op_eq
l_int|NULL
op_logical_or
id|mbcset
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
macro_line|#else
r_if
c_cond
(paren
id|BE
(paren
id|sbcset
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
macro_line|#endif /* RE_ENABLE_I18N */
(brace
op_star
id|err
op_assign
id|REG_ESPACE
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|token_len
op_assign
id|peek_token_bracket
(paren
id|token
comma
id|regexp
comma
id|syntax
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|token-&gt;type
op_eq
id|END_OF_RE
comma
l_int|0
)paren
)paren
(brace
op_star
id|err
op_assign
id|REG_BADPAT
suffix:semicolon
r_goto
id|parse_bracket_exp_free_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|token-&gt;type
op_eq
id|OP_NON_MATCH_LIST
)paren
(brace
macro_line|#ifdef RE_ENABLE_I18N
id|mbcset-&gt;non_match
op_assign
l_int|1
suffix:semicolon
macro_line|#endif /* not RE_ENABLE_I18N */
id|non_match
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|syntax
op_amp
id|RE_HAT_LISTS_NOT_NEWLINE
)paren
id|bitset_set
(paren
id|sbcset
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|re_string_skip_bytes
(paren
id|regexp
comma
id|token_len
)paren
suffix:semicolon
multiline_comment|/* Skip a token.  */
id|token_len
op_assign
id|peek_token_bracket
(paren
id|token
comma
id|regexp
comma
id|syntax
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|token-&gt;type
op_eq
id|END_OF_RE
comma
l_int|0
)paren
)paren
(brace
op_star
id|err
op_assign
id|REG_BADPAT
suffix:semicolon
r_goto
id|parse_bracket_exp_free_return
suffix:semicolon
)brace
)brace
multiline_comment|/* We treat the first &squot;]&squot; as a normal character.  */
r_if
c_cond
(paren
id|token-&gt;type
op_eq
id|OP_CLOSE_BRACKET
)paren
id|token-&gt;type
op_assign
id|CHARACTER
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|bracket_elem_t
id|start_elem
comma
id|end_elem
suffix:semicolon
r_int
r_char
id|start_name_buf
(braket
id|BRACKET_NAME_BUF_SIZE
)braket
suffix:semicolon
r_int
r_char
id|end_name_buf
(braket
id|BRACKET_NAME_BUF_SIZE
)braket
suffix:semicolon
id|reg_errcode_t
id|ret
suffix:semicolon
r_int
id|token_len2
op_assign
l_int|0
comma
id|is_range_exp
op_assign
l_int|0
suffix:semicolon
id|re_token_t
id|token2
suffix:semicolon
id|start_elem.opr.name
op_assign
id|start_name_buf
suffix:semicolon
id|ret
op_assign
id|parse_bracket_element
(paren
op_amp
id|start_elem
comma
id|regexp
comma
id|token
comma
id|token_len
comma
id|dfa
comma
id|syntax
comma
id|first_round
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|ret
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
(brace
op_star
id|err
op_assign
id|ret
suffix:semicolon
r_goto
id|parse_bracket_exp_free_return
suffix:semicolon
)brace
id|first_round
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Get information about the next token.  We need it in any case.  */
id|token_len
op_assign
id|peek_token_bracket
(paren
id|token
comma
id|regexp
comma
id|syntax
)paren
suffix:semicolon
multiline_comment|/* Do not check for ranges if we know they are not allowed.  */
r_if
c_cond
(paren
id|start_elem.type
op_ne
id|CHAR_CLASS
op_logical_and
id|start_elem.type
op_ne
id|EQUIV_CLASS
)paren
(brace
r_if
c_cond
(paren
id|BE
(paren
id|token-&gt;type
op_eq
id|END_OF_RE
comma
l_int|0
)paren
)paren
(brace
op_star
id|err
op_assign
id|REG_EBRACK
suffix:semicolon
r_goto
id|parse_bracket_exp_free_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|token-&gt;type
op_eq
id|OP_CHARSET_RANGE
)paren
(brace
id|re_string_skip_bytes
(paren
id|regexp
comma
id|token_len
)paren
suffix:semicolon
multiline_comment|/* Skip &squot;-&squot;.  */
id|token_len2
op_assign
id|peek_token_bracket
(paren
op_amp
id|token2
comma
id|regexp
comma
id|syntax
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|token2.type
op_eq
id|END_OF_RE
comma
l_int|0
)paren
)paren
(brace
op_star
id|err
op_assign
id|REG_EBRACK
suffix:semicolon
r_goto
id|parse_bracket_exp_free_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|token2.type
op_eq
id|OP_CLOSE_BRACKET
)paren
(brace
multiline_comment|/* We treat the last &squot;-&squot; as a normal character.  */
id|re_string_skip_bytes
(paren
id|regexp
comma
id|token_len
)paren
suffix:semicolon
id|token-&gt;type
op_assign
id|CHARACTER
suffix:semicolon
)brace
r_else
id|is_range_exp
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|is_range_exp
op_eq
l_int|1
)paren
(brace
id|end_elem.opr.name
op_assign
id|end_name_buf
suffix:semicolon
id|ret
op_assign
id|parse_bracket_element
(paren
op_amp
id|end_elem
comma
id|regexp
comma
op_amp
id|token2
comma
id|token_len2
comma
id|dfa
comma
id|syntax
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|ret
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
(brace
op_star
id|err
op_assign
id|ret
suffix:semicolon
r_goto
id|parse_bracket_exp_free_return
suffix:semicolon
)brace
id|token_len
op_assign
id|peek_token_bracket
(paren
id|token
comma
id|regexp
comma
id|syntax
)paren
suffix:semicolon
macro_line|#ifdef _LIBC
op_star
id|err
op_assign
id|build_range_exp
(paren
id|sbcset
comma
id|mbcset
comma
op_amp
id|range_alloc
comma
op_amp
id|start_elem
comma
op_amp
id|end_elem
)paren
suffix:semicolon
macro_line|#else
macro_line|# ifdef RE_ENABLE_I18N
op_star
id|err
op_assign
id|build_range_exp
(paren
id|sbcset
comma
id|dfa-&gt;mb_cur_max
OG
l_int|1
ques
c_cond
id|mbcset
suffix:colon
l_int|NULL
comma
op_amp
id|range_alloc
comma
op_amp
id|start_elem
comma
op_amp
id|end_elem
)paren
suffix:semicolon
macro_line|# else
op_star
id|err
op_assign
id|build_range_exp
(paren
id|sbcset
comma
op_amp
id|start_elem
comma
op_amp
id|end_elem
)paren
suffix:semicolon
macro_line|# endif
macro_line|#endif /* RE_ENABLE_I18N */
r_if
c_cond
(paren
id|BE
(paren
op_star
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_goto
id|parse_bracket_exp_free_return
suffix:semicolon
)brace
r_else
(brace
r_switch
c_cond
(paren
id|start_elem.type
)paren
(brace
r_case
id|SB_CHAR
suffix:colon
id|bitset_set
(paren
id|sbcset
comma
id|start_elem.opr.ch
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef RE_ENABLE_I18N
r_case
id|MB_CHAR
suffix:colon
multiline_comment|/* Check whether the array has enough space.  */
r_if
c_cond
(paren
id|BE
(paren
id|mbchar_alloc
op_eq
id|mbcset-&gt;nmbchars
comma
l_int|0
)paren
)paren
(brace
m_wchar_t
op_star
id|new_mbchars
suffix:semicolon
multiline_comment|/* Not enough, realloc it.  */
multiline_comment|/* +1 in case of mbcset-&gt;nmbchars is 0.  */
id|mbchar_alloc
op_assign
l_int|2
op_star
id|mbcset-&gt;nmbchars
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Use realloc since array is NULL if *alloc == 0.  */
id|new_mbchars
op_assign
id|re_realloc
(paren
id|mbcset-&gt;mbchars
comma
m_wchar_t
comma
id|mbchar_alloc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|new_mbchars
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_goto
id|parse_bracket_exp_espace
suffix:semicolon
id|mbcset-&gt;mbchars
op_assign
id|new_mbchars
suffix:semicolon
)brace
id|mbcset-&gt;mbchars
(braket
id|mbcset-&gt;nmbchars
op_increment
)braket
op_assign
id|start_elem.opr.wch
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif /* RE_ENABLE_I18N */
r_case
id|EQUIV_CLASS
suffix:colon
op_star
id|err
op_assign
id|build_equiv_class
(paren
id|sbcset
comma
macro_line|#ifdef RE_ENABLE_I18N
id|mbcset
comma
op_amp
id|equiv_class_alloc
comma
macro_line|#endif /* RE_ENABLE_I18N */
id|start_elem.opr.name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
op_star
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_goto
id|parse_bracket_exp_free_return
suffix:semicolon
r_break
suffix:semicolon
r_case
id|COLL_SYM
suffix:colon
op_star
id|err
op_assign
id|build_collating_symbol
(paren
id|sbcset
comma
macro_line|#ifdef RE_ENABLE_I18N
id|mbcset
comma
op_amp
id|coll_sym_alloc
comma
macro_line|#endif /* RE_ENABLE_I18N */
id|start_elem.opr.name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
op_star
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_goto
id|parse_bracket_exp_free_return
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CHAR_CLASS
suffix:colon
op_star
id|err
op_assign
id|build_charclass
(paren
id|regexp-&gt;trans
comma
id|sbcset
comma
macro_line|#ifdef RE_ENABLE_I18N
id|mbcset
comma
op_amp
id|char_class_alloc
comma
macro_line|#endif /* RE_ENABLE_I18N */
(paren
r_const
r_char
op_star
)paren
id|start_elem.opr.name
comma
id|syntax
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
op_star
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_goto
id|parse_bracket_exp_free_return
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
m_assert
(paren
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|BE
(paren
id|token-&gt;type
op_eq
id|END_OF_RE
comma
l_int|0
)paren
)paren
(brace
op_star
id|err
op_assign
id|REG_EBRACK
suffix:semicolon
r_goto
id|parse_bracket_exp_free_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|token-&gt;type
op_eq
id|OP_CLOSE_BRACKET
)paren
r_break
suffix:semicolon
)brace
id|re_string_skip_bytes
(paren
id|regexp
comma
id|token_len
)paren
suffix:semicolon
multiline_comment|/* Skip a token.  */
multiline_comment|/* If it is non-matching list.  */
r_if
c_cond
(paren
id|non_match
)paren
id|bitset_not
(paren
id|sbcset
)paren
suffix:semicolon
macro_line|#ifdef RE_ENABLE_I18N
multiline_comment|/* Ensure only single byte characters are set.  */
r_if
c_cond
(paren
id|dfa-&gt;mb_cur_max
OG
l_int|1
)paren
id|bitset_mask
(paren
id|sbcset
comma
id|dfa-&gt;sb_char
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mbcset-&gt;nmbchars
op_logical_or
id|mbcset-&gt;ncoll_syms
op_logical_or
id|mbcset-&gt;nequiv_classes
op_logical_or
id|mbcset-&gt;nranges
op_logical_or
(paren
id|dfa-&gt;mb_cur_max
OG
l_int|1
op_logical_and
(paren
id|mbcset-&gt;nchar_classes
op_logical_or
id|mbcset-&gt;non_match
)paren
)paren
)paren
(brace
id|bin_tree_t
op_star
id|mbc_tree
suffix:semicolon
r_int
id|sbc_idx
suffix:semicolon
multiline_comment|/* Build a tree for complex bracket.  */
id|dfa-&gt;has_mb_node
op_assign
l_int|1
suffix:semicolon
id|br_token.type
op_assign
id|COMPLEX_BRACKET
suffix:semicolon
id|br_token.opr.mbcset
op_assign
id|mbcset
suffix:semicolon
id|mbc_tree
op_assign
id|create_token_tree
(paren
id|dfa
comma
l_int|NULL
comma
l_int|NULL
comma
op_amp
id|br_token
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|mbc_tree
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_goto
id|parse_bracket_exp_espace
suffix:semicolon
r_for
c_loop
(paren
id|sbc_idx
op_assign
l_int|0
suffix:semicolon
id|sbc_idx
OL
id|BITSET_WORDS
suffix:semicolon
op_increment
id|sbc_idx
)paren
r_if
c_cond
(paren
id|sbcset
(braket
id|sbc_idx
)braket
)paren
r_break
suffix:semicolon
multiline_comment|/* If there are no bits set in sbcset, there is no point&n;&t; of having both SIMPLE_BRACKET and COMPLEX_BRACKET.  */
r_if
c_cond
(paren
id|sbc_idx
OL
id|BITSET_WORDS
)paren
(brace
multiline_comment|/* Build a tree for simple bracket.  */
id|br_token.type
op_assign
id|SIMPLE_BRACKET
suffix:semicolon
id|br_token.opr.sbcset
op_assign
id|sbcset
suffix:semicolon
id|work_tree
op_assign
id|create_token_tree
(paren
id|dfa
comma
l_int|NULL
comma
l_int|NULL
comma
op_amp
id|br_token
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|work_tree
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_goto
id|parse_bracket_exp_espace
suffix:semicolon
multiline_comment|/* Then join them by ALT node.  */
id|work_tree
op_assign
id|create_tree
(paren
id|dfa
comma
id|work_tree
comma
id|mbc_tree
comma
id|OP_ALT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|work_tree
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_goto
id|parse_bracket_exp_espace
suffix:semicolon
)brace
r_else
(brace
id|re_free
(paren
id|sbcset
)paren
suffix:semicolon
id|work_tree
op_assign
id|mbc_tree
suffix:semicolon
)brace
)brace
r_else
macro_line|#endif /* not RE_ENABLE_I18N */
(brace
macro_line|#ifdef RE_ENABLE_I18N
id|free_charset
(paren
id|mbcset
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Build a tree for simple bracket.  */
id|br_token.type
op_assign
id|SIMPLE_BRACKET
suffix:semicolon
id|br_token.opr.sbcset
op_assign
id|sbcset
suffix:semicolon
id|work_tree
op_assign
id|create_token_tree
(paren
id|dfa
comma
l_int|NULL
comma
l_int|NULL
comma
op_amp
id|br_token
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|work_tree
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_goto
id|parse_bracket_exp_espace
suffix:semicolon
)brace
r_return
id|work_tree
suffix:semicolon
id|parse_bracket_exp_espace
suffix:colon
op_star
id|err
op_assign
id|REG_ESPACE
suffix:semicolon
id|parse_bracket_exp_free_return
suffix:colon
id|re_free
(paren
id|sbcset
)paren
suffix:semicolon
macro_line|#ifdef RE_ENABLE_I18N
id|free_charset
(paren
id|mbcset
)paren
suffix:semicolon
macro_line|#endif /* RE_ENABLE_I18N */
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Parse an element in the bracket expression.  */
r_static
id|reg_errcode_t
DECL|function|parse_bracket_element
id|parse_bracket_element
(paren
id|bracket_elem_t
op_star
id|elem
comma
id|re_string_t
op_star
id|regexp
comma
id|re_token_t
op_star
id|token
comma
r_int
id|token_len
comma
id|re_dfa_t
op_star
id|dfa
comma
id|reg_syntax_t
id|syntax
comma
r_int
id|accept_hyphen
)paren
(brace
macro_line|#ifdef RE_ENABLE_I18N
r_int
id|cur_char_size
suffix:semicolon
id|cur_char_size
op_assign
id|re_string_char_size_at
(paren
id|regexp
comma
id|re_string_cur_idx
(paren
id|regexp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur_char_size
OG
l_int|1
)paren
(brace
id|elem-&gt;type
op_assign
id|MB_CHAR
suffix:semicolon
id|elem-&gt;opr.wch
op_assign
id|re_string_wchar_at
(paren
id|regexp
comma
id|re_string_cur_idx
(paren
id|regexp
)paren
)paren
suffix:semicolon
id|re_string_skip_bytes
(paren
id|regexp
comma
id|cur_char_size
)paren
suffix:semicolon
r_return
id|REG_NOERROR
suffix:semicolon
)brace
macro_line|#endif /* RE_ENABLE_I18N */
id|re_string_skip_bytes
(paren
id|regexp
comma
id|token_len
)paren
suffix:semicolon
multiline_comment|/* Skip a token.  */
r_if
c_cond
(paren
id|token-&gt;type
op_eq
id|OP_OPEN_COLL_ELEM
op_logical_or
id|token-&gt;type
op_eq
id|OP_OPEN_CHAR_CLASS
op_logical_or
id|token-&gt;type
op_eq
id|OP_OPEN_EQUIV_CLASS
)paren
r_return
id|parse_bracket_symbol
(paren
id|elem
comma
id|regexp
comma
id|token
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|token-&gt;type
op_eq
id|OP_CHARSET_RANGE
comma
l_int|0
)paren
op_logical_and
op_logical_neg
id|accept_hyphen
)paren
(brace
multiline_comment|/* A &squot;-&squot; must only appear as anything but a range indicator before&n;&t; the closing bracket.  Everything else is an error.  */
id|re_token_t
id|token2
suffix:semicolon
(paren
r_void
)paren
id|peek_token_bracket
(paren
op_amp
id|token2
comma
id|regexp
comma
id|syntax
)paren
suffix:semicolon
r_if
c_cond
(paren
id|token2.type
op_ne
id|OP_CLOSE_BRACKET
)paren
multiline_comment|/* The actual error value is not standardized since this whole&n;&t;   case is undefined.  But ERANGE makes good sense.  */
r_return
id|REG_ERANGE
suffix:semicolon
)brace
id|elem-&gt;type
op_assign
id|SB_CHAR
suffix:semicolon
id|elem-&gt;opr.ch
op_assign
id|token-&gt;opr.c
suffix:semicolon
r_return
id|REG_NOERROR
suffix:semicolon
)brace
multiline_comment|/* Parse a bracket symbol in the bracket expression.  Bracket symbols are&n;   such as [:&lt;character_class&gt;:], [.&lt;collating_element&gt;.], and&n;   [=&lt;equivalent_class&gt;=].  */
r_static
id|reg_errcode_t
DECL|function|parse_bracket_symbol
id|parse_bracket_symbol
(paren
id|bracket_elem_t
op_star
id|elem
comma
id|re_string_t
op_star
id|regexp
comma
id|re_token_t
op_star
id|token
)paren
(brace
r_int
r_char
id|ch
comma
id|delim
op_assign
id|token-&gt;opr.c
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|re_string_eoi
c_func
(paren
id|regexp
)paren
)paren
r_return
id|REG_EBRACK
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|i
op_ge
id|BRACKET_NAME_BUF_SIZE
)paren
r_return
id|REG_EBRACK
suffix:semicolon
r_if
c_cond
(paren
id|token-&gt;type
op_eq
id|OP_OPEN_CHAR_CLASS
)paren
id|ch
op_assign
id|re_string_fetch_byte_case
(paren
id|regexp
)paren
suffix:semicolon
r_else
id|ch
op_assign
id|re_string_fetch_byte
(paren
id|regexp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|re_string_eoi
c_func
(paren
id|regexp
)paren
)paren
r_return
id|REG_EBRACK
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
id|delim
op_logical_and
id|re_string_peek_byte
(paren
id|regexp
comma
l_int|0
)paren
op_eq
l_char|&squot;]&squot;
)paren
r_break
suffix:semicolon
id|elem-&gt;opr.name
(braket
id|i
)braket
op_assign
id|ch
suffix:semicolon
)brace
id|re_string_skip_bytes
(paren
id|regexp
comma
l_int|1
)paren
suffix:semicolon
id|elem-&gt;opr.name
(braket
id|i
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_switch
c_cond
(paren
id|token-&gt;type
)paren
(brace
r_case
id|OP_OPEN_COLL_ELEM
suffix:colon
id|elem-&gt;type
op_assign
id|COLL_SYM
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OP_OPEN_EQUIV_CLASS
suffix:colon
id|elem-&gt;type
op_assign
id|EQUIV_CLASS
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OP_OPEN_CHAR_CLASS
suffix:colon
id|elem-&gt;type
op_assign
id|CHAR_CLASS
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_return
id|REG_NOERROR
suffix:semicolon
)brace
multiline_comment|/* Helper function for parse_bracket_exp.&n;     Build the equivalence class which is represented by NAME.&n;     The result are written to MBCSET and SBCSET.&n;     EQUIV_CLASS_ALLOC is the allocated size of mbcset-&gt;equiv_classes,&n;     is a pointer argument sinse we may update it.  */
r_static
id|reg_errcode_t
macro_line|#ifdef RE_ENABLE_I18N
DECL|function|build_equiv_class
id|build_equiv_class
(paren
id|bitset_t
id|sbcset
comma
id|re_charset_t
op_star
id|mbcset
comma
r_int
op_star
id|equiv_class_alloc
comma
r_const
r_int
r_char
op_star
id|name
)paren
macro_line|#else /* not RE_ENABLE_I18N */
id|build_equiv_class
(paren
id|bitset_t
id|sbcset
comma
r_const
r_int
r_char
op_star
id|name
)paren
macro_line|#endif /* not RE_ENABLE_I18N */
(brace
macro_line|#ifdef _LIBC
r_uint32
id|nrules
op_assign
id|_NL_CURRENT_WORD
(paren
id|LC_COLLATE
comma
id|_NL_COLLATE_NRULES
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nrules
op_ne
l_int|0
)paren
(brace
r_const
r_int32
op_star
id|table
comma
op_star
id|indirect
suffix:semicolon
r_const
r_int
r_char
op_star
id|weights
comma
op_star
id|extra
comma
op_star
id|cp
suffix:semicolon
r_int
r_char
id|char_buf
(braket
l_int|2
)braket
suffix:semicolon
r_int32
id|idx1
comma
id|idx2
suffix:semicolon
r_int
r_int
id|ch
suffix:semicolon
r_int
id|len
suffix:semicolon
multiline_comment|/* This #include defines a local function!  */
macro_line|# include &lt;locale/weight.h&gt;
multiline_comment|/* Calculate the index for equivalence class.  */
id|cp
op_assign
id|name
suffix:semicolon
id|table
op_assign
(paren
r_const
r_int32
op_star
)paren
id|_NL_CURRENT
(paren
id|LC_COLLATE
comma
id|_NL_COLLATE_TABLEMB
)paren
suffix:semicolon
id|weights
op_assign
(paren
r_const
r_int
r_char
op_star
)paren
id|_NL_CURRENT
(paren
id|LC_COLLATE
comma
id|_NL_COLLATE_WEIGHTMB
)paren
suffix:semicolon
id|extra
op_assign
(paren
r_const
r_int
r_char
op_star
)paren
id|_NL_CURRENT
(paren
id|LC_COLLATE
comma
id|_NL_COLLATE_EXTRAMB
)paren
suffix:semicolon
id|indirect
op_assign
(paren
r_const
r_int32
op_star
)paren
id|_NL_CURRENT
(paren
id|LC_COLLATE
comma
id|_NL_COLLATE_INDIRECTMB
)paren
suffix:semicolon
id|idx1
op_assign
id|findidx
(paren
op_amp
id|cp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|idx1
op_eq
l_int|0
op_logical_or
id|cp
OL
id|name
op_plus
id|strlen
(paren
(paren
r_const
r_char
op_star
)paren
id|name
)paren
comma
l_int|0
)paren
)paren
multiline_comment|/* This isn&squot;t a valid character.  */
r_return
id|REG_ECOLLATE
suffix:semicolon
multiline_comment|/* Build single byte matcing table for this equivalence class.  */
id|char_buf
(braket
l_int|1
)braket
op_assign
(paren
r_int
r_char
)paren
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|len
op_assign
id|weights
(braket
id|idx1
op_amp
l_int|0xffffff
)braket
suffix:semicolon
r_for
c_loop
(paren
id|ch
op_assign
l_int|0
suffix:semicolon
id|ch
OL
id|SBC_MAX
suffix:semicolon
op_increment
id|ch
)paren
(brace
id|char_buf
(braket
l_int|0
)braket
op_assign
id|ch
suffix:semicolon
id|cp
op_assign
id|char_buf
suffix:semicolon
id|idx2
op_assign
id|findidx
(paren
op_amp
id|cp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;  idx2 = table[ch];&n;*/
r_if
c_cond
(paren
id|idx2
op_eq
l_int|0
)paren
multiline_comment|/* This isn&squot;t a valid character.  */
r_continue
suffix:semicolon
multiline_comment|/* Compare only if the length matches and the collation rule&n;&t;     index is the same.  */
r_if
c_cond
(paren
id|len
op_eq
id|weights
(braket
id|idx2
op_amp
l_int|0xffffff
)braket
op_logical_and
(paren
id|idx1
op_rshift
l_int|24
)paren
op_eq
(paren
id|idx2
op_rshift
l_int|24
)paren
)paren
(brace
r_int
id|cnt
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|cnt
op_le
id|len
op_logical_and
id|weights
(braket
(paren
id|idx1
op_amp
l_int|0xffffff
)paren
op_plus
l_int|1
op_plus
id|cnt
)braket
op_eq
id|weights
(braket
(paren
id|idx2
op_amp
l_int|0xffffff
)paren
op_plus
l_int|1
op_plus
id|cnt
)braket
)paren
op_increment
id|cnt
suffix:semicolon
r_if
c_cond
(paren
id|cnt
OG
id|len
)paren
id|bitset_set
(paren
id|sbcset
comma
id|ch
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Check whether the array has enough space.  */
r_if
c_cond
(paren
id|BE
(paren
op_star
id|equiv_class_alloc
op_eq
id|mbcset-&gt;nequiv_classes
comma
l_int|0
)paren
)paren
(brace
multiline_comment|/* Not enough, realloc it.  */
multiline_comment|/* +1 in case of mbcset-&gt;nequiv_classes is 0.  */
r_int
id|new_equiv_class_alloc
op_assign
l_int|2
op_star
id|mbcset-&gt;nequiv_classes
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Use realloc since the array is NULL if *alloc == 0.  */
r_int32
op_star
id|new_equiv_classes
op_assign
id|re_realloc
(paren
id|mbcset-&gt;equiv_classes
comma
r_int32
comma
id|new_equiv_class_alloc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|new_equiv_classes
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
id|mbcset-&gt;equiv_classes
op_assign
id|new_equiv_classes
suffix:semicolon
op_star
id|equiv_class_alloc
op_assign
id|new_equiv_class_alloc
suffix:semicolon
)brace
id|mbcset-&gt;equiv_classes
(braket
id|mbcset-&gt;nequiv_classes
op_increment
)braket
op_assign
id|idx1
suffix:semicolon
)brace
r_else
macro_line|#endif /* _LIBC */
(brace
r_if
c_cond
(paren
id|BE
(paren
id|strlen
(paren
(paren
r_const
r_char
op_star
)paren
id|name
)paren
op_ne
l_int|1
comma
l_int|0
)paren
)paren
r_return
id|REG_ECOLLATE
suffix:semicolon
id|bitset_set
(paren
id|sbcset
comma
op_star
id|name
)paren
suffix:semicolon
)brace
r_return
id|REG_NOERROR
suffix:semicolon
)brace
multiline_comment|/* Helper function for parse_bracket_exp.&n;     Build the character class which is represented by NAME.&n;     The result are written to MBCSET and SBCSET.&n;     CHAR_CLASS_ALLOC is the allocated size of mbcset-&gt;char_classes,&n;     is a pointer argument sinse we may update it.  */
r_static
id|reg_errcode_t
macro_line|#ifdef RE_ENABLE_I18N
DECL|function|build_charclass
id|build_charclass
(paren
id|RE_TRANSLATE_TYPE
id|trans
comma
id|bitset_t
id|sbcset
comma
id|re_charset_t
op_star
id|mbcset
comma
r_int
op_star
id|char_class_alloc
comma
r_const
r_char
op_star
id|class_name
comma
id|reg_syntax_t
id|syntax
)paren
macro_line|#else /* not RE_ENABLE_I18N */
id|build_charclass
(paren
id|RE_TRANSLATE_TYPE
id|trans
comma
id|bitset_t
id|sbcset
comma
r_const
r_char
op_star
id|class_name
comma
id|reg_syntax_t
id|syntax
)paren
macro_line|#endif /* not RE_ENABLE_I18N */
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* In case of REG_ICASE &quot;upper&quot; and &quot;lower&quot; match the both of&n;     upper and lower cases.  */
r_if
c_cond
(paren
(paren
id|syntax
op_amp
id|RE_ICASE
)paren
op_logical_and
(paren
id|strcmp
(paren
id|class_name
comma
l_string|&quot;upper&quot;
)paren
op_eq
l_int|0
op_logical_or
id|strcmp
(paren
id|class_name
comma
l_string|&quot;lower&quot;
)paren
op_eq
l_int|0
)paren
)paren
id|class_name
op_assign
l_string|&quot;alpha&quot;
suffix:semicolon
macro_line|#ifdef RE_ENABLE_I18N
multiline_comment|/* Check the space of the arrays.  */
r_if
c_cond
(paren
id|BE
(paren
op_star
id|char_class_alloc
op_eq
id|mbcset-&gt;nchar_classes
comma
l_int|0
)paren
)paren
(brace
multiline_comment|/* Not enough, realloc it.  */
multiline_comment|/* +1 in case of mbcset-&gt;nchar_classes is 0.  */
r_int
id|new_char_class_alloc
op_assign
l_int|2
op_star
id|mbcset-&gt;nchar_classes
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Use realloc since array is NULL if *alloc == 0.  */
id|wctype_t
op_star
id|new_char_classes
op_assign
id|re_realloc
(paren
id|mbcset-&gt;char_classes
comma
id|wctype_t
comma
id|new_char_class_alloc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|new_char_classes
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
id|mbcset-&gt;char_classes
op_assign
id|new_char_classes
suffix:semicolon
op_star
id|char_class_alloc
op_assign
id|new_char_class_alloc
suffix:semicolon
)brace
id|mbcset-&gt;char_classes
(braket
id|mbcset-&gt;nchar_classes
op_increment
)braket
op_assign
id|__wctype
(paren
id|class_name
)paren
suffix:semicolon
macro_line|#endif /* RE_ENABLE_I18N */
DECL|macro|BUILD_CHARCLASS_LOOP
mdefine_line|#define BUILD_CHARCLASS_LOOP(ctype_func)&t;&bslash;&n;  do {&t;&t;&t;&t;&t;&t;&bslash;&n;    if (BE (trans != NULL, 0))&t;&t;&t;&bslash;&n;      {&t;&t;&t;&t;&t;&t;&bslash;&n;&t;for (i = 0; i &lt; SBC_MAX; ++i)&t;&t;&bslash;&n;  &t;  if (ctype_func (i))&t;&t;&t;&bslash;&n;&t;    bitset_set (sbcset, trans[i]);&t;&bslash;&n;      }&t;&t;&t;&t;&t;&t;&bslash;&n;    else&t;&t;&t;&t;&t;&bslash;&n;      {&t;&t;&t;&t;&t;&t;&bslash;&n;&t;for (i = 0; i &lt; SBC_MAX; ++i)&t;&t;&bslash;&n;  &t;  if (ctype_func (i))&t;&t;&t;&bslash;&n;&t;    bitset_set (sbcset, i);&t;&t;&bslash;&n;      }&t;&t;&t;&t;&t;&t;&bslash;&n;  } while (0)
r_if
c_cond
(paren
id|strcmp
(paren
id|class_name
comma
l_string|&quot;alnum&quot;
)paren
op_eq
l_int|0
)paren
id|BUILD_CHARCLASS_LOOP
(paren
id|isalnum
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
(paren
id|class_name
comma
l_string|&quot;cntrl&quot;
)paren
op_eq
l_int|0
)paren
id|BUILD_CHARCLASS_LOOP
(paren
id|iscntrl
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
(paren
id|class_name
comma
l_string|&quot;lower&quot;
)paren
op_eq
l_int|0
)paren
id|BUILD_CHARCLASS_LOOP
(paren
id|islower
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
(paren
id|class_name
comma
l_string|&quot;space&quot;
)paren
op_eq
l_int|0
)paren
id|BUILD_CHARCLASS_LOOP
(paren
id|isspace
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
(paren
id|class_name
comma
l_string|&quot;alpha&quot;
)paren
op_eq
l_int|0
)paren
id|BUILD_CHARCLASS_LOOP
(paren
id|isalpha
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
(paren
id|class_name
comma
l_string|&quot;digit&quot;
)paren
op_eq
l_int|0
)paren
id|BUILD_CHARCLASS_LOOP
(paren
id|isdigit
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
(paren
id|class_name
comma
l_string|&quot;print&quot;
)paren
op_eq
l_int|0
)paren
id|BUILD_CHARCLASS_LOOP
(paren
id|isprint
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
(paren
id|class_name
comma
l_string|&quot;upper&quot;
)paren
op_eq
l_int|0
)paren
id|BUILD_CHARCLASS_LOOP
(paren
id|isupper
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
(paren
id|class_name
comma
l_string|&quot;blank&quot;
)paren
op_eq
l_int|0
)paren
macro_line|#ifndef GAWK
id|BUILD_CHARCLASS_LOOP
(paren
id|isblank
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/* see comments above */
id|BUILD_CHARCLASS_LOOP
(paren
id|is_blank
)paren
suffix:semicolon
macro_line|#endif
r_else
r_if
c_cond
(paren
id|strcmp
(paren
id|class_name
comma
l_string|&quot;graph&quot;
)paren
op_eq
l_int|0
)paren
id|BUILD_CHARCLASS_LOOP
(paren
id|isgraph
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
(paren
id|class_name
comma
l_string|&quot;punct&quot;
)paren
op_eq
l_int|0
)paren
id|BUILD_CHARCLASS_LOOP
(paren
id|ispunct
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
(paren
id|class_name
comma
l_string|&quot;xdigit&quot;
)paren
op_eq
l_int|0
)paren
id|BUILD_CHARCLASS_LOOP
(paren
id|isxdigit
)paren
suffix:semicolon
r_else
r_return
id|REG_ECTYPE
suffix:semicolon
r_return
id|REG_NOERROR
suffix:semicolon
)brace
r_static
id|bin_tree_t
op_star
DECL|function|build_charclass_op
id|build_charclass_op
(paren
id|re_dfa_t
op_star
id|dfa
comma
id|RE_TRANSLATE_TYPE
id|trans
comma
r_const
r_char
op_star
id|class_name
comma
r_const
r_char
op_star
id|extra
comma
r_int
id|non_match
comma
id|reg_errcode_t
op_star
id|err
)paren
(brace
id|re_bitset_ptr_t
id|sbcset
suffix:semicolon
macro_line|#ifdef RE_ENABLE_I18N
id|re_charset_t
op_star
id|mbcset
suffix:semicolon
r_int
id|alloc
op_assign
l_int|0
suffix:semicolon
macro_line|#endif /* not RE_ENABLE_I18N */
id|reg_errcode_t
id|ret
suffix:semicolon
id|re_token_t
id|br_token
suffix:semicolon
id|bin_tree_t
op_star
id|tree
suffix:semicolon
id|sbcset
op_assign
(paren
id|re_bitset_ptr_t
)paren
id|calloc
(paren
r_sizeof
(paren
id|bitset_t
)paren
comma
l_int|1
)paren
suffix:semicolon
macro_line|#ifdef RE_ENABLE_I18N
id|mbcset
op_assign
(paren
id|re_charset_t
op_star
)paren
id|calloc
(paren
r_sizeof
(paren
id|re_charset_t
)paren
comma
l_int|1
)paren
suffix:semicolon
macro_line|#endif /* RE_ENABLE_I18N */
macro_line|#ifdef RE_ENABLE_I18N
r_if
c_cond
(paren
id|BE
(paren
id|sbcset
op_eq
l_int|NULL
op_logical_or
id|mbcset
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
macro_line|#else /* not RE_ENABLE_I18N */
r_if
c_cond
(paren
id|BE
(paren
id|sbcset
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
macro_line|#endif /* not RE_ENABLE_I18N */
(brace
op_star
id|err
op_assign
id|REG_ESPACE
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|non_match
)paren
(brace
macro_line|#ifdef RE_ENABLE_I18N
id|mbcset-&gt;non_match
op_assign
l_int|1
suffix:semicolon
macro_line|#endif /* not RE_ENABLE_I18N */
)brace
multiline_comment|/* We don&squot;t care the syntax in this case.  */
id|ret
op_assign
id|build_charclass
(paren
id|trans
comma
id|sbcset
comma
macro_line|#ifdef RE_ENABLE_I18N
id|mbcset
comma
op_amp
id|alloc
comma
macro_line|#endif /* RE_ENABLE_I18N */
id|class_name
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|ret
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
(brace
id|re_free
(paren
id|sbcset
)paren
suffix:semicolon
macro_line|#ifdef RE_ENABLE_I18N
id|free_charset
(paren
id|mbcset
)paren
suffix:semicolon
macro_line|#endif /* RE_ENABLE_I18N */
op_star
id|err
op_assign
id|ret
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* &bslash;w match &squot;_&squot; also.  */
r_for
c_loop
(paren
suffix:semicolon
op_star
id|extra
suffix:semicolon
id|extra
op_increment
)paren
id|bitset_set
(paren
id|sbcset
comma
op_star
id|extra
)paren
suffix:semicolon
multiline_comment|/* If it is non-matching list.  */
r_if
c_cond
(paren
id|non_match
)paren
id|bitset_not
(paren
id|sbcset
)paren
suffix:semicolon
macro_line|#ifdef RE_ENABLE_I18N
multiline_comment|/* Ensure only single byte characters are set.  */
r_if
c_cond
(paren
id|dfa-&gt;mb_cur_max
OG
l_int|1
)paren
id|bitset_mask
(paren
id|sbcset
comma
id|dfa-&gt;sb_char
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Build a tree for simple bracket.  */
id|br_token.type
op_assign
id|SIMPLE_BRACKET
suffix:semicolon
id|br_token.opr.sbcset
op_assign
id|sbcset
suffix:semicolon
id|tree
op_assign
id|create_token_tree
(paren
id|dfa
comma
l_int|NULL
comma
l_int|NULL
comma
op_amp
id|br_token
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|tree
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_goto
id|build_word_op_espace
suffix:semicolon
macro_line|#ifdef RE_ENABLE_I18N
r_if
c_cond
(paren
id|dfa-&gt;mb_cur_max
OG
l_int|1
)paren
(brace
id|bin_tree_t
op_star
id|mbc_tree
suffix:semicolon
multiline_comment|/* Build a tree for complex bracket.  */
id|br_token.type
op_assign
id|COMPLEX_BRACKET
suffix:semicolon
id|br_token.opr.mbcset
op_assign
id|mbcset
suffix:semicolon
id|dfa-&gt;has_mb_node
op_assign
l_int|1
suffix:semicolon
id|mbc_tree
op_assign
id|create_token_tree
(paren
id|dfa
comma
l_int|NULL
comma
l_int|NULL
comma
op_amp
id|br_token
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|mbc_tree
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_goto
id|build_word_op_espace
suffix:semicolon
multiline_comment|/* Then join them by ALT node.  */
id|tree
op_assign
id|create_tree
(paren
id|dfa
comma
id|tree
comma
id|mbc_tree
comma
id|OP_ALT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|mbc_tree
op_ne
l_int|NULL
comma
l_int|1
)paren
)paren
r_return
id|tree
suffix:semicolon
)brace
r_else
(brace
id|free_charset
(paren
id|mbcset
)paren
suffix:semicolon
r_return
id|tree
suffix:semicolon
)brace
macro_line|#else /* not RE_ENABLE_I18N */
r_return
id|tree
suffix:semicolon
macro_line|#endif /* not RE_ENABLE_I18N */
id|build_word_op_espace
suffix:colon
id|re_free
(paren
id|sbcset
)paren
suffix:semicolon
macro_line|#ifdef RE_ENABLE_I18N
id|free_charset
(paren
id|mbcset
)paren
suffix:semicolon
macro_line|#endif /* RE_ENABLE_I18N */
op_star
id|err
op_assign
id|REG_ESPACE
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* This is intended for the expressions like &quot;a{1,3}&quot;.&n;   Fetch a number from `input&squot;, and return the number.&n;   Return -1, if the number field is empty like &quot;{,1}&quot;.&n;   Return -2, If an error is occured.  */
r_static
r_int
DECL|function|fetch_number
id|fetch_number
(paren
id|re_string_t
op_star
id|input
comma
id|re_token_t
op_star
id|token
comma
id|reg_syntax_t
id|syntax
)paren
(brace
r_int
id|num
op_assign
l_int|1
suffix:semicolon
r_int
r_char
id|c
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|fetch_token
(paren
id|token
comma
id|input
comma
id|syntax
)paren
suffix:semicolon
id|c
op_assign
id|token-&gt;opr.c
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|token-&gt;type
op_eq
id|END_OF_RE
comma
l_int|0
)paren
)paren
r_return
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|token-&gt;type
op_eq
id|OP_CLOSE_DUP_NUM
op_logical_or
id|c
op_eq
l_char|&squot;,&squot;
)paren
r_break
suffix:semicolon
id|num
op_assign
(paren
(paren
id|token-&gt;type
op_ne
id|CHARACTER
op_logical_or
id|c
OL
l_char|&squot;0&squot;
op_logical_or
l_char|&squot;9&squot;
OL
id|c
op_logical_or
id|num
op_eq
l_int|2
)paren
ques
c_cond
l_int|2
suffix:colon
(paren
(paren
id|num
op_eq
l_int|1
)paren
ques
c_cond
id|c
l_char|&squot;0&squot;
suffix:colon
id|num
op_star
l_int|10
op_plus
id|c
l_char|&squot;0&squot;
)paren
)paren
suffix:semicolon
id|num
op_assign
(paren
id|num
OG
id|RE_DUP_MAX
)paren
ques
c_cond
l_int|2
suffix:colon
id|num
suffix:semicolon
)brace
r_return
id|num
suffix:semicolon
)brace
"&f;"
macro_line|#ifdef RE_ENABLE_I18N
r_static
r_void
DECL|function|free_charset
id|free_charset
(paren
id|re_charset_t
op_star
id|cset
)paren
(brace
id|re_free
(paren
id|cset-&gt;mbchars
)paren
suffix:semicolon
macro_line|# ifdef _LIBC
id|re_free
(paren
id|cset-&gt;coll_syms
)paren
suffix:semicolon
id|re_free
(paren
id|cset-&gt;equiv_classes
)paren
suffix:semicolon
id|re_free
(paren
id|cset-&gt;range_starts
)paren
suffix:semicolon
id|re_free
(paren
id|cset-&gt;range_ends
)paren
suffix:semicolon
macro_line|# endif
id|re_free
(paren
id|cset-&gt;char_classes
)paren
suffix:semicolon
id|re_free
(paren
id|cset
)paren
suffix:semicolon
)brace
macro_line|#endif /* RE_ENABLE_I18N */
"&f;"
multiline_comment|/* Functions for binary tree operation.  */
multiline_comment|/* Create a tree node.  */
r_static
id|bin_tree_t
op_star
DECL|function|create_tree
id|create_tree
(paren
id|re_dfa_t
op_star
id|dfa
comma
id|bin_tree_t
op_star
id|left
comma
id|bin_tree_t
op_star
id|right
comma
id|re_token_type_t
id|type
)paren
(brace
id|re_token_t
id|t
suffix:semicolon
id|t.type
op_assign
id|type
suffix:semicolon
r_return
id|create_token_tree
(paren
id|dfa
comma
id|left
comma
id|right
comma
op_amp
id|t
)paren
suffix:semicolon
)brace
r_static
id|bin_tree_t
op_star
DECL|function|create_token_tree
id|create_token_tree
(paren
id|re_dfa_t
op_star
id|dfa
comma
id|bin_tree_t
op_star
id|left
comma
id|bin_tree_t
op_star
id|right
comma
r_const
id|re_token_t
op_star
id|token
)paren
(brace
id|bin_tree_t
op_star
id|tree
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|dfa-&gt;str_tree_storage_idx
op_eq
id|BIN_TREE_STORAGE_SIZE
comma
l_int|0
)paren
)paren
(brace
id|bin_tree_storage_t
op_star
id|storage
op_assign
id|re_malloc
(paren
id|bin_tree_storage_t
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|storage
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|storage-&gt;next
op_assign
id|dfa-&gt;str_tree_storage
suffix:semicolon
id|dfa-&gt;str_tree_storage
op_assign
id|storage
suffix:semicolon
id|dfa-&gt;str_tree_storage_idx
op_assign
l_int|0
suffix:semicolon
)brace
id|tree
op_assign
op_amp
id|dfa-&gt;str_tree_storage-&gt;data
(braket
id|dfa-&gt;str_tree_storage_idx
op_increment
)braket
suffix:semicolon
id|tree-&gt;parent
op_assign
l_int|NULL
suffix:semicolon
id|tree-&gt;left
op_assign
id|left
suffix:semicolon
id|tree-&gt;right
op_assign
id|right
suffix:semicolon
id|tree-&gt;token
op_assign
op_star
id|token
suffix:semicolon
id|tree-&gt;token.duplicated
op_assign
l_int|0
suffix:semicolon
id|tree-&gt;token.opt_subexp
op_assign
l_int|0
suffix:semicolon
id|tree-&gt;first
op_assign
l_int|NULL
suffix:semicolon
id|tree-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|tree-&gt;node_idx
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|left
op_ne
l_int|NULL
)paren
id|left-&gt;parent
op_assign
id|tree
suffix:semicolon
r_if
c_cond
(paren
id|right
op_ne
l_int|NULL
)paren
id|right-&gt;parent
op_assign
id|tree
suffix:semicolon
r_return
id|tree
suffix:semicolon
)brace
multiline_comment|/* Mark the tree SRC as an optional subexpression.&n;   To be called from preorder or postorder.  */
r_static
id|reg_errcode_t
DECL|function|mark_opt_subexp
id|mark_opt_subexp
(paren
r_void
op_star
id|extra
comma
id|bin_tree_t
op_star
id|node
)paren
(brace
r_int
id|idx
op_assign
(paren
r_int
)paren
(paren
r_int
)paren
id|extra
suffix:semicolon
r_if
c_cond
(paren
id|node-&gt;token.type
op_eq
id|SUBEXP
op_logical_and
id|node-&gt;token.opr.idx
op_eq
id|idx
)paren
id|node-&gt;token.opt_subexp
op_assign
l_int|1
suffix:semicolon
r_return
id|REG_NOERROR
suffix:semicolon
)brace
multiline_comment|/* Free the allocated memory inside NODE. */
r_static
r_void
DECL|function|free_token
id|free_token
(paren
id|re_token_t
op_star
id|node
)paren
(brace
macro_line|#ifdef RE_ENABLE_I18N
r_if
c_cond
(paren
id|node-&gt;type
op_eq
id|COMPLEX_BRACKET
op_logical_and
id|node-&gt;duplicated
op_eq
l_int|0
)paren
id|free_charset
(paren
id|node-&gt;opr.mbcset
)paren
suffix:semicolon
r_else
macro_line|#endif /* RE_ENABLE_I18N */
r_if
c_cond
(paren
id|node-&gt;type
op_eq
id|SIMPLE_BRACKET
op_logical_and
id|node-&gt;duplicated
op_eq
l_int|0
)paren
id|re_free
(paren
id|node-&gt;opr.sbcset
)paren
suffix:semicolon
)brace
multiline_comment|/* Worker function for tree walking.  Free the allocated memory inside NODE&n;   and its children. */
r_static
id|reg_errcode_t
DECL|function|free_tree
id|free_tree
(paren
r_void
op_star
id|extra
comma
id|bin_tree_t
op_star
id|node
)paren
(brace
id|free_token
(paren
op_amp
id|node-&gt;token
)paren
suffix:semicolon
r_return
id|REG_NOERROR
suffix:semicolon
)brace
multiline_comment|/* Duplicate the node SRC, and return new node.  This is a preorder&n;   visit similar to the one implemented by the generic visitor, but&n;   we need more infrastructure to maintain two parallel trees --- so,&n;   it&squot;s easier to duplicate.  */
r_static
id|bin_tree_t
op_star
DECL|function|duplicate_tree
id|duplicate_tree
(paren
r_const
id|bin_tree_t
op_star
id|root
comma
id|re_dfa_t
op_star
id|dfa
)paren
(brace
r_const
id|bin_tree_t
op_star
id|node
suffix:semicolon
id|bin_tree_t
op_star
id|dup_root
suffix:semicolon
id|bin_tree_t
op_star
op_star
id|p_new
op_assign
op_amp
id|dup_root
comma
op_star
id|dup_node
op_assign
id|root-&gt;parent
suffix:semicolon
r_for
c_loop
(paren
id|node
op_assign
id|root
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* Create a new tree and link it back to the current parent.  */
op_star
id|p_new
op_assign
id|create_token_tree
(paren
id|dfa
comma
l_int|NULL
comma
l_int|NULL
comma
op_amp
id|node-&gt;token
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p_new
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
(paren
op_star
id|p_new
)paren
op_member_access_from_pointer
id|parent
op_assign
id|dup_node
suffix:semicolon
(paren
op_star
id|p_new
)paren
op_member_access_from_pointer
id|token.duplicated
op_assign
l_int|1
suffix:semicolon
id|dup_node
op_assign
op_star
id|p_new
suffix:semicolon
multiline_comment|/* Go to the left node, or up and to the right.  */
r_if
c_cond
(paren
id|node-&gt;left
)paren
(brace
id|node
op_assign
id|node-&gt;left
suffix:semicolon
id|p_new
op_assign
op_amp
id|dup_node-&gt;left
suffix:semicolon
)brace
r_else
(brace
r_const
id|bin_tree_t
op_star
id|prev
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|node-&gt;right
op_eq
id|prev
op_logical_or
id|node-&gt;right
op_eq
l_int|NULL
)paren
(brace
id|prev
op_assign
id|node
suffix:semicolon
id|node
op_assign
id|node-&gt;parent
suffix:semicolon
id|dup_node
op_assign
id|dup_node-&gt;parent
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|node
)paren
r_return
id|dup_root
suffix:semicolon
)brace
id|node
op_assign
id|node-&gt;right
suffix:semicolon
id|p_new
op_assign
op_amp
id|dup_node-&gt;right
suffix:semicolon
)brace
)brace
)brace
eof
