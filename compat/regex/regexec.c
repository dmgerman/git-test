multiline_comment|/* Extended regular expression matching and search library.&n;   Copyright (C) 2002-2005, 2007, 2009, 2010 Free Software Foundation, Inc.&n;   This file is part of the GNU C Library.&n;   Contributed by Isamu Hasegawa &lt;isamu@yamato.ibm.com&gt;.&n;&n;   The GNU C Library is free software; you can redistribute it and/or&n;   modify it under the terms of the GNU Lesser General Public&n;   License as published by the Free Software Foundation; either&n;   version 2.1 of the License, or (at your option) any later version.&n;&n;   The GNU C Library is distributed in the hope that it will be useful,&n;   but WITHOUT ANY WARRANTY; without even the implied warranty of&n;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n;   Lesser General Public License for more details.&n;&n;   You should have received a copy of the GNU Lesser General Public&n;   License along with the GNU C Library; if not, write to the Free&n;   Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA&n;   02110-1301 USA.  */
r_static
id|reg_errcode_t
id|match_ctx_init
(paren
id|re_match_context_t
op_star
id|cache
comma
r_int
id|eflags
comma
r_int
id|n
)paren
id|internal_function
suffix:semicolon
r_static
r_void
id|match_ctx_clean
(paren
id|re_match_context_t
op_star
id|mctx
)paren
id|internal_function
suffix:semicolon
r_static
r_void
id|match_ctx_free
(paren
id|re_match_context_t
op_star
id|cache
)paren
id|internal_function
suffix:semicolon
r_static
id|reg_errcode_t
id|match_ctx_add_entry
(paren
id|re_match_context_t
op_star
id|cache
comma
r_int
id|node
comma
r_int
id|str_idx
comma
r_int
id|from
comma
r_int
id|to
)paren
id|internal_function
suffix:semicolon
r_static
r_int
id|search_cur_bkref_entry
(paren
r_const
id|re_match_context_t
op_star
id|mctx
comma
r_int
id|str_idx
)paren
id|internal_function
suffix:semicolon
r_static
id|reg_errcode_t
id|match_ctx_add_subtop
(paren
id|re_match_context_t
op_star
id|mctx
comma
r_int
id|node
comma
r_int
id|str_idx
)paren
id|internal_function
suffix:semicolon
r_static
id|re_sub_match_last_t
op_star
id|match_ctx_add_sublast
(paren
id|re_sub_match_top_t
op_star
id|subtop
comma
r_int
id|node
comma
r_int
id|str_idx
)paren
id|internal_function
suffix:semicolon
r_static
r_void
id|sift_ctx_init
(paren
id|re_sift_context_t
op_star
id|sctx
comma
id|re_dfastate_t
op_star
op_star
id|sifted_sts
comma
id|re_dfastate_t
op_star
op_star
id|limited_sts
comma
r_int
id|last_node
comma
r_int
id|last_str_idx
)paren
id|internal_function
suffix:semicolon
r_static
id|reg_errcode_t
id|re_search_internal
(paren
r_const
id|regex_t
op_star
id|preg
comma
r_const
r_char
op_star
id|string
comma
r_int
id|length
comma
r_int
id|start
comma
r_int
id|range
comma
r_int
id|stop
comma
r_int
id|nmatch
comma
id|regmatch_t
id|pmatch
(braket
)braket
comma
r_int
id|eflags
)paren
suffix:semicolon
r_static
r_int
id|re_search_2_stub
(paren
r_struct
id|re_pattern_buffer
op_star
id|bufp
comma
r_const
r_char
op_star
id|string1
comma
r_int
id|length1
comma
r_const
r_char
op_star
id|string2
comma
r_int
id|length2
comma
r_int
id|start
comma
r_int
id|range
comma
r_struct
id|re_registers
op_star
id|regs
comma
r_int
id|stop
comma
r_int
id|ret_len
)paren
suffix:semicolon
r_static
r_int
id|re_search_stub
(paren
r_struct
id|re_pattern_buffer
op_star
id|bufp
comma
r_const
r_char
op_star
id|string
comma
r_int
id|length
comma
r_int
id|start
comma
r_int
id|range
comma
r_int
id|stop
comma
r_struct
id|re_registers
op_star
id|regs
comma
r_int
id|ret_len
)paren
suffix:semicolon
r_static
r_int
id|re_copy_regs
(paren
r_struct
id|re_registers
op_star
id|regs
comma
id|regmatch_t
op_star
id|pmatch
comma
r_int
id|nregs
comma
r_int
id|regs_allocated
)paren
suffix:semicolon
r_static
id|reg_errcode_t
id|prune_impossible_nodes
(paren
id|re_match_context_t
op_star
id|mctx
)paren
suffix:semicolon
r_static
r_int
id|check_matching
(paren
id|re_match_context_t
op_star
id|mctx
comma
r_int
id|fl_longest_match
comma
r_int
op_star
id|p_match_first
)paren
id|internal_function
suffix:semicolon
r_static
r_int
id|check_halt_state_context
(paren
r_const
id|re_match_context_t
op_star
id|mctx
comma
r_const
id|re_dfastate_t
op_star
id|state
comma
r_int
id|idx
)paren
id|internal_function
suffix:semicolon
r_static
r_void
id|update_regs
(paren
r_const
id|re_dfa_t
op_star
id|dfa
comma
id|regmatch_t
op_star
id|pmatch
comma
id|regmatch_t
op_star
id|prev_idx_match
comma
r_int
id|cur_node
comma
r_int
id|cur_idx
comma
r_int
id|nmatch
)paren
id|internal_function
suffix:semicolon
r_static
id|reg_errcode_t
id|push_fail_stack
(paren
r_struct
id|re_fail_stack_t
op_star
id|fs
comma
r_int
id|str_idx
comma
r_int
id|dest_node
comma
r_int
id|nregs
comma
id|regmatch_t
op_star
id|regs
comma
id|re_node_set
op_star
id|eps_via_nodes
)paren
id|internal_function
suffix:semicolon
r_static
id|reg_errcode_t
id|set_regs
(paren
r_const
id|regex_t
op_star
id|preg
comma
r_const
id|re_match_context_t
op_star
id|mctx
comma
r_int
id|nmatch
comma
id|regmatch_t
op_star
id|pmatch
comma
r_int
id|fl_backtrack
)paren
id|internal_function
suffix:semicolon
r_static
id|reg_errcode_t
id|free_fail_stack_return
(paren
r_struct
id|re_fail_stack_t
op_star
id|fs
)paren
id|internal_function
suffix:semicolon
macro_line|#ifdef RE_ENABLE_I18N
r_static
r_int
id|sift_states_iter_mb
(paren
r_const
id|re_match_context_t
op_star
id|mctx
comma
id|re_sift_context_t
op_star
id|sctx
comma
r_int
id|node_idx
comma
r_int
id|str_idx
comma
r_int
id|max_str_idx
)paren
id|internal_function
suffix:semicolon
macro_line|#endif /* RE_ENABLE_I18N */
r_static
id|reg_errcode_t
id|sift_states_backward
(paren
r_const
id|re_match_context_t
op_star
id|mctx
comma
id|re_sift_context_t
op_star
id|sctx
)paren
id|internal_function
suffix:semicolon
r_static
id|reg_errcode_t
id|build_sifted_states
(paren
r_const
id|re_match_context_t
op_star
id|mctx
comma
id|re_sift_context_t
op_star
id|sctx
comma
r_int
id|str_idx
comma
id|re_node_set
op_star
id|cur_dest
)paren
id|internal_function
suffix:semicolon
r_static
id|reg_errcode_t
id|update_cur_sifted_state
(paren
r_const
id|re_match_context_t
op_star
id|mctx
comma
id|re_sift_context_t
op_star
id|sctx
comma
r_int
id|str_idx
comma
id|re_node_set
op_star
id|dest_nodes
)paren
id|internal_function
suffix:semicolon
r_static
id|reg_errcode_t
id|add_epsilon_src_nodes
(paren
r_const
id|re_dfa_t
op_star
id|dfa
comma
id|re_node_set
op_star
id|dest_nodes
comma
r_const
id|re_node_set
op_star
id|candidates
)paren
id|internal_function
suffix:semicolon
r_static
r_int
id|check_dst_limits
(paren
r_const
id|re_match_context_t
op_star
id|mctx
comma
id|re_node_set
op_star
id|limits
comma
r_int
id|dst_node
comma
r_int
id|dst_idx
comma
r_int
id|src_node
comma
r_int
id|src_idx
)paren
id|internal_function
suffix:semicolon
r_static
r_int
id|check_dst_limits_calc_pos_1
(paren
r_const
id|re_match_context_t
op_star
id|mctx
comma
r_int
id|boundaries
comma
r_int
id|subexp_idx
comma
r_int
id|from_node
comma
r_int
id|bkref_idx
)paren
id|internal_function
suffix:semicolon
r_static
r_int
id|check_dst_limits_calc_pos
(paren
r_const
id|re_match_context_t
op_star
id|mctx
comma
r_int
id|limit
comma
r_int
id|subexp_idx
comma
r_int
id|node
comma
r_int
id|str_idx
comma
r_int
id|bkref_idx
)paren
id|internal_function
suffix:semicolon
r_static
id|reg_errcode_t
id|check_subexp_limits
(paren
r_const
id|re_dfa_t
op_star
id|dfa
comma
id|re_node_set
op_star
id|dest_nodes
comma
r_const
id|re_node_set
op_star
id|candidates
comma
id|re_node_set
op_star
id|limits
comma
r_struct
id|re_backref_cache_entry
op_star
id|bkref_ents
comma
r_int
id|str_idx
)paren
id|internal_function
suffix:semicolon
r_static
id|reg_errcode_t
id|sift_states_bkref
(paren
r_const
id|re_match_context_t
op_star
id|mctx
comma
id|re_sift_context_t
op_star
id|sctx
comma
r_int
id|str_idx
comma
r_const
id|re_node_set
op_star
id|candidates
)paren
id|internal_function
suffix:semicolon
r_static
id|reg_errcode_t
id|merge_state_array
(paren
r_const
id|re_dfa_t
op_star
id|dfa
comma
id|re_dfastate_t
op_star
op_star
id|dst
comma
id|re_dfastate_t
op_star
op_star
id|src
comma
r_int
id|num
)paren
id|internal_function
suffix:semicolon
r_static
id|re_dfastate_t
op_star
id|find_recover_state
(paren
id|reg_errcode_t
op_star
id|err
comma
id|re_match_context_t
op_star
id|mctx
)paren
id|internal_function
suffix:semicolon
r_static
id|re_dfastate_t
op_star
id|transit_state
(paren
id|reg_errcode_t
op_star
id|err
comma
id|re_match_context_t
op_star
id|mctx
comma
id|re_dfastate_t
op_star
id|state
)paren
id|internal_function
suffix:semicolon
r_static
id|re_dfastate_t
op_star
id|merge_state_with_log
(paren
id|reg_errcode_t
op_star
id|err
comma
id|re_match_context_t
op_star
id|mctx
comma
id|re_dfastate_t
op_star
id|next_state
)paren
id|internal_function
suffix:semicolon
r_static
id|reg_errcode_t
id|check_subexp_matching_top
(paren
id|re_match_context_t
op_star
id|mctx
comma
id|re_node_set
op_star
id|cur_nodes
comma
r_int
id|str_idx
)paren
id|internal_function
suffix:semicolon
macro_line|#if 0
r_static
id|re_dfastate_t
op_star
id|transit_state_sb
(paren
id|reg_errcode_t
op_star
id|err
comma
id|re_match_context_t
op_star
id|mctx
comma
id|re_dfastate_t
op_star
id|pstate
)paren
id|internal_function
suffix:semicolon
macro_line|#endif
macro_line|#ifdef RE_ENABLE_I18N
r_static
id|reg_errcode_t
id|transit_state_mb
(paren
id|re_match_context_t
op_star
id|mctx
comma
id|re_dfastate_t
op_star
id|pstate
)paren
id|internal_function
suffix:semicolon
macro_line|#endif /* RE_ENABLE_I18N */
r_static
id|reg_errcode_t
id|transit_state_bkref
(paren
id|re_match_context_t
op_star
id|mctx
comma
r_const
id|re_node_set
op_star
id|nodes
)paren
id|internal_function
suffix:semicolon
r_static
id|reg_errcode_t
id|get_subexp
(paren
id|re_match_context_t
op_star
id|mctx
comma
r_int
id|bkref_node
comma
r_int
id|bkref_str_idx
)paren
id|internal_function
suffix:semicolon
r_static
id|reg_errcode_t
id|get_subexp_sub
(paren
id|re_match_context_t
op_star
id|mctx
comma
r_const
id|re_sub_match_top_t
op_star
id|sub_top
comma
id|re_sub_match_last_t
op_star
id|sub_last
comma
r_int
id|bkref_node
comma
r_int
id|bkref_str
)paren
id|internal_function
suffix:semicolon
r_static
r_int
id|find_subexp_node
(paren
r_const
id|re_dfa_t
op_star
id|dfa
comma
r_const
id|re_node_set
op_star
id|nodes
comma
r_int
id|subexp_idx
comma
r_int
id|type
)paren
id|internal_function
suffix:semicolon
r_static
id|reg_errcode_t
id|check_arrival
(paren
id|re_match_context_t
op_star
id|mctx
comma
id|state_array_t
op_star
id|path
comma
r_int
id|top_node
comma
r_int
id|top_str
comma
r_int
id|last_node
comma
r_int
id|last_str
comma
r_int
id|type
)paren
id|internal_function
suffix:semicolon
r_static
id|reg_errcode_t
id|check_arrival_add_next_nodes
(paren
id|re_match_context_t
op_star
id|mctx
comma
r_int
id|str_idx
comma
id|re_node_set
op_star
id|cur_nodes
comma
id|re_node_set
op_star
id|next_nodes
)paren
id|internal_function
suffix:semicolon
r_static
id|reg_errcode_t
id|check_arrival_expand_ecl
(paren
r_const
id|re_dfa_t
op_star
id|dfa
comma
id|re_node_set
op_star
id|cur_nodes
comma
r_int
id|ex_subexp
comma
r_int
id|type
)paren
id|internal_function
suffix:semicolon
r_static
id|reg_errcode_t
id|check_arrival_expand_ecl_sub
(paren
r_const
id|re_dfa_t
op_star
id|dfa
comma
id|re_node_set
op_star
id|dst_nodes
comma
r_int
id|target
comma
r_int
id|ex_subexp
comma
r_int
id|type
)paren
id|internal_function
suffix:semicolon
r_static
id|reg_errcode_t
id|expand_bkref_cache
(paren
id|re_match_context_t
op_star
id|mctx
comma
id|re_node_set
op_star
id|cur_nodes
comma
r_int
id|cur_str
comma
r_int
id|subexp_num
comma
r_int
id|type
)paren
id|internal_function
suffix:semicolon
r_static
r_int
id|build_trtable
(paren
r_const
id|re_dfa_t
op_star
id|dfa
comma
id|re_dfastate_t
op_star
id|state
)paren
id|internal_function
suffix:semicolon
macro_line|#ifdef RE_ENABLE_I18N
r_static
r_int
id|check_node_accept_bytes
(paren
r_const
id|re_dfa_t
op_star
id|dfa
comma
r_int
id|node_idx
comma
r_const
id|re_string_t
op_star
id|input
comma
r_int
id|idx
)paren
id|internal_function
suffix:semicolon
macro_line|# ifdef _LIBC
r_static
r_int
r_int
id|find_collation_sequence_value
(paren
r_const
r_int
r_char
op_star
id|mbs
comma
r_int
id|name_len
)paren
id|internal_function
suffix:semicolon
macro_line|# endif /* _LIBC */
macro_line|#endif /* RE_ENABLE_I18N */
r_static
r_int
id|group_nodes_into_DFAstates
(paren
r_const
id|re_dfa_t
op_star
id|dfa
comma
r_const
id|re_dfastate_t
op_star
id|state
comma
id|re_node_set
op_star
id|states_node
comma
id|bitset_t
op_star
id|states_ch
)paren
id|internal_function
suffix:semicolon
r_static
r_int
id|check_node_accept
(paren
r_const
id|re_match_context_t
op_star
id|mctx
comma
r_const
id|re_token_t
op_star
id|node
comma
r_int
id|idx
)paren
id|internal_function
suffix:semicolon
r_static
id|reg_errcode_t
id|extend_buffers
(paren
id|re_match_context_t
op_star
id|mctx
)paren
id|internal_function
suffix:semicolon
"&f;"
multiline_comment|/* Entry point for POSIX code.  */
multiline_comment|/* regexec searches for a given pattern, specified by PREG, in the&n;   string STRING.&n;&n;   If NMATCH is zero or REG_NOSUB was set in the cflags argument to&n;   `regcomp&squot;, we ignore PMATCH.  Otherwise, we assume PMATCH has at&n;   least NMATCH elements, and we set them to the offsets of the&n;   corresponding matched substrings.&n;&n;   EFLAGS specifies `execution flags&squot; which affect matching: if&n;   REG_NOTBOL is set, then ^ does not match at the beginning of the&n;   string; if REG_NOTEOL is set, then $ does not match at the end.&n;&n;   We return 0 if we find a match and REG_NOMATCH if not.  */
r_int
DECL|function|regexec
id|regexec
(paren
r_const
id|regex_t
op_star
id|__restrict
id|preg
comma
r_const
r_char
op_star
id|__restrict
id|string
comma
r_int
id|nmatch
comma
id|regmatch_t
id|pmatch
(braket
)braket
comma
r_int
id|eflags
)paren
(brace
id|reg_errcode_t
id|err
suffix:semicolon
r_int
id|start
comma
id|length
suffix:semicolon
r_if
c_cond
(paren
id|eflags
op_amp
op_complement
(paren
id|REG_NOTBOL
op_or
id|REG_NOTEOL
op_or
id|REG_STARTEND
)paren
)paren
r_return
id|REG_BADPAT
suffix:semicolon
r_if
c_cond
(paren
id|eflags
op_amp
id|REG_STARTEND
)paren
(brace
id|start
op_assign
id|pmatch
(braket
l_int|0
)braket
dot
id|rm_so
suffix:semicolon
id|length
op_assign
id|pmatch
(braket
l_int|0
)braket
dot
id|rm_eo
suffix:semicolon
)brace
r_else
(brace
id|start
op_assign
l_int|0
suffix:semicolon
id|length
op_assign
id|strlen
(paren
id|string
)paren
suffix:semicolon
)brace
id|__libc_lock_lock
(paren
id|dfa-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|preg-&gt;no_sub
)paren
id|err
op_assign
id|re_search_internal
(paren
id|preg
comma
id|string
comma
id|length
comma
id|start
comma
id|length
id|start
comma
id|length
comma
l_int|0
comma
l_int|NULL
comma
id|eflags
)paren
suffix:semicolon
r_else
id|err
op_assign
id|re_search_internal
(paren
id|preg
comma
id|string
comma
id|length
comma
id|start
comma
id|length
id|start
comma
id|length
comma
id|nmatch
comma
id|pmatch
comma
id|eflags
)paren
suffix:semicolon
id|__libc_lock_unlock
(paren
id|dfa-&gt;lock
)paren
suffix:semicolon
r_return
id|err
op_ne
id|REG_NOERROR
suffix:semicolon
)brace
macro_line|#ifdef _LIBC
macro_line|# include &lt;shlib-compat.h&gt;
id|versioned_symbol
(paren
id|libc
comma
id|__regexec
comma
id|regexec
comma
id|GLIBC_2_3_4
)paren
suffix:semicolon
macro_line|# if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_3_4)
id|__typeof__
(paren
id|__regexec
)paren
id|__compat_regexec
suffix:semicolon
r_int
id|attribute_compat_text_section
DECL|function|__compat_regexec
id|__compat_regexec
(paren
r_const
id|regex_t
op_star
id|__restrict
id|preg
comma
r_const
r_char
op_star
id|__restrict
id|string
comma
r_int
id|nmatch
comma
id|regmatch_t
id|pmatch
(braket
)braket
comma
r_int
id|eflags
)paren
(brace
r_return
id|regexec
(paren
id|preg
comma
id|string
comma
id|nmatch
comma
id|pmatch
comma
id|eflags
op_amp
(paren
id|REG_NOTBOL
op_or
id|REG_NOTEOL
)paren
)paren
suffix:semicolon
)brace
id|compat_symbol
(paren
id|libc
comma
id|__compat_regexec
comma
id|regexec
comma
id|GLIBC_2_0
)paren
suffix:semicolon
macro_line|# endif
macro_line|#endif
multiline_comment|/* Entry points for GNU code.  */
multiline_comment|/* re_match, re_search, re_match_2, re_search_2&n;&n;   The former two functions operate on STRING with length LENGTH,&n;   while the later two operate on concatenation of STRING1 and STRING2&n;   with lengths LENGTH1 and LENGTH2, respectively.&n;&n;   re_match() matches the compiled pattern in BUFP against the string,&n;   starting at index START.&n;&n;   re_search() first tries matching at index START, then it tries to match&n;   starting from index START + 1, and so on.  The last start position tried&n;   is START + RANGE.  (Thus RANGE = 0 forces re_search to operate the same&n;   way as re_match().)&n;&n;   The parameter STOP of re_{match,search}_2 specifies that no match exceeding&n;   the first STOP characters of the concatenation of the strings should be&n;   concerned.&n;&n;   If REGS is not NULL, and BUFP-&gt;no_sub is not set, the offsets of the match&n;   and all groups is stroed in REGS.  (For the &quot;_2&quot; variants, the offsets are&n;   computed relative to the concatenation, not relative to the individual&n;   strings.)&n;&n;   On success, re_match* functions return the length of the match, re_search*&n;   return the position of the start of the match.  Return value -1 means no&n;   match was found and -2 indicates an internal error.  */
r_int
DECL|function|re_match
id|re_match
(paren
r_struct
id|re_pattern_buffer
op_star
id|bufp
comma
r_const
r_char
op_star
id|string
comma
r_int
id|length
comma
r_int
id|start
comma
r_struct
id|re_registers
op_star
id|regs
)paren
(brace
r_return
id|re_search_stub
(paren
id|bufp
comma
id|string
comma
id|length
comma
id|start
comma
l_int|0
comma
id|length
comma
id|regs
comma
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#ifdef _LIBC
DECL|function|weak_alias
id|weak_alias
(paren
id|__re_match
comma
id|re_match
)paren
macro_line|#endif
r_int
id|re_search
(paren
r_struct
id|re_pattern_buffer
op_star
id|bufp
comma
r_const
r_char
op_star
id|string
comma
r_int
id|length
comma
r_int
id|start
comma
r_int
id|range
comma
r_struct
id|re_registers
op_star
id|regs
)paren
(brace
r_return
id|re_search_stub
(paren
id|bufp
comma
id|string
comma
id|length
comma
id|start
comma
id|range
comma
id|length
comma
id|regs
comma
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#ifdef _LIBC
DECL|function|weak_alias
id|weak_alias
(paren
id|__re_search
comma
id|re_search
)paren
macro_line|#endif
r_int
id|re_match_2
(paren
r_struct
id|re_pattern_buffer
op_star
id|bufp
comma
r_const
r_char
op_star
id|string1
comma
r_int
id|length1
comma
r_const
r_char
op_star
id|string2
comma
r_int
id|length2
comma
r_int
id|start
comma
r_struct
id|re_registers
op_star
id|regs
comma
r_int
id|stop
)paren
(brace
r_return
id|re_search_2_stub
(paren
id|bufp
comma
id|string1
comma
id|length1
comma
id|string2
comma
id|length2
comma
id|start
comma
l_int|0
comma
id|regs
comma
id|stop
comma
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#ifdef _LIBC
DECL|function|weak_alias
id|weak_alias
(paren
id|__re_match_2
comma
id|re_match_2
)paren
macro_line|#endif
r_int
id|re_search_2
(paren
r_struct
id|re_pattern_buffer
op_star
id|bufp
comma
r_const
r_char
op_star
id|string1
comma
r_int
id|length1
comma
r_const
r_char
op_star
id|string2
comma
r_int
id|length2
comma
r_int
id|start
comma
r_int
id|range
comma
r_struct
id|re_registers
op_star
id|regs
comma
r_int
id|stop
)paren
(brace
r_return
id|re_search_2_stub
(paren
id|bufp
comma
id|string1
comma
id|length1
comma
id|string2
comma
id|length2
comma
id|start
comma
id|range
comma
id|regs
comma
id|stop
comma
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#ifdef _LIBC
id|weak_alias
(paren
id|__re_search_2
comma
id|re_search_2
)paren
macro_line|#endif
r_static
r_int
DECL|function|re_search_2_stub
id|re_search_2_stub
(paren
r_struct
id|re_pattern_buffer
op_star
id|bufp
comma
r_const
r_char
op_star
id|string1
comma
r_int
id|length1
comma
r_const
r_char
op_star
id|string2
comma
r_int
id|length2
comma
r_int
id|start
comma
r_int
id|range
comma
r_struct
id|re_registers
op_star
id|regs
comma
r_int
id|stop
comma
r_int
id|ret_len
)paren
(brace
r_const
r_char
op_star
id|str
suffix:semicolon
r_int
id|rval
suffix:semicolon
r_int
id|len
op_assign
id|length1
op_plus
id|length2
suffix:semicolon
r_int
id|free_str
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|length1
OL
l_int|0
op_logical_or
id|length2
OL
l_int|0
op_logical_or
id|stop
OL
l_int|0
comma
l_int|0
)paren
)paren
r_return
l_int|2
suffix:semicolon
multiline_comment|/* Concatenate the strings.  */
r_if
c_cond
(paren
id|length2
OG
l_int|0
)paren
r_if
c_cond
(paren
id|length1
OG
l_int|0
)paren
(brace
r_char
op_star
id|s
op_assign
id|re_malloc
(paren
r_char
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|s
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
l_int|2
suffix:semicolon
id|memcpy
(paren
id|s
comma
id|string1
comma
id|length1
)paren
suffix:semicolon
id|memcpy
(paren
id|s
op_plus
id|length1
comma
id|string2
comma
id|length2
)paren
suffix:semicolon
id|str
op_assign
id|s
suffix:semicolon
id|free_str
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|str
op_assign
id|string2
suffix:semicolon
r_else
id|str
op_assign
id|string1
suffix:semicolon
id|rval
op_assign
id|re_search_stub
(paren
id|bufp
comma
id|str
comma
id|len
comma
id|start
comma
id|range
comma
id|stop
comma
id|regs
comma
id|ret_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|free_str
)paren
id|re_free
(paren
(paren
r_char
op_star
)paren
id|str
)paren
suffix:semicolon
r_return
id|rval
suffix:semicolon
)brace
multiline_comment|/* The parameters have the same meaning as those of re_search.&n;   Additional parameters:&n;   If RET_LEN is nonzero the length of the match is returned (re_match style);&n;   otherwise the position of the match is returned.  */
r_static
r_int
DECL|function|re_search_stub
id|re_search_stub
(paren
r_struct
id|re_pattern_buffer
op_star
id|bufp
comma
r_const
r_char
op_star
id|string
comma
r_int
id|length
comma
r_int
id|start
comma
r_int
id|range
comma
r_int
id|stop
comma
r_struct
id|re_registers
op_star
id|regs
comma
r_int
id|ret_len
)paren
(brace
id|reg_errcode_t
id|result
suffix:semicolon
id|regmatch_t
op_star
id|pmatch
suffix:semicolon
r_int
id|nregs
comma
id|rval
suffix:semicolon
r_int
id|eflags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Check for out-of-range.  */
r_if
c_cond
(paren
id|BE
(paren
id|start
template_param
id|length
comma
l_int|0
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|start
op_plus
id|range
OG
id|length
comma
l_int|0
)paren
)paren
id|range
op_assign
id|length
id|start
suffix:semicolon
r_else
r_if
c_cond
(paren
id|BE
(paren
id|start
op_plus
id|range
OL
l_int|0
comma
l_int|0
)paren
)paren
id|range
op_assign
id|start
suffix:semicolon
id|__libc_lock_lock
(paren
id|dfa-&gt;lock
)paren
suffix:semicolon
id|eflags
op_or_assign
(paren
id|bufp-&gt;not_bol
)paren
ques
c_cond
id|REG_NOTBOL
suffix:colon
l_int|0
suffix:semicolon
id|eflags
op_or_assign
(paren
id|bufp-&gt;not_eol
)paren
ques
c_cond
id|REG_NOTEOL
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* Compile fastmap if we haven&squot;t yet.  */
r_if
c_cond
(paren
id|range
OG
l_int|0
op_logical_and
id|bufp-&gt;fastmap
op_ne
l_int|NULL
op_logical_and
op_logical_neg
id|bufp-&gt;fastmap_accurate
)paren
id|re_compile_fastmap
(paren
id|bufp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|bufp-&gt;no_sub
comma
l_int|0
)paren
)paren
id|regs
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* We need at least 1 register.  */
r_if
c_cond
(paren
id|regs
op_eq
l_int|NULL
)paren
id|nregs
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|BE
(paren
id|bufp-&gt;regs_allocated
op_eq
id|REGS_FIXED
op_logical_and
id|regs-&gt;num_regs
OL
id|bufp-&gt;re_nsub
op_plus
l_int|1
comma
l_int|0
)paren
)paren
(brace
id|nregs
op_assign
id|regs-&gt;num_regs
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|nregs
OL
l_int|1
comma
l_int|0
)paren
)paren
(brace
multiline_comment|/* Nothing can be copied to regs.  */
id|regs
op_assign
l_int|NULL
suffix:semicolon
id|nregs
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
id|nregs
op_assign
id|bufp-&gt;re_nsub
op_plus
l_int|1
suffix:semicolon
id|pmatch
op_assign
id|re_malloc
(paren
id|regmatch_t
comma
id|nregs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|pmatch
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
(brace
id|rval
op_assign
l_int|2
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|result
op_assign
id|re_search_internal
(paren
id|bufp
comma
id|string
comma
id|length
comma
id|start
comma
id|range
comma
id|stop
comma
id|nregs
comma
id|pmatch
comma
id|eflags
)paren
suffix:semicolon
id|rval
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* I hope we needn&squot;t fill ther regs with -1&squot;s when no match was found.  */
r_if
c_cond
(paren
id|result
op_ne
id|REG_NOERROR
)paren
id|rval
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|regs
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* If caller wants register contents data back, copy them.  */
id|bufp-&gt;regs_allocated
op_assign
id|re_copy_regs
(paren
id|regs
comma
id|pmatch
comma
id|nregs
comma
id|bufp-&gt;regs_allocated
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|bufp-&gt;regs_allocated
op_eq
id|REGS_UNALLOCATED
comma
l_int|0
)paren
)paren
id|rval
op_assign
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|BE
(paren
id|rval
op_eq
l_int|0
comma
l_int|1
)paren
)paren
(brace
r_if
c_cond
(paren
id|ret_len
)paren
(brace
m_assert
(paren
id|pmatch
(braket
l_int|0
)braket
dot
id|rm_so
op_eq
id|start
)paren
suffix:semicolon
id|rval
op_assign
id|pmatch
(braket
l_int|0
)braket
dot
id|rm_eo
id|start
suffix:semicolon
)brace
r_else
id|rval
op_assign
id|pmatch
(braket
l_int|0
)braket
dot
id|rm_so
suffix:semicolon
)brace
id|re_free
(paren
id|pmatch
)paren
suffix:semicolon
id|out
suffix:colon
id|__libc_lock_unlock
(paren
id|dfa-&gt;lock
)paren
suffix:semicolon
r_return
id|rval
suffix:semicolon
)brace
r_static
r_int
DECL|function|re_copy_regs
id|re_copy_regs
(paren
r_struct
id|re_registers
op_star
id|regs
comma
id|regmatch_t
op_star
id|pmatch
comma
r_int
id|nregs
comma
r_int
id|regs_allocated
)paren
(brace
r_int
id|rval
op_assign
id|REGS_REALLOCATE
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|need_regs
op_assign
id|nregs
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* We need one extra element beyond `num_regs&squot; for the `-1&squot; marker GNU code&n;     uses.  */
multiline_comment|/* Have the register data arrays been allocated?  */
r_if
c_cond
(paren
id|regs_allocated
op_eq
id|REGS_UNALLOCATED
)paren
(brace
multiline_comment|/* No.  So allocate them with malloc.  */
id|regs-&gt;start
op_assign
id|re_malloc
(paren
id|regoff_t
comma
id|need_regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|regs-&gt;start
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
id|REGS_UNALLOCATED
suffix:semicolon
id|regs-&gt;end
op_assign
id|re_malloc
(paren
id|regoff_t
comma
id|need_regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|regs-&gt;end
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
(brace
id|re_free
(paren
id|regs-&gt;start
)paren
suffix:semicolon
r_return
id|REGS_UNALLOCATED
suffix:semicolon
)brace
id|regs-&gt;num_regs
op_assign
id|need_regs
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|regs_allocated
op_eq
id|REGS_REALLOCATE
)paren
(brace
multiline_comment|/* Yes.  If we need more elements than were already&n;&t; allocated, reallocate them.  If we need fewer, just&n;&t; leave it alone.  */
r_if
c_cond
(paren
id|BE
(paren
id|need_regs
OG
id|regs-&gt;num_regs
comma
l_int|0
)paren
)paren
(brace
id|regoff_t
op_star
id|new_start
op_assign
id|re_realloc
(paren
id|regs-&gt;start
comma
id|regoff_t
comma
id|need_regs
)paren
suffix:semicolon
id|regoff_t
op_star
id|new_end
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|new_start
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
id|REGS_UNALLOCATED
suffix:semicolon
id|new_end
op_assign
id|re_realloc
(paren
id|regs-&gt;end
comma
id|regoff_t
comma
id|need_regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|new_end
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
(brace
id|re_free
(paren
id|new_start
)paren
suffix:semicolon
r_return
id|REGS_UNALLOCATED
suffix:semicolon
)brace
id|regs-&gt;start
op_assign
id|new_start
suffix:semicolon
id|regs-&gt;end
op_assign
id|new_end
suffix:semicolon
id|regs-&gt;num_regs
op_assign
id|need_regs
suffix:semicolon
)brace
)brace
r_else
(brace
m_assert
(paren
id|regs_allocated
op_eq
id|REGS_FIXED
)paren
suffix:semicolon
multiline_comment|/* This function may not be called with REGS_FIXED and nregs too big.  */
m_assert
(paren
id|regs-&gt;num_regs
op_ge
id|nregs
)paren
suffix:semicolon
id|rval
op_assign
id|REGS_FIXED
suffix:semicolon
)brace
multiline_comment|/* Copy the regs.  */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nregs
suffix:semicolon
op_increment
id|i
)paren
(brace
id|regs-&gt;start
(braket
id|i
)braket
op_assign
id|pmatch
(braket
id|i
)braket
dot
id|rm_so
suffix:semicolon
id|regs-&gt;end
(braket
id|i
)braket
op_assign
id|pmatch
(braket
id|i
)braket
dot
id|rm_eo
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
id|regs-&gt;num_regs
suffix:semicolon
op_increment
id|i
)paren
id|regs-&gt;start
(braket
id|i
)braket
op_assign
id|regs-&gt;end
(braket
id|i
)braket
op_assign
l_int|1
suffix:semicolon
r_return
id|rval
suffix:semicolon
)brace
multiline_comment|/* Set REGS to hold NUM_REGS registers, storing them in STARTS and&n;   ENDS.  Subsequent matches using PATTERN_BUFFER and REGS will use&n;   this memory for recording register information.  STARTS and ENDS&n;   must be allocated using the malloc library routine, and must each&n;   be at least NUM_REGS * sizeof (regoff_t) bytes long.&n;&n;   If NUM_REGS == 0, then subsequent matches should allocate their own&n;   register data.&n;&n;   Unless this function is called, the first search or match using&n;   PATTERN_BUFFER will allocate its own register data, without&n;   freeing the old data.  */
r_void
DECL|function|re_set_registers
id|re_set_registers
(paren
r_struct
id|re_pattern_buffer
op_star
id|bufp
comma
r_struct
id|re_registers
op_star
id|regs
comma
r_int
id|num_regs
comma
id|regoff_t
op_star
id|starts
comma
id|regoff_t
op_star
id|ends
)paren
(brace
r_if
c_cond
(paren
id|num_regs
)paren
(brace
id|bufp-&gt;regs_allocated
op_assign
id|REGS_REALLOCATE
suffix:semicolon
id|regs-&gt;num_regs
op_assign
id|num_regs
suffix:semicolon
id|regs-&gt;start
op_assign
id|starts
suffix:semicolon
id|regs-&gt;end
op_assign
id|ends
suffix:semicolon
)brace
r_else
(brace
id|bufp-&gt;regs_allocated
op_assign
id|REGS_UNALLOCATED
suffix:semicolon
id|regs-&gt;num_regs
op_assign
l_int|0
suffix:semicolon
id|regs-&gt;start
op_assign
id|regs-&gt;end
op_assign
(paren
id|regoff_t
op_star
)paren
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#ifdef _LIBC
DECL|function|weak_alias
id|weak_alias
(paren
id|__re_set_registers
comma
id|re_set_registers
)paren
macro_line|#endif
"&f;"
multiline_comment|/* Entry points compatible with 4.2 BSD regex library.  We don&squot;t define&n;   them unless specifically requested.  */
macro_line|#if defined _REGEX_RE_COMP || defined _LIBC
r_int
macro_line|# ifdef _LIBC
id|weak_function
macro_line|# endif
id|re_exec
(paren
id|s
)paren
r_const
r_char
op_star
id|s
suffix:semicolon
(brace
r_return
l_int|0
op_eq
id|regexec
(paren
op_amp
id|re_comp_buf
comma
id|s
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif /* _REGEX_RE_COMP */
"&f;"
multiline_comment|/* Internal entry point.  */
multiline_comment|/* Searches for a compiled pattern PREG in the string STRING, whose&n;   length is LENGTH.  NMATCH, PMATCH, and EFLAGS have the same&n;   mingings with regexec.  START, and RANGE have the same meanings&n;   with re_search.&n;   Return REG_NOERROR if we find a match, and REG_NOMATCH if not,&n;   otherwise return the error code.&n;   Note: We assume front end functions already check ranges.&n;   (START + RANGE &gt;= 0 &amp;&amp; START + RANGE &lt;= LENGTH)  */
r_static
id|reg_errcode_t
DECL|function|re_search_internal
id|re_search_internal
(paren
r_const
id|regex_t
op_star
id|preg
comma
r_const
r_char
op_star
id|string
comma
r_int
id|length
comma
r_int
id|start
comma
r_int
id|range
comma
r_int
id|stop
comma
r_int
id|nmatch
comma
id|regmatch_t
id|pmatch
(braket
)braket
comma
r_int
id|eflags
)paren
(brace
id|reg_errcode_t
id|err
suffix:semicolon
r_const
id|re_dfa_t
op_star
id|dfa
op_assign
(paren
r_const
id|re_dfa_t
op_star
)paren
id|preg-&gt;buffer
suffix:semicolon
r_int
id|left_lim
comma
id|right_lim
comma
id|incr
suffix:semicolon
r_int
id|fl_longest_match
comma
id|match_first
comma
id|match_kind
comma
id|match_last
op_assign
l_int|1
suffix:semicolon
r_int
id|extra_nmatch
suffix:semicolon
r_int
id|sb
comma
id|ch
suffix:semicolon
macro_line|#if defined _LIBC || (defined __STDC_VERSION__ &amp;&amp; __STDC_VERSION__ &gt;= 199901L)
id|re_match_context_t
id|mctx
op_assign
(brace
dot
id|dfa
op_assign
id|dfa
)brace
suffix:semicolon
macro_line|#else
id|re_match_context_t
id|mctx
suffix:semicolon
macro_line|#endif
r_char
op_star
id|fastmap
op_assign
(paren
id|preg-&gt;fastmap
op_ne
l_int|NULL
op_logical_and
id|preg-&gt;fastmap_accurate
op_logical_and
id|range
op_logical_and
op_logical_neg
id|preg-&gt;can_be_null
)paren
ques
c_cond
id|preg-&gt;fastmap
suffix:colon
l_int|NULL
suffix:semicolon
id|RE_TRANSLATE_TYPE
id|t
op_assign
id|preg-&gt;translate
suffix:semicolon
macro_line|#if !(defined _LIBC || (defined __STDC_VERSION__ &amp;&amp; __STDC_VERSION__ &gt;= 199901L))
id|memset
(paren
op_amp
id|mctx
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|re_match_context_t
)paren
)paren
suffix:semicolon
id|mctx.dfa
op_assign
id|dfa
suffix:semicolon
macro_line|#endif
id|extra_nmatch
op_assign
(paren
id|nmatch
OG
id|preg-&gt;re_nsub
)paren
ques
c_cond
id|nmatch
(paren
id|preg-&gt;re_nsub
op_plus
l_int|1
)paren
suffix:colon
l_int|0
suffix:semicolon
id|nmatch
op_sub_assign
id|extra_nmatch
suffix:semicolon
multiline_comment|/* Check if the DFA haven&squot;t been compiled.  */
r_if
c_cond
(paren
id|BE
(paren
id|preg-&gt;used
op_eq
l_int|0
op_logical_or
id|dfa-&gt;init_state
op_eq
l_int|NULL
op_logical_or
id|dfa-&gt;init_state_word
op_eq
l_int|NULL
op_logical_or
id|dfa-&gt;init_state_nl
op_eq
l_int|NULL
op_logical_or
id|dfa-&gt;init_state_begbuf
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
id|REG_NOMATCH
suffix:semicolon
macro_line|#ifdef DEBUG
multiline_comment|/* We assume front-end functions already check them.  */
m_assert
(paren
id|start
op_plus
id|range
op_ge
l_int|0
op_logical_and
id|start
op_plus
id|range
op_le
id|length
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* If initial states with non-begbuf contexts have no elements,&n;     the regex must be anchored.  If preg-&gt;newline_anchor is set,&n;     we&squot;ll never use init_state_nl, so do not check it.  */
r_if
c_cond
(paren
id|dfa-&gt;init_state-&gt;nodes.nelem
op_eq
l_int|0
op_logical_and
id|dfa-&gt;init_state_word-&gt;nodes.nelem
op_eq
l_int|0
op_logical_and
(paren
id|dfa-&gt;init_state_nl-&gt;nodes.nelem
op_eq
l_int|0
op_logical_or
op_logical_neg
id|preg-&gt;newline_anchor
)paren
)paren
(brace
r_if
c_cond
(paren
id|start
op_ne
l_int|0
op_logical_and
id|start
op_plus
id|range
op_ne
l_int|0
)paren
r_return
id|REG_NOMATCH
suffix:semicolon
id|start
op_assign
id|range
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* We must check the longest matching, if nmatch &gt; 0.  */
id|fl_longest_match
op_assign
(paren
id|nmatch
op_ne
l_int|0
op_logical_or
id|dfa-&gt;nbackref
)paren
suffix:semicolon
id|err
op_assign
id|re_string_allocate
(paren
op_amp
id|mctx.input
comma
id|string
comma
id|length
comma
id|dfa-&gt;nodes_len
op_plus
l_int|1
comma
id|preg-&gt;translate
comma
id|preg-&gt;syntax
op_amp
id|RE_ICASE
comma
id|dfa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_goto
id|free_return
suffix:semicolon
id|mctx.input.stop
op_assign
id|stop
suffix:semicolon
id|mctx.input.raw_stop
op_assign
id|stop
suffix:semicolon
id|mctx.input.newline_anchor
op_assign
id|preg-&gt;newline_anchor
suffix:semicolon
id|err
op_assign
id|match_ctx_init
(paren
op_amp
id|mctx
comma
id|eflags
comma
id|dfa-&gt;nbackref
op_star
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_goto
id|free_return
suffix:semicolon
multiline_comment|/* We will log all the DFA states through which the dfa pass,&n;     if nmatch &gt; 1, or this dfa has &quot;multibyte node&quot;, which is a&n;     back-reference or a node which can accept multibyte character or&n;     multi character collating element.  */
r_if
c_cond
(paren
id|nmatch
OG
l_int|1
op_logical_or
id|dfa-&gt;has_mb_node
)paren
(brace
multiline_comment|/* Avoid overflow.  */
r_if
c_cond
(paren
id|BE
(paren
id|SIZE_MAX
op_div
r_sizeof
(paren
id|re_dfastate_t
op_star
)paren
op_le
id|mctx.input.bufs_len
comma
l_int|0
)paren
)paren
(brace
id|err
op_assign
id|REG_ESPACE
suffix:semicolon
r_goto
id|free_return
suffix:semicolon
)brace
id|mctx.state_log
op_assign
id|re_malloc
(paren
id|re_dfastate_t
op_star
comma
id|mctx.input.bufs_len
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|mctx.state_log
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
(brace
id|err
op_assign
id|REG_ESPACE
suffix:semicolon
r_goto
id|free_return
suffix:semicolon
)brace
)brace
r_else
id|mctx.state_log
op_assign
l_int|NULL
suffix:semicolon
id|match_first
op_assign
id|start
suffix:semicolon
id|mctx.input.tip_context
op_assign
(paren
id|eflags
op_amp
id|REG_NOTBOL
)paren
ques
c_cond
id|CONTEXT_BEGBUF
suffix:colon
id|CONTEXT_NEWLINE
op_or
id|CONTEXT_BEGBUF
suffix:semicolon
multiline_comment|/* Check incrementally whether of not the input string match.  */
id|incr
op_assign
(paren
id|range
OL
l_int|0
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|1
suffix:semicolon
id|left_lim
op_assign
(paren
id|range
OL
l_int|0
)paren
ques
c_cond
id|start
op_plus
id|range
suffix:colon
id|start
suffix:semicolon
id|right_lim
op_assign
(paren
id|range
OL
l_int|0
)paren
ques
c_cond
id|start
suffix:colon
id|start
op_plus
id|range
suffix:semicolon
id|sb
op_assign
id|dfa-&gt;mb_cur_max
op_eq
l_int|1
suffix:semicolon
id|match_kind
op_assign
(paren
id|fastmap
ques
c_cond
(paren
(paren
id|sb
op_logical_or
op_logical_neg
(paren
id|preg-&gt;syntax
op_amp
id|RE_ICASE
op_logical_or
id|t
)paren
ques
c_cond
l_int|4
suffix:colon
l_int|0
)paren
op_or
(paren
id|range
op_ge
l_int|0
ques
c_cond
l_int|2
suffix:colon
l_int|0
)paren
op_or
(paren
id|t
op_ne
l_int|NULL
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
)paren
suffix:colon
l_int|8
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
id|match_first
op_add_assign
id|incr
)paren
(brace
id|err
op_assign
id|REG_NOMATCH
suffix:semicolon
r_if
c_cond
(paren
id|match_first
OL
id|left_lim
op_logical_or
id|right_lim
OL
id|match_first
)paren
r_goto
id|free_return
suffix:semicolon
multiline_comment|/* Advance as rapidly as possible through the string, until we&n;&t; find a plausible place to start matching.  This may be done&n;&t; with varying efficiency, so there are various possibilities:&n;&t; only the most common of them are specialized, in order to&n;&t; save on code size.  We use a switch statement for speed.  */
r_switch
c_cond
(paren
id|match_kind
)paren
(brace
r_case
l_int|8
suffix:colon
multiline_comment|/* No fastmap.  */
r_break
suffix:semicolon
r_case
l_int|7
suffix:colon
multiline_comment|/* Fastmap with single-byte translation, match forward.  */
r_while
c_loop
(paren
id|BE
(paren
id|match_first
OL
id|right_lim
comma
l_int|1
)paren
op_logical_and
op_logical_neg
id|fastmap
(braket
id|t
(braket
(paren
r_int
r_char
)paren
id|string
(braket
id|match_first
)braket
)braket
)braket
)paren
op_increment
id|match_first
suffix:semicolon
r_goto
id|forward_match_found_start_or_reached_end
suffix:semicolon
r_case
l_int|6
suffix:colon
multiline_comment|/* Fastmap without translation, match forward.  */
r_while
c_loop
(paren
id|BE
(paren
id|match_first
OL
id|right_lim
comma
l_int|1
)paren
op_logical_and
op_logical_neg
id|fastmap
(braket
(paren
r_int
r_char
)paren
id|string
(braket
id|match_first
)braket
)braket
)paren
op_increment
id|match_first
suffix:semicolon
id|forward_match_found_start_or_reached_end
suffix:colon
r_if
c_cond
(paren
id|BE
(paren
id|match_first
op_eq
id|right_lim
comma
l_int|0
)paren
)paren
(brace
id|ch
op_assign
id|match_first
op_ge
id|length
ques
c_cond
l_int|0
suffix:colon
(paren
r_int
r_char
)paren
id|string
(braket
id|match_first
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fastmap
(braket
id|t
ques
c_cond
id|t
(braket
id|ch
)braket
suffix:colon
id|ch
)braket
)paren
r_goto
id|free_return
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
r_case
l_int|5
suffix:colon
multiline_comment|/* Fastmap without multi-byte translation, match backwards.  */
r_while
c_loop
(paren
id|match_first
op_ge
id|left_lim
)paren
(brace
id|ch
op_assign
id|match_first
op_ge
id|length
ques
c_cond
l_int|0
suffix:colon
(paren
r_int
r_char
)paren
id|string
(braket
id|match_first
)braket
suffix:semicolon
r_if
c_cond
(paren
id|fastmap
(braket
id|t
ques
c_cond
id|t
(braket
id|ch
)braket
suffix:colon
id|ch
)braket
)paren
r_break
suffix:semicolon
op_decrement
id|match_first
suffix:semicolon
)brace
r_if
c_cond
(paren
id|match_first
OL
id|left_lim
)paren
r_goto
id|free_return
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
multiline_comment|/* In this case, we can&squot;t determine easily the current byte,&n;&t;     since it might be a component byte of a multibyte&n;&t;     character.  Then we use the constructed buffer instead.  */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* If MATCH_FIRST is out of the valid range, reconstruct the&n;&t;&t; buffers.  */
r_int
r_int
id|offset
op_assign
id|match_first
id|mctx.input.raw_mbs_idx
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|offset
op_ge
(paren
r_int
r_int
)paren
id|mctx.input.valid_raw_len
comma
l_int|0
)paren
)paren
(brace
id|err
op_assign
id|re_string_reconstruct
(paren
op_amp
id|mctx.input
comma
id|match_first
comma
id|eflags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_goto
id|free_return
suffix:semicolon
id|offset
op_assign
id|match_first
id|mctx.input.raw_mbs_idx
suffix:semicolon
)brace
multiline_comment|/* If MATCH_FIRST is out of the buffer, leave it as &squot;&bslash;0&squot;.&n;&t;&t; Note that MATCH_FIRST must not be smaller than 0.  */
id|ch
op_assign
(paren
id|match_first
op_ge
id|length
ques
c_cond
l_int|0
suffix:colon
id|re_string_byte_at
(paren
op_amp
id|mctx.input
comma
id|offset
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fastmap
(braket
id|ch
)braket
)paren
r_break
suffix:semicolon
id|match_first
op_add_assign
id|incr
suffix:semicolon
r_if
c_cond
(paren
id|match_first
template_param
id|right_lim
)paren
(brace
id|err
op_assign
id|REG_NOMATCH
suffix:semicolon
r_goto
id|free_return
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/* Reconstruct the buffers so that the matcher can assume that&n;&t; the matching starts from the beginning of the buffer.  */
id|err
op_assign
id|re_string_reconstruct
(paren
op_amp
id|mctx.input
comma
id|match_first
comma
id|eflags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_goto
id|free_return
suffix:semicolon
macro_line|#ifdef RE_ENABLE_I18N
multiline_comment|/* Don&squot;t consider this char as a possible match start if it part,&n;&t;yet isn&squot;t the head, of a multibyte character.  */
r_if
c_cond
(paren
op_logical_neg
id|sb
op_logical_and
op_logical_neg
id|re_string_first_byte
(paren
op_amp
id|mctx.input
comma
l_int|0
)paren
)paren
r_continue
suffix:semicolon
macro_line|#endif
multiline_comment|/* It seems to be appropriate one, then use the matcher.  */
multiline_comment|/* We assume that the matching starts from 0.  */
id|mctx.state_log_top
op_assign
id|mctx.nbkref_ents
op_assign
id|mctx.max_mb_elem_len
op_assign
l_int|0
suffix:semicolon
id|match_last
op_assign
id|check_matching
(paren
op_amp
id|mctx
comma
id|fl_longest_match
comma
id|range
op_ge
l_int|0
ques
c_cond
op_amp
id|match_first
suffix:colon
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|match_last
op_ne
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|BE
(paren
id|match_last
op_eq
l_int|2
comma
l_int|0
)paren
)paren
(brace
id|err
op_assign
id|REG_ESPACE
suffix:semicolon
r_goto
id|free_return
suffix:semicolon
)brace
r_else
(brace
id|mctx.match_last
op_assign
id|match_last
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|preg-&gt;no_sub
op_logical_and
id|nmatch
OG
l_int|1
)paren
op_logical_or
id|dfa-&gt;nbackref
)paren
(brace
id|re_dfastate_t
op_star
id|pstate
op_assign
id|mctx.state_log
(braket
id|match_last
)braket
suffix:semicolon
id|mctx.last_node
op_assign
id|check_halt_state_context
(paren
op_amp
id|mctx
comma
id|pstate
comma
id|match_last
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
op_logical_neg
id|preg-&gt;no_sub
op_logical_and
id|nmatch
OG
l_int|1
op_logical_and
id|dfa-&gt;has_plural_match
)paren
op_logical_or
id|dfa-&gt;nbackref
)paren
(brace
id|err
op_assign
id|prune_impossible_nodes
(paren
op_amp
id|mctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
id|REG_NOERROR
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOMATCH
comma
l_int|0
)paren
)paren
r_goto
id|free_return
suffix:semicolon
id|match_last
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
multiline_comment|/* We found a match.  */
)brace
)brace
id|match_ctx_clean
(paren
op_amp
id|mctx
)paren
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
m_assert
(paren
id|match_last
op_ne
l_int|1
)paren
suffix:semicolon
m_assert
(paren
id|err
op_eq
id|REG_NOERROR
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Set pmatch[] if we need.  */
r_if
c_cond
(paren
id|nmatch
OG
l_int|0
)paren
(brace
r_int
id|reg_idx
suffix:semicolon
multiline_comment|/* Initialize registers.  */
r_for
c_loop
(paren
id|reg_idx
op_assign
l_int|1
suffix:semicolon
id|reg_idx
OL
id|nmatch
suffix:semicolon
op_increment
id|reg_idx
)paren
id|pmatch
(braket
id|reg_idx
)braket
dot
id|rm_so
op_assign
id|pmatch
(braket
id|reg_idx
)braket
dot
id|rm_eo
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Set the points where matching start/end.  */
id|pmatch
(braket
l_int|0
)braket
dot
id|rm_so
op_assign
l_int|0
suffix:semicolon
id|pmatch
(braket
l_int|0
)braket
dot
id|rm_eo
op_assign
id|mctx.match_last
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|preg-&gt;no_sub
op_logical_and
id|nmatch
OG
l_int|1
)paren
(brace
id|err
op_assign
id|set_regs
(paren
id|preg
comma
op_amp
id|mctx
comma
id|nmatch
comma
id|pmatch
comma
id|dfa-&gt;has_plural_match
op_logical_and
id|dfa-&gt;nbackref
OG
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_goto
id|free_return
suffix:semicolon
)brace
multiline_comment|/* At last, add the offset to the each registers, since we slided&n;&t; the buffers so that we could assume that the matching starts&n;&t; from 0.  */
r_for
c_loop
(paren
id|reg_idx
op_assign
l_int|0
suffix:semicolon
id|reg_idx
OL
id|nmatch
suffix:semicolon
op_increment
id|reg_idx
)paren
r_if
c_cond
(paren
id|pmatch
(braket
id|reg_idx
)braket
dot
id|rm_so
op_ne
l_int|1
)paren
(brace
macro_line|#ifdef RE_ENABLE_I18N
r_if
c_cond
(paren
id|BE
(paren
id|mctx.input.offsets_needed
op_ne
l_int|0
comma
l_int|0
)paren
)paren
(brace
id|pmatch
(braket
id|reg_idx
)braket
dot
id|rm_so
op_assign
(paren
id|pmatch
(braket
id|reg_idx
)braket
dot
id|rm_so
op_eq
id|mctx.input.valid_len
ques
c_cond
id|mctx.input.valid_raw_len
suffix:colon
id|mctx.input.offsets
(braket
id|pmatch
(braket
id|reg_idx
)braket
dot
id|rm_so
)braket
)paren
suffix:semicolon
id|pmatch
(braket
id|reg_idx
)braket
dot
id|rm_eo
op_assign
(paren
id|pmatch
(braket
id|reg_idx
)braket
dot
id|rm_eo
op_eq
id|mctx.input.valid_len
ques
c_cond
id|mctx.input.valid_raw_len
suffix:colon
id|mctx.input.offsets
(braket
id|pmatch
(braket
id|reg_idx
)braket
dot
id|rm_eo
)braket
)paren
suffix:semicolon
)brace
macro_line|#else
m_assert
(paren
id|mctx.input.offsets_needed
op_eq
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|pmatch
(braket
id|reg_idx
)braket
dot
id|rm_so
op_add_assign
id|match_first
suffix:semicolon
id|pmatch
(braket
id|reg_idx
)braket
dot
id|rm_eo
op_add_assign
id|match_first
suffix:semicolon
)brace
r_for
c_loop
(paren
id|reg_idx
op_assign
l_int|0
suffix:semicolon
id|reg_idx
OL
id|extra_nmatch
suffix:semicolon
op_increment
id|reg_idx
)paren
(brace
id|pmatch
(braket
id|nmatch
op_plus
id|reg_idx
)braket
dot
id|rm_so
op_assign
l_int|1
suffix:semicolon
id|pmatch
(braket
id|nmatch
op_plus
id|reg_idx
)braket
dot
id|rm_eo
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dfa-&gt;subexp_map
)paren
r_for
c_loop
(paren
id|reg_idx
op_assign
l_int|0
suffix:semicolon
id|reg_idx
op_plus
l_int|1
OL
id|nmatch
suffix:semicolon
id|reg_idx
op_increment
)paren
r_if
c_cond
(paren
id|dfa-&gt;subexp_map
(braket
id|reg_idx
)braket
op_ne
id|reg_idx
)paren
(brace
id|pmatch
(braket
id|reg_idx
op_plus
l_int|1
)braket
dot
id|rm_so
op_assign
id|pmatch
(braket
id|dfa-&gt;subexp_map
(braket
id|reg_idx
)braket
op_plus
l_int|1
)braket
dot
id|rm_so
suffix:semicolon
id|pmatch
(braket
id|reg_idx
op_plus
l_int|1
)braket
dot
id|rm_eo
op_assign
id|pmatch
(braket
id|dfa-&gt;subexp_map
(braket
id|reg_idx
)braket
op_plus
l_int|1
)braket
dot
id|rm_eo
suffix:semicolon
)brace
)brace
id|free_return
suffix:colon
id|re_free
(paren
id|mctx.state_log
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dfa-&gt;nbackref
)paren
id|match_ctx_free
(paren
op_amp
id|mctx
)paren
suffix:semicolon
id|re_string_destruct
(paren
op_amp
id|mctx.input
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
r_static
id|reg_errcode_t
DECL|function|prune_impossible_nodes
id|prune_impossible_nodes
(paren
id|re_match_context_t
op_star
id|mctx
)paren
(brace
r_const
id|re_dfa_t
op_star
r_const
id|dfa
op_assign
id|mctx-&gt;dfa
suffix:semicolon
r_int
id|halt_node
comma
id|match_last
suffix:semicolon
id|reg_errcode_t
id|ret
suffix:semicolon
id|re_dfastate_t
op_star
op_star
id|sifted_states
suffix:semicolon
id|re_dfastate_t
op_star
op_star
id|lim_states
op_assign
l_int|NULL
suffix:semicolon
id|re_sift_context_t
id|sctx
suffix:semicolon
macro_line|#ifdef DEBUG
m_assert
(paren
id|mctx-&gt;state_log
op_ne
l_int|NULL
)paren
suffix:semicolon
macro_line|#endif
id|match_last
op_assign
id|mctx-&gt;match_last
suffix:semicolon
id|halt_node
op_assign
id|mctx-&gt;last_node
suffix:semicolon
multiline_comment|/* Avoid overflow.  */
r_if
c_cond
(paren
id|BE
(paren
id|SIZE_MAX
op_div
r_sizeof
(paren
id|re_dfastate_t
op_star
)paren
op_le
id|match_last
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
id|sifted_states
op_assign
id|re_malloc
(paren
id|re_dfastate_t
op_star
comma
id|match_last
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|sifted_states
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
(brace
id|ret
op_assign
id|REG_ESPACE
suffix:semicolon
r_goto
id|free_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dfa-&gt;nbackref
)paren
(brace
id|lim_states
op_assign
id|re_malloc
(paren
id|re_dfastate_t
op_star
comma
id|match_last
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|lim_states
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
(brace
id|ret
op_assign
id|REG_ESPACE
suffix:semicolon
r_goto
id|free_return
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|memset
(paren
id|lim_states
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|re_dfastate_t
op_star
)paren
op_star
(paren
id|match_last
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|sift_ctx_init
(paren
op_amp
id|sctx
comma
id|sifted_states
comma
id|lim_states
comma
id|halt_node
comma
id|match_last
)paren
suffix:semicolon
id|ret
op_assign
id|sift_states_backward
(paren
id|mctx
comma
op_amp
id|sctx
)paren
suffix:semicolon
id|re_node_set_free
(paren
op_amp
id|sctx.limits
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|ret
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_goto
id|free_return
suffix:semicolon
r_if
c_cond
(paren
id|sifted_states
(braket
l_int|0
)braket
op_ne
l_int|NULL
op_logical_or
id|lim_states
(braket
l_int|0
)braket
op_ne
l_int|NULL
)paren
r_break
suffix:semicolon
r_do
(brace
op_decrement
id|match_last
suffix:semicolon
r_if
c_cond
(paren
id|match_last
OL
l_int|0
)paren
(brace
id|ret
op_assign
id|REG_NOMATCH
suffix:semicolon
r_goto
id|free_return
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|mctx-&gt;state_log
(braket
id|match_last
)braket
op_eq
l_int|NULL
op_logical_or
op_logical_neg
id|mctx-&gt;state_log
(braket
id|match_last
)braket
op_member_access_from_pointer
id|halt
)paren
suffix:semicolon
id|halt_node
op_assign
id|check_halt_state_context
(paren
id|mctx
comma
id|mctx-&gt;state_log
(braket
id|match_last
)braket
comma
id|match_last
)paren
suffix:semicolon
)brace
id|ret
op_assign
id|merge_state_array
(paren
id|dfa
comma
id|sifted_states
comma
id|lim_states
comma
id|match_last
op_plus
l_int|1
)paren
suffix:semicolon
id|re_free
(paren
id|lim_states
)paren
suffix:semicolon
id|lim_states
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|ret
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_goto
id|free_return
suffix:semicolon
)brace
r_else
(brace
id|sift_ctx_init
(paren
op_amp
id|sctx
comma
id|sifted_states
comma
id|lim_states
comma
id|halt_node
comma
id|match_last
)paren
suffix:semicolon
id|ret
op_assign
id|sift_states_backward
(paren
id|mctx
comma
op_amp
id|sctx
)paren
suffix:semicolon
id|re_node_set_free
(paren
op_amp
id|sctx.limits
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|ret
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_goto
id|free_return
suffix:semicolon
r_if
c_cond
(paren
id|sifted_states
(braket
l_int|0
)braket
op_eq
l_int|NULL
)paren
(brace
id|ret
op_assign
id|REG_NOMATCH
suffix:semicolon
r_goto
id|free_return
suffix:semicolon
)brace
)brace
id|re_free
(paren
id|mctx-&gt;state_log
)paren
suffix:semicolon
id|mctx-&gt;state_log
op_assign
id|sifted_states
suffix:semicolon
id|sifted_states
op_assign
l_int|NULL
suffix:semicolon
id|mctx-&gt;last_node
op_assign
id|halt_node
suffix:semicolon
id|mctx-&gt;match_last
op_assign
id|match_last
suffix:semicolon
id|ret
op_assign
id|REG_NOERROR
suffix:semicolon
id|free_return
suffix:colon
id|re_free
(paren
id|sifted_states
)paren
suffix:semicolon
id|re_free
(paren
id|lim_states
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Acquire an initial state and return it.&n;   We must select appropriate initial state depending on the context,&n;   since initial states may have constraints like &quot;&bslash;&lt;&quot;, &quot;^&quot;, etc..  */
r_static
r_inline
id|re_dfastate_t
op_star
id|__attribute
(paren
(paren
id|always_inline
)paren
)paren
id|internal_function
DECL|function|acquire_init_state_context
id|acquire_init_state_context
(paren
id|reg_errcode_t
op_star
id|err
comma
r_const
id|re_match_context_t
op_star
id|mctx
comma
r_int
id|idx
)paren
(brace
r_const
id|re_dfa_t
op_star
r_const
id|dfa
op_assign
id|mctx-&gt;dfa
suffix:semicolon
r_if
c_cond
(paren
id|dfa-&gt;init_state-&gt;has_constraint
)paren
(brace
r_int
r_int
id|context
suffix:semicolon
id|context
op_assign
id|re_string_context_at
(paren
op_amp
id|mctx-&gt;input
comma
id|idx
l_int|1
comma
id|mctx-&gt;eflags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_WORD_CONTEXT
(paren
id|context
)paren
)paren
r_return
id|dfa-&gt;init_state_word
suffix:semicolon
r_else
r_if
c_cond
(paren
id|IS_ORDINARY_CONTEXT
(paren
id|context
)paren
)paren
r_return
id|dfa-&gt;init_state
suffix:semicolon
r_else
r_if
c_cond
(paren
id|IS_BEGBUF_CONTEXT
(paren
id|context
)paren
op_logical_and
id|IS_NEWLINE_CONTEXT
(paren
id|context
)paren
)paren
r_return
id|dfa-&gt;init_state_begbuf
suffix:semicolon
r_else
r_if
c_cond
(paren
id|IS_NEWLINE_CONTEXT
(paren
id|context
)paren
)paren
r_return
id|dfa-&gt;init_state_nl
suffix:semicolon
r_else
r_if
c_cond
(paren
id|IS_BEGBUF_CONTEXT
(paren
id|context
)paren
)paren
(brace
multiline_comment|/* It is relatively rare case, then calculate on demand.  */
r_return
id|re_acquire_state_context
(paren
id|err
comma
id|dfa
comma
id|dfa-&gt;init_state-&gt;entrance_nodes
comma
id|context
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* Must not happen?  */
r_return
id|dfa-&gt;init_state
suffix:semicolon
)brace
r_else
r_return
id|dfa-&gt;init_state
suffix:semicolon
)brace
multiline_comment|/* Check whether the regular expression match input string INPUT or not,&n;   and return the index where the matching end, return -1 if not match,&n;   or return -2 in case of an error.&n;   FL_LONGEST_MATCH means we want the POSIX longest matching.&n;   If P_MATCH_FIRST is not NULL, and the match fails, it is set to the&n;   next place where we may want to try matching.&n;   Note that the matcher assume that the maching starts from the current&n;   index of the buffer.  */
r_static
r_int
id|internal_function
DECL|function|check_matching
id|check_matching
(paren
id|re_match_context_t
op_star
id|mctx
comma
r_int
id|fl_longest_match
comma
r_int
op_star
id|p_match_first
)paren
(brace
r_const
id|re_dfa_t
op_star
r_const
id|dfa
op_assign
id|mctx-&gt;dfa
suffix:semicolon
id|reg_errcode_t
id|err
suffix:semicolon
r_int
id|match
op_assign
l_int|0
suffix:semicolon
r_int
id|match_last
op_assign
l_int|1
suffix:semicolon
r_int
id|cur_str_idx
op_assign
id|re_string_cur_idx
(paren
op_amp
id|mctx-&gt;input
)paren
suffix:semicolon
id|re_dfastate_t
op_star
id|cur_state
suffix:semicolon
r_int
id|at_init_state
op_assign
id|p_match_first
op_ne
l_int|NULL
suffix:semicolon
r_int
id|next_start_idx
op_assign
id|cur_str_idx
suffix:semicolon
id|err
op_assign
id|REG_NOERROR
suffix:semicolon
id|cur_state
op_assign
id|acquire_init_state_context
(paren
op_amp
id|err
comma
id|mctx
comma
id|cur_str_idx
)paren
suffix:semicolon
multiline_comment|/* An initial state must not be NULL (invalid).  */
r_if
c_cond
(paren
id|BE
(paren
id|cur_state
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
(brace
m_assert
(paren
id|err
op_eq
id|REG_ESPACE
)paren
suffix:semicolon
r_return
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mctx-&gt;state_log
op_ne
l_int|NULL
)paren
(brace
id|mctx-&gt;state_log
(braket
id|cur_str_idx
)braket
op_assign
id|cur_state
suffix:semicolon
multiline_comment|/* Check OP_OPEN_SUBEXP in the initial state in case that we use them&n;&t; later.  E.g. Processing back references.  */
r_if
c_cond
(paren
id|BE
(paren
id|dfa-&gt;nbackref
comma
l_int|0
)paren
)paren
(brace
id|at_init_state
op_assign
l_int|0
suffix:semicolon
id|err
op_assign
id|check_subexp_matching_top
(paren
id|mctx
comma
op_amp
id|cur_state-&gt;nodes
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
id|cur_state-&gt;has_backref
)paren
(brace
id|err
op_assign
id|transit_state_bkref
(paren
id|mctx
comma
op_amp
id|cur_state-&gt;nodes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|err
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* If the RE accepts NULL string.  */
r_if
c_cond
(paren
id|BE
(paren
id|cur_state-&gt;halt
comma
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cur_state-&gt;has_constraint
op_logical_or
id|check_halt_state_context
(paren
id|mctx
comma
id|cur_state
comma
id|cur_str_idx
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|fl_longest_match
)paren
r_return
id|cur_str_idx
suffix:semicolon
r_else
(brace
id|match_last
op_assign
id|cur_str_idx
suffix:semicolon
id|match
op_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
op_logical_neg
id|re_string_eoi
(paren
op_amp
id|mctx-&gt;input
)paren
)paren
(brace
id|re_dfastate_t
op_star
id|old_state
op_assign
id|cur_state
suffix:semicolon
r_int
id|next_char_idx
op_assign
id|re_string_cur_idx
(paren
op_amp
id|mctx-&gt;input
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|next_char_idx
op_ge
id|mctx-&gt;input.bufs_len
comma
l_int|0
)paren
op_logical_or
(paren
id|BE
(paren
id|next_char_idx
op_ge
id|mctx-&gt;input.valid_len
comma
l_int|0
)paren
op_logical_and
id|mctx-&gt;input.valid_len
OL
id|mctx-&gt;input.len
)paren
)paren
(brace
id|err
op_assign
id|extend_buffers
(paren
id|mctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
(brace
m_assert
(paren
id|err
op_eq
id|REG_ESPACE
)paren
suffix:semicolon
r_return
l_int|2
suffix:semicolon
)brace
)brace
id|cur_state
op_assign
id|transit_state
(paren
op_amp
id|err
comma
id|mctx
comma
id|cur_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mctx-&gt;state_log
op_ne
l_int|NULL
)paren
id|cur_state
op_assign
id|merge_state_with_log
(paren
op_amp
id|err
comma
id|mctx
comma
id|cur_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur_state
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* Reached the invalid state or an error.  Try to recover a valid&n;&t;     state using the state log, if available and if we have not&n;&t;     already found a valid (even if not the longest) match.  */
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|mctx-&gt;state_log
op_eq
l_int|NULL
op_logical_or
(paren
id|match
op_logical_and
op_logical_neg
id|fl_longest_match
)paren
op_logical_or
(paren
id|cur_state
op_assign
id|find_recover_state
(paren
op_amp
id|err
comma
id|mctx
)paren
)paren
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|BE
(paren
id|at_init_state
comma
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|old_state
op_eq
id|cur_state
)paren
id|next_start_idx
op_assign
id|next_char_idx
suffix:semicolon
r_else
id|at_init_state
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cur_state-&gt;halt
)paren
(brace
multiline_comment|/* Reached a halt state.&n;&t;     Check the halt state can satisfy the current context.  */
r_if
c_cond
(paren
op_logical_neg
id|cur_state-&gt;has_constraint
op_logical_or
id|check_halt_state_context
(paren
id|mctx
comma
id|cur_state
comma
id|re_string_cur_idx
(paren
op_amp
id|mctx-&gt;input
)paren
)paren
)paren
(brace
multiline_comment|/* We found an appropriate halt state.  */
id|match_last
op_assign
id|re_string_cur_idx
(paren
op_amp
id|mctx-&gt;input
)paren
suffix:semicolon
id|match
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* We found a match, do not modify match_first below.  */
id|p_match_first
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fl_longest_match
)paren
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|p_match_first
)paren
op_star
id|p_match_first
op_add_assign
id|next_start_idx
suffix:semicolon
r_return
id|match_last
suffix:semicolon
)brace
multiline_comment|/* Check NODE match the current context.  */
r_static
r_int
id|internal_function
DECL|function|check_halt_node_context
id|check_halt_node_context
(paren
r_const
id|re_dfa_t
op_star
id|dfa
comma
r_int
id|node
comma
r_int
r_int
id|context
)paren
(brace
id|re_token_type_t
id|type
op_assign
id|dfa-&gt;nodes
(braket
id|node
)braket
dot
id|type
suffix:semicolon
r_int
r_int
id|constraint
op_assign
id|dfa-&gt;nodes
(braket
id|node
)braket
dot
id|constraint
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
id|END_OF_RE
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|constraint
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|NOT_SATISFY_NEXT_CONSTRAINT
(paren
id|constraint
comma
id|context
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Check the halt state STATE match the current context.&n;   Return 0 if not match, if the node, STATE has, is a halt node and&n;   match the context, return the node.  */
r_static
r_int
id|internal_function
DECL|function|check_halt_state_context
id|check_halt_state_context
(paren
r_const
id|re_match_context_t
op_star
id|mctx
comma
r_const
id|re_dfastate_t
op_star
id|state
comma
r_int
id|idx
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|context
suffix:semicolon
macro_line|#ifdef DEBUG
m_assert
(paren
id|state-&gt;halt
)paren
suffix:semicolon
macro_line|#endif
id|context
op_assign
id|re_string_context_at
(paren
op_amp
id|mctx-&gt;input
comma
id|idx
comma
id|mctx-&gt;eflags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|state-&gt;nodes.nelem
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
id|check_halt_node_context
(paren
id|mctx-&gt;dfa
comma
id|state-&gt;nodes.elems
(braket
id|i
)braket
comma
id|context
)paren
)paren
r_return
id|state-&gt;nodes.elems
(braket
id|i
)braket
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Compute the next node to which &quot;NFA&quot; transit from NODE(&quot;NFA&quot; is a NFA&n;   corresponding to the DFA).&n;   Return the destination node, and update EPS_VIA_NODES, return -1 in case&n;   of errors.  */
r_static
r_int
id|internal_function
DECL|function|proceed_next_node
id|proceed_next_node
(paren
r_const
id|re_match_context_t
op_star
id|mctx
comma
r_int
id|nregs
comma
id|regmatch_t
op_star
id|regs
comma
r_int
op_star
id|pidx
comma
r_int
id|node
comma
id|re_node_set
op_star
id|eps_via_nodes
comma
r_struct
id|re_fail_stack_t
op_star
id|fs
)paren
(brace
r_const
id|re_dfa_t
op_star
r_const
id|dfa
op_assign
id|mctx-&gt;dfa
suffix:semicolon
r_int
id|i
comma
id|err
suffix:semicolon
r_if
c_cond
(paren
id|IS_EPSILON_NODE
(paren
id|dfa-&gt;nodes
(braket
id|node
)braket
dot
id|type
)paren
)paren
(brace
id|re_node_set
op_star
id|cur_nodes
op_assign
op_amp
id|mctx-&gt;state_log
(braket
op_star
id|pidx
)braket
op_member_access_from_pointer
id|nodes
suffix:semicolon
id|re_node_set
op_star
id|edests
op_assign
op_amp
id|dfa-&gt;edests
(braket
id|node
)braket
suffix:semicolon
r_int
id|dest_node
suffix:semicolon
id|err
op_assign
id|re_node_set_insert
(paren
id|eps_via_nodes
comma
id|node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
OL
l_int|0
comma
l_int|0
)paren
)paren
r_return
l_int|2
suffix:semicolon
multiline_comment|/* Pick up a valid destination, or return -1 if none is found.  */
r_for
c_loop
(paren
id|dest_node
op_assign
l_int|1
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|edests-&gt;nelem
suffix:semicolon
op_increment
id|i
)paren
(brace
r_int
id|candidate
op_assign
id|edests-&gt;elems
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|re_node_set_contains
(paren
id|cur_nodes
comma
id|candidate
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|dest_node
op_eq
l_int|1
)paren
id|dest_node
op_assign
id|candidate
suffix:semicolon
r_else
(brace
multiline_comment|/* In order to avoid infinite loop like &quot;(a*)*&quot;, return the second&n;&t;&t; epsilon-transition if the first was already considered.  */
r_if
c_cond
(paren
id|re_node_set_contains
(paren
id|eps_via_nodes
comma
id|dest_node
)paren
)paren
r_return
id|candidate
suffix:semicolon
multiline_comment|/* Otherwise, push the second epsilon-transition on the fail stack.  */
r_else
r_if
c_cond
(paren
id|fs
op_ne
l_int|NULL
op_logical_and
id|push_fail_stack
(paren
id|fs
comma
op_star
id|pidx
comma
id|candidate
comma
id|nregs
comma
id|regs
comma
id|eps_via_nodes
)paren
)paren
r_return
l_int|2
suffix:semicolon
multiline_comment|/* We know we are going to exit.  */
r_break
suffix:semicolon
)brace
)brace
r_return
id|dest_node
suffix:semicolon
)brace
r_else
(brace
r_int
id|naccepted
op_assign
l_int|0
suffix:semicolon
id|re_token_type_t
id|type
op_assign
id|dfa-&gt;nodes
(braket
id|node
)braket
dot
id|type
suffix:semicolon
macro_line|#ifdef RE_ENABLE_I18N
r_if
c_cond
(paren
id|dfa-&gt;nodes
(braket
id|node
)braket
dot
id|accept_mb
)paren
id|naccepted
op_assign
id|check_node_accept_bytes
(paren
id|dfa
comma
id|node
comma
op_amp
id|mctx-&gt;input
comma
op_star
id|pidx
)paren
suffix:semicolon
r_else
macro_line|#endif /* RE_ENABLE_I18N */
r_if
c_cond
(paren
id|type
op_eq
id|OP_BACK_REF
)paren
(brace
r_int
id|subexp_idx
op_assign
id|dfa-&gt;nodes
(braket
id|node
)braket
dot
id|opr.idx
op_plus
l_int|1
suffix:semicolon
id|naccepted
op_assign
id|regs
(braket
id|subexp_idx
)braket
dot
id|rm_eo
id|regs
(braket
id|subexp_idx
)braket
dot
id|rm_so
suffix:semicolon
r_if
c_cond
(paren
id|fs
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|regs
(braket
id|subexp_idx
)braket
dot
id|rm_so
op_eq
l_int|1
op_logical_or
id|regs
(braket
id|subexp_idx
)braket
dot
id|rm_eo
op_eq
l_int|1
)paren
r_return
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|naccepted
)paren
(brace
r_char
op_star
id|buf
op_assign
(paren
r_char
op_star
)paren
id|re_string_get_buffer
(paren
op_amp
id|mctx-&gt;input
)paren
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
(paren
id|buf
op_plus
id|regs
(braket
id|subexp_idx
)braket
dot
id|rm_so
comma
id|buf
op_plus
op_star
id|pidx
comma
id|naccepted
)paren
op_ne
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|naccepted
op_eq
l_int|0
)paren
(brace
r_int
id|dest_node
suffix:semicolon
id|err
op_assign
id|re_node_set_insert
(paren
id|eps_via_nodes
comma
id|node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
OL
l_int|0
comma
l_int|0
)paren
)paren
r_return
l_int|2
suffix:semicolon
id|dest_node
op_assign
id|dfa-&gt;edests
(braket
id|node
)braket
dot
id|elems
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|re_node_set_contains
(paren
op_amp
id|mctx-&gt;state_log
(braket
op_star
id|pidx
)braket
op_member_access_from_pointer
id|nodes
comma
id|dest_node
)paren
)paren
r_return
id|dest_node
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|naccepted
op_ne
l_int|0
op_logical_or
id|check_node_accept
(paren
id|mctx
comma
id|dfa-&gt;nodes
op_plus
id|node
comma
op_star
id|pidx
)paren
)paren
(brace
r_int
id|dest_node
op_assign
id|dfa-&gt;nexts
(braket
id|node
)braket
suffix:semicolon
op_star
id|pidx
op_assign
(paren
id|naccepted
op_eq
l_int|0
)paren
ques
c_cond
op_star
id|pidx
op_plus
l_int|1
suffix:colon
op_star
id|pidx
op_plus
id|naccepted
suffix:semicolon
r_if
c_cond
(paren
id|fs
op_logical_and
(paren
op_star
id|pidx
OG
id|mctx-&gt;match_last
op_logical_or
id|mctx-&gt;state_log
(braket
op_star
id|pidx
)braket
op_eq
l_int|NULL
op_logical_or
op_logical_neg
id|re_node_set_contains
(paren
op_amp
id|mctx-&gt;state_log
(braket
op_star
id|pidx
)braket
op_member_access_from_pointer
id|nodes
comma
id|dest_node
)paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|re_node_set_empty
(paren
id|eps_via_nodes
)paren
suffix:semicolon
r_return
id|dest_node
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_static
id|reg_errcode_t
id|internal_function
DECL|function|push_fail_stack
id|push_fail_stack
(paren
r_struct
id|re_fail_stack_t
op_star
id|fs
comma
r_int
id|str_idx
comma
r_int
id|dest_node
comma
r_int
id|nregs
comma
id|regmatch_t
op_star
id|regs
comma
id|re_node_set
op_star
id|eps_via_nodes
)paren
(brace
id|reg_errcode_t
id|err
suffix:semicolon
r_int
id|num
op_assign
id|fs-&gt;num
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|fs-&gt;num
op_eq
id|fs-&gt;alloc
)paren
(brace
r_struct
id|re_fail_stack_ent_t
op_star
id|new_array
suffix:semicolon
id|new_array
op_assign
id|realloc
(paren
id|fs-&gt;stack
comma
(paren
r_sizeof
(paren
r_struct
id|re_fail_stack_ent_t
)paren
op_star
id|fs-&gt;alloc
op_star
l_int|2
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_array
op_eq
l_int|NULL
)paren
r_return
id|REG_ESPACE
suffix:semicolon
id|fs-&gt;alloc
op_mul_assign
l_int|2
suffix:semicolon
id|fs-&gt;stack
op_assign
id|new_array
suffix:semicolon
)brace
id|fs-&gt;stack
(braket
id|num
)braket
dot
id|idx
op_assign
id|str_idx
suffix:semicolon
id|fs-&gt;stack
(braket
id|num
)braket
dot
id|node
op_assign
id|dest_node
suffix:semicolon
id|fs-&gt;stack
(braket
id|num
)braket
dot
id|regs
op_assign
id|re_malloc
(paren
id|regmatch_t
comma
id|nregs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fs-&gt;stack
(braket
id|num
)braket
dot
id|regs
op_eq
l_int|NULL
)paren
r_return
id|REG_ESPACE
suffix:semicolon
id|memcpy
(paren
id|fs-&gt;stack
(braket
id|num
)braket
dot
id|regs
comma
id|regs
comma
r_sizeof
(paren
id|regmatch_t
)paren
op_star
id|nregs
)paren
suffix:semicolon
id|err
op_assign
id|re_node_set_init_copy
(paren
op_amp
id|fs-&gt;stack
(braket
id|num
)braket
dot
id|eps_via_nodes
comma
id|eps_via_nodes
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
r_static
r_int
id|internal_function
DECL|function|pop_fail_stack
id|pop_fail_stack
(paren
r_struct
id|re_fail_stack_t
op_star
id|fs
comma
r_int
op_star
id|pidx
comma
r_int
id|nregs
comma
id|regmatch_t
op_star
id|regs
comma
id|re_node_set
op_star
id|eps_via_nodes
)paren
(brace
r_int
id|num
op_assign
op_decrement
id|fs-&gt;num
suffix:semicolon
m_assert
(paren
id|num
op_ge
l_int|0
)paren
suffix:semicolon
op_star
id|pidx
op_assign
id|fs-&gt;stack
(braket
id|num
)braket
dot
id|idx
suffix:semicolon
id|memcpy
(paren
id|regs
comma
id|fs-&gt;stack
(braket
id|num
)braket
dot
id|regs
comma
r_sizeof
(paren
id|regmatch_t
)paren
op_star
id|nregs
)paren
suffix:semicolon
id|re_node_set_free
(paren
id|eps_via_nodes
)paren
suffix:semicolon
id|re_free
(paren
id|fs-&gt;stack
(braket
id|num
)braket
dot
id|regs
)paren
suffix:semicolon
op_star
id|eps_via_nodes
op_assign
id|fs-&gt;stack
(braket
id|num
)braket
dot
id|eps_via_nodes
suffix:semicolon
r_return
id|fs-&gt;stack
(braket
id|num
)braket
dot
id|node
suffix:semicolon
)brace
multiline_comment|/* Set the positions where the subexpressions are starts/ends to registers&n;   PMATCH.&n;   Note: We assume that pmatch[0] is already set, and&n;   pmatch[i].rm_so == pmatch[i].rm_eo == -1 for 0 &lt; i &lt; nmatch.  */
r_static
id|reg_errcode_t
id|internal_function
DECL|function|set_regs
id|set_regs
(paren
r_const
id|regex_t
op_star
id|preg
comma
r_const
id|re_match_context_t
op_star
id|mctx
comma
r_int
id|nmatch
comma
id|regmatch_t
op_star
id|pmatch
comma
r_int
id|fl_backtrack
)paren
(brace
r_const
id|re_dfa_t
op_star
id|dfa
op_assign
(paren
r_const
id|re_dfa_t
op_star
)paren
id|preg-&gt;buffer
suffix:semicolon
r_int
id|idx
comma
id|cur_node
suffix:semicolon
id|re_node_set
id|eps_via_nodes
suffix:semicolon
r_struct
id|re_fail_stack_t
op_star
id|fs
suffix:semicolon
r_struct
id|re_fail_stack_t
id|fs_body
op_assign
(brace
l_int|0
comma
l_int|2
comma
l_int|NULL
)brace
suffix:semicolon
id|regmatch_t
op_star
id|prev_idx_match
suffix:semicolon
r_int
id|prev_idx_match_malloced
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG
m_assert
(paren
id|nmatch
OG
l_int|1
)paren
suffix:semicolon
m_assert
(paren
id|mctx-&gt;state_log
op_ne
l_int|NULL
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|fl_backtrack
)paren
(brace
id|fs
op_assign
op_amp
id|fs_body
suffix:semicolon
id|fs-&gt;stack
op_assign
id|re_malloc
(paren
r_struct
id|re_fail_stack_ent_t
comma
id|fs-&gt;alloc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fs-&gt;stack
op_eq
l_int|NULL
)paren
r_return
id|REG_ESPACE
suffix:semicolon
)brace
r_else
id|fs
op_assign
l_int|NULL
suffix:semicolon
id|cur_node
op_assign
id|dfa-&gt;init_node
suffix:semicolon
id|re_node_set_init_empty
(paren
op_amp
id|eps_via_nodes
)paren
suffix:semicolon
macro_line|#ifdef HAVE_ALLOCA
r_if
c_cond
(paren
id|__libc_use_alloca
(paren
id|nmatch
op_star
r_sizeof
(paren
id|regmatch_t
)paren
)paren
)paren
id|prev_idx_match
op_assign
(paren
id|regmatch_t
op_star
)paren
id|alloca
(paren
id|nmatch
op_star
r_sizeof
(paren
id|regmatch_t
)paren
)paren
suffix:semicolon
r_else
macro_line|#endif
(brace
id|prev_idx_match
op_assign
id|re_malloc
(paren
id|regmatch_t
comma
id|nmatch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prev_idx_match
op_eq
l_int|NULL
)paren
(brace
id|free_fail_stack_return
(paren
id|fs
)paren
suffix:semicolon
r_return
id|REG_ESPACE
suffix:semicolon
)brace
id|prev_idx_match_malloced
op_assign
l_int|1
suffix:semicolon
)brace
id|memcpy
(paren
id|prev_idx_match
comma
id|pmatch
comma
r_sizeof
(paren
id|regmatch_t
)paren
op_star
id|nmatch
)paren
suffix:semicolon
r_for
c_loop
(paren
id|idx
op_assign
id|pmatch
(braket
l_int|0
)braket
dot
id|rm_so
suffix:semicolon
id|idx
op_le
id|pmatch
(braket
l_int|0
)braket
dot
id|rm_eo
suffix:semicolon
)paren
(brace
id|update_regs
(paren
id|dfa
comma
id|pmatch
comma
id|prev_idx_match
comma
id|cur_node
comma
id|idx
comma
id|nmatch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|idx
op_eq
id|pmatch
(braket
l_int|0
)braket
dot
id|rm_eo
op_logical_and
id|cur_node
op_eq
id|mctx-&gt;last_node
)paren
(brace
r_int
id|reg_idx
suffix:semicolon
r_if
c_cond
(paren
id|fs
)paren
(brace
r_for
c_loop
(paren
id|reg_idx
op_assign
l_int|0
suffix:semicolon
id|reg_idx
OL
id|nmatch
suffix:semicolon
op_increment
id|reg_idx
)paren
r_if
c_cond
(paren
id|pmatch
(braket
id|reg_idx
)braket
dot
id|rm_so
OG
l_int|1
op_logical_and
id|pmatch
(braket
id|reg_idx
)braket
dot
id|rm_eo
op_eq
l_int|1
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|reg_idx
op_eq
id|nmatch
)paren
(brace
id|re_node_set_free
(paren
op_amp
id|eps_via_nodes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prev_idx_match_malloced
)paren
id|re_free
(paren
id|prev_idx_match
)paren
suffix:semicolon
r_return
id|free_fail_stack_return
(paren
id|fs
)paren
suffix:semicolon
)brace
id|cur_node
op_assign
id|pop_fail_stack
(paren
id|fs
comma
op_amp
id|idx
comma
id|nmatch
comma
id|pmatch
comma
op_amp
id|eps_via_nodes
)paren
suffix:semicolon
)brace
r_else
(brace
id|re_node_set_free
(paren
op_amp
id|eps_via_nodes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prev_idx_match_malloced
)paren
id|re_free
(paren
id|prev_idx_match
)paren
suffix:semicolon
r_return
id|REG_NOERROR
suffix:semicolon
)brace
)brace
multiline_comment|/* Proceed to next node.  */
id|cur_node
op_assign
id|proceed_next_node
(paren
id|mctx
comma
id|nmatch
comma
id|pmatch
comma
op_amp
id|idx
comma
id|cur_node
comma
op_amp
id|eps_via_nodes
comma
id|fs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|cur_node
OL
l_int|0
comma
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|BE
(paren
id|cur_node
op_eq
l_int|2
comma
l_int|0
)paren
)paren
(brace
id|re_node_set_free
(paren
op_amp
id|eps_via_nodes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prev_idx_match_malloced
)paren
id|re_free
(paren
id|prev_idx_match
)paren
suffix:semicolon
id|free_fail_stack_return
(paren
id|fs
)paren
suffix:semicolon
r_return
id|REG_ESPACE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fs
)paren
id|cur_node
op_assign
id|pop_fail_stack
(paren
id|fs
comma
op_amp
id|idx
comma
id|nmatch
comma
id|pmatch
comma
op_amp
id|eps_via_nodes
)paren
suffix:semicolon
r_else
(brace
id|re_node_set_free
(paren
op_amp
id|eps_via_nodes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prev_idx_match_malloced
)paren
id|re_free
(paren
id|prev_idx_match
)paren
suffix:semicolon
r_return
id|REG_NOMATCH
suffix:semicolon
)brace
)brace
)brace
id|re_node_set_free
(paren
op_amp
id|eps_via_nodes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prev_idx_match_malloced
)paren
id|re_free
(paren
id|prev_idx_match
)paren
suffix:semicolon
r_return
id|free_fail_stack_return
(paren
id|fs
)paren
suffix:semicolon
)brace
r_static
id|reg_errcode_t
id|internal_function
DECL|function|free_fail_stack_return
id|free_fail_stack_return
(paren
r_struct
id|re_fail_stack_t
op_star
id|fs
)paren
(brace
r_if
c_cond
(paren
id|fs
)paren
(brace
r_int
id|fs_idx
suffix:semicolon
r_for
c_loop
(paren
id|fs_idx
op_assign
l_int|0
suffix:semicolon
id|fs_idx
OL
id|fs-&gt;num
suffix:semicolon
op_increment
id|fs_idx
)paren
(brace
id|re_node_set_free
(paren
op_amp
id|fs-&gt;stack
(braket
id|fs_idx
)braket
dot
id|eps_via_nodes
)paren
suffix:semicolon
id|re_free
(paren
id|fs-&gt;stack
(braket
id|fs_idx
)braket
dot
id|regs
)paren
suffix:semicolon
)brace
id|re_free
(paren
id|fs-&gt;stack
)paren
suffix:semicolon
)brace
r_return
id|REG_NOERROR
suffix:semicolon
)brace
r_static
r_void
id|internal_function
DECL|function|update_regs
id|update_regs
(paren
r_const
id|re_dfa_t
op_star
id|dfa
comma
id|regmatch_t
op_star
id|pmatch
comma
id|regmatch_t
op_star
id|prev_idx_match
comma
r_int
id|cur_node
comma
r_int
id|cur_idx
comma
r_int
id|nmatch
)paren
(brace
r_int
id|type
op_assign
id|dfa-&gt;nodes
(braket
id|cur_node
)braket
dot
id|type
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|OP_OPEN_SUBEXP
)paren
(brace
r_int
id|reg_num
op_assign
id|dfa-&gt;nodes
(braket
id|cur_node
)braket
dot
id|opr.idx
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* We are at the first node of this sub expression.  */
r_if
c_cond
(paren
id|reg_num
OL
id|nmatch
)paren
(brace
id|pmatch
(braket
id|reg_num
)braket
dot
id|rm_so
op_assign
id|cur_idx
suffix:semicolon
id|pmatch
(braket
id|reg_num
)braket
dot
id|rm_eo
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|type
op_eq
id|OP_CLOSE_SUBEXP
)paren
(brace
r_int
id|reg_num
op_assign
id|dfa-&gt;nodes
(braket
id|cur_node
)braket
dot
id|opr.idx
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|reg_num
OL
id|nmatch
)paren
(brace
multiline_comment|/* We are at the last node of this sub expression.  */
r_if
c_cond
(paren
id|pmatch
(braket
id|reg_num
)braket
dot
id|rm_so
OL
id|cur_idx
)paren
(brace
id|pmatch
(braket
id|reg_num
)braket
dot
id|rm_eo
op_assign
id|cur_idx
suffix:semicolon
multiline_comment|/* This is a non-empty match or we are not inside an optional&n;&t;&t; subexpression.  Accept this right away.  */
id|memcpy
(paren
id|prev_idx_match
comma
id|pmatch
comma
r_sizeof
(paren
id|regmatch_t
)paren
op_star
id|nmatch
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|dfa-&gt;nodes
(braket
id|cur_node
)braket
dot
id|opt_subexp
op_logical_and
id|prev_idx_match
(braket
id|reg_num
)braket
dot
id|rm_so
op_ne
l_int|1
)paren
multiline_comment|/* We transited through an empty match for an optional&n;&t;&t;   subexpression, like (a?)*, and this is not the subexp&squot;s&n;&t;&t;   first match.  Copy back the old content of the registers&n;&t;&t;   so that matches of an inner subexpression are undone as&n;&t;&t;   well, like in ((a?))*.  */
id|memcpy
(paren
id|pmatch
comma
id|prev_idx_match
comma
r_sizeof
(paren
id|regmatch_t
)paren
op_star
id|nmatch
)paren
suffix:semicolon
r_else
multiline_comment|/* We completed a subexpression, but it may be part of&n;&t;&t;   an optional one, so do not update PREV_IDX_MATCH.  */
id|pmatch
(braket
id|reg_num
)braket
dot
id|rm_eo
op_assign
id|cur_idx
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/* This function checks the STATE_LOG from the SCTX-&gt;last_str_idx to 0&n;   and sift the nodes in each states according to the following rules.&n;   Updated state_log will be wrote to STATE_LOG.&n;&n;   Rules: We throw away the Node `a&squot; in the STATE_LOG[STR_IDX] if...&n;     1. When STR_IDX == MATCH_LAST(the last index in the state_log):&n;&t;If `a&squot; isn&squot;t the LAST_NODE and `a&squot; can&squot;t epsilon transit to&n;&t;the LAST_NODE, we throw away the node `a&squot;.&n;     2. When 0 &lt;= STR_IDX &lt; MATCH_LAST and `a&squot; accepts&n;&t;string `s&squot; and transit to `b&squot;:&n;&t;i. If &squot;b&squot; isn&squot;t in the STATE_LOG[STR_IDX+strlen(&squot;s&squot;)], we throw&n;&t;   away the node `a&squot;.&n;&t;ii. If &squot;b&squot; is in the STATE_LOG[STR_IDX+strlen(&squot;s&squot;)] but &squot;b&squot; is&n;&t;    thrown away, we throw away the node `a&squot;.&n;     3. When 0 &lt;= STR_IDX &lt; MATCH_LAST and &squot;a&squot; epsilon transit to &squot;b&squot;:&n;&t;i. If &squot;b&squot; isn&squot;t in the STATE_LOG[STR_IDX], we throw away the&n;&t;   node `a&squot;.&n;&t;ii. If &squot;b&squot; is in the STATE_LOG[STR_IDX] but &squot;b&squot; is thrown away,&n;&t;    we throw away the node `a&squot;.  */
DECL|macro|STATE_NODE_CONTAINS
mdefine_line|#define STATE_NODE_CONTAINS(state,node) &bslash;&n;  ((state) != NULL &amp;&amp; re_node_set_contains (&amp;(state)-&gt;nodes, node))
r_static
id|reg_errcode_t
id|internal_function
DECL|function|sift_states_backward
id|sift_states_backward
(paren
r_const
id|re_match_context_t
op_star
id|mctx
comma
id|re_sift_context_t
op_star
id|sctx
)paren
(brace
id|reg_errcode_t
id|err
suffix:semicolon
r_int
id|null_cnt
op_assign
l_int|0
suffix:semicolon
r_int
id|str_idx
op_assign
id|sctx-&gt;last_str_idx
suffix:semicolon
id|re_node_set
id|cur_dest
suffix:semicolon
macro_line|#ifdef DEBUG
m_assert
(paren
id|mctx-&gt;state_log
op_ne
l_int|NULL
op_logical_and
id|mctx-&gt;state_log
(braket
id|str_idx
)braket
op_ne
l_int|NULL
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Build sifted state_log[str_idx].  It has the nodes which can epsilon&n;     transit to the last_node and the last_node itself.  */
id|err
op_assign
id|re_node_set_init_1
(paren
op_amp
id|cur_dest
comma
id|sctx-&gt;last_node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|err
suffix:semicolon
id|err
op_assign
id|update_cur_sifted_state
(paren
id|mctx
comma
id|sctx
comma
id|str_idx
comma
op_amp
id|cur_dest
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_goto
id|free_return
suffix:semicolon
multiline_comment|/* Then check each states in the state_log.  */
r_while
c_loop
(paren
id|str_idx
OG
l_int|0
)paren
(brace
multiline_comment|/* Update counters.  */
id|null_cnt
op_assign
(paren
id|sctx-&gt;sifted_states
(braket
id|str_idx
)braket
op_eq
l_int|NULL
)paren
ques
c_cond
id|null_cnt
op_plus
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|null_cnt
OG
id|mctx-&gt;max_mb_elem_len
)paren
(brace
id|memset
(paren
id|sctx-&gt;sifted_states
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|re_dfastate_t
op_star
)paren
op_star
id|str_idx
)paren
suffix:semicolon
id|re_node_set_free
(paren
op_amp
id|cur_dest
)paren
suffix:semicolon
r_return
id|REG_NOERROR
suffix:semicolon
)brace
id|re_node_set_empty
(paren
op_amp
id|cur_dest
)paren
suffix:semicolon
op_decrement
id|str_idx
suffix:semicolon
r_if
c_cond
(paren
id|mctx-&gt;state_log
(braket
id|str_idx
)braket
)paren
(brace
id|err
op_assign
id|build_sifted_states
(paren
id|mctx
comma
id|sctx
comma
id|str_idx
comma
op_amp
id|cur_dest
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_goto
id|free_return
suffix:semicolon
)brace
multiline_comment|/* Add all the nodes which satisfy the following conditions:&n;&t; - It can epsilon transit to a node in CUR_DEST.&n;&t; - It is in CUR_SRC.&n;&t; And update state_log.  */
id|err
op_assign
id|update_cur_sifted_state
(paren
id|mctx
comma
id|sctx
comma
id|str_idx
comma
op_amp
id|cur_dest
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_goto
id|free_return
suffix:semicolon
)brace
id|err
op_assign
id|REG_NOERROR
suffix:semicolon
id|free_return
suffix:colon
id|re_node_set_free
(paren
op_amp
id|cur_dest
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
r_static
id|reg_errcode_t
id|internal_function
DECL|function|build_sifted_states
id|build_sifted_states
(paren
r_const
id|re_match_context_t
op_star
id|mctx
comma
id|re_sift_context_t
op_star
id|sctx
comma
r_int
id|str_idx
comma
id|re_node_set
op_star
id|cur_dest
)paren
(brace
r_const
id|re_dfa_t
op_star
r_const
id|dfa
op_assign
id|mctx-&gt;dfa
suffix:semicolon
r_const
id|re_node_set
op_star
id|cur_src
op_assign
op_amp
id|mctx-&gt;state_log
(braket
id|str_idx
)braket
op_member_access_from_pointer
id|non_eps_nodes
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Then build the next sifted state.&n;     We build the next sifted state on `cur_dest&squot;, and update&n;     `sifted_states[str_idx]&squot; with `cur_dest&squot;.&n;     Note:&n;     `cur_dest&squot; is the sifted state from `state_log[str_idx + 1]&squot;.&n;     `cur_src&squot; points the node_set of the old `state_log[str_idx]&squot;&n;     (with the epsilon nodes pre-filtered out).  */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cur_src-&gt;nelem
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|prev_node
op_assign
id|cur_src-&gt;elems
(braket
id|i
)braket
suffix:semicolon
r_int
id|naccepted
op_assign
l_int|0
suffix:semicolon
r_int
id|ret
suffix:semicolon
macro_line|#ifdef DEBUG
id|re_token_type_t
id|type
op_assign
id|dfa-&gt;nodes
(braket
id|prev_node
)braket
dot
id|type
suffix:semicolon
m_assert
(paren
op_logical_neg
id|IS_EPSILON_NODE
(paren
id|type
)paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef RE_ENABLE_I18N
multiline_comment|/* If the node may accept `multi byte&squot;.  */
r_if
c_cond
(paren
id|dfa-&gt;nodes
(braket
id|prev_node
)braket
dot
id|accept_mb
)paren
id|naccepted
op_assign
id|sift_states_iter_mb
(paren
id|mctx
comma
id|sctx
comma
id|prev_node
comma
id|str_idx
comma
id|sctx-&gt;last_str_idx
)paren
suffix:semicolon
macro_line|#endif /* RE_ENABLE_I18N */
multiline_comment|/* We don&squot;t check backreferences here.&n;&t; See update_cur_sifted_state().  */
r_if
c_cond
(paren
op_logical_neg
id|naccepted
op_logical_and
id|check_node_accept
(paren
id|mctx
comma
id|dfa-&gt;nodes
op_plus
id|prev_node
comma
id|str_idx
)paren
op_logical_and
id|STATE_NODE_CONTAINS
(paren
id|sctx-&gt;sifted_states
(braket
id|str_idx
op_plus
l_int|1
)braket
comma
id|dfa-&gt;nexts
(braket
id|prev_node
)braket
)paren
)paren
id|naccepted
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|naccepted
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|sctx-&gt;limits.nelem
)paren
(brace
r_int
id|to_idx
op_assign
id|str_idx
op_plus
id|naccepted
suffix:semicolon
r_if
c_cond
(paren
id|check_dst_limits
(paren
id|mctx
comma
op_amp
id|sctx-&gt;limits
comma
id|dfa-&gt;nexts
(braket
id|prev_node
)braket
comma
id|to_idx
comma
id|prev_node
comma
id|str_idx
)paren
)paren
r_continue
suffix:semicolon
)brace
id|ret
op_assign
id|re_node_set_insert
(paren
id|cur_dest
comma
id|prev_node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|ret
op_eq
l_int|1
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
)brace
r_return
id|REG_NOERROR
suffix:semicolon
)brace
multiline_comment|/* Helper functions.  */
r_static
id|reg_errcode_t
id|internal_function
DECL|function|clean_state_log_if_needed
id|clean_state_log_if_needed
(paren
id|re_match_context_t
op_star
id|mctx
comma
r_int
id|next_state_log_idx
)paren
(brace
r_int
id|top
op_assign
id|mctx-&gt;state_log_top
suffix:semicolon
r_if
c_cond
(paren
id|next_state_log_idx
op_ge
id|mctx-&gt;input.bufs_len
op_logical_or
(paren
id|next_state_log_idx
op_ge
id|mctx-&gt;input.valid_len
op_logical_and
id|mctx-&gt;input.valid_len
OL
id|mctx-&gt;input.len
)paren
)paren
(brace
id|reg_errcode_t
id|err
suffix:semicolon
id|err
op_assign
id|extend_buffers
(paren
id|mctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|err
suffix:semicolon
)brace
r_if
c_cond
(paren
id|top
OL
id|next_state_log_idx
)paren
(brace
id|memset
(paren
id|mctx-&gt;state_log
op_plus
id|top
op_plus
l_int|1
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|re_dfastate_t
op_star
)paren
op_star
(paren
id|next_state_log_idx
id|top
)paren
)paren
suffix:semicolon
id|mctx-&gt;state_log_top
op_assign
id|next_state_log_idx
suffix:semicolon
)brace
r_return
id|REG_NOERROR
suffix:semicolon
)brace
r_static
id|reg_errcode_t
id|internal_function
DECL|function|merge_state_array
id|merge_state_array
(paren
r_const
id|re_dfa_t
op_star
id|dfa
comma
id|re_dfastate_t
op_star
op_star
id|dst
comma
id|re_dfastate_t
op_star
op_star
id|src
comma
r_int
id|num
)paren
(brace
r_int
id|st_idx
suffix:semicolon
id|reg_errcode_t
id|err
suffix:semicolon
r_for
c_loop
(paren
id|st_idx
op_assign
l_int|0
suffix:semicolon
id|st_idx
OL
id|num
suffix:semicolon
op_increment
id|st_idx
)paren
(brace
r_if
c_cond
(paren
id|dst
(braket
id|st_idx
)braket
op_eq
l_int|NULL
)paren
id|dst
(braket
id|st_idx
)braket
op_assign
id|src
(braket
id|st_idx
)braket
suffix:semicolon
r_else
r_if
c_cond
(paren
id|src
(braket
id|st_idx
)braket
op_ne
l_int|NULL
)paren
(brace
id|re_node_set
id|merged_set
suffix:semicolon
id|err
op_assign
id|re_node_set_init_union
(paren
op_amp
id|merged_set
comma
op_amp
id|dst
(braket
id|st_idx
)braket
op_member_access_from_pointer
id|nodes
comma
op_amp
id|src
(braket
id|st_idx
)braket
op_member_access_from_pointer
id|nodes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|err
suffix:semicolon
id|dst
(braket
id|st_idx
)braket
op_assign
id|re_acquire_state
(paren
op_amp
id|err
comma
id|dfa
comma
op_amp
id|merged_set
)paren
suffix:semicolon
id|re_node_set_free
(paren
op_amp
id|merged_set
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|err
suffix:semicolon
)brace
)brace
r_return
id|REG_NOERROR
suffix:semicolon
)brace
r_static
id|reg_errcode_t
id|internal_function
DECL|function|update_cur_sifted_state
id|update_cur_sifted_state
(paren
r_const
id|re_match_context_t
op_star
id|mctx
comma
id|re_sift_context_t
op_star
id|sctx
comma
r_int
id|str_idx
comma
id|re_node_set
op_star
id|dest_nodes
)paren
(brace
r_const
id|re_dfa_t
op_star
r_const
id|dfa
op_assign
id|mctx-&gt;dfa
suffix:semicolon
id|reg_errcode_t
id|err
op_assign
id|REG_NOERROR
suffix:semicolon
r_const
id|re_node_set
op_star
id|candidates
suffix:semicolon
id|candidates
op_assign
(paren
(paren
id|mctx-&gt;state_log
(braket
id|str_idx
)braket
op_eq
l_int|NULL
)paren
ques
c_cond
l_int|NULL
suffix:colon
op_amp
id|mctx-&gt;state_log
(braket
id|str_idx
)braket
op_member_access_from_pointer
id|nodes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dest_nodes-&gt;nelem
op_eq
l_int|0
)paren
id|sctx-&gt;sifted_states
(braket
id|str_idx
)braket
op_assign
l_int|NULL
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|candidates
)paren
(brace
multiline_comment|/* At first, add the nodes which can epsilon transit to a node in&n;&t;     DEST_NODE.  */
id|err
op_assign
id|add_epsilon_src_nodes
(paren
id|dfa
comma
id|dest_nodes
comma
id|candidates
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|err
suffix:semicolon
multiline_comment|/* Then, check the limitations in the current sift_context.  */
r_if
c_cond
(paren
id|sctx-&gt;limits.nelem
)paren
(brace
id|err
op_assign
id|check_subexp_limits
(paren
id|dfa
comma
id|dest_nodes
comma
id|candidates
comma
op_amp
id|sctx-&gt;limits
comma
id|mctx-&gt;bkref_ents
comma
id|str_idx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|err
suffix:semicolon
)brace
)brace
id|sctx-&gt;sifted_states
(braket
id|str_idx
)braket
op_assign
id|re_acquire_state
(paren
op_amp
id|err
comma
id|dfa
comma
id|dest_nodes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|err
suffix:semicolon
)brace
r_if
c_cond
(paren
id|candidates
op_logical_and
id|mctx-&gt;state_log
(braket
id|str_idx
)braket
op_member_access_from_pointer
id|has_backref
)paren
(brace
id|err
op_assign
id|sift_states_bkref
(paren
id|mctx
comma
id|sctx
comma
id|str_idx
comma
id|candidates
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|err
suffix:semicolon
)brace
r_return
id|REG_NOERROR
suffix:semicolon
)brace
r_static
id|reg_errcode_t
id|internal_function
DECL|function|add_epsilon_src_nodes
id|add_epsilon_src_nodes
(paren
r_const
id|re_dfa_t
op_star
id|dfa
comma
id|re_node_set
op_star
id|dest_nodes
comma
r_const
id|re_node_set
op_star
id|candidates
)paren
(brace
id|reg_errcode_t
id|err
op_assign
id|REG_NOERROR
suffix:semicolon
r_int
id|i
suffix:semicolon
id|re_dfastate_t
op_star
id|state
op_assign
id|re_acquire_state
(paren
op_amp
id|err
comma
id|dfa
comma
id|dest_nodes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|state-&gt;inveclosure.alloc
)paren
(brace
id|err
op_assign
id|re_node_set_alloc
(paren
op_amp
id|state-&gt;inveclosure
comma
id|dest_nodes-&gt;nelem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dest_nodes-&gt;nelem
suffix:semicolon
id|i
op_increment
)paren
(brace
id|err
op_assign
id|re_node_set_merge
(paren
op_amp
id|state-&gt;inveclosure
comma
id|dfa-&gt;inveclosures
op_plus
id|dest_nodes-&gt;elems
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
)brace
)brace
r_return
id|re_node_set_add_intersect
(paren
id|dest_nodes
comma
id|candidates
comma
op_amp
id|state-&gt;inveclosure
)paren
suffix:semicolon
)brace
r_static
id|reg_errcode_t
id|internal_function
DECL|function|sub_epsilon_src_nodes
id|sub_epsilon_src_nodes
(paren
r_const
id|re_dfa_t
op_star
id|dfa
comma
r_int
id|node
comma
id|re_node_set
op_star
id|dest_nodes
comma
r_const
id|re_node_set
op_star
id|candidates
)paren
(brace
r_int
id|ecl_idx
suffix:semicolon
id|reg_errcode_t
id|err
suffix:semicolon
id|re_node_set
op_star
id|inv_eclosure
op_assign
id|dfa-&gt;inveclosures
op_plus
id|node
suffix:semicolon
id|re_node_set
id|except_nodes
suffix:semicolon
id|re_node_set_init_empty
(paren
op_amp
id|except_nodes
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ecl_idx
op_assign
l_int|0
suffix:semicolon
id|ecl_idx
OL
id|inv_eclosure-&gt;nelem
suffix:semicolon
op_increment
id|ecl_idx
)paren
(brace
r_int
id|cur_node
op_assign
id|inv_eclosure-&gt;elems
(braket
id|ecl_idx
)braket
suffix:semicolon
r_if
c_cond
(paren
id|cur_node
op_eq
id|node
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|IS_EPSILON_NODE
(paren
id|dfa-&gt;nodes
(braket
id|cur_node
)braket
dot
id|type
)paren
)paren
(brace
r_int
id|edst1
op_assign
id|dfa-&gt;edests
(braket
id|cur_node
)braket
dot
id|elems
(braket
l_int|0
)braket
suffix:semicolon
r_int
id|edst2
op_assign
(paren
(paren
id|dfa-&gt;edests
(braket
id|cur_node
)braket
dot
id|nelem
OG
l_int|1
)paren
ques
c_cond
id|dfa-&gt;edests
(braket
id|cur_node
)braket
dot
id|elems
(braket
l_int|1
)braket
suffix:colon
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|re_node_set_contains
(paren
id|inv_eclosure
comma
id|edst1
)paren
op_logical_and
id|re_node_set_contains
(paren
id|dest_nodes
comma
id|edst1
)paren
)paren
op_logical_or
(paren
id|edst2
OG
l_int|0
op_logical_and
op_logical_neg
id|re_node_set_contains
(paren
id|inv_eclosure
comma
id|edst2
)paren
op_logical_and
id|re_node_set_contains
(paren
id|dest_nodes
comma
id|edst2
)paren
)paren
)paren
(brace
id|err
op_assign
id|re_node_set_add_intersect
(paren
op_amp
id|except_nodes
comma
id|candidates
comma
id|dfa-&gt;inveclosures
op_plus
id|cur_node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
(brace
id|re_node_set_free
(paren
op_amp
id|except_nodes
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
)brace
)brace
)brace
r_for
c_loop
(paren
id|ecl_idx
op_assign
l_int|0
suffix:semicolon
id|ecl_idx
OL
id|inv_eclosure-&gt;nelem
suffix:semicolon
op_increment
id|ecl_idx
)paren
(brace
r_int
id|cur_node
op_assign
id|inv_eclosure-&gt;elems
(braket
id|ecl_idx
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|re_node_set_contains
(paren
op_amp
id|except_nodes
comma
id|cur_node
)paren
)paren
(brace
r_int
id|idx
op_assign
id|re_node_set_contains
(paren
id|dest_nodes
comma
id|cur_node
)paren
l_int|1
suffix:semicolon
id|re_node_set_remove_at
(paren
id|dest_nodes
comma
id|idx
)paren
suffix:semicolon
)brace
)brace
id|re_node_set_free
(paren
op_amp
id|except_nodes
)paren
suffix:semicolon
r_return
id|REG_NOERROR
suffix:semicolon
)brace
r_static
r_int
id|internal_function
DECL|function|check_dst_limits
id|check_dst_limits
(paren
r_const
id|re_match_context_t
op_star
id|mctx
comma
id|re_node_set
op_star
id|limits
comma
r_int
id|dst_node
comma
r_int
id|dst_idx
comma
r_int
id|src_node
comma
r_int
id|src_idx
)paren
(brace
r_const
id|re_dfa_t
op_star
r_const
id|dfa
op_assign
id|mctx-&gt;dfa
suffix:semicolon
r_int
id|lim_idx
comma
id|src_pos
comma
id|dst_pos
suffix:semicolon
r_int
id|dst_bkref_idx
op_assign
id|search_cur_bkref_entry
(paren
id|mctx
comma
id|dst_idx
)paren
suffix:semicolon
r_int
id|src_bkref_idx
op_assign
id|search_cur_bkref_entry
(paren
id|mctx
comma
id|src_idx
)paren
suffix:semicolon
r_for
c_loop
(paren
id|lim_idx
op_assign
l_int|0
suffix:semicolon
id|lim_idx
OL
id|limits-&gt;nelem
suffix:semicolon
op_increment
id|lim_idx
)paren
(brace
r_int
id|subexp_idx
suffix:semicolon
r_struct
id|re_backref_cache_entry
op_star
id|ent
suffix:semicolon
id|ent
op_assign
id|mctx-&gt;bkref_ents
op_plus
id|limits-&gt;elems
(braket
id|lim_idx
)braket
suffix:semicolon
id|subexp_idx
op_assign
id|dfa-&gt;nodes
(braket
id|ent-&gt;node
)braket
dot
id|opr.idx
suffix:semicolon
id|dst_pos
op_assign
id|check_dst_limits_calc_pos
(paren
id|mctx
comma
id|limits-&gt;elems
(braket
id|lim_idx
)braket
comma
id|subexp_idx
comma
id|dst_node
comma
id|dst_idx
comma
id|dst_bkref_idx
)paren
suffix:semicolon
id|src_pos
op_assign
id|check_dst_limits_calc_pos
(paren
id|mctx
comma
id|limits-&gt;elems
(braket
id|lim_idx
)braket
comma
id|subexp_idx
comma
id|src_node
comma
id|src_idx
comma
id|src_bkref_idx
)paren
suffix:semicolon
multiline_comment|/* In case of:&n;&t; &lt;src&gt; &lt;dst&gt; ( &lt;subexp&gt; )&n;&t; ( &lt;subexp&gt; ) &lt;src&gt; &lt;dst&gt;&n;&t; ( &lt;subexp1&gt; &lt;src&gt; &lt;subexp2&gt; &lt;dst&gt; &lt;subexp3&gt; )  */
r_if
c_cond
(paren
id|src_pos
op_eq
id|dst_pos
)paren
r_continue
suffix:semicolon
multiline_comment|/* This is unrelated limitation.  */
r_else
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
id|internal_function
DECL|function|check_dst_limits_calc_pos_1
id|check_dst_limits_calc_pos_1
(paren
r_const
id|re_match_context_t
op_star
id|mctx
comma
r_int
id|boundaries
comma
r_int
id|subexp_idx
comma
r_int
id|from_node
comma
r_int
id|bkref_idx
)paren
(brace
r_const
id|re_dfa_t
op_star
r_const
id|dfa
op_assign
id|mctx-&gt;dfa
suffix:semicolon
r_const
id|re_node_set
op_star
id|eclosures
op_assign
id|dfa-&gt;eclosures
op_plus
id|from_node
suffix:semicolon
r_int
id|node_idx
suffix:semicolon
multiline_comment|/* Else, we are on the boundary: examine the nodes on the epsilon&n;     closure.  */
r_for
c_loop
(paren
id|node_idx
op_assign
l_int|0
suffix:semicolon
id|node_idx
OL
id|eclosures-&gt;nelem
suffix:semicolon
op_increment
id|node_idx
)paren
(brace
r_int
id|node
op_assign
id|eclosures-&gt;elems
(braket
id|node_idx
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|dfa-&gt;nodes
(braket
id|node
)braket
dot
id|type
)paren
(brace
r_case
id|OP_BACK_REF
suffix:colon
r_if
c_cond
(paren
id|bkref_idx
op_ne
l_int|1
)paren
(brace
r_struct
id|re_backref_cache_entry
op_star
id|ent
op_assign
id|mctx-&gt;bkref_ents
op_plus
id|bkref_idx
suffix:semicolon
r_do
(brace
r_int
id|dst
comma
id|cpos
suffix:semicolon
r_if
c_cond
(paren
id|ent-&gt;node
op_ne
id|node
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|subexp_idx
OL
id|BITSET_WORD_BITS
op_logical_and
op_logical_neg
(paren
id|ent-&gt;eps_reachable_subexps_map
op_amp
(paren
(paren
id|bitset_word_t
)paren
l_int|1
op_lshift
id|subexp_idx
)paren
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* Recurse trying to reach the OP_OPEN_SUBEXP and&n;&t;&t;     OP_CLOSE_SUBEXP cases below.  But, if the&n;&t;&t;     destination node is the same node as the source&n;&t;&t;     node, don&squot;t recurse because it would cause an&n;&t;&t;     infinite loop: a regex that exhibits this behavior&n;&t;&t;     is ()&bslash;1*&bslash;1*  */
id|dst
op_assign
id|dfa-&gt;edests
(braket
id|node
)braket
dot
id|elems
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|dst
op_eq
id|from_node
)paren
(brace
r_if
c_cond
(paren
id|boundaries
op_amp
l_int|1
)paren
r_return
l_int|1
suffix:semicolon
r_else
multiline_comment|/* if (boundaries &amp; 2) */
r_return
l_int|0
suffix:semicolon
)brace
id|cpos
op_assign
id|check_dst_limits_calc_pos_1
(paren
id|mctx
comma
id|boundaries
comma
id|subexp_idx
comma
id|dst
comma
id|bkref_idx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpos
op_eq
l_int|1
multiline_comment|/* &amp;&amp; (boundaries &amp; 1) */
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cpos
op_eq
l_int|0
op_logical_and
(paren
id|boundaries
op_amp
l_int|2
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|subexp_idx
OL
id|BITSET_WORD_BITS
)paren
id|ent-&gt;eps_reachable_subexps_map
op_and_assign
op_complement
(paren
(paren
id|bitset_word_t
)paren
l_int|1
op_lshift
id|subexp_idx
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|ent
op_increment
op_member_access_from_pointer
id|more
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OP_OPEN_SUBEXP
suffix:colon
r_if
c_cond
(paren
(paren
id|boundaries
op_amp
l_int|1
)paren
op_logical_and
id|subexp_idx
op_eq
id|dfa-&gt;nodes
(braket
id|node
)braket
dot
id|opr.idx
)paren
r_return
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OP_CLOSE_SUBEXP
suffix:colon
r_if
c_cond
(paren
(paren
id|boundaries
op_amp
l_int|2
)paren
op_logical_and
id|subexp_idx
op_eq
id|dfa-&gt;nodes
(braket
id|node
)braket
dot
id|opr.idx
)paren
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
r_return
(paren
id|boundaries
op_amp
l_int|2
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
r_static
r_int
id|internal_function
DECL|function|check_dst_limits_calc_pos
id|check_dst_limits_calc_pos
(paren
r_const
id|re_match_context_t
op_star
id|mctx
comma
r_int
id|limit
comma
r_int
id|subexp_idx
comma
r_int
id|from_node
comma
r_int
id|str_idx
comma
r_int
id|bkref_idx
)paren
(brace
r_struct
id|re_backref_cache_entry
op_star
id|lim
op_assign
id|mctx-&gt;bkref_ents
op_plus
id|limit
suffix:semicolon
r_int
id|boundaries
suffix:semicolon
multiline_comment|/* If we are outside the range of the subexpression, return -1 or 1.  */
r_if
c_cond
(paren
id|str_idx
OL
id|lim-&gt;subexp_from
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|lim-&gt;subexp_to
OL
id|str_idx
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* If we are within the subexpression, return 0.  */
id|boundaries
op_assign
(paren
id|str_idx
op_eq
id|lim-&gt;subexp_from
)paren
suffix:semicolon
id|boundaries
op_or_assign
(paren
id|str_idx
op_eq
id|lim-&gt;subexp_to
)paren
op_lshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|boundaries
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Else, examine epsilon closure.  */
r_return
id|check_dst_limits_calc_pos_1
(paren
id|mctx
comma
id|boundaries
comma
id|subexp_idx
comma
id|from_node
comma
id|bkref_idx
)paren
suffix:semicolon
)brace
multiline_comment|/* Check the limitations of sub expressions LIMITS, and remove the nodes&n;   which are against limitations from DEST_NODES. */
r_static
id|reg_errcode_t
id|internal_function
DECL|function|check_subexp_limits
id|check_subexp_limits
(paren
r_const
id|re_dfa_t
op_star
id|dfa
comma
id|re_node_set
op_star
id|dest_nodes
comma
r_const
id|re_node_set
op_star
id|candidates
comma
id|re_node_set
op_star
id|limits
comma
r_struct
id|re_backref_cache_entry
op_star
id|bkref_ents
comma
r_int
id|str_idx
)paren
(brace
id|reg_errcode_t
id|err
suffix:semicolon
r_int
id|node_idx
comma
id|lim_idx
suffix:semicolon
r_for
c_loop
(paren
id|lim_idx
op_assign
l_int|0
suffix:semicolon
id|lim_idx
OL
id|limits-&gt;nelem
suffix:semicolon
op_increment
id|lim_idx
)paren
(brace
r_int
id|subexp_idx
suffix:semicolon
r_struct
id|re_backref_cache_entry
op_star
id|ent
suffix:semicolon
id|ent
op_assign
id|bkref_ents
op_plus
id|limits-&gt;elems
(braket
id|lim_idx
)braket
suffix:semicolon
r_if
c_cond
(paren
id|str_idx
op_le
id|ent-&gt;subexp_from
op_logical_or
id|ent-&gt;str_idx
OL
id|str_idx
)paren
r_continue
suffix:semicolon
multiline_comment|/* This is unrelated limitation.  */
id|subexp_idx
op_assign
id|dfa-&gt;nodes
(braket
id|ent-&gt;node
)braket
dot
id|opr.idx
suffix:semicolon
r_if
c_cond
(paren
id|ent-&gt;subexp_to
op_eq
id|str_idx
)paren
(brace
r_int
id|ops_node
op_assign
l_int|1
suffix:semicolon
r_int
id|cls_node
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|node_idx
op_assign
l_int|0
suffix:semicolon
id|node_idx
OL
id|dest_nodes-&gt;nelem
suffix:semicolon
op_increment
id|node_idx
)paren
(brace
r_int
id|node
op_assign
id|dest_nodes-&gt;elems
(braket
id|node_idx
)braket
suffix:semicolon
id|re_token_type_t
id|type
op_assign
id|dfa-&gt;nodes
(braket
id|node
)braket
dot
id|type
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|OP_OPEN_SUBEXP
op_logical_and
id|subexp_idx
op_eq
id|dfa-&gt;nodes
(braket
id|node
)braket
dot
id|opr.idx
)paren
id|ops_node
op_assign
id|node
suffix:semicolon
r_else
r_if
c_cond
(paren
id|type
op_eq
id|OP_CLOSE_SUBEXP
op_logical_and
id|subexp_idx
op_eq
id|dfa-&gt;nodes
(braket
id|node
)braket
dot
id|opr.idx
)paren
id|cls_node
op_assign
id|node
suffix:semicolon
)brace
multiline_comment|/* Check the limitation of the open subexpression.  */
multiline_comment|/* Note that (ent-&gt;subexp_to = str_idx != ent-&gt;subexp_from).  */
r_if
c_cond
(paren
id|ops_node
op_ge
l_int|0
)paren
(brace
id|err
op_assign
id|sub_epsilon_src_nodes
(paren
id|dfa
comma
id|ops_node
comma
id|dest_nodes
comma
id|candidates
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* Check the limitation of the close subexpression.  */
r_if
c_cond
(paren
id|cls_node
op_ge
l_int|0
)paren
r_for
c_loop
(paren
id|node_idx
op_assign
l_int|0
suffix:semicolon
id|node_idx
OL
id|dest_nodes-&gt;nelem
suffix:semicolon
op_increment
id|node_idx
)paren
(brace
r_int
id|node
op_assign
id|dest_nodes-&gt;elems
(braket
id|node_idx
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|re_node_set_contains
(paren
id|dfa-&gt;inveclosures
op_plus
id|node
comma
id|cls_node
)paren
op_logical_and
op_logical_neg
id|re_node_set_contains
(paren
id|dfa-&gt;eclosures
op_plus
id|node
comma
id|cls_node
)paren
)paren
(brace
multiline_comment|/* It is against this limitation.&n;&t;&t;       Remove it form the current sifted state.  */
id|err
op_assign
id|sub_epsilon_src_nodes
(paren
id|dfa
comma
id|node
comma
id|dest_nodes
comma
id|candidates
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|err
suffix:semicolon
op_decrement
id|node_idx
suffix:semicolon
)brace
)brace
)brace
r_else
multiline_comment|/* (ent-&gt;subexp_to != str_idx)  */
(brace
r_for
c_loop
(paren
id|node_idx
op_assign
l_int|0
suffix:semicolon
id|node_idx
OL
id|dest_nodes-&gt;nelem
suffix:semicolon
op_increment
id|node_idx
)paren
(brace
r_int
id|node
op_assign
id|dest_nodes-&gt;elems
(braket
id|node_idx
)braket
suffix:semicolon
id|re_token_type_t
id|type
op_assign
id|dfa-&gt;nodes
(braket
id|node
)braket
dot
id|type
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|OP_CLOSE_SUBEXP
op_logical_or
id|type
op_eq
id|OP_OPEN_SUBEXP
)paren
(brace
r_if
c_cond
(paren
id|subexp_idx
op_ne
id|dfa-&gt;nodes
(braket
id|node
)braket
dot
id|opr.idx
)paren
r_continue
suffix:semicolon
multiline_comment|/* It is against this limitation.&n;&t;&t;     Remove it form the current sifted state.  */
id|err
op_assign
id|sub_epsilon_src_nodes
(paren
id|dfa
comma
id|node
comma
id|dest_nodes
comma
id|candidates
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|err
suffix:semicolon
)brace
)brace
)brace
)brace
r_return
id|REG_NOERROR
suffix:semicolon
)brace
r_static
id|reg_errcode_t
id|internal_function
DECL|function|sift_states_bkref
id|sift_states_bkref
(paren
r_const
id|re_match_context_t
op_star
id|mctx
comma
id|re_sift_context_t
op_star
id|sctx
comma
r_int
id|str_idx
comma
r_const
id|re_node_set
op_star
id|candidates
)paren
(brace
r_const
id|re_dfa_t
op_star
r_const
id|dfa
op_assign
id|mctx-&gt;dfa
suffix:semicolon
id|reg_errcode_t
id|err
suffix:semicolon
r_int
id|node_idx
comma
id|node
suffix:semicolon
id|re_sift_context_t
id|local_sctx
suffix:semicolon
r_int
id|first_idx
op_assign
id|search_cur_bkref_entry
(paren
id|mctx
comma
id|str_idx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|first_idx
op_eq
l_int|1
)paren
r_return
id|REG_NOERROR
suffix:semicolon
id|local_sctx.sifted_states
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Mark that it hasn&squot;t been initialized.  */
r_for
c_loop
(paren
id|node_idx
op_assign
l_int|0
suffix:semicolon
id|node_idx
OL
id|candidates-&gt;nelem
suffix:semicolon
op_increment
id|node_idx
)paren
(brace
r_int
id|enabled_idx
suffix:semicolon
id|re_token_type_t
id|type
suffix:semicolon
r_struct
id|re_backref_cache_entry
op_star
id|entry
suffix:semicolon
id|node
op_assign
id|candidates-&gt;elems
(braket
id|node_idx
)braket
suffix:semicolon
id|type
op_assign
id|dfa-&gt;nodes
(braket
id|node
)braket
dot
id|type
suffix:semicolon
multiline_comment|/* Avoid infinite loop for the REs like &quot;()&bslash;1+&quot;.  */
r_if
c_cond
(paren
id|node
op_eq
id|sctx-&gt;last_node
op_logical_and
id|str_idx
op_eq
id|sctx-&gt;last_str_idx
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
id|OP_BACK_REF
)paren
r_continue
suffix:semicolon
id|entry
op_assign
id|mctx-&gt;bkref_ents
op_plus
id|first_idx
suffix:semicolon
id|enabled_idx
op_assign
id|first_idx
suffix:semicolon
r_do
(brace
r_int
id|subexp_len
suffix:semicolon
r_int
id|to_idx
suffix:semicolon
r_int
id|dst_node
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|re_dfastate_t
op_star
id|cur_state
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;node
op_ne
id|node
)paren
r_continue
suffix:semicolon
id|subexp_len
op_assign
id|entry-&gt;subexp_to
id|entry-&gt;subexp_from
suffix:semicolon
id|to_idx
op_assign
id|str_idx
op_plus
id|subexp_len
suffix:semicolon
id|dst_node
op_assign
(paren
id|subexp_len
ques
c_cond
id|dfa-&gt;nexts
(braket
id|node
)braket
suffix:colon
id|dfa-&gt;edests
(braket
id|node
)braket
dot
id|elems
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|to_idx
OG
id|sctx-&gt;last_str_idx
op_logical_or
id|sctx-&gt;sifted_states
(braket
id|to_idx
)braket
op_eq
l_int|NULL
op_logical_or
op_logical_neg
id|STATE_NODE_CONTAINS
(paren
id|sctx-&gt;sifted_states
(braket
id|to_idx
)braket
comma
id|dst_node
)paren
op_logical_or
id|check_dst_limits
(paren
id|mctx
comma
op_amp
id|sctx-&gt;limits
comma
id|node
comma
id|str_idx
comma
id|dst_node
comma
id|to_idx
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|local_sctx.sifted_states
op_eq
l_int|NULL
)paren
(brace
id|local_sctx
op_assign
op_star
id|sctx
suffix:semicolon
id|err
op_assign
id|re_node_set_init_copy
(paren
op_amp
id|local_sctx.limits
comma
op_amp
id|sctx-&gt;limits
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_goto
id|free_return
suffix:semicolon
)brace
id|local_sctx.last_node
op_assign
id|node
suffix:semicolon
id|local_sctx.last_str_idx
op_assign
id|str_idx
suffix:semicolon
id|ret
op_assign
id|re_node_set_insert
(paren
op_amp
id|local_sctx.limits
comma
id|enabled_idx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|ret
OL
l_int|0
comma
l_int|0
)paren
)paren
(brace
id|err
op_assign
id|REG_ESPACE
suffix:semicolon
r_goto
id|free_return
suffix:semicolon
)brace
id|cur_state
op_assign
id|local_sctx.sifted_states
(braket
id|str_idx
)braket
suffix:semicolon
id|err
op_assign
id|sift_states_backward
(paren
id|mctx
comma
op_amp
id|local_sctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_goto
id|free_return
suffix:semicolon
r_if
c_cond
(paren
id|sctx-&gt;limited_states
op_ne
l_int|NULL
)paren
(brace
id|err
op_assign
id|merge_state_array
(paren
id|dfa
comma
id|sctx-&gt;limited_states
comma
id|local_sctx.sifted_states
comma
id|str_idx
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_goto
id|free_return
suffix:semicolon
)brace
id|local_sctx.sifted_states
(braket
id|str_idx
)braket
op_assign
id|cur_state
suffix:semicolon
id|re_node_set_remove
(paren
op_amp
id|local_sctx.limits
comma
id|enabled_idx
)paren
suffix:semicolon
multiline_comment|/* mctx-&gt;bkref_ents may have changed, reload the pointer.  */
id|entry
op_assign
id|mctx-&gt;bkref_ents
op_plus
id|enabled_idx
suffix:semicolon
)brace
r_while
c_loop
(paren
id|enabled_idx
op_increment
comma
id|entry
op_increment
op_member_access_from_pointer
id|more
)paren
suffix:semicolon
)brace
id|err
op_assign
id|REG_NOERROR
suffix:semicolon
id|free_return
suffix:colon
r_if
c_cond
(paren
id|local_sctx.sifted_states
op_ne
l_int|NULL
)paren
(brace
id|re_node_set_free
(paren
op_amp
id|local_sctx.limits
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
macro_line|#ifdef RE_ENABLE_I18N
r_static
r_int
id|internal_function
DECL|function|sift_states_iter_mb
id|sift_states_iter_mb
(paren
r_const
id|re_match_context_t
op_star
id|mctx
comma
id|re_sift_context_t
op_star
id|sctx
comma
r_int
id|node_idx
comma
r_int
id|str_idx
comma
r_int
id|max_str_idx
)paren
(brace
r_const
id|re_dfa_t
op_star
r_const
id|dfa
op_assign
id|mctx-&gt;dfa
suffix:semicolon
r_int
id|naccepted
suffix:semicolon
multiline_comment|/* Check the node can accept `multi byte&squot;.  */
id|naccepted
op_assign
id|check_node_accept_bytes
(paren
id|dfa
comma
id|node_idx
comma
op_amp
id|mctx-&gt;input
comma
id|str_idx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|naccepted
OG
l_int|0
op_logical_and
id|str_idx
op_plus
id|naccepted
op_le
id|max_str_idx
op_logical_and
op_logical_neg
id|STATE_NODE_CONTAINS
(paren
id|sctx-&gt;sifted_states
(braket
id|str_idx
op_plus
id|naccepted
)braket
comma
id|dfa-&gt;nexts
(braket
id|node_idx
)braket
)paren
)paren
multiline_comment|/* The node can&squot;t accept the `multi byte&squot;, or the&n;       destination was already thrown away, then the node&n;       could&squot;t accept the current input `multi byte&squot;.   */
id|naccepted
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Otherwise, it is sure that the node could accept&n;     `naccepted&squot; bytes input.  */
r_return
id|naccepted
suffix:semicolon
)brace
macro_line|#endif /* RE_ENABLE_I18N */
"&f;"
multiline_comment|/* Functions for state transition.  */
multiline_comment|/* Return the next state to which the current state STATE will transit by&n;   accepting the current input byte, and update STATE_LOG if necessary.&n;   If STATE can accept a multibyte char/collating element/back reference&n;   update the destination of STATE_LOG.  */
r_static
id|re_dfastate_t
op_star
id|internal_function
DECL|function|transit_state
id|transit_state
(paren
id|reg_errcode_t
op_star
id|err
comma
id|re_match_context_t
op_star
id|mctx
comma
id|re_dfastate_t
op_star
id|state
)paren
(brace
id|re_dfastate_t
op_star
op_star
id|trtable
suffix:semicolon
r_int
r_char
id|ch
suffix:semicolon
macro_line|#ifdef RE_ENABLE_I18N
multiline_comment|/* If the current state can accept multibyte.  */
r_if
c_cond
(paren
id|BE
(paren
id|state-&gt;accept_mb
comma
l_int|0
)paren
)paren
(brace
op_star
id|err
op_assign
id|transit_state_mb
(paren
id|mctx
comma
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
op_star
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#endif /* RE_ENABLE_I18N */
multiline_comment|/* Then decide the next state with the single byte.  */
macro_line|#if 0
r_if
c_cond
(paren
l_int|0
)paren
multiline_comment|/* don&squot;t use transition table  */
r_return
id|transit_state_sb
(paren
id|err
comma
id|mctx
comma
id|state
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Use transition table  */
id|ch
op_assign
id|re_string_fetch_byte
(paren
op_amp
id|mctx-&gt;input
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|trtable
op_assign
id|state-&gt;trtable
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|trtable
op_ne
l_int|NULL
comma
l_int|1
)paren
)paren
r_return
id|trtable
(braket
id|ch
)braket
suffix:semicolon
id|trtable
op_assign
id|state-&gt;word_trtable
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|trtable
op_ne
l_int|NULL
comma
l_int|1
)paren
)paren
(brace
r_int
r_int
id|context
suffix:semicolon
id|context
op_assign
id|re_string_context_at
(paren
op_amp
id|mctx-&gt;input
comma
id|re_string_cur_idx
(paren
op_amp
id|mctx-&gt;input
)paren
l_int|1
comma
id|mctx-&gt;eflags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_WORD_CONTEXT
(paren
id|context
)paren
)paren
r_return
id|trtable
(braket
id|ch
op_plus
id|SBC_MAX
)braket
suffix:semicolon
r_else
r_return
id|trtable
(braket
id|ch
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|build_trtable
(paren
id|mctx-&gt;dfa
comma
id|state
)paren
)paren
(brace
op_star
id|err
op_assign
id|REG_ESPACE
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Retry, we now have a transition table.  */
)brace
)brace
multiline_comment|/* Update the state_log if we need */
id|re_dfastate_t
op_star
id|internal_function
DECL|function|merge_state_with_log
id|merge_state_with_log
(paren
id|reg_errcode_t
op_star
id|err
comma
id|re_match_context_t
op_star
id|mctx
comma
id|re_dfastate_t
op_star
id|next_state
)paren
(brace
r_const
id|re_dfa_t
op_star
r_const
id|dfa
op_assign
id|mctx-&gt;dfa
suffix:semicolon
r_int
id|cur_idx
op_assign
id|re_string_cur_idx
(paren
op_amp
id|mctx-&gt;input
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur_idx
OG
id|mctx-&gt;state_log_top
)paren
(brace
id|mctx-&gt;state_log
(braket
id|cur_idx
)braket
op_assign
id|next_state
suffix:semicolon
id|mctx-&gt;state_log_top
op_assign
id|cur_idx
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|mctx-&gt;state_log
(braket
id|cur_idx
)braket
op_eq
l_int|0
)paren
(brace
id|mctx-&gt;state_log
(braket
id|cur_idx
)braket
op_assign
id|next_state
suffix:semicolon
)brace
r_else
(brace
id|re_dfastate_t
op_star
id|pstate
suffix:semicolon
r_int
r_int
id|context
suffix:semicolon
id|re_node_set
id|next_nodes
comma
op_star
id|log_nodes
comma
op_star
id|table_nodes
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* If (state_log[cur_idx] != 0), it implies that cur_idx is&n;&t; the destination of a multibyte char/collating element/&n;&t; back reference.  Then the next state is the union set of&n;&t; these destinations and the results of the transition table.  */
id|pstate
op_assign
id|mctx-&gt;state_log
(braket
id|cur_idx
)braket
suffix:semicolon
id|log_nodes
op_assign
id|pstate-&gt;entrance_nodes
suffix:semicolon
r_if
c_cond
(paren
id|next_state
op_ne
l_int|NULL
)paren
(brace
id|table_nodes
op_assign
id|next_state-&gt;entrance_nodes
suffix:semicolon
op_star
id|err
op_assign
id|re_node_set_init_union
(paren
op_amp
id|next_nodes
comma
id|table_nodes
comma
id|log_nodes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
op_star
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
r_else
id|next_nodes
op_assign
op_star
id|log_nodes
suffix:semicolon
multiline_comment|/* Note: We already add the nodes of the initial state,&n;&t; then we don&squot;t need to add them here.  */
id|context
op_assign
id|re_string_context_at
(paren
op_amp
id|mctx-&gt;input
comma
id|re_string_cur_idx
(paren
op_amp
id|mctx-&gt;input
)paren
l_int|1
comma
id|mctx-&gt;eflags
)paren
suffix:semicolon
id|next_state
op_assign
id|mctx-&gt;state_log
(braket
id|cur_idx
)braket
op_assign
id|re_acquire_state_context
(paren
id|err
comma
id|dfa
comma
op_amp
id|next_nodes
comma
id|context
)paren
suffix:semicolon
multiline_comment|/* We don&squot;t need to check errors here, since the return value of&n;&t; this function is next_state and ERR is already set.  */
r_if
c_cond
(paren
id|table_nodes
op_ne
l_int|NULL
)paren
id|re_node_set_free
(paren
op_amp
id|next_nodes
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|BE
(paren
id|dfa-&gt;nbackref
comma
l_int|0
)paren
op_logical_and
id|next_state
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Check OP_OPEN_SUBEXP in the current state in case that we use them&n;&t; later.  We must check them here, since the back references in the&n;&t; next state might use them.  */
op_star
id|err
op_assign
id|check_subexp_matching_top
(paren
id|mctx
comma
op_amp
id|next_state-&gt;nodes
comma
id|cur_idx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
op_star
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* If the next state has back references.  */
r_if
c_cond
(paren
id|next_state-&gt;has_backref
)paren
(brace
op_star
id|err
op_assign
id|transit_state_bkref
(paren
id|mctx
comma
op_amp
id|next_state-&gt;nodes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
op_star
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|next_state
op_assign
id|mctx-&gt;state_log
(braket
id|cur_idx
)braket
suffix:semicolon
)brace
)brace
r_return
id|next_state
suffix:semicolon
)brace
multiline_comment|/* Skip bytes in the input that correspond to part of a&n;   multi-byte match, then look in the log for a state&n;   from which to restart matching.  */
id|re_dfastate_t
op_star
id|internal_function
DECL|function|find_recover_state
id|find_recover_state
(paren
id|reg_errcode_t
op_star
id|err
comma
id|re_match_context_t
op_star
id|mctx
)paren
(brace
id|re_dfastate_t
op_star
id|cur_state
suffix:semicolon
r_do
(brace
r_int
id|max
op_assign
id|mctx-&gt;state_log_top
suffix:semicolon
r_int
id|cur_str_idx
op_assign
id|re_string_cur_idx
(paren
op_amp
id|mctx-&gt;input
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_increment
id|cur_str_idx
OG
id|max
)paren
r_return
l_int|NULL
suffix:semicolon
id|re_string_skip_bytes
(paren
op_amp
id|mctx-&gt;input
comma
l_int|1
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|mctx-&gt;state_log
(braket
id|cur_str_idx
)braket
op_eq
l_int|NULL
)paren
suffix:semicolon
id|cur_state
op_assign
id|merge_state_with_log
(paren
id|err
comma
id|mctx
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_star
id|err
op_eq
id|REG_NOERROR
op_logical_and
id|cur_state
op_eq
l_int|NULL
)paren
suffix:semicolon
r_return
id|cur_state
suffix:semicolon
)brace
multiline_comment|/* Helper functions for transit_state.  */
multiline_comment|/* From the node set CUR_NODES, pick up the nodes whose types are&n;   OP_OPEN_SUBEXP and which have corresponding back references in the regular&n;   expression. And register them to use them later for evaluating the&n;   correspoding back references.  */
r_static
id|reg_errcode_t
id|internal_function
DECL|function|check_subexp_matching_top
id|check_subexp_matching_top
(paren
id|re_match_context_t
op_star
id|mctx
comma
id|re_node_set
op_star
id|cur_nodes
comma
r_int
id|str_idx
)paren
(brace
r_const
id|re_dfa_t
op_star
r_const
id|dfa
op_assign
id|mctx-&gt;dfa
suffix:semicolon
r_int
id|node_idx
suffix:semicolon
id|reg_errcode_t
id|err
suffix:semicolon
multiline_comment|/* TODO: This isn&squot;t efficient.&n;&t;   Because there might be more than one nodes whose types are&n;&t;   OP_OPEN_SUBEXP and whose index is SUBEXP_IDX, we must check all&n;&t;   nodes.&n;&t;   E.g. RE: (a){2}  */
r_for
c_loop
(paren
id|node_idx
op_assign
l_int|0
suffix:semicolon
id|node_idx
OL
id|cur_nodes-&gt;nelem
suffix:semicolon
op_increment
id|node_idx
)paren
(brace
r_int
id|node
op_assign
id|cur_nodes-&gt;elems
(braket
id|node_idx
)braket
suffix:semicolon
r_if
c_cond
(paren
id|dfa-&gt;nodes
(braket
id|node
)braket
dot
id|type
op_eq
id|OP_OPEN_SUBEXP
op_logical_and
id|dfa-&gt;nodes
(braket
id|node
)braket
dot
id|opr.idx
OL
id|BITSET_WORD_BITS
op_logical_and
(paren
id|dfa-&gt;used_bkref_map
op_amp
(paren
(paren
id|bitset_word_t
)paren
l_int|1
op_lshift
id|dfa-&gt;nodes
(braket
id|node
)braket
dot
id|opr.idx
)paren
)paren
)paren
(brace
id|err
op_assign
id|match_ctx_add_subtop
(paren
id|mctx
comma
id|node
comma
id|str_idx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|err
suffix:semicolon
)brace
)brace
r_return
id|REG_NOERROR
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/* Return the next state to which the current state STATE will transit by&n;   accepting the current input byte.  */
r_static
id|re_dfastate_t
op_star
id|transit_state_sb
(paren
id|reg_errcode_t
op_star
id|err
comma
id|re_match_context_t
op_star
id|mctx
comma
id|re_dfastate_t
op_star
id|state
)paren
(brace
r_const
id|re_dfa_t
op_star
r_const
id|dfa
op_assign
id|mctx-&gt;dfa
suffix:semicolon
id|re_node_set
id|next_nodes
suffix:semicolon
id|re_dfastate_t
op_star
id|next_state
suffix:semicolon
r_int
id|node_cnt
comma
id|cur_str_idx
op_assign
id|re_string_cur_idx
(paren
op_amp
id|mctx-&gt;input
)paren
suffix:semicolon
r_int
r_int
id|context
suffix:semicolon
op_star
id|err
op_assign
id|re_node_set_alloc
(paren
op_amp
id|next_nodes
comma
id|state-&gt;nodes.nelem
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
op_star
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|node_cnt
op_assign
l_int|0
suffix:semicolon
id|node_cnt
OL
id|state-&gt;nodes.nelem
suffix:semicolon
op_increment
id|node_cnt
)paren
(brace
r_int
id|cur_node
op_assign
id|state-&gt;nodes.elems
(braket
id|node_cnt
)braket
suffix:semicolon
r_if
c_cond
(paren
id|check_node_accept
(paren
id|mctx
comma
id|dfa-&gt;nodes
op_plus
id|cur_node
comma
id|cur_str_idx
)paren
)paren
(brace
op_star
id|err
op_assign
id|re_node_set_merge
(paren
op_amp
id|next_nodes
comma
id|dfa-&gt;eclosures
op_plus
id|dfa-&gt;nexts
(braket
id|cur_node
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
op_star
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
(brace
id|re_node_set_free
(paren
op_amp
id|next_nodes
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
id|context
op_assign
id|re_string_context_at
(paren
op_amp
id|mctx-&gt;input
comma
id|cur_str_idx
comma
id|mctx-&gt;eflags
)paren
suffix:semicolon
id|next_state
op_assign
id|re_acquire_state_context
(paren
id|err
comma
id|dfa
comma
op_amp
id|next_nodes
comma
id|context
)paren
suffix:semicolon
multiline_comment|/* We don&squot;t need to check errors here, since the return value of&n;     this function is next_state and ERR is already set.  */
id|re_node_set_free
(paren
op_amp
id|next_nodes
)paren
suffix:semicolon
id|re_string_skip_bytes
(paren
op_amp
id|mctx-&gt;input
comma
l_int|1
)paren
suffix:semicolon
r_return
id|next_state
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef RE_ENABLE_I18N
r_static
id|reg_errcode_t
id|internal_function
DECL|function|transit_state_mb
id|transit_state_mb
(paren
id|re_match_context_t
op_star
id|mctx
comma
id|re_dfastate_t
op_star
id|pstate
)paren
(brace
r_const
id|re_dfa_t
op_star
r_const
id|dfa
op_assign
id|mctx-&gt;dfa
suffix:semicolon
id|reg_errcode_t
id|err
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pstate-&gt;nodes.nelem
suffix:semicolon
op_increment
id|i
)paren
(brace
id|re_node_set
id|dest_nodes
comma
op_star
id|new_nodes
suffix:semicolon
r_int
id|cur_node_idx
op_assign
id|pstate-&gt;nodes.elems
(braket
id|i
)braket
suffix:semicolon
r_int
id|naccepted
comma
id|dest_idx
suffix:semicolon
r_int
r_int
id|context
suffix:semicolon
id|re_dfastate_t
op_star
id|dest_state
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dfa-&gt;nodes
(braket
id|cur_node_idx
)braket
dot
id|accept_mb
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|dfa-&gt;nodes
(braket
id|cur_node_idx
)braket
dot
id|constraint
)paren
(brace
id|context
op_assign
id|re_string_context_at
(paren
op_amp
id|mctx-&gt;input
comma
id|re_string_cur_idx
(paren
op_amp
id|mctx-&gt;input
)paren
comma
id|mctx-&gt;eflags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NOT_SATISFY_NEXT_CONSTRAINT
(paren
id|dfa-&gt;nodes
(braket
id|cur_node_idx
)braket
dot
id|constraint
comma
id|context
)paren
)paren
r_continue
suffix:semicolon
)brace
multiline_comment|/* How many bytes the node can accept?  */
id|naccepted
op_assign
id|check_node_accept_bytes
(paren
id|dfa
comma
id|cur_node_idx
comma
op_amp
id|mctx-&gt;input
comma
id|re_string_cur_idx
(paren
op_amp
id|mctx-&gt;input
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|naccepted
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
multiline_comment|/* The node can accepts `naccepted&squot; bytes.  */
id|dest_idx
op_assign
id|re_string_cur_idx
(paren
op_amp
id|mctx-&gt;input
)paren
op_plus
id|naccepted
suffix:semicolon
id|mctx-&gt;max_mb_elem_len
op_assign
(paren
(paren
id|mctx-&gt;max_mb_elem_len
OL
id|naccepted
)paren
ques
c_cond
id|naccepted
suffix:colon
id|mctx-&gt;max_mb_elem_len
)paren
suffix:semicolon
id|err
op_assign
id|clean_state_log_if_needed
(paren
id|mctx
comma
id|dest_idx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|err
suffix:semicolon
macro_line|#ifdef DEBUG
m_assert
(paren
id|dfa-&gt;nexts
(braket
id|cur_node_idx
)braket
op_ne
l_int|1
)paren
suffix:semicolon
macro_line|#endif
id|new_nodes
op_assign
id|dfa-&gt;eclosures
op_plus
id|dfa-&gt;nexts
(braket
id|cur_node_idx
)braket
suffix:semicolon
id|dest_state
op_assign
id|mctx-&gt;state_log
(braket
id|dest_idx
)braket
suffix:semicolon
r_if
c_cond
(paren
id|dest_state
op_eq
l_int|NULL
)paren
id|dest_nodes
op_assign
op_star
id|new_nodes
suffix:semicolon
r_else
(brace
id|err
op_assign
id|re_node_set_init_union
(paren
op_amp
id|dest_nodes
comma
id|dest_state-&gt;entrance_nodes
comma
id|new_nodes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|err
suffix:semicolon
)brace
id|context
op_assign
id|re_string_context_at
(paren
op_amp
id|mctx-&gt;input
comma
id|dest_idx
l_int|1
comma
id|mctx-&gt;eflags
)paren
suffix:semicolon
id|mctx-&gt;state_log
(braket
id|dest_idx
)braket
op_assign
id|re_acquire_state_context
(paren
op_amp
id|err
comma
id|dfa
comma
op_amp
id|dest_nodes
comma
id|context
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dest_state
op_ne
l_int|NULL
)paren
id|re_node_set_free
(paren
op_amp
id|dest_nodes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|mctx-&gt;state_log
(braket
id|dest_idx
)braket
op_eq
l_int|NULL
op_logical_and
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|err
suffix:semicolon
)brace
r_return
id|REG_NOERROR
suffix:semicolon
)brace
macro_line|#endif /* RE_ENABLE_I18N */
r_static
id|reg_errcode_t
id|internal_function
DECL|function|transit_state_bkref
id|transit_state_bkref
(paren
id|re_match_context_t
op_star
id|mctx
comma
r_const
id|re_node_set
op_star
id|nodes
)paren
(brace
r_const
id|re_dfa_t
op_star
r_const
id|dfa
op_assign
id|mctx-&gt;dfa
suffix:semicolon
id|reg_errcode_t
id|err
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|cur_str_idx
op_assign
id|re_string_cur_idx
(paren
op_amp
id|mctx-&gt;input
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nodes-&gt;nelem
suffix:semicolon
op_increment
id|i
)paren
(brace
r_int
id|dest_str_idx
comma
id|prev_nelem
comma
id|bkc_idx
suffix:semicolon
r_int
id|node_idx
op_assign
id|nodes-&gt;elems
(braket
id|i
)braket
suffix:semicolon
r_int
r_int
id|context
suffix:semicolon
r_const
id|re_token_t
op_star
id|node
op_assign
id|dfa-&gt;nodes
op_plus
id|node_idx
suffix:semicolon
id|re_node_set
op_star
id|new_dest_nodes
suffix:semicolon
multiline_comment|/* Check whether `node&squot; is a backreference or not.  */
r_if
c_cond
(paren
id|node-&gt;type
op_ne
id|OP_BACK_REF
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|node-&gt;constraint
)paren
(brace
id|context
op_assign
id|re_string_context_at
(paren
op_amp
id|mctx-&gt;input
comma
id|cur_str_idx
comma
id|mctx-&gt;eflags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NOT_SATISFY_NEXT_CONSTRAINT
(paren
id|node-&gt;constraint
comma
id|context
)paren
)paren
r_continue
suffix:semicolon
)brace
multiline_comment|/* `node&squot; is a backreference.&n;&t; Check the substring which the substring matched.  */
id|bkc_idx
op_assign
id|mctx-&gt;nbkref_ents
suffix:semicolon
id|err
op_assign
id|get_subexp
(paren
id|mctx
comma
id|node_idx
comma
id|cur_str_idx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_goto
id|free_return
suffix:semicolon
multiline_comment|/* And add the epsilon closures (which is `new_dest_nodes&squot;) of&n;&t; the backreference to appropriate state_log.  */
macro_line|#ifdef DEBUG
m_assert
(paren
id|dfa-&gt;nexts
(braket
id|node_idx
)braket
op_ne
l_int|1
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
suffix:semicolon
id|bkc_idx
OL
id|mctx-&gt;nbkref_ents
suffix:semicolon
op_increment
id|bkc_idx
)paren
(brace
r_int
id|subexp_len
suffix:semicolon
id|re_dfastate_t
op_star
id|dest_state
suffix:semicolon
r_struct
id|re_backref_cache_entry
op_star
id|bkref_ent
suffix:semicolon
id|bkref_ent
op_assign
id|mctx-&gt;bkref_ents
op_plus
id|bkc_idx
suffix:semicolon
r_if
c_cond
(paren
id|bkref_ent-&gt;node
op_ne
id|node_idx
op_logical_or
id|bkref_ent-&gt;str_idx
op_ne
id|cur_str_idx
)paren
r_continue
suffix:semicolon
id|subexp_len
op_assign
id|bkref_ent-&gt;subexp_to
id|bkref_ent-&gt;subexp_from
suffix:semicolon
id|new_dest_nodes
op_assign
(paren
id|subexp_len
op_eq
l_int|0
ques
c_cond
id|dfa-&gt;eclosures
op_plus
id|dfa-&gt;edests
(braket
id|node_idx
)braket
dot
id|elems
(braket
l_int|0
)braket
suffix:colon
id|dfa-&gt;eclosures
op_plus
id|dfa-&gt;nexts
(braket
id|node_idx
)braket
)paren
suffix:semicolon
id|dest_str_idx
op_assign
(paren
id|cur_str_idx
op_plus
id|bkref_ent-&gt;subexp_to
id|bkref_ent-&gt;subexp_from
)paren
suffix:semicolon
id|context
op_assign
id|re_string_context_at
(paren
op_amp
id|mctx-&gt;input
comma
id|dest_str_idx
l_int|1
comma
id|mctx-&gt;eflags
)paren
suffix:semicolon
id|dest_state
op_assign
id|mctx-&gt;state_log
(braket
id|dest_str_idx
)braket
suffix:semicolon
id|prev_nelem
op_assign
(paren
(paren
id|mctx-&gt;state_log
(braket
id|cur_str_idx
)braket
op_eq
l_int|NULL
)paren
ques
c_cond
l_int|0
suffix:colon
id|mctx-&gt;state_log
(braket
id|cur_str_idx
)braket
op_member_access_from_pointer
id|nodes.nelem
)paren
suffix:semicolon
multiline_comment|/* Add `new_dest_node&squot; to state_log.  */
r_if
c_cond
(paren
id|dest_state
op_eq
l_int|NULL
)paren
(brace
id|mctx-&gt;state_log
(braket
id|dest_str_idx
)braket
op_assign
id|re_acquire_state_context
(paren
op_amp
id|err
comma
id|dfa
comma
id|new_dest_nodes
comma
id|context
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|mctx-&gt;state_log
(braket
id|dest_str_idx
)braket
op_eq
l_int|NULL
op_logical_and
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_goto
id|free_return
suffix:semicolon
)brace
r_else
(brace
id|re_node_set
id|dest_nodes
suffix:semicolon
id|err
op_assign
id|re_node_set_init_union
(paren
op_amp
id|dest_nodes
comma
id|dest_state-&gt;entrance_nodes
comma
id|new_dest_nodes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
(brace
id|re_node_set_free
(paren
op_amp
id|dest_nodes
)paren
suffix:semicolon
r_goto
id|free_return
suffix:semicolon
)brace
id|mctx-&gt;state_log
(braket
id|dest_str_idx
)braket
op_assign
id|re_acquire_state_context
(paren
op_amp
id|err
comma
id|dfa
comma
op_amp
id|dest_nodes
comma
id|context
)paren
suffix:semicolon
id|re_node_set_free
(paren
op_amp
id|dest_nodes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|mctx-&gt;state_log
(braket
id|dest_str_idx
)braket
op_eq
l_int|NULL
op_logical_and
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_goto
id|free_return
suffix:semicolon
)brace
multiline_comment|/* We need to check recursively if the backreference can epsilon&n;&t;     transit.  */
r_if
c_cond
(paren
id|subexp_len
op_eq
l_int|0
op_logical_and
id|mctx-&gt;state_log
(braket
id|cur_str_idx
)braket
op_member_access_from_pointer
id|nodes.nelem
OG
id|prev_nelem
)paren
(brace
id|err
op_assign
id|check_subexp_matching_top
(paren
id|mctx
comma
id|new_dest_nodes
comma
id|cur_str_idx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_goto
id|free_return
suffix:semicolon
id|err
op_assign
id|transit_state_bkref
(paren
id|mctx
comma
id|new_dest_nodes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_goto
id|free_return
suffix:semicolon
)brace
)brace
)brace
id|err
op_assign
id|REG_NOERROR
suffix:semicolon
id|free_return
suffix:colon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* Enumerate all the candidates which the backreference BKREF_NODE can match&n;   at BKREF_STR_IDX, and register them by match_ctx_add_entry().&n;   Note that we might collect inappropriate candidates here.&n;   However, the cost of checking them strictly here is too high, then we&n;   delay these checking for prune_impossible_nodes().  */
r_static
id|reg_errcode_t
id|internal_function
DECL|function|get_subexp
id|get_subexp
(paren
id|re_match_context_t
op_star
id|mctx
comma
r_int
id|bkref_node
comma
r_int
id|bkref_str_idx
)paren
(brace
r_const
id|re_dfa_t
op_star
r_const
id|dfa
op_assign
id|mctx-&gt;dfa
suffix:semicolon
r_int
id|subexp_num
comma
id|sub_top_idx
suffix:semicolon
r_const
r_char
op_star
id|buf
op_assign
(paren
r_const
r_char
op_star
)paren
id|re_string_get_buffer
(paren
op_amp
id|mctx-&gt;input
)paren
suffix:semicolon
multiline_comment|/* Return if we have already checked BKREF_NODE at BKREF_STR_IDX.  */
r_int
id|cache_idx
op_assign
id|search_cur_bkref_entry
(paren
id|mctx
comma
id|bkref_str_idx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cache_idx
op_ne
l_int|1
)paren
(brace
r_const
r_struct
id|re_backref_cache_entry
op_star
id|entry
op_assign
id|mctx-&gt;bkref_ents
op_plus
id|cache_idx
suffix:semicolon
r_do
r_if
c_cond
(paren
id|entry-&gt;node
op_eq
id|bkref_node
)paren
r_return
id|REG_NOERROR
suffix:semicolon
multiline_comment|/* We already checked it.  */
r_while
c_loop
(paren
id|entry
op_increment
op_member_access_from_pointer
id|more
)paren
suffix:semicolon
)brace
id|subexp_num
op_assign
id|dfa-&gt;nodes
(braket
id|bkref_node
)braket
dot
id|opr.idx
suffix:semicolon
multiline_comment|/* For each sub expression  */
r_for
c_loop
(paren
id|sub_top_idx
op_assign
l_int|0
suffix:semicolon
id|sub_top_idx
OL
id|mctx-&gt;nsub_tops
suffix:semicolon
op_increment
id|sub_top_idx
)paren
(brace
id|reg_errcode_t
id|err
suffix:semicolon
id|re_sub_match_top_t
op_star
id|sub_top
op_assign
id|mctx-&gt;sub_tops
(braket
id|sub_top_idx
)braket
suffix:semicolon
id|re_sub_match_last_t
op_star
id|sub_last
suffix:semicolon
r_int
id|sub_last_idx
comma
id|sl_str
comma
id|bkref_str_off
suffix:semicolon
r_if
c_cond
(paren
id|dfa-&gt;nodes
(braket
id|sub_top-&gt;node
)braket
dot
id|opr.idx
op_ne
id|subexp_num
)paren
r_continue
suffix:semicolon
multiline_comment|/* It isn&squot;t related.  */
id|sl_str
op_assign
id|sub_top-&gt;str_idx
suffix:semicolon
id|bkref_str_off
op_assign
id|bkref_str_idx
suffix:semicolon
multiline_comment|/* At first, check the last node of sub expressions we already&n;&t; evaluated.  */
r_for
c_loop
(paren
id|sub_last_idx
op_assign
l_int|0
suffix:semicolon
id|sub_last_idx
OL
id|sub_top-&gt;nlasts
suffix:semicolon
op_increment
id|sub_last_idx
)paren
(brace
r_int
id|sl_str_diff
suffix:semicolon
id|sub_last
op_assign
id|sub_top-&gt;lasts
(braket
id|sub_last_idx
)braket
suffix:semicolon
id|sl_str_diff
op_assign
id|sub_last-&gt;str_idx
id|sl_str
suffix:semicolon
multiline_comment|/* The matched string by the sub expression match with the substring&n;&t;     at the back reference?  */
r_if
c_cond
(paren
id|sl_str_diff
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|BE
(paren
id|bkref_str_off
op_plus
id|sl_str_diff
OG
id|mctx-&gt;input.valid_len
comma
l_int|0
)paren
)paren
(brace
multiline_comment|/* Not enough chars for a successful match.  */
r_if
c_cond
(paren
id|bkref_str_off
op_plus
id|sl_str_diff
OG
id|mctx-&gt;input.len
)paren
r_break
suffix:semicolon
id|err
op_assign
id|clean_state_log_if_needed
(paren
id|mctx
comma
id|bkref_str_off
op_plus
id|sl_str_diff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|err
suffix:semicolon
id|buf
op_assign
(paren
r_const
r_char
op_star
)paren
id|re_string_get_buffer
(paren
op_amp
id|mctx-&gt;input
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|memcmp
(paren
id|buf
op_plus
id|bkref_str_off
comma
id|buf
op_plus
id|sl_str
comma
id|sl_str_diff
)paren
op_ne
l_int|0
)paren
multiline_comment|/* We don&squot;t need to search this sub expression any more.  */
r_break
suffix:semicolon
)brace
id|bkref_str_off
op_add_assign
id|sl_str_diff
suffix:semicolon
id|sl_str
op_add_assign
id|sl_str_diff
suffix:semicolon
id|err
op_assign
id|get_subexp_sub
(paren
id|mctx
comma
id|sub_top
comma
id|sub_last
comma
id|bkref_node
comma
id|bkref_str_idx
)paren
suffix:semicolon
multiline_comment|/* Reload buf, since the preceding call might have reallocated&n;&t;     the buffer.  */
id|buf
op_assign
(paren
r_const
r_char
op_star
)paren
id|re_string_get_buffer
(paren
op_amp
id|mctx-&gt;input
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
id|REG_NOMATCH
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|err
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sub_last_idx
OL
id|sub_top-&gt;nlasts
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|sub_last_idx
OG
l_int|0
)paren
op_increment
id|sl_str
suffix:semicolon
multiline_comment|/* Then, search for the other last nodes of the sub expression.  */
r_for
c_loop
(paren
suffix:semicolon
id|sl_str
op_le
id|bkref_str_idx
suffix:semicolon
op_increment
id|sl_str
)paren
(brace
r_int
id|cls_node
comma
id|sl_str_off
suffix:semicolon
r_const
id|re_node_set
op_star
id|nodes
suffix:semicolon
id|sl_str_off
op_assign
id|sl_str
id|sub_top-&gt;str_idx
suffix:semicolon
multiline_comment|/* The matched string by the sub expression match with the substring&n;&t;     at the back reference?  */
r_if
c_cond
(paren
id|sl_str_off
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|BE
(paren
id|bkref_str_off
op_ge
id|mctx-&gt;input.valid_len
comma
l_int|0
)paren
)paren
(brace
multiline_comment|/* If we are at the end of the input, we cannot match.  */
r_if
c_cond
(paren
id|bkref_str_off
op_ge
id|mctx-&gt;input.len
)paren
r_break
suffix:semicolon
id|err
op_assign
id|extend_buffers
(paren
id|mctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|err
suffix:semicolon
id|buf
op_assign
(paren
r_const
r_char
op_star
)paren
id|re_string_get_buffer
(paren
op_amp
id|mctx-&gt;input
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buf
(braket
id|bkref_str_off
op_increment
)braket
op_ne
id|buf
(braket
id|sl_str
l_int|1
)braket
)paren
r_break
suffix:semicolon
multiline_comment|/* We don&squot;t need to search this sub expression&n;&t;&t;&t;  any more.  */
)brace
r_if
c_cond
(paren
id|mctx-&gt;state_log
(braket
id|sl_str
)braket
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
multiline_comment|/* Does this state have a &squot;)&squot; of the sub expression?  */
id|nodes
op_assign
op_amp
id|mctx-&gt;state_log
(braket
id|sl_str
)braket
op_member_access_from_pointer
id|nodes
suffix:semicolon
id|cls_node
op_assign
id|find_subexp_node
(paren
id|dfa
comma
id|nodes
comma
id|subexp_num
comma
id|OP_CLOSE_SUBEXP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cls_node
op_eq
l_int|1
)paren
r_continue
suffix:semicolon
multiline_comment|/* No.  */
r_if
c_cond
(paren
id|sub_top-&gt;path
op_eq
l_int|NULL
)paren
(brace
id|sub_top-&gt;path
op_assign
id|calloc
(paren
r_sizeof
(paren
id|state_array_t
)paren
comma
id|sl_str
id|sub_top-&gt;str_idx
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sub_top-&gt;path
op_eq
l_int|NULL
)paren
r_return
id|REG_ESPACE
suffix:semicolon
)brace
multiline_comment|/* Can the OP_OPEN_SUBEXP node arrive the OP_CLOSE_SUBEXP node&n;&t;     in the current context?  */
id|err
op_assign
id|check_arrival
(paren
id|mctx
comma
id|sub_top-&gt;path
comma
id|sub_top-&gt;node
comma
id|sub_top-&gt;str_idx
comma
id|cls_node
comma
id|sl_str
comma
id|OP_CLOSE_SUBEXP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
id|REG_NOMATCH
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|err
suffix:semicolon
id|sub_last
op_assign
id|match_ctx_add_sublast
(paren
id|sub_top
comma
id|cls_node
comma
id|sl_str
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|sub_last
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
id|err
op_assign
id|get_subexp_sub
(paren
id|mctx
comma
id|sub_top
comma
id|sub_last
comma
id|bkref_node
comma
id|bkref_str_idx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
id|REG_NOMATCH
)paren
r_continue
suffix:semicolon
)brace
)brace
r_return
id|REG_NOERROR
suffix:semicolon
)brace
multiline_comment|/* Helper functions for get_subexp().  */
multiline_comment|/* Check SUB_LAST can arrive to the back reference BKREF_NODE at BKREF_STR.&n;   If it can arrive, register the sub expression expressed with SUB_TOP&n;   and SUB_LAST.  */
r_static
id|reg_errcode_t
id|internal_function
DECL|function|get_subexp_sub
id|get_subexp_sub
(paren
id|re_match_context_t
op_star
id|mctx
comma
r_const
id|re_sub_match_top_t
op_star
id|sub_top
comma
id|re_sub_match_last_t
op_star
id|sub_last
comma
r_int
id|bkref_node
comma
r_int
id|bkref_str
)paren
(brace
id|reg_errcode_t
id|err
suffix:semicolon
r_int
id|to_idx
suffix:semicolon
multiline_comment|/* Can the subexpression arrive the back reference?  */
id|err
op_assign
id|check_arrival
(paren
id|mctx
comma
op_amp
id|sub_last-&gt;path
comma
id|sub_last-&gt;node
comma
id|sub_last-&gt;str_idx
comma
id|bkref_node
comma
id|bkref_str
comma
id|OP_OPEN_SUBEXP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
id|REG_NOERROR
)paren
r_return
id|err
suffix:semicolon
id|err
op_assign
id|match_ctx_add_entry
(paren
id|mctx
comma
id|bkref_node
comma
id|bkref_str
comma
id|sub_top-&gt;str_idx
comma
id|sub_last-&gt;str_idx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|err
suffix:semicolon
id|to_idx
op_assign
id|bkref_str
op_plus
id|sub_last-&gt;str_idx
id|sub_top-&gt;str_idx
suffix:semicolon
r_return
id|clean_state_log_if_needed
(paren
id|mctx
comma
id|to_idx
)paren
suffix:semicolon
)brace
multiline_comment|/* Find the first node which is &squot;(&squot; or &squot;)&squot; and whose index is SUBEXP_IDX.&n;   Search &squot;(&squot; if FL_OPEN, or search &squot;)&squot; otherwise.&n;   TODO: This function isn&squot;t efficient...&n;&t; Because there might be more than one nodes whose types are&n;&t; OP_OPEN_SUBEXP and whose index is SUBEXP_IDX, we must check all&n;&t; nodes.&n;&t; E.g. RE: (a){2}  */
r_static
r_int
id|internal_function
DECL|function|find_subexp_node
id|find_subexp_node
(paren
r_const
id|re_dfa_t
op_star
id|dfa
comma
r_const
id|re_node_set
op_star
id|nodes
comma
r_int
id|subexp_idx
comma
r_int
id|type
)paren
(brace
r_int
id|cls_idx
suffix:semicolon
r_for
c_loop
(paren
id|cls_idx
op_assign
l_int|0
suffix:semicolon
id|cls_idx
OL
id|nodes-&gt;nelem
suffix:semicolon
op_increment
id|cls_idx
)paren
(brace
r_int
id|cls_node
op_assign
id|nodes-&gt;elems
(braket
id|cls_idx
)braket
suffix:semicolon
r_const
id|re_token_t
op_star
id|node
op_assign
id|dfa-&gt;nodes
op_plus
id|cls_node
suffix:semicolon
r_if
c_cond
(paren
id|node-&gt;type
op_eq
id|type
op_logical_and
id|node-&gt;opr.idx
op_eq
id|subexp_idx
)paren
r_return
id|cls_node
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Check whether the node TOP_NODE at TOP_STR can arrive to the node&n;   LAST_NODE at LAST_STR.  We record the path onto PATH since it will be&n;   heavily reused.&n;   Return REG_NOERROR if it can arrive, or REG_NOMATCH otherwise.  */
r_static
id|reg_errcode_t
id|internal_function
DECL|function|check_arrival
id|check_arrival
(paren
id|re_match_context_t
op_star
id|mctx
comma
id|state_array_t
op_star
id|path
comma
r_int
id|top_node
comma
r_int
id|top_str
comma
r_int
id|last_node
comma
r_int
id|last_str
comma
r_int
id|type
)paren
(brace
r_const
id|re_dfa_t
op_star
r_const
id|dfa
op_assign
id|mctx-&gt;dfa
suffix:semicolon
id|reg_errcode_t
id|err
op_assign
id|REG_NOERROR
suffix:semicolon
r_int
id|subexp_num
comma
id|backup_cur_idx
comma
id|str_idx
comma
id|null_cnt
suffix:semicolon
id|re_dfastate_t
op_star
id|cur_state
op_assign
l_int|NULL
suffix:semicolon
id|re_node_set
op_star
id|cur_nodes
comma
id|next_nodes
suffix:semicolon
id|re_dfastate_t
op_star
op_star
id|backup_state_log
suffix:semicolon
r_int
r_int
id|context
suffix:semicolon
id|subexp_num
op_assign
id|dfa-&gt;nodes
(braket
id|top_node
)braket
dot
id|opr.idx
suffix:semicolon
multiline_comment|/* Extend the buffer if we need.  */
r_if
c_cond
(paren
id|BE
(paren
id|path-&gt;alloc
OL
id|last_str
op_plus
id|mctx-&gt;max_mb_elem_len
op_plus
l_int|1
comma
l_int|0
)paren
)paren
(brace
id|re_dfastate_t
op_star
op_star
id|new_array
suffix:semicolon
r_int
id|old_alloc
op_assign
id|path-&gt;alloc
suffix:semicolon
id|path-&gt;alloc
op_add_assign
id|last_str
op_plus
id|mctx-&gt;max_mb_elem_len
op_plus
l_int|1
suffix:semicolon
id|new_array
op_assign
id|re_realloc
(paren
id|path-&gt;array
comma
id|re_dfastate_t
op_star
comma
id|path-&gt;alloc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|new_array
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
(brace
id|path-&gt;alloc
op_assign
id|old_alloc
suffix:semicolon
r_return
id|REG_ESPACE
suffix:semicolon
)brace
id|path-&gt;array
op_assign
id|new_array
suffix:semicolon
id|memset
(paren
id|new_array
op_plus
id|old_alloc
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|re_dfastate_t
op_star
)paren
op_star
(paren
id|path-&gt;alloc
id|old_alloc
)paren
)paren
suffix:semicolon
)brace
id|str_idx
op_assign
id|path-&gt;next_idx
ques
c_cond
id|path-&gt;next_idx
suffix:colon
id|top_str
suffix:semicolon
multiline_comment|/* Temporary modify MCTX.  */
id|backup_state_log
op_assign
id|mctx-&gt;state_log
suffix:semicolon
id|backup_cur_idx
op_assign
id|mctx-&gt;input.cur_idx
suffix:semicolon
id|mctx-&gt;state_log
op_assign
id|path-&gt;array
suffix:semicolon
id|mctx-&gt;input.cur_idx
op_assign
id|str_idx
suffix:semicolon
multiline_comment|/* Setup initial node set.  */
id|context
op_assign
id|re_string_context_at
(paren
op_amp
id|mctx-&gt;input
comma
id|str_idx
l_int|1
comma
id|mctx-&gt;eflags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|str_idx
op_eq
id|top_str
)paren
(brace
id|err
op_assign
id|re_node_set_init_1
(paren
op_amp
id|next_nodes
comma
id|top_node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|err
suffix:semicolon
id|err
op_assign
id|check_arrival_expand_ecl
(paren
id|dfa
comma
op_amp
id|next_nodes
comma
id|subexp_num
comma
id|type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
(brace
id|re_node_set_free
(paren
op_amp
id|next_nodes
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
)brace
r_else
(brace
id|cur_state
op_assign
id|mctx-&gt;state_log
(braket
id|str_idx
)braket
suffix:semicolon
r_if
c_cond
(paren
id|cur_state
op_logical_and
id|cur_state-&gt;has_backref
)paren
(brace
id|err
op_assign
id|re_node_set_init_copy
(paren
op_amp
id|next_nodes
comma
op_amp
id|cur_state-&gt;nodes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|err
suffix:semicolon
)brace
r_else
id|re_node_set_init_empty
(paren
op_amp
id|next_nodes
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|str_idx
op_eq
id|top_str
op_logical_or
(paren
id|cur_state
op_logical_and
id|cur_state-&gt;has_backref
)paren
)paren
(brace
r_if
c_cond
(paren
id|next_nodes.nelem
)paren
(brace
id|err
op_assign
id|expand_bkref_cache
(paren
id|mctx
comma
op_amp
id|next_nodes
comma
id|str_idx
comma
id|subexp_num
comma
id|type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
(brace
id|re_node_set_free
(paren
op_amp
id|next_nodes
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
)brace
id|cur_state
op_assign
id|re_acquire_state_context
(paren
op_amp
id|err
comma
id|dfa
comma
op_amp
id|next_nodes
comma
id|context
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|cur_state
op_eq
l_int|NULL
op_logical_and
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
(brace
id|re_node_set_free
(paren
op_amp
id|next_nodes
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
id|mctx-&gt;state_log
(braket
id|str_idx
)braket
op_assign
id|cur_state
suffix:semicolon
)brace
r_for
c_loop
(paren
id|null_cnt
op_assign
l_int|0
suffix:semicolon
id|str_idx
OL
id|last_str
op_logical_and
id|null_cnt
op_le
id|mctx-&gt;max_mb_elem_len
suffix:semicolon
)paren
(brace
id|re_node_set_empty
(paren
op_amp
id|next_nodes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mctx-&gt;state_log
(braket
id|str_idx
op_plus
l_int|1
)braket
)paren
(brace
id|err
op_assign
id|re_node_set_merge
(paren
op_amp
id|next_nodes
comma
op_amp
id|mctx-&gt;state_log
(braket
id|str_idx
op_plus
l_int|1
)braket
op_member_access_from_pointer
id|nodes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
(brace
id|re_node_set_free
(paren
op_amp
id|next_nodes
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|cur_state
)paren
(brace
id|err
op_assign
id|check_arrival_add_next_nodes
(paren
id|mctx
comma
id|str_idx
comma
op_amp
id|cur_state-&gt;non_eps_nodes
comma
op_amp
id|next_nodes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
(brace
id|re_node_set_free
(paren
op_amp
id|next_nodes
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
)brace
op_increment
id|str_idx
suffix:semicolon
r_if
c_cond
(paren
id|next_nodes.nelem
)paren
(brace
id|err
op_assign
id|check_arrival_expand_ecl
(paren
id|dfa
comma
op_amp
id|next_nodes
comma
id|subexp_num
comma
id|type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
(brace
id|re_node_set_free
(paren
op_amp
id|next_nodes
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
id|err
op_assign
id|expand_bkref_cache
(paren
id|mctx
comma
op_amp
id|next_nodes
comma
id|str_idx
comma
id|subexp_num
comma
id|type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
(brace
id|re_node_set_free
(paren
op_amp
id|next_nodes
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
)brace
id|context
op_assign
id|re_string_context_at
(paren
op_amp
id|mctx-&gt;input
comma
id|str_idx
l_int|1
comma
id|mctx-&gt;eflags
)paren
suffix:semicolon
id|cur_state
op_assign
id|re_acquire_state_context
(paren
op_amp
id|err
comma
id|dfa
comma
op_amp
id|next_nodes
comma
id|context
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|cur_state
op_eq
l_int|NULL
op_logical_and
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
(brace
id|re_node_set_free
(paren
op_amp
id|next_nodes
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
id|mctx-&gt;state_log
(braket
id|str_idx
)braket
op_assign
id|cur_state
suffix:semicolon
id|null_cnt
op_assign
id|cur_state
op_eq
l_int|NULL
ques
c_cond
id|null_cnt
op_plus
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
id|re_node_set_free
(paren
op_amp
id|next_nodes
)paren
suffix:semicolon
id|cur_nodes
op_assign
(paren
id|mctx-&gt;state_log
(braket
id|last_str
)braket
op_eq
l_int|NULL
ques
c_cond
l_int|NULL
suffix:colon
op_amp
id|mctx-&gt;state_log
(braket
id|last_str
)braket
op_member_access_from_pointer
id|nodes
)paren
suffix:semicolon
id|path-&gt;next_idx
op_assign
id|str_idx
suffix:semicolon
multiline_comment|/* Fix MCTX.  */
id|mctx-&gt;state_log
op_assign
id|backup_state_log
suffix:semicolon
id|mctx-&gt;input.cur_idx
op_assign
id|backup_cur_idx
suffix:semicolon
multiline_comment|/* Then check the current node set has the node LAST_NODE.  */
r_if
c_cond
(paren
id|cur_nodes
op_ne
l_int|NULL
op_logical_and
id|re_node_set_contains
(paren
id|cur_nodes
comma
id|last_node
)paren
)paren
r_return
id|REG_NOERROR
suffix:semicolon
r_return
id|REG_NOMATCH
suffix:semicolon
)brace
multiline_comment|/* Helper functions for check_arrival.  */
multiline_comment|/* Calculate the destination nodes of CUR_NODES at STR_IDX, and append them&n;   to NEXT_NODES.&n;   TODO: This function is similar to the functions transit_state*(),&n;&t; however this function has many additional works.&n;&t; Can&squot;t we unify them?  */
r_static
id|reg_errcode_t
id|internal_function
DECL|function|check_arrival_add_next_nodes
id|check_arrival_add_next_nodes
(paren
id|re_match_context_t
op_star
id|mctx
comma
r_int
id|str_idx
comma
id|re_node_set
op_star
id|cur_nodes
comma
id|re_node_set
op_star
id|next_nodes
)paren
(brace
r_const
id|re_dfa_t
op_star
r_const
id|dfa
op_assign
id|mctx-&gt;dfa
suffix:semicolon
r_int
id|result
suffix:semicolon
r_int
id|cur_idx
suffix:semicolon
macro_line|#ifdef RE_ENABLE_I18N
id|reg_errcode_t
id|err
op_assign
id|REG_NOERROR
suffix:semicolon
macro_line|#endif
id|re_node_set
id|union_set
suffix:semicolon
id|re_node_set_init_empty
(paren
op_amp
id|union_set
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cur_idx
op_assign
l_int|0
suffix:semicolon
id|cur_idx
OL
id|cur_nodes-&gt;nelem
suffix:semicolon
op_increment
id|cur_idx
)paren
(brace
r_int
id|naccepted
op_assign
l_int|0
suffix:semicolon
r_int
id|cur_node
op_assign
id|cur_nodes-&gt;elems
(braket
id|cur_idx
)braket
suffix:semicolon
macro_line|#ifdef DEBUG
id|re_token_type_t
id|type
op_assign
id|dfa-&gt;nodes
(braket
id|cur_node
)braket
dot
id|type
suffix:semicolon
m_assert
(paren
op_logical_neg
id|IS_EPSILON_NODE
(paren
id|type
)paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef RE_ENABLE_I18N
multiline_comment|/* If the node may accept `multi byte&squot;.  */
r_if
c_cond
(paren
id|dfa-&gt;nodes
(braket
id|cur_node
)braket
dot
id|accept_mb
)paren
(brace
id|naccepted
op_assign
id|check_node_accept_bytes
(paren
id|dfa
comma
id|cur_node
comma
op_amp
id|mctx-&gt;input
comma
id|str_idx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|naccepted
OG
l_int|1
)paren
(brace
id|re_dfastate_t
op_star
id|dest_state
suffix:semicolon
r_int
id|next_node
op_assign
id|dfa-&gt;nexts
(braket
id|cur_node
)braket
suffix:semicolon
r_int
id|next_idx
op_assign
id|str_idx
op_plus
id|naccepted
suffix:semicolon
id|dest_state
op_assign
id|mctx-&gt;state_log
(braket
id|next_idx
)braket
suffix:semicolon
id|re_node_set_empty
(paren
op_amp
id|union_set
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dest_state
)paren
(brace
id|err
op_assign
id|re_node_set_merge
(paren
op_amp
id|union_set
comma
op_amp
id|dest_state-&gt;nodes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
(brace
id|re_node_set_free
(paren
op_amp
id|union_set
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
)brace
id|result
op_assign
id|re_node_set_insert
(paren
op_amp
id|union_set
comma
id|next_node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|result
OL
l_int|0
comma
l_int|0
)paren
)paren
(brace
id|re_node_set_free
(paren
op_amp
id|union_set
)paren
suffix:semicolon
r_return
id|REG_ESPACE
suffix:semicolon
)brace
id|mctx-&gt;state_log
(braket
id|next_idx
)braket
op_assign
id|re_acquire_state
(paren
op_amp
id|err
comma
id|dfa
comma
op_amp
id|union_set
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|mctx-&gt;state_log
(braket
id|next_idx
)braket
op_eq
l_int|NULL
op_logical_and
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
(brace
id|re_node_set_free
(paren
op_amp
id|union_set
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif /* RE_ENABLE_I18N */
r_if
c_cond
(paren
id|naccepted
op_logical_or
id|check_node_accept
(paren
id|mctx
comma
id|dfa-&gt;nodes
op_plus
id|cur_node
comma
id|str_idx
)paren
)paren
(brace
id|result
op_assign
id|re_node_set_insert
(paren
id|next_nodes
comma
id|dfa-&gt;nexts
(braket
id|cur_node
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|result
OL
l_int|0
comma
l_int|0
)paren
)paren
(brace
id|re_node_set_free
(paren
op_amp
id|union_set
)paren
suffix:semicolon
r_return
id|REG_ESPACE
suffix:semicolon
)brace
)brace
)brace
id|re_node_set_free
(paren
op_amp
id|union_set
)paren
suffix:semicolon
r_return
id|REG_NOERROR
suffix:semicolon
)brace
multiline_comment|/* For all the nodes in CUR_NODES, add the epsilon closures of them to&n;   CUR_NODES, however exclude the nodes which are:&n;    - inside the sub expression whose number is EX_SUBEXP, if FL_OPEN.&n;    - out of the sub expression whose number is EX_SUBEXP, if !FL_OPEN.&n;*/
r_static
id|reg_errcode_t
id|internal_function
DECL|function|check_arrival_expand_ecl
id|check_arrival_expand_ecl
(paren
r_const
id|re_dfa_t
op_star
id|dfa
comma
id|re_node_set
op_star
id|cur_nodes
comma
r_int
id|ex_subexp
comma
r_int
id|type
)paren
(brace
id|reg_errcode_t
id|err
suffix:semicolon
r_int
id|idx
comma
id|outside_node
suffix:semicolon
id|re_node_set
id|new_nodes
suffix:semicolon
macro_line|#ifdef DEBUG
m_assert
(paren
id|cur_nodes-&gt;nelem
)paren
suffix:semicolon
macro_line|#endif
id|err
op_assign
id|re_node_set_alloc
(paren
op_amp
id|new_nodes
comma
id|cur_nodes-&gt;nelem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|err
suffix:semicolon
multiline_comment|/* Create a new node set NEW_NODES with the nodes which are epsilon&n;     closures of the node in CUR_NODES.  */
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
id|cur_nodes-&gt;nelem
suffix:semicolon
op_increment
id|idx
)paren
(brace
r_int
id|cur_node
op_assign
id|cur_nodes-&gt;elems
(braket
id|idx
)braket
suffix:semicolon
r_const
id|re_node_set
op_star
id|eclosure
op_assign
id|dfa-&gt;eclosures
op_plus
id|cur_node
suffix:semicolon
id|outside_node
op_assign
id|find_subexp_node
(paren
id|dfa
comma
id|eclosure
comma
id|ex_subexp
comma
id|type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|outside_node
op_eq
l_int|1
)paren
(brace
multiline_comment|/* There are no problematic nodes, just merge them.  */
id|err
op_assign
id|re_node_set_merge
(paren
op_amp
id|new_nodes
comma
id|eclosure
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
(brace
id|re_node_set_free
(paren
op_amp
id|new_nodes
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* There are problematic nodes, re-calculate incrementally.  */
id|err
op_assign
id|check_arrival_expand_ecl_sub
(paren
id|dfa
comma
op_amp
id|new_nodes
comma
id|cur_node
comma
id|ex_subexp
comma
id|type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
(brace
id|re_node_set_free
(paren
op_amp
id|new_nodes
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
)brace
)brace
id|re_node_set_free
(paren
id|cur_nodes
)paren
suffix:semicolon
op_star
id|cur_nodes
op_assign
id|new_nodes
suffix:semicolon
r_return
id|REG_NOERROR
suffix:semicolon
)brace
multiline_comment|/* Helper function for check_arrival_expand_ecl.&n;   Check incrementally the epsilon closure of TARGET, and if it isn&squot;t&n;   problematic append it to DST_NODES.  */
r_static
id|reg_errcode_t
id|internal_function
DECL|function|check_arrival_expand_ecl_sub
id|check_arrival_expand_ecl_sub
(paren
r_const
id|re_dfa_t
op_star
id|dfa
comma
id|re_node_set
op_star
id|dst_nodes
comma
r_int
id|target
comma
r_int
id|ex_subexp
comma
r_int
id|type
)paren
(brace
r_int
id|cur_node
suffix:semicolon
r_for
c_loop
(paren
id|cur_node
op_assign
id|target
suffix:semicolon
op_logical_neg
id|re_node_set_contains
(paren
id|dst_nodes
comma
id|cur_node
)paren
suffix:semicolon
)paren
(brace
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|dfa-&gt;nodes
(braket
id|cur_node
)braket
dot
id|type
op_eq
id|type
op_logical_and
id|dfa-&gt;nodes
(braket
id|cur_node
)braket
dot
id|opr.idx
op_eq
id|ex_subexp
)paren
(brace
r_if
c_cond
(paren
id|type
op_eq
id|OP_CLOSE_SUBEXP
)paren
(brace
id|err
op_assign
id|re_node_set_insert
(paren
id|dst_nodes
comma
id|cur_node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_eq
l_int|1
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
id|err
op_assign
id|re_node_set_insert
(paren
id|dst_nodes
comma
id|cur_node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_eq
l_int|1
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
r_if
c_cond
(paren
id|dfa-&gt;edests
(braket
id|cur_node
)braket
dot
id|nelem
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|dfa-&gt;edests
(braket
id|cur_node
)braket
dot
id|nelem
op_eq
l_int|2
)paren
(brace
id|err
op_assign
id|check_arrival_expand_ecl_sub
(paren
id|dfa
comma
id|dst_nodes
comma
id|dfa-&gt;edests
(braket
id|cur_node
)braket
dot
id|elems
(braket
l_int|1
)braket
comma
id|ex_subexp
comma
id|type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|err
suffix:semicolon
)brace
id|cur_node
op_assign
id|dfa-&gt;edests
(braket
id|cur_node
)braket
dot
id|elems
(braket
l_int|0
)braket
suffix:semicolon
)brace
r_return
id|REG_NOERROR
suffix:semicolon
)brace
multiline_comment|/* For all the back references in the current state, calculate the&n;   destination of the back references by the appropriate entry&n;   in MCTX-&gt;BKREF_ENTS.  */
r_static
id|reg_errcode_t
id|internal_function
DECL|function|expand_bkref_cache
id|expand_bkref_cache
(paren
id|re_match_context_t
op_star
id|mctx
comma
id|re_node_set
op_star
id|cur_nodes
comma
r_int
id|cur_str
comma
r_int
id|subexp_num
comma
r_int
id|type
)paren
(brace
r_const
id|re_dfa_t
op_star
r_const
id|dfa
op_assign
id|mctx-&gt;dfa
suffix:semicolon
id|reg_errcode_t
id|err
suffix:semicolon
r_int
id|cache_idx_start
op_assign
id|search_cur_bkref_entry
(paren
id|mctx
comma
id|cur_str
)paren
suffix:semicolon
r_struct
id|re_backref_cache_entry
op_star
id|ent
suffix:semicolon
r_if
c_cond
(paren
id|cache_idx_start
op_eq
l_int|1
)paren
r_return
id|REG_NOERROR
suffix:semicolon
id|restart
suffix:colon
id|ent
op_assign
id|mctx-&gt;bkref_ents
op_plus
id|cache_idx_start
suffix:semicolon
r_do
(brace
r_int
id|to_idx
comma
id|next_node
suffix:semicolon
multiline_comment|/* Is this entry ENT is appropriate?  */
r_if
c_cond
(paren
op_logical_neg
id|re_node_set_contains
(paren
id|cur_nodes
comma
id|ent-&gt;node
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* No.  */
id|to_idx
op_assign
id|cur_str
op_plus
id|ent-&gt;subexp_to
id|ent-&gt;subexp_from
suffix:semicolon
multiline_comment|/* Calculate the destination of the back reference, and append it&n;&t; to MCTX-&gt;STATE_LOG.  */
r_if
c_cond
(paren
id|to_idx
op_eq
id|cur_str
)paren
(brace
multiline_comment|/* The backreference did epsilon transit, we must re-check all the&n;&t;     node in the current state.  */
id|re_node_set
id|new_dests
suffix:semicolon
id|reg_errcode_t
id|err2
comma
id|err3
suffix:semicolon
id|next_node
op_assign
id|dfa-&gt;edests
(braket
id|ent-&gt;node
)braket
dot
id|elems
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|re_node_set_contains
(paren
id|cur_nodes
comma
id|next_node
)paren
)paren
r_continue
suffix:semicolon
id|err
op_assign
id|re_node_set_init_1
(paren
op_amp
id|new_dests
comma
id|next_node
)paren
suffix:semicolon
id|err2
op_assign
id|check_arrival_expand_ecl
(paren
id|dfa
comma
op_amp
id|new_dests
comma
id|subexp_num
comma
id|type
)paren
suffix:semicolon
id|err3
op_assign
id|re_node_set_merge
(paren
id|cur_nodes
comma
op_amp
id|new_dests
)paren
suffix:semicolon
id|re_node_set_free
(paren
op_amp
id|new_dests
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
op_logical_or
id|err2
op_ne
id|REG_NOERROR
op_logical_or
id|err3
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
(brace
id|err
op_assign
(paren
id|err
op_ne
id|REG_NOERROR
ques
c_cond
id|err
suffix:colon
(paren
id|err2
op_ne
id|REG_NOERROR
ques
c_cond
id|err2
suffix:colon
id|err3
)paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* TODO: It is still inefficient...  */
r_goto
id|restart
suffix:semicolon
)brace
r_else
(brace
id|re_node_set
id|union_set
suffix:semicolon
id|next_node
op_assign
id|dfa-&gt;nexts
(braket
id|ent-&gt;node
)braket
suffix:semicolon
r_if
c_cond
(paren
id|mctx-&gt;state_log
(braket
id|to_idx
)braket
)paren
(brace
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|re_node_set_contains
(paren
op_amp
id|mctx-&gt;state_log
(braket
id|to_idx
)braket
op_member_access_from_pointer
id|nodes
comma
id|next_node
)paren
)paren
r_continue
suffix:semicolon
id|err
op_assign
id|re_node_set_init_copy
(paren
op_amp
id|union_set
comma
op_amp
id|mctx-&gt;state_log
(braket
id|to_idx
)braket
op_member_access_from_pointer
id|nodes
)paren
suffix:semicolon
id|ret
op_assign
id|re_node_set_insert
(paren
op_amp
id|union_set
comma
id|next_node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
op_logical_or
id|ret
OL
l_int|0
comma
l_int|0
)paren
)paren
(brace
id|re_node_set_free
(paren
op_amp
id|union_set
)paren
suffix:semicolon
id|err
op_assign
id|err
op_ne
id|REG_NOERROR
ques
c_cond
id|err
suffix:colon
id|REG_ESPACE
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
)brace
r_else
(brace
id|err
op_assign
id|re_node_set_init_1
(paren
op_amp
id|union_set
comma
id|next_node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|err
suffix:semicolon
)brace
id|mctx-&gt;state_log
(braket
id|to_idx
)braket
op_assign
id|re_acquire_state
(paren
op_amp
id|err
comma
id|dfa
comma
op_amp
id|union_set
)paren
suffix:semicolon
id|re_node_set_free
(paren
op_amp
id|union_set
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|mctx-&gt;state_log
(braket
id|to_idx
)braket
op_eq
l_int|NULL
op_logical_and
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|err
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|ent
op_increment
op_member_access_from_pointer
id|more
)paren
suffix:semicolon
r_return
id|REG_NOERROR
suffix:semicolon
)brace
multiline_comment|/* Build transition table for the state.&n;   Return 1 if succeeded, otherwise return NULL.  */
r_static
r_int
id|internal_function
DECL|function|build_trtable
id|build_trtable
(paren
r_const
id|re_dfa_t
op_star
id|dfa
comma
id|re_dfastate_t
op_star
id|state
)paren
(brace
id|reg_errcode_t
id|err
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|ch
comma
id|need_word_trtable
op_assign
l_int|0
suffix:semicolon
id|bitset_word_t
id|elem
comma
id|mask
suffix:semicolon
r_bool
id|dests_node_malloced
op_assign
l_bool|false
suffix:semicolon
r_bool
id|dest_states_malloced
op_assign
l_bool|false
suffix:semicolon
r_int
id|ndests
suffix:semicolon
multiline_comment|/* Number of the destination states from `state&squot;.  */
id|re_dfastate_t
op_star
op_star
id|trtable
suffix:semicolon
id|re_dfastate_t
op_star
op_star
id|dest_states
op_assign
l_int|NULL
comma
op_star
op_star
id|dest_states_word
comma
op_star
op_star
id|dest_states_nl
suffix:semicolon
id|re_node_set
id|follows
comma
op_star
id|dests_node
suffix:semicolon
id|bitset_t
op_star
id|dests_ch
suffix:semicolon
id|bitset_t
id|acceptable
suffix:semicolon
r_struct
id|dests_alloc
(brace
id|re_node_set
id|dests_node
(braket
id|SBC_MAX
)braket
suffix:semicolon
id|bitset_t
id|dests_ch
(braket
id|SBC_MAX
)braket
suffix:semicolon
)brace
op_star
id|dests_alloc
suffix:semicolon
multiline_comment|/* We build DFA states which corresponds to the destination nodes&n;     from `state&squot;.  `dests_node[i]&squot; represents the nodes which i-th&n;     destination state contains, and `dests_ch[i]&squot; represents the&n;     characters which i-th destination state accepts.  */
macro_line|#ifdef HAVE_ALLOCA
r_if
c_cond
(paren
id|__libc_use_alloca
(paren
r_sizeof
(paren
r_struct
id|dests_alloc
)paren
)paren
)paren
id|dests_alloc
op_assign
(paren
r_struct
id|dests_alloc
op_star
)paren
id|alloca
(paren
r_sizeof
(paren
r_struct
id|dests_alloc
)paren
)paren
suffix:semicolon
r_else
macro_line|#endif
(brace
id|dests_alloc
op_assign
id|re_malloc
(paren
r_struct
id|dests_alloc
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|dests_alloc
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|dests_node_malloced
op_assign
l_bool|true
suffix:semicolon
)brace
id|dests_node
op_assign
id|dests_alloc-&gt;dests_node
suffix:semicolon
id|dests_ch
op_assign
id|dests_alloc-&gt;dests_ch
suffix:semicolon
multiline_comment|/* Initialize transiton table.  */
id|state-&gt;word_trtable
op_assign
id|state-&gt;trtable
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* At first, group all nodes belonging to `state&squot; into several&n;     destinations.  */
id|ndests
op_assign
id|group_nodes_into_DFAstates
(paren
id|dfa
comma
id|state
comma
id|dests_node
comma
id|dests_ch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|ndests
op_le
l_int|0
comma
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|dests_node_malloced
)paren
id|free
(paren
id|dests_alloc
)paren
suffix:semicolon
multiline_comment|/* Return 0 in case of an error, 1 otherwise.  */
r_if
c_cond
(paren
id|ndests
op_eq
l_int|0
)paren
(brace
id|state-&gt;trtable
op_assign
(paren
id|re_dfastate_t
op_star
op_star
)paren
id|calloc
(paren
r_sizeof
(paren
id|re_dfastate_t
op_star
)paren
comma
id|SBC_MAX
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|err
op_assign
id|re_node_set_alloc
(paren
op_amp
id|follows
comma
id|ndests
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_goto
id|out_free
suffix:semicolon
multiline_comment|/* Avoid arithmetic overflow in size calculation.  */
r_if
c_cond
(paren
id|BE
(paren
(paren
(paren
(paren
id|SIZE_MAX
(paren
r_sizeof
(paren
id|re_node_set
)paren
op_plus
r_sizeof
(paren
id|bitset_t
)paren
)paren
op_star
id|SBC_MAX
)paren
op_div
(paren
l_int|3
op_star
r_sizeof
(paren
id|re_dfastate_t
op_star
)paren
)paren
)paren
OL
id|ndests
)paren
comma
l_int|0
)paren
)paren
r_goto
id|out_free
suffix:semicolon
macro_line|#ifdef HAVE_ALLOCA
r_if
c_cond
(paren
id|__libc_use_alloca
(paren
(paren
r_sizeof
(paren
id|re_node_set
)paren
op_plus
r_sizeof
(paren
id|bitset_t
)paren
)paren
op_star
id|SBC_MAX
op_plus
id|ndests
op_star
l_int|3
op_star
r_sizeof
(paren
id|re_dfastate_t
op_star
)paren
)paren
)paren
id|dest_states
op_assign
(paren
id|re_dfastate_t
op_star
op_star
)paren
id|alloca
(paren
id|ndests
op_star
l_int|3
op_star
r_sizeof
(paren
id|re_dfastate_t
op_star
)paren
)paren
suffix:semicolon
r_else
macro_line|#endif
(brace
id|dest_states
op_assign
(paren
id|re_dfastate_t
op_star
op_star
)paren
id|malloc
(paren
id|ndests
op_star
l_int|3
op_star
r_sizeof
(paren
id|re_dfastate_t
op_star
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|dest_states
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
(brace
id|out_free
suffix:colon
r_if
c_cond
(paren
id|dest_states_malloced
)paren
id|free
(paren
id|dest_states
)paren
suffix:semicolon
id|re_node_set_free
(paren
op_amp
id|follows
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ndests
suffix:semicolon
op_increment
id|i
)paren
id|re_node_set_free
(paren
id|dests_node
op_plus
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dests_node_malloced
)paren
id|free
(paren
id|dests_alloc
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|dest_states_malloced
op_assign
l_bool|true
suffix:semicolon
)brace
id|dest_states_word
op_assign
id|dest_states
op_plus
id|ndests
suffix:semicolon
id|dest_states_nl
op_assign
id|dest_states_word
op_plus
id|ndests
suffix:semicolon
id|bitset_empty
(paren
id|acceptable
)paren
suffix:semicolon
multiline_comment|/* Then build the states for all destinations.  */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ndests
suffix:semicolon
op_increment
id|i
)paren
(brace
r_int
id|next_node
suffix:semicolon
id|re_node_set_empty
(paren
op_amp
id|follows
)paren
suffix:semicolon
multiline_comment|/* Merge the follows of this destination states.  */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|dests_node
(braket
id|i
)braket
dot
id|nelem
suffix:semicolon
op_increment
id|j
)paren
(brace
id|next_node
op_assign
id|dfa-&gt;nexts
(braket
id|dests_node
(braket
id|i
)braket
dot
id|elems
(braket
id|j
)braket
)braket
suffix:semicolon
r_if
c_cond
(paren
id|next_node
op_ne
l_int|1
)paren
(brace
id|err
op_assign
id|re_node_set_merge
(paren
op_amp
id|follows
comma
id|dfa-&gt;eclosures
op_plus
id|next_node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_goto
id|out_free
suffix:semicolon
)brace
)brace
id|dest_states
(braket
id|i
)braket
op_assign
id|re_acquire_state_context
(paren
op_amp
id|err
comma
id|dfa
comma
op_amp
id|follows
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|dest_states
(braket
id|i
)braket
op_eq
l_int|NULL
op_logical_and
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_goto
id|out_free
suffix:semicolon
multiline_comment|/* If the new state has context constraint,&n;&t; build appropriate states for these contexts.  */
r_if
c_cond
(paren
id|dest_states
(braket
id|i
)braket
op_member_access_from_pointer
id|has_constraint
)paren
(brace
id|dest_states_word
(braket
id|i
)braket
op_assign
id|re_acquire_state_context
(paren
op_amp
id|err
comma
id|dfa
comma
op_amp
id|follows
comma
id|CONTEXT_WORD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|dest_states_word
(braket
id|i
)braket
op_eq
l_int|NULL
op_logical_and
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_goto
id|out_free
suffix:semicolon
r_if
c_cond
(paren
id|dest_states
(braket
id|i
)braket
op_ne
id|dest_states_word
(braket
id|i
)braket
op_logical_and
id|dfa-&gt;mb_cur_max
OG
l_int|1
)paren
id|need_word_trtable
op_assign
l_int|1
suffix:semicolon
id|dest_states_nl
(braket
id|i
)braket
op_assign
id|re_acquire_state_context
(paren
op_amp
id|err
comma
id|dfa
comma
op_amp
id|follows
comma
id|CONTEXT_NEWLINE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|dest_states_nl
(braket
id|i
)braket
op_eq
l_int|NULL
op_logical_and
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_goto
id|out_free
suffix:semicolon
)brace
r_else
(brace
id|dest_states_word
(braket
id|i
)braket
op_assign
id|dest_states
(braket
id|i
)braket
suffix:semicolon
id|dest_states_nl
(braket
id|i
)braket
op_assign
id|dest_states
(braket
id|i
)braket
suffix:semicolon
)brace
id|bitset_merge
(paren
id|acceptable
comma
id|dests_ch
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|BE
(paren
id|need_word_trtable
comma
l_int|0
)paren
)paren
(brace
multiline_comment|/* We don&squot;t care about whether the following character is a word&n;&t; character, or we are in a single-byte character set so we can&n;&t; discern by looking at the character code: allocate a&n;&t; 256-entry transition table.  */
id|trtable
op_assign
id|state-&gt;trtable
op_assign
(paren
id|re_dfastate_t
op_star
op_star
)paren
id|calloc
(paren
r_sizeof
(paren
id|re_dfastate_t
op_star
)paren
comma
id|SBC_MAX
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|trtable
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_goto
id|out_free
suffix:semicolon
multiline_comment|/* For all characters ch...:  */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|BITSET_WORDS
suffix:semicolon
op_increment
id|i
)paren
r_for
c_loop
(paren
id|ch
op_assign
id|i
op_star
id|BITSET_WORD_BITS
comma
id|elem
op_assign
id|acceptable
(braket
id|i
)braket
comma
id|mask
op_assign
l_int|1
suffix:semicolon
id|elem
suffix:semicolon
id|mask
op_lshift_assign
l_int|1
comma
id|elem
op_rshift_assign
l_int|1
comma
op_increment
id|ch
)paren
r_if
c_cond
(paren
id|BE
(paren
id|elem
op_amp
l_int|1
comma
l_int|0
)paren
)paren
(brace
multiline_comment|/* There must be exactly one destination which accepts&n;&t;&t; character ch.  See group_nodes_into_DFAstates.  */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
(paren
id|dests_ch
(braket
id|j
)braket
(braket
id|i
)braket
op_amp
id|mask
)paren
op_eq
l_int|0
suffix:semicolon
op_increment
id|j
)paren
suffix:semicolon
multiline_comment|/* j-th destination accepts the word character ch.  */
r_if
c_cond
(paren
id|dfa-&gt;word_char
(braket
id|i
)braket
op_amp
id|mask
)paren
id|trtable
(braket
id|ch
)braket
op_assign
id|dest_states_word
(braket
id|j
)braket
suffix:semicolon
r_else
id|trtable
(braket
id|ch
)braket
op_assign
id|dest_states
(braket
id|j
)braket
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* We care about whether the following character is a word&n;&t; character, and we are in a multi-byte character set: discern&n;&t; by looking at the character code: build two 256-entry&n;&t; transition tables, one starting at trtable[0] and one&n;&t; starting at trtable[SBC_MAX].  */
id|trtable
op_assign
id|state-&gt;word_trtable
op_assign
(paren
id|re_dfastate_t
op_star
op_star
)paren
id|calloc
(paren
r_sizeof
(paren
id|re_dfastate_t
op_star
)paren
comma
l_int|2
op_star
id|SBC_MAX
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|trtable
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_goto
id|out_free
suffix:semicolon
multiline_comment|/* For all characters ch...:  */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|BITSET_WORDS
suffix:semicolon
op_increment
id|i
)paren
r_for
c_loop
(paren
id|ch
op_assign
id|i
op_star
id|BITSET_WORD_BITS
comma
id|elem
op_assign
id|acceptable
(braket
id|i
)braket
comma
id|mask
op_assign
l_int|1
suffix:semicolon
id|elem
suffix:semicolon
id|mask
op_lshift_assign
l_int|1
comma
id|elem
op_rshift_assign
l_int|1
comma
op_increment
id|ch
)paren
r_if
c_cond
(paren
id|BE
(paren
id|elem
op_amp
l_int|1
comma
l_int|0
)paren
)paren
(brace
multiline_comment|/* There must be exactly one destination which accepts&n;&t;&t; character ch.  See group_nodes_into_DFAstates.  */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
(paren
id|dests_ch
(braket
id|j
)braket
(braket
id|i
)braket
op_amp
id|mask
)paren
op_eq
l_int|0
suffix:semicolon
op_increment
id|j
)paren
suffix:semicolon
multiline_comment|/* j-th destination accepts the word character ch.  */
id|trtable
(braket
id|ch
)braket
op_assign
id|dest_states
(braket
id|j
)braket
suffix:semicolon
id|trtable
(braket
id|ch
op_plus
id|SBC_MAX
)braket
op_assign
id|dest_states_word
(braket
id|j
)braket
suffix:semicolon
)brace
)brace
multiline_comment|/* new line */
r_if
c_cond
(paren
id|bitset_contain
(paren
id|acceptable
comma
id|NEWLINE_CHAR
)paren
)paren
(brace
multiline_comment|/* The current state accepts newline character.  */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|ndests
suffix:semicolon
op_increment
id|j
)paren
r_if
c_cond
(paren
id|bitset_contain
(paren
id|dests_ch
(braket
id|j
)braket
comma
id|NEWLINE_CHAR
)paren
)paren
(brace
multiline_comment|/* k-th destination accepts newline character.  */
id|trtable
(braket
id|NEWLINE_CHAR
)braket
op_assign
id|dest_states_nl
(braket
id|j
)braket
suffix:semicolon
r_if
c_cond
(paren
id|need_word_trtable
)paren
id|trtable
(braket
id|NEWLINE_CHAR
op_plus
id|SBC_MAX
)braket
op_assign
id|dest_states_nl
(braket
id|j
)braket
suffix:semicolon
multiline_comment|/* There must be only one destination which accepts&n;&t;       newline.  See group_nodes_into_DFAstates.  */
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|dest_states_malloced
)paren
id|free
(paren
id|dest_states
)paren
suffix:semicolon
id|re_node_set_free
(paren
op_amp
id|follows
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ndests
suffix:semicolon
op_increment
id|i
)paren
id|re_node_set_free
(paren
id|dests_node
op_plus
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dests_node_malloced
)paren
id|free
(paren
id|dests_alloc
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Group all nodes belonging to STATE into several destinations.&n;   Then for all destinations, set the nodes belonging to the destination&n;   to DESTS_NODE[i] and set the characters accepted by the destination&n;   to DEST_CH[i].  This function return the number of destinations.  */
r_static
r_int
id|internal_function
DECL|function|group_nodes_into_DFAstates
id|group_nodes_into_DFAstates
(paren
r_const
id|re_dfa_t
op_star
id|dfa
comma
r_const
id|re_dfastate_t
op_star
id|state
comma
id|re_node_set
op_star
id|dests_node
comma
id|bitset_t
op_star
id|dests_ch
)paren
(brace
id|reg_errcode_t
id|err
suffix:semicolon
r_int
id|result
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|k
suffix:semicolon
r_int
id|ndests
suffix:semicolon
multiline_comment|/* Number of the destinations from `state&squot;.  */
id|bitset_t
id|accepts
suffix:semicolon
multiline_comment|/* Characters a node can accept.  */
r_const
id|re_node_set
op_star
id|cur_nodes
op_assign
op_amp
id|state-&gt;nodes
suffix:semicolon
id|bitset_empty
(paren
id|accepts
)paren
suffix:semicolon
id|ndests
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* For all the nodes belonging to `state&squot;,  */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cur_nodes-&gt;nelem
suffix:semicolon
op_increment
id|i
)paren
(brace
id|re_token_t
op_star
id|node
op_assign
op_amp
id|dfa-&gt;nodes
(braket
id|cur_nodes-&gt;elems
(braket
id|i
)braket
)braket
suffix:semicolon
id|re_token_type_t
id|type
op_assign
id|node-&gt;type
suffix:semicolon
r_int
r_int
id|constraint
op_assign
id|node-&gt;constraint
suffix:semicolon
multiline_comment|/* Enumerate all single byte character this node can accept.  */
r_if
c_cond
(paren
id|type
op_eq
id|CHARACTER
)paren
id|bitset_set
(paren
id|accepts
comma
id|node-&gt;opr.c
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|type
op_eq
id|SIMPLE_BRACKET
)paren
(brace
id|bitset_merge
(paren
id|accepts
comma
id|node-&gt;opr.sbcset
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|type
op_eq
id|OP_PERIOD
)paren
(brace
macro_line|#ifdef RE_ENABLE_I18N
r_if
c_cond
(paren
id|dfa-&gt;mb_cur_max
OG
l_int|1
)paren
id|bitset_merge
(paren
id|accepts
comma
id|dfa-&gt;sb_char
)paren
suffix:semicolon
r_else
macro_line|#endif
id|bitset_set_all
(paren
id|accepts
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|dfa-&gt;syntax
op_amp
id|RE_DOT_NEWLINE
)paren
)paren
id|bitset_clear
(paren
id|accepts
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dfa-&gt;syntax
op_amp
id|RE_DOT_NOT_NULL
)paren
id|bitset_clear
(paren
id|accepts
comma
l_char|&squot;&bslash;0&squot;
)paren
suffix:semicolon
)brace
macro_line|#ifdef RE_ENABLE_I18N
r_else
r_if
c_cond
(paren
id|type
op_eq
id|OP_UTF8_PERIOD
)paren
(brace
id|memset
(paren
id|accepts
comma
l_char|&squot;&bslash;xff&squot;
comma
r_sizeof
(paren
id|bitset_t
)paren
op_div
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|dfa-&gt;syntax
op_amp
id|RE_DOT_NEWLINE
)paren
)paren
id|bitset_clear
(paren
id|accepts
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dfa-&gt;syntax
op_amp
id|RE_DOT_NOT_NULL
)paren
id|bitset_clear
(paren
id|accepts
comma
l_char|&squot;&bslash;0&squot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_else
r_continue
suffix:semicolon
multiline_comment|/* Check the `accepts&squot; and sift the characters which are not&n;&t; match it the context.  */
r_if
c_cond
(paren
id|constraint
)paren
(brace
r_if
c_cond
(paren
id|constraint
op_amp
id|NEXT_NEWLINE_CONSTRAINT
)paren
(brace
r_bool
id|accepts_newline
op_assign
id|bitset_contain
(paren
id|accepts
comma
id|NEWLINE_CHAR
)paren
suffix:semicolon
id|bitset_empty
(paren
id|accepts
)paren
suffix:semicolon
r_if
c_cond
(paren
id|accepts_newline
)paren
id|bitset_set
(paren
id|accepts
comma
id|NEWLINE_CHAR
)paren
suffix:semicolon
r_else
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|constraint
op_amp
id|NEXT_ENDBUF_CONSTRAINT
)paren
(brace
id|bitset_empty
(paren
id|accepts
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|constraint
op_amp
id|NEXT_WORD_CONSTRAINT
)paren
(brace
id|bitset_word_t
id|any_set
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|CHARACTER
op_logical_and
op_logical_neg
id|node-&gt;word_char
)paren
(brace
id|bitset_empty
(paren
id|accepts
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
macro_line|#ifdef RE_ENABLE_I18N
r_if
c_cond
(paren
id|dfa-&gt;mb_cur_max
OG
l_int|1
)paren
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|BITSET_WORDS
suffix:semicolon
op_increment
id|j
)paren
id|any_set
op_or_assign
(paren
id|accepts
(braket
id|j
)braket
op_and_assign
(paren
id|dfa-&gt;word_char
(braket
id|j
)braket
op_or
op_complement
id|dfa-&gt;sb_char
(braket
id|j
)braket
)paren
)paren
suffix:semicolon
r_else
macro_line|#endif
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|BITSET_WORDS
suffix:semicolon
op_increment
id|j
)paren
id|any_set
op_or_assign
(paren
id|accepts
(braket
id|j
)braket
op_and_assign
id|dfa-&gt;word_char
(braket
id|j
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|any_set
)paren
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|constraint
op_amp
id|NEXT_NOTWORD_CONSTRAINT
)paren
(brace
id|bitset_word_t
id|any_set
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|CHARACTER
op_logical_and
id|node-&gt;word_char
)paren
(brace
id|bitset_empty
(paren
id|accepts
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
macro_line|#ifdef RE_ENABLE_I18N
r_if
c_cond
(paren
id|dfa-&gt;mb_cur_max
OG
l_int|1
)paren
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|BITSET_WORDS
suffix:semicolon
op_increment
id|j
)paren
id|any_set
op_or_assign
(paren
id|accepts
(braket
id|j
)braket
op_and_assign
op_complement
(paren
id|dfa-&gt;word_char
(braket
id|j
)braket
op_amp
id|dfa-&gt;sb_char
(braket
id|j
)braket
)paren
)paren
suffix:semicolon
r_else
macro_line|#endif
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|BITSET_WORDS
suffix:semicolon
op_increment
id|j
)paren
id|any_set
op_or_assign
(paren
id|accepts
(braket
id|j
)braket
op_and_assign
op_complement
id|dfa-&gt;word_char
(braket
id|j
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|any_set
)paren
r_continue
suffix:semicolon
)brace
)brace
multiline_comment|/* Then divide `accepts&squot; into DFA states, or create a new&n;&t; state.  Above, we make sure that accepts is not empty.  */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|ndests
suffix:semicolon
op_increment
id|j
)paren
(brace
id|bitset_t
id|intersec
suffix:semicolon
multiline_comment|/* Intersection sets, see below.  */
id|bitset_t
id|remains
suffix:semicolon
multiline_comment|/* Flags, see below.  */
id|bitset_word_t
id|has_intersec
comma
id|not_subset
comma
id|not_consumed
suffix:semicolon
multiline_comment|/* Optimization, skip if this state doesn&squot;t accept the character.  */
r_if
c_cond
(paren
id|type
op_eq
id|CHARACTER
op_logical_and
op_logical_neg
id|bitset_contain
(paren
id|dests_ch
(braket
id|j
)braket
comma
id|node-&gt;opr.c
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* Enumerate the intersection set of this state and `accepts&squot;.  */
id|has_intersec
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|BITSET_WORDS
suffix:semicolon
op_increment
id|k
)paren
id|has_intersec
op_or_assign
id|intersec
(braket
id|k
)braket
op_assign
id|accepts
(braket
id|k
)braket
op_amp
id|dests_ch
(braket
id|j
)braket
(braket
id|k
)braket
suffix:semicolon
multiline_comment|/* And skip if the intersection set is empty.  */
r_if
c_cond
(paren
op_logical_neg
id|has_intersec
)paren
r_continue
suffix:semicolon
multiline_comment|/* Then check if this state is a subset of `accepts&squot;.  */
id|not_subset
op_assign
id|not_consumed
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|BITSET_WORDS
suffix:semicolon
op_increment
id|k
)paren
(brace
id|not_subset
op_or_assign
id|remains
(braket
id|k
)braket
op_assign
op_complement
id|accepts
(braket
id|k
)braket
op_amp
id|dests_ch
(braket
id|j
)braket
(braket
id|k
)braket
suffix:semicolon
id|not_consumed
op_or_assign
id|accepts
(braket
id|k
)braket
op_assign
id|accepts
(braket
id|k
)braket
op_amp
op_complement
id|dests_ch
(braket
id|j
)braket
(braket
id|k
)braket
suffix:semicolon
)brace
multiline_comment|/* If this state isn&squot;t a subset of `accepts&squot;, create a&n;&t;     new group state, which has the `remains&squot;. */
r_if
c_cond
(paren
id|not_subset
)paren
(brace
id|bitset_copy
(paren
id|dests_ch
(braket
id|ndests
)braket
comma
id|remains
)paren
suffix:semicolon
id|bitset_copy
(paren
id|dests_ch
(braket
id|j
)braket
comma
id|intersec
)paren
suffix:semicolon
id|err
op_assign
id|re_node_set_init_copy
(paren
id|dests_node
op_plus
id|ndests
comma
op_amp
id|dests_node
(braket
id|j
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_goto
id|error_return
suffix:semicolon
op_increment
id|ndests
suffix:semicolon
)brace
multiline_comment|/* Put the position in the current group. */
id|result
op_assign
id|re_node_set_insert
(paren
op_amp
id|dests_node
(braket
id|j
)braket
comma
id|cur_nodes-&gt;elems
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|result
OL
l_int|0
comma
l_int|0
)paren
)paren
r_goto
id|error_return
suffix:semicolon
multiline_comment|/* If all characters are consumed, go to next node. */
r_if
c_cond
(paren
op_logical_neg
id|not_consumed
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* Some characters remain, create a new group. */
r_if
c_cond
(paren
id|j
op_eq
id|ndests
)paren
(brace
id|bitset_copy
(paren
id|dests_ch
(braket
id|ndests
)braket
comma
id|accepts
)paren
suffix:semicolon
id|err
op_assign
id|re_node_set_init_1
(paren
id|dests_node
op_plus
id|ndests
comma
id|cur_nodes-&gt;elems
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|err
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_goto
id|error_return
suffix:semicolon
op_increment
id|ndests
suffix:semicolon
id|bitset_empty
(paren
id|accepts
)paren
suffix:semicolon
)brace
)brace
r_return
id|ndests
suffix:semicolon
id|error_return
suffix:colon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|ndests
suffix:semicolon
op_increment
id|j
)paren
id|re_node_set_free
(paren
id|dests_node
op_plus
id|j
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef RE_ENABLE_I18N
multiline_comment|/* Check how many bytes the node `dfa-&gt;nodes[node_idx]&squot; accepts.&n;   Return the number of the bytes the node accepts.&n;   STR_IDX is the current index of the input string.&n;&n;   This function handles the nodes which can accept one character, or&n;   one collating element like &squot;.&squot;, &squot;[a-z]&squot;, opposite to the other nodes&n;   can only accept one byte.  */
r_static
r_int
id|internal_function
DECL|function|check_node_accept_bytes
id|check_node_accept_bytes
(paren
r_const
id|re_dfa_t
op_star
id|dfa
comma
r_int
id|node_idx
comma
r_const
id|re_string_t
op_star
id|input
comma
r_int
id|str_idx
)paren
(brace
r_const
id|re_token_t
op_star
id|node
op_assign
id|dfa-&gt;nodes
op_plus
id|node_idx
suffix:semicolon
r_int
id|char_len
comma
id|elem_len
suffix:semicolon
r_int
id|i
suffix:semicolon
id|wint_t
id|wc
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|node-&gt;type
op_eq
id|OP_UTF8_PERIOD
comma
l_int|0
)paren
)paren
(brace
r_int
r_char
id|c
op_assign
id|re_string_byte_at
(paren
id|input
comma
id|str_idx
)paren
comma
id|d
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|c
OL
l_int|0xc2
comma
l_int|1
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|str_idx
op_plus
l_int|2
OG
id|input-&gt;len
)paren
r_return
l_int|0
suffix:semicolon
id|d
op_assign
id|re_string_byte_at
(paren
id|input
comma
id|str_idx
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
OL
l_int|0xe0
)paren
r_return
(paren
id|d
template_param
l_int|0xbf
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|2
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c
OL
l_int|0xf0
)paren
(brace
id|char_len
op_assign
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_int|0xe0
op_logical_and
id|d
OL
l_int|0xa0
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|c
OL
l_int|0xf8
)paren
(brace
id|char_len
op_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_int|0xf0
op_logical_and
id|d
OL
l_int|0x90
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|c
OL
l_int|0xfc
)paren
(brace
id|char_len
op_assign
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_int|0xf8
op_logical_and
id|d
OL
l_int|0x88
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|c
OL
l_int|0xfe
)paren
(brace
id|char_len
op_assign
l_int|6
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_int|0xfc
op_logical_and
id|d
OL
l_int|0x84
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|str_idx
op_plus
id|char_len
OG
id|input-&gt;len
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|char_len
suffix:semicolon
op_increment
id|i
)paren
(brace
id|d
op_assign
id|re_string_byte_at
(paren
id|input
comma
id|str_idx
op_plus
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|d
template_param
l_int|0xbf
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|char_len
suffix:semicolon
)brace
id|char_len
op_assign
id|re_string_char_size_at
(paren
id|input
comma
id|str_idx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|node-&gt;type
op_eq
id|OP_PERIOD
)paren
(brace
r_if
c_cond
(paren
id|char_len
op_le
l_int|1
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* FIXME: I don&squot;t think this if is needed, as both &squot;&bslash;n&squot;&n;&t; and &squot;&bslash;0&squot; are char_len == 1.  */
multiline_comment|/* &squot;.&squot; accepts any one character except the following two cases.  */
r_if
c_cond
(paren
(paren
op_logical_neg
(paren
id|dfa-&gt;syntax
op_amp
id|RE_DOT_NEWLINE
)paren
op_logical_and
id|re_string_byte_at
(paren
id|input
comma
id|str_idx
)paren
op_eq
l_char|&squot;&bslash;n&squot;
)paren
op_logical_or
(paren
(paren
id|dfa-&gt;syntax
op_amp
id|RE_DOT_NOT_NULL
)paren
op_logical_and
id|re_string_byte_at
(paren
id|input
comma
id|str_idx
)paren
op_eq
l_char|&squot;&bslash;0&squot;
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|char_len
suffix:semicolon
)brace
id|elem_len
op_assign
id|re_string_elem_size_at
(paren
id|input
comma
id|str_idx
)paren
suffix:semicolon
id|wc
op_assign
id|__btowc
c_func
(paren
op_star
(paren
id|input-&gt;mbs
op_plus
id|str_idx
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|elem_len
op_le
l_int|1
op_logical_and
id|char_len
op_le
l_int|1
)paren
op_logical_or
id|char_len
op_eq
l_int|0
)paren
op_logical_and
(paren
id|wc
op_ne
id|WEOF
op_logical_and
id|wc
OL
id|SBC_MAX
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|node-&gt;type
op_eq
id|COMPLEX_BRACKET
)paren
(brace
r_const
id|re_charset_t
op_star
id|cset
op_assign
id|node-&gt;opr.mbcset
suffix:semicolon
macro_line|# ifdef _LIBC
r_const
r_int
r_char
op_star
id|pin
op_assign
(paren
(paren
r_const
r_int
r_char
op_star
)paren
id|re_string_get_buffer
(paren
id|input
)paren
op_plus
id|str_idx
)paren
suffix:semicolon
r_int
id|j
suffix:semicolon
r_uint32
id|nrules
suffix:semicolon
macro_line|# endif /* _LIBC */
r_int
id|match_len
op_assign
l_int|0
suffix:semicolon
m_wchar_t
id|wc
op_assign
(paren
(paren
id|cset-&gt;nranges
op_logical_or
id|cset-&gt;nchar_classes
op_logical_or
id|cset-&gt;nmbchars
)paren
ques
c_cond
id|re_string_wchar_at
(paren
id|input
comma
id|str_idx
)paren
suffix:colon
l_int|0
)paren
suffix:semicolon
multiline_comment|/* match with multibyte character?  */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cset-&gt;nmbchars
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
id|wc
op_eq
id|cset-&gt;mbchars
(braket
id|i
)braket
)paren
(brace
id|match_len
op_assign
id|char_len
suffix:semicolon
r_goto
id|check_node_accept_bytes_match
suffix:semicolon
)brace
multiline_comment|/* match with character_class?  */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cset-&gt;nchar_classes
suffix:semicolon
op_increment
id|i
)paren
(brace
id|wctype_t
id|wt
op_assign
id|cset-&gt;char_classes
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|__iswctype
(paren
id|wc
comma
id|wt
)paren
)paren
(brace
id|match_len
op_assign
id|char_len
suffix:semicolon
r_goto
id|check_node_accept_bytes_match
suffix:semicolon
)brace
)brace
macro_line|# ifdef _LIBC
id|nrules
op_assign
id|_NL_CURRENT_WORD
(paren
id|LC_COLLATE
comma
id|_NL_COLLATE_NRULES
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nrules
op_ne
l_int|0
)paren
(brace
r_int
r_int
id|in_collseq
op_assign
l_int|0
suffix:semicolon
r_const
r_int32
op_star
id|table
comma
op_star
id|indirect
suffix:semicolon
r_const
r_int
r_char
op_star
id|weights
comma
op_star
id|extra
suffix:semicolon
r_const
r_char
op_star
id|collseqwc
suffix:semicolon
multiline_comment|/* This #include defines a local function!  */
macro_line|#  include &lt;locale/weight.h&gt;
multiline_comment|/* match with collating_symbol?  */
r_if
c_cond
(paren
id|cset-&gt;ncoll_syms
)paren
id|extra
op_assign
(paren
r_const
r_int
r_char
op_star
)paren
id|_NL_CURRENT
(paren
id|LC_COLLATE
comma
id|_NL_COLLATE_SYMB_EXTRAMB
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cset-&gt;ncoll_syms
suffix:semicolon
op_increment
id|i
)paren
(brace
r_const
r_int
r_char
op_star
id|coll_sym
op_assign
id|extra
op_plus
id|cset-&gt;coll_syms
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* Compare the length of input collating element and&n;&t;&t; the length of current collating element.  */
r_if
c_cond
(paren
op_star
id|coll_sym
op_ne
id|elem_len
)paren
r_continue
suffix:semicolon
multiline_comment|/* Compare each bytes.  */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
op_star
id|coll_sym
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
id|pin
(braket
id|j
)braket
op_ne
id|coll_sym
(braket
l_int|1
op_plus
id|j
)braket
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|j
op_eq
op_star
id|coll_sym
)paren
(brace
multiline_comment|/* Match if every bytes is equal.  */
id|match_len
op_assign
id|j
suffix:semicolon
r_goto
id|check_node_accept_bytes_match
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|cset-&gt;nranges
)paren
(brace
r_if
c_cond
(paren
id|elem_len
op_le
id|char_len
)paren
(brace
id|collseqwc
op_assign
id|_NL_CURRENT
(paren
id|LC_COLLATE
comma
id|_NL_COLLATE_COLLSEQWC
)paren
suffix:semicolon
id|in_collseq
op_assign
id|__collseq_table_lookup
(paren
id|collseqwc
comma
id|wc
)paren
suffix:semicolon
)brace
r_else
id|in_collseq
op_assign
id|find_collation_sequence_value
(paren
id|pin
comma
id|elem_len
)paren
suffix:semicolon
)brace
multiline_comment|/* match with range expression?  */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cset-&gt;nranges
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
id|cset-&gt;range_starts
(braket
id|i
)braket
op_le
id|in_collseq
op_logical_and
id|in_collseq
op_le
id|cset-&gt;range_ends
(braket
id|i
)braket
)paren
(brace
id|match_len
op_assign
id|elem_len
suffix:semicolon
r_goto
id|check_node_accept_bytes_match
suffix:semicolon
)brace
multiline_comment|/* match with equivalence_class?  */
r_if
c_cond
(paren
id|cset-&gt;nequiv_classes
)paren
(brace
r_const
r_int
r_char
op_star
id|cp
op_assign
id|pin
suffix:semicolon
id|table
op_assign
(paren
r_const
r_int32
op_star
)paren
id|_NL_CURRENT
(paren
id|LC_COLLATE
comma
id|_NL_COLLATE_TABLEMB
)paren
suffix:semicolon
id|weights
op_assign
(paren
r_const
r_int
r_char
op_star
)paren
id|_NL_CURRENT
(paren
id|LC_COLLATE
comma
id|_NL_COLLATE_WEIGHTMB
)paren
suffix:semicolon
id|extra
op_assign
(paren
r_const
r_int
r_char
op_star
)paren
id|_NL_CURRENT
(paren
id|LC_COLLATE
comma
id|_NL_COLLATE_EXTRAMB
)paren
suffix:semicolon
id|indirect
op_assign
(paren
r_const
r_int32
op_star
)paren
id|_NL_CURRENT
(paren
id|LC_COLLATE
comma
id|_NL_COLLATE_INDIRECTMB
)paren
suffix:semicolon
r_int32
id|idx
op_assign
id|findidx
(paren
op_amp
id|cp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|idx
OG
l_int|0
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cset-&gt;nequiv_classes
suffix:semicolon
op_increment
id|i
)paren
(brace
r_int32
id|equiv_class_idx
op_assign
id|cset-&gt;equiv_classes
(braket
id|i
)braket
suffix:semicolon
r_int
id|weight_len
op_assign
id|weights
(braket
id|idx
op_amp
l_int|0xffffff
)braket
suffix:semicolon
r_if
c_cond
(paren
id|weight_len
op_eq
id|weights
(braket
id|equiv_class_idx
op_amp
l_int|0xffffff
)braket
op_logical_and
(paren
id|idx
op_rshift
l_int|24
)paren
op_eq
(paren
id|equiv_class_idx
op_rshift
l_int|24
)paren
)paren
(brace
r_int
id|cnt
op_assign
l_int|0
suffix:semicolon
id|idx
op_and_assign
l_int|0xffffff
suffix:semicolon
id|equiv_class_idx
op_and_assign
l_int|0xffffff
suffix:semicolon
r_while
c_loop
(paren
id|cnt
op_le
id|weight_len
op_logical_and
(paren
id|weights
(braket
id|equiv_class_idx
op_plus
l_int|1
op_plus
id|cnt
)braket
op_eq
id|weights
(braket
id|idx
op_plus
l_int|1
op_plus
id|cnt
)braket
)paren
)paren
op_increment
id|cnt
suffix:semicolon
r_if
c_cond
(paren
id|cnt
OG
id|weight_len
)paren
(brace
id|match_len
op_assign
id|elem_len
suffix:semicolon
r_goto
id|check_node_accept_bytes_match
suffix:semicolon
)brace
)brace
)brace
)brace
)brace
r_else
macro_line|# endif /* _LIBC */
(brace
multiline_comment|/* match with range expression?  */
macro_line|#if __GNUC__ &gt;= 2
m_wchar_t
id|cmp_buf
(braket
)braket
op_assign
(brace
id|L
l_char|&squot;&bslash;0&squot;
comma
id|L
l_char|&squot;&bslash;0&squot;
comma
id|wc
comma
id|L
l_char|&squot;&bslash;0&squot;
comma
id|L
l_char|&squot;&bslash;0&squot;
comma
id|L
l_char|&squot;&bslash;0&squot;
)brace
suffix:semicolon
macro_line|#else
m_wchar_t
id|cmp_buf
(braket
)braket
op_assign
(brace
id|L
l_char|&squot;&bslash;0&squot;
comma
id|L
l_char|&squot;&bslash;0&squot;
comma
id|L
l_char|&squot;&bslash;0&squot;
comma
id|L
l_char|&squot;&bslash;0&squot;
comma
id|L
l_char|&squot;&bslash;0&squot;
comma
id|L
l_char|&squot;&bslash;0&squot;
)brace
suffix:semicolon
id|cmp_buf
(braket
l_int|2
)braket
op_assign
id|wc
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cset-&gt;nranges
suffix:semicolon
op_increment
id|i
)paren
(brace
id|cmp_buf
(braket
l_int|0
)braket
op_assign
id|cset-&gt;range_starts
(braket
id|i
)braket
suffix:semicolon
id|cmp_buf
(braket
l_int|4
)braket
op_assign
id|cset-&gt;range_ends
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|wcscoll
(paren
id|cmp_buf
comma
id|cmp_buf
op_plus
l_int|2
)paren
op_le
l_int|0
op_logical_and
id|wcscoll
(paren
id|cmp_buf
op_plus
l_int|2
comma
id|cmp_buf
op_plus
l_int|4
)paren
op_le
l_int|0
)paren
(brace
id|match_len
op_assign
id|char_len
suffix:semicolon
r_goto
id|check_node_accept_bytes_match
suffix:semicolon
)brace
)brace
)brace
id|check_node_accept_bytes_match
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|cset-&gt;non_match
)paren
r_return
id|match_len
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|match_len
OG
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_else
r_return
(paren
id|elem_len
OG
id|char_len
)paren
ques
c_cond
id|elem_len
suffix:colon
id|char_len
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|# ifdef _LIBC
r_static
r_int
r_int
id|internal_function
DECL|function|find_collation_sequence_value
id|find_collation_sequence_value
(paren
r_const
r_int
r_char
op_star
id|mbs
comma
r_int
id|mbs_len
)paren
(brace
r_uint32
id|nrules
op_assign
id|_NL_CURRENT_WORD
(paren
id|LC_COLLATE
comma
id|_NL_COLLATE_NRULES
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nrules
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|mbs_len
op_eq
l_int|1
)paren
(brace
multiline_comment|/* No valid character.  Match it as a single byte character.  */
r_const
r_int
r_char
op_star
id|collseq
op_assign
(paren
r_const
r_int
r_char
op_star
)paren
id|_NL_CURRENT
(paren
id|LC_COLLATE
comma
id|_NL_COLLATE_COLLSEQMB
)paren
suffix:semicolon
r_return
id|collseq
(braket
id|mbs
(braket
l_int|0
)braket
)braket
suffix:semicolon
)brace
r_return
id|UINT_MAX
suffix:semicolon
)brace
r_else
(brace
r_int32
id|idx
suffix:semicolon
r_const
r_int
r_char
op_star
id|extra
op_assign
(paren
r_const
r_int
r_char
op_star
)paren
id|_NL_CURRENT
(paren
id|LC_COLLATE
comma
id|_NL_COLLATE_SYMB_EXTRAMB
)paren
suffix:semicolon
r_int32
id|extrasize
op_assign
(paren
r_const
r_int
r_char
op_star
)paren
id|_NL_CURRENT
(paren
id|LC_COLLATE
comma
id|_NL_COLLATE_SYMB_EXTRAMB
op_plus
l_int|1
)paren
id|extra
suffix:semicolon
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
id|extrasize
suffix:semicolon
)paren
(brace
r_int
id|mbs_cnt
comma
id|found
op_assign
l_int|0
suffix:semicolon
r_int32
id|elem_mbs_len
suffix:semicolon
multiline_comment|/* Skip the name of collating element name.  */
id|idx
op_assign
id|idx
op_plus
id|extra
(braket
id|idx
)braket
op_plus
l_int|1
suffix:semicolon
id|elem_mbs_len
op_assign
id|extra
(braket
id|idx
op_increment
)braket
suffix:semicolon
r_if
c_cond
(paren
id|mbs_len
op_eq
id|elem_mbs_len
)paren
(brace
r_for
c_loop
(paren
id|mbs_cnt
op_assign
l_int|0
suffix:semicolon
id|mbs_cnt
OL
id|elem_mbs_len
suffix:semicolon
op_increment
id|mbs_cnt
)paren
r_if
c_cond
(paren
id|extra
(braket
id|idx
op_plus
id|mbs_cnt
)braket
op_ne
id|mbs
(braket
id|mbs_cnt
)braket
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|mbs_cnt
op_eq
id|elem_mbs_len
)paren
multiline_comment|/* Found the entry.  */
id|found
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Skip the byte sequence of the collating element.  */
id|idx
op_add_assign
id|elem_mbs_len
suffix:semicolon
multiline_comment|/* Adjust for the alignment.  */
id|idx
op_assign
(paren
id|idx
op_plus
l_int|3
)paren
op_amp
op_complement
l_int|3
suffix:semicolon
multiline_comment|/* Skip the collation sequence value.  */
id|idx
op_add_assign
r_sizeof
(paren
r_uint32
)paren
suffix:semicolon
multiline_comment|/* Skip the wide char sequence of the collating element.  */
id|idx
op_assign
id|idx
op_plus
r_sizeof
(paren
r_uint32
)paren
op_star
(paren
id|extra
(braket
id|idx
)braket
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* If we found the entry, return the sequence value.  */
r_if
c_cond
(paren
id|found
)paren
r_return
op_star
(paren
r_uint32
op_star
)paren
(paren
id|extra
op_plus
id|idx
)paren
suffix:semicolon
multiline_comment|/* Skip the collation sequence value.  */
id|idx
op_add_assign
r_sizeof
(paren
r_uint32
)paren
suffix:semicolon
)brace
r_return
id|UINT_MAX
suffix:semicolon
)brace
)brace
macro_line|# endif /* _LIBC */
macro_line|#endif /* RE_ENABLE_I18N */
multiline_comment|/* Check whether the node accepts the byte which is IDX-th&n;   byte of the INPUT.  */
r_static
r_int
id|internal_function
DECL|function|check_node_accept
id|check_node_accept
(paren
r_const
id|re_match_context_t
op_star
id|mctx
comma
r_const
id|re_token_t
op_star
id|node
comma
r_int
id|idx
)paren
(brace
r_int
r_char
id|ch
suffix:semicolon
id|ch
op_assign
id|re_string_byte_at
(paren
op_amp
id|mctx-&gt;input
comma
id|idx
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|node-&gt;type
)paren
(brace
r_case
id|CHARACTER
suffix:colon
r_if
c_cond
(paren
id|node-&gt;opr.c
op_ne
id|ch
)paren
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIMPLE_BRACKET
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|bitset_contain
(paren
id|node-&gt;opr.sbcset
comma
id|ch
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef RE_ENABLE_I18N
r_case
id|OP_UTF8_PERIOD
suffix:colon
r_if
c_cond
(paren
id|ch
op_ge
l_int|0x80
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
macro_line|#endif
r_case
id|OP_PERIOD
suffix:colon
r_if
c_cond
(paren
(paren
id|ch
op_eq
l_char|&squot;&bslash;n&squot;
op_logical_and
op_logical_neg
(paren
id|mctx-&gt;dfa-&gt;syntax
op_amp
id|RE_DOT_NEWLINE
)paren
)paren
op_logical_or
(paren
id|ch
op_eq
l_char|&squot;&bslash;0&squot;
op_logical_and
(paren
id|mctx-&gt;dfa-&gt;syntax
op_amp
id|RE_DOT_NOT_NULL
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|node-&gt;constraint
)paren
(brace
multiline_comment|/* The node has constraints.  Check whether the current context&n;&t; satisfies the constraints.  */
r_int
r_int
id|context
op_assign
id|re_string_context_at
(paren
op_amp
id|mctx-&gt;input
comma
id|idx
comma
id|mctx-&gt;eflags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NOT_SATISFY_NEXT_CONSTRAINT
(paren
id|node-&gt;constraint
comma
id|context
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Extend the buffers, if the buffers have run out.  */
r_static
id|reg_errcode_t
id|internal_function
DECL|function|extend_buffers
id|extend_buffers
(paren
id|re_match_context_t
op_star
id|mctx
)paren
(brace
id|reg_errcode_t
id|ret
suffix:semicolon
id|re_string_t
op_star
id|pstr
op_assign
op_amp
id|mctx-&gt;input
suffix:semicolon
multiline_comment|/* Avoid overflow.  */
r_if
c_cond
(paren
id|BE
(paren
id|INT_MAX
op_div
l_int|2
op_div
r_sizeof
(paren
id|re_dfastate_t
op_star
)paren
op_le
id|pstr-&gt;bufs_len
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
multiline_comment|/* Double the lengthes of the buffers.  */
id|ret
op_assign
id|re_string_realloc_buffers
(paren
id|pstr
comma
id|pstr-&gt;bufs_len
op_star
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|ret
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|mctx-&gt;state_log
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* And double the length of state_log.  */
multiline_comment|/* XXX We have no indication of the size of this buffer.  If this&n;&t; allocation fail we have no indication that the state_log array&n;&t; does not have the right size.  */
id|re_dfastate_t
op_star
op_star
id|new_array
op_assign
id|re_realloc
(paren
id|mctx-&gt;state_log
comma
id|re_dfastate_t
op_star
comma
id|pstr-&gt;bufs_len
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|new_array
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
id|mctx-&gt;state_log
op_assign
id|new_array
suffix:semicolon
)brace
multiline_comment|/* Then reconstruct the buffers.  */
r_if
c_cond
(paren
id|pstr-&gt;icase
)paren
(brace
macro_line|#ifdef RE_ENABLE_I18N
r_if
c_cond
(paren
id|pstr-&gt;mb_cur_max
OG
l_int|1
)paren
(brace
id|ret
op_assign
id|build_wcs_upper_buffer
(paren
id|pstr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|ret
op_ne
id|REG_NOERROR
comma
l_int|0
)paren
)paren
r_return
id|ret
suffix:semicolon
)brace
r_else
macro_line|#endif /* RE_ENABLE_I18N  */
id|build_upper_buffer
(paren
id|pstr
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef RE_ENABLE_I18N
r_if
c_cond
(paren
id|pstr-&gt;mb_cur_max
OG
l_int|1
)paren
id|build_wcs_buffer
(paren
id|pstr
)paren
suffix:semicolon
r_else
macro_line|#endif /* RE_ENABLE_I18N  */
(brace
r_if
c_cond
(paren
id|pstr-&gt;trans
op_ne
l_int|NULL
)paren
id|re_string_translate_buffer
(paren
id|pstr
)paren
suffix:semicolon
)brace
)brace
r_return
id|REG_NOERROR
suffix:semicolon
)brace
"&f;"
multiline_comment|/* Functions for matching context.  */
multiline_comment|/* Initialize MCTX.  */
r_static
id|reg_errcode_t
id|internal_function
DECL|function|match_ctx_init
id|match_ctx_init
(paren
id|re_match_context_t
op_star
id|mctx
comma
r_int
id|eflags
comma
r_int
id|n
)paren
(brace
id|mctx-&gt;eflags
op_assign
id|eflags
suffix:semicolon
id|mctx-&gt;match_last
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|n
OG
l_int|0
)paren
(brace
id|mctx-&gt;bkref_ents
op_assign
id|re_malloc
(paren
r_struct
id|re_backref_cache_entry
comma
id|n
)paren
suffix:semicolon
id|mctx-&gt;sub_tops
op_assign
id|re_malloc
(paren
id|re_sub_match_top_t
op_star
comma
id|n
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|mctx-&gt;bkref_ents
op_eq
l_int|NULL
op_logical_or
id|mctx-&gt;sub_tops
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
)brace
multiline_comment|/* Already zero-ed by the caller.&n;     else&n;       mctx-&gt;bkref_ents = NULL;&n;     mctx-&gt;nbkref_ents = 0;&n;     mctx-&gt;nsub_tops = 0;  */
id|mctx-&gt;abkref_ents
op_assign
id|n
suffix:semicolon
id|mctx-&gt;max_mb_elem_len
op_assign
l_int|1
suffix:semicolon
id|mctx-&gt;asub_tops
op_assign
id|n
suffix:semicolon
r_return
id|REG_NOERROR
suffix:semicolon
)brace
multiline_comment|/* Clean the entries which depend on the current input in MCTX.&n;   This function must be invoked when the matcher changes the start index&n;   of the input, or changes the input string.  */
r_static
r_void
id|internal_function
DECL|function|match_ctx_clean
id|match_ctx_clean
(paren
id|re_match_context_t
op_star
id|mctx
)paren
(brace
r_int
id|st_idx
suffix:semicolon
r_for
c_loop
(paren
id|st_idx
op_assign
l_int|0
suffix:semicolon
id|st_idx
OL
id|mctx-&gt;nsub_tops
suffix:semicolon
op_increment
id|st_idx
)paren
(brace
r_int
id|sl_idx
suffix:semicolon
id|re_sub_match_top_t
op_star
id|top
op_assign
id|mctx-&gt;sub_tops
(braket
id|st_idx
)braket
suffix:semicolon
r_for
c_loop
(paren
id|sl_idx
op_assign
l_int|0
suffix:semicolon
id|sl_idx
OL
id|top-&gt;nlasts
suffix:semicolon
op_increment
id|sl_idx
)paren
(brace
id|re_sub_match_last_t
op_star
id|last
op_assign
id|top-&gt;lasts
(braket
id|sl_idx
)braket
suffix:semicolon
id|re_free
(paren
id|last-&gt;path.array
)paren
suffix:semicolon
id|re_free
(paren
id|last
)paren
suffix:semicolon
)brace
id|re_free
(paren
id|top-&gt;lasts
)paren
suffix:semicolon
r_if
c_cond
(paren
id|top-&gt;path
)paren
(brace
id|re_free
(paren
id|top-&gt;path-&gt;array
)paren
suffix:semicolon
id|re_free
(paren
id|top-&gt;path
)paren
suffix:semicolon
)brace
id|free
(paren
id|top
)paren
suffix:semicolon
)brace
id|mctx-&gt;nsub_tops
op_assign
l_int|0
suffix:semicolon
id|mctx-&gt;nbkref_ents
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Free all the memory associated with MCTX.  */
r_static
r_void
id|internal_function
DECL|function|match_ctx_free
id|match_ctx_free
(paren
id|re_match_context_t
op_star
id|mctx
)paren
(brace
multiline_comment|/* First, free all the memory associated with MCTX-&gt;SUB_TOPS.  */
id|match_ctx_clean
(paren
id|mctx
)paren
suffix:semicolon
id|re_free
(paren
id|mctx-&gt;sub_tops
)paren
suffix:semicolon
id|re_free
(paren
id|mctx-&gt;bkref_ents
)paren
suffix:semicolon
)brace
multiline_comment|/* Add a new backreference entry to MCTX.&n;   Note that we assume that caller never call this function with duplicate&n;   entry, and call with STR_IDX which isn&squot;t smaller than any existing entry.&n;*/
r_static
id|reg_errcode_t
id|internal_function
DECL|function|match_ctx_add_entry
id|match_ctx_add_entry
(paren
id|re_match_context_t
op_star
id|mctx
comma
r_int
id|node
comma
r_int
id|str_idx
comma
r_int
id|from
comma
r_int
id|to
)paren
(brace
r_if
c_cond
(paren
id|mctx-&gt;nbkref_ents
op_ge
id|mctx-&gt;abkref_ents
)paren
(brace
r_struct
id|re_backref_cache_entry
op_star
id|new_entry
suffix:semicolon
id|new_entry
op_assign
id|re_realloc
(paren
id|mctx-&gt;bkref_ents
comma
r_struct
id|re_backref_cache_entry
comma
id|mctx-&gt;abkref_ents
op_star
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|new_entry
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
(brace
id|re_free
(paren
id|mctx-&gt;bkref_ents
)paren
suffix:semicolon
r_return
id|REG_ESPACE
suffix:semicolon
)brace
id|mctx-&gt;bkref_ents
op_assign
id|new_entry
suffix:semicolon
id|memset
(paren
id|mctx-&gt;bkref_ents
op_plus
id|mctx-&gt;nbkref_ents
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
r_struct
id|re_backref_cache_entry
)paren
op_star
id|mctx-&gt;abkref_ents
)paren
suffix:semicolon
id|mctx-&gt;abkref_ents
op_mul_assign
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mctx-&gt;nbkref_ents
OG
l_int|0
op_logical_and
id|mctx-&gt;bkref_ents
(braket
id|mctx-&gt;nbkref_ents
l_int|1
)braket
dot
id|str_idx
op_eq
id|str_idx
)paren
id|mctx-&gt;bkref_ents
(braket
id|mctx-&gt;nbkref_ents
l_int|1
)braket
dot
id|more
op_assign
l_int|1
suffix:semicolon
id|mctx-&gt;bkref_ents
(braket
id|mctx-&gt;nbkref_ents
)braket
dot
id|node
op_assign
id|node
suffix:semicolon
id|mctx-&gt;bkref_ents
(braket
id|mctx-&gt;nbkref_ents
)braket
dot
id|str_idx
op_assign
id|str_idx
suffix:semicolon
id|mctx-&gt;bkref_ents
(braket
id|mctx-&gt;nbkref_ents
)braket
dot
id|subexp_from
op_assign
id|from
suffix:semicolon
id|mctx-&gt;bkref_ents
(braket
id|mctx-&gt;nbkref_ents
)braket
dot
id|subexp_to
op_assign
id|to
suffix:semicolon
multiline_comment|/* This is a cache that saves negative results of check_dst_limits_calc_pos.&n;     If bit N is clear, means that this entry won&squot;t epsilon-transition to&n;     an OP_OPEN_SUBEXP or OP_CLOSE_SUBEXP for the N+1-th subexpression.  If&n;     it is set, check_dst_limits_calc_pos_1 will recurse and try to find one&n;     such node.&n;&n;     A backreference does not epsilon-transition unless it is empty, so set&n;     to all zeros if FROM != TO.  */
id|mctx-&gt;bkref_ents
(braket
id|mctx-&gt;nbkref_ents
)braket
dot
id|eps_reachable_subexps_map
op_assign
(paren
id|from
op_eq
id|to
ques
c_cond
op_complement
l_int|0
suffix:colon
l_int|0
)paren
suffix:semicolon
id|mctx-&gt;bkref_ents
(braket
id|mctx-&gt;nbkref_ents
op_increment
)braket
dot
id|more
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|mctx-&gt;max_mb_elem_len
OL
id|to
id|from
)paren
id|mctx-&gt;max_mb_elem_len
op_assign
id|to
id|from
suffix:semicolon
r_return
id|REG_NOERROR
suffix:semicolon
)brace
multiline_comment|/* Search for the first entry which has the same str_idx, or -1 if none is&n;   found.  Note that MCTX-&gt;BKREF_ENTS is already sorted by MCTX-&gt;STR_IDX.  */
r_static
r_int
id|internal_function
DECL|function|search_cur_bkref_entry
id|search_cur_bkref_entry
(paren
r_const
id|re_match_context_t
op_star
id|mctx
comma
r_int
id|str_idx
)paren
(brace
r_int
id|left
comma
id|right
comma
id|mid
comma
id|last
suffix:semicolon
id|last
op_assign
id|right
op_assign
id|mctx-&gt;nbkref_ents
suffix:semicolon
r_for
c_loop
(paren
id|left
op_assign
l_int|0
suffix:semicolon
id|left
OL
id|right
suffix:semicolon
)paren
(brace
id|mid
op_assign
(paren
id|left
op_plus
id|right
)paren
op_div
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|mctx-&gt;bkref_ents
(braket
id|mid
)braket
dot
id|str_idx
OL
id|str_idx
)paren
id|left
op_assign
id|mid
op_plus
l_int|1
suffix:semicolon
r_else
id|right
op_assign
id|mid
suffix:semicolon
)brace
r_if
c_cond
(paren
id|left
OL
id|last
op_logical_and
id|mctx-&gt;bkref_ents
(braket
id|left
)braket
dot
id|str_idx
op_eq
id|str_idx
)paren
r_return
id|left
suffix:semicolon
r_else
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Register the node NODE, whose type is OP_OPEN_SUBEXP, and which matches&n;   at STR_IDX.  */
r_static
id|reg_errcode_t
id|internal_function
DECL|function|match_ctx_add_subtop
id|match_ctx_add_subtop
(paren
id|re_match_context_t
op_star
id|mctx
comma
r_int
id|node
comma
r_int
id|str_idx
)paren
(brace
macro_line|#ifdef DEBUG
m_assert
(paren
id|mctx-&gt;sub_tops
op_ne
l_int|NULL
)paren
suffix:semicolon
m_assert
(paren
id|mctx-&gt;asub_tops
OG
l_int|0
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|BE
(paren
id|mctx-&gt;nsub_tops
op_eq
id|mctx-&gt;asub_tops
comma
l_int|0
)paren
)paren
(brace
r_int
id|new_asub_tops
op_assign
id|mctx-&gt;asub_tops
op_star
l_int|2
suffix:semicolon
id|re_sub_match_top_t
op_star
op_star
id|new_array
op_assign
id|re_realloc
(paren
id|mctx-&gt;sub_tops
comma
id|re_sub_match_top_t
op_star
comma
id|new_asub_tops
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|new_array
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
id|mctx-&gt;sub_tops
op_assign
id|new_array
suffix:semicolon
id|mctx-&gt;asub_tops
op_assign
id|new_asub_tops
suffix:semicolon
)brace
id|mctx-&gt;sub_tops
(braket
id|mctx-&gt;nsub_tops
)braket
op_assign
id|calloc
(paren
l_int|1
comma
r_sizeof
(paren
id|re_sub_match_top_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|mctx-&gt;sub_tops
(braket
id|mctx-&gt;nsub_tops
)braket
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
id|REG_ESPACE
suffix:semicolon
id|mctx-&gt;sub_tops
(braket
id|mctx-&gt;nsub_tops
)braket
op_member_access_from_pointer
id|node
op_assign
id|node
suffix:semicolon
id|mctx-&gt;sub_tops
(braket
id|mctx-&gt;nsub_tops
op_increment
)braket
op_member_access_from_pointer
id|str_idx
op_assign
id|str_idx
suffix:semicolon
r_return
id|REG_NOERROR
suffix:semicolon
)brace
multiline_comment|/* Register the node NODE, whose type is OP_CLOSE_SUBEXP, and which matches&n;   at STR_IDX, whose corresponding OP_OPEN_SUBEXP is SUB_TOP.  */
r_static
id|re_sub_match_last_t
op_star
id|internal_function
DECL|function|match_ctx_add_sublast
id|match_ctx_add_sublast
(paren
id|re_sub_match_top_t
op_star
id|subtop
comma
r_int
id|node
comma
r_int
id|str_idx
)paren
(brace
id|re_sub_match_last_t
op_star
id|new_entry
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|subtop-&gt;nlasts
op_eq
id|subtop-&gt;alasts
comma
l_int|0
)paren
)paren
(brace
r_int
id|new_alasts
op_assign
l_int|2
op_star
id|subtop-&gt;alasts
op_plus
l_int|1
suffix:semicolon
id|re_sub_match_last_t
op_star
op_star
id|new_array
op_assign
id|re_realloc
(paren
id|subtop-&gt;lasts
comma
id|re_sub_match_last_t
op_star
comma
id|new_alasts
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|new_array
op_eq
l_int|NULL
comma
l_int|0
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|subtop-&gt;lasts
op_assign
id|new_array
suffix:semicolon
id|subtop-&gt;alasts
op_assign
id|new_alasts
suffix:semicolon
)brace
id|new_entry
op_assign
id|calloc
(paren
l_int|1
comma
r_sizeof
(paren
id|re_sub_match_last_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BE
(paren
id|new_entry
op_ne
l_int|NULL
comma
l_int|1
)paren
)paren
(brace
id|subtop-&gt;lasts
(braket
id|subtop-&gt;nlasts
)braket
op_assign
id|new_entry
suffix:semicolon
id|new_entry-&gt;node
op_assign
id|node
suffix:semicolon
id|new_entry-&gt;str_idx
op_assign
id|str_idx
suffix:semicolon
op_increment
id|subtop-&gt;nlasts
suffix:semicolon
)brace
r_return
id|new_entry
suffix:semicolon
)brace
r_static
r_void
id|internal_function
DECL|function|sift_ctx_init
id|sift_ctx_init
(paren
id|re_sift_context_t
op_star
id|sctx
comma
id|re_dfastate_t
op_star
op_star
id|sifted_sts
comma
id|re_dfastate_t
op_star
op_star
id|limited_sts
comma
r_int
id|last_node
comma
r_int
id|last_str_idx
)paren
(brace
id|sctx-&gt;sifted_states
op_assign
id|sifted_sts
suffix:semicolon
id|sctx-&gt;limited_states
op_assign
id|limited_sts
suffix:semicolon
id|sctx-&gt;last_node
op_assign
id|last_node
suffix:semicolon
id|sctx-&gt;last_str_idx
op_assign
id|last_str_idx
suffix:semicolon
id|re_node_set_init_empty
(paren
op_amp
id|sctx-&gt;limits
)paren
suffix:semicolon
)brace
eof
