multiline_comment|/* Extended regular expression matching and search library,&n;   version 0.12.&n;   (Implements POSIX draft P10003.2/D11.2, except for&n;   internationalization features.)&n;&n;   Copyright (C) 1993 Free Software Foundation, Inc.&n;&n;   This program is free software; you can redistribute it and/or modify&n;   it under the terms of the GNU General Public License as published by&n;   the Free Software Foundation; either version 2, or (at your option)&n;   any later version.&n;&n;   This program is distributed in the hope that it will be useful,&n;   but WITHOUT ANY WARRANTY; without even the implied warranty of&n;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n;   GNU General Public License for more details.&n;&n;   You should have received a copy of the GNU General Public License&n;   along with this program; if not, write to the Free Software&n;   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
multiline_comment|/* AIX requires this to be the first thing in the file. */
macro_line|#if defined (_AIX) &amp;&amp; !defined (REGEX_MALLOC)
macro_line|#pragma alloca
macro_line|#endif
DECL|macro|_GNU_SOURCE
mdefine_line|#define _GNU_SOURCE
multiline_comment|/* We need this for `regex.h&squot;, and perhaps for the Emacs include files.  */
macro_line|#include &lt;sys/types.h&gt;
multiline_comment|/* We used to test for `BSTRING&squot; here, but only GCC and Emacs define&n;   `BSTRING&squot;, as far as I know, and neither of them use this code.  */
macro_line|#include &lt;string.h&gt;
macro_line|#ifndef bcmp
DECL|macro|bcmp
mdefine_line|#define bcmp(s1, s2, n)&t;memcmp ((s1), (s2), (n))
macro_line|#endif
macro_line|#ifndef bcopy
DECL|macro|bcopy
mdefine_line|#define bcopy(s, d, n)&t;memcpy ((d), (s), (n))
macro_line|#endif
macro_line|#ifndef bzero
DECL|macro|bzero
mdefine_line|#define bzero(s, n)&t;memset ((s), 0, (n))
macro_line|#endif
macro_line|#include &lt;stdlib.h&gt;
multiline_comment|/* Define the syntax stuff for &bslash;&lt;, &bslash;&gt;, etc.  */
multiline_comment|/* This must be nonzero for the wordchar and notwordchar pattern&n;   commands in re_match_2.  */
macro_line|#ifndef Sword
DECL|macro|Sword
mdefine_line|#define Sword 1
macro_line|#endif
macro_line|#ifdef SYNTAX_TABLE
r_extern
r_char
op_star
id|re_syntax_table
suffix:semicolon
macro_line|#else /* not SYNTAX_TABLE */
multiline_comment|/* How many characters in the character set.  */
DECL|macro|CHAR_SET_SIZE
mdefine_line|#define CHAR_SET_SIZE 256
DECL|variable|re_syntax_table
r_static
r_char
id|re_syntax_table
(braket
id|CHAR_SET_SIZE
)braket
suffix:semicolon
r_static
r_void
DECL|function|init_syntax_once
id|init_syntax_once
(paren
)paren
(brace
r_register
r_int
id|c
suffix:semicolon
r_static
r_int
id|done
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|done
)paren
r_return
suffix:semicolon
id|bzero
(paren
id|re_syntax_table
comma
r_sizeof
id|re_syntax_table
)paren
suffix:semicolon
r_for
c_loop
(paren
id|c
op_assign
l_char|&squot;a&squot;
suffix:semicolon
id|c
op_le
l_char|&squot;z&squot;
suffix:semicolon
id|c
op_increment
)paren
id|re_syntax_table
(braket
id|c
)braket
op_assign
id|Sword
suffix:semicolon
r_for
c_loop
(paren
id|c
op_assign
l_char|&squot;A&squot;
suffix:semicolon
id|c
op_le
l_char|&squot;Z&squot;
suffix:semicolon
id|c
op_increment
)paren
id|re_syntax_table
(braket
id|c
)braket
op_assign
id|Sword
suffix:semicolon
r_for
c_loop
(paren
id|c
op_assign
l_char|&squot;0&squot;
suffix:semicolon
id|c
op_le
l_char|&squot;9&squot;
suffix:semicolon
id|c
op_increment
)paren
id|re_syntax_table
(braket
id|c
)braket
op_assign
id|Sword
suffix:semicolon
id|re_syntax_table
(braket
l_char|&squot;_&squot;
)braket
op_assign
id|Sword
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#endif /* not SYNTAX_TABLE */
DECL|macro|SYNTAX
mdefine_line|#define SYNTAX(c) re_syntax_table[c]
"&f;"
multiline_comment|/* Get the interface, including the syntax bits.  */
macro_line|#include &quot;regex.h&quot;
multiline_comment|/* isalpha etc. are used for the character classes.  */
macro_line|#include &lt;ctype.h&gt;
macro_line|#ifndef isascii
DECL|macro|isascii
mdefine_line|#define isascii(c) 1
macro_line|#endif
macro_line|#ifdef isblank
DECL|macro|ISBLANK
mdefine_line|#define ISBLANK(c) (isascii (c) &amp;&amp; isblank (c))
macro_line|#else
DECL|macro|ISBLANK
mdefine_line|#define ISBLANK(c) ((c) == &squot; &squot; || (c) == &squot;&bslash;t&squot;)
macro_line|#endif
macro_line|#ifdef isgraph
DECL|macro|ISGRAPH
mdefine_line|#define ISGRAPH(c) (isascii (c) &amp;&amp; isgraph (c))
macro_line|#else
DECL|macro|ISGRAPH
mdefine_line|#define ISGRAPH(c) (isascii (c) &amp;&amp; isprint (c) &amp;&amp; !isspace (c))
macro_line|#endif
DECL|macro|ISPRINT
mdefine_line|#define ISPRINT(c) (isascii (c) &amp;&amp; isprint (c))
DECL|macro|ISDIGIT
mdefine_line|#define ISDIGIT(c) (isascii (c) &amp;&amp; isdigit (c))
DECL|macro|ISALNUM
mdefine_line|#define ISALNUM(c) (isascii (c) &amp;&amp; isalnum (c))
DECL|macro|ISALPHA
mdefine_line|#define ISALPHA(c) (isascii (c) &amp;&amp; isalpha (c))
DECL|macro|ISCNTRL
mdefine_line|#define ISCNTRL(c) (isascii (c) &amp;&amp; iscntrl (c))
DECL|macro|ISLOWER
mdefine_line|#define ISLOWER(c) (isascii (c) &amp;&amp; islower (c))
DECL|macro|ISPUNCT
mdefine_line|#define ISPUNCT(c) (isascii (c) &amp;&amp; ispunct (c))
DECL|macro|ISSPACE
mdefine_line|#define ISSPACE(c) (isascii (c) &amp;&amp; isspace (c))
DECL|macro|ISUPPER
mdefine_line|#define ISUPPER(c) (isascii (c) &amp;&amp; isupper (c))
DECL|macro|ISXDIGIT
mdefine_line|#define ISXDIGIT(c) (isascii (c) &amp;&amp; isxdigit (c))
macro_line|#ifndef NULL
DECL|macro|NULL
mdefine_line|#define NULL 0
macro_line|#endif
multiline_comment|/* We remove any previous definition of `SIGN_EXTEND_CHAR&squot;,&n;   since ours (we hope) works properly with all combinations of&n;   machines, compilers, `char&squot; and `unsigned char&squot; argument types.&n;   (Per Bothner suggested the basic approach.)  */
DECL|macro|SIGN_EXTEND_CHAR
macro_line|#undef SIGN_EXTEND_CHAR
macro_line|#if __STDC__
DECL|macro|SIGN_EXTEND_CHAR
mdefine_line|#define SIGN_EXTEND_CHAR(c) ((signed char) (c))
macro_line|#else  /* not __STDC__ */
multiline_comment|/* As in Harbison and Steele.  */
DECL|macro|SIGN_EXTEND_CHAR
mdefine_line|#define SIGN_EXTEND_CHAR(c) ((((unsigned char) (c)) ^ 128) - 128)
macro_line|#endif
"&f;"
multiline_comment|/* Should we use malloc or alloca?  If REGEX_MALLOC is not defined, we&n;   use `alloca&squot; instead of `malloc&squot;.  This is because using malloc in&n;   re_search* or re_match* could cause memory leaks when C-g is used in&n;   Emacs; also, malloc is slower and causes storage fragmentation.  On&n;   the other hand, malloc is more portable, and easier to debug.&n;&n;   Because we sometimes use alloca, some routines have to be macros,&n;   not functions -- `alloca&squot;-allocated space disappears at the end of the&n;   function it is called in.  */
macro_line|#ifdef REGEX_MALLOC
DECL|macro|REGEX_ALLOCATE
mdefine_line|#define REGEX_ALLOCATE malloc
DECL|macro|REGEX_REALLOCATE
mdefine_line|#define REGEX_REALLOCATE(source, osize, nsize) realloc (source, nsize)
macro_line|#else /* not REGEX_MALLOC  */
multiline_comment|/* Emacs already defines alloca, sometimes.  */
macro_line|#ifndef alloca
multiline_comment|/* Make alloca work the best possible way.  */
macro_line|#ifdef __GNUC__
DECL|macro|alloca
mdefine_line|#define alloca __builtin_alloca
macro_line|#else /* not __GNUC__ */
macro_line|#if HAVE_ALLOCA_H
macro_line|#include &lt;alloca.h&gt;
macro_line|#else /* not __GNUC__ or HAVE_ALLOCA_H */
macro_line|#ifndef _AIX /* Already did AIX, up at the top.  */
r_char
op_star
id|alloca
(paren
)paren
suffix:semicolon
macro_line|#endif /* not _AIX */
macro_line|#endif /* not HAVE_ALLOCA_H */
macro_line|#endif /* not __GNUC__ */
macro_line|#endif /* not alloca */
DECL|macro|REGEX_ALLOCATE
mdefine_line|#define REGEX_ALLOCATE alloca
multiline_comment|/* Assumes a `char *destination&squot; variable.  */
DECL|macro|REGEX_REALLOCATE
mdefine_line|#define REGEX_REALLOCATE(source, osize, nsize)&t;&t;&t;&t;&bslash;&n;  (destination = (char *) alloca (nsize),&t;&t;&t;&t;&bslash;&n;   bcopy (source, destination, osize),&t;&t;&t;&t;&t;&bslash;&n;   destination)
macro_line|#endif /* not REGEX_MALLOC */
multiline_comment|/* True if `size1&squot; is non-NULL and PTR is pointing anywhere inside&n;   `string1&squot; or just past its end.  This works if PTR is NULL, which is&n;   a good thing.  */
DECL|macro|FIRST_STRING_P
mdefine_line|#define FIRST_STRING_P(ptr) &t;&t;&t;&t;&t;&bslash;&n;  (size1 &amp;&amp; string1 &lt;= (ptr) &amp;&amp; (ptr) &lt;= string1 + size1)
multiline_comment|/* (Re)Allocate N items of type T using malloc, or fail.  */
DECL|macro|TALLOC
mdefine_line|#define TALLOC(n, t) ((t *) malloc ((n) * sizeof (t)))
DECL|macro|RETALLOC
mdefine_line|#define RETALLOC(addr, n, t) ((addr) = (t *) realloc (addr, (n) * sizeof (t)))
DECL|macro|REGEX_TALLOC
mdefine_line|#define REGEX_TALLOC(n, t) ((t *) REGEX_ALLOCATE ((n) * sizeof (t)))
DECL|macro|BYTEWIDTH
mdefine_line|#define BYTEWIDTH 8 /* In bits.  */
DECL|macro|STREQ
mdefine_line|#define STREQ(s1, s2) ((strcmp (s1, s2) == 0))
DECL|macro|MAX
mdefine_line|#define MAX(a, b) ((a) &gt; (b) ? (a) : (b))
DECL|macro|MIN
mdefine_line|#define MIN(a, b) ((a) &lt; (b) ? (a) : (b))
DECL|typedef|boolean
r_typedef
r_char
id|boolean
suffix:semicolon
DECL|macro|false
mdefine_line|#define false 0
DECL|macro|true
mdefine_line|#define true 1
"&f;"
multiline_comment|/* These are the command codes that appear in compiled regular&n;   expressions.  Some opcodes are followed by argument bytes.  A&n;   command code can specify any interpretation whatsoever for its&n;   arguments.  Zero bytes may appear in the compiled regular expression.&n;&n;   The value of `exactn&squot; is needed in search.c (search_buffer) in Emacs.&n;   So regex.h defines a symbol `RE_EXACTN_VALUE&squot; to be 1; the value of&n;   `exactn&squot; we use here must also be 1.  */
r_typedef
r_enum
(brace
DECL|enumerator|no_op
id|no_op
op_assign
l_int|0
comma
multiline_comment|/* Followed by one byte giving n, then by n literal bytes.  */
DECL|enumerator|exactn
id|exactn
op_assign
l_int|1
comma
multiline_comment|/* Matches any (more or less) character.  */
DECL|enumerator|anychar
id|anychar
comma
multiline_comment|/* Matches any one char belonging to specified set.  First&n;&t;   following byte is number of bitmap bytes.  Then come bytes&n;&t;   for a bitmap saying which chars are in.  Bits in each byte&n;&t;   are ordered low-bit-first.  A character is in the set if its&n;&t;   bit is 1.  A character too large to have a bit in the map is&n;&t;   automatically not in the set.  */
DECL|enumerator|charset
id|charset
comma
multiline_comment|/* Same parameters as charset, but match any character that is&n;&t;   not one of those specified.  */
DECL|enumerator|charset_not
id|charset_not
comma
multiline_comment|/* Start remembering the text that is matched, for storing in a&n;&t;   register.  Followed by one byte with the register number, in&n;&t;   the range 0 to one less than the pattern buffer&squot;s re_nsub&n;&t;   field.  Then followed by one byte with the number of groups&n;&t;   inner to this one.  (This last has to be part of the&n;&t;   start_memory only because we need it in the on_failure_jump&n;&t;   of re_match_2.)  */
DECL|enumerator|start_memory
id|start_memory
comma
multiline_comment|/* Stop remembering the text that is matched and store it in a&n;&t;   memory register.  Followed by one byte with the register&n;&t;   number, in the range 0 to one less than `re_nsub&squot; in the&n;&t;   pattern buffer, and one byte with the number of inner groups,&n;&t;   just like `start_memory&squot;.  (We need the number of inner&n;&t;   groups here because we don&squot;t have any easy way of finding the&n;&t;   corresponding start_memory when we&squot;re at a stop_memory.)  */
DECL|enumerator|stop_memory
id|stop_memory
comma
multiline_comment|/* Match a duplicate of something remembered. Followed by one&n;&t;   byte containing the register number.  */
DECL|enumerator|duplicate
id|duplicate
comma
multiline_comment|/* Fail unless at beginning of line.  */
DECL|enumerator|begline
id|begline
comma
multiline_comment|/* Fail unless at end of line.  */
DECL|enumerator|endline
id|endline
comma
multiline_comment|/* Succeeds if at beginning of buffer (if emacs) or at beginning&n;&t;   of string to be matched (if not).  */
DECL|enumerator|begbuf
id|begbuf
comma
multiline_comment|/* Analogously, for end of buffer/string.  */
DECL|enumerator|endbuf
id|endbuf
comma
multiline_comment|/* Followed by two byte relative address to which to jump.  */
DECL|enumerator|jump
id|jump
comma
multiline_comment|/* Same as jump, but marks the end of an alternative.  */
DECL|enumerator|jump_past_alt
id|jump_past_alt
comma
multiline_comment|/* Followed by two-byte relative address of place to resume at&n;&t;   in case of failure.  */
DECL|enumerator|on_failure_jump
id|on_failure_jump
comma
multiline_comment|/* Like on_failure_jump, but pushes a placeholder instead of the&n;&t;   current string position when executed.  */
DECL|enumerator|on_failure_keep_string_jump
id|on_failure_keep_string_jump
comma
multiline_comment|/* Throw away latest failure point and then jump to following&n;&t;   two-byte relative address.  */
DECL|enumerator|pop_failure_jump
id|pop_failure_jump
comma
multiline_comment|/* Change to pop_failure_jump if know won&squot;t have to backtrack to&n;&t;   match; otherwise change to jump.  This is used to jump&n;&t;   back to the beginning of a repeat.  If what follows this jump&n;&t;   clearly won&squot;t match what the repeat does, such that we can be&n;&t;   sure that there is no use backtracking out of repetitions&n;&t;   already matched, then we change it to a pop_failure_jump.&n;&t;   Followed by two-byte address.  */
DECL|enumerator|maybe_pop_jump
id|maybe_pop_jump
comma
multiline_comment|/* Jump to following two-byte address, and push a dummy failure&n;&t;   point. This failure point will be thrown away if an attempt&n;&t;   is made to use it for a failure.  A `+&squot; construct makes this&n;&t;   before the first repeat.  Also used as an intermediary kind&n;&t;   of jump when compiling an alternative.  */
DECL|enumerator|dummy_failure_jump
id|dummy_failure_jump
comma
multiline_comment|/* Push a dummy failure point and continue.  Used at the end of&n;&t;   alternatives.  */
DECL|enumerator|push_dummy_failure
id|push_dummy_failure
comma
multiline_comment|/* Followed by two-byte relative address and two-byte number n.&n;&t;   After matching N times, jump to the address upon failure.  */
DECL|enumerator|succeed_n
id|succeed_n
comma
multiline_comment|/* Followed by two-byte relative address, and two-byte number n.&n;&t;   Jump to the address N times, then fail.  */
DECL|enumerator|jump_n
id|jump_n
comma
multiline_comment|/* Set the following two-byte relative address to the&n;&t;   subsequent two-byte number.  The address *includes* the two&n;&t;   bytes of number.  */
DECL|enumerator|set_number_at
id|set_number_at
comma
DECL|enumerator|wordchar
id|wordchar
comma
multiline_comment|/* Matches any word-constituent character.  */
DECL|enumerator|notwordchar
id|notwordchar
comma
multiline_comment|/* Matches any char that is not a word-constituent.  */
DECL|enumerator|wordbeg
id|wordbeg
comma
multiline_comment|/* Succeeds if at word beginning.  */
DECL|enumerator|wordend
id|wordend
comma
multiline_comment|/* Succeeds if at word end.  */
DECL|enumerator|wordbound
id|wordbound
comma
multiline_comment|/* Succeeds if at a word boundary.  */
DECL|enumerator|notwordbound
id|notwordbound
multiline_comment|/* Succeeds if not at a word boundary.  */
macro_line|#ifdef emacs
DECL|enumerator|before_dot
comma
id|before_dot
comma
multiline_comment|/* Succeeds if before point.  */
DECL|enumerator|at_dot
id|at_dot
comma
multiline_comment|/* Succeeds if at point.  */
DECL|enumerator|after_dot
id|after_dot
comma
multiline_comment|/* Succeeds if after point.  */
multiline_comment|/* Matches any character whose syntax is specified.  Followed by&n;&t;   a byte which contains a syntax code, e.g., Sword.  */
DECL|enumerator|syntaxspec
id|syntaxspec
comma
multiline_comment|/* Matches any character whose syntax is not that specified.  */
DECL|enumerator|notsyntaxspec
id|notsyntaxspec
macro_line|#endif /* emacs */
DECL|typedef|re_opcode_t
)brace
id|re_opcode_t
suffix:semicolon
"&f;"
multiline_comment|/* Common operations on the compiled pattern.  */
multiline_comment|/* Store NUMBER in two contiguous bytes starting at DESTINATION.  */
DECL|macro|STORE_NUMBER
mdefine_line|#define STORE_NUMBER(destination, number)&t;&t;&t;&t;&bslash;&n;  do {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    (destination)[0] = (number) &amp; 0377;&t;&t;&t;&t;&t;&bslash;&n;    (destination)[1] = (number) &gt;&gt; 8;&t;&t;&t;&t;&t;&bslash;&n;  } while (0)
multiline_comment|/* Same as STORE_NUMBER, except increment DESTINATION to&n;   the byte after where the number is stored.  Therefore, DESTINATION&n;   must be an lvalue.  */
DECL|macro|STORE_NUMBER_AND_INCR
mdefine_line|#define STORE_NUMBER_AND_INCR(destination, number)&t;&t;&t;&bslash;&n;  do {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    STORE_NUMBER (destination, number);&t;&t;&t;&t;&t;&bslash;&n;    (destination) += 2;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  } while (0)
multiline_comment|/* Put into DESTINATION a number stored in two contiguous bytes starting&n;   at SOURCE.  */
DECL|macro|EXTRACT_NUMBER
mdefine_line|#define EXTRACT_NUMBER(destination, source)&t;&t;&t;&t;&bslash;&n;  do {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    (destination) = *(source) &amp; 0377;&t;&t;&t;&t;&t;&bslash;&n;    (destination) += SIGN_EXTEND_CHAR (*((source) + 1)) &lt;&lt; 8;&t;&t;&bslash;&n;  } while (0)
macro_line|#ifdef DEBUG
r_static
r_void
DECL|function|extract_number
id|extract_number
(paren
id|dest
comma
id|source
)paren
r_int
op_star
id|dest
suffix:semicolon
r_int
r_char
op_star
id|source
suffix:semicolon
(brace
r_int
id|temp
op_assign
id|SIGN_EXTEND_CHAR
(paren
op_star
(paren
id|source
op_plus
l_int|1
)paren
)paren
suffix:semicolon
op_star
id|dest
op_assign
op_star
id|source
op_amp
l_int|0377
suffix:semicolon
op_star
id|dest
op_add_assign
id|temp
op_lshift
l_int|8
suffix:semicolon
)brace
macro_line|#ifndef EXTRACT_MACROS /* To debug the macros.  */
DECL|macro|EXTRACT_NUMBER
macro_line|#undef EXTRACT_NUMBER
DECL|macro|EXTRACT_NUMBER
mdefine_line|#define EXTRACT_NUMBER(dest, src) extract_number (&amp;dest, src)
macro_line|#endif /* not EXTRACT_MACROS */
macro_line|#endif /* DEBUG */
multiline_comment|/* Same as EXTRACT_NUMBER, except increment SOURCE to after the number.&n;   SOURCE must be an lvalue.  */
DECL|macro|EXTRACT_NUMBER_AND_INCR
mdefine_line|#define EXTRACT_NUMBER_AND_INCR(destination, source)&t;&t;&t;&bslash;&n;  do {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    EXTRACT_NUMBER (destination, source);&t;&t;&t;&t;&bslash;&n;    (source) += 2; &t;&t;&t;&t;&t;&t;&t;&bslash;&n;  } while (0)
macro_line|#ifdef DEBUG
r_static
r_void
DECL|function|extract_number_and_incr
id|extract_number_and_incr
(paren
id|destination
comma
id|source
)paren
r_int
op_star
id|destination
suffix:semicolon
r_int
r_char
op_star
op_star
id|source
suffix:semicolon
(brace
id|extract_number
(paren
id|destination
comma
op_star
id|source
)paren
suffix:semicolon
op_star
id|source
op_add_assign
l_int|2
suffix:semicolon
)brace
macro_line|#ifndef EXTRACT_MACROS
DECL|macro|EXTRACT_NUMBER_AND_INCR
macro_line|#undef EXTRACT_NUMBER_AND_INCR
DECL|macro|EXTRACT_NUMBER_AND_INCR
mdefine_line|#define EXTRACT_NUMBER_AND_INCR(dest, src) &bslash;&n;  extract_number_and_incr (&amp;dest, &amp;src)
macro_line|#endif /* not EXTRACT_MACROS */
macro_line|#endif /* DEBUG */
"&f;"
multiline_comment|/* If DEBUG is defined, Regex prints many voluminous messages about what&n;   it is doing (if the variable `debug&squot; is nonzero).  If linked with the&n;   main program in `iregex.c&squot;, you can enter patterns and strings&n;   interactively.  And if linked with the main program in `main.c&squot; and&n;   the other test files, you can run the already-written tests.  */
macro_line|#ifdef DEBUG
multiline_comment|/* We use standard I/O for debugging.  */
macro_line|#include &lt;stdio.h&gt;
multiline_comment|/* It is useful to test things that ``must&squot;&squot; be true when debugging.  */
macro_line|#include &lt;assert.h&gt;
DECL|variable|debug
r_static
r_int
id|debug
op_assign
l_int|0
suffix:semicolon
DECL|macro|DEBUG_STATEMENT
mdefine_line|#define DEBUG_STATEMENT(e) e
DECL|macro|DEBUG_PRINT1
mdefine_line|#define DEBUG_PRINT1(x) if (debug) printf (x)
DECL|macro|DEBUG_PRINT2
mdefine_line|#define DEBUG_PRINT2(x1, x2) if (debug) printf (x1, x2)
DECL|macro|DEBUG_PRINT3
mdefine_line|#define DEBUG_PRINT3(x1, x2, x3) if (debug) printf (x1, x2, x3)
DECL|macro|DEBUG_PRINT4
mdefine_line|#define DEBUG_PRINT4(x1, x2, x3, x4) if (debug) printf (x1, x2, x3, x4)
DECL|macro|DEBUG_PRINT_COMPILED_PATTERN
mdefine_line|#define DEBUG_PRINT_COMPILED_PATTERN(p, s, e) &t;&t;&t;&t;&bslash;&n;  if (debug) print_partial_compiled_pattern (s, e)
DECL|macro|DEBUG_PRINT_DOUBLE_STRING
mdefine_line|#define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)&t;&t;&t;&bslash;&n;  if (debug) print_double_string (w, s1, sz1, s2, sz2)
r_extern
r_void
id|printchar
(paren
)paren
suffix:semicolon
multiline_comment|/* Print the fastmap in human-readable form.  */
r_void
DECL|function|print_fastmap
id|print_fastmap
(paren
id|fastmap
)paren
r_char
op_star
id|fastmap
suffix:semicolon
(brace
r_int
id|was_a_range
op_assign
l_int|0
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|i
OL
(paren
l_int|1
op_lshift
id|BYTEWIDTH
)paren
)paren
(brace
r_if
c_cond
(paren
id|fastmap
(braket
id|i
op_increment
)braket
)paren
(brace
id|was_a_range
op_assign
l_int|0
suffix:semicolon
id|printchar
(paren
id|i
l_int|1
)paren
suffix:semicolon
r_while
c_loop
(paren
id|i
OL
(paren
l_int|1
op_lshift
id|BYTEWIDTH
)paren
op_logical_and
id|fastmap
(braket
id|i
)braket
)paren
(brace
id|was_a_range
op_assign
l_int|1
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|was_a_range
)paren
(brace
id|printf
(paren
l_string|&quot;-&quot;
)paren
suffix:semicolon
id|printchar
(paren
id|i
l_int|1
)paren
suffix:semicolon
)brace
)brace
)brace
id|putchar
(paren
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Print a compiled pattern string in human-readable form, starting at&n;   the START pointer into it and ending just before the pointer END.  */
r_void
DECL|function|print_partial_compiled_pattern
id|print_partial_compiled_pattern
(paren
id|start
comma
id|end
)paren
r_int
r_char
op_star
id|start
suffix:semicolon
r_int
r_char
op_star
id|end
suffix:semicolon
(brace
r_int
id|mcnt
comma
id|mcnt2
suffix:semicolon
r_int
r_char
op_star
id|p
op_assign
id|start
suffix:semicolon
r_int
r_char
op_star
id|pend
op_assign
id|end
suffix:semicolon
r_if
c_cond
(paren
id|start
op_eq
l_int|NULL
)paren
(brace
id|printf
(paren
l_string|&quot;(null)&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Loop over pattern commands.  */
r_while
c_loop
(paren
id|p
OL
id|pend
)paren
(brace
r_switch
c_cond
(paren
(paren
id|re_opcode_t
)paren
op_star
id|p
op_increment
)paren
(brace
r_case
id|no_op
suffix:colon
id|printf
(paren
l_string|&quot;/no_op&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|exactn
suffix:colon
id|mcnt
op_assign
op_star
id|p
op_increment
suffix:semicolon
id|printf
(paren
l_string|&quot;/exactn/%d&quot;
comma
id|mcnt
)paren
suffix:semicolon
r_do
(brace
id|putchar
(paren
l_char|&squot;/&squot;
)paren
suffix:semicolon
id|printchar
(paren
op_star
id|p
op_increment
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|mcnt
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|start_memory
suffix:colon
id|mcnt
op_assign
op_star
id|p
op_increment
suffix:semicolon
id|printf
(paren
l_string|&quot;/start_memory/%d/%d&quot;
comma
id|mcnt
comma
op_star
id|p
op_increment
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|stop_memory
suffix:colon
id|mcnt
op_assign
op_star
id|p
op_increment
suffix:semicolon
id|printf
(paren
l_string|&quot;/stop_memory/%d/%d&quot;
comma
id|mcnt
comma
op_star
id|p
op_increment
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|duplicate
suffix:colon
id|printf
(paren
l_string|&quot;/duplicate/%d&quot;
comma
op_star
id|p
op_increment
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|anychar
suffix:colon
id|printf
(paren
l_string|&quot;/anychar&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|charset
suffix:colon
r_case
id|charset_not
suffix:colon
(brace
r_register
r_int
id|c
suffix:semicolon
id|printf
(paren
l_string|&quot;/charset%s&quot;
comma
(paren
id|re_opcode_t
)paren
op_star
(paren
id|p
l_int|1
)paren
op_eq
id|charset_not
ques
c_cond
l_string|&quot;_not&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
m_assert
(paren
id|p
op_plus
op_star
id|p
OL
id|pend
)paren
suffix:semicolon
r_for
c_loop
(paren
id|c
op_assign
l_int|0
suffix:semicolon
id|c
OL
op_star
id|p
suffix:semicolon
id|c
op_increment
)paren
(brace
r_int
id|bit
suffix:semicolon
r_int
r_char
id|map_byte
op_assign
id|p
(braket
l_int|1
op_plus
id|c
)braket
suffix:semicolon
id|putchar
(paren
l_char|&squot;/&squot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|bit
op_assign
l_int|0
suffix:semicolon
id|bit
OL
id|BYTEWIDTH
suffix:semicolon
id|bit
op_increment
)paren
r_if
c_cond
(paren
id|map_byte
op_amp
(paren
l_int|1
op_lshift
id|bit
)paren
)paren
id|printchar
(paren
id|c
op_star
id|BYTEWIDTH
op_plus
id|bit
)paren
suffix:semicolon
)brace
id|p
op_add_assign
l_int|1
op_plus
op_star
id|p
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|begline
suffix:colon
id|printf
(paren
l_string|&quot;/begline&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|endline
suffix:colon
id|printf
(paren
l_string|&quot;/endline&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|on_failure_jump
suffix:colon
id|extract_number_and_incr
(paren
op_amp
id|mcnt
comma
op_amp
id|p
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;/on_failure_jump/0/%d&quot;
comma
id|mcnt
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|on_failure_keep_string_jump
suffix:colon
id|extract_number_and_incr
(paren
op_amp
id|mcnt
comma
op_amp
id|p
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;/on_failure_keep_string_jump/0/%d&quot;
comma
id|mcnt
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|dummy_failure_jump
suffix:colon
id|extract_number_and_incr
(paren
op_amp
id|mcnt
comma
op_amp
id|p
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;/dummy_failure_jump/0/%d&quot;
comma
id|mcnt
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|push_dummy_failure
suffix:colon
id|printf
(paren
l_string|&quot;/push_dummy_failure&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|maybe_pop_jump
suffix:colon
id|extract_number_and_incr
(paren
op_amp
id|mcnt
comma
op_amp
id|p
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;/maybe_pop_jump/0/%d&quot;
comma
id|mcnt
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|pop_failure_jump
suffix:colon
id|extract_number_and_incr
(paren
op_amp
id|mcnt
comma
op_amp
id|p
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;/pop_failure_jump/0/%d&quot;
comma
id|mcnt
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|jump_past_alt
suffix:colon
id|extract_number_and_incr
(paren
op_amp
id|mcnt
comma
op_amp
id|p
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;/jump_past_alt/0/%d&quot;
comma
id|mcnt
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|jump
suffix:colon
id|extract_number_and_incr
(paren
op_amp
id|mcnt
comma
op_amp
id|p
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;/jump/0/%d&quot;
comma
id|mcnt
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|succeed_n
suffix:colon
id|extract_number_and_incr
(paren
op_amp
id|mcnt
comma
op_amp
id|p
)paren
suffix:semicolon
id|extract_number_and_incr
(paren
op_amp
id|mcnt2
comma
op_amp
id|p
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;/succeed_n/0/%d/0/%d&quot;
comma
id|mcnt
comma
id|mcnt2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|jump_n
suffix:colon
id|extract_number_and_incr
(paren
op_amp
id|mcnt
comma
op_amp
id|p
)paren
suffix:semicolon
id|extract_number_and_incr
(paren
op_amp
id|mcnt2
comma
op_amp
id|p
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;/jump_n/0/%d/0/%d&quot;
comma
id|mcnt
comma
id|mcnt2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|set_number_at
suffix:colon
id|extract_number_and_incr
(paren
op_amp
id|mcnt
comma
op_amp
id|p
)paren
suffix:semicolon
id|extract_number_and_incr
(paren
op_amp
id|mcnt2
comma
op_amp
id|p
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;/set_number_at/0/%d/0/%d&quot;
comma
id|mcnt
comma
id|mcnt2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|wordbound
suffix:colon
id|printf
(paren
l_string|&quot;/wordbound&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|notwordbound
suffix:colon
id|printf
(paren
l_string|&quot;/notwordbound&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|wordbeg
suffix:colon
id|printf
(paren
l_string|&quot;/wordbeg&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|wordend
suffix:colon
id|printf
(paren
l_string|&quot;/wordend&quot;
)paren
suffix:semicolon
macro_line|#ifdef emacs
r_case
id|before_dot
suffix:colon
id|printf
(paren
l_string|&quot;/before_dot&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|at_dot
suffix:colon
id|printf
(paren
l_string|&quot;/at_dot&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|after_dot
suffix:colon
id|printf
(paren
l_string|&quot;/after_dot&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|syntaxspec
suffix:colon
id|printf
(paren
l_string|&quot;/syntaxspec&quot;
)paren
suffix:semicolon
id|mcnt
op_assign
op_star
id|p
op_increment
suffix:semicolon
id|printf
(paren
l_string|&quot;/%d&quot;
comma
id|mcnt
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|notsyntaxspec
suffix:colon
id|printf
(paren
l_string|&quot;/notsyntaxspec&quot;
)paren
suffix:semicolon
id|mcnt
op_assign
op_star
id|p
op_increment
suffix:semicolon
id|printf
(paren
l_string|&quot;/%d&quot;
comma
id|mcnt
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif /* emacs */
r_case
id|wordchar
suffix:colon
id|printf
(paren
l_string|&quot;/wordchar&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|notwordchar
suffix:colon
id|printf
(paren
l_string|&quot;/notwordchar&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|begbuf
suffix:colon
id|printf
(paren
l_string|&quot;/begbuf&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|endbuf
suffix:colon
id|printf
(paren
l_string|&quot;/endbuf&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printf
(paren
l_string|&quot;?%d&quot;
comma
op_star
(paren
id|p
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
)brace
id|printf
(paren
l_string|&quot;/&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_void
DECL|function|print_compiled_pattern
id|print_compiled_pattern
(paren
id|bufp
)paren
r_struct
id|re_pattern_buffer
op_star
id|bufp
suffix:semicolon
(brace
r_int
r_char
op_star
id|buffer
op_assign
id|bufp-&gt;buffer
suffix:semicolon
id|print_partial_compiled_pattern
(paren
id|buffer
comma
id|buffer
op_plus
id|bufp-&gt;used
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;%d bytes used/%d bytes allocated.&bslash;n&quot;
comma
id|bufp-&gt;used
comma
id|bufp-&gt;allocated
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bufp-&gt;fastmap_accurate
op_logical_and
id|bufp-&gt;fastmap
)paren
(brace
id|printf
(paren
l_string|&quot;fastmap: &quot;
)paren
suffix:semicolon
id|print_fastmap
(paren
id|bufp-&gt;fastmap
)paren
suffix:semicolon
)brace
id|printf
(paren
l_string|&quot;re_nsub: %d&bslash;t&quot;
comma
id|bufp-&gt;re_nsub
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;regs_alloc: %d&bslash;t&quot;
comma
id|bufp-&gt;regs_allocated
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;can_be_null: %d&bslash;t&quot;
comma
id|bufp-&gt;can_be_null
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;newline_anchor: %d&bslash;n&quot;
comma
id|bufp-&gt;newline_anchor
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;no_sub: %d&bslash;t&quot;
comma
id|bufp-&gt;no_sub
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;not_bol: %d&bslash;t&quot;
comma
id|bufp-&gt;not_bol
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;not_eol: %d&bslash;t&quot;
comma
id|bufp-&gt;not_eol
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;syntax: %d&bslash;n&quot;
comma
id|bufp-&gt;syntax
)paren
suffix:semicolon
multiline_comment|/* Perhaps we should print the translate table?  */
)brace
r_void
DECL|function|print_double_string
id|print_double_string
(paren
id|where
comma
id|string1
comma
id|size1
comma
id|string2
comma
id|size2
)paren
r_const
r_char
op_star
id|where
suffix:semicolon
r_const
r_char
op_star
id|string1
suffix:semicolon
r_const
r_char
op_star
id|string2
suffix:semicolon
r_int
id|size1
suffix:semicolon
r_int
id|size2
suffix:semicolon
(brace
r_int
id|this_char
suffix:semicolon
r_if
c_cond
(paren
id|where
op_eq
l_int|NULL
)paren
id|printf
(paren
l_string|&quot;(null)&quot;
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|FIRST_STRING_P
(paren
id|where
)paren
)paren
(brace
r_for
c_loop
(paren
id|this_char
op_assign
id|where
id|string1
suffix:semicolon
id|this_char
OL
id|size1
suffix:semicolon
id|this_char
op_increment
)paren
id|printchar
(paren
id|string1
(braket
id|this_char
)braket
)paren
suffix:semicolon
id|where
op_assign
id|string2
suffix:semicolon
)brace
r_for
c_loop
(paren
id|this_char
op_assign
id|where
id|string2
suffix:semicolon
id|this_char
OL
id|size2
suffix:semicolon
id|this_char
op_increment
)paren
id|printchar
(paren
id|string2
(braket
id|this_char
)braket
)paren
suffix:semicolon
)brace
)brace
macro_line|#else /* not DEBUG */
DECL|macro|assert
macro_line|#undef assert
DECL|macro|assert
mdefine_line|#define assert(e)
DECL|macro|DEBUG_STATEMENT
mdefine_line|#define DEBUG_STATEMENT(e)
DECL|macro|DEBUG_PRINT1
mdefine_line|#define DEBUG_PRINT1(x)
DECL|macro|DEBUG_PRINT2
mdefine_line|#define DEBUG_PRINT2(x1, x2)
DECL|macro|DEBUG_PRINT3
mdefine_line|#define DEBUG_PRINT3(x1, x2, x3)
DECL|macro|DEBUG_PRINT4
mdefine_line|#define DEBUG_PRINT4(x1, x2, x3, x4)
DECL|macro|DEBUG_PRINT_COMPILED_PATTERN
mdefine_line|#define DEBUG_PRINT_COMPILED_PATTERN(p, s, e)
DECL|macro|DEBUG_PRINT_DOUBLE_STRING
mdefine_line|#define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)
macro_line|#endif /* not DEBUG */
"&f;"
multiline_comment|/* Set by `re_set_syntax&squot; to the current regexp syntax to recognize.  Can&n;   also be assigned to arbitrarily: each pattern buffer stores its own&n;   syntax, so it can be changed between regex compilations.  */
DECL|variable|re_syntax_options
id|reg_syntax_t
id|re_syntax_options
op_assign
id|RE_SYNTAX_EMACS
suffix:semicolon
multiline_comment|/* Specify the precise syntax of regexps for compilation.  This provides&n;   for compatibility for various utilities which historically have&n;   different, incompatible syntaxes.&n;&n;   The argument SYNTAX is a bit mask comprised of the various bits&n;   defined in regex.h.  We return the old syntax.  */
id|reg_syntax_t
DECL|function|re_set_syntax
id|re_set_syntax
(paren
id|syntax
)paren
id|reg_syntax_t
id|syntax
suffix:semicolon
(brace
id|reg_syntax_t
id|ret
op_assign
id|re_syntax_options
suffix:semicolon
id|re_syntax_options
op_assign
id|syntax
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
"&f;"
multiline_comment|/* This table gives an error message for each of the error codes listed&n;   in regex.h.  Obviously the order here has to be same as there.  */
DECL|variable|re_error_msg
r_static
r_const
r_char
op_star
id|re_error_msg
(braket
)braket
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* REG_NOERROR */
l_string|&quot;No match&quot;
comma
multiline_comment|/* REG_NOMATCH */
l_string|&quot;Invalid regular expression&quot;
comma
multiline_comment|/* REG_BADPAT */
l_string|&quot;Invalid collation character&quot;
comma
multiline_comment|/* REG_ECOLLATE */
l_string|&quot;Invalid character class name&quot;
comma
multiline_comment|/* REG_ECTYPE */
l_string|&quot;Trailing backslash&quot;
comma
multiline_comment|/* REG_EESCAPE */
l_string|&quot;Invalid back reference&quot;
comma
multiline_comment|/* REG_ESUBREG */
l_string|&quot;Unmatched [ or [^&quot;
comma
multiline_comment|/* REG_EBRACK */
l_string|&quot;Unmatched ( or &bslash;&bslash;(&quot;
comma
multiline_comment|/* REG_EPAREN */
l_string|&quot;Unmatched &bslash;&bslash;{&quot;
comma
multiline_comment|/* REG_EBRACE */
l_string|&quot;Invalid content of &bslash;&bslash;{&bslash;&bslash;}&quot;
comma
multiline_comment|/* REG_BADBR */
l_string|&quot;Invalid range end&quot;
comma
multiline_comment|/* REG_ERANGE */
l_string|&quot;Memory exhausted&quot;
comma
multiline_comment|/* REG_ESPACE */
l_string|&quot;Invalid preceding regular expression&quot;
comma
multiline_comment|/* REG_BADRPT */
l_string|&quot;Premature end of regular expression&quot;
comma
multiline_comment|/* REG_EEND */
l_string|&quot;Regular expression too big&quot;
comma
multiline_comment|/* REG_ESIZE */
l_string|&quot;Unmatched ) or &bslash;&bslash;)&quot;
comma
multiline_comment|/* REG_ERPAREN */
)brace
suffix:semicolon
"&f;"
multiline_comment|/* Subroutine declarations and macros for regex_compile.  */
r_static
r_void
id|store_op1
(paren
)paren
comma
id|store_op2
(paren
)paren
suffix:semicolon
r_static
r_void
id|insert_op1
(paren
)paren
comma
id|insert_op2
(paren
)paren
suffix:semicolon
r_static
id|boolean
id|at_begline_loc_p
(paren
)paren
comma
id|at_endline_loc_p
(paren
)paren
suffix:semicolon
r_static
id|boolean
id|group_in_compile_stack
(paren
)paren
suffix:semicolon
r_static
id|reg_errcode_t
id|compile_range
(paren
)paren
suffix:semicolon
multiline_comment|/* Fetch the next character in the uncompiled pattern---translating it&n;   if necessary.  Also cast from a signed character in the constant&n;   string passed to us by the user to an unsigned char that we can use&n;   as an array index (in, e.g., `translate&squot;).  */
DECL|macro|PATFETCH
mdefine_line|#define PATFETCH(c)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  do {if (p == pend) return REG_EEND;&t;&t;&t;&t;&t;&bslash;&n;    c = (unsigned char) *p++;&t;&t;&t;&t;&t;&t;&bslash;&n;    if (translate) c = translate[c]; &t;&t;&t;&t;&t;&bslash;&n;  } while (0)
multiline_comment|/* Fetch the next character in the uncompiled pattern, with no&n;   translation.  */
DECL|macro|PATFETCH_RAW
mdefine_line|#define PATFETCH_RAW(c)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  do {if (p == pend) return REG_EEND;&t;&t;&t;&t;&t;&bslash;&n;    c = (unsigned char) *p++; &t;&t;&t;&t;&t;&t;&bslash;&n;  } while (0)
multiline_comment|/* Go backwards one character in the pattern.  */
DECL|macro|PATUNFETCH
mdefine_line|#define PATUNFETCH p--
multiline_comment|/* If `translate&squot; is non-null, return translate[D], else just D.  We&n;   cast the subscript to translate because some data is declared as&n;   `char *&squot;, to avoid warnings when a string constant is passed.  But&n;   when we use a character as a subscript we must make it unsigned.  */
DECL|macro|TRANSLATE
mdefine_line|#define TRANSLATE(d) (translate ? translate[(unsigned char) (d)] : (d))
multiline_comment|/* Macros for outputting the compiled pattern into `buffer&squot;.  */
multiline_comment|/* If the buffer isn&squot;t allocated when it comes in, use this.  */
DECL|macro|INIT_BUF_SIZE
mdefine_line|#define INIT_BUF_SIZE  32
multiline_comment|/* Make sure we have at least N more bytes of space in buffer.  */
DECL|macro|GET_BUFFER_SPACE
mdefine_line|#define GET_BUFFER_SPACE(n)&t;&t;&t;&t;&t;&t;&bslash;&n;    while (b - bufp-&gt;buffer + (n) &gt; bufp-&gt;allocated)&t;&t;&t;&bslash;&n;      EXTEND_BUFFER ()
multiline_comment|/* Make sure we have one more byte of buffer space and then add C to it.  */
DECL|macro|BUF_PUSH
mdefine_line|#define BUF_PUSH(c)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  do {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    GET_BUFFER_SPACE (1);&t;&t;&t;&t;&t;&t;&bslash;&n;    *b++ = (unsigned char) (c);&t;&t;&t;&t;&t;&t;&bslash;&n;  } while (0)
multiline_comment|/* Ensure we have two more bytes of buffer space and then append C1 and C2.  */
DECL|macro|BUF_PUSH_2
mdefine_line|#define BUF_PUSH_2(c1, c2)&t;&t;&t;&t;&t;&t;&bslash;&n;  do {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    GET_BUFFER_SPACE (2);&t;&t;&t;&t;&t;&t;&bslash;&n;    *b++ = (unsigned char) (c1);&t;&t;&t;&t;&t;&bslash;&n;    *b++ = (unsigned char) (c2);&t;&t;&t;&t;&t;&bslash;&n;  } while (0)
multiline_comment|/* As with BUF_PUSH_2, except for three bytes.  */
DECL|macro|BUF_PUSH_3
mdefine_line|#define BUF_PUSH_3(c1, c2, c3)&t;&t;&t;&t;&t;&t;&bslash;&n;  do {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    GET_BUFFER_SPACE (3);&t;&t;&t;&t;&t;&t;&bslash;&n;    *b++ = (unsigned char) (c1);&t;&t;&t;&t;&t;&bslash;&n;    *b++ = (unsigned char) (c2);&t;&t;&t;&t;&t;&bslash;&n;    *b++ = (unsigned char) (c3);&t;&t;&t;&t;&t;&bslash;&n;  } while (0)
multiline_comment|/* Store a jump with opcode OP at LOC to location TO.  We store a&n;   relative address offset by the three bytes the jump itself occupies.  */
DECL|macro|STORE_JUMP
mdefine_line|#define STORE_JUMP(op, loc, to) &bslash;&n;  store_op1 (op, loc, (to) - (loc) - 3)
multiline_comment|/* Likewise, for a two-argument jump.  */
DECL|macro|STORE_JUMP2
mdefine_line|#define STORE_JUMP2(op, loc, to, arg) &bslash;&n;  store_op2 (op, loc, (to) - (loc) - 3, arg)
multiline_comment|/* Like `STORE_JUMP&squot;, but for inserting.  Assume `b&squot; is the buffer end.  */
DECL|macro|INSERT_JUMP
mdefine_line|#define INSERT_JUMP(op, loc, to) &bslash;&n;  insert_op1 (op, loc, (to) - (loc) - 3, b)
multiline_comment|/* Like `STORE_JUMP2&squot;, but for inserting.  Assume `b&squot; is the buffer end.  */
DECL|macro|INSERT_JUMP2
mdefine_line|#define INSERT_JUMP2(op, loc, to, arg) &bslash;&n;  insert_op2 (op, loc, (to) - (loc) - 3, arg, b)
multiline_comment|/* This is not an arbitrary limit: the arguments which represent offsets&n;   into the pattern are two bytes long.  So if 2^16 bytes turns out to&n;   be too small, many things would have to change.  */
DECL|macro|MAX_BUF_SIZE
mdefine_line|#define MAX_BUF_SIZE (1L &lt;&lt; 16)
multiline_comment|/* Extend the buffer by twice its current size via realloc and&n;   reset the pointers that pointed into the old block to point to the&n;   correct places in the new one.  If extending the buffer results in it&n;   being larger than MAX_BUF_SIZE, then flag memory exhausted.  */
DECL|macro|EXTEND_BUFFER
mdefine_line|#define EXTEND_BUFFER()&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  do { &t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    unsigned char *old_buffer = bufp-&gt;buffer;&t;&t;&t;&t;&bslash;&n;    if (bufp-&gt;allocated == MAX_BUF_SIZE) &t;&t;&t;&t;&bslash;&n;      return REG_ESIZE;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    bufp-&gt;allocated &lt;&lt;= 1;&t;&t;&t;&t;&t;&t;&bslash;&n;    if (bufp-&gt;allocated &gt; MAX_BUF_SIZE)&t;&t;&t;&t;&t;&bslash;&n;      bufp-&gt;allocated = MAX_BUF_SIZE; &t;&t;&t;&t;&t;&bslash;&n;    bufp-&gt;buffer = (unsigned char *) realloc (bufp-&gt;buffer, bufp-&gt;allocated);&bslash;&n;    if (bufp-&gt;buffer == NULL)&t;&t;&t;&t;&t;&t;&bslash;&n;      return REG_ESPACE;&t;&t;&t;&t;&t;&t;&bslash;&n;    /* If the buffer moved, move all the pointers into it.  */&t;&t;&bslash;&n;    if (old_buffer != bufp-&gt;buffer)&t;&t;&t;&t;&t;&bslash;&n;      {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;b = (b - old_buffer) + bufp-&gt;buffer;&t;&t;&t;&t;&bslash;&n;&t;begalt = (begalt - old_buffer) + bufp-&gt;buffer;&t;&t;&t;&bslash;&n;&t;if (fixup_alt_jump)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;  fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp-&gt;buffer;&bslash;&n;&t;if (laststart)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;  laststart = (laststart - old_buffer) + bufp-&gt;buffer;&t;&t;&bslash;&n;&t;if (pending_exact)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;  pending_exact = (pending_exact - old_buffer) + bufp-&gt;buffer;&t;&bslash;&n;      }&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  } while (0)
multiline_comment|/* Since we have one byte reserved for the register number argument to&n;   {start,stop}_memory, the maximum number of groups we can report&n;   things about is what fits in that byte.  */
DECL|macro|MAX_REGNUM
mdefine_line|#define MAX_REGNUM 255
multiline_comment|/* But patterns can have more than `MAX_REGNUM&squot; registers.  We just&n;   ignore the excess.  */
DECL|typedef|regnum_t
r_typedef
r_int
id|regnum_t
suffix:semicolon
multiline_comment|/* Macros for the compile stack.  */
multiline_comment|/* Since offsets can go either forwards or backwards, this type needs to&n;   be able to hold values from -(MAX_BUF_SIZE - 1) to MAX_BUF_SIZE - 1.  */
DECL|typedef|pattern_offset_t
r_typedef
r_int
id|pattern_offset_t
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|begalt_offset
id|pattern_offset_t
id|begalt_offset
suffix:semicolon
DECL|member|fixup_alt_jump
id|pattern_offset_t
id|fixup_alt_jump
suffix:semicolon
DECL|member|inner_group_offset
id|pattern_offset_t
id|inner_group_offset
suffix:semicolon
DECL|member|laststart_offset
id|pattern_offset_t
id|laststart_offset
suffix:semicolon
DECL|member|regnum
id|regnum_t
id|regnum
suffix:semicolon
DECL|typedef|compile_stack_elt_t
)brace
id|compile_stack_elt_t
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|stack
id|compile_stack_elt_t
op_star
id|stack
suffix:semicolon
DECL|member|size
r_int
id|size
suffix:semicolon
DECL|member|avail
r_int
id|avail
suffix:semicolon
multiline_comment|/* Offset of next open position.  */
DECL|typedef|compile_stack_type
)brace
id|compile_stack_type
suffix:semicolon
DECL|macro|INIT_COMPILE_STACK_SIZE
mdefine_line|#define INIT_COMPILE_STACK_SIZE 32
DECL|macro|COMPILE_STACK_EMPTY
mdefine_line|#define COMPILE_STACK_EMPTY  (compile_stack.avail == 0)
DECL|macro|COMPILE_STACK_FULL
mdefine_line|#define COMPILE_STACK_FULL  (compile_stack.avail == compile_stack.size)
multiline_comment|/* The next available element.  */
DECL|macro|COMPILE_STACK_TOP
mdefine_line|#define COMPILE_STACK_TOP (compile_stack.stack[compile_stack.avail])
multiline_comment|/* Set the bit for character C in a list.  */
DECL|macro|SET_LIST_BIT
mdefine_line|#define SET_LIST_BIT(c)                               &bslash;&n;  (b[((unsigned char) (c)) / BYTEWIDTH]               &bslash;&n;   |= 1 &lt;&lt; (((unsigned char) c) % BYTEWIDTH))
multiline_comment|/* Get the next unsigned number in the uncompiled pattern.  */
DECL|macro|GET_UNSIGNED_NUMBER
mdefine_line|#define GET_UNSIGNED_NUMBER(num) &t;&t;&t;&t;&t;&bslash;&n;  { if (p != pend)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;     {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;       PATFETCH (c); &t;&t;&t;&t;&t;&t;&t;&bslash;&n;       while (ISDIGIT (c)) &t;&t;&t;&t;&t;&t;&bslash;&n;&t; { &t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;   if (num &lt; 0)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;      num = 0;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;   num = num * 10 + c - &squot;0&squot;; &t;&t;&t;&t;&t;&bslash;&n;&t;   if (p == pend) &t;&t;&t;&t;&t;&t;&bslash;&n;&t;      break; &t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;   PATFETCH (c);&t;&t;&t;&t;&t;&t;&bslash;&n;&t; } &t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;       } &t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    }
DECL|macro|CHAR_CLASS_MAX_LENGTH
mdefine_line|#define CHAR_CLASS_MAX_LENGTH  6 /* Namely, `xdigit&squot;.  */
DECL|macro|IS_CHAR_CLASS
mdefine_line|#define IS_CHAR_CLASS(string)&t;&t;&t;&t;&t;&t;&bslash;&n;   (STREQ (string, &quot;alpha&quot;) || STREQ (string, &quot;upper&quot;)&t;&t;&t;&bslash;&n;    || STREQ (string, &quot;lower&quot;) || STREQ (string, &quot;digit&quot;)&t;&t;&bslash;&n;    || STREQ (string, &quot;alnum&quot;) || STREQ (string, &quot;xdigit&quot;)&t;&t;&bslash;&n;    || STREQ (string, &quot;space&quot;) || STREQ (string, &quot;print&quot;)&t;&t;&bslash;&n;    || STREQ (string, &quot;punct&quot;) || STREQ (string, &quot;graph&quot;)&t;&t;&bslash;&n;    || STREQ (string, &quot;cntrl&quot;) || STREQ (string, &quot;blank&quot;))
"&f;"
multiline_comment|/* `regex_compile&squot; compiles PATTERN (of length SIZE) according to SYNTAX.&n;   Returns one of error codes defined in `regex.h&squot;, or zero for success.&n;&n;   Assumes the `allocated&squot; (and perhaps `buffer&squot;) and `translate&squot;&n;   fields are set in BUFP on entry.&n;&n;   If it succeeds, results are put in BUFP (if it returns an error, the&n;   contents of BUFP are undefined):&n;     `buffer&squot; is the compiled pattern;&n;     `syntax&squot; is set to SYNTAX;&n;     `used&squot; is set to the length of the compiled pattern;&n;     `fastmap_accurate&squot; is zero;&n;     `re_nsub&squot; is the number of subexpressions in PATTERN;&n;     `not_bol&squot; and `not_eol&squot; are zero;&n;&n;   The `fastmap&squot; and `newline_anchor&squot; fields are neither&n;   examined nor set.  */
r_static
id|reg_errcode_t
DECL|function|regex_compile
id|regex_compile
(paren
id|pattern
comma
id|size
comma
id|syntax
comma
id|bufp
)paren
r_const
r_char
op_star
id|pattern
suffix:semicolon
r_int
id|size
suffix:semicolon
id|reg_syntax_t
id|syntax
suffix:semicolon
r_struct
id|re_pattern_buffer
op_star
id|bufp
suffix:semicolon
(brace
multiline_comment|/* We fetch characters from PATTERN here.  Even though PATTERN is&n;     `char *&squot; (i.e., signed), we declare these variables as unsigned, so&n;     they can be reliably used as array indices.  */
r_register
r_int
r_char
id|c
comma
id|c1
suffix:semicolon
multiline_comment|/* A random tempory spot in PATTERN.  */
r_const
r_char
op_star
id|p1
suffix:semicolon
multiline_comment|/* Points to the end of the buffer, where we should append.  */
r_register
r_int
r_char
op_star
id|b
suffix:semicolon
multiline_comment|/* Keeps track of unclosed groups.  */
id|compile_stack_type
id|compile_stack
suffix:semicolon
multiline_comment|/* Points to the current (ending) position in the pattern.  */
r_const
r_char
op_star
id|p
op_assign
id|pattern
suffix:semicolon
r_const
r_char
op_star
id|pend
op_assign
id|pattern
op_plus
id|size
suffix:semicolon
multiline_comment|/* How to translate the characters in the pattern.  */
r_char
op_star
id|translate
op_assign
id|bufp-&gt;translate
suffix:semicolon
multiline_comment|/* Address of the count-byte of the most recently inserted `exactn&squot;&n;     command.  This makes it possible to tell if a new exact-match&n;     character can be added to that command or if the character requires&n;     a new `exactn&squot; command.  */
r_int
r_char
op_star
id|pending_exact
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Address of start of the most recently finished expression.&n;     This tells, e.g., postfix * where to find the start of its&n;     operand.  Reset at the beginning of groups and alternatives.  */
r_int
r_char
op_star
id|laststart
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Address of beginning of regexp, or inside of last group.  */
r_int
r_char
op_star
id|begalt
suffix:semicolon
multiline_comment|/* Place in the uncompiled pattern (i.e., the {) to&n;     which to go back if the interval is invalid.  */
r_const
r_char
op_star
id|beg_interval
suffix:semicolon
multiline_comment|/* Address of the place where a forward jump should go to the end of&n;     the containing expression.  Each alternative of an `or&squot; -- except the&n;     last -- ends with a forward jump of this sort.  */
r_int
r_char
op_star
id|fixup_alt_jump
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Counts open-groups as they are encountered.  Remembered for the&n;     matching close-group on the compile stack, so the same register&n;     number is put in the stop_memory as the start_memory.  */
id|regnum_t
id|regnum
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG
id|DEBUG_PRINT1
(paren
l_string|&quot;&bslash;nCompiling pattern: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
)paren
(brace
r_int
id|debug_count
suffix:semicolon
r_for
c_loop
(paren
id|debug_count
op_assign
l_int|0
suffix:semicolon
id|debug_count
OL
id|size
suffix:semicolon
id|debug_count
op_increment
)paren
id|printchar
(paren
id|pattern
(braket
id|debug_count
)braket
)paren
suffix:semicolon
id|putchar
(paren
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
macro_line|#endif /* DEBUG */
multiline_comment|/* Initialize the compile stack.  */
id|compile_stack.stack
op_assign
id|TALLOC
(paren
id|INIT_COMPILE_STACK_SIZE
comma
id|compile_stack_elt_t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|compile_stack.stack
op_eq
l_int|NULL
)paren
r_return
id|REG_ESPACE
suffix:semicolon
id|compile_stack.size
op_assign
id|INIT_COMPILE_STACK_SIZE
suffix:semicolon
id|compile_stack.avail
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Initialize the pattern buffer.  */
id|bufp-&gt;syntax
op_assign
id|syntax
suffix:semicolon
id|bufp-&gt;fastmap_accurate
op_assign
l_int|0
suffix:semicolon
id|bufp-&gt;not_bol
op_assign
id|bufp-&gt;not_eol
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Set `used&squot; to zero, so that if we return an error, the pattern&n;     printer (for debugging) will think there&squot;s no pattern.  We reset it&n;     at the end.  */
id|bufp-&gt;used
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Always count groups, whether or not bufp-&gt;no_sub is set.  */
id|bufp-&gt;re_nsub
op_assign
l_int|0
suffix:semicolon
macro_line|#if !defined (emacs) &amp;&amp; !defined (SYNTAX_TABLE)
multiline_comment|/* Initialize the syntax table.  */
id|init_syntax_once
(paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|bufp-&gt;allocated
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|bufp-&gt;buffer
)paren
(brace
multiline_comment|/* If zero allocated, but buffer is non-null, try to realloc&n;&t;     enough space.  This loses if buffer&squot;s address is bogus, but&n;&t;     that is the user&squot;s responsibility.  */
id|RETALLOC
(paren
id|bufp-&gt;buffer
comma
id|INIT_BUF_SIZE
comma
r_int
r_char
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Caller did not allocate a buffer.  Do it for them.  */
id|bufp-&gt;buffer
op_assign
id|TALLOC
(paren
id|INIT_BUF_SIZE
comma
r_int
r_char
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|bufp-&gt;buffer
)paren
r_return
id|REG_ESPACE
suffix:semicolon
id|bufp-&gt;allocated
op_assign
id|INIT_BUF_SIZE
suffix:semicolon
)brace
id|begalt
op_assign
id|b
op_assign
id|bufp-&gt;buffer
suffix:semicolon
multiline_comment|/* Loop through the uncompiled pattern until we&squot;re at the end.  */
r_while
c_loop
(paren
id|p
op_ne
id|pend
)paren
(brace
id|PATFETCH
(paren
id|c
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
l_char|&squot;^&squot;
suffix:colon
(brace
r_if
c_cond
(paren
multiline_comment|/* If at start of pattern, it&squot;s an operator.  */
id|p
op_eq
id|pattern
op_plus
l_int|1
multiline_comment|/* If context independent, it&squot;s an operator.  */
op_logical_or
id|syntax
op_amp
id|RE_CONTEXT_INDEP_ANCHORS
multiline_comment|/* Otherwise, depends on what&squot;s come before.  */
op_logical_or
id|at_begline_loc_p
(paren
id|pattern
comma
id|p
comma
id|syntax
)paren
)paren
id|BUF_PUSH
(paren
id|begline
)paren
suffix:semicolon
r_else
r_goto
id|normal_char
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;$&squot;
suffix:colon
(brace
r_if
c_cond
(paren
multiline_comment|/* If at end of pattern, it&squot;s an operator.  */
id|p
op_eq
id|pend
multiline_comment|/* If context independent, it&squot;s an operator.  */
op_logical_or
id|syntax
op_amp
id|RE_CONTEXT_INDEP_ANCHORS
multiline_comment|/* Otherwise, depends on what&squot;s next.  */
op_logical_or
id|at_endline_loc_p
(paren
id|p
comma
id|pend
comma
id|syntax
)paren
)paren
id|BUF_PUSH
(paren
id|endline
)paren
suffix:semicolon
r_else
r_goto
id|normal_char
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;+&squot;
suffix:colon
r_case
l_char|&squot;?&squot;
suffix:colon
r_if
c_cond
(paren
(paren
id|syntax
op_amp
id|RE_BK_PLUS_QM
)paren
op_logical_or
(paren
id|syntax
op_amp
id|RE_LIMITED_OPS
)paren
)paren
r_goto
id|normal_char
suffix:semicolon
id|handle_plus
suffix:colon
r_case
l_char|&squot;*&squot;
suffix:colon
multiline_comment|/* If there is no previous pattern... */
r_if
c_cond
(paren
op_logical_neg
id|laststart
)paren
(brace
r_if
c_cond
(paren
id|syntax
op_amp
id|RE_CONTEXT_INVALID_OPS
)paren
r_return
id|REG_BADRPT
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|syntax
op_amp
id|RE_CONTEXT_INDEP_OPS
)paren
)paren
r_goto
id|normal_char
suffix:semicolon
)brace
(brace
multiline_comment|/* Are we optimizing this jump?  */
id|boolean
id|keep_string_p
op_assign
l_bool|false
suffix:semicolon
multiline_comment|/* 1 means zero (many) matches is allowed.  */
r_char
id|zero_times_ok
op_assign
l_int|0
comma
id|many_times_ok
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If there is a sequence of repetition chars, collapse it&n;&t;       down to just one (the right one).  We can&squot;t combine&n;&t;       interval operators with these because of, e.g., `a{2}*&squot;,&n;&t;       which should only match an even number of `a&squot;s.  */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|zero_times_ok
op_or_assign
id|c
op_ne
l_char|&squot;+&squot;
suffix:semicolon
id|many_times_ok
op_or_assign
id|c
op_ne
l_char|&squot;?&squot;
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
id|pend
)paren
r_break
suffix:semicolon
id|PATFETCH
(paren
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;*&squot;
op_logical_or
(paren
op_logical_neg
(paren
id|syntax
op_amp
id|RE_BK_PLUS_QM
)paren
op_logical_and
(paren
id|c
op_eq
l_char|&squot;+&squot;
op_logical_or
id|c
op_eq
l_char|&squot;?&squot;
)paren
)paren
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|syntax
op_amp
id|RE_BK_PLUS_QM
op_logical_and
id|c
op_eq
l_char|&squot;&bslash;&bslash;&squot;
)paren
(brace
r_if
c_cond
(paren
id|p
op_eq
id|pend
)paren
r_return
id|REG_EESCAPE
suffix:semicolon
id|PATFETCH
(paren
id|c1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|c1
op_eq
l_char|&squot;+&squot;
op_logical_or
id|c1
op_eq
l_char|&squot;?&squot;
)paren
)paren
(brace
id|PATUNFETCH
suffix:semicolon
id|PATUNFETCH
suffix:semicolon
r_break
suffix:semicolon
)brace
id|c
op_assign
id|c1
suffix:semicolon
)brace
r_else
(brace
id|PATUNFETCH
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* If we get here, we found another repeat character.  */
)brace
multiline_comment|/* Star, etc. applied to an empty pattern is equivalent&n;&t;       to an empty pattern.  */
r_if
c_cond
(paren
op_logical_neg
id|laststart
)paren
r_break
suffix:semicolon
multiline_comment|/* Now we know whether or not zero matches is allowed&n;&t;       and also whether or not two or more matches is allowed.  */
r_if
c_cond
(paren
id|many_times_ok
)paren
(brace
multiline_comment|/* More than one repetition is allowed, so put in at the&n;&t;&t;   end a backward relative jump from `b&squot; to before the next&n;&t;&t;   jump we&squot;re going to put in below (which jumps from&n;&t;&t;   laststart to after this jump).&n;&n;&t;&t;   But if we are at the `*&squot; in the exact sequence `.*&bslash;n&squot;,&n;&t;&t;   insert an unconditional jump backwards to the .,&n;&t;&t;   instead of the beginning of the loop.  This way we only&n;&t;&t;   push a failure point once, instead of every time&n;&t;&t;   through the loop.  */
m_assert
(paren
id|p
l_int|1
OG
id|pattern
)paren
suffix:semicolon
multiline_comment|/* Allocate the space for the jump.  */
id|GET_BUFFER_SPACE
(paren
l_int|3
)paren
suffix:semicolon
multiline_comment|/* We know we are not at the first character of the pattern,&n;&t;&t;   because laststart was nonzero.  And we&squot;ve already&n;&t;&t;   incremented `p&squot;, by the way, to be the character after&n;&t;&t;   the `*&squot;.  Do we have to do something analogous here&n;&t;&t;   for null bytes, because of RE_DOT_NOT_NULL?  */
r_if
c_cond
(paren
id|TRANSLATE
(paren
op_star
(paren
id|p
l_int|2
)paren
)paren
op_eq
id|TRANSLATE
(paren
l_char|&squot;.&squot;
)paren
op_logical_and
id|zero_times_ok
op_logical_and
id|p
OL
id|pend
op_logical_and
id|TRANSLATE
(paren
op_star
id|p
)paren
op_eq
id|TRANSLATE
(paren
l_char|&squot;&bslash;n&squot;
)paren
op_logical_and
op_logical_neg
(paren
id|syntax
op_amp
id|RE_DOT_NEWLINE
)paren
)paren
(brace
multiline_comment|/* We have .*&bslash;n.  */
id|STORE_JUMP
(paren
id|jump
comma
id|b
comma
id|laststart
)paren
suffix:semicolon
id|keep_string_p
op_assign
l_bool|true
suffix:semicolon
)brace
r_else
multiline_comment|/* Anything else.  */
id|STORE_JUMP
(paren
id|maybe_pop_jump
comma
id|b
comma
id|laststart
l_int|3
)paren
suffix:semicolon
multiline_comment|/* We&squot;ve added more stuff to the buffer.  */
id|b
op_add_assign
l_int|3
suffix:semicolon
)brace
multiline_comment|/* On failure, jump from laststart to b + 3, which will be the&n;&t;       end of the buffer after this jump is inserted.  */
id|GET_BUFFER_SPACE
(paren
l_int|3
)paren
suffix:semicolon
id|INSERT_JUMP
(paren
id|keep_string_p
ques
c_cond
id|on_failure_keep_string_jump
suffix:colon
id|on_failure_jump
comma
id|laststart
comma
id|b
op_plus
l_int|3
)paren
suffix:semicolon
id|pending_exact
op_assign
l_int|0
suffix:semicolon
id|b
op_add_assign
l_int|3
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|zero_times_ok
)paren
(brace
multiline_comment|/* At least one repetition is required, so insert a&n;&t;&t;   `dummy_failure_jump&squot; before the initial&n;&t;&t;   `on_failure_jump&squot; instruction of the loop. This&n;&t;&t;   effects a skip over that instruction the first time&n;&t;&t;   we hit that loop.  */
id|GET_BUFFER_SPACE
(paren
l_int|3
)paren
suffix:semicolon
id|INSERT_JUMP
(paren
id|dummy_failure_jump
comma
id|laststart
comma
id|laststart
op_plus
l_int|6
)paren
suffix:semicolon
id|b
op_add_assign
l_int|3
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;.&squot;
suffix:colon
id|laststart
op_assign
id|b
suffix:semicolon
id|BUF_PUSH
(paren
id|anychar
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;[&squot;
suffix:colon
(brace
id|boolean
id|had_char_class
op_assign
l_bool|false
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
id|pend
)paren
r_return
id|REG_EBRACK
suffix:semicolon
multiline_comment|/* Ensure that we have enough space to push a charset: the&n;&t;       opcode, the length count, and the bitset; 34 bytes in all.  */
id|GET_BUFFER_SPACE
(paren
l_int|34
)paren
suffix:semicolon
id|laststart
op_assign
id|b
suffix:semicolon
multiline_comment|/* We test `*p == &squot;^&squot; twice, instead of using an if&n;&t;       statement, so we only need one BUF_PUSH.  */
id|BUF_PUSH
(paren
op_star
id|p
op_eq
l_char|&squot;^&squot;
ques
c_cond
id|charset_not
suffix:colon
id|charset
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p
op_eq
l_char|&squot;^&squot;
)paren
id|p
op_increment
suffix:semicolon
multiline_comment|/* Remember the first position in the bracket expression.  */
id|p1
op_assign
id|p
suffix:semicolon
multiline_comment|/* Push the number of bytes in the bitmap.  */
id|BUF_PUSH
(paren
(paren
l_int|1
op_lshift
id|BYTEWIDTH
)paren
op_div
id|BYTEWIDTH
)paren
suffix:semicolon
multiline_comment|/* Clear the whole map.  */
id|bzero
(paren
id|b
comma
(paren
l_int|1
op_lshift
id|BYTEWIDTH
)paren
op_div
id|BYTEWIDTH
)paren
suffix:semicolon
multiline_comment|/* charset_not matches newline according to a syntax bit.  */
r_if
c_cond
(paren
(paren
id|re_opcode_t
)paren
id|b
(braket
l_int|2
)braket
op_eq
id|charset_not
op_logical_and
(paren
id|syntax
op_amp
id|RE_HAT_LISTS_NOT_NEWLINE
)paren
)paren
id|SET_LIST_BIT
(paren
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
multiline_comment|/* Read in characters and ranges, setting map bits.  */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|p
op_eq
id|pend
)paren
r_return
id|REG_EBRACK
suffix:semicolon
id|PATFETCH
(paren
id|c
)paren
suffix:semicolon
multiline_comment|/* &bslash; might escape characters inside [...] and [^...].  */
r_if
c_cond
(paren
(paren
id|syntax
op_amp
id|RE_BACKSLASH_ESCAPE_IN_LISTS
)paren
op_logical_and
id|c
op_eq
l_char|&squot;&bslash;&bslash;&squot;
)paren
(brace
r_if
c_cond
(paren
id|p
op_eq
id|pend
)paren
r_return
id|REG_EESCAPE
suffix:semicolon
id|PATFETCH
(paren
id|c1
)paren
suffix:semicolon
id|SET_LIST_BIT
(paren
id|c1
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Could be the end of the bracket expression.  If it&squot;s&n;&t;&t;   not (i.e., when the bracket expression is `[]&squot; so&n;&t;&t;   far), the &squot;]&squot; character bit gets set way below.  */
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;]&squot;
op_logical_and
id|p
op_ne
id|p1
op_plus
l_int|1
)paren
r_break
suffix:semicolon
multiline_comment|/* Look ahead to see if it&squot;s a range when the last thing&n;&t;&t;   was a character class.  */
r_if
c_cond
(paren
id|had_char_class
op_logical_and
id|c
op_eq
l_char|&squot;-&squot;
op_logical_and
op_star
id|p
op_ne
l_char|&squot;]&squot;
)paren
r_return
id|REG_ERANGE
suffix:semicolon
multiline_comment|/* Look ahead to see if it&squot;s a range when the last thing&n;&t;&t;   was a character: if this is a hyphen not at the&n;&t;&t;   beginning or the end of a list, then it&squot;s the range&n;&t;&t;   operator.  */
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;-&squot;
op_logical_and
op_logical_neg
(paren
id|p
l_int|2
op_ge
id|pattern
op_logical_and
id|p
(braket
l_int|2
)braket
op_eq
l_char|&squot;[&squot;
)paren
op_logical_and
op_logical_neg
(paren
id|p
l_int|3
op_ge
id|pattern
op_logical_and
id|p
(braket
l_int|3
)braket
op_eq
l_char|&squot;[&squot;
op_logical_and
id|p
(braket
l_int|2
)braket
op_eq
l_char|&squot;^&squot;
)paren
op_logical_and
op_star
id|p
op_ne
l_char|&squot;]&squot;
)paren
(brace
id|reg_errcode_t
id|ret
op_assign
id|compile_range
(paren
op_amp
id|p
comma
id|pend
comma
id|translate
comma
id|syntax
comma
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
id|REG_NOERROR
)paren
r_return
id|ret
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|p
(braket
l_int|0
)braket
op_eq
l_char|&squot;-&squot;
op_logical_and
id|p
(braket
l_int|1
)braket
op_ne
l_char|&squot;]&squot;
)paren
(brace
multiline_comment|/* This handles ranges made up of characters only.  */
id|reg_errcode_t
id|ret
suffix:semicolon
multiline_comment|/* Move past the `-&squot;.  */
id|PATFETCH
(paren
id|c1
)paren
suffix:semicolon
id|ret
op_assign
id|compile_range
(paren
op_amp
id|p
comma
id|pend
comma
id|translate
comma
id|syntax
comma
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
id|REG_NOERROR
)paren
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* See if we&squot;re at the beginning of a possible character&n;&t;&t;   class.  */
r_else
r_if
c_cond
(paren
id|syntax
op_amp
id|RE_CHAR_CLASSES
op_logical_and
id|c
op_eq
l_char|&squot;[&squot;
op_logical_and
op_star
id|p
op_eq
l_char|&squot;:&squot;
)paren
(brace
multiline_comment|/* Leave room for the null.  */
r_char
id|str
(braket
id|CHAR_CLASS_MAX_LENGTH
op_plus
l_int|1
)braket
suffix:semicolon
id|PATFETCH
(paren
id|c
)paren
suffix:semicolon
id|c1
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If pattern is `[[:&squot;.  */
r_if
c_cond
(paren
id|p
op_eq
id|pend
)paren
r_return
id|REG_EBRACK
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|PATFETCH
(paren
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;:&squot;
op_logical_or
id|c
op_eq
l_char|&squot;]&squot;
op_logical_or
id|p
op_eq
id|pend
op_logical_or
id|c1
op_eq
id|CHAR_CLASS_MAX_LENGTH
)paren
r_break
suffix:semicolon
id|str
(braket
id|c1
op_increment
)braket
op_assign
id|c
suffix:semicolon
)brace
id|str
(braket
id|c1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
multiline_comment|/* If isn&squot;t a word bracketed by `[:&squot; and:`]&squot;:&n;&t;&t;       undo the ending character, the letters, and leave&n;&t;&t;       the leading `:&squot; and `[&squot; (but set bits for them).  */
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;:&squot;
op_logical_and
op_star
id|p
op_eq
l_char|&squot;]&squot;
)paren
(brace
r_int
id|ch
suffix:semicolon
id|boolean
id|is_alnum
op_assign
id|STREQ
(paren
id|str
comma
l_string|&quot;alnum&quot;
)paren
suffix:semicolon
id|boolean
id|is_alpha
op_assign
id|STREQ
(paren
id|str
comma
l_string|&quot;alpha&quot;
)paren
suffix:semicolon
id|boolean
id|is_blank
op_assign
id|STREQ
(paren
id|str
comma
l_string|&quot;blank&quot;
)paren
suffix:semicolon
id|boolean
id|is_cntrl
op_assign
id|STREQ
(paren
id|str
comma
l_string|&quot;cntrl&quot;
)paren
suffix:semicolon
id|boolean
id|is_digit
op_assign
id|STREQ
(paren
id|str
comma
l_string|&quot;digit&quot;
)paren
suffix:semicolon
id|boolean
id|is_graph
op_assign
id|STREQ
(paren
id|str
comma
l_string|&quot;graph&quot;
)paren
suffix:semicolon
id|boolean
id|is_lower
op_assign
id|STREQ
(paren
id|str
comma
l_string|&quot;lower&quot;
)paren
suffix:semicolon
id|boolean
id|is_print
op_assign
id|STREQ
(paren
id|str
comma
l_string|&quot;print&quot;
)paren
suffix:semicolon
id|boolean
id|is_punct
op_assign
id|STREQ
(paren
id|str
comma
l_string|&quot;punct&quot;
)paren
suffix:semicolon
id|boolean
id|is_space
op_assign
id|STREQ
(paren
id|str
comma
l_string|&quot;space&quot;
)paren
suffix:semicolon
id|boolean
id|is_upper
op_assign
id|STREQ
(paren
id|str
comma
l_string|&quot;upper&quot;
)paren
suffix:semicolon
id|boolean
id|is_xdigit
op_assign
id|STREQ
(paren
id|str
comma
l_string|&quot;xdigit&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_CHAR_CLASS
(paren
id|str
)paren
)paren
r_return
id|REG_ECTYPE
suffix:semicolon
multiline_comment|/* Throw away the ] at the end of the character&n;&t;&t;&t;   class.  */
id|PATFETCH
(paren
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
id|pend
)paren
r_return
id|REG_EBRACK
suffix:semicolon
r_for
c_loop
(paren
id|ch
op_assign
l_int|0
suffix:semicolon
id|ch
OL
l_int|1
op_lshift
id|BYTEWIDTH
suffix:semicolon
id|ch
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|is_alnum
op_logical_and
id|ISALNUM
(paren
id|ch
)paren
)paren
op_logical_or
(paren
id|is_alpha
op_logical_and
id|ISALPHA
(paren
id|ch
)paren
)paren
op_logical_or
(paren
id|is_blank
op_logical_and
id|ISBLANK
(paren
id|ch
)paren
)paren
op_logical_or
(paren
id|is_cntrl
op_logical_and
id|ISCNTRL
(paren
id|ch
)paren
)paren
op_logical_or
(paren
id|is_digit
op_logical_and
id|ISDIGIT
(paren
id|ch
)paren
)paren
op_logical_or
(paren
id|is_graph
op_logical_and
id|ISGRAPH
(paren
id|ch
)paren
)paren
op_logical_or
(paren
id|is_lower
op_logical_and
id|ISLOWER
(paren
id|ch
)paren
)paren
op_logical_or
(paren
id|is_print
op_logical_and
id|ISPRINT
(paren
id|ch
)paren
)paren
op_logical_or
(paren
id|is_punct
op_logical_and
id|ISPUNCT
(paren
id|ch
)paren
)paren
op_logical_or
(paren
id|is_space
op_logical_and
id|ISSPACE
(paren
id|ch
)paren
)paren
op_logical_or
(paren
id|is_upper
op_logical_and
id|ISUPPER
(paren
id|ch
)paren
)paren
op_logical_or
(paren
id|is_xdigit
op_logical_and
id|ISXDIGIT
(paren
id|ch
)paren
)paren
)paren
id|SET_LIST_BIT
(paren
id|ch
)paren
suffix:semicolon
)brace
id|had_char_class
op_assign
l_bool|true
suffix:semicolon
)brace
r_else
(brace
id|c1
op_increment
suffix:semicolon
r_while
c_loop
(paren
id|c1
op_decrement
)paren
id|PATUNFETCH
suffix:semicolon
id|SET_LIST_BIT
(paren
l_char|&squot;[&squot;
)paren
suffix:semicolon
id|SET_LIST_BIT
(paren
l_char|&squot;:&squot;
)paren
suffix:semicolon
id|had_char_class
op_assign
l_bool|false
suffix:semicolon
)brace
)brace
r_else
(brace
id|had_char_class
op_assign
l_bool|false
suffix:semicolon
id|SET_LIST_BIT
(paren
id|c
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Discard any (non)matching list bytes that are all 0 at the&n;&t;       end of the map.  Decrease the map-length byte too.  */
r_while
c_loop
(paren
(paren
r_int
)paren
id|b
(braket
l_int|1
)braket
OG
l_int|0
op_logical_and
id|b
(braket
id|b
(braket
l_int|1
)braket
l_int|1
)braket
op_eq
l_int|0
)paren
id|b
(braket
l_int|1
)braket
op_decrement
suffix:semicolon
id|b
op_add_assign
id|b
(braket
l_int|1
)braket
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;(&squot;
suffix:colon
r_if
c_cond
(paren
id|syntax
op_amp
id|RE_NO_BK_PARENS
)paren
r_goto
id|handle_open
suffix:semicolon
r_else
r_goto
id|normal_char
suffix:semicolon
r_case
l_char|&squot;)&squot;
suffix:colon
r_if
c_cond
(paren
id|syntax
op_amp
id|RE_NO_BK_PARENS
)paren
r_goto
id|handle_close
suffix:semicolon
r_else
r_goto
id|normal_char
suffix:semicolon
r_case
l_char|&squot;&bslash;n&squot;
suffix:colon
r_if
c_cond
(paren
id|syntax
op_amp
id|RE_NEWLINE_ALT
)paren
r_goto
id|handle_alt
suffix:semicolon
r_else
r_goto
id|normal_char
suffix:semicolon
r_case
l_char|&squot;|&squot;
suffix:colon
r_if
c_cond
(paren
id|syntax
op_amp
id|RE_NO_BK_VBAR
)paren
r_goto
id|handle_alt
suffix:semicolon
r_else
r_goto
id|normal_char
suffix:semicolon
r_case
l_char|&squot;{&squot;
suffix:colon
r_if
c_cond
(paren
id|syntax
op_amp
id|RE_INTERVALS
op_logical_and
id|syntax
op_amp
id|RE_NO_BK_BRACES
)paren
r_goto
id|handle_interval
suffix:semicolon
r_else
r_goto
id|normal_char
suffix:semicolon
r_case
l_char|&squot;&bslash;&bslash;&squot;
suffix:colon
r_if
c_cond
(paren
id|p
op_eq
id|pend
)paren
r_return
id|REG_EESCAPE
suffix:semicolon
multiline_comment|/* Do not translate the character after the &bslash;, so that we can&n;&t;     distinguish, e.g., &bslash;B from &bslash;b, even if we normally would&n;&t;     translate, e.g., B to b.  */
id|PATFETCH_RAW
(paren
id|c
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
l_char|&squot;(&squot;
suffix:colon
r_if
c_cond
(paren
id|syntax
op_amp
id|RE_NO_BK_PARENS
)paren
r_goto
id|normal_backslash
suffix:semicolon
id|handle_open
suffix:colon
id|bufp-&gt;re_nsub
op_increment
suffix:semicolon
id|regnum
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|COMPILE_STACK_FULL
)paren
(brace
id|RETALLOC
(paren
id|compile_stack.stack
comma
id|compile_stack.size
op_lshift
l_int|1
comma
id|compile_stack_elt_t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|compile_stack.stack
op_eq
l_int|NULL
)paren
r_return
id|REG_ESPACE
suffix:semicolon
id|compile_stack.size
op_lshift_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* These are the values to restore when we hit end of this&n;&t;&t; group.  They are all relative offsets, so that if the&n;&t;&t; whole pattern moves because of realloc, they will still&n;&t;&t; be valid.  */
id|COMPILE_STACK_TOP.begalt_offset
op_assign
id|begalt
id|bufp-&gt;buffer
suffix:semicolon
id|COMPILE_STACK_TOP.fixup_alt_jump
op_assign
id|fixup_alt_jump
ques
c_cond
id|fixup_alt_jump
id|bufp-&gt;buffer
op_plus
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|COMPILE_STACK_TOP.laststart_offset
op_assign
id|b
id|bufp-&gt;buffer
suffix:semicolon
id|COMPILE_STACK_TOP.regnum
op_assign
id|regnum
suffix:semicolon
multiline_comment|/* We will eventually replace the 0 with the number of&n;&t;&t; groups inner to this one.  But do not push a&n;&t;&t; start_memory for groups beyond the last one we can&n;&t;&t; represent in the compiled pattern.  */
r_if
c_cond
(paren
id|regnum
op_le
id|MAX_REGNUM
)paren
(brace
id|COMPILE_STACK_TOP.inner_group_offset
op_assign
id|b
id|bufp-&gt;buffer
op_plus
l_int|2
suffix:semicolon
id|BUF_PUSH_3
(paren
id|start_memory
comma
id|regnum
comma
l_int|0
)paren
suffix:semicolon
)brace
id|compile_stack.avail
op_increment
suffix:semicolon
id|fixup_alt_jump
op_assign
l_int|0
suffix:semicolon
id|laststart
op_assign
l_int|0
suffix:semicolon
id|begalt
op_assign
id|b
suffix:semicolon
multiline_comment|/* If we&squot;ve reached MAX_REGNUM groups, then this open&n;&t;&t; won&squot;t actually generate any code, so we&squot;ll have to&n;&t;&t; clear pending_exact explicitly.  */
id|pending_exact
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;)&squot;
suffix:colon
r_if
c_cond
(paren
id|syntax
op_amp
id|RE_NO_BK_PARENS
)paren
r_goto
id|normal_backslash
suffix:semicolon
r_if
c_cond
(paren
id|COMPILE_STACK_EMPTY
)paren
(brace
r_if
c_cond
(paren
id|syntax
op_amp
id|RE_UNMATCHED_RIGHT_PAREN_ORD
)paren
r_goto
id|normal_backslash
suffix:semicolon
r_else
r_return
id|REG_ERPAREN
suffix:semicolon
)brace
id|handle_close
suffix:colon
r_if
c_cond
(paren
id|fixup_alt_jump
)paren
(brace
multiline_comment|/* Push a dummy failure point at the end of the&n;&t;&t;     alternative for a possible future&n;&t;&t;     `pop_failure_jump&squot; to pop.  See comments at&n;&t;&t;     `push_dummy_failure&squot; in `re_match_2&squot;.  */
id|BUF_PUSH
(paren
id|push_dummy_failure
)paren
suffix:semicolon
multiline_comment|/* We allocated space for this jump when we assigned&n;&t;&t;     to `fixup_alt_jump&squot;, in the `handle_alt&squot; case below.  */
id|STORE_JUMP
(paren
id|jump_past_alt
comma
id|fixup_alt_jump
comma
id|b
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* See similar code for backslashed left paren above.  */
r_if
c_cond
(paren
id|COMPILE_STACK_EMPTY
)paren
(brace
r_if
c_cond
(paren
id|syntax
op_amp
id|RE_UNMATCHED_RIGHT_PAREN_ORD
)paren
r_goto
id|normal_char
suffix:semicolon
r_else
r_return
id|REG_ERPAREN
suffix:semicolon
)brace
multiline_comment|/* Since we just checked for an empty stack above, this&n;&t;&t; ``can&squot;t happen&squot;&squot;.  */
m_assert
(paren
id|compile_stack.avail
op_ne
l_int|0
)paren
suffix:semicolon
(brace
multiline_comment|/* We don&squot;t just want to restore into `regnum&squot;, because&n;&t;&t;   later groups should continue to be numbered higher,&n;&t;&t;   as in `(ab)c(de)&squot; -- the second group is #2.  */
id|regnum_t
id|this_group_regnum
suffix:semicolon
id|compile_stack.avail
op_decrement
suffix:semicolon
id|begalt
op_assign
id|bufp-&gt;buffer
op_plus
id|COMPILE_STACK_TOP.begalt_offset
suffix:semicolon
id|fixup_alt_jump
op_assign
id|COMPILE_STACK_TOP.fixup_alt_jump
ques
c_cond
id|bufp-&gt;buffer
op_plus
id|COMPILE_STACK_TOP.fixup_alt_jump
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|laststart
op_assign
id|bufp-&gt;buffer
op_plus
id|COMPILE_STACK_TOP.laststart_offset
suffix:semicolon
id|this_group_regnum
op_assign
id|COMPILE_STACK_TOP.regnum
suffix:semicolon
multiline_comment|/* If we&squot;ve reached MAX_REGNUM groups, then this open&n;&t;&t;   won&squot;t actually generate any code, so we&squot;ll have to&n;&t;&t;   clear pending_exact explicitly.  */
id|pending_exact
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We&squot;re at the end of the group, so now we know how many&n;&t;&t;   groups were inside this one.  */
r_if
c_cond
(paren
id|this_group_regnum
op_le
id|MAX_REGNUM
)paren
(brace
r_int
r_char
op_star
id|inner_group_loc
op_assign
id|bufp-&gt;buffer
op_plus
id|COMPILE_STACK_TOP.inner_group_offset
suffix:semicolon
op_star
id|inner_group_loc
op_assign
id|regnum
id|this_group_regnum
suffix:semicolon
id|BUF_PUSH_3
(paren
id|stop_memory
comma
id|this_group_regnum
comma
id|regnum
id|this_group_regnum
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;|&squot;
suffix:colon
multiline_comment|/* `&bslash;|&squot;.  */
r_if
c_cond
(paren
id|syntax
op_amp
id|RE_LIMITED_OPS
op_logical_or
id|syntax
op_amp
id|RE_NO_BK_VBAR
)paren
r_goto
id|normal_backslash
suffix:semicolon
id|handle_alt
suffix:colon
r_if
c_cond
(paren
id|syntax
op_amp
id|RE_LIMITED_OPS
)paren
r_goto
id|normal_char
suffix:semicolon
multiline_comment|/* Insert before the previous alternative a jump which&n;&t;&t; jumps to this alternative if the former fails.  */
id|GET_BUFFER_SPACE
(paren
l_int|3
)paren
suffix:semicolon
id|INSERT_JUMP
(paren
id|on_failure_jump
comma
id|begalt
comma
id|b
op_plus
l_int|6
)paren
suffix:semicolon
id|pending_exact
op_assign
l_int|0
suffix:semicolon
id|b
op_add_assign
l_int|3
suffix:semicolon
multiline_comment|/* The alternative before this one has a jump after it&n;&t;&t; which gets executed if it gets matched.  Adjust that&n;&t;&t; jump so it will jump to this alternative&squot;s analogous&n;&t;&t; jump (put in below, which in turn will jump to the next&n;&t;&t; (if any) alternative&squot;s such jump, etc.).  The last such&n;&t;&t; jump jumps to the correct final destination.  A picture:&n;&t;&t;&t;  _____ _____&n;&t;&t;&t;  |   | |   |&n;&t;&t;&t;  |   v |   v&n;&t;&t;&t; a | b   | c&n;&n;&t;&t; If we are at `b&squot;, then fixup_alt_jump right now points to a&n;&t;&t; three-byte space after `a&squot;.  We&squot;ll put in the jump, set&n;&t;&t; fixup_alt_jump to right after `b&squot;, and leave behind three&n;&t;&t; bytes which we&squot;ll fill in when we get to after `c&squot;.  */
r_if
c_cond
(paren
id|fixup_alt_jump
)paren
id|STORE_JUMP
(paren
id|jump_past_alt
comma
id|fixup_alt_jump
comma
id|b
)paren
suffix:semicolon
multiline_comment|/* Mark and leave space for a jump after this alternative,&n;&t;&t; to be filled in later either by next alternative or&n;&t;&t; when know we&squot;re at the end of a series of alternatives.  */
id|fixup_alt_jump
op_assign
id|b
suffix:semicolon
id|GET_BUFFER_SPACE
(paren
l_int|3
)paren
suffix:semicolon
id|b
op_add_assign
l_int|3
suffix:semicolon
id|laststart
op_assign
l_int|0
suffix:semicolon
id|begalt
op_assign
id|b
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;{&squot;
suffix:colon
multiline_comment|/* If &bslash;{ is a literal.  */
r_if
c_cond
(paren
op_logical_neg
(paren
id|syntax
op_amp
id|RE_INTERVALS
)paren
multiline_comment|/* If we&squot;re at `&bslash;{&squot; and it&squot;s not the open-interval&n;&t;&t;&t;operator.  */
op_logical_or
(paren
(paren
id|syntax
op_amp
id|RE_INTERVALS
)paren
op_logical_and
(paren
id|syntax
op_amp
id|RE_NO_BK_BRACES
)paren
)paren
op_logical_or
(paren
id|p
l_int|2
op_eq
id|pattern
op_logical_and
id|p
op_eq
id|pend
)paren
)paren
r_goto
id|normal_backslash
suffix:semicolon
id|handle_interval
suffix:colon
(brace
multiline_comment|/* If got here, then the syntax allows intervals.  */
multiline_comment|/* At least (most) this many matches must be made.  */
r_int
id|lower_bound
op_assign
l_int|1
comma
id|upper_bound
op_assign
l_int|1
suffix:semicolon
id|beg_interval
op_assign
id|p
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
id|pend
)paren
(brace
r_if
c_cond
(paren
id|syntax
op_amp
id|RE_NO_BK_BRACES
)paren
r_goto
id|unfetch_interval
suffix:semicolon
r_else
r_return
id|REG_EBRACE
suffix:semicolon
)brace
id|GET_UNSIGNED_NUMBER
(paren
id|lower_bound
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;,&squot;
)paren
(brace
id|GET_UNSIGNED_NUMBER
(paren
id|upper_bound
)paren
suffix:semicolon
r_if
c_cond
(paren
id|upper_bound
OL
l_int|0
)paren
id|upper_bound
op_assign
id|RE_DUP_MAX
suffix:semicolon
)brace
r_else
multiline_comment|/* Interval such as `{1}&squot; =&gt; match exactly once. */
id|upper_bound
op_assign
id|lower_bound
suffix:semicolon
r_if
c_cond
(paren
id|lower_bound
template_param
id|RE_DUP_MAX
op_logical_or
id|lower_bound
OG
id|upper_bound
)paren
(brace
r_if
c_cond
(paren
id|syntax
op_amp
id|RE_NO_BK_BRACES
)paren
r_goto
id|unfetch_interval
suffix:semicolon
r_else
r_return
id|REG_BADBR
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|syntax
op_amp
id|RE_NO_BK_BRACES
)paren
)paren
(brace
r_if
c_cond
(paren
id|c
op_ne
l_char|&squot;&bslash;&bslash;&squot;
)paren
r_return
id|REG_EBRACE
suffix:semicolon
id|PATFETCH
(paren
id|c
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_ne
l_char|&squot;}&squot;
)paren
(brace
r_if
c_cond
(paren
id|syntax
op_amp
id|RE_NO_BK_BRACES
)paren
r_goto
id|unfetch_interval
suffix:semicolon
r_else
r_return
id|REG_BADBR
suffix:semicolon
)brace
multiline_comment|/* We just parsed a valid interval.  */
multiline_comment|/* If it&squot;s invalid to have no preceding re.  */
r_if
c_cond
(paren
op_logical_neg
id|laststart
)paren
(brace
r_if
c_cond
(paren
id|syntax
op_amp
id|RE_CONTEXT_INVALID_OPS
)paren
r_return
id|REG_BADRPT
suffix:semicolon
r_else
r_if
c_cond
(paren
id|syntax
op_amp
id|RE_CONTEXT_INDEP_OPS
)paren
id|laststart
op_assign
id|b
suffix:semicolon
r_else
r_goto
id|unfetch_interval
suffix:semicolon
)brace
multiline_comment|/* If the upper bound is zero, don&squot;t want to succeed at&n;&t;&t;   all; jump from `laststart&squot; to `b + 3&squot;, which will be&n;&t;&t;   the end of the buffer after we insert the jump.  */
r_if
c_cond
(paren
id|upper_bound
op_eq
l_int|0
)paren
(brace
id|GET_BUFFER_SPACE
(paren
l_int|3
)paren
suffix:semicolon
id|INSERT_JUMP
(paren
id|jump
comma
id|laststart
comma
id|b
op_plus
l_int|3
)paren
suffix:semicolon
id|b
op_add_assign
l_int|3
suffix:semicolon
)brace
multiline_comment|/* Otherwise, we have a nontrivial interval.  When&n;&t;&t;    we&squot;re all done, the pattern will look like:&n;&t;&t;      set_number_at &lt;jump count&gt; &lt;upper bound&gt;&n;&t;&t;      set_number_at &lt;succeed_n count&gt; &lt;lower bound&gt;&n;&t;&t;      succeed_n &lt;after jump addr&gt; &lt;succed_n count&gt;&n;&t;&t;      &lt;body of loop&gt;&n;&t;&t;      jump_n &lt;succeed_n addr&gt; &lt;jump count&gt;&n;&t;&t;    (The upper bound and `jump_n&squot; are omitted if&n;&t;&t;    `upper_bound&squot; is 1, though.)  */
r_else
(brace
multiline_comment|/* If the upper bound is &gt; 1, we need to insert&n;&t;&t;&t;more at the end of the loop.  */
r_int
id|nbytes
op_assign
l_int|10
op_plus
(paren
id|upper_bound
OG
l_int|1
)paren
op_star
l_int|10
suffix:semicolon
id|GET_BUFFER_SPACE
(paren
id|nbytes
)paren
suffix:semicolon
multiline_comment|/* Initialize lower bound of the `succeed_n&squot;, even&n;&t;&t;&t;though it will be set during matching by its&n;&t;&t;&t;attendant `set_number_at&squot; (inserted next),&n;&t;&t;&t;because `re_compile_fastmap&squot; needs to know.&n;&t;&t;&t;Jump to the `jump_n&squot; we might insert below.  */
id|INSERT_JUMP2
(paren
id|succeed_n
comma
id|laststart
comma
id|b
op_plus
l_int|5
op_plus
(paren
id|upper_bound
OG
l_int|1
)paren
op_star
l_int|5
comma
id|lower_bound
)paren
suffix:semicolon
id|b
op_add_assign
l_int|5
suffix:semicolon
multiline_comment|/* Code to initialize the lower bound.  Insert&n;&t;&t;&t;before the `succeed_n&squot;.  The `5&squot; is the last two&n;&t;&t;&t;bytes of this `set_number_at&squot;, plus 3 bytes of&n;&t;&t;&t;the following `succeed_n&squot;.  */
id|insert_op2
(paren
id|set_number_at
comma
id|laststart
comma
l_int|5
comma
id|lower_bound
comma
id|b
)paren
suffix:semicolon
id|b
op_add_assign
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|upper_bound
OG
l_int|1
)paren
(brace
multiline_comment|/* More than one repetition is allowed, so&n;&t;&t;&t;    append a backward jump to the `succeed_n&squot;&n;&t;&t;&t;    that starts this interval.&n;&n;&t;&t;&t;    When we&squot;ve reached this during matching,&n;&t;&t;&t;    we&squot;ll have matched the interval once, so&n;&t;&t;&t;    jump back only `upper_bound - 1&squot; times.  */
id|STORE_JUMP2
(paren
id|jump_n
comma
id|b
comma
id|laststart
op_plus
l_int|5
comma
id|upper_bound
l_int|1
)paren
suffix:semicolon
id|b
op_add_assign
l_int|5
suffix:semicolon
multiline_comment|/* The location we want to set is the second&n;&t;&t;&t;    parameter of the `jump_n&squot;; that is `b-2&squot; as&n;&t;&t;&t;    an absolute address.  `laststart&squot; will be&n;&t;&t;&t;    the `set_number_at&squot; we&squot;re about to insert;&n;&t;&t;&t;    `laststart+3&squot; the number to set, the source&n;&t;&t;&t;    for the relative address.  But we are&n;&t;&t;&t;    inserting into the middle of the pattern --&n;&t;&t;&t;    so everything is getting moved up by 5.&n;&t;&t;&t;    Conclusion: (b - 2) - (laststart + 3) + 5,&n;&t;&t;&t;    i.e., b - laststart.&n;&n;&t;&t;&t;    We insert this at the beginning of the loop&n;&t;&t;&t;    so that if we fail during matching, we&squot;ll&n;&t;&t;&t;    reinitialize the bounds.  */
id|insert_op2
(paren
id|set_number_at
comma
id|laststart
comma
id|b
id|laststart
comma
id|upper_bound
l_int|1
comma
id|b
)paren
suffix:semicolon
id|b
op_add_assign
l_int|5
suffix:semicolon
)brace
)brace
id|pending_exact
op_assign
l_int|0
suffix:semicolon
id|beg_interval
op_assign
l_int|NULL
suffix:semicolon
)brace
r_break
suffix:semicolon
id|unfetch_interval
suffix:colon
multiline_comment|/* If an invalid interval, match the characters as literals.  */
m_assert
(paren
id|beg_interval
)paren
suffix:semicolon
id|p
op_assign
id|beg_interval
suffix:semicolon
id|beg_interval
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* normal_char and normal_backslash need `c&squot;.  */
id|PATFETCH
(paren
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|syntax
op_amp
id|RE_NO_BK_BRACES
)paren
)paren
(brace
r_if
c_cond
(paren
id|p
OG
id|pattern
op_logical_and
id|p
(braket
l_int|1
)braket
op_eq
l_char|&squot;&bslash;&bslash;&squot;
)paren
r_goto
id|normal_backslash
suffix:semicolon
)brace
r_goto
id|normal_char
suffix:semicolon
macro_line|#ifdef emacs
multiline_comment|/* There is no way to specify the before_dot and after_dot&n;&t;       operators.  rms says this is ok.  --karl  */
r_case
l_char|&squot;=&squot;
suffix:colon
id|BUF_PUSH
(paren
id|at_dot
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;s&squot;
suffix:colon
id|laststart
op_assign
id|b
suffix:semicolon
id|PATFETCH
(paren
id|c
)paren
suffix:semicolon
id|BUF_PUSH_2
(paren
id|syntaxspec
comma
id|syntax_spec_code
(braket
id|c
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;S&squot;
suffix:colon
id|laststart
op_assign
id|b
suffix:semicolon
id|PATFETCH
(paren
id|c
)paren
suffix:semicolon
id|BUF_PUSH_2
(paren
id|notsyntaxspec
comma
id|syntax_spec_code
(braket
id|c
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif /* emacs */
r_case
l_char|&squot;w&squot;
suffix:colon
id|laststart
op_assign
id|b
suffix:semicolon
id|BUF_PUSH
(paren
id|wordchar
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;W&squot;
suffix:colon
id|laststart
op_assign
id|b
suffix:semicolon
id|BUF_PUSH
(paren
id|notwordchar
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;&lt;&squot;
suffix:colon
id|BUF_PUSH
(paren
id|wordbeg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;&gt;&squot;
suffix:colon
id|BUF_PUSH
(paren
id|wordend
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;b&squot;
suffix:colon
id|BUF_PUSH
(paren
id|wordbound
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;B&squot;
suffix:colon
id|BUF_PUSH
(paren
id|notwordbound
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;`&squot;
suffix:colon
id|BUF_PUSH
(paren
id|begbuf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;&bslash;&squot;&squot;
suffix:colon
id|BUF_PUSH
(paren
id|endbuf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;1&squot;
suffix:colon
r_case
l_char|&squot;2&squot;
suffix:colon
r_case
l_char|&squot;3&squot;
suffix:colon
r_case
l_char|&squot;4&squot;
suffix:colon
r_case
l_char|&squot;5&squot;
suffix:colon
r_case
l_char|&squot;6&squot;
suffix:colon
r_case
l_char|&squot;7&squot;
suffix:colon
r_case
l_char|&squot;8&squot;
suffix:colon
r_case
l_char|&squot;9&squot;
suffix:colon
r_if
c_cond
(paren
id|syntax
op_amp
id|RE_NO_BK_REFS
)paren
r_goto
id|normal_char
suffix:semicolon
id|c1
op_assign
id|c
l_char|&squot;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|c1
OG
id|regnum
)paren
r_return
id|REG_ESUBREG
suffix:semicolon
multiline_comment|/* Can&squot;t back reference to a subexpression if inside of it.  */
r_if
c_cond
(paren
id|group_in_compile_stack
(paren
id|compile_stack
comma
id|c1
)paren
)paren
r_goto
id|normal_char
suffix:semicolon
id|laststart
op_assign
id|b
suffix:semicolon
id|BUF_PUSH_2
(paren
id|duplicate
comma
id|c1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;+&squot;
suffix:colon
r_case
l_char|&squot;?&squot;
suffix:colon
r_if
c_cond
(paren
id|syntax
op_amp
id|RE_BK_PLUS_QM
)paren
r_goto
id|handle_plus
suffix:semicolon
r_else
r_goto
id|normal_backslash
suffix:semicolon
r_default
suffix:colon
id|normal_backslash
suffix:colon
multiline_comment|/* You might think it would be useful for &bslash; to mean&n;&t;&t; not to translate; but if we don&squot;t translate it&n;&t;&t; it will never match anything.  */
id|c
op_assign
id|TRANSLATE
(paren
id|c
)paren
suffix:semicolon
r_goto
id|normal_char
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
multiline_comment|/* Expects the character in `c&squot;.  */
id|normal_char
suffix:colon
multiline_comment|/* If no exactn currently being built.  */
r_if
c_cond
(paren
op_logical_neg
id|pending_exact
multiline_comment|/* If last exactn not at current position.  */
op_logical_or
id|pending_exact
op_plus
op_star
id|pending_exact
op_plus
l_int|1
op_ne
id|b
multiline_comment|/* We have only one byte following the exactn for the count.  */
op_logical_or
op_star
id|pending_exact
op_eq
(paren
l_int|1
op_lshift
id|BYTEWIDTH
)paren
l_int|1
multiline_comment|/* If followed by a repetition operator.  */
op_logical_or
op_star
id|p
op_eq
l_char|&squot;*&squot;
op_logical_or
op_star
id|p
op_eq
l_char|&squot;^&squot;
op_logical_or
(paren
(paren
id|syntax
op_amp
id|RE_BK_PLUS_QM
)paren
ques
c_cond
op_star
id|p
op_eq
l_char|&squot;&bslash;&bslash;&squot;
op_logical_and
(paren
id|p
(braket
l_int|1
)braket
op_eq
l_char|&squot;+&squot;
op_logical_or
id|p
(braket
l_int|1
)braket
op_eq
l_char|&squot;?&squot;
)paren
suffix:colon
(paren
op_star
id|p
op_eq
l_char|&squot;+&squot;
op_logical_or
op_star
id|p
op_eq
l_char|&squot;?&squot;
)paren
)paren
op_logical_or
(paren
(paren
id|syntax
op_amp
id|RE_INTERVALS
)paren
op_logical_and
(paren
(paren
id|syntax
op_amp
id|RE_NO_BK_BRACES
)paren
ques
c_cond
op_star
id|p
op_eq
l_char|&squot;{&squot;
suffix:colon
(paren
id|p
(braket
l_int|0
)braket
op_eq
l_char|&squot;&bslash;&bslash;&squot;
op_logical_and
id|p
(braket
l_int|1
)braket
op_eq
l_char|&squot;{&squot;
)paren
)paren
)paren
)paren
(brace
multiline_comment|/* Start building a new exactn.  */
id|laststart
op_assign
id|b
suffix:semicolon
id|BUF_PUSH_2
(paren
id|exactn
comma
l_int|0
)paren
suffix:semicolon
id|pending_exact
op_assign
id|b
l_int|1
suffix:semicolon
)brace
id|BUF_PUSH
(paren
id|c
)paren
suffix:semicolon
(paren
op_star
id|pending_exact
)paren
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* switch (c) */
)brace
multiline_comment|/* while p != pend */
multiline_comment|/* Through the pattern now.  */
r_if
c_cond
(paren
id|fixup_alt_jump
)paren
id|STORE_JUMP
(paren
id|jump_past_alt
comma
id|fixup_alt_jump
comma
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|COMPILE_STACK_EMPTY
)paren
r_return
id|REG_EPAREN
suffix:semicolon
id|free
(paren
id|compile_stack.stack
)paren
suffix:semicolon
multiline_comment|/* We have succeeded; set the length of the buffer.  */
id|bufp-&gt;used
op_assign
id|b
id|bufp-&gt;buffer
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|debug
)paren
(brace
id|DEBUG_PRINT1
(paren
l_string|&quot;&bslash;nCompiled pattern: &quot;
)paren
suffix:semicolon
id|print_compiled_pattern
(paren
id|bufp
)paren
suffix:semicolon
)brace
macro_line|#endif /* DEBUG */
r_return
id|REG_NOERROR
suffix:semicolon
)brace
multiline_comment|/* regex_compile */
"&f;"
multiline_comment|/* Subroutines for `regex_compile&squot;.  */
multiline_comment|/* Store OP at LOC followed by two-byte integer parameter ARG.  */
r_static
r_void
DECL|function|store_op1
id|store_op1
(paren
id|op
comma
id|loc
comma
id|arg
)paren
id|re_opcode_t
id|op
suffix:semicolon
r_int
r_char
op_star
id|loc
suffix:semicolon
r_int
id|arg
suffix:semicolon
(brace
op_star
id|loc
op_assign
(paren
r_int
r_char
)paren
id|op
suffix:semicolon
id|STORE_NUMBER
(paren
id|loc
op_plus
l_int|1
comma
id|arg
)paren
suffix:semicolon
)brace
multiline_comment|/* Like `store_op1&squot;, but for two two-byte parameters ARG1 and ARG2.  */
r_static
r_void
DECL|function|store_op2
id|store_op2
(paren
id|op
comma
id|loc
comma
id|arg1
comma
id|arg2
)paren
id|re_opcode_t
id|op
suffix:semicolon
r_int
r_char
op_star
id|loc
suffix:semicolon
r_int
id|arg1
comma
id|arg2
suffix:semicolon
(brace
op_star
id|loc
op_assign
(paren
r_int
r_char
)paren
id|op
suffix:semicolon
id|STORE_NUMBER
(paren
id|loc
op_plus
l_int|1
comma
id|arg1
)paren
suffix:semicolon
id|STORE_NUMBER
(paren
id|loc
op_plus
l_int|3
comma
id|arg2
)paren
suffix:semicolon
)brace
multiline_comment|/* Copy the bytes from LOC to END to open up three bytes of space at LOC&n;   for OP followed by two-byte integer parameter ARG.  */
r_static
r_void
DECL|function|insert_op1
id|insert_op1
(paren
id|op
comma
id|loc
comma
id|arg
comma
id|end
)paren
id|re_opcode_t
id|op
suffix:semicolon
r_int
r_char
op_star
id|loc
suffix:semicolon
r_int
id|arg
suffix:semicolon
r_int
r_char
op_star
id|end
suffix:semicolon
(brace
r_register
r_int
r_char
op_star
id|pfrom
op_assign
id|end
suffix:semicolon
r_register
r_int
r_char
op_star
id|pto
op_assign
id|end
op_plus
l_int|3
suffix:semicolon
r_while
c_loop
(paren
id|pfrom
op_ne
id|loc
)paren
op_star
op_decrement
id|pto
op_assign
op_star
op_decrement
id|pfrom
suffix:semicolon
id|store_op1
(paren
id|op
comma
id|loc
comma
id|arg
)paren
suffix:semicolon
)brace
multiline_comment|/* Like `insert_op1&squot;, but for two two-byte parameters ARG1 and ARG2.  */
r_static
r_void
DECL|function|insert_op2
id|insert_op2
(paren
id|op
comma
id|loc
comma
id|arg1
comma
id|arg2
comma
id|end
)paren
id|re_opcode_t
id|op
suffix:semicolon
r_int
r_char
op_star
id|loc
suffix:semicolon
r_int
id|arg1
comma
id|arg2
suffix:semicolon
r_int
r_char
op_star
id|end
suffix:semicolon
(brace
r_register
r_int
r_char
op_star
id|pfrom
op_assign
id|end
suffix:semicolon
r_register
r_int
r_char
op_star
id|pto
op_assign
id|end
op_plus
l_int|5
suffix:semicolon
r_while
c_loop
(paren
id|pfrom
op_ne
id|loc
)paren
op_star
op_decrement
id|pto
op_assign
op_star
op_decrement
id|pfrom
suffix:semicolon
id|store_op2
(paren
id|op
comma
id|loc
comma
id|arg1
comma
id|arg2
)paren
suffix:semicolon
)brace
multiline_comment|/* P points to just after a ^ in PATTERN.  Return true if that ^ comes&n;   after an alternative or a begin-subexpression.  We assume there is at&n;   least one character before the ^.  */
r_static
id|boolean
DECL|function|at_begline_loc_p
id|at_begline_loc_p
(paren
id|pattern
comma
id|p
comma
id|syntax
)paren
r_const
r_char
op_star
id|pattern
comma
op_star
id|p
suffix:semicolon
id|reg_syntax_t
id|syntax
suffix:semicolon
(brace
r_const
r_char
op_star
id|prev
op_assign
id|p
l_int|2
suffix:semicolon
id|boolean
id|prev_prev_backslash
op_assign
id|prev
OG
id|pattern
op_logical_and
id|prev
(braket
l_int|1
)braket
op_eq
l_char|&squot;&bslash;&bslash;&squot;
suffix:semicolon
r_return
multiline_comment|/* After a subexpression?  */
(paren
op_star
id|prev
op_eq
l_char|&squot;(&squot;
op_logical_and
(paren
id|syntax
op_amp
id|RE_NO_BK_PARENS
op_logical_or
id|prev_prev_backslash
)paren
)paren
multiline_comment|/* After an alternative?  */
op_logical_or
(paren
op_star
id|prev
op_eq
l_char|&squot;|&squot;
op_logical_and
(paren
id|syntax
op_amp
id|RE_NO_BK_VBAR
op_logical_or
id|prev_prev_backslash
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* The dual of at_begline_loc_p.  This one is for $.  We assume there is&n;   at least one character after the $, i.e., `P &lt; PEND&squot;.  */
r_static
id|boolean
DECL|function|at_endline_loc_p
id|at_endline_loc_p
(paren
id|p
comma
id|pend
comma
id|syntax
)paren
r_const
r_char
op_star
id|p
comma
op_star
id|pend
suffix:semicolon
r_int
id|syntax
suffix:semicolon
(brace
r_const
r_char
op_star
id|next
op_assign
id|p
suffix:semicolon
id|boolean
id|next_backslash
op_assign
op_star
id|next
op_eq
l_char|&squot;&bslash;&bslash;&squot;
suffix:semicolon
r_const
r_char
op_star
id|next_next
op_assign
id|p
op_plus
l_int|1
OL
id|pend
ques
c_cond
id|p
op_plus
l_int|1
suffix:colon
l_int|NULL
suffix:semicolon
r_return
multiline_comment|/* Before a subexpression?  */
(paren
id|syntax
op_amp
id|RE_NO_BK_PARENS
ques
c_cond
op_star
id|next
op_eq
l_char|&squot;)&squot;
suffix:colon
id|next_backslash
op_logical_and
id|next_next
op_logical_and
op_star
id|next_next
op_eq
l_char|&squot;)&squot;
)paren
multiline_comment|/* Before an alternative?  */
op_logical_or
(paren
id|syntax
op_amp
id|RE_NO_BK_VBAR
ques
c_cond
op_star
id|next
op_eq
l_char|&squot;|&squot;
suffix:colon
id|next_backslash
op_logical_and
id|next_next
op_logical_and
op_star
id|next_next
op_eq
l_char|&squot;|&squot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Returns true if REGNUM is in one of COMPILE_STACK&squot;s elements and&n;   false if it&squot;s not.  */
r_static
id|boolean
DECL|function|group_in_compile_stack
id|group_in_compile_stack
(paren
id|compile_stack
comma
id|regnum
)paren
id|compile_stack_type
id|compile_stack
suffix:semicolon
id|regnum_t
id|regnum
suffix:semicolon
(brace
r_int
id|this_element
suffix:semicolon
r_for
c_loop
(paren
id|this_element
op_assign
id|compile_stack.avail
l_int|1
suffix:semicolon
id|this_element
op_ge
l_int|0
suffix:semicolon
id|this_element
op_decrement
)paren
r_if
c_cond
(paren
id|compile_stack.stack
(braket
id|this_element
)braket
dot
id|regnum
op_eq
id|regnum
)paren
r_return
l_bool|true
suffix:semicolon
r_return
l_bool|false
suffix:semicolon
)brace
multiline_comment|/* Read the ending character of a range (in a bracket expression) from the&n;   uncompiled pattern *P_PTR (which ends at PEND).  We assume the&n;   starting character is in `P[-2]&squot;.  (`P[-1]&squot; is the character `-&squot;.)&n;   Then we set the translation of all bits between the starting and&n;   ending characters (inclusive) in the compiled pattern B.&n;&n;   Return an error code.&n;&n;   We use these short variable names so we can use the same macros as&n;   `regex_compile&squot; itself.  */
r_static
id|reg_errcode_t
DECL|function|compile_range
id|compile_range
(paren
id|p_ptr
comma
id|pend
comma
id|translate
comma
id|syntax
comma
id|b
)paren
r_const
r_char
op_star
op_star
id|p_ptr
comma
op_star
id|pend
suffix:semicolon
r_char
op_star
id|translate
suffix:semicolon
id|reg_syntax_t
id|syntax
suffix:semicolon
r_int
r_char
op_star
id|b
suffix:semicolon
(brace
r_int
id|this_char
suffix:semicolon
r_const
r_char
op_star
id|p
op_assign
op_star
id|p_ptr
suffix:semicolon
r_int
id|range_start
comma
id|range_end
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
id|pend
)paren
r_return
id|REG_ERANGE
suffix:semicolon
multiline_comment|/* Even though the pattern is a signed `char *&squot;, we need to fetch&n;     with unsigned char *&squot;s; if the high bit of the pattern character&n;     is set, the range endpoints will be negative if we fetch using a&n;     signed char *.&n;&n;     We also want to fetch the endpoints without translating them; the&n;     appropriate translation is done in the bit-setting loop below.  */
id|range_start
op_assign
(paren
(paren
r_int
r_char
op_star
)paren
id|p
)paren
(braket
l_int|2
)braket
suffix:semicolon
id|range_end
op_assign
(paren
(paren
r_int
r_char
op_star
)paren
id|p
)paren
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* Have to increment the pointer into the pattern string, so the&n;     caller isn&squot;t still at the ending character.  */
(paren
op_star
id|p_ptr
)paren
op_increment
suffix:semicolon
multiline_comment|/* If the start is after the end, the range is empty.  */
r_if
c_cond
(paren
id|range_start
OG
id|range_end
)paren
r_return
id|syntax
op_amp
id|RE_NO_EMPTY_RANGES
ques
c_cond
id|REG_ERANGE
suffix:colon
id|REG_NOERROR
suffix:semicolon
multiline_comment|/* Here we see why `this_char&squot; has to be larger than an `unsigned&n;     char&squot; -- the range is inclusive, so if `range_end&squot; == 0xff&n;     (assuming 8-bit characters), we would otherwise go into an infinite&n;     loop, since all characters &lt;= 0xff.  */
r_for
c_loop
(paren
id|this_char
op_assign
id|range_start
suffix:semicolon
id|this_char
op_le
id|range_end
suffix:semicolon
id|this_char
op_increment
)paren
(brace
id|SET_LIST_BIT
(paren
id|TRANSLATE
(paren
id|this_char
)paren
)paren
suffix:semicolon
)brace
r_return
id|REG_NOERROR
suffix:semicolon
)brace
"&f;"
multiline_comment|/* Failure stack declarations and macros; both re_compile_fastmap and&n;   re_match_2 use a failure stack.  These have to be macros because of&n;   REGEX_ALLOCATE.  */
multiline_comment|/* Number of failure points for which to initially allocate space&n;   when matching.  If this number is exceeded, we allocate more&n;   space, so it is not a hard limit.  */
macro_line|#ifndef INIT_FAILURE_ALLOC
DECL|macro|INIT_FAILURE_ALLOC
mdefine_line|#define INIT_FAILURE_ALLOC 5
macro_line|#endif
multiline_comment|/* Roughly the maximum number of failure points on the stack.  Would be&n;   exactly that if always used MAX_FAILURE_SPACE each time we failed.&n;   This is a variable only so users of regex can assign to it; we never&n;   change it ourselves.  */
DECL|variable|re_max_failures
r_int
id|re_max_failures
op_assign
l_int|2000
suffix:semicolon
DECL|typedef|fail_stack_elt_t
r_typedef
r_const
r_int
r_char
op_star
id|fail_stack_elt_t
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|stack
id|fail_stack_elt_t
op_star
id|stack
suffix:semicolon
DECL|member|size
r_int
id|size
suffix:semicolon
DECL|member|avail
r_int
id|avail
suffix:semicolon
multiline_comment|/* Offset of next open position.  */
DECL|typedef|fail_stack_type
)brace
id|fail_stack_type
suffix:semicolon
DECL|macro|FAIL_STACK_EMPTY
mdefine_line|#define FAIL_STACK_EMPTY()     (fail_stack.avail == 0)
DECL|macro|FAIL_STACK_PTR_EMPTY
mdefine_line|#define FAIL_STACK_PTR_EMPTY() (fail_stack_ptr-&gt;avail == 0)
DECL|macro|FAIL_STACK_FULL
mdefine_line|#define FAIL_STACK_FULL()      (fail_stack.avail == fail_stack.size)
DECL|macro|FAIL_STACK_TOP
mdefine_line|#define FAIL_STACK_TOP()       (fail_stack.stack[fail_stack.avail])
multiline_comment|/* Initialize `fail_stack&squot;.  Do `return -2&squot; if the alloc fails.  */
DECL|macro|INIT_FAIL_STACK
mdefine_line|#define INIT_FAIL_STACK()&t;&t;&t;&t;&t;&t;&bslash;&n;  do {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    fail_stack.stack = (fail_stack_elt_t *)&t;&t;&t;&t;&bslash;&n;      REGEX_ALLOCATE (INIT_FAILURE_ALLOC * sizeof (fail_stack_elt_t));&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    if (fail_stack.stack == NULL)&t;&t;&t;&t;&t;&bslash;&n;      return -2;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    fail_stack.size = INIT_FAILURE_ALLOC;&t;&t;&t;&t;&bslash;&n;    fail_stack.avail = 0;&t;&t;&t;&t;&t;&t;&bslash;&n;  } while (0)
multiline_comment|/* Double the size of FAIL_STACK, up to approximately `re_max_failures&squot; items.&n;&n;   Return 1 if succeeds, and 0 if either ran out of memory&n;   allocating space for it or it was already too large.&n;&n;   REGEX_REALLOCATE requires `destination&squot; be declared.   */
DECL|macro|DOUBLE_FAIL_STACK
mdefine_line|#define DOUBLE_FAIL_STACK(fail_stack)&t;&t;&t;&t;&t;&bslash;&n;  ((fail_stack).size &gt; re_max_failures * MAX_FAILURE_ITEMS&t;&t;&bslash;&n;   ? 0&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;   : ((fail_stack).stack = (fail_stack_elt_t *)&t;&t;&t;&t;&bslash;&n;&t;REGEX_REALLOCATE ((fail_stack).stack, &t;&t;&t;&t;&bslash;&n;&t;  (fail_stack).size * sizeof (fail_stack_elt_t),&t;&t;&bslash;&n;&t;  ((fail_stack).size &lt;&lt; 1) * sizeof (fail_stack_elt_t)),&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;      (fail_stack).stack == NULL&t;&t;&t;&t;&t;&bslash;&n;      ? 0&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;      : ((fail_stack).size &lt;&lt;= 1, &t;&t;&t;&t;&t;&bslash;&n;&t; 1)))
multiline_comment|/* Push PATTERN_OP on FAIL_STACK.&n;&n;   Return 1 if was able to do so and 0 if ran out of memory allocating&n;   space to do so.  */
DECL|macro|PUSH_PATTERN_OP
mdefine_line|#define PUSH_PATTERN_OP(pattern_op, fail_stack)&t;&t;&t;&t;&bslash;&n;  ((FAIL_STACK_FULL ()&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    &amp;&amp; !DOUBLE_FAIL_STACK (fail_stack))&t;&t;&t;&t;&t;&bslash;&n;    ? 0&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    : ((fail_stack).stack[(fail_stack).avail++] = pattern_op,&t;&t;&bslash;&n;       1))
multiline_comment|/* This pushes an item onto the failure stack.  Must be a four-byte&n;   value.  Assumes the variable `fail_stack&squot;.  Probably should only&n;   be called from within `PUSH_FAILURE_POINT&squot;.  */
DECL|macro|PUSH_FAILURE_ITEM
mdefine_line|#define PUSH_FAILURE_ITEM(item)&t;&t;&t;&t;&t;&t;&bslash;&n;  fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) item
multiline_comment|/* The complement operation.  Assumes `fail_stack&squot; is nonempty.  */
DECL|macro|POP_FAILURE_ITEM
mdefine_line|#define POP_FAILURE_ITEM() fail_stack.stack[--fail_stack.avail]
multiline_comment|/* Used to omit pushing failure point id&squot;s when we&squot;re not debugging.  */
macro_line|#ifdef DEBUG
DECL|macro|DEBUG_PUSH
mdefine_line|#define DEBUG_PUSH PUSH_FAILURE_ITEM
DECL|macro|DEBUG_POP
mdefine_line|#define DEBUG_POP(item_addr) *(item_addr) = POP_FAILURE_ITEM ()
macro_line|#else
DECL|macro|DEBUG_PUSH
mdefine_line|#define DEBUG_PUSH(item)
DECL|macro|DEBUG_POP
mdefine_line|#define DEBUG_POP(item_addr)
macro_line|#endif
multiline_comment|/* Push the information about the state we will need&n;   if we ever fail back to it.&n;&n;   Requires variables fail_stack, regstart, regend, reg_info, and&n;   num_regs be declared.  DOUBLE_FAIL_STACK requires `destination&squot; be&n;   declared.&n;&n;   Does `return FAILURE_CODE&squot; if runs out of memory.  */
DECL|macro|PUSH_FAILURE_POINT
mdefine_line|#define PUSH_FAILURE_POINT(pattern_place, string_place, failure_code)&t;&bslash;&n;  do {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    char *destination;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    /* Must be int, so when we don&squot;t save any registers, the arithmetic&t;&bslash;&n;       of 0 + -1 isn&squot;t done as unsigned.  */&t;&t;&t;&t;&bslash;&n;    int this_reg;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    DEBUG_STATEMENT (failure_id++);&t;&t;&t;&t;&t;&bslash;&n;    DEBUG_STATEMENT (nfailure_points_pushed++);&t;&t;&t;&t;&bslash;&n;    DEBUG_PRINT2 (&quot;&bslash;nPUSH_FAILURE_POINT #%u:&bslash;n&quot;, failure_id);&t;&t;&bslash;&n;    DEBUG_PRINT2 (&quot;  Before push, next avail: %d&bslash;n&quot;, (fail_stack).avail);&bslash;&n;    DEBUG_PRINT2 (&quot;                     size: %d&bslash;n&quot;, (fail_stack).size);&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    DEBUG_PRINT2 (&quot;  slots needed: %d&bslash;n&quot;, NUM_FAILURE_ITEMS);&t;&t;&bslash;&n;    DEBUG_PRINT2 (&quot;     available: %d&bslash;n&quot;, REMAINING_AVAIL_SLOTS);&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    /* Ensure we have enough space allocated for what we will push.  */&t;&bslash;&n;    while (REMAINING_AVAIL_SLOTS &lt; NUM_FAILURE_ITEMS)&t;&t;&t;&bslash;&n;      {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if (!DOUBLE_FAIL_STACK (fail_stack))&t;&t;&t;&bslash;&n;&t;  return failure_code;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;DEBUG_PRINT2 (&quot;&bslash;n  Doubled stack; size now: %d&bslash;n&quot;,&t;&t;&bslash;&n;&t;&t;       (fail_stack).size);&t;&t;&t;&t;&bslash;&n;&t;DEBUG_PRINT2 (&quot;  slots available: %d&bslash;n&quot;, REMAINING_AVAIL_SLOTS);&bslash;&n;      }&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    /* Push the info, starting with the registers.  */&t;&t;&t;&bslash;&n;    DEBUG_PRINT1 (&quot;&bslash;n&quot;);&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    for (this_reg = lowest_active_reg; this_reg &lt;= highest_active_reg;&t;&bslash;&n;&t; this_reg++)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;      {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;DEBUG_PRINT2 (&quot;  Pushing reg: %d&bslash;n&quot;, this_reg);&t;&t;&t;&bslash;&n;&t;DEBUG_STATEMENT (num_regs_pushed++);&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;DEBUG_PRINT2 (&quot;    start: 0x%x&bslash;n&quot;, regstart[this_reg]);&t;&t;&bslash;&n;&t;PUSH_FAILURE_ITEM (regstart[this_reg]);&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;DEBUG_PRINT2 (&quot;    end: 0x%x&bslash;n&quot;, regend[this_reg]);&t;&t;&bslash;&n;&t;PUSH_FAILURE_ITEM (regend[this_reg]);&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;DEBUG_PRINT2 (&quot;    info: 0x%x&bslash;n      &quot;, reg_info[this_reg]);&t;&bslash;&n;&t;DEBUG_PRINT2 (&quot; match_null=%d&quot;,&t;&t;&t;&t;&t;&bslash;&n;&t;&t;      REG_MATCH_NULL_STRING_P (reg_info[this_reg]));&t;&bslash;&n;&t;DEBUG_PRINT2 (&quot; active=%d&quot;, IS_ACTIVE (reg_info[this_reg]));&t;&bslash;&n;&t;DEBUG_PRINT2 (&quot; matched_something=%d&quot;,&t;&t;&t;&t;&bslash;&n;&t;&t;      MATCHED_SOMETHING (reg_info[this_reg]));&t;&t;&bslash;&n;&t;DEBUG_PRINT2 (&quot; ever_matched=%d&quot;,&t;&t;&t;&t;&bslash;&n;&t;&t;      EVER_MATCHED_SOMETHING (reg_info[this_reg]));&t;&bslash;&n;&t;DEBUG_PRINT1 (&quot;&bslash;n&quot;);&t;&t;&t;&t;&t;&t;&bslash;&n;&t;PUSH_FAILURE_ITEM (reg_info[this_reg].word);&t;&t;&t;&bslash;&n;      }&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    DEBUG_PRINT2 (&quot;  Pushing  low active reg: %d&bslash;n&quot;, lowest_active_reg);&bslash;&n;    PUSH_FAILURE_ITEM (lowest_active_reg);&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    DEBUG_PRINT2 (&quot;  Pushing high active reg: %d&bslash;n&quot;, highest_active_reg);&bslash;&n;    PUSH_FAILURE_ITEM (highest_active_reg);&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    DEBUG_PRINT2 (&quot;  Pushing pattern 0x%x: &quot;, pattern_place);&t;&t;&bslash;&n;    DEBUG_PRINT_COMPILED_PATTERN (bufp, pattern_place, pend);&t;&t;&bslash;&n;    PUSH_FAILURE_ITEM (pattern_place);&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    DEBUG_PRINT2 (&quot;  Pushing string 0x%x: `&quot;, string_place);&t;&t;&bslash;&n;    DEBUG_PRINT_DOUBLE_STRING (string_place, string1, size1, string2,   &bslash;&n;&t;&t;&t;&t; size2);&t;&t;&t;&t;&bslash;&n;    DEBUG_PRINT1 (&quot;&squot;&bslash;n&quot;);&t;&t;&t;&t;&t;&t;&bslash;&n;    PUSH_FAILURE_ITEM (string_place);&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    DEBUG_PRINT2 (&quot;  Pushing failure id: %u&bslash;n&quot;, failure_id);&t;&t;&bslash;&n;    DEBUG_PUSH (failure_id);&t;&t;&t;&t;&t;&t;&bslash;&n;  } while (0)
multiline_comment|/* This is the number of items that are pushed and popped on the stack&n;   for each register.  */
DECL|macro|NUM_REG_ITEMS
mdefine_line|#define NUM_REG_ITEMS  3
multiline_comment|/* Individual items aside from the registers.  */
macro_line|#ifdef DEBUG
DECL|macro|NUM_NONREG_ITEMS
mdefine_line|#define NUM_NONREG_ITEMS 5 /* Includes failure point id.  */
macro_line|#else
DECL|macro|NUM_NONREG_ITEMS
mdefine_line|#define NUM_NONREG_ITEMS 4
macro_line|#endif
multiline_comment|/* We push at most this many items on the stack.  */
DECL|macro|MAX_FAILURE_ITEMS
mdefine_line|#define MAX_FAILURE_ITEMS ((num_regs - 1) * NUM_REG_ITEMS + NUM_NONREG_ITEMS)
multiline_comment|/* We actually push this many items.  */
DECL|macro|NUM_FAILURE_ITEMS
mdefine_line|#define NUM_FAILURE_ITEMS&t;&t;&t;&t;&t;&t;&bslash;&n;  ((highest_active_reg - lowest_active_reg + 1) * NUM_REG_ITEMS &t;&bslash;&n;    + NUM_NONREG_ITEMS)
multiline_comment|/* How many items can still be added to the stack without overflowing it.  */
DECL|macro|REMAINING_AVAIL_SLOTS
mdefine_line|#define REMAINING_AVAIL_SLOTS ((fail_stack).size - (fail_stack).avail)
multiline_comment|/* Pops what PUSH_FAIL_STACK pushes.&n;&n;   We restore into the parameters, all of which should be lvalues:&n;     STR -- the saved data position.&n;     PAT -- the saved pattern position.&n;     LOW_REG, HIGH_REG -- the highest and lowest active registers.&n;     REGSTART, REGEND -- arrays of string positions.&n;     REG_INFO -- array of information about each subexpression.&n;&n;   Also assumes the variables `fail_stack&squot; and (if debugging), `bufp&squot;,&n;   `pend&squot;, `string1&squot;, `size1&squot;, `string2&squot;, and `size2&squot;.  */
DECL|macro|POP_FAILURE_POINT
mdefine_line|#define POP_FAILURE_POINT(str, pat, low_reg, high_reg, regstart, regend, reg_info)&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  DEBUG_STATEMENT (fail_stack_elt_t failure_id;)&t;&t;&t;&bslash;&n;  int this_reg;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  const unsigned char *string_temp;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  assert (!FAIL_STACK_EMPTY ());&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  /* Remove failure points and point to how many regs pushed.  */&t;&bslash;&n;  DEBUG_PRINT1 (&quot;POP_FAILURE_POINT:&bslash;n&quot;);&t;&t;&t;&t;&bslash;&n;  DEBUG_PRINT2 (&quot;  Before pop, next avail: %d&bslash;n&quot;, fail_stack.avail);&t;&bslash;&n;  DEBUG_PRINT2 (&quot;                    size: %d&bslash;n&quot;, fail_stack.size);&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  assert (fail_stack.avail &gt;= NUM_NONREG_ITEMS);&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  DEBUG_POP (&amp;failure_id);&t;&t;&t;&t;&t;&t;&bslash;&n;  DEBUG_PRINT2 (&quot;  Popping failure id: %u&bslash;n&quot;, failure_id);&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  /* If the saved string location is NULL, it came from an&t;&t;&bslash;&n;     on_failure_keep_string_jump opcode, and we want to throw away the&t;&bslash;&n;     saved NULL, thus retaining our current position in the string.  */&t;&bslash;&n;  string_temp = POP_FAILURE_ITEM ();&t;&t;&t;&t;&t;&bslash;&n;  if (string_temp != NULL)&t;&t;&t;&t;&t;&t;&bslash;&n;    str = (const char *) string_temp;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  DEBUG_PRINT2 (&quot;  Popping string 0x%x: `&quot;, str);&t;&t;&t;&bslash;&n;  DEBUG_PRINT_DOUBLE_STRING (str, string1, size1, string2, size2);&t;&bslash;&n;  DEBUG_PRINT1 (&quot;&squot;&bslash;n&quot;);&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  pat = (unsigned char *) POP_FAILURE_ITEM ();&t;&t;&t;&t;&bslash;&n;  DEBUG_PRINT2 (&quot;  Popping pattern 0x%x: &quot;, pat);&t;&t;&t;&bslash;&n;  DEBUG_PRINT_COMPILED_PATTERN (bufp, pat, pend);&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  /* Restore register info.  */&t;&t;&t;&t;&t;&t;&bslash;&n;  high_reg = (unsigned) POP_FAILURE_ITEM ();&t;&t;&t;&t;&bslash;&n;  DEBUG_PRINT2 (&quot;  Popping high active reg: %d&bslash;n&quot;, high_reg);&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  low_reg = (unsigned) POP_FAILURE_ITEM ();&t;&t;&t;&t;&bslash;&n;  DEBUG_PRINT2 (&quot;  Popping  low active reg: %d&bslash;n&quot;, low_reg);&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  for (this_reg = high_reg; this_reg &gt;= low_reg; this_reg--)&t;&t;&bslash;&n;    {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;      DEBUG_PRINT2 (&quot;    Popping reg: %d&bslash;n&quot;, this_reg);&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;      reg_info[this_reg].word = POP_FAILURE_ITEM ();&t;&t;&t;&bslash;&n;      DEBUG_PRINT2 (&quot;      info: 0x%x&bslash;n&quot;, reg_info[this_reg]);&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;      regend[this_reg] = (const char *) POP_FAILURE_ITEM ();&t;&t;&bslash;&n;      DEBUG_PRINT2 (&quot;      end: 0x%x&bslash;n&quot;, regend[this_reg]);&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;      regstart[this_reg] = (const char *) POP_FAILURE_ITEM ();&t;&t;&bslash;&n;      DEBUG_PRINT2 (&quot;      start: 0x%x&bslash;n&quot;, regstart[this_reg]);&t;&t;&bslash;&n;    }&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  DEBUG_STATEMENT (nfailure_points_popped++);&t;&t;&t;&t;&bslash;&n;} /* POP_FAILURE_POINT */
"&f;"
multiline_comment|/* re_compile_fastmap computes a ``fastmap&squot;&squot; for the compiled pattern in&n;   BUFP.  A fastmap records which of the (1 &lt;&lt; BYTEWIDTH) possible&n;   characters can start a string that matches the pattern.  This fastmap&n;   is used by re_search to skip quickly over impossible starting points.&n;&n;   The caller must supply the address of a (1 &lt;&lt; BYTEWIDTH)-byte data&n;   area as BUFP-&gt;fastmap.&n;&n;   We set the `fastmap&squot;, `fastmap_accurate&squot;, and `can_be_null&squot; fields in&n;   the pattern buffer.&n;&n;   Returns 0 if we succeed, -2 if an internal error.   */
r_int
DECL|function|re_compile_fastmap
id|re_compile_fastmap
(paren
id|bufp
)paren
r_struct
id|re_pattern_buffer
op_star
id|bufp
suffix:semicolon
(brace
r_int
id|j
comma
id|k
suffix:semicolon
id|fail_stack_type
id|fail_stack
suffix:semicolon
macro_line|#ifndef REGEX_MALLOC
r_char
op_star
id|destination
suffix:semicolon
macro_line|#endif
multiline_comment|/* We don&squot;t push any register information onto the failure stack.  */
r_int
id|num_regs
op_assign
l_int|0
suffix:semicolon
r_register
r_char
op_star
id|fastmap
op_assign
id|bufp-&gt;fastmap
suffix:semicolon
r_int
r_char
op_star
id|pattern
op_assign
id|bufp-&gt;buffer
suffix:semicolon
r_int
r_int
id|size
op_assign
id|bufp-&gt;used
suffix:semicolon
r_const
r_int
r_char
op_star
id|p
op_assign
id|pattern
suffix:semicolon
r_register
r_int
r_char
op_star
id|pend
op_assign
id|pattern
op_plus
id|size
suffix:semicolon
multiline_comment|/* Assume that each path through the pattern can be null until&n;     proven otherwise.  We set this false at the bottom of switch&n;     statement, to which we get only if a particular path doesn&squot;t&n;     match the empty string.  */
id|boolean
id|path_can_be_null
op_assign
l_bool|true
suffix:semicolon
multiline_comment|/* We aren&squot;t doing a `succeed_n&squot; to begin with.  */
id|boolean
id|succeed_n_p
op_assign
l_bool|false
suffix:semicolon
m_assert
(paren
id|fastmap
op_ne
l_int|NULL
op_logical_and
id|p
op_ne
l_int|NULL
)paren
suffix:semicolon
id|INIT_FAIL_STACK
(paren
)paren
suffix:semicolon
id|bzero
(paren
id|fastmap
comma
l_int|1
op_lshift
id|BYTEWIDTH
)paren
suffix:semicolon
multiline_comment|/* Assume nothing&squot;s valid.  */
id|bufp-&gt;fastmap_accurate
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* It will be when we&squot;re done.  */
id|bufp-&gt;can_be_null
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|p
op_ne
id|pend
op_logical_or
op_logical_neg
id|FAIL_STACK_EMPTY
(paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|p
op_eq
id|pend
)paren
(brace
id|bufp-&gt;can_be_null
op_or_assign
id|path_can_be_null
suffix:semicolon
multiline_comment|/* Reset for next path.  */
id|path_can_be_null
op_assign
l_bool|true
suffix:semicolon
id|p
op_assign
id|fail_stack.stack
(braket
op_decrement
id|fail_stack.avail
)braket
suffix:semicolon
)brace
multiline_comment|/* We should never be about to go beyond the end of the pattern.  */
m_assert
(paren
id|p
OL
id|pend
)paren
suffix:semicolon
macro_line|#ifdef SWITCH_ENUM_BUG
r_switch
c_cond
(paren
(paren
r_int
)paren
(paren
(paren
id|re_opcode_t
)paren
op_star
id|p
op_increment
)paren
)paren
macro_line|#else
r_switch
c_cond
(paren
(paren
id|re_opcode_t
)paren
op_star
id|p
op_increment
)paren
macro_line|#endif
(brace
multiline_comment|/* I guess the idea here is to simply not bother with a fastmap&n;&t;   if a backreference is used, since it&squot;s too hard to figure out&n;&t;   the fastmap for the corresponding group.  Setting&n;&t;   `can_be_null&squot; stops `re_search_2&squot; from using the fastmap, so&n;&t;   that is all we do.  */
r_case
id|duplicate
suffix:colon
id|bufp-&gt;can_be_null
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Following are the cases which match a character.  These end&n;&t; with `break&squot;.  */
r_case
id|exactn
suffix:colon
id|fastmap
(braket
id|p
(braket
l_int|1
)braket
)braket
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|charset
suffix:colon
r_for
c_loop
(paren
id|j
op_assign
op_star
id|p
op_increment
op_star
id|BYTEWIDTH
l_int|1
suffix:semicolon
id|j
op_ge
l_int|0
suffix:semicolon
id|j
op_decrement
)paren
r_if
c_cond
(paren
id|p
(braket
id|j
op_div
id|BYTEWIDTH
)braket
op_amp
(paren
l_int|1
op_lshift
(paren
id|j
op_mod
id|BYTEWIDTH
)paren
)paren
)paren
id|fastmap
(braket
id|j
)braket
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|charset_not
suffix:colon
multiline_comment|/* Chars beyond end of map must be allowed.  */
r_for
c_loop
(paren
id|j
op_assign
op_star
id|p
op_star
id|BYTEWIDTH
suffix:semicolon
id|j
OL
(paren
l_int|1
op_lshift
id|BYTEWIDTH
)paren
suffix:semicolon
id|j
op_increment
)paren
id|fastmap
(braket
id|j
)braket
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
op_star
id|p
op_increment
op_star
id|BYTEWIDTH
l_int|1
suffix:semicolon
id|j
op_ge
l_int|0
suffix:semicolon
id|j
op_decrement
)paren
r_if
c_cond
(paren
op_logical_neg
(paren
id|p
(braket
id|j
op_div
id|BYTEWIDTH
)braket
op_amp
(paren
l_int|1
op_lshift
(paren
id|j
op_mod
id|BYTEWIDTH
)paren
)paren
)paren
)paren
id|fastmap
(braket
id|j
)braket
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|wordchar
suffix:colon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
(paren
l_int|1
op_lshift
id|BYTEWIDTH
)paren
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
id|SYNTAX
(paren
id|j
)paren
op_eq
id|Sword
)paren
id|fastmap
(braket
id|j
)braket
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|notwordchar
suffix:colon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
(paren
l_int|1
op_lshift
id|BYTEWIDTH
)paren
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
id|SYNTAX
(paren
id|j
)paren
op_ne
id|Sword
)paren
id|fastmap
(braket
id|j
)braket
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|anychar
suffix:colon
multiline_comment|/* `.&squot; matches anything ...  */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
(paren
l_int|1
op_lshift
id|BYTEWIDTH
)paren
suffix:semicolon
id|j
op_increment
)paren
id|fastmap
(braket
id|j
)braket
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* ... except perhaps newline.  */
r_if
c_cond
(paren
op_logical_neg
(paren
id|bufp-&gt;syntax
op_amp
id|RE_DOT_NEWLINE
)paren
)paren
id|fastmap
(braket
l_char|&squot;&bslash;n&squot;
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Return if we have already set `can_be_null&squot;; if we have,&n;&t;     then the fastmap is irrelevant.  Something&squot;s wrong here.  */
r_else
r_if
c_cond
(paren
id|bufp-&gt;can_be_null
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Otherwise, have to check alternative paths.  */
r_break
suffix:semicolon
macro_line|#ifdef emacs
r_case
id|syntaxspec
suffix:colon
id|k
op_assign
op_star
id|p
op_increment
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
(paren
l_int|1
op_lshift
id|BYTEWIDTH
)paren
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
id|SYNTAX
(paren
id|j
)paren
op_eq
(paren
r_enum
id|syntaxcode
)paren
id|k
)paren
id|fastmap
(braket
id|j
)braket
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|notsyntaxspec
suffix:colon
id|k
op_assign
op_star
id|p
op_increment
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
(paren
l_int|1
op_lshift
id|BYTEWIDTH
)paren
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
id|SYNTAX
(paren
id|j
)paren
op_ne
(paren
r_enum
id|syntaxcode
)paren
id|k
)paren
id|fastmap
(braket
id|j
)braket
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* All cases after this match the empty string.  These end with&n;&t; `continue&squot;.  */
r_case
id|before_dot
suffix:colon
r_case
id|at_dot
suffix:colon
r_case
id|after_dot
suffix:colon
r_continue
suffix:semicolon
macro_line|#endif /* not emacs */
r_case
id|no_op
suffix:colon
r_case
id|begline
suffix:colon
r_case
id|endline
suffix:colon
r_case
id|begbuf
suffix:colon
r_case
id|endbuf
suffix:colon
r_case
id|wordbound
suffix:colon
r_case
id|notwordbound
suffix:colon
r_case
id|wordbeg
suffix:colon
r_case
id|wordend
suffix:colon
r_case
id|push_dummy_failure
suffix:colon
r_continue
suffix:semicolon
r_case
id|jump_n
suffix:colon
r_case
id|pop_failure_jump
suffix:colon
r_case
id|maybe_pop_jump
suffix:colon
r_case
id|jump
suffix:colon
r_case
id|jump_past_alt
suffix:colon
r_case
id|dummy_failure_jump
suffix:colon
id|EXTRACT_NUMBER_AND_INCR
(paren
id|j
comma
id|p
)paren
suffix:semicolon
id|p
op_add_assign
id|j
suffix:semicolon
r_if
c_cond
(paren
id|j
OG
l_int|0
)paren
r_continue
suffix:semicolon
multiline_comment|/* Jump backward implies we just went through the body of a&n;&t;     loop and matched nothing.  Opcode jumped to should be&n;&t;     `on_failure_jump&squot; or `succeed_n&squot;.  Just treat it like an&n;&t;     ordinary jump.  For a * loop, it has pushed its failure&n;&t;     point already; if so, discard that as redundant.  */
r_if
c_cond
(paren
(paren
id|re_opcode_t
)paren
op_star
id|p
op_ne
id|on_failure_jump
op_logical_and
(paren
id|re_opcode_t
)paren
op_star
id|p
op_ne
id|succeed_n
)paren
r_continue
suffix:semicolon
id|p
op_increment
suffix:semicolon
id|EXTRACT_NUMBER_AND_INCR
(paren
id|j
comma
id|p
)paren
suffix:semicolon
id|p
op_add_assign
id|j
suffix:semicolon
multiline_comment|/* If what&squot;s on the stack is where we are now, pop it.  */
r_if
c_cond
(paren
op_logical_neg
id|FAIL_STACK_EMPTY
(paren
)paren
op_logical_and
id|fail_stack.stack
(braket
id|fail_stack.avail
l_int|1
)braket
op_eq
id|p
)paren
id|fail_stack.avail
op_decrement
suffix:semicolon
r_continue
suffix:semicolon
r_case
id|on_failure_jump
suffix:colon
r_case
id|on_failure_keep_string_jump
suffix:colon
id|handle_on_failure_jump
suffix:colon
id|EXTRACT_NUMBER_AND_INCR
(paren
id|j
comma
id|p
)paren
suffix:semicolon
multiline_comment|/* For some patterns, e.g., `(a?)?&squot;, `p+j&squot; here points to the&n;&t;     end of the pattern.  We don&squot;t want to push such a point,&n;&t;     since when we restore it above, entering the switch will&n;&t;     increment `p&squot; past the end of the pattern.  We don&squot;t need&n;&t;     to push such a point since we obviously won&squot;t find any more&n;&t;     fastmap entries beyond `pend&squot;.  Such a pattern can match&n;&t;     the null string, though.  */
r_if
c_cond
(paren
id|p
op_plus
id|j
OL
id|pend
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|PUSH_PATTERN_OP
(paren
id|p
op_plus
id|j
comma
id|fail_stack
)paren
)paren
r_return
l_int|2
suffix:semicolon
)brace
r_else
id|bufp-&gt;can_be_null
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|succeed_n_p
)paren
(brace
id|EXTRACT_NUMBER_AND_INCR
(paren
id|k
comma
id|p
)paren
suffix:semicolon
multiline_comment|/* Skip the n.  */
id|succeed_n_p
op_assign
l_bool|false
suffix:semicolon
)brace
r_continue
suffix:semicolon
r_case
id|succeed_n
suffix:colon
multiline_comment|/* Get to the number of times to succeed.  */
id|p
op_add_assign
l_int|2
suffix:semicolon
multiline_comment|/* Increment p past the n for when k != 0.  */
id|EXTRACT_NUMBER_AND_INCR
(paren
id|k
comma
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|k
op_eq
l_int|0
)paren
(brace
id|p
op_sub_assign
l_int|4
suffix:semicolon
id|succeed_n_p
op_assign
l_bool|true
suffix:semicolon
multiline_comment|/* Spaghetti code alert.  */
r_goto
id|handle_on_failure_jump
suffix:semicolon
)brace
r_continue
suffix:semicolon
r_case
id|set_number_at
suffix:colon
id|p
op_add_assign
l_int|4
suffix:semicolon
r_continue
suffix:semicolon
r_case
id|start_memory
suffix:colon
r_case
id|stop_memory
suffix:colon
id|p
op_add_assign
l_int|2
suffix:semicolon
r_continue
suffix:semicolon
r_default
suffix:colon
m_abort
(paren
)paren
suffix:semicolon
multiline_comment|/* We have listed all the cases.  */
)brace
multiline_comment|/* switch *p++ */
multiline_comment|/* Getting here means we have found the possible starting&n;&t; characters for one path of the pattern -- and that the empty&n;&t; string does not match.  We need not follow this path further.&n;&t; Instead, look at the next alternative (remembered on the&n;&t; stack), or quit if no more.  The test at the top of the loop&n;&t; does these things.  */
id|path_can_be_null
op_assign
l_bool|false
suffix:semicolon
id|p
op_assign
id|pend
suffix:semicolon
)brace
multiline_comment|/* while p */
multiline_comment|/* Set `can_be_null&squot; for the last path (also the first path, if the&n;     pattern is empty).  */
id|bufp-&gt;can_be_null
op_or_assign
id|path_can_be_null
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* re_compile_fastmap */
"&f;"
multiline_comment|/* Set REGS to hold NUM_REGS registers, storing them in STARTS and&n;   ENDS.  Subsequent matches using PATTERN_BUFFER and REGS will use&n;   this memory for recording register information.  STARTS and ENDS&n;   must be allocated using the malloc library routine, and must each&n;   be at least NUM_REGS * sizeof (regoff_t) bytes long.&n;&n;   If NUM_REGS == 0, then subsequent matches should allocate their own&n;   register data.&n;&n;   Unless this function is called, the first search or match using&n;   PATTERN_BUFFER will allocate its own register data, without&n;   freeing the old data.  */
r_void
DECL|function|re_set_registers
id|re_set_registers
(paren
id|bufp
comma
id|regs
comma
id|num_regs
comma
id|starts
comma
id|ends
)paren
r_struct
id|re_pattern_buffer
op_star
id|bufp
suffix:semicolon
r_struct
id|re_registers
op_star
id|regs
suffix:semicolon
r_int
id|num_regs
suffix:semicolon
id|regoff_t
op_star
id|starts
comma
op_star
id|ends
suffix:semicolon
(brace
r_if
c_cond
(paren
id|num_regs
)paren
(brace
id|bufp-&gt;regs_allocated
op_assign
id|REGS_REALLOCATE
suffix:semicolon
id|regs-&gt;num_regs
op_assign
id|num_regs
suffix:semicolon
id|regs-&gt;start
op_assign
id|starts
suffix:semicolon
id|regs-&gt;end
op_assign
id|ends
suffix:semicolon
)brace
r_else
(brace
id|bufp-&gt;regs_allocated
op_assign
id|REGS_UNALLOCATED
suffix:semicolon
id|regs-&gt;num_regs
op_assign
l_int|0
suffix:semicolon
id|regs-&gt;start
op_assign
id|regs-&gt;end
op_assign
(paren
id|regoff_t
)paren
l_int|0
suffix:semicolon
)brace
)brace
"&f;"
multiline_comment|/* Searching routines.  */
multiline_comment|/* Like re_search_2, below, but only one string is specified, and&n;   doesn&squot;t let you say where to stop matching. */
r_int
DECL|function|re_search
id|re_search
(paren
id|bufp
comma
id|string
comma
id|size
comma
id|startpos
comma
id|range
comma
id|regs
)paren
r_struct
id|re_pattern_buffer
op_star
id|bufp
suffix:semicolon
r_const
r_char
op_star
id|string
suffix:semicolon
r_int
id|size
comma
id|startpos
comma
id|range
suffix:semicolon
r_struct
id|re_registers
op_star
id|regs
suffix:semicolon
(brace
r_return
id|re_search_2
(paren
id|bufp
comma
l_int|NULL
comma
l_int|0
comma
id|string
comma
id|size
comma
id|startpos
comma
id|range
comma
id|regs
comma
id|size
)paren
suffix:semicolon
)brace
multiline_comment|/* Using the compiled pattern in BUFP-&gt;buffer, first tries to match the&n;   virtual concatenation of STRING1 and STRING2, starting first at index&n;   STARTPOS, then at STARTPOS + 1, and so on.&n;&n;   STRING1 and STRING2 have length SIZE1 and SIZE2, respectively.&n;&n;   RANGE is how far to scan while trying to match.  RANGE = 0 means try&n;   only at STARTPOS; in general, the last start tried is STARTPOS +&n;   RANGE.&n;&n;   In REGS, return the indices of the virtual concatenation of STRING1&n;   and STRING2 that matched the entire BUFP-&gt;buffer and its contained&n;   subexpressions.&n;&n;   Do not consider matching one past the index STOP in the virtual&n;   concatenation of STRING1 and STRING2.&n;&n;   We return either the position in the strings at which the match was&n;   found, -1 if no match, or -2 if error (such as failure&n;   stack overflow).  */
r_int
DECL|function|re_search_2
id|re_search_2
(paren
id|bufp
comma
id|string1
comma
id|size1
comma
id|string2
comma
id|size2
comma
id|startpos
comma
id|range
comma
id|regs
comma
id|stop
)paren
r_struct
id|re_pattern_buffer
op_star
id|bufp
suffix:semicolon
r_const
r_char
op_star
id|string1
comma
op_star
id|string2
suffix:semicolon
r_int
id|size1
comma
id|size2
suffix:semicolon
r_int
id|startpos
suffix:semicolon
r_int
id|range
suffix:semicolon
r_struct
id|re_registers
op_star
id|regs
suffix:semicolon
r_int
id|stop
suffix:semicolon
(brace
r_int
id|val
suffix:semicolon
r_register
r_char
op_star
id|fastmap
op_assign
id|bufp-&gt;fastmap
suffix:semicolon
r_register
r_char
op_star
id|translate
op_assign
id|bufp-&gt;translate
suffix:semicolon
r_int
id|total_size
op_assign
id|size1
op_plus
id|size2
suffix:semicolon
r_int
id|endpos
op_assign
id|startpos
op_plus
id|range
suffix:semicolon
multiline_comment|/* Check for out-of-range STARTPOS.  */
r_if
c_cond
(paren
id|startpos
template_param
id|total_size
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Fix up RANGE if it might eventually take us outside&n;     the virtual concatenation of STRING1 and STRING2.  */
r_if
c_cond
(paren
id|endpos
OL
l_int|1
)paren
id|range
op_assign
l_int|1
id|startpos
suffix:semicolon
r_else
r_if
c_cond
(paren
id|endpos
OG
id|total_size
)paren
id|range
op_assign
id|total_size
id|startpos
suffix:semicolon
multiline_comment|/* If the search isn&squot;t to be a backwards one, don&squot;t waste time in a&n;     search for a pattern that must be anchored.  */
r_if
c_cond
(paren
id|bufp-&gt;used
OG
l_int|0
op_logical_and
(paren
id|re_opcode_t
)paren
id|bufp-&gt;buffer
(braket
l_int|0
)braket
op_eq
id|begbuf
op_logical_and
id|range
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|startpos
OG
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_else
id|range
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Update the fastmap now if not correct already.  */
r_if
c_cond
(paren
id|fastmap
op_logical_and
op_logical_neg
id|bufp-&gt;fastmap_accurate
)paren
r_if
c_cond
(paren
id|re_compile_fastmap
(paren
id|bufp
)paren
op_eq
l_int|2
)paren
r_return
l_int|2
suffix:semicolon
multiline_comment|/* Loop through the string, looking for a place to start matching.  */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* If a fastmap is supplied, skip quickly over characters that&n;&t; cannot be the start of a match.  If the pattern can match the&n;&t; null string, however, we don&squot;t need to skip characters; we want&n;&t; the first null string.  */
r_if
c_cond
(paren
id|fastmap
op_logical_and
id|startpos
OL
id|total_size
op_logical_and
op_logical_neg
id|bufp-&gt;can_be_null
)paren
(brace
r_if
c_cond
(paren
id|range
OG
l_int|0
)paren
multiline_comment|/* Searching forwards.  */
(brace
r_register
r_const
r_char
op_star
id|d
suffix:semicolon
r_register
r_int
id|lim
op_assign
l_int|0
suffix:semicolon
r_int
id|irange
op_assign
id|range
suffix:semicolon
r_if
c_cond
(paren
id|startpos
OL
id|size1
op_logical_and
id|startpos
op_plus
id|range
op_ge
id|size1
)paren
id|lim
op_assign
id|range
(paren
id|size1
id|startpos
)paren
suffix:semicolon
id|d
op_assign
(paren
id|startpos
op_ge
id|size1
ques
c_cond
id|string2
id|size1
suffix:colon
id|string1
)paren
op_plus
id|startpos
suffix:semicolon
multiline_comment|/* Written out as an if-else to avoid testing `translate&squot;&n;&t;&t; inside the loop.  */
r_if
c_cond
(paren
id|translate
)paren
r_while
c_loop
(paren
id|range
OG
id|lim
op_logical_and
op_logical_neg
id|fastmap
(braket
(paren
r_int
r_char
)paren
id|translate
(braket
(paren
r_int
r_char
)paren
op_star
id|d
op_increment
)braket
)braket
)paren
id|range
op_decrement
suffix:semicolon
r_else
r_while
c_loop
(paren
id|range
OG
id|lim
op_logical_and
op_logical_neg
id|fastmap
(braket
(paren
r_int
r_char
)paren
op_star
id|d
op_increment
)braket
)paren
id|range
op_decrement
suffix:semicolon
id|startpos
op_add_assign
id|irange
id|range
suffix:semicolon
)brace
r_else
multiline_comment|/* Searching backwards.  */
(brace
r_register
r_char
id|c
op_assign
(paren
id|size1
op_eq
l_int|0
op_logical_or
id|startpos
op_ge
id|size1
ques
c_cond
id|string2
(braket
id|startpos
id|size1
)braket
suffix:colon
id|string1
(braket
id|startpos
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fastmap
(braket
(paren
r_int
r_char
)paren
id|TRANSLATE
(paren
id|c
)paren
)braket
)paren
r_goto
id|advance
suffix:semicolon
)brace
)brace
multiline_comment|/* If can&squot;t match the null string, and that&squot;s all we have left, fail.  */
r_if
c_cond
(paren
id|range
op_ge
l_int|0
op_logical_and
id|startpos
op_eq
id|total_size
op_logical_and
id|fastmap
op_logical_and
op_logical_neg
id|bufp-&gt;can_be_null
)paren
r_return
l_int|1
suffix:semicolon
id|val
op_assign
id|re_match_2
(paren
id|bufp
comma
id|string1
comma
id|size1
comma
id|string2
comma
id|size2
comma
id|startpos
comma
id|regs
comma
id|stop
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ge
l_int|0
)paren
r_return
id|startpos
suffix:semicolon
r_if
c_cond
(paren
id|val
op_eq
l_int|2
)paren
r_return
l_int|2
suffix:semicolon
id|advance
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|range
)paren
r_break
suffix:semicolon
r_else
r_if
c_cond
(paren
id|range
OG
l_int|0
)paren
(brace
id|range
op_decrement
suffix:semicolon
id|startpos
op_increment
suffix:semicolon
)brace
r_else
(brace
id|range
op_increment
suffix:semicolon
id|startpos
op_decrement
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* re_search_2 */
"&f;"
multiline_comment|/* Declarations and macros for re_match_2.  */
r_static
r_int
id|bcmp_translate
(paren
)paren
suffix:semicolon
r_static
id|boolean
id|alt_match_null_string_p
(paren
)paren
comma
id|common_op_match_null_string_p
(paren
)paren
comma
id|group_match_null_string_p
(paren
)paren
suffix:semicolon
multiline_comment|/* Structure for per-register (a.k.a. per-group) information.&n;   This must not be longer than one word, because we push this value&n;   onto the failure stack.  Other register information, such as the&n;   starting and ending positions (which are addresses), and the list of&n;   inner groups (which is a bits list) are maintained in separate&n;   variables.&n;&n;   We are making a (strictly speaking) nonportable assumption here: that&n;   the compiler will pack our bit fields into something that fits into&n;   the type of `word&squot;, i.e., is something that fits into one item on the&n;   failure stack.  */
r_typedef
r_union
(brace
DECL|member|word
id|fail_stack_elt_t
id|word
suffix:semicolon
r_struct
(brace
multiline_comment|/* This field is one if this group can match the empty string,&n;&t; zero if not.  If not yet determined,  `MATCH_NULL_UNSET_VALUE&squot;.  */
DECL|macro|MATCH_NULL_UNSET_VALUE
mdefine_line|#define MATCH_NULL_UNSET_VALUE 3
DECL|member|match_null_string_p
r_int
id|match_null_string_p
suffix:colon
l_int|2
suffix:semicolon
DECL|member|is_active
r_int
id|is_active
suffix:colon
l_int|1
suffix:semicolon
DECL|member|matched_something
r_int
id|matched_something
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ever_matched_something
r_int
id|ever_matched_something
suffix:colon
l_int|1
suffix:semicolon
DECL|member|bits
)brace
id|bits
suffix:semicolon
DECL|typedef|register_info_type
)brace
id|register_info_type
suffix:semicolon
DECL|macro|REG_MATCH_NULL_STRING_P
mdefine_line|#define REG_MATCH_NULL_STRING_P(R)  ((R).bits.match_null_string_p)
DECL|macro|IS_ACTIVE
mdefine_line|#define IS_ACTIVE(R)  ((R).bits.is_active)
DECL|macro|MATCHED_SOMETHING
mdefine_line|#define MATCHED_SOMETHING(R)  ((R).bits.matched_something)
DECL|macro|EVER_MATCHED_SOMETHING
mdefine_line|#define EVER_MATCHED_SOMETHING(R)  ((R).bits.ever_matched_something)
multiline_comment|/* Call this when have matched a real character; it sets `matched&squot; flags&n;   for the subexpressions which we are currently inside.  Also records&n;   that those subexprs have matched.  */
DECL|macro|SET_REGS_MATCHED
mdefine_line|#define SET_REGS_MATCHED()&t;&t;&t;&t;&t;&t;&bslash;&n;  do&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;      unsigned r;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;      for (r = lowest_active_reg; r &lt;= highest_active_reg; r++)&t;&t;&bslash;&n;&t;{&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;  MATCHED_SOMETHING (reg_info[r])&t;&t;&t;&t;&bslash;&n;&t;    = EVER_MATCHED_SOMETHING (reg_info[r])&t;&t;&t;&bslash;&n;&t;    = 1;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;}&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    }&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  while (0)
multiline_comment|/* This converts PTR, a pointer into one of the search strings `string1&squot;&n;   and `string2&squot; into an offset from the beginning of that string.  */
DECL|macro|POINTER_TO_OFFSET
mdefine_line|#define POINTER_TO_OFFSET(ptr)&t;&t;&t;&t;&t;&t;&bslash;&n;  (FIRST_STRING_P (ptr) ? (ptr) - string1 : (ptr) - string2 + size1)
multiline_comment|/* Registers are set to a sentinel when they haven&squot;t yet matched.  */
DECL|macro|REG_UNSET_VALUE
mdefine_line|#define REG_UNSET_VALUE ((char *) -1)
DECL|macro|REG_UNSET
mdefine_line|#define REG_UNSET(e) ((e) == REG_UNSET_VALUE)
multiline_comment|/* Macros for dealing with the split strings in re_match_2.  */
DECL|macro|MATCHING_IN_FIRST_STRING
mdefine_line|#define MATCHING_IN_FIRST_STRING  (dend == end_match_1)
multiline_comment|/* Call before fetching a character with *d.  This switches over to&n;   string2 if necessary.  */
DECL|macro|PREFETCH
mdefine_line|#define PREFETCH()&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  while (d == dend)&t;&t;&t;&t;&t;&t;    &t;&bslash;&n;    {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;      /* End of string2 =&gt; fail.  */&t;&t;&t;&t;&t;&bslash;&n;      if (dend == end_match_2) &t;&t;&t;&t;&t;&t;&bslash;&n;&t;goto fail;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;      /* End of string1 =&gt; advance to string2.  */ &t;&t;&t;&bslash;&n;      d = string2;&t;&t;&t;&t;&t;&t;        &bslash;&n;      dend = end_match_2;&t;&t;&t;&t;&t;&t;&bslash;&n;    }
multiline_comment|/* Test if at very beginning or at very end of the virtual concatenation&n;   of `string1&squot; and `string2&squot;.  If only one string, it&squot;s `string2&squot;.  */
DECL|macro|AT_STRINGS_BEG
mdefine_line|#define AT_STRINGS_BEG(d) ((d) == (size1 ? string1 : string2) || !size2)
DECL|macro|AT_STRINGS_END
mdefine_line|#define AT_STRINGS_END(d) ((d) == end2)
multiline_comment|/* Test if D points to a character which is word-constituent.  We have&n;   two special cases to check for: if past the end of string1, look at&n;   the first character in string2; and if before the beginning of&n;   string2, look at the last character in string1.  */
DECL|macro|WORDCHAR_P
mdefine_line|#define WORDCHAR_P(d)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  (SYNTAX ((d) == end1 ? *string2&t;&t;&t;&t;&t;&bslash;&n;&t;   : (d) == string2 - 1 ? *(end1 - 1) : *(d))&t;&t;&t;&bslash;&n;   == Sword)
multiline_comment|/* Test if the character before D and the one at D differ with respect&n;   to being word-constituent.  */
DECL|macro|AT_WORD_BOUNDARY
mdefine_line|#define AT_WORD_BOUNDARY(d)&t;&t;&t;&t;&t;&t;&bslash;&n;  (AT_STRINGS_BEG (d) || AT_STRINGS_END (d)&t;&t;&t;&t;&bslash;&n;   || WORDCHAR_P (d - 1) != WORDCHAR_P (d))
multiline_comment|/* Free everything we malloc.  */
macro_line|#ifdef REGEX_MALLOC
DECL|macro|FREE_VAR
mdefine_line|#define FREE_VAR(var) if (var) free (var); var = NULL
DECL|macro|FREE_VARIABLES
mdefine_line|#define FREE_VARIABLES()&t;&t;&t;&t;&t;&t;&bslash;&n;  do {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    FREE_VAR (fail_stack.stack);&t;&t;&t;&t;&t;&bslash;&n;    FREE_VAR (regstart);&t;&t;&t;&t;&t;&t;&bslash;&n;    FREE_VAR (regend);&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    FREE_VAR (old_regstart);&t;&t;&t;&t;&t;&t;&bslash;&n;    FREE_VAR (old_regend);&t;&t;&t;&t;&t;&t;&bslash;&n;    FREE_VAR (best_regstart);&t;&t;&t;&t;&t;&t;&bslash;&n;    FREE_VAR (best_regend);&t;&t;&t;&t;&t;&t;&bslash;&n;    FREE_VAR (reg_info);&t;&t;&t;&t;&t;&t;&bslash;&n;    FREE_VAR (reg_dummy);&t;&t;&t;&t;&t;&t;&bslash;&n;    FREE_VAR (reg_info_dummy);&t;&t;&t;&t;&t;&t;&bslash;&n;  } while (0)
macro_line|#else /* not REGEX_MALLOC */
multiline_comment|/* Some MIPS systems (at least) want this to free alloca&squot;d storage.  */
DECL|macro|FREE_VARIABLES
mdefine_line|#define FREE_VARIABLES() alloca (0)
macro_line|#endif /* not REGEX_MALLOC */
multiline_comment|/* These values must meet several constraints.  They must not be valid&n;   register values; since we have a limit of 255 registers (because&n;   we use only one byte in the pattern for the register number), we can&n;   use numbers larger than 255.  They must differ by 1, because of&n;   NUM_FAILURE_ITEMS above.  And the value for the lowest register must&n;   be larger than the value for the highest register, so we do not try&n;   to actually save any registers when none are active.  */
DECL|macro|NO_HIGHEST_ACTIVE_REG
mdefine_line|#define NO_HIGHEST_ACTIVE_REG (1 &lt;&lt; BYTEWIDTH)
DECL|macro|NO_LOWEST_ACTIVE_REG
mdefine_line|#define NO_LOWEST_ACTIVE_REG (NO_HIGHEST_ACTIVE_REG + 1)
"&f;"
multiline_comment|/* Matching routines.  */
macro_line|#ifndef emacs   /* Emacs never uses this.  */
multiline_comment|/* re_match is like re_match_2 except it takes only a single string.  */
r_int
DECL|function|re_match
id|re_match
(paren
id|bufp
comma
id|string
comma
id|size
comma
id|pos
comma
id|regs
)paren
r_struct
id|re_pattern_buffer
op_star
id|bufp
suffix:semicolon
r_const
r_char
op_star
id|string
suffix:semicolon
r_int
id|size
comma
id|pos
suffix:semicolon
r_struct
id|re_registers
op_star
id|regs
suffix:semicolon
(brace
r_return
id|re_match_2
(paren
id|bufp
comma
l_int|NULL
comma
l_int|0
comma
id|string
comma
id|size
comma
id|pos
comma
id|regs
comma
id|size
)paren
suffix:semicolon
)brace
macro_line|#endif /* not emacs */
multiline_comment|/* re_match_2 matches the compiled pattern in BUFP against the&n;   the (virtual) concatenation of STRING1 and STRING2 (of length SIZE1&n;   and SIZE2, respectively).  We start matching at POS, and stop&n;   matching at STOP.&n;&n;   If REGS is non-null and the `no_sub&squot; field of BUFP is nonzero, we&n;   store offsets for the substring each group matched in REGS.  See the&n;   documentation for exactly how many groups we fill.&n;&n;   We return -1 if no match, -2 if an internal error (such as the&n;   failure stack overflowing).  Otherwise, we return the length of the&n;   matched substring.  */
r_int
DECL|function|re_match_2
id|re_match_2
(paren
id|bufp
comma
id|string1
comma
id|size1
comma
id|string2
comma
id|size2
comma
id|pos
comma
id|regs
comma
id|stop
)paren
r_struct
id|re_pattern_buffer
op_star
id|bufp
suffix:semicolon
r_const
r_char
op_star
id|string1
comma
op_star
id|string2
suffix:semicolon
r_int
id|size1
comma
id|size2
suffix:semicolon
r_int
id|pos
suffix:semicolon
r_struct
id|re_registers
op_star
id|regs
suffix:semicolon
r_int
id|stop
suffix:semicolon
(brace
multiline_comment|/* General temporaries.  */
r_int
id|mcnt
suffix:semicolon
r_int
r_char
op_star
id|p1
suffix:semicolon
multiline_comment|/* Just past the end of the corresponding string.  */
r_const
r_char
op_star
id|end1
comma
op_star
id|end2
suffix:semicolon
multiline_comment|/* Pointers into string1 and string2, just past the last characters in&n;     each to consider matching.  */
r_const
r_char
op_star
id|end_match_1
comma
op_star
id|end_match_2
suffix:semicolon
multiline_comment|/* Where we are in the data, and the end of the current string.  */
r_const
r_char
op_star
id|d
comma
op_star
id|dend
suffix:semicolon
multiline_comment|/* Where we are in the pattern, and the end of the pattern.  */
r_int
r_char
op_star
id|p
op_assign
id|bufp-&gt;buffer
suffix:semicolon
r_register
r_int
r_char
op_star
id|pend
op_assign
id|p
op_plus
id|bufp-&gt;used
suffix:semicolon
multiline_comment|/* We use this to map every character in the string.  */
r_char
op_star
id|translate
op_assign
id|bufp-&gt;translate
suffix:semicolon
multiline_comment|/* Failure point stack.  Each place that can handle a failure further&n;     down the line pushes a failure point on this stack.  It consists of&n;     restart, regend, and reg_info for all registers corresponding to&n;     the subexpressions we&squot;re currently inside, plus the number of such&n;     registers, and, finally, two char *&squot;s.  The first char * is where&n;     to resume scanning the pattern; the second one is where to resume&n;     scanning the strings.  If the latter is zero, the failure point is&n;     a ``dummy&squot;&squot;; if a failure happens and the failure point is a dummy,&n;     it gets discarded and the next next one is tried.  */
id|fail_stack_type
id|fail_stack
suffix:semicolon
macro_line|#ifdef DEBUG
r_static
r_int
id|failure_id
op_assign
l_int|0
suffix:semicolon
r_int
id|nfailure_points_pushed
op_assign
l_int|0
comma
id|nfailure_points_popped
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/* We fill all the registers internally, independent of what we&n;     return, for use in backreferences.  The number here includes&n;     an element for register zero.  */
r_int
id|num_regs
op_assign
id|bufp-&gt;re_nsub
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* The currently active registers.  */
r_int
id|lowest_active_reg
op_assign
id|NO_LOWEST_ACTIVE_REG
suffix:semicolon
r_int
id|highest_active_reg
op_assign
id|NO_HIGHEST_ACTIVE_REG
suffix:semicolon
multiline_comment|/* Information on the contents of registers. These are pointers into&n;     the input strings; they record just what was matched (on this&n;     attempt) by a subexpression part of the pattern, that is, the&n;     regnum-th regstart pointer points to where in the pattern we began&n;     matching and the regnum-th regend points to right after where we&n;     stopped matching the regnum-th subexpression.  (The zeroth register&n;     keeps track of what the whole pattern matches.)  */
r_const
r_char
op_star
op_star
id|regstart
op_assign
l_int|NULL
comma
op_star
op_star
id|regend
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* If a group that&squot;s operated upon by a repetition operator fails to&n;     match anything, then the register for its start will need to be&n;     restored because it will have been set to wherever in the string we&n;     are when we last see its open-group operator.  Similarly for a&n;     register&squot;s end.  */
r_const
r_char
op_star
op_star
id|old_regstart
op_assign
l_int|NULL
comma
op_star
op_star
id|old_regend
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* The is_active field of reg_info helps us keep track of which (possibly&n;     nested) subexpressions we are currently in. The matched_something&n;     field of reg_info[reg_num] helps us tell whether or not we have&n;     matched any of the pattern so far this time through the reg_num-th&n;     subexpression.  These two fields get reset each time through any&n;     loop their register is in.  */
id|register_info_type
op_star
id|reg_info
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* The following record the register info as found in the above&n;     variables when we find a match better than any we&squot;ve seen before.&n;     This happens as we backtrack through the failure points, which in&n;     turn happens only if we have not yet matched the entire string. */
r_int
id|best_regs_set
op_assign
l_bool|false
suffix:semicolon
r_const
r_char
op_star
op_star
id|best_regstart
op_assign
l_int|NULL
comma
op_star
op_star
id|best_regend
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Logically, this is `best_regend[0]&squot;.  But we don&squot;t want to have to&n;     allocate space for that if we&squot;re not allocating space for anything&n;     else (see below).  Also, we never need info about register 0 for&n;     any of the other register vectors, and it seems rather a kludge to&n;     treat `best_regend&squot; differently than the rest.  So we keep track of&n;     the end of the best match so far in a separate variable.  We&n;     initialize this to NULL so that when we backtrack the first time&n;     and need to test it, it&squot;s not garbage.  */
r_const
r_char
op_star
id|match_end
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Used when we pop values we don&squot;t care about.  */
r_const
r_char
op_star
op_star
id|reg_dummy
op_assign
l_int|NULL
suffix:semicolon
id|register_info_type
op_star
id|reg_info_dummy
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef DEBUG
multiline_comment|/* Counts the total number of registers pushed.  */
r_int
id|num_regs_pushed
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|DEBUG_PRINT1
(paren
l_string|&quot;&bslash;n&bslash;nEntering re_match_2.&bslash;n&quot;
)paren
suffix:semicolon
id|INIT_FAIL_STACK
(paren
)paren
suffix:semicolon
multiline_comment|/* Do not bother to initialize all the register variables if there are&n;     no groups in the pattern, as it takes a fair amount of time.  If&n;     there are groups, we include space for register 0 (the whole&n;     pattern), even though we never use it, since it simplifies the&n;     array indexing.  We should fix this.  */
r_if
c_cond
(paren
id|bufp-&gt;re_nsub
)paren
(brace
id|regstart
op_assign
id|REGEX_TALLOC
(paren
id|num_regs
comma
r_const
r_char
op_star
)paren
suffix:semicolon
id|regend
op_assign
id|REGEX_TALLOC
(paren
id|num_regs
comma
r_const
r_char
op_star
)paren
suffix:semicolon
id|old_regstart
op_assign
id|REGEX_TALLOC
(paren
id|num_regs
comma
r_const
r_char
op_star
)paren
suffix:semicolon
id|old_regend
op_assign
id|REGEX_TALLOC
(paren
id|num_regs
comma
r_const
r_char
op_star
)paren
suffix:semicolon
id|best_regstart
op_assign
id|REGEX_TALLOC
(paren
id|num_regs
comma
r_const
r_char
op_star
)paren
suffix:semicolon
id|best_regend
op_assign
id|REGEX_TALLOC
(paren
id|num_regs
comma
r_const
r_char
op_star
)paren
suffix:semicolon
id|reg_info
op_assign
id|REGEX_TALLOC
(paren
id|num_regs
comma
id|register_info_type
)paren
suffix:semicolon
id|reg_dummy
op_assign
id|REGEX_TALLOC
(paren
id|num_regs
comma
r_const
r_char
op_star
)paren
suffix:semicolon
id|reg_info_dummy
op_assign
id|REGEX_TALLOC
(paren
id|num_regs
comma
id|register_info_type
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|regstart
op_logical_and
id|regend
op_logical_and
id|old_regstart
op_logical_and
id|old_regend
op_logical_and
id|reg_info
op_logical_and
id|best_regstart
op_logical_and
id|best_regend
op_logical_and
id|reg_dummy
op_logical_and
id|reg_info_dummy
)paren
)paren
(brace
id|FREE_VARIABLES
(paren
)paren
suffix:semicolon
r_return
l_int|2
suffix:semicolon
)brace
)brace
macro_line|#ifdef REGEX_MALLOC
r_else
(brace
multiline_comment|/* We must initialize all our variables to NULL, so that&n;&t; `FREE_VARIABLES&squot; doesn&squot;t try to free them.  */
id|regstart
op_assign
id|regend
op_assign
id|old_regstart
op_assign
id|old_regend
op_assign
id|best_regstart
op_assign
id|best_regend
op_assign
id|reg_dummy
op_assign
l_int|NULL
suffix:semicolon
id|reg_info
op_assign
id|reg_info_dummy
op_assign
(paren
id|register_info_type
op_star
)paren
l_int|NULL
suffix:semicolon
)brace
macro_line|#endif /* REGEX_MALLOC */
multiline_comment|/* The starting position is bogus.  */
r_if
c_cond
(paren
id|pos
template_param
id|size1
op_plus
id|size2
)paren
(brace
id|FREE_VARIABLES
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Initialize subexpression text positions to -1 to mark ones that no&n;     start_memory/stop_memory has been seen for. Also initialize the&n;     register information struct.  */
r_for
c_loop
(paren
id|mcnt
op_assign
l_int|1
suffix:semicolon
id|mcnt
OL
id|num_regs
suffix:semicolon
id|mcnt
op_increment
)paren
(brace
id|regstart
(braket
id|mcnt
)braket
op_assign
id|regend
(braket
id|mcnt
)braket
op_assign
id|old_regstart
(braket
id|mcnt
)braket
op_assign
id|old_regend
(braket
id|mcnt
)braket
op_assign
id|REG_UNSET_VALUE
suffix:semicolon
id|REG_MATCH_NULL_STRING_P
(paren
id|reg_info
(braket
id|mcnt
)braket
)paren
op_assign
id|MATCH_NULL_UNSET_VALUE
suffix:semicolon
id|IS_ACTIVE
(paren
id|reg_info
(braket
id|mcnt
)braket
)paren
op_assign
l_int|0
suffix:semicolon
id|MATCHED_SOMETHING
(paren
id|reg_info
(braket
id|mcnt
)braket
)paren
op_assign
l_int|0
suffix:semicolon
id|EVER_MATCHED_SOMETHING
(paren
id|reg_info
(braket
id|mcnt
)braket
)paren
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* We move `string1&squot; into `string2&squot; if the latter&squot;s empty -- but not if&n;     `string1&squot; is null.  */
r_if
c_cond
(paren
id|size2
op_eq
l_int|0
op_logical_and
id|string1
op_ne
l_int|NULL
)paren
(brace
id|string2
op_assign
id|string1
suffix:semicolon
id|size2
op_assign
id|size1
suffix:semicolon
id|string1
op_assign
l_int|0
suffix:semicolon
id|size1
op_assign
l_int|0
suffix:semicolon
)brace
id|end1
op_assign
id|string1
op_plus
id|size1
suffix:semicolon
id|end2
op_assign
id|string2
op_plus
id|size2
suffix:semicolon
multiline_comment|/* Compute where to stop matching, within the two strings.  */
r_if
c_cond
(paren
id|stop
op_le
id|size1
)paren
(brace
id|end_match_1
op_assign
id|string1
op_plus
id|stop
suffix:semicolon
id|end_match_2
op_assign
id|string2
suffix:semicolon
)brace
r_else
(brace
id|end_match_1
op_assign
id|end1
suffix:semicolon
id|end_match_2
op_assign
id|string2
op_plus
id|stop
id|size1
suffix:semicolon
)brace
multiline_comment|/* `p&squot; scans through the pattern as `d&squot; scans through the data.&n;     `dend&squot; is the end of the input string that `d&squot; points within.  `d&squot;&n;     is advanced into the following input string whenever necessary, but&n;     this happens before fetching; therefore, at the beginning of the&n;     loop, `d&squot; can be pointing at the end of a string, but it cannot&n;     equal `string2&squot;.  */
r_if
c_cond
(paren
id|size1
OG
l_int|0
op_logical_and
id|pos
op_le
id|size1
)paren
(brace
id|d
op_assign
id|string1
op_plus
id|pos
suffix:semicolon
id|dend
op_assign
id|end_match_1
suffix:semicolon
)brace
r_else
(brace
id|d
op_assign
id|string2
op_plus
id|pos
id|size1
suffix:semicolon
id|dend
op_assign
id|end_match_2
suffix:semicolon
)brace
id|DEBUG_PRINT1
(paren
l_string|&quot;The compiled pattern is: &quot;
)paren
suffix:semicolon
id|DEBUG_PRINT_COMPILED_PATTERN
(paren
id|bufp
comma
id|p
comma
id|pend
)paren
suffix:semicolon
id|DEBUG_PRINT1
(paren
l_string|&quot;The string to match is: `&quot;
)paren
suffix:semicolon
id|DEBUG_PRINT_DOUBLE_STRING
(paren
id|d
comma
id|string1
comma
id|size1
comma
id|string2
comma
id|size2
)paren
suffix:semicolon
id|DEBUG_PRINT1
(paren
l_string|&quot;&squot;&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* This loops over pattern commands.  It exits by returning from the&n;     function if the match is complete, or it drops through if the match&n;     fails at this starting point in the input data.  */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|DEBUG_PRINT2
(paren
l_string|&quot;&bslash;n0x%x: &quot;
comma
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
id|pend
)paren
(brace
multiline_comment|/* End of pattern means we might have succeeded.  */
id|DEBUG_PRINT1
(paren
l_string|&quot;end of pattern ... &quot;
)paren
suffix:semicolon
multiline_comment|/* If we haven&squot;t matched the entire string, and we want the&n;&t;     longest match, try backtracking.  */
r_if
c_cond
(paren
id|d
op_ne
id|end_match_2
)paren
(brace
id|DEBUG_PRINT1
(paren
l_string|&quot;backtracking.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|FAIL_STACK_EMPTY
(paren
)paren
)paren
(brace
multiline_comment|/* More failure points to try.  */
id|boolean
id|same_str_p
op_assign
(paren
id|FIRST_STRING_P
(paren
id|match_end
)paren
op_eq
id|MATCHING_IN_FIRST_STRING
)paren
suffix:semicolon
multiline_comment|/* If exceeds best match so far, save it.  */
r_if
c_cond
(paren
op_logical_neg
id|best_regs_set
op_logical_or
(paren
id|same_str_p
op_logical_and
id|d
OG
id|match_end
)paren
op_logical_or
(paren
op_logical_neg
id|same_str_p
op_logical_and
op_logical_neg
id|MATCHING_IN_FIRST_STRING
)paren
)paren
(brace
id|best_regs_set
op_assign
l_bool|true
suffix:semicolon
id|match_end
op_assign
id|d
suffix:semicolon
id|DEBUG_PRINT1
(paren
l_string|&quot;&bslash;nSAVING match as best so far.&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|mcnt
op_assign
l_int|1
suffix:semicolon
id|mcnt
OL
id|num_regs
suffix:semicolon
id|mcnt
op_increment
)paren
(brace
id|best_regstart
(braket
id|mcnt
)braket
op_assign
id|regstart
(braket
id|mcnt
)braket
suffix:semicolon
id|best_regend
(braket
id|mcnt
)braket
op_assign
id|regend
(braket
id|mcnt
)braket
suffix:semicolon
)brace
)brace
r_goto
id|fail
suffix:semicolon
)brace
multiline_comment|/* If no failure points, don&squot;t restore garbage.  */
r_else
r_if
c_cond
(paren
id|best_regs_set
)paren
(brace
id|restore_best_regs
suffix:colon
multiline_comment|/* Restore best match.  It may happen that `dend ==&n;&t;&t;     end_match_1&squot; while the restored d is in string2.&n;&t;&t;     For example, the pattern `x.*y.*z&squot; against the&n;&t;&t;     strings `x-&squot; and `y-z-&squot;, if the two strings are&n;&t;&t;     not consecutive in memory.  */
id|DEBUG_PRINT1
(paren
l_string|&quot;Restoring best registers.&bslash;n&quot;
)paren
suffix:semicolon
id|d
op_assign
id|match_end
suffix:semicolon
id|dend
op_assign
(paren
(paren
id|d
op_ge
id|string1
op_logical_and
id|d
op_le
id|end1
)paren
ques
c_cond
id|end_match_1
suffix:colon
id|end_match_2
)paren
suffix:semicolon
r_for
c_loop
(paren
id|mcnt
op_assign
l_int|1
suffix:semicolon
id|mcnt
OL
id|num_regs
suffix:semicolon
id|mcnt
op_increment
)paren
(brace
id|regstart
(braket
id|mcnt
)braket
op_assign
id|best_regstart
(braket
id|mcnt
)braket
suffix:semicolon
id|regend
(braket
id|mcnt
)braket
op_assign
id|best_regend
(braket
id|mcnt
)braket
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* d != end_match_2 */
id|DEBUG_PRINT1
(paren
l_string|&quot;Accepting match.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* If caller wants register contents data back, do it.  */
r_if
c_cond
(paren
id|regs
op_logical_and
op_logical_neg
id|bufp-&gt;no_sub
)paren
(brace
multiline_comment|/* Have the register data arrays been allocated?  */
r_if
c_cond
(paren
id|bufp-&gt;regs_allocated
op_eq
id|REGS_UNALLOCATED
)paren
(brace
multiline_comment|/* No.  So allocate them with malloc.  We need one&n;&t;&t;     extra element beyond `num_regs&squot; for the `-1&squot; marker&n;&t;&t;     GNU code uses.  */
id|regs-&gt;num_regs
op_assign
id|MAX
(paren
id|RE_NREGS
comma
id|num_regs
op_plus
l_int|1
)paren
suffix:semicolon
id|regs-&gt;start
op_assign
id|TALLOC
(paren
id|regs-&gt;num_regs
comma
id|regoff_t
)paren
suffix:semicolon
id|regs-&gt;end
op_assign
id|TALLOC
(paren
id|regs-&gt;num_regs
comma
id|regoff_t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|regs-&gt;start
op_eq
l_int|NULL
op_logical_or
id|regs-&gt;end
op_eq
l_int|NULL
)paren
r_return
l_int|2
suffix:semicolon
id|bufp-&gt;regs_allocated
op_assign
id|REGS_REALLOCATE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|bufp-&gt;regs_allocated
op_eq
id|REGS_REALLOCATE
)paren
(brace
multiline_comment|/* Yes.  If we need more elements than were already&n;&t;&t;     allocated, reallocate them.  If we need fewer, just&n;&t;&t;     leave it alone.  */
r_if
c_cond
(paren
id|regs-&gt;num_regs
OL
id|num_regs
op_plus
l_int|1
)paren
(brace
id|regs-&gt;num_regs
op_assign
id|num_regs
op_plus
l_int|1
suffix:semicolon
id|RETALLOC
(paren
id|regs-&gt;start
comma
id|regs-&gt;num_regs
comma
id|regoff_t
)paren
suffix:semicolon
id|RETALLOC
(paren
id|regs-&gt;end
comma
id|regs-&gt;num_regs
comma
id|regoff_t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|regs-&gt;start
op_eq
l_int|NULL
op_logical_or
id|regs-&gt;end
op_eq
l_int|NULL
)paren
r_return
l_int|2
suffix:semicolon
)brace
)brace
r_else
m_assert
(paren
id|bufp-&gt;regs_allocated
op_eq
id|REGS_FIXED
)paren
suffix:semicolon
multiline_comment|/* Convert the pointer data in `regstart&squot; and `regend&squot; to&n;&t;&t; indices.  Register zero has to be set differently,&n;&t;&t; since we haven&squot;t kept track of any info for it.  */
r_if
c_cond
(paren
id|regs-&gt;num_regs
OG
l_int|0
)paren
(brace
id|regs-&gt;start
(braket
l_int|0
)braket
op_assign
id|pos
suffix:semicolon
id|regs-&gt;end
(braket
l_int|0
)braket
op_assign
(paren
id|MATCHING_IN_FIRST_STRING
ques
c_cond
id|d
id|string1
suffix:colon
id|d
id|string2
op_plus
id|size1
)paren
suffix:semicolon
)brace
multiline_comment|/* Go through the first `min (num_regs, regs-&gt;num_regs)&squot;&n;&t;&t; registers, since that is all we initialized.  */
r_for
c_loop
(paren
id|mcnt
op_assign
l_int|1
suffix:semicolon
id|mcnt
OL
id|MIN
(paren
id|num_regs
comma
id|regs-&gt;num_regs
)paren
suffix:semicolon
id|mcnt
op_increment
)paren
(brace
r_if
c_cond
(paren
id|REG_UNSET
(paren
id|regstart
(braket
id|mcnt
)braket
)paren
op_logical_or
id|REG_UNSET
(paren
id|regend
(braket
id|mcnt
)braket
)paren
)paren
id|regs-&gt;start
(braket
id|mcnt
)braket
op_assign
id|regs-&gt;end
(braket
id|mcnt
)braket
op_assign
l_int|1
suffix:semicolon
r_else
(brace
id|regs-&gt;start
(braket
id|mcnt
)braket
op_assign
id|POINTER_TO_OFFSET
(paren
id|regstart
(braket
id|mcnt
)braket
)paren
suffix:semicolon
id|regs-&gt;end
(braket
id|mcnt
)braket
op_assign
id|POINTER_TO_OFFSET
(paren
id|regend
(braket
id|mcnt
)braket
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* If the regs structure we return has more elements than&n;&t;&t; were in the pattern, set the extra elements to -1.  If&n;&t;&t; we (re)allocated the registers, this is the case,&n;&t;&t; because we always allocate enough to have at least one&n;&t;&t; -1 at the end.  */
r_for
c_loop
(paren
id|mcnt
op_assign
id|num_regs
suffix:semicolon
id|mcnt
OL
id|regs-&gt;num_regs
suffix:semicolon
id|mcnt
op_increment
)paren
id|regs-&gt;start
(braket
id|mcnt
)braket
op_assign
id|regs-&gt;end
(braket
id|mcnt
)braket
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* regs &amp;&amp; !bufp-&gt;no_sub */
id|FREE_VARIABLES
(paren
)paren
suffix:semicolon
id|DEBUG_PRINT4
(paren
l_string|&quot;%u failure points pushed, %u popped (%u remain).&bslash;n&quot;
comma
id|nfailure_points_pushed
comma
id|nfailure_points_popped
comma
id|nfailure_points_pushed
id|nfailure_points_popped
)paren
suffix:semicolon
id|DEBUG_PRINT2
(paren
l_string|&quot;%u registers pushed.&bslash;n&quot;
comma
id|num_regs_pushed
)paren
suffix:semicolon
id|mcnt
op_assign
id|d
id|pos
(paren
id|MATCHING_IN_FIRST_STRING
ques
c_cond
id|string1
suffix:colon
id|string2
id|size1
)paren
suffix:semicolon
id|DEBUG_PRINT2
(paren
l_string|&quot;Returning %d from re_match_2.&bslash;n&quot;
comma
id|mcnt
)paren
suffix:semicolon
r_return
id|mcnt
suffix:semicolon
)brace
multiline_comment|/* Otherwise match next pattern command.  */
macro_line|#ifdef SWITCH_ENUM_BUG
r_switch
c_cond
(paren
(paren
r_int
)paren
(paren
(paren
id|re_opcode_t
)paren
op_star
id|p
op_increment
)paren
)paren
macro_line|#else
r_switch
c_cond
(paren
(paren
id|re_opcode_t
)paren
op_star
id|p
op_increment
)paren
macro_line|#endif
(brace
multiline_comment|/* Ignore these.  Used to ignore the n of succeed_n&squot;s which&n;&t;   currently have n == 0.  */
r_case
id|no_op
suffix:colon
id|DEBUG_PRINT1
(paren
l_string|&quot;EXECUTING no_op.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Match the next n pattern characters exactly.  The following&n;&t;   byte in the pattern defines n, and the n bytes after that&n;&t;   are the characters to match.  */
r_case
id|exactn
suffix:colon
id|mcnt
op_assign
op_star
id|p
op_increment
suffix:semicolon
id|DEBUG_PRINT2
(paren
l_string|&quot;EXECUTING exactn %d.&bslash;n&quot;
comma
id|mcnt
)paren
suffix:semicolon
multiline_comment|/* This is written out as an if-else so we don&squot;t waste time&n;&t;     testing `translate&squot; inside the loop.  */
r_if
c_cond
(paren
id|translate
)paren
(brace
r_do
(brace
id|PREFETCH
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|translate
(braket
(paren
r_int
r_char
)paren
op_star
id|d
op_increment
)braket
op_ne
(paren
r_char
)paren
op_star
id|p
op_increment
)paren
r_goto
id|fail
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|mcnt
)paren
suffix:semicolon
)brace
r_else
(brace
r_do
(brace
id|PREFETCH
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|d
op_increment
op_ne
(paren
r_char
)paren
op_star
id|p
op_increment
)paren
r_goto
id|fail
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|mcnt
)paren
suffix:semicolon
)brace
id|SET_REGS_MATCHED
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Match any character except possibly a newline or a null.  */
r_case
id|anychar
suffix:colon
id|DEBUG_PRINT1
(paren
l_string|&quot;EXECUTING anychar.&bslash;n&quot;
)paren
suffix:semicolon
id|PREFETCH
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
(paren
id|bufp-&gt;syntax
op_amp
id|RE_DOT_NEWLINE
)paren
op_logical_and
id|TRANSLATE
(paren
op_star
id|d
)paren
op_eq
l_char|&squot;&bslash;n&squot;
)paren
op_logical_or
(paren
id|bufp-&gt;syntax
op_amp
id|RE_DOT_NOT_NULL
op_logical_and
id|TRANSLATE
(paren
op_star
id|d
)paren
op_eq
l_char|&squot;&bslash;000&squot;
)paren
)paren
r_goto
id|fail
suffix:semicolon
id|SET_REGS_MATCHED
(paren
)paren
suffix:semicolon
id|DEBUG_PRINT2
(paren
l_string|&quot;  Matched `%d&squot;.&bslash;n&quot;
comma
op_star
id|d
)paren
suffix:semicolon
id|d
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|charset
suffix:colon
r_case
id|charset_not
suffix:colon
(brace
r_register
r_int
r_char
id|c
suffix:semicolon
id|boolean
op_logical_neg
op_assign
(paren
id|re_opcode_t
)paren
op_star
(paren
id|p
l_int|1
)paren
op_eq
id|charset_not
suffix:semicolon
id|DEBUG_PRINT2
(paren
l_string|&quot;EXECUTING charset%s.&bslash;n&quot;
comma
op_logical_neg
ques
c_cond
l_string|&quot;_not&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|PREFETCH
(paren
)paren
suffix:semicolon
id|c
op_assign
id|TRANSLATE
(paren
op_star
id|d
)paren
suffix:semicolon
multiline_comment|/* The character to match.  */
multiline_comment|/* Cast to `unsigned&squot; instead of `unsigned char&squot; in case the&n;&t;       bit list is a full 32 bytes long.  */
r_if
c_cond
(paren
id|c
OL
(paren
r_int
)paren
(paren
op_star
id|p
op_star
id|BYTEWIDTH
)paren
op_logical_and
id|p
(braket
l_int|1
op_plus
id|c
op_div
id|BYTEWIDTH
)braket
op_amp
(paren
l_int|1
op_lshift
(paren
id|c
op_mod
id|BYTEWIDTH
)paren
)paren
)paren
op_logical_neg
op_assign
op_logical_neg
op_logical_neg
suffix:semicolon
id|p
op_add_assign
l_int|1
op_plus
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_logical_neg
)paren
r_goto
id|fail
suffix:semicolon
id|SET_REGS_MATCHED
(paren
)paren
suffix:semicolon
id|d
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* The beginning of a group is represented by start_memory.&n;&t;   The arguments are the register number in the next byte, and the&n;&t;   number of groups inner to this one in the next.  The text&n;&t;   matched within the group is recorded (in the internal&n;&t;   registers data structure) under the register number.  */
r_case
id|start_memory
suffix:colon
id|DEBUG_PRINT3
(paren
l_string|&quot;EXECUTING start_memory %d (%d):&bslash;n&quot;
comma
op_star
id|p
comma
id|p
(braket
l_int|1
)braket
)paren
suffix:semicolon
multiline_comment|/* Find out if this group can match the empty string.  */
id|p1
op_assign
id|p
suffix:semicolon
multiline_comment|/* To send to group_match_null_string_p.  */
r_if
c_cond
(paren
id|REG_MATCH_NULL_STRING_P
(paren
id|reg_info
(braket
op_star
id|p
)braket
)paren
op_eq
id|MATCH_NULL_UNSET_VALUE
)paren
id|REG_MATCH_NULL_STRING_P
(paren
id|reg_info
(braket
op_star
id|p
)braket
)paren
op_assign
id|group_match_null_string_p
(paren
op_amp
id|p1
comma
id|pend
comma
id|reg_info
)paren
suffix:semicolon
multiline_comment|/* Save the position in the string where we were the last time&n;&t;     we were at this open-group operator in case the group is&n;&t;     operated upon by a repetition operator, e.g., with `(a*)*b&squot;&n;&t;     against `ab&squot;; then we want to ignore where we are now in&n;&t;     the string in case this attempt to match fails.  */
id|old_regstart
(braket
op_star
id|p
)braket
op_assign
id|REG_MATCH_NULL_STRING_P
(paren
id|reg_info
(braket
op_star
id|p
)braket
)paren
ques
c_cond
id|REG_UNSET
(paren
id|regstart
(braket
op_star
id|p
)braket
)paren
ques
c_cond
id|d
suffix:colon
id|regstart
(braket
op_star
id|p
)braket
suffix:colon
id|regstart
(braket
op_star
id|p
)braket
suffix:semicolon
id|DEBUG_PRINT2
(paren
l_string|&quot;  old_regstart: %d&bslash;n&quot;
comma
id|POINTER_TO_OFFSET
(paren
id|old_regstart
(braket
op_star
id|p
)braket
)paren
)paren
suffix:semicolon
id|regstart
(braket
op_star
id|p
)braket
op_assign
id|d
suffix:semicolon
id|DEBUG_PRINT2
(paren
l_string|&quot;  regstart: %d&bslash;n&quot;
comma
id|POINTER_TO_OFFSET
(paren
id|regstart
(braket
op_star
id|p
)braket
)paren
)paren
suffix:semicolon
id|IS_ACTIVE
(paren
id|reg_info
(braket
op_star
id|p
)braket
)paren
op_assign
l_int|1
suffix:semicolon
id|MATCHED_SOMETHING
(paren
id|reg_info
(braket
op_star
id|p
)braket
)paren
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* This is the new highest active register.  */
id|highest_active_reg
op_assign
op_star
id|p
suffix:semicolon
multiline_comment|/* If nothing was active before, this is the new lowest active&n;&t;     register.  */
r_if
c_cond
(paren
id|lowest_active_reg
op_eq
id|NO_LOWEST_ACTIVE_REG
)paren
id|lowest_active_reg
op_assign
op_star
id|p
suffix:semicolon
multiline_comment|/* Move past the register number and inner group count.  */
id|p
op_add_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* The stop_memory opcode represents the end of a group.  Its&n;&t;   arguments are the same as start_memory&squot;s: the register&n;&t;   number, and the number of inner groups.  */
r_case
id|stop_memory
suffix:colon
id|DEBUG_PRINT3
(paren
l_string|&quot;EXECUTING stop_memory %d (%d):&bslash;n&quot;
comma
op_star
id|p
comma
id|p
(braket
l_int|1
)braket
)paren
suffix:semicolon
multiline_comment|/* We need to save the string position the last time we were at&n;&t;     this close-group operator in case the group is operated&n;&t;     upon by a repetition operator, e.g., with `((a*)*(b*)*)*&squot;&n;&t;     against `aba&squot;; then we want to ignore where we are now in&n;&t;     the string in case this attempt to match fails.  */
id|old_regend
(braket
op_star
id|p
)braket
op_assign
id|REG_MATCH_NULL_STRING_P
(paren
id|reg_info
(braket
op_star
id|p
)braket
)paren
ques
c_cond
id|REG_UNSET
(paren
id|regend
(braket
op_star
id|p
)braket
)paren
ques
c_cond
id|d
suffix:colon
id|regend
(braket
op_star
id|p
)braket
suffix:colon
id|regend
(braket
op_star
id|p
)braket
suffix:semicolon
id|DEBUG_PRINT2
(paren
l_string|&quot;      old_regend: %d&bslash;n&quot;
comma
id|POINTER_TO_OFFSET
(paren
id|old_regend
(braket
op_star
id|p
)braket
)paren
)paren
suffix:semicolon
id|regend
(braket
op_star
id|p
)braket
op_assign
id|d
suffix:semicolon
id|DEBUG_PRINT2
(paren
l_string|&quot;      regend: %d&bslash;n&quot;
comma
id|POINTER_TO_OFFSET
(paren
id|regend
(braket
op_star
id|p
)braket
)paren
)paren
suffix:semicolon
multiline_comment|/* This register isn&squot;t active anymore.  */
id|IS_ACTIVE
(paren
id|reg_info
(braket
op_star
id|p
)braket
)paren
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If this was the only register active, nothing is active&n;&t;     anymore.  */
r_if
c_cond
(paren
id|lowest_active_reg
op_eq
id|highest_active_reg
)paren
(brace
id|lowest_active_reg
op_assign
id|NO_LOWEST_ACTIVE_REG
suffix:semicolon
id|highest_active_reg
op_assign
id|NO_HIGHEST_ACTIVE_REG
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We must scan for the new highest active register, since&n;&t;&t; it isn&squot;t necessarily one less than now: consider&n;&t;&t; (a(b)c(d(e)f)g).  When group 3 ends, after the f), the&n;&t;&t; new highest active register is 1.  */
r_int
r_char
id|r
op_assign
op_star
id|p
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|r
OG
l_int|0
op_logical_and
op_logical_neg
id|IS_ACTIVE
(paren
id|reg_info
(braket
id|r
)braket
)paren
)paren
id|r
op_decrement
suffix:semicolon
multiline_comment|/* If we end up at register zero, that means that we saved&n;&t;&t; the registers as the result of an `on_failure_jump&squot;, not&n;&t;&t; a `start_memory&squot;, and we jumped to past the innermost&n;&t;&t; `stop_memory&squot;.  For example, in ((.)*) we save&n;&t;&t; registers 1 and 2 as a result of the *, but when we pop&n;&t;&t; back to the second ), we are at the stop_memory 1.&n;&t;&t; Thus, nothing is active.  */
r_if
c_cond
(paren
id|r
op_eq
l_int|0
)paren
(brace
id|lowest_active_reg
op_assign
id|NO_LOWEST_ACTIVE_REG
suffix:semicolon
id|highest_active_reg
op_assign
id|NO_HIGHEST_ACTIVE_REG
suffix:semicolon
)brace
r_else
id|highest_active_reg
op_assign
id|r
suffix:semicolon
)brace
multiline_comment|/* If just failed to match something this time around with a&n;&t;     group that&squot;s operated on by a repetition operator, try to&n;&t;     force exit from the ``loop&squot;&squot;, and restore the register&n;&t;     information for this group that we had before trying this&n;&t;     last match.  */
r_if
c_cond
(paren
(paren
op_logical_neg
id|MATCHED_SOMETHING
(paren
id|reg_info
(braket
op_star
id|p
)braket
)paren
op_logical_or
(paren
id|re_opcode_t
)paren
id|p
(braket
l_int|3
)braket
op_eq
id|start_memory
)paren
op_logical_and
(paren
id|p
op_plus
l_int|2
)paren
OL
id|pend
)paren
(brace
id|boolean
id|is_a_jump_n
op_assign
l_bool|false
suffix:semicolon
id|p1
op_assign
id|p
op_plus
l_int|2
suffix:semicolon
id|mcnt
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
(paren
id|re_opcode_t
)paren
op_star
id|p1
op_increment
)paren
(brace
r_case
id|jump_n
suffix:colon
id|is_a_jump_n
op_assign
l_bool|true
suffix:semicolon
r_case
id|pop_failure_jump
suffix:colon
r_case
id|maybe_pop_jump
suffix:colon
r_case
id|jump
suffix:colon
r_case
id|dummy_failure_jump
suffix:colon
id|EXTRACT_NUMBER_AND_INCR
(paren
id|mcnt
comma
id|p1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_a_jump_n
)paren
id|p1
op_add_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* do nothing */
suffix:semicolon
)brace
id|p1
op_add_assign
id|mcnt
suffix:semicolon
multiline_comment|/* If the next operation is a jump backwards in the pattern&n;&t;&t; to an on_failure_jump right before the start_memory&n;&t;&t; corresponding to this stop_memory, exit from the loop&n;&t;&t; by forcing a failure after pushing on the stack the&n;&t;&t; on_failure_jump&squot;s jump in the pattern, and d.  */
r_if
c_cond
(paren
id|mcnt
OL
l_int|0
op_logical_and
(paren
id|re_opcode_t
)paren
op_star
id|p1
op_eq
id|on_failure_jump
op_logical_and
(paren
id|re_opcode_t
)paren
id|p1
(braket
l_int|3
)braket
op_eq
id|start_memory
op_logical_and
id|p1
(braket
l_int|4
)braket
op_eq
op_star
id|p
)paren
(brace
multiline_comment|/* If this group ever matched anything, then restore&n;&t;&t;     what its registers were before trying this last&n;&t;&t;     failed match, e.g., with `(a*)*b&squot; against `ab&squot; for&n;&t;&t;     regstart[1], and, e.g., with `((a*)*(b*)*)*&squot;&n;&t;&t;     against `aba&squot; for regend[3].&n;&n;&t;&t;     Also restore the registers for inner groups for,&n;&t;&t;     e.g., `((a*)(b*))*&squot; against `aba&squot; (register 3 would&n;&t;&t;     otherwise get trashed).  */
r_if
c_cond
(paren
id|EVER_MATCHED_SOMETHING
(paren
id|reg_info
(braket
op_star
id|p
)braket
)paren
)paren
(brace
r_int
id|r
suffix:semicolon
id|EVER_MATCHED_SOMETHING
(paren
id|reg_info
(braket
op_star
id|p
)braket
)paren
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Restore this and inner groups&squot; (if any) registers.  */
r_for
c_loop
(paren
id|r
op_assign
op_star
id|p
suffix:semicolon
id|r
OL
op_star
id|p
op_plus
op_star
(paren
id|p
op_plus
l_int|1
)paren
suffix:semicolon
id|r
op_increment
)paren
(brace
id|regstart
(braket
id|r
)braket
op_assign
id|old_regstart
(braket
id|r
)braket
suffix:semicolon
multiline_comment|/* xx why this test?  */
r_if
c_cond
(paren
(paren
r_int
)paren
id|old_regend
(braket
id|r
)braket
op_ge
(paren
r_int
)paren
id|regstart
(braket
id|r
)braket
)paren
id|regend
(braket
id|r
)braket
op_assign
id|old_regend
(braket
id|r
)braket
suffix:semicolon
)brace
)brace
id|p1
op_increment
suffix:semicolon
id|EXTRACT_NUMBER_AND_INCR
(paren
id|mcnt
comma
id|p1
)paren
suffix:semicolon
id|PUSH_FAILURE_POINT
(paren
id|p1
op_plus
id|mcnt
comma
id|d
comma
l_int|2
)paren
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
)brace
multiline_comment|/* Move past the register number and the inner group count.  */
id|p
op_add_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* &bslash;&lt;digit&gt; has been turned into a `duplicate&squot; command which is&n;&t;   followed by the numeric value of &lt;digit&gt; as the register number.  */
r_case
id|duplicate
suffix:colon
(brace
r_register
r_const
r_char
op_star
id|d2
comma
op_star
id|dend2
suffix:semicolon
r_int
id|regno
op_assign
op_star
id|p
op_increment
suffix:semicolon
multiline_comment|/* Get which register to match against.  */
id|DEBUG_PRINT2
(paren
l_string|&quot;EXECUTING duplicate %d.&bslash;n&quot;
comma
id|regno
)paren
suffix:semicolon
multiline_comment|/* Can&squot;t back reference a group which we&squot;ve never matched.  */
r_if
c_cond
(paren
id|REG_UNSET
(paren
id|regstart
(braket
id|regno
)braket
)paren
op_logical_or
id|REG_UNSET
(paren
id|regend
(braket
id|regno
)braket
)paren
)paren
r_goto
id|fail
suffix:semicolon
multiline_comment|/* Where in input to try to start matching.  */
id|d2
op_assign
id|regstart
(braket
id|regno
)braket
suffix:semicolon
multiline_comment|/* Where to stop matching; if both the place to start and&n;&t;       the place to stop matching are in the same string, then&n;&t;       set to the place to stop, otherwise, for now have to use&n;&t;       the end of the first string.  */
id|dend2
op_assign
(paren
(paren
id|FIRST_STRING_P
(paren
id|regstart
(braket
id|regno
)braket
)paren
op_eq
id|FIRST_STRING_P
(paren
id|regend
(braket
id|regno
)braket
)paren
)paren
ques
c_cond
id|regend
(braket
id|regno
)braket
suffix:colon
id|end_match_1
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* If necessary, advance to next segment in register&n;&t;&t;   contents.  */
r_while
c_loop
(paren
id|d2
op_eq
id|dend2
)paren
(brace
r_if
c_cond
(paren
id|dend2
op_eq
id|end_match_2
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|dend2
op_eq
id|regend
(braket
id|regno
)braket
)paren
r_break
suffix:semicolon
multiline_comment|/* End of string1 =&gt; advance to string2. */
id|d2
op_assign
id|string2
suffix:semicolon
id|dend2
op_assign
id|regend
(braket
id|regno
)braket
suffix:semicolon
)brace
multiline_comment|/* At end of register contents =&gt; success */
r_if
c_cond
(paren
id|d2
op_eq
id|dend2
)paren
r_break
suffix:semicolon
multiline_comment|/* If necessary, advance to next segment in data.  */
id|PREFETCH
(paren
)paren
suffix:semicolon
multiline_comment|/* How many characters left in this segment to match.  */
id|mcnt
op_assign
id|dend
id|d
suffix:semicolon
multiline_comment|/* Want how many consecutive characters we can match in&n;&t;&t;   one shot, so, if necessary, adjust the count.  */
r_if
c_cond
(paren
id|mcnt
OG
id|dend2
id|d2
)paren
id|mcnt
op_assign
id|dend2
id|d2
suffix:semicolon
multiline_comment|/* Compare that many; failure if mismatch, else move&n;&t;&t;   past them.  */
r_if
c_cond
(paren
id|translate
ques
c_cond
id|bcmp_translate
(paren
id|d
comma
id|d2
comma
id|mcnt
comma
id|translate
)paren
suffix:colon
id|bcmp
(paren
id|d
comma
id|d2
comma
id|mcnt
)paren
)paren
r_goto
id|fail
suffix:semicolon
id|d
op_add_assign
id|mcnt
comma
id|d2
op_add_assign
id|mcnt
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
multiline_comment|/* begline matches the empty string at the beginning of the string&n;&t;   (unless `not_bol&squot; is set in `bufp&squot;), and, if&n;&t;   `newline_anchor&squot; is set, after newlines.  */
r_case
id|begline
suffix:colon
id|DEBUG_PRINT1
(paren
l_string|&quot;EXECUTING begline.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|AT_STRINGS_BEG
(paren
id|d
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bufp-&gt;not_bol
)paren
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|d
(braket
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
op_logical_and
id|bufp-&gt;newline_anchor
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/* In all other cases, we fail.  */
r_goto
id|fail
suffix:semicolon
multiline_comment|/* endline is the dual of begline.  */
r_case
id|endline
suffix:colon
id|DEBUG_PRINT1
(paren
l_string|&quot;EXECUTING endline.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|AT_STRINGS_END
(paren
id|d
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bufp-&gt;not_eol
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* We have to ``prefetch&squot;&squot; the next character.  */
r_else
r_if
c_cond
(paren
(paren
id|d
op_eq
id|end1
ques
c_cond
op_star
id|string2
suffix:colon
op_star
id|d
)paren
op_eq
l_char|&squot;&bslash;n&squot;
op_logical_and
id|bufp-&gt;newline_anchor
)paren
(brace
r_break
suffix:semicolon
)brace
r_goto
id|fail
suffix:semicolon
multiline_comment|/* Match at the very beginning of the data.  */
r_case
id|begbuf
suffix:colon
id|DEBUG_PRINT1
(paren
l_string|&quot;EXECUTING begbuf.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|AT_STRINGS_BEG
(paren
id|d
)paren
)paren
r_break
suffix:semicolon
r_goto
id|fail
suffix:semicolon
multiline_comment|/* Match at the very end of the data.  */
r_case
id|endbuf
suffix:colon
id|DEBUG_PRINT1
(paren
l_string|&quot;EXECUTING endbuf.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|AT_STRINGS_END
(paren
id|d
)paren
)paren
r_break
suffix:semicolon
r_goto
id|fail
suffix:semicolon
multiline_comment|/* on_failure_keep_string_jump is used to optimize `.*&bslash;n&squot;.  It&n;&t;   pushes NULL as the value for the string on the stack.  Then&n;&t;   `pop_failure_point&squot; will keep the current value for the&n;&t;   string, instead of restoring it.  To see why, consider&n;&t;   matching `foo&bslash;nbar&squot; against `.*&bslash;n&squot;.  The .* matches the foo;&n;&t;   then the . fails against the &bslash;n.  But the next thing we want&n;&t;   to do is match the &bslash;n against the &bslash;n; if we restored the&n;&t;   string value, we would be back at the foo.&n;&n;&t;   Because this is used only in specific cases, we don&squot;t need to&n;&t;   check all the things that `on_failure_jump&squot; does, to make&n;&t;   sure the right things get saved on the stack.  Hence we don&squot;t&n;&t;   share its code.  The only reason to push anything on the&n;&t;   stack at all is that otherwise we would have to change&n;&t;   `anychar&squot;s code to do something besides goto fail in this&n;&t;   case; that seems worse than this.  */
r_case
id|on_failure_keep_string_jump
suffix:colon
id|DEBUG_PRINT1
(paren
l_string|&quot;EXECUTING on_failure_keep_string_jump&quot;
)paren
suffix:semicolon
id|EXTRACT_NUMBER_AND_INCR
(paren
id|mcnt
comma
id|p
)paren
suffix:semicolon
id|DEBUG_PRINT3
(paren
l_string|&quot; %d (to 0x%x):&bslash;n&quot;
comma
id|mcnt
comma
id|p
op_plus
id|mcnt
)paren
suffix:semicolon
id|PUSH_FAILURE_POINT
(paren
id|p
op_plus
id|mcnt
comma
l_int|NULL
comma
l_int|2
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Uses of on_failure_jump:&n;&n;&t;   Each alternative starts with an on_failure_jump that points&n;&t;   to the beginning of the next alternative.  Each alternative&n;&t;   except the last ends with a jump that in effect jumps past&n;&t;   the rest of the alternatives.  (They really jump to the&n;&t;   ending jump of the following alternative, because tensioning&n;&t;   these jumps is a hassle.)&n;&n;&t;   Repeats start with an on_failure_jump that points past both&n;&t;   the repetition text and either the following jump or&n;&t;   pop_failure_jump back to this on_failure_jump.  */
r_case
id|on_failure_jump
suffix:colon
id|on_failure
suffix:colon
id|DEBUG_PRINT1
(paren
l_string|&quot;EXECUTING on_failure_jump&quot;
)paren
suffix:semicolon
id|EXTRACT_NUMBER_AND_INCR
(paren
id|mcnt
comma
id|p
)paren
suffix:semicolon
id|DEBUG_PRINT3
(paren
l_string|&quot; %d (to 0x%x)&quot;
comma
id|mcnt
comma
id|p
op_plus
id|mcnt
)paren
suffix:semicolon
multiline_comment|/* If this on_failure_jump comes right before a group (i.e.,&n;&t;     the original * applied to a group), save the information&n;&t;     for that group and all inner ones, so that if we fail back&n;&t;     to this point, the group&squot;s information will be correct.&n;&t;     For example, in &bslash;(a*&bslash;)*&bslash;1, we need the preceding group,&n;&t;     and in &bslash;(&bslash;(a*&bslash;)b*&bslash;)&bslash;2, we need the inner group.  */
multiline_comment|/* We can&squot;t use `p&squot; to check ahead because we push&n;&t;     a failure point to `p + mcnt&squot; after we do this.  */
id|p1
op_assign
id|p
suffix:semicolon
multiline_comment|/* We need to skip no_op&squot;s before we look for the&n;&t;     start_memory in case this on_failure_jump is happening as&n;&t;     the result of a completed succeed_n, as in &bslash;(a&bslash;)&bslash;{1,3&bslash;}b&bslash;1&n;&t;     against aba.  */
r_while
c_loop
(paren
id|p1
OL
id|pend
op_logical_and
(paren
id|re_opcode_t
)paren
op_star
id|p1
op_eq
id|no_op
)paren
id|p1
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|p1
OL
id|pend
op_logical_and
(paren
id|re_opcode_t
)paren
op_star
id|p1
op_eq
id|start_memory
)paren
(brace
multiline_comment|/* We have a new highest active register now.  This will&n;&t;&t; get reset at the start_memory we are about to get to,&n;&t;&t; but we will have saved all the registers relevant to&n;&t;&t; this repetition op, as described above.  */
id|highest_active_reg
op_assign
op_star
(paren
id|p1
op_plus
l_int|1
)paren
op_plus
op_star
(paren
id|p1
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lowest_active_reg
op_eq
id|NO_LOWEST_ACTIVE_REG
)paren
id|lowest_active_reg
op_assign
op_star
(paren
id|p1
op_plus
l_int|1
)paren
suffix:semicolon
)brace
id|DEBUG_PRINT1
(paren
l_string|&quot;:&bslash;n&quot;
)paren
suffix:semicolon
id|PUSH_FAILURE_POINT
(paren
id|p
op_plus
id|mcnt
comma
id|d
comma
l_int|2
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* A smart repeat ends with `maybe_pop_jump&squot;.&n;&t;   We change it to either `pop_failure_jump&squot; or `jump&squot;.  */
r_case
id|maybe_pop_jump
suffix:colon
id|EXTRACT_NUMBER_AND_INCR
(paren
id|mcnt
comma
id|p
)paren
suffix:semicolon
id|DEBUG_PRINT2
(paren
l_string|&quot;EXECUTING maybe_pop_jump %d.&bslash;n&quot;
comma
id|mcnt
)paren
suffix:semicolon
(brace
r_register
r_int
r_char
op_star
id|p2
op_assign
id|p
suffix:semicolon
multiline_comment|/* Compare the beginning of the repeat with what in the&n;&t;       pattern follows its end. If we can establish that there&n;&t;       is nothing that they would both match, i.e., that we&n;&t;       would have to backtrack because of (as in, e.g., `a*a&squot;)&n;&t;       then we can change to pop_failure_jump, because we&squot;ll&n;&t;       never have to backtrack.&n;&n;&t;       This is not true in the case of alternatives: in&n;&t;       `(a|ab)*&squot; we do need to backtrack to the `ab&squot; alternative&n;&t;       (e.g., if the string was `ab&squot;).  But instead of trying to&n;&t;       detect that here, the alternative has put on a dummy&n;&t;       failure point which is what we will end up popping.  */
multiline_comment|/* Skip over open/close-group commands.  */
r_while
c_loop
(paren
id|p2
op_plus
l_int|2
OL
id|pend
op_logical_and
(paren
(paren
id|re_opcode_t
)paren
op_star
id|p2
op_eq
id|stop_memory
op_logical_or
(paren
id|re_opcode_t
)paren
op_star
id|p2
op_eq
id|start_memory
)paren
)paren
id|p2
op_add_assign
l_int|3
suffix:semicolon
multiline_comment|/* Skip over args, too.  */
multiline_comment|/* If we&squot;re at the end of the pattern, we can change.  */
r_if
c_cond
(paren
id|p2
op_eq
id|pend
)paren
(brace
multiline_comment|/* Consider what happens when matching &quot;:&bslash;(.*&bslash;)&quot;&n;&t;&t;   against &quot;:/&quot;.  I don&squot;t really understand this code&n;&t;&t;   yet.  */
id|p
(braket
l_int|3
)braket
op_assign
(paren
r_int
r_char
)paren
id|pop_failure_jump
suffix:semicolon
id|DEBUG_PRINT1
(paren
l_string|&quot;  End of pattern: change to `pop_failure_jump&squot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|re_opcode_t
)paren
op_star
id|p2
op_eq
id|exactn
op_logical_or
(paren
id|bufp-&gt;newline_anchor
op_logical_and
(paren
id|re_opcode_t
)paren
op_star
id|p2
op_eq
id|endline
)paren
)paren
(brace
r_register
r_int
r_char
id|c
op_assign
op_star
id|p2
op_eq
(paren
r_int
r_char
)paren
id|endline
ques
c_cond
l_char|&squot;&bslash;n&squot;
suffix:colon
id|p2
(braket
l_int|2
)braket
suffix:semicolon
id|p1
op_assign
id|p
op_plus
id|mcnt
suffix:semicolon
multiline_comment|/* p1[0] ... p1[2] are the `on_failure_jump&squot; corresponding&n;&t;&t;   to the `maybe_finalize_jump&squot; of this case.  Examine what&n;&t;&t;   follows.  */
r_if
c_cond
(paren
(paren
id|re_opcode_t
)paren
id|p1
(braket
l_int|3
)braket
op_eq
id|exactn
op_logical_and
id|p1
(braket
l_int|5
)braket
op_ne
id|c
)paren
(brace
id|p
(braket
l_int|3
)braket
op_assign
(paren
r_int
r_char
)paren
id|pop_failure_jump
suffix:semicolon
id|DEBUG_PRINT3
(paren
l_string|&quot;  %c != %c =&gt; pop_failure_jump.&bslash;n&quot;
comma
id|c
comma
id|p1
(braket
l_int|5
)braket
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|re_opcode_t
)paren
id|p1
(braket
l_int|3
)braket
op_eq
id|charset
op_logical_or
(paren
id|re_opcode_t
)paren
id|p1
(braket
l_int|3
)braket
op_eq
id|charset_not
)paren
(brace
r_int
op_logical_neg
op_assign
(paren
id|re_opcode_t
)paren
id|p1
(braket
l_int|3
)braket
op_eq
id|charset_not
suffix:semicolon
r_if
c_cond
(paren
id|c
OL
(paren
r_int
r_char
)paren
(paren
id|p1
(braket
l_int|4
)braket
op_star
id|BYTEWIDTH
)paren
op_logical_and
id|p1
(braket
l_int|5
op_plus
id|c
op_div
id|BYTEWIDTH
)braket
op_amp
(paren
l_int|1
op_lshift
(paren
id|c
op_mod
id|BYTEWIDTH
)paren
)paren
)paren
op_logical_neg
op_assign
op_logical_neg
op_logical_neg
suffix:semicolon
multiline_comment|/* `not&squot; is equal to 1 if c would match, which means&n;&t;&t;&t;that we can&squot;t change to pop_failure_jump.  */
r_if
c_cond
(paren
op_logical_neg
op_logical_neg
)paren
(brace
id|p
(braket
l_int|3
)braket
op_assign
(paren
r_int
r_char
)paren
id|pop_failure_jump
suffix:semicolon
id|DEBUG_PRINT1
(paren
l_string|&quot;  No match =&gt; pop_failure_jump.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
id|p
op_sub_assign
l_int|2
suffix:semicolon
multiline_comment|/* Point at relative address again.  */
r_if
c_cond
(paren
(paren
id|re_opcode_t
)paren
id|p
(braket
l_int|1
)braket
op_ne
id|pop_failure_jump
)paren
(brace
id|p
(braket
l_int|1
)braket
op_assign
(paren
r_int
r_char
)paren
id|jump
suffix:semicolon
id|DEBUG_PRINT1
(paren
l_string|&quot;  Match =&gt; jump.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|unconditional_jump
suffix:semicolon
)brace
multiline_comment|/* Note fall through.  */
multiline_comment|/* The end of a simple repeat has a pop_failure_jump back to&n;&t;   its matching on_failure_jump, where the latter will push a&n;&t;   failure point.  The pop_failure_jump takes off failure&n;&t;   points put on by this pop_failure_jump&squot;s matching&n;&t;   on_failure_jump; we got through the pattern to here from the&n;&t;   matching on_failure_jump, so didn&squot;t fail.  */
r_case
id|pop_failure_jump
suffix:colon
(brace
multiline_comment|/* We need to pass separate storage for the lowest and&n;&t;       highest registers, even though we don&squot;t care about the&n;&t;       actual values.  Otherwise, we will restore only one&n;&t;       register from the stack, since lowest will == highest in&n;&t;       `pop_failure_point&squot;.  */
r_int
id|dummy_low_reg
comma
id|dummy_high_reg
suffix:semicolon
r_int
r_char
op_star
id|pdummy
suffix:semicolon
r_const
r_char
op_star
id|sdummy
suffix:semicolon
id|DEBUG_PRINT1
(paren
l_string|&quot;EXECUTING pop_failure_jump.&bslash;n&quot;
)paren
suffix:semicolon
id|POP_FAILURE_POINT
(paren
id|sdummy
comma
id|pdummy
comma
id|dummy_low_reg
comma
id|dummy_high_reg
comma
id|reg_dummy
comma
id|reg_dummy
comma
id|reg_info_dummy
)paren
suffix:semicolon
)brace
multiline_comment|/* Note fall through.  */
multiline_comment|/* Unconditionally jump (without popping any failure points).  */
r_case
id|jump
suffix:colon
id|unconditional_jump
suffix:colon
id|EXTRACT_NUMBER_AND_INCR
(paren
id|mcnt
comma
id|p
)paren
suffix:semicolon
multiline_comment|/* Get the amount to jump.  */
id|DEBUG_PRINT2
(paren
l_string|&quot;EXECUTING jump %d &quot;
comma
id|mcnt
)paren
suffix:semicolon
id|p
op_add_assign
id|mcnt
suffix:semicolon
multiline_comment|/* Do the jump.  */
id|DEBUG_PRINT2
(paren
l_string|&quot;(to 0x%x).&bslash;n&quot;
comma
id|p
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* We need this opcode so we can detect where alternatives end&n;&t;   in `group_match_null_string_p&squot; et al.  */
r_case
id|jump_past_alt
suffix:colon
id|DEBUG_PRINT1
(paren
l_string|&quot;EXECUTING jump_past_alt.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|unconditional_jump
suffix:semicolon
multiline_comment|/* Normally, the on_failure_jump pushes a failure point, which&n;&t;   then gets popped at pop_failure_jump.  We will end up at&n;&t;   pop_failure_jump, also, and with a pattern of, say, `a+&squot;, we&n;&t;   are skipping over the on_failure_jump, so we have to push&n;&t;   something meaningless for pop_failure_jump to pop.  */
r_case
id|dummy_failure_jump
suffix:colon
id|DEBUG_PRINT1
(paren
l_string|&quot;EXECUTING dummy_failure_jump.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* It doesn&squot;t matter what we push for the string here.  What&n;&t;     the code at `fail&squot; tests is the value for the pattern.  */
id|PUSH_FAILURE_POINT
(paren
l_int|0
comma
l_int|0
comma
l_int|2
)paren
suffix:semicolon
r_goto
id|unconditional_jump
suffix:semicolon
multiline_comment|/* At the end of an alternative, we need to push a dummy failure&n;&t;   point in case we are followed by a `pop_failure_jump&squot;, because&n;&t;   we don&squot;t want the failure point for the alternative to be&n;&t;   popped.  For example, matching `(a|ab)*&squot; against `aab&squot;&n;&t;   requires that we match the `ab&squot; alternative.  */
r_case
id|push_dummy_failure
suffix:colon
id|DEBUG_PRINT1
(paren
l_string|&quot;EXECUTING push_dummy_failure.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* See comments just above at `dummy_failure_jump&squot; about the&n;&t;     two zeroes.  */
id|PUSH_FAILURE_POINT
(paren
l_int|0
comma
l_int|0
comma
l_int|2
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Have to succeed matching what follows at least n times.&n;&t;   After that, handle like `on_failure_jump&squot;.  */
r_case
id|succeed_n
suffix:colon
id|EXTRACT_NUMBER
(paren
id|mcnt
comma
id|p
op_plus
l_int|2
)paren
suffix:semicolon
id|DEBUG_PRINT2
(paren
l_string|&quot;EXECUTING succeed_n %d.&bslash;n&quot;
comma
id|mcnt
)paren
suffix:semicolon
m_assert
(paren
id|mcnt
op_ge
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Originally, this is how many times we HAVE to succeed.  */
r_if
c_cond
(paren
id|mcnt
OG
l_int|0
)paren
(brace
id|mcnt
op_decrement
suffix:semicolon
id|p
op_add_assign
l_int|2
suffix:semicolon
id|STORE_NUMBER_AND_INCR
(paren
id|p
comma
id|mcnt
)paren
suffix:semicolon
id|DEBUG_PRINT3
(paren
l_string|&quot;  Setting 0x%x to %d.&bslash;n&quot;
comma
id|p
comma
id|mcnt
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|mcnt
op_eq
l_int|0
)paren
(brace
id|DEBUG_PRINT2
(paren
l_string|&quot;  Setting two bytes from 0x%x to no_op.&bslash;n&quot;
comma
id|p
op_plus
l_int|2
)paren
suffix:semicolon
id|p
(braket
l_int|2
)braket
op_assign
(paren
r_int
r_char
)paren
id|no_op
suffix:semicolon
id|p
(braket
l_int|3
)braket
op_assign
(paren
r_int
r_char
)paren
id|no_op
suffix:semicolon
r_goto
id|on_failure
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|jump_n
suffix:colon
id|EXTRACT_NUMBER
(paren
id|mcnt
comma
id|p
op_plus
l_int|2
)paren
suffix:semicolon
id|DEBUG_PRINT2
(paren
l_string|&quot;EXECUTING jump_n %d.&bslash;n&quot;
comma
id|mcnt
)paren
suffix:semicolon
multiline_comment|/* Originally, this is how many times we CAN jump.  */
r_if
c_cond
(paren
id|mcnt
)paren
(brace
id|mcnt
op_decrement
suffix:semicolon
id|STORE_NUMBER
(paren
id|p
op_plus
l_int|2
comma
id|mcnt
)paren
suffix:semicolon
r_goto
id|unconditional_jump
suffix:semicolon
)brace
multiline_comment|/* If don&squot;t have to jump any more, skip over the rest of command.  */
r_else
id|p
op_add_assign
l_int|4
suffix:semicolon
r_break
suffix:semicolon
r_case
id|set_number_at
suffix:colon
(brace
id|DEBUG_PRINT1
(paren
l_string|&quot;EXECUTING set_number_at.&bslash;n&quot;
)paren
suffix:semicolon
id|EXTRACT_NUMBER_AND_INCR
(paren
id|mcnt
comma
id|p
)paren
suffix:semicolon
id|p1
op_assign
id|p
op_plus
id|mcnt
suffix:semicolon
id|EXTRACT_NUMBER_AND_INCR
(paren
id|mcnt
comma
id|p
)paren
suffix:semicolon
id|DEBUG_PRINT3
(paren
l_string|&quot;  Setting 0x%x to %d.&bslash;n&quot;
comma
id|p1
comma
id|mcnt
)paren
suffix:semicolon
id|STORE_NUMBER
(paren
id|p1
comma
id|mcnt
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|wordbound
suffix:colon
id|DEBUG_PRINT1
(paren
l_string|&quot;EXECUTING wordbound.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|AT_WORD_BOUNDARY
(paren
id|d
)paren
)paren
r_break
suffix:semicolon
r_goto
id|fail
suffix:semicolon
r_case
id|notwordbound
suffix:colon
id|DEBUG_PRINT1
(paren
l_string|&quot;EXECUTING notwordbound.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|AT_WORD_BOUNDARY
(paren
id|d
)paren
)paren
r_goto
id|fail
suffix:semicolon
r_break
suffix:semicolon
r_case
id|wordbeg
suffix:colon
id|DEBUG_PRINT1
(paren
l_string|&quot;EXECUTING wordbeg.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|WORDCHAR_P
(paren
id|d
)paren
op_logical_and
(paren
id|AT_STRINGS_BEG
(paren
id|d
)paren
op_logical_or
op_logical_neg
id|WORDCHAR_P
(paren
id|d
l_int|1
)paren
)paren
)paren
r_break
suffix:semicolon
r_goto
id|fail
suffix:semicolon
r_case
id|wordend
suffix:colon
id|DEBUG_PRINT1
(paren
l_string|&quot;EXECUTING wordend.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|AT_STRINGS_BEG
(paren
id|d
)paren
op_logical_and
id|WORDCHAR_P
(paren
id|d
l_int|1
)paren
op_logical_and
(paren
op_logical_neg
id|WORDCHAR_P
(paren
id|d
)paren
op_logical_or
id|AT_STRINGS_END
(paren
id|d
)paren
)paren
)paren
r_break
suffix:semicolon
r_goto
id|fail
suffix:semicolon
macro_line|#ifdef emacs
macro_line|#ifdef emacs19
r_case
id|before_dot
suffix:colon
id|DEBUG_PRINT1
(paren
l_string|&quot;EXECUTING before_dot.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PTR_CHAR_POS
(paren
(paren
r_int
r_char
op_star
)paren
id|d
)paren
op_ge
id|point
)paren
r_goto
id|fail
suffix:semicolon
r_break
suffix:semicolon
r_case
id|at_dot
suffix:colon
id|DEBUG_PRINT1
(paren
l_string|&quot;EXECUTING at_dot.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PTR_CHAR_POS
(paren
(paren
r_int
r_char
op_star
)paren
id|d
)paren
op_ne
id|point
)paren
r_goto
id|fail
suffix:semicolon
r_break
suffix:semicolon
r_case
id|after_dot
suffix:colon
id|DEBUG_PRINT1
(paren
l_string|&quot;EXECUTING after_dot.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PTR_CHAR_POS
(paren
(paren
r_int
r_char
op_star
)paren
id|d
)paren
op_le
id|point
)paren
r_goto
id|fail
suffix:semicolon
r_break
suffix:semicolon
macro_line|#else /* not emacs19 */
r_case
id|at_dot
suffix:colon
id|DEBUG_PRINT1
(paren
l_string|&quot;EXECUTING at_dot.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PTR_CHAR_POS
(paren
(paren
r_int
r_char
op_star
)paren
id|d
)paren
op_plus
l_int|1
op_ne
id|point
)paren
r_goto
id|fail
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif /* not emacs19 */
r_case
id|syntaxspec
suffix:colon
id|DEBUG_PRINT2
(paren
l_string|&quot;EXECUTING syntaxspec %d.&bslash;n&quot;
comma
id|mcnt
)paren
suffix:semicolon
id|mcnt
op_assign
op_star
id|p
op_increment
suffix:semicolon
r_goto
id|matchsyntax
suffix:semicolon
r_case
id|wordchar
suffix:colon
id|DEBUG_PRINT1
(paren
l_string|&quot;EXECUTING Emacs wordchar.&bslash;n&quot;
)paren
suffix:semicolon
id|mcnt
op_assign
(paren
r_int
)paren
id|Sword
suffix:semicolon
id|matchsyntax
suffix:colon
id|PREFETCH
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SYNTAX
(paren
op_star
id|d
op_increment
)paren
op_ne
(paren
r_enum
id|syntaxcode
)paren
id|mcnt
)paren
r_goto
id|fail
suffix:semicolon
id|SET_REGS_MATCHED
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|notsyntaxspec
suffix:colon
id|DEBUG_PRINT2
(paren
l_string|&quot;EXECUTING notsyntaxspec %d.&bslash;n&quot;
comma
id|mcnt
)paren
suffix:semicolon
id|mcnt
op_assign
op_star
id|p
op_increment
suffix:semicolon
r_goto
id|matchnotsyntax
suffix:semicolon
r_case
id|notwordchar
suffix:colon
id|DEBUG_PRINT1
(paren
l_string|&quot;EXECUTING Emacs notwordchar.&bslash;n&quot;
)paren
suffix:semicolon
id|mcnt
op_assign
(paren
r_int
)paren
id|Sword
suffix:semicolon
id|matchnotsyntax
suffix:colon
id|PREFETCH
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SYNTAX
(paren
op_star
id|d
op_increment
)paren
op_eq
(paren
r_enum
id|syntaxcode
)paren
id|mcnt
)paren
r_goto
id|fail
suffix:semicolon
id|SET_REGS_MATCHED
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#else /* not emacs */
r_case
id|wordchar
suffix:colon
id|DEBUG_PRINT1
(paren
l_string|&quot;EXECUTING non-Emacs wordchar.&bslash;n&quot;
)paren
suffix:semicolon
id|PREFETCH
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|WORDCHAR_P
(paren
id|d
)paren
)paren
r_goto
id|fail
suffix:semicolon
id|SET_REGS_MATCHED
(paren
)paren
suffix:semicolon
id|d
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|notwordchar
suffix:colon
id|DEBUG_PRINT1
(paren
l_string|&quot;EXECUTING non-Emacs notwordchar.&bslash;n&quot;
)paren
suffix:semicolon
id|PREFETCH
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|WORDCHAR_P
(paren
id|d
)paren
)paren
r_goto
id|fail
suffix:semicolon
id|SET_REGS_MATCHED
(paren
)paren
suffix:semicolon
id|d
op_increment
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif /* not emacs */
r_default
suffix:colon
m_abort
(paren
)paren
suffix:semicolon
)brace
r_continue
suffix:semicolon
multiline_comment|/* Successfully executed one pattern command; keep going.  */
multiline_comment|/* We goto here if a matching operation fails. */
id|fail
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|FAIL_STACK_EMPTY
(paren
)paren
)paren
(brace
multiline_comment|/* A restart point is known.  Restore to that state.  */
id|DEBUG_PRINT1
(paren
l_string|&quot;&bslash;nFAIL:&bslash;n&quot;
)paren
suffix:semicolon
id|POP_FAILURE_POINT
(paren
id|d
comma
id|p
comma
id|lowest_active_reg
comma
id|highest_active_reg
comma
id|regstart
comma
id|regend
comma
id|reg_info
)paren
suffix:semicolon
multiline_comment|/* If this failure point is a dummy, try the next one.  */
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_goto
id|fail
suffix:semicolon
multiline_comment|/* If we failed to the end of the pattern, don&squot;t examine *p.  */
m_assert
(paren
id|p
op_le
id|pend
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
OL
id|pend
)paren
(brace
id|boolean
id|is_a_jump_n
op_assign
l_bool|false
suffix:semicolon
multiline_comment|/* If failed to a backwards jump that&squot;s part of a repetition&n;&t;&t; loop, need to pop this failure point and use the next one.  */
r_switch
c_cond
(paren
(paren
id|re_opcode_t
)paren
op_star
id|p
)paren
(brace
r_case
id|jump_n
suffix:colon
id|is_a_jump_n
op_assign
l_bool|true
suffix:semicolon
r_case
id|maybe_pop_jump
suffix:colon
r_case
id|pop_failure_jump
suffix:colon
r_case
id|jump
suffix:colon
id|p1
op_assign
id|p
op_plus
l_int|1
suffix:semicolon
id|EXTRACT_NUMBER_AND_INCR
(paren
id|mcnt
comma
id|p1
)paren
suffix:semicolon
id|p1
op_add_assign
id|mcnt
suffix:semicolon
r_if
c_cond
(paren
(paren
id|is_a_jump_n
op_logical_and
(paren
id|re_opcode_t
)paren
op_star
id|p1
op_eq
id|succeed_n
)paren
op_logical_or
(paren
op_logical_neg
id|is_a_jump_n
op_logical_and
(paren
id|re_opcode_t
)paren
op_star
id|p1
op_eq
id|on_failure_jump
)paren
)paren
r_goto
id|fail
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* do nothing */
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|d
op_ge
id|string1
op_logical_and
id|d
op_le
id|end1
)paren
id|dend
op_assign
id|end_match_1
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
multiline_comment|/* Matching at this starting point really fails.  */
)brace
multiline_comment|/* for (;;) */
r_if
c_cond
(paren
id|best_regs_set
)paren
r_goto
id|restore_best_regs
suffix:semicolon
id|FREE_VARIABLES
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Failure to match.  */
)brace
multiline_comment|/* re_match_2 */
"&f;"
multiline_comment|/* Subroutine definitions for re_match_2.  */
multiline_comment|/* We are passed P pointing to a register number after a start_memory.&n;&n;   Return true if the pattern up to the corresponding stop_memory can&n;   match the empty string, and false otherwise.&n;&n;   If we find the matching stop_memory, sets P to point to one past its number.&n;   Otherwise, sets P to an undefined byte less than or equal to END.&n;&n;   We don&squot;t handle duplicates properly (yet).  */
r_static
id|boolean
DECL|function|group_match_null_string_p
id|group_match_null_string_p
(paren
id|p
comma
id|end
comma
id|reg_info
)paren
r_int
r_char
op_star
op_star
id|p
comma
op_star
id|end
suffix:semicolon
id|register_info_type
op_star
id|reg_info
suffix:semicolon
(brace
r_int
id|mcnt
suffix:semicolon
multiline_comment|/* Point to after the args to the start_memory.  */
r_int
r_char
op_star
id|p1
op_assign
op_star
id|p
op_plus
l_int|2
suffix:semicolon
r_while
c_loop
(paren
id|p1
OL
id|end
)paren
(brace
multiline_comment|/* Skip over opcodes that can match nothing, and return true or&n;&t; false, as appropriate, when we get to one that can&squot;t, or to the&n;&t; matching stop_memory.  */
r_switch
c_cond
(paren
(paren
id|re_opcode_t
)paren
op_star
id|p1
)paren
(brace
multiline_comment|/* Could be either a loop or a series of alternatives.  */
r_case
id|on_failure_jump
suffix:colon
id|p1
op_increment
suffix:semicolon
id|EXTRACT_NUMBER_AND_INCR
(paren
id|mcnt
comma
id|p1
)paren
suffix:semicolon
multiline_comment|/* If the next operation is not a jump backwards in the&n;&t;     pattern.  */
r_if
c_cond
(paren
id|mcnt
op_ge
l_int|0
)paren
(brace
multiline_comment|/* Go through the on_failure_jumps of the alternatives,&n;&t;&t; seeing if any of the alternatives cannot match nothing.&n;&t;&t; The last alternative starts with only a jump,&n;&t;&t; whereas the rest start with on_failure_jump and end&n;&t;&t; with a jump, e.g., here is the pattern for `a|b|c&squot;:&n;&n;&t;&t; /on_failure_jump/0/6/exactn/1/a/jump_past_alt/0/6&n;&t;&t; /on_failure_jump/0/6/exactn/1/b/jump_past_alt/0/3&n;&t;&t; /exactn/1/c&n;&n;&t;&t; So, we have to first go through the first (n-1)&n;&t;&t; alternatives and then deal with the last one separately.  */
multiline_comment|/* Deal with the first (n-1) alternatives, which start&n;&t;&t; with an on_failure_jump (see above) that jumps to right&n;&t;&t; past a jump_past_alt.  */
r_while
c_loop
(paren
(paren
id|re_opcode_t
)paren
id|p1
(braket
id|mcnt
op_minus
l_int|3
)braket
op_eq
id|jump_past_alt
)paren
(brace
multiline_comment|/* `mcnt&squot; holds how many bytes long the alternative&n;&t;&t;     is, including the ending `jump_past_alt&squot; and&n;&t;&t;     its number.  */
r_if
c_cond
(paren
op_logical_neg
id|alt_match_null_string_p
(paren
id|p1
comma
id|p1
op_plus
id|mcnt
l_int|3
comma
id|reg_info
)paren
)paren
r_return
l_bool|false
suffix:semicolon
multiline_comment|/* Move to right after this alternative, including the&n;&t;&t;     jump_past_alt.  */
id|p1
op_add_assign
id|mcnt
suffix:semicolon
multiline_comment|/* Break if it&squot;s the beginning of an n-th alternative&n;&t;&t;     that doesn&squot;t begin with an on_failure_jump.  */
r_if
c_cond
(paren
(paren
id|re_opcode_t
)paren
op_star
id|p1
op_ne
id|on_failure_jump
)paren
r_break
suffix:semicolon
multiline_comment|/* Still have to check that it&squot;s not an n-th&n;&t;&t;     alternative that starts with an on_failure_jump.  */
id|p1
op_increment
suffix:semicolon
id|EXTRACT_NUMBER_AND_INCR
(paren
id|mcnt
comma
id|p1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|re_opcode_t
)paren
id|p1
(braket
id|mcnt
op_minus
l_int|3
)braket
op_ne
id|jump_past_alt
)paren
(brace
multiline_comment|/* Get to the beginning of the n-th alternative.  */
id|p1
op_sub_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Deal with the last alternative: go back and get number&n;&t;&t; of the `jump_past_alt&squot; just before it.  `mcnt&squot; contains&n;&t;&t; the length of the alternative.  */
id|EXTRACT_NUMBER
(paren
id|mcnt
comma
id|p1
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|alt_match_null_string_p
(paren
id|p1
comma
id|p1
op_plus
id|mcnt
comma
id|reg_info
)paren
)paren
r_return
l_bool|false
suffix:semicolon
id|p1
op_add_assign
id|mcnt
suffix:semicolon
multiline_comment|/* Get past the n-th alternative.  */
)brace
multiline_comment|/* if mcnt &gt; 0 */
r_break
suffix:semicolon
r_case
id|stop_memory
suffix:colon
m_assert
(paren
id|p1
(braket
l_int|1
)braket
op_eq
op_star
op_star
id|p
)paren
suffix:semicolon
op_star
id|p
op_assign
id|p1
op_plus
l_int|2
suffix:semicolon
r_return
l_bool|true
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|common_op_match_null_string_p
(paren
op_amp
id|p1
comma
id|end
comma
id|reg_info
)paren
)paren
r_return
l_bool|false
suffix:semicolon
)brace
)brace
multiline_comment|/* while p1 &lt; end */
r_return
l_bool|false
suffix:semicolon
)brace
multiline_comment|/* group_match_null_string_p */
multiline_comment|/* Similar to group_match_null_string_p, but doesn&squot;t deal with alternatives:&n;   It expects P to be the first byte of a single alternative and END one&n;   byte past the last. The alternative can contain groups.  */
r_static
id|boolean
DECL|function|alt_match_null_string_p
id|alt_match_null_string_p
(paren
id|p
comma
id|end
comma
id|reg_info
)paren
r_int
r_char
op_star
id|p
comma
op_star
id|end
suffix:semicolon
id|register_info_type
op_star
id|reg_info
suffix:semicolon
(brace
r_int
id|mcnt
suffix:semicolon
r_int
r_char
op_star
id|p1
op_assign
id|p
suffix:semicolon
r_while
c_loop
(paren
id|p1
OL
id|end
)paren
(brace
multiline_comment|/* Skip over opcodes that can match nothing, and break when we get&n;&t; to one that can&squot;t.  */
r_switch
c_cond
(paren
(paren
id|re_opcode_t
)paren
op_star
id|p1
)paren
(brace
multiline_comment|/* It&squot;s a loop.  */
r_case
id|on_failure_jump
suffix:colon
id|p1
op_increment
suffix:semicolon
id|EXTRACT_NUMBER_AND_INCR
(paren
id|mcnt
comma
id|p1
)paren
suffix:semicolon
id|p1
op_add_assign
id|mcnt
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|common_op_match_null_string_p
(paren
op_amp
id|p1
comma
id|end
comma
id|reg_info
)paren
)paren
r_return
l_bool|false
suffix:semicolon
)brace
)brace
multiline_comment|/* while p1 &lt; end */
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/* alt_match_null_string_p */
multiline_comment|/* Deals with the ops common to group_match_null_string_p and&n;   alt_match_null_string_p.&n;&n;   Sets P to one after the op and its arguments, if any.  */
r_static
id|boolean
DECL|function|common_op_match_null_string_p
id|common_op_match_null_string_p
(paren
id|p
comma
id|end
comma
id|reg_info
)paren
r_int
r_char
op_star
op_star
id|p
comma
op_star
id|end
suffix:semicolon
id|register_info_type
op_star
id|reg_info
suffix:semicolon
(brace
r_int
id|mcnt
suffix:semicolon
id|boolean
id|ret
suffix:semicolon
r_int
id|reg_no
suffix:semicolon
r_int
r_char
op_star
id|p1
op_assign
op_star
id|p
suffix:semicolon
r_switch
c_cond
(paren
(paren
id|re_opcode_t
)paren
op_star
id|p1
op_increment
)paren
(brace
r_case
id|no_op
suffix:colon
r_case
id|begline
suffix:colon
r_case
id|endline
suffix:colon
r_case
id|begbuf
suffix:colon
r_case
id|endbuf
suffix:colon
r_case
id|wordbeg
suffix:colon
r_case
id|wordend
suffix:colon
r_case
id|wordbound
suffix:colon
r_case
id|notwordbound
suffix:colon
macro_line|#ifdef emacs
r_case
id|before_dot
suffix:colon
r_case
id|at_dot
suffix:colon
r_case
id|after_dot
suffix:colon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|start_memory
suffix:colon
id|reg_no
op_assign
op_star
id|p1
suffix:semicolon
m_assert
(paren
id|reg_no
OG
l_int|0
op_logical_and
id|reg_no
op_le
id|MAX_REGNUM
)paren
suffix:semicolon
id|ret
op_assign
id|group_match_null_string_p
(paren
op_amp
id|p1
comma
id|end
comma
id|reg_info
)paren
suffix:semicolon
multiline_comment|/* Have to set this here in case we&squot;re checking a group which&n;&t; contains a group and a back reference to it.  */
r_if
c_cond
(paren
id|REG_MATCH_NULL_STRING_P
(paren
id|reg_info
(braket
id|reg_no
)braket
)paren
op_eq
id|MATCH_NULL_UNSET_VALUE
)paren
id|REG_MATCH_NULL_STRING_P
(paren
id|reg_info
(braket
id|reg_no
)braket
)paren
op_assign
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
r_return
l_bool|false
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* If this is an optimized succeed_n for zero times, make the jump.  */
r_case
id|jump
suffix:colon
id|EXTRACT_NUMBER_AND_INCR
(paren
id|mcnt
comma
id|p1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mcnt
op_ge
l_int|0
)paren
id|p1
op_add_assign
id|mcnt
suffix:semicolon
r_else
r_return
l_bool|false
suffix:semicolon
r_break
suffix:semicolon
r_case
id|succeed_n
suffix:colon
multiline_comment|/* Get to the number of times to succeed.  */
id|p1
op_add_assign
l_int|2
suffix:semicolon
id|EXTRACT_NUMBER_AND_INCR
(paren
id|mcnt
comma
id|p1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mcnt
op_eq
l_int|0
)paren
(brace
id|p1
op_sub_assign
l_int|4
suffix:semicolon
id|EXTRACT_NUMBER_AND_INCR
(paren
id|mcnt
comma
id|p1
)paren
suffix:semicolon
id|p1
op_add_assign
id|mcnt
suffix:semicolon
)brace
r_else
r_return
l_bool|false
suffix:semicolon
r_break
suffix:semicolon
r_case
id|duplicate
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|REG_MATCH_NULL_STRING_P
(paren
id|reg_info
(braket
op_star
id|p1
)braket
)paren
)paren
r_return
l_bool|false
suffix:semicolon
r_break
suffix:semicolon
r_case
id|set_number_at
suffix:colon
id|p1
op_add_assign
l_int|4
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* All other opcodes mean we cannot match the empty string.  */
r_return
l_bool|false
suffix:semicolon
)brace
op_star
id|p
op_assign
id|p1
suffix:semicolon
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/* common_op_match_null_string_p */
multiline_comment|/* Return zero if TRANSLATE[S1] and TRANSLATE[S2] are identical for LEN&n;   bytes; nonzero otherwise.  */
r_static
r_int
DECL|function|bcmp_translate
id|bcmp_translate
c_func
(paren
r_int
r_char
op_star
id|s1
comma
r_int
r_char
op_star
id|s2
comma
r_int
id|len
comma
r_char
op_star
id|translate
)paren
(brace
r_register
r_int
r_char
op_star
id|p1
op_assign
id|s1
comma
op_star
id|p2
op_assign
id|s2
suffix:semicolon
r_while
c_loop
(paren
id|len
)paren
(brace
r_if
c_cond
(paren
id|translate
(braket
op_star
id|p1
op_increment
)braket
op_ne
id|translate
(braket
op_star
id|p2
op_increment
)braket
)paren
r_return
l_int|1
suffix:semicolon
id|len
op_decrement
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/* Entry points for GNU code.  */
multiline_comment|/* re_compile_pattern is the GNU regular expression compiler: it&n;   compiles PATTERN (of length SIZE) and puts the result in BUFP.&n;   Returns 0 if the pattern was valid, otherwise an error string.&n;&n;   Assumes the `allocated&squot; (and perhaps `buffer&squot;) and `translate&squot; fields&n;   are set in BUFP on entry.&n;&n;   We call regex_compile to do the actual compilation.  */
r_const
r_char
op_star
DECL|function|re_compile_pattern
id|re_compile_pattern
(paren
id|pattern
comma
id|length
comma
id|bufp
)paren
r_const
r_char
op_star
id|pattern
suffix:semicolon
r_int
id|length
suffix:semicolon
r_struct
id|re_pattern_buffer
op_star
id|bufp
suffix:semicolon
(brace
id|reg_errcode_t
id|ret
suffix:semicolon
multiline_comment|/* GNU code is written to assume at least RE_NREGS registers will be set&n;     (and at least one extra will be -1).  */
id|bufp-&gt;regs_allocated
op_assign
id|REGS_UNALLOCATED
suffix:semicolon
multiline_comment|/* And GNU code determines whether or not to get register information&n;     by passing null for the REGS argument to re_match, etc., not by&n;     setting no_sub.  */
id|bufp-&gt;no_sub
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Match anchors at newline.  */
id|bufp-&gt;newline_anchor
op_assign
l_int|1
suffix:semicolon
id|ret
op_assign
id|regex_compile
(paren
id|pattern
comma
id|length
comma
id|re_syntax_options
comma
id|bufp
)paren
suffix:semicolon
r_return
id|re_error_msg
(braket
(paren
r_int
)paren
id|ret
)braket
suffix:semicolon
)brace
"&f;"
multiline_comment|/* Entry points compatible with 4.2 BSD regex library.  We don&squot;t define&n;   them if this is an Emacs or POSIX compilation.  */
macro_line|#if !defined (emacs) &amp;&amp; !defined (_POSIX_SOURCE)
multiline_comment|/* BSD has one and only one pattern buffer.  */
DECL|variable|re_comp_buf
r_static
r_struct
id|re_pattern_buffer
id|re_comp_buf
suffix:semicolon
r_char
op_star
DECL|function|re_comp
id|re_comp
(paren
id|s
)paren
r_const
r_char
op_star
id|s
suffix:semicolon
(brace
id|reg_errcode_t
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|re_comp_buf.buffer
)paren
r_return
l_string|&quot;No previous regular expression&quot;
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|re_comp_buf.buffer
)paren
(brace
id|re_comp_buf.buffer
op_assign
(paren
r_int
r_char
op_star
)paren
id|malloc
(paren
l_int|200
)paren
suffix:semicolon
r_if
c_cond
(paren
id|re_comp_buf.buffer
op_eq
l_int|NULL
)paren
r_return
l_string|&quot;Memory exhausted&quot;
suffix:semicolon
id|re_comp_buf.allocated
op_assign
l_int|200
suffix:semicolon
id|re_comp_buf.fastmap
op_assign
(paren
r_char
op_star
)paren
id|malloc
(paren
l_int|1
op_lshift
id|BYTEWIDTH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|re_comp_buf.fastmap
op_eq
l_int|NULL
)paren
r_return
l_string|&quot;Memory exhausted&quot;
suffix:semicolon
)brace
multiline_comment|/* Since `re_exec&squot; always passes NULL for the `regs&squot; argument, we&n;     don&squot;t need to initialize the pattern buffer fields which affect it.  */
multiline_comment|/* Match anchors at newlines.  */
id|re_comp_buf.newline_anchor
op_assign
l_int|1
suffix:semicolon
id|ret
op_assign
id|regex_compile
(paren
id|s
comma
id|strlen
(paren
id|s
)paren
comma
id|re_syntax_options
comma
op_amp
id|re_comp_buf
)paren
suffix:semicolon
multiline_comment|/* Yes, we&squot;re discarding `const&squot; here.  */
r_return
(paren
r_char
op_star
)paren
id|re_error_msg
(braket
(paren
r_int
)paren
id|ret
)braket
suffix:semicolon
)brace
r_int
DECL|function|re_exec
id|re_exec
(paren
id|s
)paren
r_const
r_char
op_star
id|s
suffix:semicolon
(brace
r_const
r_int
id|len
op_assign
id|strlen
(paren
id|s
)paren
suffix:semicolon
r_return
l_int|0
op_le
id|re_search
(paren
op_amp
id|re_comp_buf
comma
id|s
comma
id|len
comma
l_int|0
comma
id|len
comma
(paren
r_struct
id|re_registers
op_star
)paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif /* not emacs and not _POSIX_SOURCE */
"&f;"
multiline_comment|/* POSIX.2 functions.  Don&squot;t define these for Emacs.  */
macro_line|#ifndef emacs
multiline_comment|/* regcomp takes a regular expression as a string and compiles it.&n;&n;   PREG is a regex_t *.  We do not expect any fields to be initialized,&n;   since POSIX says we shouldn&squot;t.  Thus, we set&n;&n;     `buffer&squot; to the compiled pattern;&n;     `used&squot; to the length of the compiled pattern;&n;     `syntax&squot; to RE_SYNTAX_POSIX_EXTENDED if the&n;       REG_EXTENDED bit in CFLAGS is set; otherwise, to&n;       RE_SYNTAX_POSIX_BASIC;&n;     `newline_anchor&squot; to REG_NEWLINE being set in CFLAGS;&n;     `fastmap&squot; and `fastmap_accurate&squot; to zero;&n;     `re_nsub&squot; to the number of subexpressions in PATTERN.&n;&n;   PATTERN is the address of the pattern string.&n;&n;   CFLAGS is a series of bits which affect compilation.&n;&n;     If REG_EXTENDED is set, we use POSIX extended syntax; otherwise, we&n;     use POSIX basic syntax.&n;&n;     If REG_NEWLINE is set, then . and [^...] don&squot;t match newline.&n;     Also, regexec will try a match beginning after every newline.&n;&n;     If REG_ICASE is set, then we considers upper- and lowercase&n;     versions of letters to be equivalent when matching.&n;&n;     If REG_NOSUB is set, then when PREG is passed to regexec, that&n;     routine will report only success or failure, and nothing about the&n;     registers.&n;&n;   It returns 0 if it succeeds, nonzero if it doesn&squot;t.  (See regex.h for&n;   the return codes and their meanings.)  */
r_int
DECL|function|regcomp
id|regcomp
(paren
id|preg
comma
id|pattern
comma
id|cflags
)paren
id|regex_t
op_star
id|preg
suffix:semicolon
r_const
r_char
op_star
id|pattern
suffix:semicolon
r_int
id|cflags
suffix:semicolon
(brace
id|reg_errcode_t
id|ret
suffix:semicolon
r_int
id|syntax
op_assign
(paren
id|cflags
op_amp
id|REG_EXTENDED
)paren
ques
c_cond
id|RE_SYNTAX_POSIX_EXTENDED
suffix:colon
id|RE_SYNTAX_POSIX_BASIC
suffix:semicolon
multiline_comment|/* regex_compile will allocate the space for the compiled pattern.  */
id|preg-&gt;buffer
op_assign
l_int|0
suffix:semicolon
id|preg-&gt;allocated
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Don&squot;t bother to use a fastmap when searching.  This simplifies the&n;     REG_NEWLINE case: if we used a fastmap, we&squot;d have to put all the&n;     characters after newlines into the fastmap.  This way, we just try&n;     every character.  */
id|preg-&gt;fastmap
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cflags
op_amp
id|REG_ICASE
)paren
(brace
r_int
id|i
suffix:semicolon
id|preg-&gt;translate
op_assign
(paren
r_char
op_star
)paren
id|malloc
(paren
id|CHAR_SET_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|preg-&gt;translate
op_eq
l_int|NULL
)paren
r_return
(paren
r_int
)paren
id|REG_ESPACE
suffix:semicolon
multiline_comment|/* Map uppercase characters to corresponding lowercase ones.  */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CHAR_SET_SIZE
suffix:semicolon
id|i
op_increment
)paren
id|preg-&gt;translate
(braket
id|i
)braket
op_assign
id|ISUPPER
(paren
id|i
)paren
ques
c_cond
id|tolower
(paren
id|i
)paren
suffix:colon
id|i
suffix:semicolon
)brace
r_else
id|preg-&gt;translate
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* If REG_NEWLINE is set, newlines are treated differently.  */
r_if
c_cond
(paren
id|cflags
op_amp
id|REG_NEWLINE
)paren
(brace
multiline_comment|/* REG_NEWLINE implies neither . nor [^...] match newline.  */
id|syntax
op_and_assign
op_complement
id|RE_DOT_NEWLINE
suffix:semicolon
id|syntax
op_or_assign
id|RE_HAT_LISTS_NOT_NEWLINE
suffix:semicolon
multiline_comment|/* It also changes the matching behavior.  */
id|preg-&gt;newline_anchor
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|preg-&gt;newline_anchor
op_assign
l_int|0
suffix:semicolon
id|preg-&gt;no_sub
op_assign
op_logical_neg
op_logical_neg
(paren
id|cflags
op_amp
id|REG_NOSUB
)paren
suffix:semicolon
multiline_comment|/* POSIX says a null character in the pattern terminates it, so we&n;     can use strlen here in compiling the pattern.  */
id|ret
op_assign
id|regex_compile
(paren
id|pattern
comma
id|strlen
(paren
id|pattern
)paren
comma
id|syntax
comma
id|preg
)paren
suffix:semicolon
multiline_comment|/* POSIX doesn&squot;t distinguish between an unmatched open-group and an&n;     unmatched close-group: both are REG_EPAREN.  */
r_if
c_cond
(paren
id|ret
op_eq
id|REG_ERPAREN
)paren
id|ret
op_assign
id|REG_EPAREN
suffix:semicolon
r_return
(paren
r_int
)paren
id|ret
suffix:semicolon
)brace
multiline_comment|/* regexec searches for a given pattern, specified by PREG, in the&n;   string STRING.&n;&n;   If NMATCH is zero or REG_NOSUB was set in the cflags argument to&n;   `regcomp&squot;, we ignore PMATCH.  Otherwise, we assume PMATCH has at&n;   least NMATCH elements, and we set them to the offsets of the&n;   corresponding matched substrings.&n;&n;   EFLAGS specifies `execution flags&squot; which affect matching: if&n;   REG_NOTBOL is set, then ^ does not match at the beginning of the&n;   string; if REG_NOTEOL is set, then $ does not match at the end.&n;&n;   We return 0 if we find a match and REG_NOMATCH if not.  */
r_int
DECL|function|regexec
id|regexec
(paren
id|preg
comma
id|string
comma
id|nmatch
comma
id|pmatch
comma
id|eflags
)paren
r_const
id|regex_t
op_star
id|preg
suffix:semicolon
r_const
r_char
op_star
id|string
suffix:semicolon
r_int
id|nmatch
suffix:semicolon
id|regmatch_t
id|pmatch
(braket
)braket
suffix:semicolon
r_int
id|eflags
suffix:semicolon
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|re_registers
id|regs
suffix:semicolon
id|regex_t
id|private_preg
suffix:semicolon
r_int
id|len
op_assign
id|strlen
(paren
id|string
)paren
suffix:semicolon
id|boolean
id|want_reg_info
op_assign
op_logical_neg
id|preg-&gt;no_sub
op_logical_and
id|nmatch
OG
l_int|0
suffix:semicolon
id|private_preg
op_assign
op_star
id|preg
suffix:semicolon
id|private_preg.not_bol
op_assign
op_logical_neg
op_logical_neg
(paren
id|eflags
op_amp
id|REG_NOTBOL
)paren
suffix:semicolon
id|private_preg.not_eol
op_assign
op_logical_neg
op_logical_neg
(paren
id|eflags
op_amp
id|REG_NOTEOL
)paren
suffix:semicolon
multiline_comment|/* The user has told us exactly how many registers to return&n;     information about, via `nmatch&squot;.  We have to pass that on to the&n;     matching routines.  */
id|private_preg.regs_allocated
op_assign
id|REGS_FIXED
suffix:semicolon
r_if
c_cond
(paren
id|want_reg_info
)paren
(brace
id|regs.num_regs
op_assign
id|nmatch
suffix:semicolon
id|regs.start
op_assign
id|TALLOC
(paren
id|nmatch
comma
id|regoff_t
)paren
suffix:semicolon
id|regs.end
op_assign
id|TALLOC
(paren
id|nmatch
comma
id|regoff_t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|regs.start
op_eq
l_int|NULL
op_logical_or
id|regs.end
op_eq
l_int|NULL
)paren
r_return
(paren
r_int
)paren
id|REG_NOMATCH
suffix:semicolon
)brace
multiline_comment|/* Perform the searching operation.  */
id|ret
op_assign
id|re_search
(paren
op_amp
id|private_preg
comma
id|string
comma
id|len
comma
multiline_comment|/* start: */
l_int|0
comma
multiline_comment|/* range: */
id|len
comma
id|want_reg_info
ques
c_cond
op_amp
id|regs
suffix:colon
(paren
r_struct
id|re_registers
op_star
)paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Copy the register information to the POSIX structure.  */
r_if
c_cond
(paren
id|want_reg_info
)paren
(brace
r_if
c_cond
(paren
id|ret
op_ge
l_int|0
)paren
(brace
r_int
id|r
suffix:semicolon
r_for
c_loop
(paren
id|r
op_assign
l_int|0
suffix:semicolon
id|r
OL
id|nmatch
suffix:semicolon
id|r
op_increment
)paren
(brace
id|pmatch
(braket
id|r
)braket
dot
id|rm_so
op_assign
id|regs.start
(braket
id|r
)braket
suffix:semicolon
id|pmatch
(braket
id|r
)braket
dot
id|rm_eo
op_assign
id|regs.end
(braket
id|r
)braket
suffix:semicolon
)brace
)brace
multiline_comment|/* If we needed the temporary register info, free the space now.  */
id|free
(paren
id|regs.start
)paren
suffix:semicolon
id|free
(paren
id|regs.end
)paren
suffix:semicolon
)brace
multiline_comment|/* We want zero return to mean success, unlike `re_search&squot;.  */
r_return
id|ret
op_ge
l_int|0
ques
c_cond
(paren
r_int
)paren
id|REG_NOERROR
suffix:colon
(paren
r_int
)paren
id|REG_NOMATCH
suffix:semicolon
)brace
multiline_comment|/* Returns a message corresponding to an error code, ERRCODE, returned&n;   from either regcomp or regexec.   We don&squot;t use PREG here.  */
r_int
DECL|function|regerror
id|regerror
(paren
id|errcode
comma
id|preg
comma
id|errbuf
comma
id|errbuf_size
)paren
r_int
id|errcode
suffix:semicolon
r_const
id|regex_t
op_star
id|preg
suffix:semicolon
r_char
op_star
id|errbuf
suffix:semicolon
r_int
id|errbuf_size
suffix:semicolon
(brace
r_const
r_char
op_star
id|msg
suffix:semicolon
r_int
id|msg_size
suffix:semicolon
r_if
c_cond
(paren
id|errcode
OL
l_int|0
op_logical_or
id|errcode
op_ge
(paren
r_sizeof
(paren
id|re_error_msg
)paren
op_div
r_sizeof
(paren
id|re_error_msg
(braket
l_int|0
)braket
)paren
)paren
)paren
multiline_comment|/* Only error codes returned by the rest of the code should be passed&n;       to this routine.  If we are given anything else, or if other regex&n;       code generates an invalid error code, then the program has a bug.&n;       Dump core so we can fix it.  */
m_abort
(paren
)paren
suffix:semicolon
id|msg
op_assign
id|re_error_msg
(braket
id|errcode
)braket
suffix:semicolon
multiline_comment|/* POSIX doesn&squot;t require that we do anything in this case, but why&n;     not be nice.  */
r_if
c_cond
(paren
op_logical_neg
id|msg
)paren
id|msg
op_assign
l_string|&quot;Success&quot;
suffix:semicolon
id|msg_size
op_assign
id|strlen
(paren
id|msg
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Includes the null.  */
r_if
c_cond
(paren
id|errbuf_size
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|msg_size
OG
id|errbuf_size
)paren
(brace
id|strncpy
(paren
id|errbuf
comma
id|msg
comma
id|errbuf_size
l_int|1
)paren
suffix:semicolon
id|errbuf
(braket
id|errbuf_size
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|strcpy
(paren
id|errbuf
comma
id|msg
)paren
suffix:semicolon
)brace
r_return
id|msg_size
suffix:semicolon
)brace
multiline_comment|/* Free dynamically allocated space used by PREG.  */
r_void
DECL|function|regfree
id|regfree
(paren
id|preg
)paren
id|regex_t
op_star
id|preg
suffix:semicolon
(brace
r_if
c_cond
(paren
id|preg-&gt;buffer
op_ne
l_int|NULL
)paren
id|free
(paren
id|preg-&gt;buffer
)paren
suffix:semicolon
id|preg-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
id|preg-&gt;allocated
op_assign
l_int|0
suffix:semicolon
id|preg-&gt;used
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|preg-&gt;fastmap
op_ne
l_int|NULL
)paren
id|free
(paren
id|preg-&gt;fastmap
)paren
suffix:semicolon
id|preg-&gt;fastmap
op_assign
l_int|NULL
suffix:semicolon
id|preg-&gt;fastmap_accurate
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|preg-&gt;translate
op_ne
l_int|NULL
)paren
id|free
(paren
id|preg-&gt;translate
)paren
suffix:semicolon
id|preg-&gt;translate
op_assign
l_int|NULL
suffix:semicolon
)brace
macro_line|#endif /* not emacs  */
"&f;"
multiline_comment|/*&n;Local variables:&n;make-backup-files: t&n;version-control: t&n;trim-versions-without-asking: nil&n;End:&n;*/
eof
