macro_line|#include &quot;../git-compat-util.h&quot;
macro_line|#include &quot;win32.h&quot;
macro_line|#include &lt;conio.h&gt;
macro_line|#include &quot;../strbuf.h&quot;
macro_line|#include &quot;../run-command.h&quot;
DECL|variable|delay
r_static
r_const
r_int
id|delay
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|1
comma
l_int|10
comma
l_int|20
comma
l_int|40
)brace
suffix:semicolon
DECL|function|err_win_to_posix
r_int
id|err_win_to_posix
c_func
(paren
id|DWORD
id|winerr
)paren
(brace
r_int
id|error
op_assign
id|ENOSYS
suffix:semicolon
r_switch
c_cond
(paren
id|winerr
)paren
(brace
r_case
id|ERROR_ACCESS_DENIED
suffix:colon
id|error
op_assign
id|EACCES
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_ACCOUNT_DISABLED
suffix:colon
id|error
op_assign
id|EACCES
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_ACCOUNT_RESTRICTION
suffix:colon
id|error
op_assign
id|EACCES
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_ALREADY_ASSIGNED
suffix:colon
id|error
op_assign
id|EBUSY
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_ALREADY_EXISTS
suffix:colon
id|error
op_assign
id|EEXIST
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_ARITHMETIC_OVERFLOW
suffix:colon
id|error
op_assign
id|ERANGE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_BAD_COMMAND
suffix:colon
id|error
op_assign
id|EIO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_BAD_DEVICE
suffix:colon
id|error
op_assign
id|ENODEV
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_BAD_DRIVER_LEVEL
suffix:colon
id|error
op_assign
id|ENXIO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_BAD_EXE_FORMAT
suffix:colon
id|error
op_assign
id|ENOEXEC
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_BAD_FORMAT
suffix:colon
id|error
op_assign
id|ENOEXEC
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_BAD_LENGTH
suffix:colon
id|error
op_assign
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_BAD_PATHNAME
suffix:colon
id|error
op_assign
id|ENOENT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_BAD_PIPE
suffix:colon
id|error
op_assign
id|EPIPE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_BAD_UNIT
suffix:colon
id|error
op_assign
id|ENODEV
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_BAD_USERNAME
suffix:colon
id|error
op_assign
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_BROKEN_PIPE
suffix:colon
id|error
op_assign
id|EPIPE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_BUFFER_OVERFLOW
suffix:colon
id|error
op_assign
id|ENAMETOOLONG
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_BUSY
suffix:colon
id|error
op_assign
id|EBUSY
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_BUSY_DRIVE
suffix:colon
id|error
op_assign
id|EBUSY
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_CALL_NOT_IMPLEMENTED
suffix:colon
id|error
op_assign
id|ENOSYS
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_CANNOT_MAKE
suffix:colon
id|error
op_assign
id|EACCES
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_CANTOPEN
suffix:colon
id|error
op_assign
id|EIO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_CANTREAD
suffix:colon
id|error
op_assign
id|EIO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_CANTWRITE
suffix:colon
id|error
op_assign
id|EIO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_CRC
suffix:colon
id|error
op_assign
id|EIO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_CURRENT_DIRECTORY
suffix:colon
id|error
op_assign
id|EACCES
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_DEVICE_IN_USE
suffix:colon
id|error
op_assign
id|EBUSY
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_DEV_NOT_EXIST
suffix:colon
id|error
op_assign
id|ENODEV
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_DIRECTORY
suffix:colon
id|error
op_assign
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_DIR_NOT_EMPTY
suffix:colon
id|error
op_assign
id|ENOTEMPTY
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_DISK_CHANGE
suffix:colon
id|error
op_assign
id|EIO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_DISK_FULL
suffix:colon
id|error
op_assign
id|ENOSPC
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_DRIVE_LOCKED
suffix:colon
id|error
op_assign
id|EBUSY
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_ENVVAR_NOT_FOUND
suffix:colon
id|error
op_assign
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_EXE_MARKED_INVALID
suffix:colon
id|error
op_assign
id|ENOEXEC
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_FILENAME_EXCED_RANGE
suffix:colon
id|error
op_assign
id|ENAMETOOLONG
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_FILE_EXISTS
suffix:colon
id|error
op_assign
id|EEXIST
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_FILE_INVALID
suffix:colon
id|error
op_assign
id|ENODEV
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_FILE_NOT_FOUND
suffix:colon
id|error
op_assign
id|ENOENT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_GEN_FAILURE
suffix:colon
id|error
op_assign
id|EIO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_HANDLE_DISK_FULL
suffix:colon
id|error
op_assign
id|ENOSPC
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_INSUFFICIENT_BUFFER
suffix:colon
id|error
op_assign
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_INVALID_ACCESS
suffix:colon
id|error
op_assign
id|EACCES
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_INVALID_ADDRESS
suffix:colon
id|error
op_assign
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_INVALID_BLOCK
suffix:colon
id|error
op_assign
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_INVALID_DATA
suffix:colon
id|error
op_assign
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_INVALID_DRIVE
suffix:colon
id|error
op_assign
id|ENODEV
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_INVALID_EXE_SIGNATURE
suffix:colon
id|error
op_assign
id|ENOEXEC
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_INVALID_FLAGS
suffix:colon
id|error
op_assign
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_INVALID_FUNCTION
suffix:colon
id|error
op_assign
id|ENOSYS
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_INVALID_HANDLE
suffix:colon
id|error
op_assign
id|EBADF
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_INVALID_LOGON_HOURS
suffix:colon
id|error
op_assign
id|EACCES
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_INVALID_NAME
suffix:colon
id|error
op_assign
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_INVALID_OWNER
suffix:colon
id|error
op_assign
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_INVALID_PARAMETER
suffix:colon
id|error
op_assign
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_INVALID_PASSWORD
suffix:colon
id|error
op_assign
id|EPERM
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_INVALID_PRIMARY_GROUP
suffix:colon
id|error
op_assign
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_INVALID_SIGNAL_NUMBER
suffix:colon
id|error
op_assign
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_INVALID_TARGET_HANDLE
suffix:colon
id|error
op_assign
id|EIO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_INVALID_WORKSTATION
suffix:colon
id|error
op_assign
id|EACCES
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_IO_DEVICE
suffix:colon
id|error
op_assign
id|EIO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_IO_INCOMPLETE
suffix:colon
id|error
op_assign
id|EINTR
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_LOCKED
suffix:colon
id|error
op_assign
id|EBUSY
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_LOCK_VIOLATION
suffix:colon
id|error
op_assign
id|EACCES
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_LOGON_FAILURE
suffix:colon
id|error
op_assign
id|EACCES
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_MAPPED_ALIGNMENT
suffix:colon
id|error
op_assign
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_META_EXPANSION_TOO_LONG
suffix:colon
id|error
op_assign
id|E2BIG
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_MORE_DATA
suffix:colon
id|error
op_assign
id|EPIPE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_NEGATIVE_SEEK
suffix:colon
id|error
op_assign
id|ESPIPE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_NOACCESS
suffix:colon
id|error
op_assign
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_NONE_MAPPED
suffix:colon
id|error
op_assign
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_NOT_ENOUGH_MEMORY
suffix:colon
id|error
op_assign
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_NOT_READY
suffix:colon
id|error
op_assign
id|EAGAIN
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_NOT_SAME_DEVICE
suffix:colon
id|error
op_assign
id|EXDEV
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_NO_DATA
suffix:colon
id|error
op_assign
id|EPIPE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_NO_MORE_SEARCH_HANDLES
suffix:colon
id|error
op_assign
id|EIO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_NO_PROC_SLOTS
suffix:colon
id|error
op_assign
id|EAGAIN
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_NO_SUCH_PRIVILEGE
suffix:colon
id|error
op_assign
id|EACCES
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_OPEN_FAILED
suffix:colon
id|error
op_assign
id|EIO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_OPEN_FILES
suffix:colon
id|error
op_assign
id|EBUSY
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_OPERATION_ABORTED
suffix:colon
id|error
op_assign
id|EINTR
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_OUTOFMEMORY
suffix:colon
id|error
op_assign
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_PASSWORD_EXPIRED
suffix:colon
id|error
op_assign
id|EACCES
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_PATH_BUSY
suffix:colon
id|error
op_assign
id|EBUSY
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_PATH_NOT_FOUND
suffix:colon
id|error
op_assign
id|ENOENT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_PIPE_BUSY
suffix:colon
id|error
op_assign
id|EBUSY
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_PIPE_CONNECTED
suffix:colon
id|error
op_assign
id|EPIPE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_PIPE_LISTENING
suffix:colon
id|error
op_assign
id|EPIPE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_PIPE_NOT_CONNECTED
suffix:colon
id|error
op_assign
id|EPIPE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_PRIVILEGE_NOT_HELD
suffix:colon
id|error
op_assign
id|EACCES
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_READ_FAULT
suffix:colon
id|error
op_assign
id|EIO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_SEEK
suffix:colon
id|error
op_assign
id|EIO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_SEEK_ON_DEVICE
suffix:colon
id|error
op_assign
id|ESPIPE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_SHARING_BUFFER_EXCEEDED
suffix:colon
id|error
op_assign
id|ENFILE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_SHARING_VIOLATION
suffix:colon
id|error
op_assign
id|EACCES
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_STACK_OVERFLOW
suffix:colon
id|error
op_assign
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_SWAPERROR
suffix:colon
id|error
op_assign
id|ENOENT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_TOO_MANY_MODULES
suffix:colon
id|error
op_assign
id|EMFILE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_TOO_MANY_OPEN_FILES
suffix:colon
id|error
op_assign
id|EMFILE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_UNRECOGNIZED_MEDIA
suffix:colon
id|error
op_assign
id|ENXIO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_UNRECOGNIZED_VOLUME
suffix:colon
id|error
op_assign
id|ENODEV
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_WAIT_NO_CHILDREN
suffix:colon
id|error
op_assign
id|ECHILD
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_WRITE_FAULT
suffix:colon
id|error
op_assign
id|EIO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ERROR_WRITE_PROTECT
suffix:colon
id|error
op_assign
id|EROFS
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
DECL|function|is_file_in_use_error
r_static
r_inline
r_int
id|is_file_in_use_error
c_func
(paren
id|DWORD
id|errcode
)paren
(brace
r_switch
c_cond
(paren
id|errcode
)paren
(brace
r_case
id|ERROR_SHARING_VIOLATION
suffix:colon
r_case
id|ERROR_ACCESS_DENIED
suffix:colon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|read_yes_no_answer
r_static
r_int
id|read_yes_no_answer
c_func
(paren
r_void
)paren
(brace
r_char
id|answer
(braket
l_int|1024
)braket
suffix:semicolon
r_if
c_cond
(paren
id|fgets
c_func
(paren
id|answer
comma
r_sizeof
(paren
id|answer
)paren
comma
id|stdin
)paren
)paren
(brace
r_int
id|answer_len
op_assign
id|strlen
c_func
(paren
id|answer
)paren
suffix:semicolon
r_int
id|got_full_line
op_assign
l_int|0
comma
id|c
suffix:semicolon
multiline_comment|/* remove the newline */
r_if
c_cond
(paren
id|answer_len
op_ge
l_int|2
op_logical_and
id|answer
(braket
id|answer_len
op_minus
l_int|2
)braket
op_eq
l_char|&squot;&bslash;r&squot;
)paren
(brace
id|answer
(braket
id|answer_len
op_minus
l_int|2
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|got_full_line
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|answer_len
op_ge
l_int|1
op_logical_and
id|answer
(braket
id|answer_len
op_minus
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|answer
(braket
id|answer_len
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|got_full_line
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* flush the buffer in case we did not get the full line */
r_if
c_cond
(paren
op_logical_neg
id|got_full_line
)paren
r_while
c_loop
(paren
(paren
id|c
op_assign
id|getchar
c_func
(paren
)paren
)paren
op_ne
id|EOF
op_logical_and
id|c
op_ne
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* we could not read, return the&n;&t;&t; * default answer which is no */
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tolower
c_func
(paren
id|answer
(braket
l_int|0
)braket
)paren
op_eq
l_char|&squot;y&squot;
op_logical_and
op_logical_neg
id|answer
(braket
l_int|1
)braket
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncasecmp
c_func
(paren
id|answer
comma
l_string|&quot;yes&quot;
comma
r_sizeof
(paren
id|answer
)paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|tolower
c_func
(paren
id|answer
(braket
l_int|0
)braket
)paren
op_eq
l_char|&squot;n&squot;
op_logical_and
op_logical_neg
id|answer
(braket
l_int|1
)braket
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncasecmp
c_func
(paren
id|answer
comma
l_string|&quot;no&quot;
comma
r_sizeof
(paren
id|answer
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* did not find an answer we understand */
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|ask_yes_no_if_possible
r_static
r_int
id|ask_yes_no_if_possible
c_func
(paren
r_const
r_char
op_star
id|format
comma
dot
dot
dot
)paren
(brace
r_char
id|question
(braket
l_int|4096
)braket
suffix:semicolon
r_const
r_char
op_star
id|retry_hook
(braket
)braket
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
id|va_list
id|args
suffix:semicolon
id|va_start
c_func
(paren
id|args
comma
id|format
)paren
suffix:semicolon
id|vsnprintf
c_func
(paren
id|question
comma
r_sizeof
(paren
id|question
)paren
comma
id|format
comma
id|args
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|retry_hook
(braket
l_int|0
)braket
op_assign
id|mingw_getenv
c_func
(paren
l_string|&quot;GIT_ASK_YESNO&quot;
)paren
)paren
)paren
(brace
id|retry_hook
(braket
l_int|1
)braket
op_assign
id|question
suffix:semicolon
r_return
op_logical_neg
id|run_command_v_opt
c_func
(paren
id|retry_hook
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|isatty
c_func
(paren
id|_fileno
c_func
(paren
id|stdin
)paren
)paren
op_logical_or
op_logical_neg
id|isatty
c_func
(paren
id|_fileno
c_func
(paren
id|stderr
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_int
id|answer
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s (y/n) &quot;
comma
id|question
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|answer
op_assign
id|read_yes_no_answer
c_func
(paren
)paren
)paren
op_ge
l_int|0
)paren
r_return
id|answer
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Sorry, I did not understand your answer. &quot;
l_string|&quot;Please type &squot;y&squot; or &squot;n&squot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|macro|unlink
macro_line|#undef unlink
DECL|function|mingw_unlink
r_int
id|mingw_unlink
c_func
(paren
r_const
r_char
op_star
id|pathname
)paren
(brace
r_int
id|ret
comma
id|tries
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* read-only files cannot be removed */
id|chmod
c_func
(paren
id|pathname
comma
l_int|0666
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ret
op_assign
id|unlink
c_func
(paren
id|pathname
)paren
)paren
op_eq
l_int|1
op_logical_and
id|tries
OL
id|ARRAY_SIZE
c_func
(paren
id|delay
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|is_file_in_use_error
c_func
(paren
id|GetLastError
c_func
(paren
)paren
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We assume that some other process had the source or&n;&t;&t; * destination file open at the wrong moment and retry.&n;&t;&t; * In order to give the other process a higher chance to&n;&t;&t; * complete its operation, we give up our time slice now.&n;&t;&t; * If we have to retry again, we do sleep a bit.&n;&t;&t; */
id|Sleep
c_func
(paren
id|delay
(braket
id|tries
)braket
)paren
suffix:semicolon
id|tries
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|ret
op_eq
l_int|1
op_logical_and
id|is_file_in_use_error
c_func
(paren
id|GetLastError
c_func
(paren
)paren
)paren
op_logical_and
id|ask_yes_no_if_possible
c_func
(paren
l_string|&quot;Unlink of file &squot;%s&squot; failed. &quot;
l_string|&quot;Should I try again?&quot;
comma
id|pathname
)paren
)paren
id|ret
op_assign
id|unlink
c_func
(paren
id|pathname
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|is_dir_empty
r_static
r_int
id|is_dir_empty
c_func
(paren
r_const
r_char
op_star
id|path
)paren
(brace
r_struct
id|strbuf
id|buf
op_assign
id|STRBUF_INIT
suffix:semicolon
id|WIN32_FIND_DATAA
id|findbuf
suffix:semicolon
id|HANDLE
id|handle
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
id|buf
comma
l_string|&quot;%s&bslash;&bslash;*&quot;
comma
id|path
)paren
suffix:semicolon
id|handle
op_assign
id|FindFirstFileA
c_func
(paren
id|buf.buf
comma
op_amp
id|findbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|handle
op_eq
id|INVALID_HANDLE_VALUE
)paren
(brace
id|strbuf_release
c_func
(paren
op_amp
id|buf
)paren
suffix:semicolon
r_return
id|GetLastError
c_func
(paren
)paren
op_eq
id|ERROR_NO_MORE_FILES
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|findbuf.cFileName
comma
l_string|&quot;.&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|findbuf.cFileName
comma
l_string|&quot;..&quot;
)paren
)paren
r_if
c_cond
(paren
op_logical_neg
id|FindNextFile
c_func
(paren
id|handle
comma
op_amp
id|findbuf
)paren
)paren
(brace
id|strbuf_release
c_func
(paren
op_amp
id|buf
)paren
suffix:semicolon
r_return
id|GetLastError
c_func
(paren
)paren
op_eq
id|ERROR_NO_MORE_FILES
suffix:semicolon
)brace
id|FindClose
c_func
(paren
id|handle
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|buf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|rmdir
macro_line|#undef rmdir
DECL|function|mingw_rmdir
r_int
id|mingw_rmdir
c_func
(paren
r_const
r_char
op_star
id|pathname
)paren
(brace
r_int
id|ret
comma
id|tries
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ret
op_assign
id|rmdir
c_func
(paren
id|pathname
)paren
)paren
op_eq
l_int|1
op_logical_and
id|tries
OL
id|ARRAY_SIZE
c_func
(paren
id|delay
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|is_file_in_use_error
c_func
(paren
id|GetLastError
c_func
(paren
)paren
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_dir_empty
c_func
(paren
id|pathname
)paren
)paren
(brace
id|errno
op_assign
id|ENOTEMPTY
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * We assume that some other process had the source or&n;&t;&t; * destination file open at the wrong moment and retry.&n;&t;&t; * In order to give the other process a higher chance to&n;&t;&t; * complete its operation, we give up our time slice now.&n;&t;&t; * If we have to retry again, we do sleep a bit.&n;&t;&t; */
id|Sleep
c_func
(paren
id|delay
(braket
id|tries
)braket
)paren
suffix:semicolon
id|tries
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|ret
op_eq
l_int|1
op_logical_and
id|is_file_in_use_error
c_func
(paren
id|GetLastError
c_func
(paren
)paren
)paren
op_logical_and
id|ask_yes_no_if_possible
c_func
(paren
l_string|&quot;Deletion of directory &squot;%s&squot; failed. &quot;
l_string|&quot;Should I try again?&quot;
comma
id|pathname
)paren
)paren
id|ret
op_assign
id|rmdir
c_func
(paren
id|pathname
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|macro|open
macro_line|#undef open
DECL|function|mingw_open
r_int
id|mingw_open
(paren
r_const
r_char
op_star
id|filename
comma
r_int
id|oflags
comma
dot
dot
dot
)paren
(brace
id|va_list
id|args
suffix:semicolon
r_int
id|mode
suffix:semicolon
r_int
id|fd
suffix:semicolon
id|va_start
c_func
(paren
id|args
comma
id|oflags
)paren
suffix:semicolon
id|mode
op_assign
id|va_arg
c_func
(paren
id|args
comma
r_int
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
id|filename
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|filename
comma
l_string|&quot;/dev/null&quot;
)paren
)paren
id|filename
op_assign
l_string|&quot;nul&quot;
suffix:semicolon
id|fd
op_assign
id|open
c_func
(paren
id|filename
comma
id|oflags
comma
id|mode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
op_logical_and
(paren
id|oflags
op_amp
id|O_CREAT
)paren
op_logical_and
id|errno
op_eq
id|EACCES
)paren
(brace
id|DWORD
id|attrs
op_assign
id|GetFileAttributes
c_func
(paren
id|filename
)paren
suffix:semicolon
r_if
c_cond
(paren
id|attrs
op_ne
id|INVALID_FILE_ATTRIBUTES
op_logical_and
(paren
id|attrs
op_amp
id|FILE_ATTRIBUTE_DIRECTORY
)paren
)paren
id|errno
op_assign
id|EISDIR
suffix:semicolon
)brace
r_return
id|fd
suffix:semicolon
)brace
DECL|macro|write
macro_line|#undef write
DECL|function|mingw_write
id|ssize_t
id|mingw_write
c_func
(paren
r_int
id|fd
comma
r_const
r_void
op_star
id|buf
comma
r_int
id|count
)paren
(brace
multiline_comment|/*&n;&t; * While write() calls to a file on a local disk are translated&n;&t; * into WriteFile() calls with a maximum size of 64KB on Windows&n;&t; * XP and 256KB on Vista, no such cap is placed on writes to&n;&t; * files over the network on Windows XP.  Unfortunately, there&n;&t; * seems to be a limit of 32MB-28KB on X64 and 64MB-32KB on x86;&n;&t; * bigger writes fail on Windows XP.&n;&t; * So we cap to a nice 31MB here to avoid write failures over&n;&t; * the net without changing the number of WriteFile() calls in&n;&t; * the local case.&n;&t; */
r_return
id|write
c_func
(paren
id|fd
comma
id|buf
comma
id|min
c_func
(paren
id|count
comma
l_int|31
op_star
l_int|1024
op_star
l_int|1024
)paren
)paren
suffix:semicolon
)brace
DECL|macro|fopen
macro_line|#undef fopen
DECL|function|mingw_fopen
id|FILE
op_star
id|mingw_fopen
(paren
r_const
r_char
op_star
id|filename
comma
r_const
r_char
op_star
id|otype
)paren
(brace
r_if
c_cond
(paren
id|filename
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|filename
comma
l_string|&quot;/dev/null&quot;
)paren
)paren
id|filename
op_assign
l_string|&quot;nul&quot;
suffix:semicolon
r_return
id|fopen
c_func
(paren
id|filename
comma
id|otype
)paren
suffix:semicolon
)brace
DECL|macro|freopen
macro_line|#undef freopen
DECL|function|mingw_freopen
id|FILE
op_star
id|mingw_freopen
(paren
r_const
r_char
op_star
id|filename
comma
r_const
r_char
op_star
id|otype
comma
id|FILE
op_star
id|stream
)paren
(brace
r_if
c_cond
(paren
id|filename
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|filename
comma
l_string|&quot;/dev/null&quot;
)paren
)paren
id|filename
op_assign
l_string|&quot;nul&quot;
suffix:semicolon
r_return
id|freopen
c_func
(paren
id|filename
comma
id|otype
comma
id|stream
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The unit of FILETIME is 100-nanoseconds since January 1, 1601, UTC.&n; * Returns the 100-nanoseconds (&quot;hekto nanoseconds&quot;) since the epoch.&n; */
DECL|function|filetime_to_hnsec
r_static
r_inline
r_int
r_int
id|filetime_to_hnsec
c_func
(paren
r_const
id|FILETIME
op_star
id|ft
)paren
(brace
r_int
r_int
id|winTime
op_assign
(paren
(paren
r_int
r_int
)paren
id|ft-&gt;dwHighDateTime
op_lshift
l_int|32
)paren
op_plus
id|ft-&gt;dwLowDateTime
suffix:semicolon
multiline_comment|/* Windows to Unix Epoch conversion */
r_return
id|winTime
l_int|116444736000000000LL
suffix:semicolon
)brace
DECL|function|filetime_to_time_t
r_static
r_inline
id|time_t
id|filetime_to_time_t
c_func
(paren
r_const
id|FILETIME
op_star
id|ft
)paren
(brace
r_return
(paren
id|time_t
)paren
(paren
id|filetime_to_hnsec
c_func
(paren
id|ft
)paren
op_div
l_int|10000000
)paren
suffix:semicolon
)brace
multiline_comment|/* We keep the do_lstat code in a separate function to avoid recursion.&n; * When a path ends with a slash, the stat will fail with ENOENT. In&n; * this case, we strip the trailing slashes and stat again.&n; *&n; * If follow is true then act like stat() and report on the link&n; * target. Otherwise report on the link itself.&n; */
DECL|function|do_lstat
r_static
r_int
id|do_lstat
c_func
(paren
r_int
id|follow
comma
r_const
r_char
op_star
id|file_name
comma
r_struct
id|stat
op_star
id|buf
)paren
(brace
r_int
id|err
suffix:semicolon
id|WIN32_FILE_ATTRIBUTE_DATA
id|fdata
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|err
op_assign
id|get_file_attr
c_func
(paren
id|file_name
comma
op_amp
id|fdata
)paren
)paren
)paren
(brace
id|buf-&gt;st_ino
op_assign
l_int|0
suffix:semicolon
id|buf-&gt;st_gid
op_assign
l_int|0
suffix:semicolon
id|buf-&gt;st_uid
op_assign
l_int|0
suffix:semicolon
id|buf-&gt;st_nlink
op_assign
l_int|1
suffix:semicolon
id|buf-&gt;st_mode
op_assign
id|file_attr_to_st_mode
c_func
(paren
id|fdata.dwFileAttributes
)paren
suffix:semicolon
id|buf-&gt;st_size
op_assign
id|fdata.nFileSizeLow
op_or
(paren
(paren
(paren
id|off_t
)paren
id|fdata.nFileSizeHigh
)paren
op_lshift
l_int|32
)paren
suffix:semicolon
id|buf-&gt;st_dev
op_assign
id|buf-&gt;st_rdev
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* not used by Git */
id|buf-&gt;st_atime
op_assign
id|filetime_to_time_t
c_func
(paren
op_amp
(paren
id|fdata.ftLastAccessTime
)paren
)paren
suffix:semicolon
id|buf-&gt;st_mtime
op_assign
id|filetime_to_time_t
c_func
(paren
op_amp
(paren
id|fdata.ftLastWriteTime
)paren
)paren
suffix:semicolon
id|buf-&gt;st_ctime
op_assign
id|filetime_to_time_t
c_func
(paren
op_amp
(paren
id|fdata.ftCreationTime
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fdata.dwFileAttributes
op_amp
id|FILE_ATTRIBUTE_REPARSE_POINT
)paren
(brace
id|WIN32_FIND_DATAA
id|findbuf
suffix:semicolon
id|HANDLE
id|handle
op_assign
id|FindFirstFileA
c_func
(paren
id|file_name
comma
op_amp
id|findbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|handle
op_ne
id|INVALID_HANDLE_VALUE
)paren
(brace
r_if
c_cond
(paren
(paren
id|findbuf.dwFileAttributes
op_amp
id|FILE_ATTRIBUTE_REPARSE_POINT
)paren
op_logical_and
(paren
id|findbuf.dwReserved0
op_eq
id|IO_REPARSE_TAG_SYMLINK
)paren
)paren
(brace
r_if
c_cond
(paren
id|follow
)paren
(brace
r_char
id|buffer
(braket
id|MAXIMUM_REPARSE_DATA_BUFFER_SIZE
)braket
suffix:semicolon
id|buf-&gt;st_size
op_assign
id|readlink
c_func
(paren
id|file_name
comma
id|buffer
comma
id|MAXIMUM_REPARSE_DATA_BUFFER_SIZE
)paren
suffix:semicolon
)brace
r_else
(brace
id|buf-&gt;st_mode
op_assign
id|S_IFLNK
suffix:semicolon
)brace
id|buf-&gt;st_mode
op_or_assign
id|S_IREAD
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|findbuf.dwFileAttributes
op_amp
id|FILE_ATTRIBUTE_READONLY
)paren
)paren
id|buf-&gt;st_mode
op_or_assign
id|S_IWRITE
suffix:semicolon
)brace
id|FindClose
c_func
(paren
id|handle
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|errno
op_assign
id|err
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* We provide our own lstat/fstat functions, since the provided&n; * lstat/fstat functions are so slow. These stat functions are&n; * tailored for Git&squot;s usage (read: fast), and are not meant to be&n; * complete. Note that Git stat()s are redirected to mingw_lstat()&n; * too, since Windows doesn&squot;t really handle symlinks that well.&n; */
DECL|function|do_stat_internal
r_static
r_int
id|do_stat_internal
c_func
(paren
r_int
id|follow
comma
r_const
r_char
op_star
id|file_name
comma
r_struct
id|stat
op_star
id|buf
)paren
(brace
r_int
id|namelen
suffix:semicolon
r_static
r_char
id|alt_name
(braket
id|PATH_MAX
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|do_lstat
c_func
(paren
id|follow
comma
id|file_name
comma
id|buf
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* if file_name ended in a &squot;/&squot;, Windows returned ENOENT;&n;&t; * try again without trailing slashes&n;&t; */
r_if
c_cond
(paren
id|errno
op_ne
id|ENOENT
)paren
r_return
l_int|1
suffix:semicolon
id|namelen
op_assign
id|strlen
c_func
(paren
id|file_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|namelen
op_logical_and
id|file_name
(braket
id|namelen
op_minus
l_int|1
)braket
op_ne
l_char|&squot;/&squot;
)paren
r_return
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|namelen
op_logical_and
id|file_name
(braket
id|namelen
op_minus
l_int|1
)braket
op_eq
l_char|&squot;/&squot;
)paren
op_decrement
id|namelen
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|namelen
op_logical_or
id|namelen
op_ge
id|PATH_MAX
)paren
r_return
l_int|1
suffix:semicolon
id|memcpy
c_func
(paren
id|alt_name
comma
id|file_name
comma
id|namelen
)paren
suffix:semicolon
id|alt_name
(braket
id|namelen
)braket
op_assign
l_int|0
suffix:semicolon
r_return
id|do_lstat
c_func
(paren
id|follow
comma
id|alt_name
comma
id|buf
)paren
suffix:semicolon
)brace
DECL|function|mingw_lstat
r_int
id|mingw_lstat
c_func
(paren
r_const
r_char
op_star
id|file_name
comma
r_struct
id|stat
op_star
id|buf
)paren
(brace
r_return
id|do_stat_internal
c_func
(paren
l_int|0
comma
id|file_name
comma
id|buf
)paren
suffix:semicolon
)brace
DECL|function|mingw_stat
r_int
id|mingw_stat
c_func
(paren
r_const
r_char
op_star
id|file_name
comma
r_struct
id|stat
op_star
id|buf
)paren
(brace
r_return
id|do_stat_internal
c_func
(paren
l_int|1
comma
id|file_name
comma
id|buf
)paren
suffix:semicolon
)brace
DECL|macro|fstat
macro_line|#undef fstat
DECL|function|mingw_fstat
r_int
id|mingw_fstat
c_func
(paren
r_int
id|fd
comma
r_struct
id|stat
op_star
id|buf
)paren
(brace
id|HANDLE
id|fh
op_assign
(paren
id|HANDLE
)paren
id|_get_osfhandle
c_func
(paren
id|fd
)paren
suffix:semicolon
id|BY_HANDLE_FILE_INFORMATION
id|fdata
suffix:semicolon
r_if
c_cond
(paren
id|fh
op_eq
id|INVALID_HANDLE_VALUE
)paren
(brace
id|errno
op_assign
id|EBADF
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* direct non-file handles to MS&squot;s fstat() */
r_if
c_cond
(paren
id|GetFileType
c_func
(paren
id|fh
)paren
op_ne
id|FILE_TYPE_DISK
)paren
r_return
id|_fstati64
c_func
(paren
id|fd
comma
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GetFileInformationByHandle
c_func
(paren
id|fh
comma
op_amp
id|fdata
)paren
)paren
(brace
id|buf-&gt;st_ino
op_assign
l_int|0
suffix:semicolon
id|buf-&gt;st_gid
op_assign
l_int|0
suffix:semicolon
id|buf-&gt;st_uid
op_assign
l_int|0
suffix:semicolon
id|buf-&gt;st_nlink
op_assign
l_int|1
suffix:semicolon
id|buf-&gt;st_mode
op_assign
id|file_attr_to_st_mode
c_func
(paren
id|fdata.dwFileAttributes
)paren
suffix:semicolon
id|buf-&gt;st_size
op_assign
id|fdata.nFileSizeLow
op_or
(paren
(paren
(paren
id|off_t
)paren
id|fdata.nFileSizeHigh
)paren
op_lshift
l_int|32
)paren
suffix:semicolon
id|buf-&gt;st_dev
op_assign
id|buf-&gt;st_rdev
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* not used by Git */
id|buf-&gt;st_atime
op_assign
id|filetime_to_time_t
c_func
(paren
op_amp
(paren
id|fdata.ftLastAccessTime
)paren
)paren
suffix:semicolon
id|buf-&gt;st_mtime
op_assign
id|filetime_to_time_t
c_func
(paren
op_amp
(paren
id|fdata.ftLastWriteTime
)paren
)paren
suffix:semicolon
id|buf-&gt;st_ctime
op_assign
id|filetime_to_time_t
c_func
(paren
op_amp
(paren
id|fdata.ftCreationTime
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|errno
op_assign
id|EBADF
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|time_t_to_filetime
r_static
r_inline
r_void
id|time_t_to_filetime
c_func
(paren
id|time_t
id|t
comma
id|FILETIME
op_star
id|ft
)paren
(brace
r_int
r_int
id|winTime
op_assign
id|t
op_star
l_int|10000000LL
op_plus
l_int|116444736000000000LL
suffix:semicolon
id|ft-&gt;dwLowDateTime
op_assign
id|winTime
suffix:semicolon
id|ft-&gt;dwHighDateTime
op_assign
id|winTime
op_rshift
l_int|32
suffix:semicolon
)brace
DECL|function|mingw_utime
r_int
id|mingw_utime
(paren
r_const
r_char
op_star
id|file_name
comma
r_const
r_struct
id|utimbuf
op_star
id|times
)paren
(brace
id|FILETIME
id|mft
comma
id|aft
suffix:semicolon
r_int
id|fh
comma
id|rc
suffix:semicolon
multiline_comment|/* must have write permission */
id|DWORD
id|attrs
op_assign
id|GetFileAttributes
c_func
(paren
id|file_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|attrs
op_ne
id|INVALID_FILE_ATTRIBUTES
op_logical_and
(paren
id|attrs
op_amp
id|FILE_ATTRIBUTE_READONLY
)paren
)paren
(brace
multiline_comment|/* ignore errors here; open() will report them */
id|SetFileAttributes
c_func
(paren
id|file_name
comma
id|attrs
op_amp
op_complement
id|FILE_ATTRIBUTE_READONLY
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|fh
op_assign
id|open
c_func
(paren
id|file_name
comma
id|O_RDWR
op_or
id|O_BINARY
)paren
)paren
OL
l_int|0
)paren
(brace
id|rc
op_assign
l_int|1
suffix:semicolon
r_goto
id|revert_attrs
suffix:semicolon
)brace
r_if
c_cond
(paren
id|times
)paren
(brace
id|time_t_to_filetime
c_func
(paren
id|times-&gt;modtime
comma
op_amp
id|mft
)paren
suffix:semicolon
id|time_t_to_filetime
c_func
(paren
id|times-&gt;actime
comma
op_amp
id|aft
)paren
suffix:semicolon
)brace
r_else
(brace
id|GetSystemTimeAsFileTime
c_func
(paren
op_amp
id|mft
)paren
suffix:semicolon
id|aft
op_assign
id|mft
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|SetFileTime
c_func
(paren
(paren
id|HANDLE
)paren
id|_get_osfhandle
c_func
(paren
id|fh
)paren
comma
l_int|NULL
comma
op_amp
id|aft
comma
op_amp
id|mft
)paren
)paren
(brace
id|errno
op_assign
id|EINVAL
suffix:semicolon
id|rc
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|rc
op_assign
l_int|0
suffix:semicolon
id|close
c_func
(paren
id|fh
)paren
suffix:semicolon
id|revert_attrs
suffix:colon
r_if
c_cond
(paren
id|attrs
op_ne
id|INVALID_FILE_ATTRIBUTES
op_logical_and
(paren
id|attrs
op_amp
id|FILE_ATTRIBUTE_READONLY
)paren
)paren
(brace
multiline_comment|/* ignore errors again */
id|SetFileAttributes
c_func
(paren
id|file_name
comma
id|attrs
)paren
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
DECL|function|sleep
r_int
r_int
id|sleep
(paren
r_int
r_int
id|seconds
)paren
(brace
id|Sleep
c_func
(paren
id|seconds
op_star
l_int|1000
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|mkstemp
r_int
id|mkstemp
c_func
(paren
r_char
op_star
r_template
)paren
(brace
r_char
op_star
id|filename
op_assign
id|mktemp
c_func
(paren
r_template
)paren
suffix:semicolon
r_if
c_cond
(paren
id|filename
op_eq
l_int|NULL
)paren
r_return
l_int|1
suffix:semicolon
r_return
id|open
c_func
(paren
id|filename
comma
id|O_RDWR
op_or
id|O_CREAT
comma
l_int|0600
)paren
suffix:semicolon
)brace
DECL|function|gettimeofday
r_int
id|gettimeofday
c_func
(paren
r_struct
id|timeval
op_star
id|tv
comma
r_void
op_star
id|tz
)paren
(brace
id|FILETIME
id|ft
suffix:semicolon
r_int
r_int
id|hnsec
suffix:semicolon
id|GetSystemTimeAsFileTime
c_func
(paren
op_amp
id|ft
)paren
suffix:semicolon
id|hnsec
op_assign
id|filetime_to_hnsec
c_func
(paren
op_amp
id|ft
)paren
suffix:semicolon
id|tv-&gt;tv_sec
op_assign
id|hnsec
op_div
l_int|10000000
suffix:semicolon
id|tv-&gt;tv_usec
op_assign
(paren
id|hnsec
op_mod
l_int|10000000
)paren
op_div
l_int|10
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pipe
r_int
id|pipe
c_func
(paren
r_int
id|filedes
(braket
l_int|2
)braket
)paren
(brace
id|HANDLE
id|h
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* this creates non-inheritable handles */
r_if
c_cond
(paren
op_logical_neg
id|CreatePipe
c_func
(paren
op_amp
id|h
(braket
l_int|0
)braket
comma
op_amp
id|h
(braket
l_int|1
)braket
comma
l_int|NULL
comma
l_int|8192
)paren
)paren
(brace
id|errno
op_assign
id|err_win_to_posix
c_func
(paren
id|GetLastError
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|filedes
(braket
l_int|0
)braket
op_assign
id|_open_osfhandle
c_func
(paren
(paren
r_int
)paren
id|h
(braket
l_int|0
)braket
comma
id|O_NOINHERIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|filedes
(braket
l_int|0
)braket
OL
l_int|0
)paren
(brace
id|CloseHandle
c_func
(paren
id|h
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|CloseHandle
c_func
(paren
id|h
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|filedes
(braket
l_int|1
)braket
op_assign
id|_open_osfhandle
c_func
(paren
(paren
r_int
)paren
id|h
(braket
l_int|1
)braket
comma
id|O_NOINHERIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|filedes
(braket
l_int|0
)braket
OL
l_int|0
)paren
(brace
id|close
c_func
(paren
id|filedes
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|CloseHandle
c_func
(paren
id|h
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|gmtime_r
r_struct
id|tm
op_star
id|gmtime_r
c_func
(paren
r_const
id|time_t
op_star
id|timep
comma
r_struct
id|tm
op_star
id|result
)paren
(brace
multiline_comment|/* gmtime() in MSVCRT.DLL is thread-safe, but not reentrant */
id|memcpy
c_func
(paren
id|result
comma
id|gmtime
c_func
(paren
id|timep
)paren
comma
r_sizeof
(paren
r_struct
id|tm
)paren
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|localtime_r
r_struct
id|tm
op_star
id|localtime_r
c_func
(paren
r_const
id|time_t
op_star
id|timep
comma
r_struct
id|tm
op_star
id|result
)paren
(brace
multiline_comment|/* localtime() in MSVCRT.DLL is thread-safe, but not reentrant */
id|memcpy
c_func
(paren
id|result
comma
id|localtime
c_func
(paren
id|timep
)paren
comma
r_sizeof
(paren
r_struct
id|tm
)paren
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|macro|getcwd
macro_line|#undef getcwd
DECL|function|mingw_getcwd
r_char
op_star
id|mingw_getcwd
c_func
(paren
r_char
op_star
id|pointer
comma
r_int
id|len
)paren
(brace
r_int
id|i
suffix:semicolon
r_char
op_star
id|ret
op_assign
id|getcwd
c_func
(paren
id|pointer
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
r_return
id|ret
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|pointer
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|pointer
(braket
id|i
)braket
op_eq
l_char|&squot;&bslash;&bslash;&squot;
)paren
id|pointer
(braket
id|i
)braket
op_assign
l_char|&squot;/&squot;
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * See http://msdn2.microsoft.com/en-us/library/17w5ykft(vs.71).aspx&n; * (Parsing C++ Command-Line Arguments)&n; */
DECL|function|quote_arg
r_static
r_const
r_char
op_star
id|quote_arg
c_func
(paren
r_const
r_char
op_star
id|arg
)paren
(brace
multiline_comment|/* count chars to quote */
r_int
id|len
op_assign
l_int|0
comma
id|n
op_assign
l_int|0
suffix:semicolon
r_int
id|force_quotes
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|q
comma
op_star
id|d
suffix:semicolon
r_const
r_char
op_star
id|p
op_assign
id|arg
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|p
)paren
id|force_quotes
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
op_star
id|p
)paren
(brace
r_if
c_cond
(paren
id|isspace
c_func
(paren
op_star
id|p
)paren
op_logical_or
op_star
id|p
op_eq
l_char|&squot;*&squot;
op_logical_or
op_star
id|p
op_eq
l_char|&squot;?&squot;
op_logical_or
op_star
id|p
op_eq
l_char|&squot;{&squot;
op_logical_or
op_star
id|p
op_eq
l_char|&squot;&bslash;&squot;&squot;
)paren
id|force_quotes
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
op_star
id|p
op_eq
l_char|&squot;&quot;&squot;
)paren
id|n
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
op_star
id|p
op_eq
l_char|&squot;&bslash;&bslash;&squot;
)paren
(brace
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_star
id|p
op_eq
l_char|&squot;&bslash;&bslash;&squot;
)paren
(brace
id|count
op_increment
suffix:semicolon
id|p
op_increment
suffix:semicolon
id|len
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|p
op_eq
l_char|&squot;&quot;&squot;
)paren
id|n
op_add_assign
id|count
op_star
l_int|2
op_plus
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|len
op_increment
suffix:semicolon
id|p
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|force_quotes
op_logical_and
id|n
op_eq
l_int|0
)paren
r_return
id|arg
suffix:semicolon
multiline_comment|/* insert &bslash; where necessary */
id|d
op_assign
id|q
op_assign
id|xmalloc
c_func
(paren
id|len
op_plus
id|n
op_plus
l_int|3
)paren
suffix:semicolon
op_star
id|d
op_increment
op_assign
l_char|&squot;&quot;&squot;
suffix:semicolon
r_while
c_loop
(paren
op_star
id|arg
)paren
(brace
r_if
c_cond
(paren
op_star
id|arg
op_eq
l_char|&squot;&quot;&squot;
)paren
op_star
id|d
op_increment
op_assign
l_char|&squot;&bslash;&bslash;&squot;
suffix:semicolon
r_else
r_if
c_cond
(paren
op_star
id|arg
op_eq
l_char|&squot;&bslash;&bslash;&squot;
)paren
(brace
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_star
id|arg
op_eq
l_char|&squot;&bslash;&bslash;&squot;
)paren
(brace
id|count
op_increment
suffix:semicolon
op_star
id|d
op_increment
op_assign
op_star
id|arg
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|arg
op_eq
l_char|&squot;&quot;&squot;
)paren
(brace
r_while
c_loop
(paren
id|count
op_decrement
OG
l_int|0
)paren
op_star
id|d
op_increment
op_assign
l_char|&squot;&bslash;&bslash;&squot;
suffix:semicolon
op_star
id|d
op_increment
op_assign
l_char|&squot;&bslash;&bslash;&squot;
suffix:semicolon
)brace
)brace
op_star
id|d
op_increment
op_assign
op_star
id|arg
op_increment
suffix:semicolon
)brace
op_star
id|d
op_increment
op_assign
l_char|&squot;&quot;&squot;
suffix:semicolon
op_star
id|d
op_increment
op_assign
l_int|0
suffix:semicolon
r_return
id|q
suffix:semicolon
)brace
DECL|function|parse_interpreter
r_static
r_const
r_char
op_star
id|parse_interpreter
c_func
(paren
r_const
r_char
op_star
id|cmd
)paren
(brace
r_static
r_char
id|buf
(braket
l_int|100
)braket
suffix:semicolon
r_char
op_star
id|p
comma
op_star
id|opt
suffix:semicolon
r_int
id|n
comma
id|fd
suffix:semicolon
multiline_comment|/* don&squot;t even try a .exe */
id|n
op_assign
id|strlen
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
op_ge
l_int|4
op_logical_and
op_logical_neg
id|strcasecmp
c_func
(paren
id|cmd
op_plus
id|n
op_minus
l_int|4
comma
l_string|&quot;.exe&quot;
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|fd
op_assign
id|open
c_func
(paren
id|cmd
comma
id|O_RDONLY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
id|n
op_assign
id|read
c_func
(paren
id|fd
comma
id|buf
comma
r_sizeof
(paren
id|buf
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
OL
l_int|4
)paren
multiline_comment|/* at least &squot;#!/x&squot; and not error */
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|buf
(braket
l_int|0
)braket
op_ne
l_char|&squot;#&squot;
op_logical_or
id|buf
(braket
l_int|1
)braket
op_ne
l_char|&squot;!&squot;
)paren
r_return
l_int|NULL
suffix:semicolon
id|buf
(braket
id|n
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|p
op_assign
id|buf
op_plus
id|strcspn
c_func
(paren
id|buf
comma
l_string|&quot;&bslash;r&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|p
)paren
r_return
l_int|NULL
suffix:semicolon
op_star
id|p
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|p
op_assign
id|strrchr
c_func
(paren
id|buf
op_plus
l_int|2
comma
l_char|&squot;/&squot;
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|p
op_assign
id|strrchr
c_func
(paren
id|buf
op_plus
l_int|2
comma
l_char|&squot;&bslash;&bslash;&squot;
)paren
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* strip options */
r_if
c_cond
(paren
(paren
id|opt
op_assign
id|strchr
c_func
(paren
id|p
op_plus
l_int|1
comma
l_char|&squot; &squot;
)paren
)paren
)paren
op_star
id|opt
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_return
id|p
op_plus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Splits the PATH into parts.&n; */
DECL|function|get_path_split
r_static
r_char
op_star
op_star
id|get_path_split
c_func
(paren
r_void
)paren
(brace
r_char
op_star
id|p
comma
op_star
op_star
id|path
comma
op_star
id|envpath
op_assign
id|mingw_getenv
c_func
(paren
l_string|&quot;PATH&quot;
)paren
suffix:semicolon
r_int
id|i
comma
id|n
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|envpath
op_logical_or
op_logical_neg
op_star
id|envpath
)paren
r_return
l_int|NULL
suffix:semicolon
id|envpath
op_assign
id|xstrdup
c_func
(paren
id|envpath
)paren
suffix:semicolon
id|p
op_assign
id|envpath
suffix:semicolon
r_while
c_loop
(paren
id|p
)paren
(brace
r_char
op_star
id|dir
op_assign
id|p
suffix:semicolon
id|p
op_assign
id|strchr
c_func
(paren
id|p
comma
l_char|&squot;;&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
op_star
id|p
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
op_star
id|dir
)paren
(brace
multiline_comment|/* not earlier, catches series of ; */
op_increment
id|n
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|n
)paren
r_return
l_int|NULL
suffix:semicolon
id|path
op_assign
id|xmalloc
c_func
(paren
(paren
id|n
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
r_char
op_star
)paren
)paren
suffix:semicolon
id|p
op_assign
id|envpath
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_star
id|p
)paren
id|path
(braket
id|i
op_increment
)braket
op_assign
id|xstrdup
c_func
(paren
id|p
)paren
suffix:semicolon
id|p
op_assign
id|p
op_plus
id|strlen
c_func
(paren
id|p
)paren
op_plus
l_int|1
suffix:semicolon
)brace
r_while
c_loop
(paren
id|i
OL
id|n
)paren
suffix:semicolon
id|path
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|free
c_func
(paren
id|envpath
)paren
suffix:semicolon
r_return
id|path
suffix:semicolon
)brace
DECL|function|free_path_split
r_static
r_void
id|free_path_split
c_func
(paren
r_char
op_star
op_star
id|path
)paren
(brace
r_char
op_star
op_star
id|p
op_assign
id|path
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|path
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
op_star
id|p
)paren
id|free
c_func
(paren
op_star
id|p
op_increment
)paren
suffix:semicolon
id|free
c_func
(paren
id|path
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * exe_only means that we only want to detect .exe files, but not scripts&n; * (which do not have an extension)&n; */
DECL|function|lookup_prog
r_static
r_char
op_star
id|lookup_prog
c_func
(paren
r_const
r_char
op_star
id|dir
comma
r_const
r_char
op_star
id|cmd
comma
r_int
id|isexe
comma
r_int
id|exe_only
)paren
(brace
r_char
id|path
(braket
id|MAX_PATH
)braket
suffix:semicolon
id|snprintf
c_func
(paren
id|path
comma
r_sizeof
(paren
id|path
)paren
comma
l_string|&quot;%s/%s.exe&quot;
comma
id|dir
comma
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|isexe
op_logical_and
id|access
c_func
(paren
id|path
comma
id|F_OK
)paren
op_eq
l_int|0
)paren
r_return
id|xstrdup
c_func
(paren
id|path
)paren
suffix:semicolon
id|path
(braket
id|strlen
c_func
(paren
id|path
)paren
op_minus
l_int|4
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|exe_only
op_logical_or
id|isexe
)paren
op_logical_and
id|access
c_func
(paren
id|path
comma
id|F_OK
)paren
op_eq
l_int|0
)paren
r_if
c_cond
(paren
op_logical_neg
(paren
id|GetFileAttributes
c_func
(paren
id|path
)paren
op_amp
id|FILE_ATTRIBUTE_DIRECTORY
)paren
)paren
r_return
id|xstrdup
c_func
(paren
id|path
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Determines the absolute path of cmd using the split path in path.&n; * If cmd contains a slash or backslash, no lookup is performed.&n; */
DECL|function|path_lookup
r_static
r_char
op_star
id|path_lookup
c_func
(paren
r_const
r_char
op_star
id|cmd
comma
r_char
op_star
op_star
id|path
comma
r_int
id|exe_only
)paren
(brace
r_char
op_star
id|prog
op_assign
l_int|NULL
suffix:semicolon
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_int
id|isexe
op_assign
id|len
op_ge
l_int|4
op_logical_and
op_logical_neg
id|strcasecmp
c_func
(paren
id|cmd
op_plus
id|len
op_minus
l_int|4
comma
l_string|&quot;.exe&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strchr
c_func
(paren
id|cmd
comma
l_char|&squot;/&squot;
)paren
op_logical_or
id|strchr
c_func
(paren
id|cmd
comma
l_char|&squot;&bslash;&bslash;&squot;
)paren
)paren
id|prog
op_assign
id|xstrdup
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|prog
op_logical_and
op_star
id|path
)paren
id|prog
op_assign
id|lookup_prog
c_func
(paren
op_star
id|path
op_increment
comma
id|cmd
comma
id|isexe
comma
id|exe_only
)paren
suffix:semicolon
r_return
id|prog
suffix:semicolon
)brace
DECL|function|env_compare
r_static
r_int
id|env_compare
c_func
(paren
r_const
r_void
op_star
id|a
comma
r_const
r_void
op_star
id|b
)paren
(brace
r_char
op_star
r_const
op_star
id|ea
op_assign
id|a
suffix:semicolon
r_char
op_star
r_const
op_star
id|eb
op_assign
id|b
suffix:semicolon
r_return
id|strcasecmp
c_func
(paren
op_star
id|ea
comma
op_star
id|eb
)paren
suffix:semicolon
)brace
DECL|struct|pinfo_t
r_struct
id|pinfo_t
(brace
DECL|member|next
r_struct
id|pinfo_t
op_star
id|next
suffix:semicolon
DECL|member|pid
id|pid_t
id|pid
suffix:semicolon
DECL|member|proc
id|HANDLE
id|proc
suffix:semicolon
DECL|variable|pinfo_t
)brace
id|pinfo_t
suffix:semicolon
DECL|variable|pinfo
r_struct
id|pinfo_t
op_star
id|pinfo
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|pinfo_cs
id|CRITICAL_SECTION
id|pinfo_cs
suffix:semicolon
DECL|function|mingw_spawnve_fd
r_static
id|pid_t
id|mingw_spawnve_fd
c_func
(paren
r_const
r_char
op_star
id|cmd
comma
r_const
r_char
op_star
op_star
id|argv
comma
r_char
op_star
op_star
id|env
comma
r_const
r_char
op_star
id|dir
comma
r_int
id|prepend_cmd
comma
r_int
id|fhin
comma
r_int
id|fhout
comma
r_int
id|fherr
)paren
(brace
id|STARTUPINFO
id|si
suffix:semicolon
id|PROCESS_INFORMATION
id|pi
suffix:semicolon
r_struct
id|strbuf
id|envblk
comma
id|args
suffix:semicolon
r_int
id|flags
suffix:semicolon
id|BOOL
id|ret
suffix:semicolon
multiline_comment|/* Determine whether or not we are associated to a console */
id|HANDLE
id|cons
op_assign
id|CreateFile
c_func
(paren
l_string|&quot;CONOUT$&quot;
comma
id|GENERIC_WRITE
comma
id|FILE_SHARE_WRITE
comma
l_int|NULL
comma
id|OPEN_EXISTING
comma
id|FILE_ATTRIBUTE_NORMAL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cons
op_eq
id|INVALID_HANDLE_VALUE
)paren
(brace
multiline_comment|/* There is no console associated with this process.&n;&t;&t; * Since the child is a console process, Windows&n;&t;&t; * would normally create a console window. But&n;&t;&t; * since we&squot;ll be redirecting std streams, we do&n;&t;&t; * not need the console.&n;&t;&t; * It is necessary to use DETACHED_PROCESS&n;&t;&t; * instead of CREATE_NO_WINDOW to make ssh&n;&t;&t; * recognize that it has no console.&n;&t;&t; */
id|flags
op_assign
id|DETACHED_PROCESS
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* There is already a console. If we specified&n;&t;&t; * DETACHED_PROCESS here, too, Windows would&n;&t;&t; * disassociate the child from the console.&n;&t;&t; * The same is true for CREATE_NO_WINDOW.&n;&t;&t; * Go figure!&n;&t;&t; */
id|flags
op_assign
l_int|0
suffix:semicolon
id|CloseHandle
c_func
(paren
id|cons
)paren
suffix:semicolon
)brace
id|memset
c_func
(paren
op_amp
id|si
comma
l_int|0
comma
r_sizeof
(paren
id|si
)paren
)paren
suffix:semicolon
id|si.cb
op_assign
r_sizeof
(paren
id|si
)paren
suffix:semicolon
id|si.dwFlags
op_assign
id|STARTF_USESTDHANDLES
suffix:semicolon
id|si.hStdInput
op_assign
(paren
id|HANDLE
)paren
id|_get_osfhandle
c_func
(paren
id|fhin
)paren
suffix:semicolon
id|si.hStdOutput
op_assign
(paren
id|HANDLE
)paren
id|_get_osfhandle
c_func
(paren
id|fhout
)paren
suffix:semicolon
id|si.hStdError
op_assign
(paren
id|HANDLE
)paren
id|_get_osfhandle
c_func
(paren
id|fherr
)paren
suffix:semicolon
multiline_comment|/* concatenate argv, quoting args as we go */
id|strbuf_init
c_func
(paren
op_amp
id|args
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prepend_cmd
)paren
(brace
r_char
op_star
id|quoted
op_assign
(paren
r_char
op_star
)paren
id|quote_arg
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|args
comma
id|quoted
)paren
suffix:semicolon
r_if
c_cond
(paren
id|quoted
op_ne
id|cmd
)paren
id|free
c_func
(paren
id|quoted
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
op_star
id|argv
suffix:semicolon
id|argv
op_increment
)paren
(brace
r_char
op_star
id|quoted
op_assign
(paren
r_char
op_star
)paren
id|quote_arg
c_func
(paren
op_star
id|argv
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|args.buf
)paren
id|strbuf_addch
c_func
(paren
op_amp
id|args
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|args
comma
id|quoted
)paren
suffix:semicolon
r_if
c_cond
(paren
id|quoted
op_ne
op_star
id|argv
)paren
id|free
c_func
(paren
id|quoted
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|env
)paren
(brace
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_char
op_star
op_star
id|e
comma
op_star
op_star
id|sorted_env
suffix:semicolon
r_for
c_loop
(paren
id|e
op_assign
id|env
suffix:semicolon
op_star
id|e
suffix:semicolon
id|e
op_increment
)paren
id|count
op_increment
suffix:semicolon
multiline_comment|/* environment must be sorted */
id|sorted_env
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|sorted_env
)paren
op_star
(paren
id|count
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|sorted_env
comma
id|env
comma
r_sizeof
(paren
op_star
id|sorted_env
)paren
op_star
(paren
id|count
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|qsort
c_func
(paren
id|sorted_env
comma
id|count
comma
r_sizeof
(paren
op_star
id|sorted_env
)paren
comma
id|env_compare
)paren
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|envblk
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|e
op_assign
id|sorted_env
suffix:semicolon
op_star
id|e
suffix:semicolon
id|e
op_increment
)paren
(brace
id|strbuf_addstr
c_func
(paren
op_amp
id|envblk
comma
op_star
id|e
)paren
suffix:semicolon
id|strbuf_addch
c_func
(paren
op_amp
id|envblk
comma
l_char|&squot;&bslash;0&squot;
)paren
suffix:semicolon
)brace
id|free
c_func
(paren
id|sorted_env
)paren
suffix:semicolon
)brace
id|memset
c_func
(paren
op_amp
id|pi
comma
l_int|0
comma
r_sizeof
(paren
id|pi
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|CreateProcess
c_func
(paren
id|cmd
comma
id|args.buf
comma
l_int|NULL
comma
l_int|NULL
comma
id|TRUE
comma
id|flags
comma
id|env
ques
c_cond
id|envblk.buf
suffix:colon
l_int|NULL
comma
id|dir
comma
op_amp
id|si
comma
op_amp
id|pi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|env
)paren
id|strbuf_release
c_func
(paren
op_amp
id|envblk
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
id|errno
op_assign
id|ENOENT
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|CloseHandle
c_func
(paren
id|pi.hThread
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The process ID is the human-readable identifier of the process&n;&t; * that we want to present in log and error messages. The handle&n;&t; * is not useful for this purpose. But we cannot close it, either,&n;&t; * because it is not possible to turn a process ID into a process&n;&t; * handle after the process terminated.&n;&t; * Keep the handle in a list for waitpid.&n;&t; */
id|EnterCriticalSection
c_func
(paren
op_amp
id|pinfo_cs
)paren
suffix:semicolon
(brace
r_struct
id|pinfo_t
op_star
id|info
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pinfo_t
)paren
)paren
suffix:semicolon
id|info-&gt;pid
op_assign
id|pi.dwProcessId
suffix:semicolon
id|info-&gt;proc
op_assign
id|pi.hProcess
suffix:semicolon
id|info-&gt;next
op_assign
id|pinfo
suffix:semicolon
id|pinfo
op_assign
id|info
suffix:semicolon
)brace
id|LeaveCriticalSection
c_func
(paren
op_amp
id|pinfo_cs
)paren
suffix:semicolon
r_return
(paren
id|pid_t
)paren
id|pi.dwProcessId
suffix:semicolon
)brace
DECL|function|mingw_spawnve
r_static
id|pid_t
id|mingw_spawnve
c_func
(paren
r_const
r_char
op_star
id|cmd
comma
r_const
r_char
op_star
op_star
id|argv
comma
r_char
op_star
op_star
id|env
comma
r_int
id|prepend_cmd
)paren
(brace
r_return
id|mingw_spawnve_fd
c_func
(paren
id|cmd
comma
id|argv
comma
id|env
comma
l_int|NULL
comma
id|prepend_cmd
comma
l_int|0
comma
l_int|1
comma
l_int|2
)paren
suffix:semicolon
)brace
DECL|function|mingw_spawnvpe
id|pid_t
id|mingw_spawnvpe
c_func
(paren
r_const
r_char
op_star
id|cmd
comma
r_const
r_char
op_star
op_star
id|argv
comma
r_char
op_star
op_star
id|env
comma
r_const
r_char
op_star
id|dir
comma
r_int
id|fhin
comma
r_int
id|fhout
comma
r_int
id|fherr
)paren
(brace
id|pid_t
id|pid
suffix:semicolon
r_char
op_star
op_star
id|path
op_assign
id|get_path_split
c_func
(paren
)paren
suffix:semicolon
r_char
op_star
id|prog
op_assign
id|path_lookup
c_func
(paren
id|cmd
comma
id|path
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prog
)paren
(brace
id|errno
op_assign
id|ENOENT
suffix:semicolon
id|pid
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_const
r_char
op_star
id|interpr
op_assign
id|parse_interpreter
c_func
(paren
id|prog
)paren
suffix:semicolon
r_if
c_cond
(paren
id|interpr
)paren
(brace
r_const
r_char
op_star
id|argv0
op_assign
id|argv
(braket
l_int|0
)braket
suffix:semicolon
r_char
op_star
id|iprog
op_assign
id|path_lookup
c_func
(paren
id|interpr
comma
id|path
comma
l_int|1
)paren
suffix:semicolon
id|argv
(braket
l_int|0
)braket
op_assign
id|prog
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|iprog
)paren
(brace
id|errno
op_assign
id|ENOENT
suffix:semicolon
id|pid
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|pid
op_assign
id|mingw_spawnve_fd
c_func
(paren
id|iprog
comma
id|argv
comma
id|env
comma
id|dir
comma
l_int|1
comma
id|fhin
comma
id|fhout
comma
id|fherr
)paren
suffix:semicolon
id|free
c_func
(paren
id|iprog
)paren
suffix:semicolon
)brace
id|argv
(braket
l_int|0
)braket
op_assign
id|argv0
suffix:semicolon
)brace
r_else
id|pid
op_assign
id|mingw_spawnve_fd
c_func
(paren
id|prog
comma
id|argv
comma
id|env
comma
id|dir
comma
l_int|0
comma
id|fhin
comma
id|fhout
comma
id|fherr
)paren
suffix:semicolon
id|free
c_func
(paren
id|prog
)paren
suffix:semicolon
)brace
id|free_path_split
c_func
(paren
id|path
)paren
suffix:semicolon
r_return
id|pid
suffix:semicolon
)brace
DECL|function|try_shell_exec
r_static
r_int
id|try_shell_exec
c_func
(paren
r_const
r_char
op_star
id|cmd
comma
r_char
op_star
r_const
op_star
id|argv
comma
r_char
op_star
op_star
id|env
)paren
(brace
r_const
r_char
op_star
id|interpr
op_assign
id|parse_interpreter
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_char
op_star
op_star
id|path
suffix:semicolon
r_char
op_star
id|prog
suffix:semicolon
r_int
id|pid
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|interpr
)paren
r_return
l_int|0
suffix:semicolon
id|path
op_assign
id|get_path_split
c_func
(paren
)paren
suffix:semicolon
id|prog
op_assign
id|path_lookup
c_func
(paren
id|interpr
comma
id|path
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prog
)paren
(brace
r_int
id|argc
op_assign
l_int|0
suffix:semicolon
r_const
r_char
op_star
op_star
id|argv2
suffix:semicolon
r_while
c_loop
(paren
id|argv
(braket
id|argc
)braket
)paren
id|argc
op_increment
suffix:semicolon
id|argv2
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|argv
)paren
op_star
(paren
id|argc
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|argv2
(braket
l_int|0
)braket
op_assign
(paren
r_char
op_star
)paren
id|cmd
suffix:semicolon
multiline_comment|/* full path to the script file */
id|memcpy
c_func
(paren
op_amp
id|argv2
(braket
l_int|1
)braket
comma
op_amp
id|argv
(braket
l_int|1
)braket
comma
r_sizeof
(paren
op_star
id|argv
)paren
op_star
id|argc
)paren
suffix:semicolon
id|pid
op_assign
id|mingw_spawnve
c_func
(paren
id|prog
comma
id|argv2
comma
id|env
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pid
op_ge
l_int|0
)paren
(brace
r_int
id|status
suffix:semicolon
r_if
c_cond
(paren
id|waitpid
c_func
(paren
id|pid
comma
op_amp
id|status
comma
l_int|0
)paren
OL
l_int|0
)paren
id|status
op_assign
l_int|255
suffix:semicolon
m_exit
(paren
id|status
)paren
suffix:semicolon
)brace
id|pid
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* indicate that we tried but failed */
id|free
c_func
(paren
id|prog
)paren
suffix:semicolon
id|free
c_func
(paren
id|argv2
)paren
suffix:semicolon
)brace
id|free_path_split
c_func
(paren
id|path
)paren
suffix:semicolon
r_return
id|pid
suffix:semicolon
)brace
DECL|function|mingw_execve
r_static
r_void
id|mingw_execve
c_func
(paren
r_const
r_char
op_star
id|cmd
comma
r_char
op_star
r_const
op_star
id|argv
comma
r_char
op_star
r_const
op_star
id|env
)paren
(brace
multiline_comment|/* check if git_command is a shell script */
r_if
c_cond
(paren
op_logical_neg
id|try_shell_exec
c_func
(paren
id|cmd
comma
id|argv
comma
(paren
r_char
op_star
op_star
)paren
id|env
)paren
)paren
(brace
r_int
id|pid
comma
id|status
suffix:semicolon
id|pid
op_assign
id|mingw_spawnve
c_func
(paren
id|cmd
comma
(paren
r_const
r_char
op_star
op_star
)paren
id|argv
comma
(paren
r_char
op_star
op_star
)paren
id|env
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pid
OL
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|waitpid
c_func
(paren
id|pid
comma
op_amp
id|status
comma
l_int|0
)paren
OL
l_int|0
)paren
id|status
op_assign
l_int|255
suffix:semicolon
m_exit
(paren
id|status
)paren
suffix:semicolon
)brace
)brace
DECL|function|mingw_execvp
r_void
id|mingw_execvp
c_func
(paren
r_const
r_char
op_star
id|cmd
comma
r_char
op_star
r_const
op_star
id|argv
)paren
(brace
r_char
op_star
op_star
id|path
op_assign
id|get_path_split
c_func
(paren
)paren
suffix:semicolon
r_char
op_star
id|prog
op_assign
id|path_lookup
c_func
(paren
id|cmd
comma
id|path
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prog
)paren
(brace
id|mingw_execve
c_func
(paren
id|prog
comma
id|argv
comma
id|environ
)paren
suffix:semicolon
id|free
c_func
(paren
id|prog
)paren
suffix:semicolon
)brace
r_else
id|errno
op_assign
id|ENOENT
suffix:semicolon
id|free_path_split
c_func
(paren
id|path
)paren
suffix:semicolon
)brace
DECL|function|mingw_execv
r_void
id|mingw_execv
c_func
(paren
r_const
r_char
op_star
id|cmd
comma
r_char
op_star
r_const
op_star
id|argv
)paren
(brace
id|mingw_execve
c_func
(paren
id|cmd
comma
id|argv
comma
id|environ
)paren
suffix:semicolon
)brace
DECL|function|mingw_kill
r_int
id|mingw_kill
c_func
(paren
id|pid_t
id|pid
comma
r_int
id|sig
)paren
(brace
r_if
c_cond
(paren
id|pid
OG
l_int|0
op_logical_and
id|sig
op_eq
id|SIGTERM
)paren
(brace
id|HANDLE
id|h
op_assign
id|OpenProcess
c_func
(paren
id|PROCESS_TERMINATE
comma
id|FALSE
comma
id|pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TerminateProcess
c_func
(paren
id|h
comma
l_int|1
)paren
)paren
(brace
id|CloseHandle
c_func
(paren
id|h
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|errno
op_assign
id|err_win_to_posix
c_func
(paren
id|GetLastError
c_func
(paren
)paren
)paren
suffix:semicolon
id|CloseHandle
c_func
(paren
id|h
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|errno
op_assign
id|EINVAL
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|copy_environ
r_static
r_char
op_star
op_star
id|copy_environ
c_func
(paren
r_void
)paren
(brace
r_char
op_star
op_star
id|env
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|environ
(braket
id|i
)braket
)paren
id|i
op_increment
suffix:semicolon
id|env
op_assign
id|xmalloc
c_func
(paren
(paren
id|i
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
op_star
id|env
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|environ
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
id|env
(braket
id|i
)braket
op_assign
id|xstrdup
c_func
(paren
id|environ
(braket
id|i
)braket
)paren
suffix:semicolon
id|env
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
id|env
suffix:semicolon
)brace
DECL|function|free_environ
r_void
id|free_environ
c_func
(paren
r_char
op_star
op_star
id|env
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|env
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
id|free
c_func
(paren
id|env
(braket
id|i
)braket
)paren
suffix:semicolon
id|free
c_func
(paren
id|env
)paren
suffix:semicolon
)brace
DECL|function|lookup_env
r_static
r_int
id|lookup_env
c_func
(paren
r_char
op_star
op_star
id|env
comma
r_const
r_char
op_star
id|name
comma
r_int
id|nmln
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|env
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
l_int|0
op_eq
id|strncmp
c_func
(paren
id|env
(braket
id|i
)braket
comma
id|name
comma
id|nmln
)paren
op_logical_and
l_char|&squot;=&squot;
op_eq
id|env
(braket
id|i
)braket
(braket
id|nmln
)braket
)paren
multiline_comment|/* matches */
r_return
id|i
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * If name contains &squot;=&squot;, then sets the variable, otherwise it unsets it&n; */
DECL|function|env_setenv
r_static
r_char
op_star
op_star
id|env_setenv
c_func
(paren
r_char
op_star
op_star
id|env
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_char
op_star
id|eq
op_assign
id|strchrnul
c_func
(paren
id|name
comma
l_char|&squot;=&squot;
)paren
suffix:semicolon
r_int
id|i
op_assign
id|lookup_env
c_func
(paren
id|env
comma
id|name
comma
id|eq
op_minus
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_star
id|eq
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|env
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
suffix:semicolon
id|env
op_assign
id|xrealloc
c_func
(paren
id|env
comma
(paren
id|i
op_plus
l_int|2
)paren
op_star
r_sizeof
(paren
op_star
id|env
)paren
)paren
suffix:semicolon
id|env
(braket
id|i
)braket
op_assign
id|xstrdup
c_func
(paren
id|name
)paren
suffix:semicolon
id|env
(braket
id|i
op_plus
l_int|1
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_else
(brace
id|free
c_func
(paren
id|env
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|eq
)paren
id|env
(braket
id|i
)braket
op_assign
id|xstrdup
c_func
(paren
id|name
)paren
suffix:semicolon
r_else
r_for
c_loop
(paren
suffix:semicolon
id|env
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
id|env
(braket
id|i
)braket
op_assign
id|env
(braket
id|i
op_plus
l_int|1
)braket
suffix:semicolon
)brace
r_return
id|env
suffix:semicolon
)brace
multiline_comment|/*&n; * Copies global environ and adjusts variables as specified by vars.&n; */
DECL|function|make_augmented_environ
r_char
op_star
op_star
id|make_augmented_environ
c_func
(paren
r_const
r_char
op_star
r_const
op_star
id|vars
)paren
(brace
r_char
op_star
op_star
id|env
op_assign
id|copy_environ
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
op_star
id|vars
)paren
id|env
op_assign
id|env_setenv
c_func
(paren
id|env
comma
op_star
id|vars
op_increment
)paren
suffix:semicolon
r_return
id|env
suffix:semicolon
)brace
DECL|macro|getenv
macro_line|#undef getenv
multiline_comment|/*&n; * The system&squot;s getenv looks up the name in a case-insensitive manner.&n; * This version tries a case-sensitive lookup and falls back to&n; * case-insensitive if nothing was found.  This is necessary because,&n; * as a prominent example, CMD sets &squot;Path&squot;, but not &squot;PATH&squot;.&n; * Warning: not thread-safe.&n; */
DECL|function|getenv_cs
r_static
r_char
op_star
id|getenv_cs
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
r_int
id|i
op_assign
id|lookup_env
c_func
(paren
id|environ
comma
id|name
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
l_int|0
)paren
r_return
id|environ
(braket
id|i
)braket
op_plus
id|len
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* skip past name and &squot;=&squot; */
r_return
id|getenv
c_func
(paren
id|name
)paren
suffix:semicolon
)brace
DECL|function|mingw_getenv
r_char
op_star
id|mingw_getenv
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_char
op_star
id|result
op_assign
id|getenv_cs
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;TMPDIR&quot;
)paren
)paren
(brace
multiline_comment|/* on Windows it is TMP and TEMP */
id|result
op_assign
id|getenv_cs
c_func
(paren
l_string|&quot;TMP&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result
)paren
id|result
op_assign
id|getenv_cs
c_func
(paren
l_string|&quot;TEMP&quot;
)paren
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * Note, this isn&squot;t a complete replacement for getaddrinfo. It assumes&n; * that service contains a numerical port, or that it is null. It&n; * does a simple search using gethostbyname, and returns one IPv4 host&n; * if one was found.&n; */
DECL|function|getaddrinfo_stub
r_static
r_int
id|WSAAPI
id|getaddrinfo_stub
c_func
(paren
r_const
r_char
op_star
id|node
comma
r_const
r_char
op_star
id|service
comma
r_const
r_struct
id|addrinfo
op_star
id|hints
comma
r_struct
id|addrinfo
op_star
op_star
id|res
)paren
(brace
r_struct
id|hostent
op_star
id|h
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|addrinfo
op_star
id|ai
suffix:semicolon
r_struct
id|sockaddr_in
op_star
id|sin
suffix:semicolon
r_if
c_cond
(paren
id|node
)paren
(brace
id|h
op_assign
id|gethostbyname
c_func
(paren
id|node
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|h
)paren
r_return
id|WSAGetLastError
c_func
(paren
)paren
suffix:semicolon
)brace
id|ai
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|addrinfo
)paren
)paren
suffix:semicolon
op_star
id|res
op_assign
id|ai
suffix:semicolon
id|ai-&gt;ai_flags
op_assign
l_int|0
suffix:semicolon
id|ai-&gt;ai_family
op_assign
id|AF_INET
suffix:semicolon
id|ai-&gt;ai_socktype
op_assign
id|hints
ques
c_cond
id|hints-&gt;ai_socktype
suffix:colon
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|ai-&gt;ai_socktype
)paren
(brace
r_case
id|SOCK_STREAM
suffix:colon
id|ai-&gt;ai_protocol
op_assign
id|IPPROTO_TCP
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOCK_DGRAM
suffix:colon
id|ai-&gt;ai_protocol
op_assign
id|IPPROTO_UDP
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ai-&gt;ai_protocol
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ai-&gt;ai_addrlen
op_assign
r_sizeof
(paren
r_struct
id|sockaddr_in
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hints
op_logical_and
(paren
id|hints-&gt;ai_flags
op_amp
id|AI_CANONNAME
)paren
)paren
id|ai-&gt;ai_canonname
op_assign
id|h
ques
c_cond
id|strdup
c_func
(paren
id|h-&gt;h_name
)paren
suffix:colon
l_int|NULL
suffix:semicolon
r_else
id|ai-&gt;ai_canonname
op_assign
l_int|NULL
suffix:semicolon
id|sin
op_assign
id|xmalloc
c_func
(paren
id|ai-&gt;ai_addrlen
)paren
suffix:semicolon
id|memset
c_func
(paren
id|sin
comma
l_int|0
comma
id|ai-&gt;ai_addrlen
)paren
suffix:semicolon
id|sin-&gt;sin_family
op_assign
id|AF_INET
suffix:semicolon
multiline_comment|/* Note: getaddrinfo is supposed to allow service to be a string,&n;&t; * which should be looked up using getservbyname. This is&n;&t; * currently not implemented */
r_if
c_cond
(paren
id|service
)paren
id|sin-&gt;sin_port
op_assign
id|htons
c_func
(paren
id|atoi
c_func
(paren
id|service
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|h
)paren
id|sin-&gt;sin_addr
op_assign
op_star
(paren
r_struct
id|in_addr
op_star
)paren
id|h-&gt;h_addr
suffix:semicolon
r_else
r_if
c_cond
(paren
id|hints
op_logical_and
(paren
id|hints-&gt;ai_flags
op_amp
id|AI_PASSIVE
)paren
)paren
id|sin-&gt;sin_addr.s_addr
op_assign
id|INADDR_ANY
suffix:semicolon
r_else
id|sin-&gt;sin_addr.s_addr
op_assign
id|INADDR_LOOPBACK
suffix:semicolon
id|ai-&gt;ai_addr
op_assign
(paren
r_struct
id|sockaddr
op_star
)paren
id|sin
suffix:semicolon
id|ai-&gt;ai_next
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|freeaddrinfo_stub
r_static
r_void
id|WSAAPI
id|freeaddrinfo_stub
c_func
(paren
r_struct
id|addrinfo
op_star
id|res
)paren
(brace
id|free
c_func
(paren
id|res-&gt;ai_canonname
)paren
suffix:semicolon
id|free
c_func
(paren
id|res-&gt;ai_addr
)paren
suffix:semicolon
id|free
c_func
(paren
id|res
)paren
suffix:semicolon
)brace
DECL|function|getnameinfo_stub
r_static
r_int
id|WSAAPI
id|getnameinfo_stub
c_func
(paren
r_const
r_struct
id|sockaddr
op_star
id|sa
comma
id|socklen_t
id|salen
comma
r_char
op_star
id|host
comma
id|DWORD
id|hostlen
comma
r_char
op_star
id|serv
comma
id|DWORD
id|servlen
comma
r_int
id|flags
)paren
(brace
r_const
r_struct
id|sockaddr_in
op_star
id|sin
op_assign
(paren
r_const
r_struct
id|sockaddr_in
op_star
)paren
id|sa
suffix:semicolon
r_if
c_cond
(paren
id|sa-&gt;sa_family
op_ne
id|AF_INET
)paren
r_return
id|EAI_FAMILY
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|host
op_logical_and
op_logical_neg
id|serv
)paren
r_return
id|EAI_NONAME
suffix:semicolon
r_if
c_cond
(paren
id|host
op_logical_and
id|hostlen
OG
l_int|0
)paren
(brace
r_struct
id|hostent
op_star
id|ent
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|NI_NUMERICHOST
)paren
)paren
id|ent
op_assign
id|gethostbyaddr
c_func
(paren
(paren
r_const
r_char
op_star
)paren
op_amp
id|sin-&gt;sin_addr
comma
r_sizeof
(paren
id|sin-&gt;sin_addr
)paren
comma
id|AF_INET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ent
)paren
id|snprintf
c_func
(paren
id|host
comma
id|hostlen
comma
l_string|&quot;%s&quot;
comma
id|ent-&gt;h_name
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|flags
op_amp
id|NI_NAMEREQD
)paren
r_return
id|EAI_NONAME
suffix:semicolon
r_else
id|snprintf
c_func
(paren
id|host
comma
id|hostlen
comma
l_string|&quot;%s&quot;
comma
id|inet_ntoa
c_func
(paren
id|sin-&gt;sin_addr
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|serv
op_logical_and
id|servlen
OG
l_int|0
)paren
(brace
r_struct
id|servent
op_star
id|ent
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|NI_NUMERICSERV
)paren
)paren
id|ent
op_assign
id|getservbyport
c_func
(paren
id|sin-&gt;sin_port
comma
id|flags
op_amp
id|NI_DGRAM
ques
c_cond
l_string|&quot;udp&quot;
suffix:colon
l_string|&quot;tcp&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ent
)paren
id|snprintf
c_func
(paren
id|serv
comma
id|servlen
comma
l_string|&quot;%s&quot;
comma
id|ent-&gt;s_name
)paren
suffix:semicolon
r_else
id|snprintf
c_func
(paren
id|serv
comma
id|servlen
comma
l_string|&quot;%d&quot;
comma
id|ntohs
c_func
(paren
id|sin-&gt;sin_port
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|ipv6_dll
r_static
id|HMODULE
id|ipv6_dll
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|ipv6_freeaddrinfo
r_static
r_void
(paren
id|WSAAPI
op_star
id|ipv6_freeaddrinfo
)paren
(paren
r_struct
id|addrinfo
op_star
id|res
)paren
suffix:semicolon
DECL|variable|ipv6_getaddrinfo
r_static
r_int
(paren
id|WSAAPI
op_star
id|ipv6_getaddrinfo
)paren
(paren
r_const
r_char
op_star
id|node
comma
r_const
r_char
op_star
id|service
comma
r_const
r_struct
id|addrinfo
op_star
id|hints
comma
r_struct
id|addrinfo
op_star
op_star
id|res
)paren
suffix:semicolon
DECL|variable|ipv6_getnameinfo
r_static
r_int
(paren
id|WSAAPI
op_star
id|ipv6_getnameinfo
)paren
(paren
r_const
r_struct
id|sockaddr
op_star
id|sa
comma
id|socklen_t
id|salen
comma
r_char
op_star
id|host
comma
id|DWORD
id|hostlen
comma
r_char
op_star
id|serv
comma
id|DWORD
id|servlen
comma
r_int
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n; * gai_strerror is an inline function in the ws2tcpip.h header, so we&n; * don&squot;t need to try to load that one dynamically.&n; */
DECL|function|socket_cleanup
r_static
r_void
id|socket_cleanup
c_func
(paren
r_void
)paren
(brace
id|WSACleanup
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ipv6_dll
)paren
id|FreeLibrary
c_func
(paren
id|ipv6_dll
)paren
suffix:semicolon
id|ipv6_dll
op_assign
l_int|NULL
suffix:semicolon
id|ipv6_freeaddrinfo
op_assign
id|freeaddrinfo_stub
suffix:semicolon
id|ipv6_getaddrinfo
op_assign
id|getaddrinfo_stub
suffix:semicolon
id|ipv6_getnameinfo
op_assign
id|getnameinfo_stub
suffix:semicolon
)brace
DECL|function|ensure_socket_initialization
r_static
r_void
id|ensure_socket_initialization
c_func
(paren
r_void
)paren
(brace
id|WSADATA
id|wsa
suffix:semicolon
r_static
r_int
id|initialized
op_assign
l_int|0
suffix:semicolon
r_const
r_char
op_star
id|libraries
(braket
)braket
op_assign
(brace
l_string|&quot;ws2_32.dll&quot;
comma
l_string|&quot;wship6.dll&quot;
comma
l_int|NULL
)brace
suffix:semicolon
r_const
r_char
op_star
op_star
id|name
suffix:semicolon
r_if
c_cond
(paren
id|initialized
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|WSAStartup
c_func
(paren
id|MAKEWORD
c_func
(paren
l_int|2
comma
l_int|2
)paren
comma
op_amp
id|wsa
)paren
)paren
id|die
c_func
(paren
l_string|&quot;unable to initialize winsock subsystem, error %d&quot;
comma
id|WSAGetLastError
c_func
(paren
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|name
op_assign
id|libraries
suffix:semicolon
op_star
id|name
suffix:semicolon
id|name
op_increment
)paren
(brace
id|ipv6_dll
op_assign
id|LoadLibrary
c_func
(paren
op_star
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ipv6_dll
)paren
r_continue
suffix:semicolon
id|ipv6_freeaddrinfo
op_assign
(paren
r_void
(paren
id|WSAAPI
op_star
)paren
(paren
r_struct
id|addrinfo
op_star
)paren
)paren
id|GetProcAddress
c_func
(paren
id|ipv6_dll
comma
l_string|&quot;freeaddrinfo&quot;
)paren
suffix:semicolon
id|ipv6_getaddrinfo
op_assign
(paren
r_int
(paren
id|WSAAPI
op_star
)paren
(paren
r_const
r_char
op_star
comma
r_const
r_char
op_star
comma
r_const
r_struct
id|addrinfo
op_star
comma
r_struct
id|addrinfo
op_star
op_star
)paren
)paren
id|GetProcAddress
c_func
(paren
id|ipv6_dll
comma
l_string|&quot;getaddrinfo&quot;
)paren
suffix:semicolon
id|ipv6_getnameinfo
op_assign
(paren
r_int
(paren
id|WSAAPI
op_star
)paren
(paren
r_const
r_struct
id|sockaddr
op_star
comma
id|socklen_t
comma
r_char
op_star
comma
id|DWORD
comma
r_char
op_star
comma
id|DWORD
comma
r_int
)paren
)paren
id|GetProcAddress
c_func
(paren
id|ipv6_dll
comma
l_string|&quot;getnameinfo&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ipv6_freeaddrinfo
op_logical_or
op_logical_neg
id|ipv6_getaddrinfo
op_logical_or
op_logical_neg
id|ipv6_getnameinfo
)paren
(brace
id|FreeLibrary
c_func
(paren
id|ipv6_dll
)paren
suffix:semicolon
id|ipv6_dll
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ipv6_freeaddrinfo
op_logical_or
op_logical_neg
id|ipv6_getaddrinfo
op_logical_or
op_logical_neg
id|ipv6_getnameinfo
)paren
(brace
id|ipv6_freeaddrinfo
op_assign
id|freeaddrinfo_stub
suffix:semicolon
id|ipv6_getaddrinfo
op_assign
id|getaddrinfo_stub
suffix:semicolon
id|ipv6_getnameinfo
op_assign
id|getnameinfo_stub
suffix:semicolon
)brace
id|atexit
c_func
(paren
id|socket_cleanup
)paren
suffix:semicolon
id|initialized
op_assign
l_int|1
suffix:semicolon
)brace
DECL|macro|gethostbyname
macro_line|#undef gethostbyname
DECL|function|mingw_gethostbyname
r_struct
id|hostent
op_star
id|mingw_gethostbyname
c_func
(paren
r_const
r_char
op_star
id|host
)paren
(brace
id|ensure_socket_initialization
c_func
(paren
)paren
suffix:semicolon
r_return
id|gethostbyname
c_func
(paren
id|host
)paren
suffix:semicolon
)brace
DECL|function|mingw_freeaddrinfo
r_void
id|mingw_freeaddrinfo
c_func
(paren
r_struct
id|addrinfo
op_star
id|res
)paren
(brace
id|ipv6_freeaddrinfo
c_func
(paren
id|res
)paren
suffix:semicolon
)brace
DECL|function|mingw_getaddrinfo
r_int
id|mingw_getaddrinfo
c_func
(paren
r_const
r_char
op_star
id|node
comma
r_const
r_char
op_star
id|service
comma
r_const
r_struct
id|addrinfo
op_star
id|hints
comma
r_struct
id|addrinfo
op_star
op_star
id|res
)paren
(brace
id|ensure_socket_initialization
c_func
(paren
)paren
suffix:semicolon
r_return
id|ipv6_getaddrinfo
c_func
(paren
id|node
comma
id|service
comma
id|hints
comma
id|res
)paren
suffix:semicolon
)brace
DECL|function|mingw_getnameinfo
r_int
id|mingw_getnameinfo
c_func
(paren
r_const
r_struct
id|sockaddr
op_star
id|sa
comma
id|socklen_t
id|salen
comma
r_char
op_star
id|host
comma
id|DWORD
id|hostlen
comma
r_char
op_star
id|serv
comma
id|DWORD
id|servlen
comma
r_int
id|flags
)paren
(brace
id|ensure_socket_initialization
c_func
(paren
)paren
suffix:semicolon
r_return
id|ipv6_getnameinfo
c_func
(paren
id|sa
comma
id|salen
comma
id|host
comma
id|hostlen
comma
id|serv
comma
id|servlen
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|mingw_socket
r_int
id|mingw_socket
c_func
(paren
r_int
id|domain
comma
r_int
id|type
comma
r_int
id|protocol
)paren
(brace
r_int
id|sockfd
suffix:semicolon
id|SOCKET
id|s
suffix:semicolon
id|ensure_socket_initialization
c_func
(paren
)paren
suffix:semicolon
id|s
op_assign
id|WSASocket
c_func
(paren
id|domain
comma
id|type
comma
id|protocol
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
op_eq
id|INVALID_SOCKET
)paren
(brace
multiline_comment|/*&n;&t;&t; * WSAGetLastError() values are regular BSD error codes&n;&t;&t; * biased by WSABASEERR.&n;&t;&t; * However, strerror() does not know about networking&n;&t;&t; * specific errors, which are values beginning at 38 or so.&n;&t;&t; * Therefore, we choose to leave the biased error code&n;&t;&t; * in errno so that _if_ someone looks up the code somewhere,&n;&t;&t; * then it is at least the number that are usually listed.&n;&t;&t; */
id|errno
op_assign
id|WSAGetLastError
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* convert into a file descriptor */
r_if
c_cond
(paren
(paren
id|sockfd
op_assign
id|_open_osfhandle
c_func
(paren
id|s
comma
id|O_RDWR
op_or
id|O_BINARY
)paren
)paren
OL
l_int|0
)paren
(brace
id|closesocket
c_func
(paren
id|s
)paren
suffix:semicolon
r_return
id|error
c_func
(paren
l_string|&quot;unable to make a socket file descriptor: %s&quot;
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
)brace
r_return
id|sockfd
suffix:semicolon
)brace
DECL|macro|connect
macro_line|#undef connect
DECL|function|mingw_connect
r_int
id|mingw_connect
c_func
(paren
r_int
id|sockfd
comma
r_struct
id|sockaddr
op_star
id|sa
comma
r_int
id|sz
)paren
(brace
id|SOCKET
id|s
op_assign
(paren
id|SOCKET
)paren
id|_get_osfhandle
c_func
(paren
id|sockfd
)paren
suffix:semicolon
r_return
id|connect
c_func
(paren
id|s
comma
id|sa
comma
id|sz
)paren
suffix:semicolon
)brace
DECL|macro|bind
macro_line|#undef bind
DECL|function|mingw_bind
r_int
id|mingw_bind
c_func
(paren
r_int
id|sockfd
comma
r_struct
id|sockaddr
op_star
id|sa
comma
r_int
id|sz
)paren
(brace
id|SOCKET
id|s
op_assign
(paren
id|SOCKET
)paren
id|_get_osfhandle
c_func
(paren
id|sockfd
)paren
suffix:semicolon
r_return
id|bind
c_func
(paren
id|s
comma
id|sa
comma
id|sz
)paren
suffix:semicolon
)brace
DECL|macro|setsockopt
macro_line|#undef setsockopt
DECL|function|mingw_setsockopt
r_int
id|mingw_setsockopt
c_func
(paren
r_int
id|sockfd
comma
r_int
id|lvl
comma
r_int
id|optname
comma
r_void
op_star
id|optval
comma
r_int
id|optlen
)paren
(brace
id|SOCKET
id|s
op_assign
(paren
id|SOCKET
)paren
id|_get_osfhandle
c_func
(paren
id|sockfd
)paren
suffix:semicolon
r_return
id|setsockopt
c_func
(paren
id|s
comma
id|lvl
comma
id|optname
comma
(paren
r_const
r_char
op_star
)paren
id|optval
comma
id|optlen
)paren
suffix:semicolon
)brace
DECL|macro|shutdown
macro_line|#undef shutdown
DECL|function|mingw_shutdown
r_int
id|mingw_shutdown
c_func
(paren
r_int
id|sockfd
comma
r_int
id|how
)paren
(brace
id|SOCKET
id|s
op_assign
(paren
id|SOCKET
)paren
id|_get_osfhandle
c_func
(paren
id|sockfd
)paren
suffix:semicolon
r_return
id|shutdown
c_func
(paren
id|s
comma
id|how
)paren
suffix:semicolon
)brace
DECL|macro|listen
macro_line|#undef listen
DECL|function|mingw_listen
r_int
id|mingw_listen
c_func
(paren
r_int
id|sockfd
comma
r_int
id|backlog
)paren
(brace
id|SOCKET
id|s
op_assign
(paren
id|SOCKET
)paren
id|_get_osfhandle
c_func
(paren
id|sockfd
)paren
suffix:semicolon
r_return
id|listen
c_func
(paren
id|s
comma
id|backlog
)paren
suffix:semicolon
)brace
DECL|macro|accept
macro_line|#undef accept
DECL|function|mingw_accept
r_int
id|mingw_accept
c_func
(paren
r_int
id|sockfd1
comma
r_struct
id|sockaddr
op_star
id|sa
comma
id|socklen_t
op_star
id|sz
)paren
(brace
r_int
id|sockfd2
suffix:semicolon
id|SOCKET
id|s1
op_assign
(paren
id|SOCKET
)paren
id|_get_osfhandle
c_func
(paren
id|sockfd1
)paren
suffix:semicolon
id|SOCKET
id|s2
op_assign
id|accept
c_func
(paren
id|s1
comma
id|sa
comma
id|sz
)paren
suffix:semicolon
multiline_comment|/* convert into a file descriptor */
r_if
c_cond
(paren
(paren
id|sockfd2
op_assign
id|_open_osfhandle
c_func
(paren
id|s2
comma
id|O_RDWR
op_or
id|O_BINARY
)paren
)paren
OL
l_int|0
)paren
(brace
r_int
id|err
op_assign
id|errno
suffix:semicolon
id|closesocket
c_func
(paren
id|s2
)paren
suffix:semicolon
r_return
id|error
c_func
(paren
l_string|&quot;unable to make a socket file descriptor: %s&quot;
comma
id|strerror
c_func
(paren
id|err
)paren
)paren
suffix:semicolon
)brace
r_return
id|sockfd2
suffix:semicolon
)brace
DECL|macro|rename
macro_line|#undef rename
DECL|function|mingw_rename
r_int
id|mingw_rename
c_func
(paren
r_const
r_char
op_star
id|pold
comma
r_const
r_char
op_star
id|pnew
)paren
(brace
id|DWORD
id|attrs
comma
id|gle
suffix:semicolon
r_int
id|tries
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Try native rename() first to get errno right.&n;&t; * It is based on MoveFile(), which cannot overwrite existing files.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|rename
c_func
(paren
id|pold
comma
id|pnew
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|errno
op_ne
id|EEXIST
)paren
r_return
l_int|1
suffix:semicolon
id|repeat
suffix:colon
r_if
c_cond
(paren
id|MoveFileEx
c_func
(paren
id|pold
comma
id|pnew
comma
id|MOVEFILE_REPLACE_EXISTING
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* TODO: translate more errors */
id|gle
op_assign
id|GetLastError
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gle
op_eq
id|ERROR_ACCESS_DENIED
op_logical_and
(paren
id|attrs
op_assign
id|GetFileAttributes
c_func
(paren
id|pnew
)paren
)paren
op_ne
id|INVALID_FILE_ATTRIBUTES
)paren
(brace
r_if
c_cond
(paren
id|attrs
op_amp
id|FILE_ATTRIBUTE_DIRECTORY
)paren
(brace
id|errno
op_assign
id|EISDIR
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|attrs
op_amp
id|FILE_ATTRIBUTE_READONLY
)paren
op_logical_and
id|SetFileAttributes
c_func
(paren
id|pnew
comma
id|attrs
op_amp
op_complement
id|FILE_ATTRIBUTE_READONLY
)paren
)paren
(brace
r_if
c_cond
(paren
id|MoveFileEx
c_func
(paren
id|pold
comma
id|pnew
comma
id|MOVEFILE_REPLACE_EXISTING
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|gle
op_assign
id|GetLastError
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* revert file attributes on failure */
id|SetFileAttributes
c_func
(paren
id|pnew
comma
id|attrs
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|tries
OL
id|ARRAY_SIZE
c_func
(paren
id|delay
)paren
op_logical_and
id|gle
op_eq
id|ERROR_ACCESS_DENIED
)paren
(brace
multiline_comment|/*&n;&t;&t; * We assume that some other process had the source or&n;&t;&t; * destination file open at the wrong moment and retry.&n;&t;&t; * In order to give the other process a higher chance to&n;&t;&t; * complete its operation, we give up our time slice now.&n;&t;&t; * If we have to retry again, we do sleep a bit.&n;&t;&t; */
id|Sleep
c_func
(paren
id|delay
(braket
id|tries
)braket
)paren
suffix:semicolon
id|tries
op_increment
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
r_if
c_cond
(paren
id|gle
op_eq
id|ERROR_ACCESS_DENIED
op_logical_and
id|ask_yes_no_if_possible
c_func
(paren
l_string|&quot;Rename from &squot;%s&squot; to &squot;%s&squot; failed. &quot;
l_string|&quot;Should I try again?&quot;
comma
id|pold
comma
id|pnew
)paren
)paren
r_goto
id|repeat
suffix:semicolon
id|errno
op_assign
id|EACCES
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Note that this doesn&squot;t return the actual pagesize, but&n; * the allocation granularity. If future Windows specific git code&n; * needs the real getpagesize function, we need to find another solution.&n; */
DECL|function|mingw_getpagesize
r_int
id|mingw_getpagesize
c_func
(paren
r_void
)paren
(brace
id|SYSTEM_INFO
id|si
suffix:semicolon
id|GetSystemInfo
c_func
(paren
op_amp
id|si
)paren
suffix:semicolon
r_return
id|si.dwAllocationGranularity
suffix:semicolon
)brace
DECL|function|getpwuid
r_struct
id|passwd
op_star
id|getpwuid
c_func
(paren
r_int
id|uid
)paren
(brace
r_static
r_char
id|user_name
(braket
l_int|100
)braket
suffix:semicolon
r_static
r_struct
id|passwd
id|p
suffix:semicolon
id|DWORD
id|len
op_assign
r_sizeof
(paren
id|user_name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|GetUserName
c_func
(paren
id|user_name
comma
op_amp
id|len
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|p.pw_name
op_assign
id|user_name
suffix:semicolon
id|p.pw_gecos
op_assign
l_string|&quot;unknown&quot;
suffix:semicolon
id|p.pw_dir
op_assign
l_int|NULL
suffix:semicolon
r_return
op_amp
id|p
suffix:semicolon
)brace
DECL|variable|timer_event
r_static
id|HANDLE
id|timer_event
suffix:semicolon
DECL|variable|timer_thread
r_static
id|HANDLE
id|timer_thread
suffix:semicolon
DECL|variable|timer_interval
r_static
r_int
id|timer_interval
suffix:semicolon
DECL|variable|one_shot
r_static
r_int
id|one_shot
suffix:semicolon
DECL|variable|timer_fn
r_static
id|sig_handler_t
id|timer_fn
op_assign
id|SIG_DFL
suffix:semicolon
multiline_comment|/* The timer works like this:&n; * The thread, ticktack(), is a trivial routine that most of the time&n; * only waits to receive the signal to terminate. The main thread tells&n; * the thread to terminate by setting the timer_event to the signalled&n; * state.&n; * But ticktack() interrupts the wait state after the timer&squot;s interval&n; * length to call the signal handler.&n; */
DECL|function|ticktack
r_static
r_int
id|__stdcall
id|ticktack
c_func
(paren
r_void
op_star
id|dummy
)paren
(brace
r_while
c_loop
(paren
id|WaitForSingleObject
c_func
(paren
id|timer_event
comma
id|timer_interval
)paren
op_eq
id|WAIT_TIMEOUT
)paren
(brace
r_if
c_cond
(paren
id|timer_fn
op_eq
id|SIG_DFL
)paren
id|die
c_func
(paren
l_string|&quot;Alarm&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timer_fn
op_ne
id|SIG_IGN
)paren
id|timer_fn
c_func
(paren
id|SIGALRM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|one_shot
)paren
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|start_timer_thread
r_static
r_int
id|start_timer_thread
c_func
(paren
r_void
)paren
(brace
id|timer_event
op_assign
id|CreateEvent
c_func
(paren
l_int|NULL
comma
id|FALSE
comma
id|FALSE
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timer_event
)paren
(brace
id|timer_thread
op_assign
(paren
id|HANDLE
)paren
id|_beginthreadex
c_func
(paren
l_int|NULL
comma
l_int|0
comma
id|ticktack
comma
l_int|NULL
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|timer_thread
)paren
r_return
id|errno
op_assign
id|ENOMEM
comma
id|error
c_func
(paren
l_string|&quot;cannot start timer thread&quot;
)paren
suffix:semicolon
)brace
r_else
r_return
id|errno
op_assign
id|ENOMEM
comma
id|error
c_func
(paren
l_string|&quot;cannot allocate resources for timer&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|stop_timer_thread
r_static
r_void
id|stop_timer_thread
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|timer_event
)paren
id|SetEvent
c_func
(paren
id|timer_event
)paren
suffix:semicolon
multiline_comment|/* tell thread to terminate */
r_if
c_cond
(paren
id|timer_thread
)paren
(brace
r_int
id|rc
op_assign
id|WaitForSingleObject
c_func
(paren
id|timer_thread
comma
l_int|1000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
id|WAIT_TIMEOUT
)paren
id|error
c_func
(paren
l_string|&quot;timer thread did not terminate timely&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rc
op_ne
id|WAIT_OBJECT_0
)paren
id|error
c_func
(paren
l_string|&quot;waiting for timer thread failed: %lu&quot;
comma
id|GetLastError
c_func
(paren
)paren
)paren
suffix:semicolon
id|CloseHandle
c_func
(paren
id|timer_thread
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|timer_event
)paren
id|CloseHandle
c_func
(paren
id|timer_event
)paren
suffix:semicolon
id|timer_event
op_assign
l_int|NULL
suffix:semicolon
id|timer_thread
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|is_timeval_eq
r_static
r_inline
r_int
id|is_timeval_eq
c_func
(paren
r_const
r_struct
id|timeval
op_star
id|i1
comma
r_const
r_struct
id|timeval
op_star
id|i2
)paren
(brace
r_return
id|i1-&gt;tv_sec
op_eq
id|i2-&gt;tv_sec
op_logical_and
id|i1-&gt;tv_usec
op_eq
id|i2-&gt;tv_usec
suffix:semicolon
)brace
DECL|function|setitimer
r_int
id|setitimer
c_func
(paren
r_int
id|type
comma
r_struct
id|itimerval
op_star
id|in
comma
r_struct
id|itimerval
op_star
id|out
)paren
(brace
r_static
r_const
r_struct
id|timeval
id|zero
suffix:semicolon
r_static
r_int
id|atexit_done
suffix:semicolon
r_if
c_cond
(paren
id|out
op_ne
l_int|NULL
)paren
r_return
id|errno
op_assign
id|EINVAL
comma
id|error
c_func
(paren
l_string|&quot;setitimer param 3 != NULL not implemented&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_timeval_eq
c_func
(paren
op_amp
id|in-&gt;it_interval
comma
op_amp
id|zero
)paren
op_logical_and
op_logical_neg
id|is_timeval_eq
c_func
(paren
op_amp
id|in-&gt;it_interval
comma
op_amp
id|in-&gt;it_value
)paren
)paren
r_return
id|errno
op_assign
id|EINVAL
comma
id|error
c_func
(paren
l_string|&quot;setitimer: it_interval must be zero or eq it_value&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timer_thread
)paren
id|stop_timer_thread
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_timeval_eq
c_func
(paren
op_amp
id|in-&gt;it_value
comma
op_amp
id|zero
)paren
op_logical_and
id|is_timeval_eq
c_func
(paren
op_amp
id|in-&gt;it_interval
comma
op_amp
id|zero
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|timer_interval
op_assign
id|in-&gt;it_value.tv_sec
op_star
l_int|1000
op_plus
id|in-&gt;it_value.tv_usec
op_div
l_int|1000
suffix:semicolon
id|one_shot
op_assign
id|is_timeval_eq
c_func
(paren
op_amp
id|in-&gt;it_interval
comma
op_amp
id|zero
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|atexit_done
)paren
(brace
id|atexit
c_func
(paren
id|stop_timer_thread
)paren
suffix:semicolon
id|atexit_done
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|start_timer_thread
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|sigaction
r_int
id|sigaction
c_func
(paren
r_int
id|sig
comma
r_struct
id|sigaction
op_star
id|in
comma
r_struct
id|sigaction
op_star
id|out
)paren
(brace
r_if
c_cond
(paren
id|sig
op_ne
id|SIGALRM
)paren
r_return
id|errno
op_assign
id|EINVAL
comma
id|error
c_func
(paren
l_string|&quot;sigaction only implemented for SIGALRM&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|out
op_ne
l_int|NULL
)paren
r_return
id|errno
op_assign
id|EINVAL
comma
id|error
c_func
(paren
l_string|&quot;sigaction: param 3 != NULL not implemented&quot;
)paren
suffix:semicolon
id|timer_fn
op_assign
id|in-&gt;sa_handler
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|signal
macro_line|#undef signal
DECL|function|mingw_signal
id|sig_handler_t
id|mingw_signal
c_func
(paren
r_int
id|sig
comma
id|sig_handler_t
id|handler
)paren
(brace
id|sig_handler_t
id|old
op_assign
id|timer_fn
suffix:semicolon
r_if
c_cond
(paren
id|sig
op_ne
id|SIGALRM
)paren
r_return
id|signal
c_func
(paren
id|sig
comma
id|handler
)paren
suffix:semicolon
id|timer_fn
op_assign
id|handler
suffix:semicolon
r_return
id|old
suffix:semicolon
)brace
DECL|function|make_backslash_path
r_static
r_const
r_char
op_star
id|make_backslash_path
c_func
(paren
r_const
r_char
op_star
id|path
)paren
(brace
r_static
r_char
id|buf
(braket
id|PATH_MAX
op_plus
l_int|1
)braket
suffix:semicolon
r_char
op_star
id|c
suffix:semicolon
r_if
c_cond
(paren
id|strlcpy
c_func
(paren
id|buf
comma
id|path
comma
id|PATH_MAX
)paren
op_ge
id|PATH_MAX
)paren
id|die
c_func
(paren
l_string|&quot;Too long path: %.*s&quot;
comma
l_int|60
comma
id|path
)paren
suffix:semicolon
r_for
c_loop
(paren
id|c
op_assign
id|buf
suffix:semicolon
op_star
id|c
suffix:semicolon
id|c
op_increment
)paren
(brace
r_if
c_cond
(paren
op_star
id|c
op_eq
l_char|&squot;/&squot;
)paren
op_star
id|c
op_assign
l_char|&squot;&bslash;&bslash;&squot;
suffix:semicolon
)brace
r_return
id|buf
suffix:semicolon
)brace
DECL|function|mingw_open_html
r_void
id|mingw_open_html
c_func
(paren
r_const
r_char
op_star
id|unixpath
)paren
(brace
r_const
r_char
op_star
id|htmlpath
op_assign
id|make_backslash_path
c_func
(paren
id|unixpath
)paren
suffix:semicolon
r_typedef
id|HINSTANCE
(paren
id|WINAPI
op_star
id|T
)paren
(paren
id|HWND
comma
r_const
r_char
op_star
comma
r_const
r_char
op_star
comma
r_const
r_char
op_star
comma
r_const
r_char
op_star
comma
id|INT
)paren
suffix:semicolon
id|T
id|ShellExecute
suffix:semicolon
id|HMODULE
id|shell32
suffix:semicolon
r_int
id|r
suffix:semicolon
id|shell32
op_assign
id|LoadLibrary
c_func
(paren
l_string|&quot;shell32.dll&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|shell32
)paren
id|die
c_func
(paren
l_string|&quot;cannot load shell32.dll&quot;
)paren
suffix:semicolon
id|ShellExecute
op_assign
(paren
id|T
)paren
id|GetProcAddress
c_func
(paren
id|shell32
comma
l_string|&quot;ShellExecuteA&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ShellExecute
)paren
id|die
c_func
(paren
l_string|&quot;cannot run browser&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Launching default browser to display HTML ...&bslash;n&quot;
)paren
suffix:semicolon
id|r
op_assign
(paren
r_int
)paren
id|ShellExecute
c_func
(paren
l_int|NULL
comma
l_string|&quot;open&quot;
comma
id|htmlpath
comma
l_int|NULL
comma
l_string|&quot;&bslash;&bslash;&quot;
comma
id|SW_SHOWNORMAL
)paren
suffix:semicolon
id|FreeLibrary
c_func
(paren
id|shell32
)paren
suffix:semicolon
multiline_comment|/* see the MSDN documentation referring to the result codes here */
r_if
c_cond
(paren
id|r
op_le
l_int|32
)paren
(brace
id|die
c_func
(paren
l_string|&quot;failed to launch browser for %.*s&quot;
comma
id|MAX_PATH
comma
id|unixpath
)paren
suffix:semicolon
)brace
)brace
DECL|function|link
r_int
id|link
c_func
(paren
r_const
r_char
op_star
id|oldpath
comma
r_const
r_char
op_star
id|newpath
)paren
(brace
r_typedef
id|BOOL
(paren
id|WINAPI
op_star
id|T
)paren
(paren
r_const
r_char
op_star
comma
r_const
r_char
op_star
comma
id|LPSECURITY_ATTRIBUTES
)paren
suffix:semicolon
r_static
id|T
id|create_hard_link
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|create_hard_link
)paren
(brace
id|create_hard_link
op_assign
(paren
id|T
)paren
id|GetProcAddress
c_func
(paren
id|GetModuleHandle
c_func
(paren
l_string|&quot;kernel32.dll&quot;
)paren
comma
l_string|&quot;CreateHardLinkA&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|create_hard_link
)paren
id|create_hard_link
op_assign
(paren
id|T
)paren
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|create_hard_link
op_eq
(paren
id|T
)paren
op_minus
l_int|1
)paren
(brace
id|errno
op_assign
id|ENOSYS
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|create_hard_link
c_func
(paren
id|newpath
comma
id|oldpath
comma
l_int|NULL
)paren
)paren
(brace
id|errno
op_assign
id|err_win_to_posix
c_func
(paren
id|GetLastError
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|getpass
r_char
op_star
id|getpass
c_func
(paren
r_const
r_char
op_star
id|prompt
)paren
(brace
r_struct
id|strbuf
id|buf
op_assign
id|STRBUF_INIT
suffix:semicolon
id|fputs
c_func
(paren
id|prompt
comma
id|stderr
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_char
id|c
op_assign
id|_getch
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;r&squot;
op_logical_or
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
r_break
suffix:semicolon
id|strbuf_addch
c_func
(paren
op_amp
id|buf
comma
id|c
)paren
suffix:semicolon
)brace
id|fputs
c_func
(paren
l_string|&quot;&bslash;n&quot;
comma
id|stderr
)paren
suffix:semicolon
r_return
id|strbuf_detach
c_func
(paren
op_amp
id|buf
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|waitpid
id|pid_t
id|waitpid
c_func
(paren
id|pid_t
id|pid
comma
r_int
op_star
id|status
comma
r_int
id|options
)paren
(brace
id|HANDLE
id|h
op_assign
id|OpenProcess
c_func
(paren
id|SYNCHRONIZE
op_or
id|PROCESS_QUERY_INFORMATION
comma
id|FALSE
comma
id|pid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|h
)paren
(brace
id|errno
op_assign
id|ECHILD
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pid
OG
l_int|0
op_logical_and
id|options
op_amp
id|WNOHANG
)paren
(brace
r_if
c_cond
(paren
id|WAIT_OBJECT_0
op_ne
id|WaitForSingleObject
c_func
(paren
id|h
comma
l_int|0
)paren
)paren
(brace
id|CloseHandle
c_func
(paren
id|h
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|options
op_and_assign
op_complement
id|WNOHANG
suffix:semicolon
)brace
r_if
c_cond
(paren
id|options
op_eq
l_int|0
)paren
(brace
r_struct
id|pinfo_t
op_star
op_star
id|ppinfo
suffix:semicolon
r_if
c_cond
(paren
id|WaitForSingleObject
c_func
(paren
id|h
comma
id|INFINITE
)paren
op_ne
id|WAIT_OBJECT_0
)paren
(brace
id|CloseHandle
c_func
(paren
id|h
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
)paren
id|GetExitCodeProcess
c_func
(paren
id|h
comma
(paren
id|LPDWORD
)paren
id|status
)paren
suffix:semicolon
id|EnterCriticalSection
c_func
(paren
op_amp
id|pinfo_cs
)paren
suffix:semicolon
id|ppinfo
op_assign
op_amp
id|pinfo
suffix:semicolon
r_while
c_loop
(paren
op_star
id|ppinfo
)paren
(brace
r_struct
id|pinfo_t
op_star
id|info
op_assign
op_star
id|ppinfo
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;pid
op_eq
id|pid
)paren
(brace
id|CloseHandle
c_func
(paren
id|info-&gt;proc
)paren
suffix:semicolon
op_star
id|ppinfo
op_assign
id|info-&gt;next
suffix:semicolon
id|free
c_func
(paren
id|info
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ppinfo
op_assign
op_amp
id|info-&gt;next
suffix:semicolon
)brace
id|LeaveCriticalSection
c_func
(paren
op_amp
id|pinfo_cs
)paren
suffix:semicolon
id|CloseHandle
c_func
(paren
id|h
)paren
suffix:semicolon
r_return
id|pid
suffix:semicolon
)brace
id|CloseHandle
c_func
(paren
id|h
)paren
suffix:semicolon
id|errno
op_assign
id|EINVAL
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
eof
