multiline_comment|/*&n; * Helper functions for tree diff generation&n; */
macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;diff.h&quot;
macro_line|#include &quot;diffcore.h&quot;
macro_line|#include &quot;tree.h&quot;
multiline_comment|/*&n; * internal mode marker, saying a tree entry != entry of tp[imin]&n; * (see ll_diff_tree_paths for what it means there)&n; *&n; * we will update/use/emit entry for diff only with it unset.&n; */
DECL|macro|S_IFXMIN_NEQ
mdefine_line|#define S_IFXMIN_NEQ&t;S_DIFFTREE_IFXMIN_NEQ
r_static
r_struct
id|combine_diff_path
op_star
id|ll_diff_tree_paths
c_func
(paren
r_struct
id|combine_diff_path
op_star
id|p
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_const
r_int
r_char
op_star
op_star
id|parents_sha1
comma
r_int
id|nparent
comma
r_struct
id|strbuf
op_star
id|base
comma
r_struct
id|diff_options
op_star
id|opt
)paren
suffix:semicolon
r_static
r_int
id|ll_diff_tree_sha1
c_func
(paren
r_const
r_int
r_char
op_star
id|old
comma
r_const
r_int
r_char
op_star
r_new
comma
r_struct
id|strbuf
op_star
id|base
comma
r_struct
id|diff_options
op_star
id|opt
)paren
suffix:semicolon
multiline_comment|/*&n; * Compare two tree entries, taking into account only path/S_ISDIR(mode),&n; * but not their sha1&squot;s.&n; *&n; * NOTE files and directories *always* compare differently, even when having&n; *      the same name - thanks to base_name_compare().&n; *&n; * NOTE empty (=invalid) descriptor(s) take part in comparison as +infty,&n; *      so that they sort *after* valid tree entries.&n; *&n; *      Due to this convention, if trees are scanned in sorted order, all&n; *      non-empty descriptors will be processed first.&n; */
DECL|function|tree_entry_pathcmp
r_static
r_int
id|tree_entry_pathcmp
c_func
(paren
r_struct
id|tree_desc
op_star
id|t1
comma
r_struct
id|tree_desc
op_star
id|t2
)paren
(brace
r_struct
id|name_entry
op_star
id|e1
comma
op_star
id|e2
suffix:semicolon
r_int
id|cmp
suffix:semicolon
multiline_comment|/* empty descriptors sort after valid tree entries */
r_if
c_cond
(paren
op_logical_neg
id|t1-&gt;size
)paren
r_return
id|t2-&gt;size
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|t2-&gt;size
)paren
r_return
l_int|1
suffix:semicolon
id|e1
op_assign
op_amp
id|t1-&gt;entry
suffix:semicolon
id|e2
op_assign
op_amp
id|t2-&gt;entry
suffix:semicolon
id|cmp
op_assign
id|base_name_compare
c_func
(paren
id|e1-&gt;path
comma
id|tree_entry_len
c_func
(paren
id|e1
)paren
comma
id|e1-&gt;mode
comma
id|e2-&gt;path
comma
id|tree_entry_len
c_func
(paren
id|e2
)paren
comma
id|e2-&gt;mode
)paren
suffix:semicolon
r_return
id|cmp
suffix:semicolon
)brace
multiline_comment|/*&n; * convert path -&gt; opt-&gt;diff_*() callbacks&n; *&n; * emits diff to first parent only, and tells diff tree-walker that we are done&n; * with p and it can be freed.&n; */
DECL|function|emit_diff_first_parent_only
r_static
r_int
id|emit_diff_first_parent_only
c_func
(paren
r_struct
id|diff_options
op_star
id|opt
comma
r_struct
id|combine_diff_path
op_star
id|p
)paren
(brace
r_struct
id|combine_diff_parent
op_star
id|p0
op_assign
op_amp
id|p-&gt;parent
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;mode
op_logical_and
id|p0-&gt;mode
)paren
(brace
id|opt
op_member_access_from_pointer
id|change
c_func
(paren
id|opt
comma
id|p0-&gt;mode
comma
id|p-&gt;mode
comma
id|p0-&gt;oid.hash
comma
id|p-&gt;oid.hash
comma
l_int|1
comma
l_int|1
comma
id|p-&gt;path
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
r_const
r_int
r_char
op_star
id|sha1
suffix:semicolon
r_int
r_int
id|mode
suffix:semicolon
r_int
id|addremove
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;mode
)paren
(brace
id|addremove
op_assign
l_char|&squot;+&squot;
suffix:semicolon
id|sha1
op_assign
id|p-&gt;oid.hash
suffix:semicolon
id|mode
op_assign
id|p-&gt;mode
suffix:semicolon
)brace
r_else
(brace
id|addremove
op_assign
l_char|&squot;-&squot;
suffix:semicolon
id|sha1
op_assign
id|p0-&gt;oid.hash
suffix:semicolon
id|mode
op_assign
id|p0-&gt;mode
suffix:semicolon
)brace
id|opt
op_member_access_from_pointer
id|add_remove
c_func
(paren
id|opt
comma
id|addremove
comma
id|mode
comma
id|sha1
comma
l_int|1
comma
id|p-&gt;path
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* we are done with p */
)brace
multiline_comment|/*&n; * Make a new combine_diff_path from path/mode/sha1&n; * and append it to paths list tail.&n; *&n; * Memory for created elements could be reused:&n; *&n; *&t;- if last-&gt;next == NULL, the memory is allocated;&n; *&n; *&t;- if last-&gt;next != NULL, it is assumed that p=last-&gt;next was returned&n; *&t;  earlier by this function, and p-&gt;next was *not* modified.&n; *&t;  The memory is then reused from p.&n; *&n; * so for clients,&n; *&n; * - if you do need to keep the element&n; *&n; *&t;p = path_appendnew(p, ...);&n; *&t;process(p);&n; *&t;p-&gt;next = NULL;&n; *&n; * - if you don&squot;t need to keep the element after processing&n; *&n; *&t;pprev = p;&n; *&t;p = path_appendnew(p, ...);&n; *&t;process(p);&n; *&t;p = pprev;&n; *&t;; don&squot;t forget to free tail-&gt;next in the end&n; *&n; * p-&gt;parent[] remains uninitialized.&n; */
DECL|function|path_appendnew
r_static
r_struct
id|combine_diff_path
op_star
id|path_appendnew
c_func
(paren
r_struct
id|combine_diff_path
op_star
id|last
comma
r_int
id|nparent
comma
r_const
r_struct
id|strbuf
op_star
id|base
comma
r_const
r_char
op_star
id|path
comma
r_int
id|pathlen
comma
r_int
id|mode
comma
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_struct
id|combine_diff_path
op_star
id|p
suffix:semicolon
r_int
id|len
op_assign
id|base-&gt;len
op_plus
id|pathlen
suffix:semicolon
r_int
id|alloclen
op_assign
id|combine_diff_path_size
c_func
(paren
id|nparent
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* if last-&gt;next is !NULL - it is a pre-allocated memory, we can reuse */
id|p
op_assign
id|last-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|p
op_logical_and
(paren
id|alloclen
OG
(paren
r_intptr
)paren
id|p-&gt;next
)paren
)paren
(brace
id|free
c_func
(paren
id|p
)paren
suffix:semicolon
id|p
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
(brace
id|p
op_assign
id|xmalloc
c_func
(paren
id|alloclen
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * until we go to it next round, .next holds how many bytes we&n;&t;&t; * allocated (for faster realloc - we don&squot;t need copying old data).&n;&t;&t; */
id|p-&gt;next
op_assign
(paren
r_struct
id|combine_diff_path
op_star
)paren
(paren
r_intptr
)paren
id|alloclen
suffix:semicolon
)brace
id|last-&gt;next
op_assign
id|p
suffix:semicolon
id|p-&gt;path
op_assign
(paren
r_char
op_star
)paren
op_amp
(paren
id|p-&gt;parent
(braket
id|nparent
)braket
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|p-&gt;path
comma
id|base-&gt;buf
comma
id|base-&gt;len
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|p-&gt;path
op_plus
id|base-&gt;len
comma
id|path
comma
id|pathlen
)paren
suffix:semicolon
id|p-&gt;path
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
id|p-&gt;mode
op_assign
id|mode
suffix:semicolon
id|hashcpy
c_func
(paren
id|p-&gt;oid.hash
comma
id|sha1
ques
c_cond
id|sha1
suffix:colon
id|null_sha1
)paren
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
multiline_comment|/*&n; * new path should be added to combine diff&n; *&n; * 3 cases on how/when it should be called and behaves:&n; *&n; *&t; t, !tp&t;&t;-&gt; path added, all parents lack it&n; *&t;!t,  tp&t;&t;-&gt; path removed from all parents&n; *&t; t,  tp&t;&t;-&gt; path modified/added&n; *&t;&t;&t;   (M for tp[i]=tp[imin], A otherwise)&n; */
DECL|function|emit_path
r_static
r_struct
id|combine_diff_path
op_star
id|emit_path
c_func
(paren
r_struct
id|combine_diff_path
op_star
id|p
comma
r_struct
id|strbuf
op_star
id|base
comma
r_struct
id|diff_options
op_star
id|opt
comma
r_int
id|nparent
comma
r_struct
id|tree_desc
op_star
id|t
comma
r_struct
id|tree_desc
op_star
id|tp
comma
r_int
id|imin
)paren
(brace
r_int
id|mode
suffix:semicolon
r_const
r_char
op_star
id|path
suffix:semicolon
r_const
r_int
r_char
op_star
id|sha1
suffix:semicolon
r_int
id|pathlen
suffix:semicolon
r_int
id|old_baselen
op_assign
id|base-&gt;len
suffix:semicolon
r_int
id|i
comma
id|isdir
comma
id|recurse
op_assign
l_int|0
comma
id|emitthis
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* at least something has to be valid */
m_assert
(paren
id|t
op_logical_or
id|tp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
)paren
(brace
multiline_comment|/* path present in resulting tree */
id|sha1
op_assign
id|tree_entry_extract
c_func
(paren
id|t
comma
op_amp
id|path
comma
op_amp
id|mode
)paren
suffix:semicolon
id|pathlen
op_assign
id|tree_entry_len
c_func
(paren
op_amp
id|t-&gt;entry
)paren
suffix:semicolon
id|isdir
op_assign
id|S_ISDIR
c_func
(paren
id|mode
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * a path was removed - take path from imin parent. Also take&n;&t;&t; * mode from that parent, to decide on recursion(1).&n;&t;&t; *&n;&t;&t; * 1) all modes for tp[i]=tp[imin] should be the same wrt&n;&t;&t; *    S_ISDIR, thanks to base_name_compare().&n;&t;&t; */
id|tree_entry_extract
c_func
(paren
op_amp
id|tp
(braket
id|imin
)braket
comma
op_amp
id|path
comma
op_amp
id|mode
)paren
suffix:semicolon
id|pathlen
op_assign
id|tree_entry_len
c_func
(paren
op_amp
id|tp
(braket
id|imin
)braket
dot
id|entry
)paren
suffix:semicolon
id|isdir
op_assign
id|S_ISDIR
c_func
(paren
id|mode
)paren
suffix:semicolon
id|sha1
op_assign
l_int|NULL
suffix:semicolon
id|mode
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DIFF_OPT_TST
c_func
(paren
id|opt
comma
id|RECURSIVE
)paren
op_logical_and
id|isdir
)paren
(brace
id|recurse
op_assign
l_int|1
suffix:semicolon
id|emitthis
op_assign
id|DIFF_OPT_TST
c_func
(paren
id|opt
comma
id|TREE_IN_RECURSIVE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|emitthis
)paren
(brace
r_int
id|keep
suffix:semicolon
r_struct
id|combine_diff_path
op_star
id|pprev
op_assign
id|p
suffix:semicolon
id|p
op_assign
id|path_appendnew
c_func
(paren
id|p
comma
id|nparent
comma
id|base
comma
id|path
comma
id|pathlen
comma
id|mode
comma
id|sha1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nparent
suffix:semicolon
op_increment
id|i
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * tp[i] is valid, if present and if tp[i]==tp[imin] -&n;&t;&t;&t; * otherwise, we should ignore it.&n;&t;&t;&t; */
r_int
id|tpi_valid
op_assign
id|tp
op_logical_and
op_logical_neg
(paren
id|tp
(braket
id|i
)braket
dot
id|entry.mode
op_amp
id|S_IFXMIN_NEQ
)paren
suffix:semicolon
r_const
r_int
r_char
op_star
id|sha1_i
suffix:semicolon
r_int
id|mode_i
suffix:semicolon
id|p-&gt;parent
(braket
id|i
)braket
dot
id|status
op_assign
op_logical_neg
id|t
ques
c_cond
id|DIFF_STATUS_DELETED
suffix:colon
id|tpi_valid
ques
c_cond
id|DIFF_STATUS_MODIFIED
suffix:colon
id|DIFF_STATUS_ADDED
suffix:semicolon
r_if
c_cond
(paren
id|tpi_valid
)paren
(brace
id|sha1_i
op_assign
id|tp
(braket
id|i
)braket
dot
id|entry.sha1
suffix:semicolon
id|mode_i
op_assign
id|tp
(braket
id|i
)braket
dot
id|entry.mode
suffix:semicolon
)brace
r_else
(brace
id|sha1_i
op_assign
l_int|NULL
suffix:semicolon
id|mode_i
op_assign
l_int|0
suffix:semicolon
)brace
id|p-&gt;parent
(braket
id|i
)braket
dot
id|mode
op_assign
id|mode_i
suffix:semicolon
id|hashcpy
c_func
(paren
id|p-&gt;parent
(braket
id|i
)braket
dot
id|oid.hash
comma
id|sha1_i
ques
c_cond
id|sha1_i
suffix:colon
id|null_sha1
)paren
suffix:semicolon
)brace
id|keep
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|opt-&gt;pathchange
)paren
id|keep
op_assign
id|opt
op_member_access_from_pointer
id|pathchange
c_func
(paren
id|opt
comma
id|p
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If a path was filtered or consumed - we don&squot;t need to add it&n;&t;&t; * to the list and can reuse its memory, leaving it as&n;&t;&t; * pre-allocated element on the tail.&n;&t;&t; *&n;&t;&t; * On the other hand, if path needs to be kept, we need to&n;&t;&t; * correct its .next to NULL, as it was pre-initialized to how&n;&t;&t; * much memory was allocated.&n;&t;&t; *&n;&t;&t; * see path_appendnew() for details.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|keep
)paren
id|p
op_assign
id|pprev
suffix:semicolon
r_else
id|p-&gt;next
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|recurse
)paren
(brace
r_const
r_int
r_char
op_star
op_star
id|parents_sha1
suffix:semicolon
id|parents_sha1
op_assign
id|xalloca
c_func
(paren
id|nparent
op_star
r_sizeof
(paren
id|parents_sha1
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nparent
suffix:semicolon
op_increment
id|i
)paren
(brace
multiline_comment|/* same rule as in emitthis */
r_int
id|tpi_valid
op_assign
id|tp
op_logical_and
op_logical_neg
(paren
id|tp
(braket
id|i
)braket
dot
id|entry.mode
op_amp
id|S_IFXMIN_NEQ
)paren
suffix:semicolon
id|parents_sha1
(braket
id|i
)braket
op_assign
id|tpi_valid
ques
c_cond
id|tp
(braket
id|i
)braket
dot
id|entry.sha1
suffix:colon
l_int|NULL
suffix:semicolon
)brace
id|strbuf_add
c_func
(paren
id|base
comma
id|path
comma
id|pathlen
)paren
suffix:semicolon
id|strbuf_addch
c_func
(paren
id|base
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
id|p
op_assign
id|ll_diff_tree_paths
c_func
(paren
id|p
comma
id|sha1
comma
id|parents_sha1
comma
id|nparent
comma
id|base
comma
id|opt
)paren
suffix:semicolon
id|xalloca_free
c_func
(paren
id|parents_sha1
)paren
suffix:semicolon
)brace
id|strbuf_setlen
c_func
(paren
id|base
comma
id|old_baselen
)paren
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
DECL|function|skip_uninteresting
r_static
r_void
id|skip_uninteresting
c_func
(paren
r_struct
id|tree_desc
op_star
id|t
comma
r_struct
id|strbuf
op_star
id|base
comma
r_struct
id|diff_options
op_star
id|opt
)paren
(brace
r_enum
id|interesting
id|match
suffix:semicolon
r_while
c_loop
(paren
id|t-&gt;size
)paren
(brace
id|match
op_assign
id|tree_entry_interesting
c_func
(paren
op_amp
id|t-&gt;entry
comma
id|base
comma
l_int|0
comma
op_amp
id|opt-&gt;pathspec
)paren
suffix:semicolon
r_if
c_cond
(paren
id|match
)paren
(brace
r_if
c_cond
(paren
id|match
op_eq
id|all_entries_not_interesting
)paren
id|t-&gt;size
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|update_tree_entry
c_func
(paren
id|t
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * generate paths for combined diff D(sha1,parents_sha1[])&n; *&n; * Resulting paths are appended to combine_diff_path linked list, and also, are&n; * emitted on the go via opt-&gt;pathchange() callback, so it is possible to&n; * process the result as batch or incrementally.&n; *&n; * The paths are generated scanning new tree and all parents trees&n; * simultaneously, similarly to what diff_tree() was doing for 2 trees.&n; * The theory behind such scan is as follows:&n; *&n; *&n; * D(T,P1...Pn) calculation scheme&n; * -------------------------------&n; *&n; * D(T,P1...Pn) = D(T,P1) ^ ... ^ D(T,Pn)&t;(regarding resulting paths set)&n; *&n; *&t;D(T,Pj)&t;&t;- diff between T..Pj&n; *&t;D(T,P1...Pn)&t;- combined diff from T to parents P1,...,Pn&n; *&n; *&n; * We start from all trees, which are sorted, and compare their entries in&n; * lock-step:&n; *&n; *&t; T     P1       Pn&n; *&t; -     -        -&n; *&t;|t|   |p1|     |pn|&n; *&t;|-|   |--| ... |--|      imin = argmin(p1...pn)&n; *&t;| |   |  |     |  |&n; *&t;|-|   |--|     |--|&n; *&t;|.|   |. |     |. |&n; *&t; .     .        .&n; *&t; .     .        .&n; *&n; * at any time there could be 3 cases:&n; *&n; *&t;1)  t &lt; p[imin];&n; *&t;2)  t &gt; p[imin];&n; *&t;3)  t = p[imin].&n; *&n; * Schematic deduction of what every case means, and what to do, follows:&n; *&n; * 1)  t &lt; p[imin]  -&gt;  &forall;j t &notin; Pj  -&gt;  &quot;+t&quot; &isin; D(T,Pj)  -&gt;  D += &quot;+t&quot;;  t&darr;&n; *&n; * 2)  t &gt; p[imin]&n; *&n; *     2.1) &exist;j: pj &gt; p[imin]  -&gt;  &quot;-p[imin]&quot; &notin; D(T,Pj)  -&gt;  D += &oslash;;  &forall; pi=p[imin]  pi&darr;&n; *     2.2) &forall;i  pi = p[imin]  -&gt;  pi &notin; T  -&gt;  &quot;-pi&quot; &isin; D(T,Pi)  -&gt;  D += &quot;-p[imin]&quot;;  &forall;i pi&darr;&n; *&n; * 3)  t = p[imin]&n; *&n; *     3.1) &exist;j: pj &gt; p[imin]  -&gt;  &quot;+t&quot; &isin; D(T,Pj)  -&gt;  only pi=p[imin] remains to investigate&n; *     3.2) pi = p[imin]  -&gt;  investigate &delta;(t,pi)&n; *      |&n; *      |&n; *      v&n; *&n; *     3.1+3.2) looking at &delta;(t,pi) &forall;i: pi=p[imin] - if all != &oslash;  -&gt;&n; *&n; *                       &#x23a7;&delta;(t,pi)  - if pi=p[imin]&n; *              -&gt;  D += &#x23a8;&n; *                       &#x23a9;&quot;+t&quot;     - if pi&gt;p[imin]&n; *&n; *&n; *     in any case t&darr;  &forall; pi=p[imin]  pi&darr;&n; *&n; *&n; * ~~~~~~~~&n; *&n; * NOTE&n; *&n; *&t;Usual diff D(A,B) is by definition the same as combined diff D(A,[B]),&n; *&t;so this diff paths generator can, and is used, for plain diffs&n; *&t;generation too.&n; *&n; *&t;Please keep attention to the common D(A,[B]) case when working on the&n; *&t;code, in order not to slow it down.&n; *&n; * NOTE&n; *&t;nparent must be &gt; 0.&n; */
multiline_comment|/* &forall; pi=p[imin]  pi&darr; */
DECL|function|update_tp_entries
r_static
r_inline
r_void
id|update_tp_entries
c_func
(paren
r_struct
id|tree_desc
op_star
id|tp
comma
r_int
id|nparent
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nparent
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
op_logical_neg
(paren
id|tp
(braket
id|i
)braket
dot
id|entry.mode
op_amp
id|S_IFXMIN_NEQ
)paren
)paren
id|update_tree_entry
c_func
(paren
op_amp
id|tp
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
DECL|function|ll_diff_tree_paths
r_static
r_struct
id|combine_diff_path
op_star
id|ll_diff_tree_paths
c_func
(paren
r_struct
id|combine_diff_path
op_star
id|p
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_const
r_int
r_char
op_star
op_star
id|parents_sha1
comma
r_int
id|nparent
comma
r_struct
id|strbuf
op_star
id|base
comma
r_struct
id|diff_options
op_star
id|opt
)paren
(brace
r_struct
id|tree_desc
id|t
comma
op_star
id|tp
suffix:semicolon
r_void
op_star
id|ttree
comma
op_star
op_star
id|tptree
suffix:semicolon
r_int
id|i
suffix:semicolon
id|tp
op_assign
id|xalloca
c_func
(paren
id|nparent
op_star
r_sizeof
(paren
id|tp
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|tptree
op_assign
id|xalloca
c_func
(paren
id|nparent
op_star
r_sizeof
(paren
id|tptree
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * load parents first, as they are probably already cached.&n;&t; *&n;&t; * ( log_tree_diff() parses commit-&gt;parent before calling here via&n;&t; *   diff_tree_sha1(parent, commit) )&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nparent
suffix:semicolon
op_increment
id|i
)paren
id|tptree
(braket
id|i
)braket
op_assign
id|fill_tree_descriptor
c_func
(paren
op_amp
id|tp
(braket
id|i
)braket
comma
id|parents_sha1
(braket
id|i
)braket
)paren
suffix:semicolon
id|ttree
op_assign
id|fill_tree_descriptor
c_func
(paren
op_amp
id|t
comma
id|sha1
)paren
suffix:semicolon
multiline_comment|/* Enable recursion indefinitely */
id|opt-&gt;pathspec.recursive
op_assign
id|DIFF_OPT_TST
c_func
(paren
id|opt
comma
id|RECURSIVE
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|imin
comma
id|cmp
suffix:semicolon
r_if
c_cond
(paren
id|diff_can_quit_early
c_func
(paren
id|opt
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|opt-&gt;pathspec.nr
)paren
(brace
id|skip_uninteresting
c_func
(paren
op_amp
id|t
comma
id|base
comma
id|opt
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nparent
suffix:semicolon
id|i
op_increment
)paren
id|skip_uninteresting
c_func
(paren
op_amp
id|tp
(braket
id|i
)braket
comma
id|base
comma
id|opt
)paren
suffix:semicolon
)brace
multiline_comment|/* comparing is finished when all trees are done */
r_if
c_cond
(paren
op_logical_neg
id|t.size
)paren
(brace
r_int
id|done
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nparent
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
id|tp
(braket
id|i
)braket
dot
id|size
)paren
(brace
id|done
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|done
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * lookup imin = argmin(p1...pn),&n;&t;&t; * mark entries whether they =p[imin] along the way&n;&t;&t; */
id|imin
op_assign
l_int|0
suffix:semicolon
id|tp
(braket
l_int|0
)braket
dot
id|entry.mode
op_and_assign
op_complement
id|S_IFXMIN_NEQ
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|nparent
suffix:semicolon
op_increment
id|i
)paren
(brace
id|cmp
op_assign
id|tree_entry_pathcmp
c_func
(paren
op_amp
id|tp
(braket
id|i
)braket
comma
op_amp
id|tp
(braket
id|imin
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmp
OL
l_int|0
)paren
(brace
id|imin
op_assign
id|i
suffix:semicolon
id|tp
(braket
id|i
)braket
dot
id|entry.mode
op_and_assign
op_complement
id|S_IFXMIN_NEQ
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cmp
op_eq
l_int|0
)paren
(brace
id|tp
(braket
id|i
)braket
dot
id|entry.mode
op_and_assign
op_complement
id|S_IFXMIN_NEQ
suffix:semicolon
)brace
r_else
(brace
id|tp
(braket
id|i
)braket
dot
id|entry.mode
op_or_assign
id|S_IFXMIN_NEQ
suffix:semicolon
)brace
)brace
multiline_comment|/* fixup markings for entries before imin */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|imin
suffix:semicolon
op_increment
id|i
)paren
id|tp
(braket
id|i
)braket
dot
id|entry.mode
op_or_assign
id|S_IFXMIN_NEQ
suffix:semicolon
multiline_comment|/* pi &gt; p[imin] */
multiline_comment|/* compare t vs p[imin] */
id|cmp
op_assign
id|tree_entry_pathcmp
c_func
(paren
op_amp
id|t
comma
op_amp
id|tp
(braket
id|imin
)braket
)paren
suffix:semicolon
multiline_comment|/* t = p[imin] */
r_if
c_cond
(paren
id|cmp
op_eq
l_int|0
)paren
(brace
multiline_comment|/* are either pi &gt; p[imin] or diff(t,pi) != &oslash; ? */
r_if
c_cond
(paren
op_logical_neg
id|DIFF_OPT_TST
c_func
(paren
id|opt
comma
id|FIND_COPIES_HARDER
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nparent
suffix:semicolon
op_increment
id|i
)paren
(brace
multiline_comment|/* p[i] &gt; p[imin] */
r_if
c_cond
(paren
id|tp
(braket
id|i
)braket
dot
id|entry.mode
op_amp
id|S_IFXMIN_NEQ
)paren
r_continue
suffix:semicolon
multiline_comment|/* diff(t,pi) != &oslash; */
r_if
c_cond
(paren
id|hashcmp
c_func
(paren
id|t.entry.sha1
comma
id|tp
(braket
id|i
)braket
dot
id|entry.sha1
)paren
op_logical_or
(paren
id|t.entry.mode
op_ne
id|tp
(braket
id|i
)braket
dot
id|entry.mode
)paren
)paren
r_continue
suffix:semicolon
r_goto
id|skip_emit_t_tp
suffix:semicolon
)brace
)brace
multiline_comment|/* D += {&delta;(t,pi) if pi=p[imin];  &quot;+a&quot; if pi &gt; p[imin]} */
id|p
op_assign
id|emit_path
c_func
(paren
id|p
comma
id|base
comma
id|opt
comma
id|nparent
comma
op_amp
id|t
comma
id|tp
comma
id|imin
)paren
suffix:semicolon
id|skip_emit_t_tp
suffix:colon
multiline_comment|/* t&darr;,  &forall; pi=p[imin]  pi&darr; */
id|update_tree_entry
c_func
(paren
op_amp
id|t
)paren
suffix:semicolon
id|update_tp_entries
c_func
(paren
id|tp
comma
id|nparent
)paren
suffix:semicolon
)brace
multiline_comment|/* t &lt; p[imin] */
r_else
r_if
c_cond
(paren
id|cmp
OL
l_int|0
)paren
(brace
multiline_comment|/* D += &quot;+t&quot; */
id|p
op_assign
id|emit_path
c_func
(paren
id|p
comma
id|base
comma
id|opt
comma
id|nparent
comma
op_amp
id|t
comma
multiline_comment|/*tp=*/
l_int|NULL
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* t&darr; */
id|update_tree_entry
c_func
(paren
op_amp
id|t
)paren
suffix:semicolon
)brace
multiline_comment|/* t &gt; p[imin] */
r_else
(brace
multiline_comment|/* &forall;i pi=p[imin] -&gt; D += &quot;-p[imin]&quot; */
r_if
c_cond
(paren
op_logical_neg
id|DIFF_OPT_TST
c_func
(paren
id|opt
comma
id|FIND_COPIES_HARDER
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nparent
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
id|tp
(braket
id|i
)braket
dot
id|entry.mode
op_amp
id|S_IFXMIN_NEQ
)paren
r_goto
id|skip_emit_tp
suffix:semicolon
)brace
id|p
op_assign
id|emit_path
c_func
(paren
id|p
comma
id|base
comma
id|opt
comma
id|nparent
comma
multiline_comment|/*t=*/
l_int|NULL
comma
id|tp
comma
id|imin
)paren
suffix:semicolon
id|skip_emit_tp
suffix:colon
multiline_comment|/* &forall; pi=p[imin]  pi&darr; */
id|update_tp_entries
c_func
(paren
id|tp
comma
id|nparent
)paren
suffix:semicolon
)brace
)brace
id|free
c_func
(paren
id|ttree
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|nparent
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
id|free
c_func
(paren
id|tptree
(braket
id|i
)braket
)paren
suffix:semicolon
id|xalloca_free
c_func
(paren
id|tptree
)paren
suffix:semicolon
id|xalloca_free
c_func
(paren
id|tp
)paren
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
DECL|function|diff_tree_paths
r_struct
id|combine_diff_path
op_star
id|diff_tree_paths
c_func
(paren
r_struct
id|combine_diff_path
op_star
id|p
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_const
r_int
r_char
op_star
op_star
id|parents_sha1
comma
r_int
id|nparent
comma
r_struct
id|strbuf
op_star
id|base
comma
r_struct
id|diff_options
op_star
id|opt
)paren
(brace
id|p
op_assign
id|ll_diff_tree_paths
c_func
(paren
id|p
comma
id|sha1
comma
id|parents_sha1
comma
id|nparent
comma
id|base
comma
id|opt
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * free pre-allocated last element, if any&n;&t; * (see path_appendnew() for details about why)&n;&t; */
r_if
c_cond
(paren
id|p-&gt;next
)paren
(brace
id|free
c_func
(paren
id|p-&gt;next
)paren
suffix:semicolon
id|p-&gt;next
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|p
suffix:semicolon
)brace
multiline_comment|/*&n; * Does it look like the resulting diff might be due to a rename?&n; *  - single entry&n; *  - not a valid previous file&n; */
DECL|function|diff_might_be_rename
r_static
r_inline
r_int
id|diff_might_be_rename
c_func
(paren
r_void
)paren
(brace
r_return
id|diff_queued_diff.nr
op_eq
l_int|1
op_logical_and
op_logical_neg
id|DIFF_FILE_VALID
c_func
(paren
id|diff_queued_diff.queue
(braket
l_int|0
)braket
op_member_access_from_pointer
id|one
)paren
suffix:semicolon
)brace
DECL|function|try_to_follow_renames
r_static
r_void
id|try_to_follow_renames
c_func
(paren
r_const
r_int
r_char
op_star
id|old
comma
r_const
r_int
r_char
op_star
r_new
comma
r_struct
id|strbuf
op_star
id|base
comma
r_struct
id|diff_options
op_star
id|opt
)paren
(brace
r_struct
id|diff_options
id|diff_opts
suffix:semicolon
r_struct
id|diff_queue_struct
op_star
id|q
op_assign
op_amp
id|diff_queued_diff
suffix:semicolon
r_struct
id|diff_filepair
op_star
id|choice
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * follow-rename code is very specific, we need exactly one&n;&t; * path. Magic that matches more than one path is not&n;&t; * supported.&n;&t; */
id|GUARD_PATHSPEC
c_func
(paren
op_amp
id|opt-&gt;pathspec
comma
id|PATHSPEC_FROMTOP
op_or
id|PATHSPEC_LITERAL
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/*&n;&t; * We should reject wildcards as well. Unfortunately we&n;&t; * haven&squot;t got a reliable way to detect that &squot;foo&bslash;*bar&squot; in&n;&t; * fact has no wildcards. nowildcard_len is merely a hint for&n;&t; * optimization. Let it slip for now until wildmatch is taught&n;&t; * about dry-run mode and returns wildcard info.&n;&t; */
r_if
c_cond
(paren
id|opt-&gt;pathspec.has_wildcard
)paren
id|die
c_func
(paren
l_string|&quot;BUG:%s:%d: wildcards are not supported&quot;
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Remove the file creation entry from the diff queue, and remember it */
id|choice
op_assign
id|q-&gt;queue
(braket
l_int|0
)braket
suffix:semicolon
id|q-&gt;nr
op_assign
l_int|0
suffix:semicolon
id|diff_setup
c_func
(paren
op_amp
id|diff_opts
)paren
suffix:semicolon
id|DIFF_OPT_SET
c_func
(paren
op_amp
id|diff_opts
comma
id|RECURSIVE
)paren
suffix:semicolon
id|DIFF_OPT_SET
c_func
(paren
op_amp
id|diff_opts
comma
id|FIND_COPIES_HARDER
)paren
suffix:semicolon
id|diff_opts.output_format
op_assign
id|DIFF_FORMAT_NO_OUTPUT
suffix:semicolon
id|diff_opts.single_follow
op_assign
id|opt-&gt;pathspec.items
(braket
l_int|0
)braket
dot
id|match
suffix:semicolon
id|diff_opts.break_opt
op_assign
id|opt-&gt;break_opt
suffix:semicolon
id|diff_opts.rename_score
op_assign
id|opt-&gt;rename_score
suffix:semicolon
id|diff_setup_done
c_func
(paren
op_amp
id|diff_opts
)paren
suffix:semicolon
id|ll_diff_tree_sha1
c_func
(paren
id|old
comma
r_new
comma
id|base
comma
op_amp
id|diff_opts
)paren
suffix:semicolon
id|diffcore_std
c_func
(paren
op_amp
id|diff_opts
)paren
suffix:semicolon
id|free_pathspec
c_func
(paren
op_amp
id|diff_opts.pathspec
)paren
suffix:semicolon
multiline_comment|/* Go through the new set of filepairing, and see if we find a more interesting one */
id|opt-&gt;found_follow
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|q-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|diff_filepair
op_star
id|p
op_assign
id|q-&gt;queue
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Found a source? Not only do we use that for the new&n;&t;&t; * diff_queued_diff, we will also use that as the path in&n;&t;&t; * the future!&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|p-&gt;status
op_eq
l_char|&squot;R&squot;
op_logical_or
id|p-&gt;status
op_eq
l_char|&squot;C&squot;
)paren
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|p-&gt;two-&gt;path
comma
id|opt-&gt;pathspec.items
(braket
l_int|0
)braket
dot
id|match
)paren
)paren
(brace
r_const
r_char
op_star
id|path
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* Switch the file-pairs around */
id|q-&gt;queue
(braket
id|i
)braket
op_assign
id|choice
suffix:semicolon
id|choice
op_assign
id|p
suffix:semicolon
multiline_comment|/* Update the path we use from now on.. */
id|path
(braket
l_int|0
)braket
op_assign
id|p-&gt;one-&gt;path
suffix:semicolon
id|path
(braket
l_int|1
)braket
op_assign
l_int|NULL
suffix:semicolon
id|free_pathspec
c_func
(paren
op_amp
id|opt-&gt;pathspec
)paren
suffix:semicolon
id|parse_pathspec
c_func
(paren
op_amp
id|opt-&gt;pathspec
comma
id|PATHSPEC_ALL_MAGIC
op_amp
op_complement
id|PATHSPEC_LITERAL
comma
id|PATHSPEC_LITERAL_PATH
comma
l_string|&quot;&quot;
comma
id|path
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * The caller expects us to return a set of vanilla&n;&t;&t;&t; * filepairs to let a later call to diffcore_std()&n;&t;&t;&t; * it makes to sort the renames out (among other&n;&t;&t;&t; * things), but we already have found renames&n;&t;&t;&t; * ourselves; signal diffcore_std() not to muck with&n;&t;&t;&t; * rename information.&n;&t;&t;&t; */
id|opt-&gt;found_follow
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Then, discard all the non-relevant file pairs...&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|q-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|diff_filepair
op_star
id|p
op_assign
id|q-&gt;queue
(braket
id|i
)braket
suffix:semicolon
id|diff_free_filepair
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * .. and re-instate the one we want (which might be either the&n;&t; * original one, or the rename/copy we found)&n;&t; */
id|q-&gt;queue
(braket
l_int|0
)braket
op_assign
id|choice
suffix:semicolon
id|q-&gt;nr
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|ll_diff_tree_sha1
r_static
r_int
id|ll_diff_tree_sha1
c_func
(paren
r_const
r_int
r_char
op_star
id|old
comma
r_const
r_int
r_char
op_star
r_new
comma
r_struct
id|strbuf
op_star
id|base
comma
r_struct
id|diff_options
op_star
id|opt
)paren
(brace
r_struct
id|combine_diff_path
id|phead
comma
op_star
id|p
suffix:semicolon
id|pathchange_fn_t
id|pathchange_old
op_assign
id|opt-&gt;pathchange
suffix:semicolon
id|phead.next
op_assign
l_int|NULL
suffix:semicolon
id|opt-&gt;pathchange
op_assign
id|emit_diff_first_parent_only
suffix:semicolon
id|diff_tree_paths
c_func
(paren
op_amp
id|phead
comma
r_new
comma
op_amp
id|old
comma
l_int|1
comma
id|base
comma
id|opt
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|phead.next
suffix:semicolon
id|p
suffix:semicolon
)paren
(brace
r_struct
id|combine_diff_path
op_star
id|pprev
op_assign
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
suffix:semicolon
id|free
c_func
(paren
id|pprev
)paren
suffix:semicolon
)brace
id|opt-&gt;pathchange
op_assign
id|pathchange_old
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|diff_tree_sha1
r_int
id|diff_tree_sha1
c_func
(paren
r_const
r_int
r_char
op_star
id|old
comma
r_const
r_int
r_char
op_star
r_new
comma
r_const
r_char
op_star
id|base_str
comma
r_struct
id|diff_options
op_star
id|opt
)paren
(brace
r_struct
id|strbuf
id|base
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|base
comma
id|PATH_MAX
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|base
comma
id|base_str
)paren
suffix:semicolon
id|retval
op_assign
id|ll_diff_tree_sha1
c_func
(paren
id|old
comma
r_new
comma
op_amp
id|base
comma
id|opt
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|base_str
op_logical_and
id|DIFF_OPT_TST
c_func
(paren
id|opt
comma
id|FOLLOW_RENAMES
)paren
op_logical_and
id|diff_might_be_rename
c_func
(paren
)paren
)paren
id|try_to_follow_renames
c_func
(paren
id|old
comma
r_new
comma
op_amp
id|base
comma
id|opt
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|base
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|diff_root_tree_sha1
r_int
id|diff_root_tree_sha1
c_func
(paren
r_const
r_int
r_char
op_star
r_new
comma
r_const
r_char
op_star
id|base
comma
r_struct
id|diff_options
op_star
id|opt
)paren
(brace
r_return
id|diff_tree_sha1
c_func
(paren
l_int|NULL
comma
r_new
comma
id|base
comma
id|opt
)paren
suffix:semicolon
)brace
eof
