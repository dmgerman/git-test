macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;tag.h&quot;
macro_line|#include &quot;blob.h&quot;
macro_line|#include &quot;tree.h&quot;
macro_line|#include &quot;commit.h&quot;
macro_line|#include &quot;diff.h&quot;
macro_line|#include &quot;refs.h&quot;
macro_line|#include &quot;revision.h&quot;
macro_line|#include &lt;regex.h&gt;
macro_line|#include &quot;grep.h&quot;
DECL|function|path_name
r_static
r_char
op_star
id|path_name
c_func
(paren
r_struct
id|name_path
op_star
id|path
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|name_path
op_star
id|p
suffix:semicolon
r_char
op_star
id|n
comma
op_star
id|m
suffix:semicolon
r_int
id|nlen
op_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
r_int
id|len
op_assign
id|nlen
op_plus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|path
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;up
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;elem_len
)paren
id|len
op_add_assign
id|p-&gt;elem_len
op_plus
l_int|1
suffix:semicolon
)brace
id|n
op_assign
id|xmalloc
c_func
(paren
id|len
)paren
suffix:semicolon
id|m
op_assign
id|n
op_plus
id|len
(paren
id|nlen
op_plus
l_int|1
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|m
comma
id|name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|path
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;up
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;elem_len
)paren
(brace
id|m
op_sub_assign
id|p-&gt;elem_len
op_plus
l_int|1
suffix:semicolon
id|memcpy
c_func
(paren
id|m
comma
id|p-&gt;elem
comma
id|p-&gt;elem_len
)paren
suffix:semicolon
id|m
(braket
id|p-&gt;elem_len
)braket
op_assign
l_char|&squot;/&squot;
suffix:semicolon
)brace
)brace
r_return
id|n
suffix:semicolon
)brace
DECL|function|add_object
r_void
id|add_object
c_func
(paren
r_struct
id|object
op_star
id|obj
comma
r_struct
id|object_array
op_star
id|p
comma
r_struct
id|name_path
op_star
id|path
comma
r_const
r_char
op_star
id|name
)paren
(brace
id|add_object_array
c_func
(paren
id|obj
comma
id|path_name
c_func
(paren
id|path
comma
id|name
)paren
comma
id|p
)paren
suffix:semicolon
)brace
DECL|function|mark_blob_uninteresting
r_static
r_void
id|mark_blob_uninteresting
c_func
(paren
r_struct
id|blob
op_star
id|blob
)paren
(brace
r_if
c_cond
(paren
id|blob-&gt;object.flags
op_amp
id|UNINTERESTING
)paren
r_return
suffix:semicolon
id|blob-&gt;object.flags
op_or_assign
id|UNINTERESTING
suffix:semicolon
)brace
DECL|function|mark_tree_uninteresting
r_void
id|mark_tree_uninteresting
c_func
(paren
r_struct
id|tree
op_star
id|tree
)paren
(brace
r_struct
id|tree_desc
id|desc
suffix:semicolon
r_struct
id|name_entry
id|entry
suffix:semicolon
r_struct
id|object
op_star
id|obj
op_assign
op_amp
id|tree-&gt;object
suffix:semicolon
r_if
c_cond
(paren
id|obj-&gt;flags
op_amp
id|UNINTERESTING
)paren
r_return
suffix:semicolon
id|obj-&gt;flags
op_or_assign
id|UNINTERESTING
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|has_sha1_file
c_func
(paren
id|obj-&gt;sha1
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|parse_tree
c_func
(paren
id|tree
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;bad tree %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|obj-&gt;sha1
)paren
)paren
suffix:semicolon
id|desc.buf
op_assign
id|tree-&gt;buffer
suffix:semicolon
id|desc.size
op_assign
id|tree-&gt;size
suffix:semicolon
r_while
c_loop
(paren
id|tree_entry
c_func
(paren
op_amp
id|desc
comma
op_amp
id|entry
)paren
)paren
(brace
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|entry.mode
)paren
)paren
id|mark_tree_uninteresting
c_func
(paren
id|lookup_tree
c_func
(paren
id|entry.sha1
)paren
)paren
suffix:semicolon
r_else
id|mark_blob_uninteresting
c_func
(paren
id|lookup_blob
c_func
(paren
id|entry.sha1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We don&squot;t care about the tree any more&n;&t; * after it has been marked uninteresting.&n;&t; */
id|free
c_func
(paren
id|tree-&gt;buffer
)paren
suffix:semicolon
id|tree-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|mark_parents_uninteresting
r_void
id|mark_parents_uninteresting
c_func
(paren
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_struct
id|commit_list
op_star
id|parents
op_assign
id|commit-&gt;parents
suffix:semicolon
r_while
c_loop
(paren
id|parents
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
id|parents-&gt;item
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|commit-&gt;object.flags
op_amp
id|UNINTERESTING
)paren
)paren
(brace
id|commit-&gt;object.flags
op_or_assign
id|UNINTERESTING
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Normally we haven&squot;t parsed the parent&n;&t;&t;&t; * yet, so we won&squot;t have a parent of a parent&n;&t;&t;&t; * here. However, it may turn out that we&squot;ve&n;&t;&t;&t; * reached this commit some other way (where it&n;&t;&t;&t; * wasn&squot;t uninteresting), in which case we need&n;&t;&t;&t; * to mark its parents recursively too..&n;&t;&t;&t; */
r_if
c_cond
(paren
id|commit-&gt;parents
)paren
id|mark_parents_uninteresting
c_func
(paren
id|commit
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * A missing commit is ok iff its parent is marked&n;&t;&t; * uninteresting.&n;&t;&t; *&n;&t;&t; * We just mark such a thing parsed, so that when&n;&t;&t; * it is popped next time around, we won&squot;t be trying&n;&t;&t; * to parse it and get an error.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|has_sha1_file
c_func
(paren
id|commit-&gt;object.sha1
)paren
)paren
id|commit-&gt;object.parsed
op_assign
l_int|1
suffix:semicolon
id|parents
op_assign
id|parents-&gt;next
suffix:semicolon
)brace
)brace
DECL|function|add_pending_object
r_void
id|add_pending_object
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_struct
id|object
op_star
id|obj
comma
r_const
r_char
op_star
id|name
)paren
(brace
id|add_object_array
c_func
(paren
id|obj
comma
id|name
comma
op_amp
id|revs-&gt;pending
)paren
suffix:semicolon
)brace
DECL|function|get_reference
r_static
r_struct
id|object
op_star
id|get_reference
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_const
r_char
op_star
id|name
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
r_int
id|flags
)paren
(brace
r_struct
id|object
op_star
id|object
suffix:semicolon
id|object
op_assign
id|parse_object
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|object
)paren
id|die
c_func
(paren
l_string|&quot;bad object %s&quot;
comma
id|name
)paren
suffix:semicolon
id|object-&gt;flags
op_or_assign
id|flags
suffix:semicolon
r_return
id|object
suffix:semicolon
)brace
DECL|function|handle_commit
r_static
r_struct
id|commit
op_star
id|handle_commit
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_struct
id|object
op_star
id|object
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_int
r_int
id|flags
op_assign
id|object-&gt;flags
suffix:semicolon
multiline_comment|/*&n;&t; * Tag object? Look what it points to..&n;&t; */
r_while
c_loop
(paren
id|object-&gt;type
op_eq
id|OBJ_TAG
)paren
(brace
r_struct
id|tag
op_star
id|tag
op_assign
(paren
r_struct
id|tag
op_star
)paren
id|object
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;tag_objects
op_logical_and
op_logical_neg
(paren
id|flags
op_amp
id|UNINTERESTING
)paren
)paren
id|add_pending_object
c_func
(paren
id|revs
comma
id|object
comma
id|tag-&gt;tag
)paren
suffix:semicolon
id|object
op_assign
id|parse_object
c_func
(paren
id|tag-&gt;tagged-&gt;sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|object
)paren
id|die
c_func
(paren
l_string|&quot;bad object %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|tag-&gt;tagged-&gt;sha1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Commit object? Just return it, we&squot;ll do all the complex&n;&t; * reachability crud.&n;&t; */
r_if
c_cond
(paren
id|object-&gt;type
op_eq
id|OBJ_COMMIT
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
(paren
r_struct
id|commit
op_star
)paren
id|object
suffix:semicolon
r_if
c_cond
(paren
id|parse_commit
c_func
(paren
id|commit
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;unable to parse commit %s&quot;
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|UNINTERESTING
)paren
(brace
id|commit-&gt;object.flags
op_or_assign
id|UNINTERESTING
suffix:semicolon
id|mark_parents_uninteresting
c_func
(paren
id|commit
)paren
suffix:semicolon
id|revs-&gt;limited
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|commit
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Tree object? Either mark it uniniteresting, or add it&n;&t; * to the list of objects to look at later..&n;&t; */
r_if
c_cond
(paren
id|object-&gt;type
op_eq
id|OBJ_TREE
)paren
(brace
r_struct
id|tree
op_star
id|tree
op_assign
(paren
r_struct
id|tree
op_star
)paren
id|object
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|revs-&gt;tree_objects
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|UNINTERESTING
)paren
(brace
id|mark_tree_uninteresting
c_func
(paren
id|tree
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|add_pending_object
c_func
(paren
id|revs
comma
id|object
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Blob object? You know the drill by now..&n;&t; */
r_if
c_cond
(paren
id|object-&gt;type
op_eq
id|OBJ_BLOB
)paren
(brace
r_struct
id|blob
op_star
id|blob
op_assign
(paren
r_struct
id|blob
op_star
)paren
id|object
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|revs-&gt;blob_objects
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|UNINTERESTING
)paren
(brace
id|mark_blob_uninteresting
c_func
(paren
id|blob
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|add_pending_object
c_func
(paren
id|revs
comma
id|object
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|die
c_func
(paren
l_string|&quot;%s is unknown object&quot;
comma
id|name
)paren
suffix:semicolon
)brace
DECL|function|everybody_uninteresting
r_static
r_int
id|everybody_uninteresting
c_func
(paren
r_struct
id|commit_list
op_star
id|orig
)paren
(brace
r_struct
id|commit_list
op_star
id|list
op_assign
id|orig
suffix:semicolon
r_while
c_loop
(paren
id|list
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
id|list-&gt;item
suffix:semicolon
id|list
op_assign
id|list-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|commit-&gt;object.flags
op_amp
id|UNINTERESTING
)paren
r_continue
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|variable|tree_difference
r_static
r_int
id|tree_difference
op_assign
id|REV_TREE_SAME
suffix:semicolon
DECL|function|file_add_remove
r_static
r_void
id|file_add_remove
c_func
(paren
r_struct
id|diff_options
op_star
id|options
comma
r_int
id|addremove
comma
r_int
id|mode
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_const
r_char
op_star
id|base
comma
r_const
r_char
op_star
id|path
)paren
(brace
r_int
id|diff
op_assign
id|REV_TREE_DIFFERENT
suffix:semicolon
multiline_comment|/*&n;&t; * Is it an add of a new file? It means that the old tree&n;&t; * didn&squot;t have it at all, so we will turn &quot;REV_TREE_SAME&quot; -&gt;&n;&t; * &quot;REV_TREE_NEW&quot;, but leave any &quot;REV_TREE_DIFFERENT&quot; alone&n;&t; * (and if it already was &quot;REV_TREE_NEW&quot;, we&squot;ll keep it&n;&t; * &quot;REV_TREE_NEW&quot; of course).&n;&t; */
r_if
c_cond
(paren
id|addremove
op_eq
l_char|&squot;+&squot;
)paren
(brace
id|diff
op_assign
id|tree_difference
suffix:semicolon
r_if
c_cond
(paren
id|diff
op_ne
id|REV_TREE_SAME
)paren
r_return
suffix:semicolon
id|diff
op_assign
id|REV_TREE_NEW
suffix:semicolon
)brace
id|tree_difference
op_assign
id|diff
suffix:semicolon
)brace
DECL|function|file_change
r_static
r_void
id|file_change
c_func
(paren
r_struct
id|diff_options
op_star
id|options
comma
r_int
id|old_mode
comma
r_int
id|new_mode
comma
r_const
r_int
r_char
op_star
id|old_sha1
comma
r_const
r_int
r_char
op_star
id|new_sha1
comma
r_const
r_char
op_star
id|base
comma
r_const
r_char
op_star
id|path
)paren
(brace
id|tree_difference
op_assign
id|REV_TREE_DIFFERENT
suffix:semicolon
)brace
DECL|function|rev_compare_tree
r_int
id|rev_compare_tree
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_struct
id|tree
op_star
id|t1
comma
r_struct
id|tree
op_star
id|t2
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|t1
)paren
r_return
id|REV_TREE_NEW
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|t2
)paren
r_return
id|REV_TREE_DIFFERENT
suffix:semicolon
id|tree_difference
op_assign
id|REV_TREE_SAME
suffix:semicolon
r_if
c_cond
(paren
id|diff_tree_sha1
c_func
(paren
id|t1-&gt;object.sha1
comma
id|t2-&gt;object.sha1
comma
l_string|&quot;&quot;
comma
op_amp
id|revs-&gt;pruning
)paren
OL
l_int|0
)paren
r_return
id|REV_TREE_DIFFERENT
suffix:semicolon
r_return
id|tree_difference
suffix:semicolon
)brace
DECL|function|rev_same_tree_as_empty
r_int
id|rev_same_tree_as_empty
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_struct
id|tree
op_star
id|t1
)paren
(brace
r_int
id|retval
suffix:semicolon
r_void
op_star
id|tree
suffix:semicolon
r_struct
id|tree_desc
id|empty
comma
id|real
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|t1
)paren
r_return
l_int|0
suffix:semicolon
id|tree
op_assign
id|read_object_with_reference
c_func
(paren
id|t1-&gt;object.sha1
comma
id|tree_type
comma
op_amp
id|real.size
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tree
)paren
r_return
l_int|0
suffix:semicolon
id|real.buf
op_assign
id|tree
suffix:semicolon
id|empty.buf
op_assign
l_string|&quot;&quot;
suffix:semicolon
id|empty.size
op_assign
l_int|0
suffix:semicolon
id|tree_difference
op_assign
l_int|0
suffix:semicolon
id|retval
op_assign
id|diff_tree
c_func
(paren
op_amp
id|empty
comma
op_amp
id|real
comma
l_string|&quot;&quot;
comma
op_amp
id|revs-&gt;pruning
)paren
suffix:semicolon
id|free
c_func
(paren
id|tree
)paren
suffix:semicolon
r_return
id|retval
op_ge
l_int|0
op_logical_and
op_logical_neg
id|tree_difference
suffix:semicolon
)brace
DECL|function|try_to_simplify_commit
r_static
r_void
id|try_to_simplify_commit
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_struct
id|commit_list
op_star
op_star
id|pp
comma
op_star
id|parent
suffix:semicolon
r_int
id|tree_changed
op_assign
l_int|0
comma
id|tree_same
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|commit-&gt;tree
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|commit-&gt;parents
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|rev_same_tree_as_empty
c_func
(paren
id|revs
comma
id|commit-&gt;tree
)paren
)paren
id|commit-&gt;object.flags
op_or_assign
id|TREECHANGE
suffix:semicolon
r_return
suffix:semicolon
)brace
id|pp
op_assign
op_amp
id|commit-&gt;parents
suffix:semicolon
r_while
c_loop
(paren
(paren
id|parent
op_assign
op_star
id|pp
)paren
op_ne
l_int|NULL
)paren
(brace
r_struct
id|commit
op_star
id|p
op_assign
id|parent-&gt;item
suffix:semicolon
id|parse_commit
c_func
(paren
id|p
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|rev_compare_tree
c_func
(paren
id|revs
comma
id|p-&gt;tree
comma
id|commit-&gt;tree
)paren
)paren
(brace
r_case
id|REV_TREE_SAME
suffix:colon
id|tree_same
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|revs-&gt;simplify_history
op_logical_or
(paren
id|p-&gt;object.flags
op_amp
id|UNINTERESTING
)paren
)paren
(brace
multiline_comment|/* Even if a merge with an uninteresting&n;&t;&t;&t;&t; * side branch brought the entire change&n;&t;&t;&t;&t; * we are interested in, we do not want&n;&t;&t;&t;&t; * to lose the other branches of this&n;&t;&t;&t;&t; * merge, so we just keep going.&n;&t;&t;&t;&t; */
id|pp
op_assign
op_amp
id|parent-&gt;next
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|parent-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|commit-&gt;parents
op_assign
id|parent
suffix:semicolon
r_return
suffix:semicolon
r_case
id|REV_TREE_NEW
suffix:colon
r_if
c_cond
(paren
id|revs-&gt;remove_empty_trees
op_logical_and
id|rev_same_tree_as_empty
c_func
(paren
id|revs
comma
id|p-&gt;tree
)paren
)paren
(brace
multiline_comment|/* We are adding all the specified&n;&t;&t;&t;&t; * paths from this parent, so the&n;&t;&t;&t;&t; * history beyond this parent is not&n;&t;&t;&t;&t; * interesting.  Remove its parents&n;&t;&t;&t;&t; * (they are grandparents for us).&n;&t;&t;&t;&t; * IOW, we pretend this parent is a&n;&t;&t;&t;&t; * &quot;root&quot; commit.&n;&t;&t;&t;&t; */
id|parse_commit
c_func
(paren
id|p
)paren
suffix:semicolon
id|p-&gt;parents
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* fallthrough */
r_case
id|REV_TREE_DIFFERENT
suffix:colon
id|tree_changed
op_assign
l_int|1
suffix:semicolon
id|pp
op_assign
op_amp
id|parent-&gt;next
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|die
c_func
(paren
l_string|&quot;bad tree compare for commit %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|commit-&gt;object.sha1
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tree_changed
op_logical_and
op_logical_neg
id|tree_same
)paren
id|commit-&gt;object.flags
op_or_assign
id|TREECHANGE
suffix:semicolon
)brace
DECL|function|add_parents_to_list
r_static
r_void
id|add_parents_to_list
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_struct
id|commit
op_star
id|commit
comma
r_struct
id|commit_list
op_star
op_star
id|list
)paren
(brace
r_struct
id|commit_list
op_star
id|parent
op_assign
id|commit-&gt;parents
suffix:semicolon
r_if
c_cond
(paren
id|commit-&gt;object.flags
op_amp
id|ADDED
)paren
r_return
suffix:semicolon
id|commit-&gt;object.flags
op_or_assign
id|ADDED
suffix:semicolon
multiline_comment|/*&n;&t; * If the commit is uninteresting, don&squot;t try to&n;&t; * prune parents - we want the maximal uninteresting&n;&t; * set.&n;&t; *&n;&t; * Normally we haven&squot;t parsed the parent&n;&t; * yet, so we won&squot;t have a parent of a parent&n;&t; * here. However, it may turn out that we&squot;ve&n;&t; * reached this commit some other way (where it&n;&t; * wasn&squot;t uninteresting), in which case we need&n;&t; * to mark its parents recursively too..&n;&t; */
r_if
c_cond
(paren
id|commit-&gt;object.flags
op_amp
id|UNINTERESTING
)paren
(brace
r_while
c_loop
(paren
id|parent
)paren
(brace
r_struct
id|commit
op_star
id|p
op_assign
id|parent-&gt;item
suffix:semicolon
id|parent
op_assign
id|parent-&gt;next
suffix:semicolon
id|parse_commit
c_func
(paren
id|p
)paren
suffix:semicolon
id|p-&gt;object.flags
op_or_assign
id|UNINTERESTING
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;parents
)paren
id|mark_parents_uninteresting
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;object.flags
op_amp
id|SEEN
)paren
r_continue
suffix:semicolon
id|p-&gt;object.flags
op_or_assign
id|SEEN
suffix:semicolon
id|insert_by_date
c_func
(paren
id|p
comma
id|list
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Ok, the commit wasn&squot;t uninteresting. Try to&n;&t; * simplify the commit history and find the parent&n;&t; * that has no differences in the path set if one exists.&n;&t; */
r_if
c_cond
(paren
id|revs-&gt;prune_fn
)paren
id|revs
op_member_access_from_pointer
id|prune_fn
c_func
(paren
id|revs
comma
id|commit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;no_walk
)paren
r_return
suffix:semicolon
id|parent
op_assign
id|commit-&gt;parents
suffix:semicolon
r_while
c_loop
(paren
id|parent
)paren
(brace
r_struct
id|commit
op_star
id|p
op_assign
id|parent-&gt;item
suffix:semicolon
id|parent
op_assign
id|parent-&gt;next
suffix:semicolon
id|parse_commit
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;object.flags
op_amp
id|SEEN
)paren
r_continue
suffix:semicolon
id|p-&gt;object.flags
op_or_assign
id|SEEN
suffix:semicolon
id|insert_by_date
c_func
(paren
id|p
comma
id|list
)paren
suffix:semicolon
)brace
)brace
DECL|function|limit_list
r_static
r_void
id|limit_list
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
)paren
(brace
r_struct
id|commit_list
op_star
id|list
op_assign
id|revs-&gt;commits
suffix:semicolon
r_struct
id|commit_list
op_star
id|newlist
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|commit_list
op_star
op_star
id|p
op_assign
op_amp
id|newlist
suffix:semicolon
r_while
c_loop
(paren
id|list
)paren
(brace
r_struct
id|commit_list
op_star
id|entry
op_assign
id|list
suffix:semicolon
r_struct
id|commit
op_star
id|commit
op_assign
id|list-&gt;item
suffix:semicolon
r_struct
id|object
op_star
id|obj
op_assign
op_amp
id|commit-&gt;object
suffix:semicolon
id|list
op_assign
id|list-&gt;next
suffix:semicolon
id|free
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;max_age
op_ne
l_int|1
op_logical_and
(paren
id|commit-&gt;date
OL
id|revs-&gt;max_age
)paren
)paren
id|obj-&gt;flags
op_or_assign
id|UNINTERESTING
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;unpacked
op_logical_and
id|has_sha1_pack
c_func
(paren
id|obj-&gt;sha1
comma
id|revs-&gt;ignore_packed
)paren
)paren
id|obj-&gt;flags
op_or_assign
id|UNINTERESTING
suffix:semicolon
id|add_parents_to_list
c_func
(paren
id|revs
comma
id|commit
comma
op_amp
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|obj-&gt;flags
op_amp
id|UNINTERESTING
)paren
(brace
id|mark_parents_uninteresting
c_func
(paren
id|commit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|everybody_uninteresting
c_func
(paren
id|list
)paren
)paren
r_break
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|revs-&gt;min_age
op_ne
l_int|1
op_logical_and
(paren
id|commit-&gt;date
OG
id|revs-&gt;min_age
)paren
)paren
r_continue
suffix:semicolon
id|p
op_assign
op_amp
id|commit_list_insert
c_func
(paren
id|commit
comma
id|p
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|revs-&gt;boundary
)paren
(brace
multiline_comment|/* mark the ones that are on the result list first */
r_for
c_loop
(paren
id|list
op_assign
id|newlist
suffix:semicolon
id|list
suffix:semicolon
id|list
op_assign
id|list-&gt;next
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
id|list-&gt;item
suffix:semicolon
id|commit-&gt;object.flags
op_or_assign
id|TMP_MARK
suffix:semicolon
)brace
r_for
c_loop
(paren
id|list
op_assign
id|newlist
suffix:semicolon
id|list
suffix:semicolon
id|list
op_assign
id|list-&gt;next
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
id|list-&gt;item
suffix:semicolon
r_struct
id|object
op_star
id|obj
op_assign
op_amp
id|commit-&gt;object
suffix:semicolon
r_struct
id|commit_list
op_star
id|parent
suffix:semicolon
r_if
c_cond
(paren
id|obj-&gt;flags
op_amp
id|UNINTERESTING
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|parent
op_assign
id|commit-&gt;parents
suffix:semicolon
id|parent
suffix:semicolon
id|parent
op_assign
id|parent-&gt;next
)paren
(brace
r_struct
id|commit
op_star
id|pcommit
op_assign
id|parent-&gt;item
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|pcommit-&gt;object.flags
op_amp
id|UNINTERESTING
)paren
)paren
r_continue
suffix:semicolon
id|pcommit-&gt;object.flags
op_or_assign
id|BOUNDARY
suffix:semicolon
r_if
c_cond
(paren
id|pcommit-&gt;object.flags
op_amp
id|TMP_MARK
)paren
r_continue
suffix:semicolon
id|pcommit-&gt;object.flags
op_or_assign
id|TMP_MARK
suffix:semicolon
id|p
op_assign
op_amp
id|commit_list_insert
c_func
(paren
id|pcommit
comma
id|p
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|list
op_assign
id|newlist
suffix:semicolon
id|list
suffix:semicolon
id|list
op_assign
id|list-&gt;next
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
id|list-&gt;item
suffix:semicolon
id|commit-&gt;object.flags
op_and_assign
op_complement
id|TMP_MARK
suffix:semicolon
)brace
)brace
id|revs-&gt;commits
op_assign
id|newlist
suffix:semicolon
)brace
DECL|variable|all_flags
r_static
r_int
id|all_flags
suffix:semicolon
DECL|variable|all_revs
r_static
r_struct
id|rev_info
op_star
id|all_revs
suffix:semicolon
DECL|function|handle_one_ref
r_static
r_int
id|handle_one_ref
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_struct
id|object
op_star
id|object
op_assign
id|get_reference
c_func
(paren
id|all_revs
comma
id|path
comma
id|sha1
comma
id|all_flags
)paren
suffix:semicolon
id|add_pending_object
c_func
(paren
id|all_revs
comma
id|object
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|handle_all
r_static
r_void
id|handle_all
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_int
id|flags
)paren
(brace
id|all_revs
op_assign
id|revs
suffix:semicolon
id|all_flags
op_assign
id|flags
suffix:semicolon
id|for_each_ref
c_func
(paren
id|handle_one_ref
)paren
suffix:semicolon
)brace
DECL|function|add_parents_only
r_static
r_int
id|add_parents_only
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_const
r_char
op_star
id|arg
comma
r_int
id|flags
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_struct
id|object
op_star
id|it
suffix:semicolon
r_struct
id|commit
op_star
id|commit
suffix:semicolon
r_struct
id|commit_list
op_star
id|parents
suffix:semicolon
r_if
c_cond
(paren
op_star
id|arg
op_eq
l_char|&squot;^&squot;
)paren
(brace
id|flags
op_xor_assign
id|UNINTERESTING
suffix:semicolon
id|arg
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|get_sha1
c_func
(paren
id|arg
comma
id|sha1
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|it
op_assign
id|get_reference
c_func
(paren
id|revs
comma
id|arg
comma
id|sha1
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|it-&gt;type
op_ne
id|OBJ_TAG
)paren
r_break
suffix:semicolon
id|hashcpy
c_func
(paren
id|sha1
comma
(paren
(paren
r_struct
id|tag
op_star
)paren
id|it
)paren
op_member_access_from_pointer
id|tagged-&gt;sha1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|it-&gt;type
op_ne
id|OBJ_COMMIT
)paren
r_return
l_int|0
suffix:semicolon
id|commit
op_assign
(paren
r_struct
id|commit
op_star
)paren
id|it
suffix:semicolon
r_for
c_loop
(paren
id|parents
op_assign
id|commit-&gt;parents
suffix:semicolon
id|parents
suffix:semicolon
id|parents
op_assign
id|parents-&gt;next
)paren
(brace
id|it
op_assign
op_amp
id|parents-&gt;item-&gt;object
suffix:semicolon
id|it-&gt;flags
op_or_assign
id|flags
suffix:semicolon
id|add_pending_object
c_func
(paren
id|revs
comma
id|it
comma
id|arg
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|init_revisions
r_void
id|init_revisions
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_const
r_char
op_star
id|prefix
)paren
(brace
id|memset
c_func
(paren
id|revs
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|revs
)paren
)paren
suffix:semicolon
id|revs-&gt;abbrev
op_assign
id|DEFAULT_ABBREV
suffix:semicolon
id|revs-&gt;ignore_merges
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;simplify_history
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;pruning.recursive
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;pruning.add_remove
op_assign
id|file_add_remove
suffix:semicolon
id|revs-&gt;pruning.change
op_assign
id|file_change
suffix:semicolon
id|revs-&gt;lifo
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;dense
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;prefix
op_assign
id|prefix
suffix:semicolon
id|revs-&gt;max_age
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;min_age
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;max_count
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;prune_fn
op_assign
l_int|NULL
suffix:semicolon
id|revs-&gt;prune_data
op_assign
l_int|NULL
suffix:semicolon
id|revs-&gt;topo_setter
op_assign
id|topo_sort_default_setter
suffix:semicolon
id|revs-&gt;topo_getter
op_assign
id|topo_sort_default_getter
suffix:semicolon
id|revs-&gt;commit_format
op_assign
id|CMIT_FMT_DEFAULT
suffix:semicolon
id|diff_setup
c_func
(paren
op_amp
id|revs-&gt;diffopt
)paren
suffix:semicolon
)brace
DECL|function|add_pending_commit_list
r_static
r_void
id|add_pending_commit_list
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_struct
id|commit_list
op_star
id|commit_list
comma
r_int
r_int
id|flags
)paren
(brace
r_while
c_loop
(paren
id|commit_list
)paren
(brace
r_struct
id|object
op_star
id|object
op_assign
op_amp
id|commit_list-&gt;item-&gt;object
suffix:semicolon
id|object-&gt;flags
op_or_assign
id|flags
suffix:semicolon
id|add_pending_object
c_func
(paren
id|revs
comma
id|object
comma
id|sha1_to_hex
c_func
(paren
id|object-&gt;sha1
)paren
)paren
suffix:semicolon
id|commit_list
op_assign
id|commit_list-&gt;next
suffix:semicolon
)brace
)brace
DECL|function|prepare_show_merge
r_static
r_void
id|prepare_show_merge
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
)paren
(brace
r_struct
id|commit_list
op_star
id|bases
suffix:semicolon
r_struct
id|commit
op_star
id|head
comma
op_star
id|other
suffix:semicolon
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_const
r_char
op_star
op_star
id|prune
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
comma
id|prune_num
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* counting terminating NULL */
r_if
c_cond
(paren
id|get_sha1
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|sha1
)paren
op_logical_or
op_logical_neg
(paren
id|head
op_assign
id|lookup_commit
c_func
(paren
id|sha1
)paren
)paren
)paren
id|die
c_func
(paren
l_string|&quot;--merge without HEAD?&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1
c_func
(paren
l_string|&quot;MERGE_HEAD&quot;
comma
id|sha1
)paren
op_logical_or
op_logical_neg
(paren
id|other
op_assign
id|lookup_commit
c_func
(paren
id|sha1
)paren
)paren
)paren
id|die
c_func
(paren
l_string|&quot;--merge without MERGE_HEAD?&quot;
)paren
suffix:semicolon
id|add_pending_object
c_func
(paren
id|revs
comma
op_amp
id|head-&gt;object
comma
l_string|&quot;HEAD&quot;
)paren
suffix:semicolon
id|add_pending_object
c_func
(paren
id|revs
comma
op_amp
id|other-&gt;object
comma
l_string|&quot;MERGE_HEAD&quot;
)paren
suffix:semicolon
id|bases
op_assign
id|get_merge_bases
c_func
(paren
id|head
comma
id|other
comma
l_int|1
)paren
suffix:semicolon
r_while
c_loop
(paren
id|bases
)paren
(brace
r_struct
id|commit
op_star
id|it
op_assign
id|bases-&gt;item
suffix:semicolon
r_struct
id|commit_list
op_star
id|n
op_assign
id|bases-&gt;next
suffix:semicolon
id|free
c_func
(paren
id|bases
)paren
suffix:semicolon
id|bases
op_assign
id|n
suffix:semicolon
id|it-&gt;object.flags
op_or_assign
id|UNINTERESTING
suffix:semicolon
id|add_pending_object
c_func
(paren
id|revs
comma
op_amp
id|it-&gt;object
comma
l_string|&quot;(merge-base)&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|active_nr
)paren
id|read_cache
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|active_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|cache_entry
op_star
id|ce
op_assign
id|active_cache
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ce_stage
c_func
(paren
id|ce
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|ce_path_match
c_func
(paren
id|ce
comma
id|revs-&gt;prune_data
)paren
)paren
(brace
id|prune_num
op_increment
suffix:semicolon
id|prune
op_assign
id|xrealloc
c_func
(paren
id|prune
comma
r_sizeof
(paren
op_star
id|prune
)paren
op_star
id|prune_num
)paren
suffix:semicolon
id|prune
(braket
id|prune_num
op_minus
l_int|2
)braket
op_assign
id|ce-&gt;name
suffix:semicolon
id|prune
(braket
id|prune_num
op_minus
l_int|1
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|i
op_plus
l_int|1
OL
id|active_nr
)paren
op_logical_and
id|ce_same_name
c_func
(paren
id|ce
comma
id|active_cache
(braket
id|i
op_plus
l_int|1
)braket
)paren
)paren
id|i
op_increment
suffix:semicolon
)brace
id|revs-&gt;prune_data
op_assign
id|prune
suffix:semicolon
)brace
DECL|function|handle_revision_arg
r_int
id|handle_revision_arg
c_func
(paren
r_const
r_char
op_star
id|arg
comma
r_struct
id|rev_info
op_star
id|revs
comma
r_int
id|flags
comma
r_int
id|cant_be_filename
)paren
(brace
r_char
op_star
id|dotdot
suffix:semicolon
r_struct
id|object
op_star
id|object
suffix:semicolon
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_int
id|local_flags
suffix:semicolon
id|dotdot
op_assign
id|strstr
c_func
(paren
id|arg
comma
l_string|&quot;..&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dotdot
)paren
(brace
r_int
r_char
id|from_sha1
(braket
l_int|20
)braket
suffix:semicolon
r_const
r_char
op_star
id|next
op_assign
id|dotdot
op_plus
l_int|2
suffix:semicolon
r_const
r_char
op_star
id|this
op_assign
id|arg
suffix:semicolon
r_int
id|symmetric
op_assign
op_star
id|next
op_eq
l_char|&squot;.&squot;
suffix:semicolon
r_int
r_int
id|flags_exclude
op_assign
id|flags
op_xor
id|UNINTERESTING
suffix:semicolon
op_star
id|dotdot
op_assign
l_int|0
suffix:semicolon
id|next
op_add_assign
id|symmetric
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|next
)paren
id|next
op_assign
l_string|&quot;HEAD&quot;
suffix:semicolon
r_if
c_cond
(paren
id|dotdot
op_eq
id|arg
)paren
id|this
op_assign
l_string|&quot;HEAD&quot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|get_sha1
c_func
(paren
id|this
comma
id|from_sha1
)paren
op_logical_and
op_logical_neg
id|get_sha1
c_func
(paren
id|next
comma
id|sha1
)paren
)paren
(brace
r_struct
id|commit
op_star
id|a
comma
op_star
id|b
suffix:semicolon
r_struct
id|commit_list
op_star
id|exclude
suffix:semicolon
id|a
op_assign
id|lookup_commit_reference
c_func
(paren
id|from_sha1
)paren
suffix:semicolon
id|b
op_assign
id|lookup_commit_reference
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|a
op_logical_or
op_logical_neg
id|b
)paren
(brace
id|die
c_func
(paren
id|symmetric
ques
c_cond
l_string|&quot;Invalid symmetric difference expression %s...%s&quot;
suffix:colon
l_string|&quot;Invalid revision range %s..%s&quot;
comma
id|arg
comma
id|next
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|cant_be_filename
)paren
(brace
op_star
id|dotdot
op_assign
l_char|&squot;.&squot;
suffix:semicolon
id|verify_non_filename
c_func
(paren
id|revs-&gt;prefix
comma
id|arg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|symmetric
)paren
(brace
id|exclude
op_assign
id|get_merge_bases
c_func
(paren
id|a
comma
id|b
comma
l_int|1
)paren
suffix:semicolon
id|add_pending_commit_list
c_func
(paren
id|revs
comma
id|exclude
comma
id|flags_exclude
)paren
suffix:semicolon
id|free_commit_list
c_func
(paren
id|exclude
)paren
suffix:semicolon
id|a-&gt;object.flags
op_or_assign
id|flags
suffix:semicolon
)brace
r_else
id|a-&gt;object.flags
op_or_assign
id|flags_exclude
suffix:semicolon
id|b-&gt;object.flags
op_or_assign
id|flags
suffix:semicolon
id|add_pending_object
c_func
(paren
id|revs
comma
op_amp
id|a-&gt;object
comma
id|this
)paren
suffix:semicolon
id|add_pending_object
c_func
(paren
id|revs
comma
op_amp
id|b-&gt;object
comma
id|next
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
op_star
id|dotdot
op_assign
l_char|&squot;.&squot;
suffix:semicolon
)brace
id|dotdot
op_assign
id|strstr
c_func
(paren
id|arg
comma
l_string|&quot;^@&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dotdot
op_logical_and
op_logical_neg
id|dotdot
(braket
l_int|2
)braket
)paren
(brace
op_star
id|dotdot
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|add_parents_only
c_func
(paren
id|revs
comma
id|arg
comma
id|flags
)paren
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|dotdot
op_assign
l_char|&squot;^&squot;
suffix:semicolon
)brace
id|local_flags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_star
id|arg
op_eq
l_char|&squot;^&squot;
)paren
(brace
id|local_flags
op_assign
id|UNINTERESTING
suffix:semicolon
id|arg
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|get_sha1
c_func
(paren
id|arg
comma
id|sha1
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cant_be_filename
)paren
id|verify_non_filename
c_func
(paren
id|revs-&gt;prefix
comma
id|arg
)paren
suffix:semicolon
id|object
op_assign
id|get_reference
c_func
(paren
id|revs
comma
id|arg
comma
id|sha1
comma
id|flags
op_xor
id|local_flags
)paren
suffix:semicolon
id|add_pending_object
c_func
(paren
id|revs
comma
id|object
comma
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|add_ignore_packed
r_static
r_void
id|add_ignore_packed
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_int
id|num
op_assign
op_increment
id|revs-&gt;num_ignore_packed
suffix:semicolon
id|revs-&gt;ignore_packed
op_assign
id|xrealloc
c_func
(paren
id|revs-&gt;ignore_packed
comma
r_sizeof
(paren
r_const
r_char
op_star
op_star
)paren
op_star
(paren
id|num
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|revs-&gt;ignore_packed
(braket
id|num
op_minus
l_int|1
)braket
op_assign
id|name
suffix:semicolon
id|revs-&gt;ignore_packed
(braket
id|num
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Parse revision information, filling in the &quot;rev_info&quot; structure,&n; * and removing the used arguments from the argument list.&n; *&n; * Returns the number of arguments left that weren&squot;t recognized&n; * (which are also moved to the head of the argument list)&n; */
DECL|function|setup_revisions
r_int
id|setup_revisions
c_func
(paren
r_int
id|argc
comma
r_const
r_char
op_star
op_star
id|argv
comma
r_struct
id|rev_info
op_star
id|revs
comma
r_const
r_char
op_star
id|def
)paren
(brace
r_int
id|i
comma
id|flags
comma
id|seen_dashdash
comma
id|show_merge
suffix:semicolon
r_const
r_char
op_star
op_star
id|unrecognized
op_assign
id|argv
op_plus
l_int|1
suffix:semicolon
r_int
id|left
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* First, search for &quot;--&quot; */
id|seen_dashdash
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|argc
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_char
op_star
id|arg
op_assign
id|argv
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--&quot;
)paren
)paren
r_continue
suffix:semicolon
id|argv
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|argc
op_assign
id|i
suffix:semicolon
id|revs-&gt;prune_data
op_assign
id|get_pathspec
c_func
(paren
id|revs-&gt;prefix
comma
id|argv
op_plus
id|i
op_plus
l_int|1
)paren
suffix:semicolon
id|seen_dashdash
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|flags
op_assign
id|show_merge
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|argc
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_char
op_star
id|arg
op_assign
id|argv
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_star
id|arg
op_eq
l_char|&squot;-&squot;
)paren
(brace
r_int
id|opts
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|arg
comma
l_string|&quot;--max-count=&quot;
comma
l_int|12
)paren
)paren
(brace
id|revs-&gt;max_count
op_assign
id|atoi
c_func
(paren
id|arg
op_plus
l_int|12
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* accept -&lt;digit&gt;, like traditional &quot;head&quot; */
r_if
c_cond
(paren
(paren
op_star
id|arg
op_eq
l_char|&squot;-&squot;
)paren
op_logical_and
id|isdigit
c_func
(paren
id|arg
(braket
l_int|1
)braket
)paren
)paren
(brace
id|revs-&gt;max_count
op_assign
id|atoi
c_func
(paren
id|arg
op_plus
l_int|1
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;-n&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|argc
op_le
id|i
op_plus
l_int|1
)paren
id|die
c_func
(paren
l_string|&quot;-n requires an argument&quot;
)paren
suffix:semicolon
id|revs-&gt;max_count
op_assign
id|atoi
c_func
(paren
id|argv
(braket
op_increment
id|i
)braket
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|arg
comma
l_string|&quot;-n&quot;
comma
l_int|2
)paren
)paren
(brace
id|revs-&gt;max_count
op_assign
id|atoi
c_func
(paren
id|arg
op_plus
l_int|2
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|arg
comma
l_string|&quot;--max-age=&quot;
comma
l_int|10
)paren
)paren
(brace
id|revs-&gt;max_age
op_assign
id|atoi
c_func
(paren
id|arg
op_plus
l_int|10
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|arg
comma
l_string|&quot;--since=&quot;
comma
l_int|8
)paren
)paren
(brace
id|revs-&gt;max_age
op_assign
id|approxidate
c_func
(paren
id|arg
op_plus
l_int|8
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|arg
comma
l_string|&quot;--after=&quot;
comma
l_int|8
)paren
)paren
(brace
id|revs-&gt;max_age
op_assign
id|approxidate
c_func
(paren
id|arg
op_plus
l_int|8
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|arg
comma
l_string|&quot;--min-age=&quot;
comma
l_int|10
)paren
)paren
(brace
id|revs-&gt;min_age
op_assign
id|atoi
c_func
(paren
id|arg
op_plus
l_int|10
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|arg
comma
l_string|&quot;--before=&quot;
comma
l_int|9
)paren
)paren
(brace
id|revs-&gt;min_age
op_assign
id|approxidate
c_func
(paren
id|arg
op_plus
l_int|9
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|arg
comma
l_string|&quot;--until=&quot;
comma
l_int|8
)paren
)paren
(brace
id|revs-&gt;min_age
op_assign
id|approxidate
c_func
(paren
id|arg
op_plus
l_int|8
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--all&quot;
)paren
)paren
(brace
id|handle_all
c_func
(paren
id|revs
comma
id|flags
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--not&quot;
)paren
)paren
(brace
id|flags
op_xor_assign
id|UNINTERESTING
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--default&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_increment
id|i
op_ge
id|argc
)paren
id|die
c_func
(paren
l_string|&quot;bad --default argument&quot;
)paren
suffix:semicolon
id|def
op_assign
id|argv
(braket
id|i
)braket
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--merge&quot;
)paren
)paren
(brace
id|show_merge
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--topo-order&quot;
)paren
)paren
(brace
id|revs-&gt;topo_order
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--date-order&quot;
)paren
)paren
(brace
id|revs-&gt;lifo
op_assign
l_int|0
suffix:semicolon
id|revs-&gt;topo_order
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--parents&quot;
)paren
)paren
(brace
id|revs-&gt;parents
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--dense&quot;
)paren
)paren
(brace
id|revs-&gt;dense
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--sparse&quot;
)paren
)paren
(brace
id|revs-&gt;dense
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--remove-empty&quot;
)paren
)paren
(brace
id|revs-&gt;remove_empty_trees
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--no-merges&quot;
)paren
)paren
(brace
id|revs-&gt;no_merges
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--boundary&quot;
)paren
)paren
(brace
id|revs-&gt;boundary
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--objects&quot;
)paren
)paren
(brace
id|revs-&gt;tag_objects
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;tree_objects
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;blob_objects
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--objects-edge&quot;
)paren
)paren
(brace
id|revs-&gt;tag_objects
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;tree_objects
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;blob_objects
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;edge_hint
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--unpacked&quot;
)paren
)paren
(brace
id|revs-&gt;unpacked
op_assign
l_int|1
suffix:semicolon
id|free
c_func
(paren
id|revs-&gt;ignore_packed
)paren
suffix:semicolon
id|revs-&gt;ignore_packed
op_assign
l_int|NULL
suffix:semicolon
id|revs-&gt;num_ignore_packed
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|arg
comma
l_string|&quot;--unpacked=&quot;
comma
l_int|11
)paren
)paren
(brace
id|revs-&gt;unpacked
op_assign
l_int|1
suffix:semicolon
id|add_ignore_packed
c_func
(paren
id|revs
comma
id|arg
op_plus
l_int|11
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;-r&quot;
)paren
)paren
(brace
id|revs-&gt;diff
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;diffopt.recursive
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;-t&quot;
)paren
)paren
(brace
id|revs-&gt;diff
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;diffopt.recursive
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;diffopt.tree_in_recursive
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;-m&quot;
)paren
)paren
(brace
id|revs-&gt;ignore_merges
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;-c&quot;
)paren
)paren
(brace
id|revs-&gt;diff
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;dense_combined_merges
op_assign
l_int|0
suffix:semicolon
id|revs-&gt;combine_merges
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--cc&quot;
)paren
)paren
(brace
id|revs-&gt;diff
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;dense_combined_merges
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;combine_merges
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;-v&quot;
)paren
)paren
(brace
id|revs-&gt;verbose_header
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|arg
comma
l_string|&quot;--pretty&quot;
comma
l_int|8
)paren
)paren
(brace
id|revs-&gt;verbose_header
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;commit_format
op_assign
id|get_commit_format
c_func
(paren
id|arg
op_plus
l_int|8
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--root&quot;
)paren
)paren
(brace
id|revs-&gt;show_root_diff
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--no-commit-id&quot;
)paren
)paren
(brace
id|revs-&gt;no_commit_id
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--always&quot;
)paren
)paren
(brace
id|revs-&gt;always_show_header
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--no-abbrev&quot;
)paren
)paren
(brace
id|revs-&gt;abbrev
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--abbrev&quot;
)paren
)paren
(brace
id|revs-&gt;abbrev
op_assign
id|DEFAULT_ABBREV
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|arg
comma
l_string|&quot;--abbrev=&quot;
comma
l_int|9
)paren
)paren
(brace
id|revs-&gt;abbrev
op_assign
id|strtoul
c_func
(paren
id|arg
op_plus
l_int|9
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;abbrev
OL
id|MINIMUM_ABBREV
)paren
id|revs-&gt;abbrev
op_assign
id|MINIMUM_ABBREV
suffix:semicolon
r_else
r_if
c_cond
(paren
id|revs-&gt;abbrev
OG
l_int|40
)paren
id|revs-&gt;abbrev
op_assign
l_int|40
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--abbrev-commit&quot;
)paren
)paren
(brace
id|revs-&gt;abbrev_commit
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--full-diff&quot;
)paren
)paren
(brace
id|revs-&gt;diff
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;full_diff
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--full-history&quot;
)paren
)paren
(brace
id|revs-&gt;simplify_history
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--relative-date&quot;
)paren
)paren
(brace
id|revs-&gt;relative_date
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|opts
op_assign
id|diff_opt_parse
c_func
(paren
op_amp
id|revs-&gt;diffopt
comma
id|argv
op_plus
id|i
comma
id|argc
op_minus
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opts
OG
l_int|0
)paren
(brace
id|revs-&gt;diff
op_assign
l_int|1
suffix:semicolon
id|i
op_add_assign
id|opts
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
op_star
id|unrecognized
op_increment
op_assign
id|arg
suffix:semicolon
id|left
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|handle_revision_arg
c_func
(paren
id|arg
comma
id|revs
comma
id|flags
comma
id|seen_dashdash
)paren
)paren
(brace
r_int
id|j
suffix:semicolon
r_if
c_cond
(paren
id|seen_dashdash
op_logical_or
op_star
id|arg
op_eq
l_char|&squot;^&squot;
)paren
id|die
c_func
(paren
l_string|&quot;bad revision &squot;%s&squot;&quot;
comma
id|arg
)paren
suffix:semicolon
multiline_comment|/* If we didn&squot;t have a &quot;--&quot;:&n;&t;&t;&t; * (1) all filenames must exist;&n;&t;&t;&t; * (2) all rev-args must not be interpretable&n;&t;&t;&t; *     as a valid filename.&n;&t;&t;&t; * but the latter we have checked in the main loop.&n;&t;&t;&t; */
r_for
c_loop
(paren
id|j
op_assign
id|i
suffix:semicolon
id|j
OL
id|argc
suffix:semicolon
id|j
op_increment
)paren
id|verify_filename
c_func
(paren
id|revs-&gt;prefix
comma
id|argv
(braket
id|j
)braket
)paren
suffix:semicolon
id|revs-&gt;prune_data
op_assign
id|get_pathspec
c_func
(paren
id|revs-&gt;prefix
comma
id|argv
op_plus
id|i
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|show_merge
)paren
id|prepare_show_merge
c_func
(paren
id|revs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|def
op_logical_and
op_logical_neg
id|revs-&gt;pending.nr
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_struct
id|object
op_star
id|object
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1
c_func
(paren
id|def
comma
id|sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;bad default revision &squot;%s&squot;&quot;
comma
id|def
)paren
suffix:semicolon
id|object
op_assign
id|get_reference
c_func
(paren
id|revs
comma
id|def
comma
id|sha1
comma
l_int|0
)paren
suffix:semicolon
id|add_pending_object
c_func
(paren
id|revs
comma
id|object
comma
id|def
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|revs-&gt;topo_order
op_logical_or
id|revs-&gt;unpacked
)paren
id|revs-&gt;limited
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;prune_data
)paren
(brace
id|diff_tree_setup_paths
c_func
(paren
id|revs-&gt;prune_data
comma
op_amp
id|revs-&gt;pruning
)paren
suffix:semicolon
id|revs-&gt;prune_fn
op_assign
id|try_to_simplify_commit
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|revs-&gt;full_diff
)paren
id|diff_tree_setup_paths
c_func
(paren
id|revs-&gt;prune_data
comma
op_amp
id|revs-&gt;diffopt
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|revs-&gt;combine_merges
)paren
(brace
id|revs-&gt;ignore_merges
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;dense_combined_merges
op_logical_and
op_logical_neg
id|revs-&gt;diffopt.output_format
)paren
id|revs-&gt;diffopt.output_format
op_assign
id|DIFF_FORMAT_PATCH
suffix:semicolon
)brace
id|revs-&gt;diffopt.abbrev
op_assign
id|revs-&gt;abbrev
suffix:semicolon
r_if
c_cond
(paren
id|diff_setup_done
c_func
(paren
op_amp
id|revs-&gt;diffopt
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;diff_setup_done failed&quot;
)paren
suffix:semicolon
r_return
id|left
suffix:semicolon
)brace
DECL|function|prepare_revision_walk
r_void
id|prepare_revision_walk
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
)paren
(brace
r_int
id|nr
op_assign
id|revs-&gt;pending.nr
suffix:semicolon
r_struct
id|object_array_entry
op_star
id|list
op_assign
id|revs-&gt;pending.objects
suffix:semicolon
id|revs-&gt;pending.nr
op_assign
l_int|0
suffix:semicolon
id|revs-&gt;pending.alloc
op_assign
l_int|0
suffix:semicolon
id|revs-&gt;pending.objects
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|nr
op_ge
l_int|0
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
id|handle_commit
c_func
(paren
id|revs
comma
id|list-&gt;item
comma
id|list-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|commit
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|commit-&gt;object.flags
op_amp
id|SEEN
)paren
)paren
(brace
id|commit-&gt;object.flags
op_or_assign
id|SEEN
suffix:semicolon
id|insert_by_date
c_func
(paren
id|commit
comma
op_amp
id|revs-&gt;commits
)paren
suffix:semicolon
)brace
)brace
id|list
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|revs-&gt;no_walk
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;limited
)paren
id|limit_list
c_func
(paren
id|revs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;topo_order
)paren
id|sort_in_topological_order_fn
c_func
(paren
op_amp
id|revs-&gt;commits
comma
id|revs-&gt;lifo
comma
id|revs-&gt;topo_setter
comma
id|revs-&gt;topo_getter
)paren
suffix:semicolon
)brace
DECL|function|rewrite_one
r_static
r_int
id|rewrite_one
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_struct
id|commit
op_star
op_star
id|pp
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|commit
op_star
id|p
op_assign
op_star
id|pp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|revs-&gt;limited
)paren
id|add_parents_to_list
c_func
(paren
id|revs
comma
id|p
comma
op_amp
id|revs-&gt;commits
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;parents
op_logical_and
id|p-&gt;parents-&gt;next
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;object.flags
op_amp
(paren
id|TREECHANGE
op_or
id|UNINTERESTING
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;parents
)paren
r_return
l_int|1
suffix:semicolon
op_star
id|pp
op_assign
id|p-&gt;parents-&gt;item
suffix:semicolon
)brace
)brace
DECL|function|rewrite_parents
r_static
r_void
id|rewrite_parents
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_struct
id|commit_list
op_star
op_star
id|pp
op_assign
op_amp
id|commit-&gt;parents
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pp
)paren
(brace
r_struct
id|commit_list
op_star
id|parent
op_assign
op_star
id|pp
suffix:semicolon
r_if
c_cond
(paren
id|rewrite_one
c_func
(paren
id|revs
comma
op_amp
id|parent-&gt;item
)paren
OL
l_int|0
)paren
(brace
op_star
id|pp
op_assign
id|parent-&gt;next
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|pp
op_assign
op_amp
id|parent-&gt;next
suffix:semicolon
)brace
)brace
DECL|function|mark_boundary_to_show
r_static
r_void
id|mark_boundary_to_show
c_func
(paren
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_struct
id|commit_list
op_star
id|p
op_assign
id|commit-&gt;parents
suffix:semicolon
r_while
c_loop
(paren
id|p
)paren
(brace
id|commit
op_assign
id|p-&gt;item
suffix:semicolon
id|p
op_assign
id|p-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|commit-&gt;object.flags
op_amp
id|BOUNDARY
)paren
id|commit-&gt;object.flags
op_or_assign
id|BOUNDARY_SHOW
suffix:semicolon
)brace
)brace
DECL|function|commit_match
r_static
r_int
id|commit_match
c_func
(paren
r_struct
id|commit
op_star
id|commit
comma
r_struct
id|rev_info
op_star
id|opt
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|opt-&gt;header_filter
op_logical_and
op_logical_neg
id|opt-&gt;message_filter
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* match it here */
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|get_revision
r_struct
id|commit
op_star
id|get_revision
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
)paren
(brace
r_struct
id|commit_list
op_star
id|list
op_assign
id|revs-&gt;commits
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* Check the max_count ... */
r_switch
c_cond
(paren
id|revs-&gt;max_count
)paren
(brace
r_case
l_int|1
suffix:colon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
r_return
l_int|NULL
suffix:semicolon
r_default
suffix:colon
id|revs-&gt;max_count
op_decrement
suffix:semicolon
)brace
r_do
(brace
r_struct
id|commit_list
op_star
id|entry
op_assign
id|revs-&gt;commits
suffix:semicolon
r_struct
id|commit
op_star
id|commit
op_assign
id|entry-&gt;item
suffix:semicolon
id|revs-&gt;commits
op_assign
id|entry-&gt;next
suffix:semicolon
id|free
c_func
(paren
id|entry
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we haven&squot;t done the list limiting, we need to look at&n;&t;&t; * the parents here. We also need to do the date-based limiting&n;&t;&t; * that we&squot;d otherwise have done in limit_list().&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|revs-&gt;limited
)paren
(brace
r_if
c_cond
(paren
(paren
id|revs-&gt;unpacked
op_logical_and
id|has_sha1_pack
c_func
(paren
id|commit-&gt;object.sha1
comma
id|revs-&gt;ignore_packed
)paren
)paren
op_logical_or
(paren
id|revs-&gt;max_age
op_ne
l_int|1
op_logical_and
(paren
id|commit-&gt;date
OL
id|revs-&gt;max_age
)paren
)paren
)paren
r_continue
suffix:semicolon
id|add_parents_to_list
c_func
(paren
id|revs
comma
id|commit
comma
op_amp
id|revs-&gt;commits
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|commit-&gt;object.flags
op_amp
id|SHOWN
)paren
r_continue
suffix:semicolon
multiline_comment|/* We want to show boundary commits only when their&n;&t;&t; * children are shown.  When path-limiter is in effect,&n;&t;&t; * rewrite_parents() drops some commits from getting shown,&n;&t;&t; * and there is no point showing boundary parents that&n;&t;&t; * are not shown.  After rewrite_parents() rewrites the&n;&t;&t; * parents of a commit that is shown, we mark the boundary&n;&t;&t; * parents with BOUNDARY_SHOW.&n;&t;&t; */
r_if
c_cond
(paren
id|commit-&gt;object.flags
op_amp
id|BOUNDARY_SHOW
)paren
(brace
id|commit-&gt;object.flags
op_or_assign
id|SHOWN
suffix:semicolon
r_return
id|commit
suffix:semicolon
)brace
r_if
c_cond
(paren
id|commit-&gt;object.flags
op_amp
id|UNINTERESTING
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;min_age
op_ne
l_int|1
op_logical_and
(paren
id|commit-&gt;date
OG
id|revs-&gt;min_age
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;no_merges
op_logical_and
id|commit-&gt;parents
op_logical_and
id|commit-&gt;parents-&gt;next
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|commit_match
c_func
(paren
id|commit
comma
id|revs
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;prune_fn
op_logical_and
id|revs-&gt;dense
)paren
(brace
multiline_comment|/* Commit without changes? */
r_if
c_cond
(paren
op_logical_neg
(paren
id|commit-&gt;object.flags
op_amp
id|TREECHANGE
)paren
)paren
(brace
multiline_comment|/* drop merges unless we want parenthood */
r_if
c_cond
(paren
op_logical_neg
id|revs-&gt;parents
)paren
r_continue
suffix:semicolon
multiline_comment|/* non-merge - always ignore it */
r_if
c_cond
(paren
op_logical_neg
id|commit-&gt;parents
op_logical_or
op_logical_neg
id|commit-&gt;parents-&gt;next
)paren
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|revs-&gt;parents
)paren
id|rewrite_parents
c_func
(paren
id|revs
comma
id|commit
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|revs-&gt;boundary
)paren
id|mark_boundary_to_show
c_func
(paren
id|commit
)paren
suffix:semicolon
id|commit-&gt;object.flags
op_or_assign
id|SHOWN
suffix:semicolon
r_return
id|commit
suffix:semicolon
)brace
r_while
c_loop
(paren
id|revs-&gt;commits
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
eof
