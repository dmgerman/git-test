macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;tag.h&quot;
macro_line|#include &quot;blob.h&quot;
macro_line|#include &quot;tree.h&quot;
macro_line|#include &quot;commit.h&quot;
macro_line|#include &quot;diff.h&quot;
macro_line|#include &quot;refs.h&quot;
macro_line|#include &quot;revision.h&quot;
macro_line|#include &quot;graph.h&quot;
macro_line|#include &quot;grep.h&quot;
macro_line|#include &quot;reflog-walk.h&quot;
macro_line|#include &quot;patch-ids.h&quot;
macro_line|#include &quot;decorate.h&quot;
macro_line|#include &quot;log-tree.h&quot;
macro_line|#include &quot;string-list.h&quot;
DECL|variable|show_early_output
r_volatile
id|show_early_output_fn_t
id|show_early_output
suffix:semicolon
DECL|function|path_name
r_char
op_star
id|path_name
c_func
(paren
r_const
r_struct
id|name_path
op_star
id|path
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_const
r_struct
id|name_path
op_star
id|p
suffix:semicolon
r_char
op_star
id|n
comma
op_star
id|m
suffix:semicolon
r_int
id|nlen
op_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
r_int
id|len
op_assign
id|nlen
op_plus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|path
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;up
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;elem_len
)paren
id|len
op_add_assign
id|p-&gt;elem_len
op_plus
l_int|1
suffix:semicolon
)brace
id|n
op_assign
id|xmalloc
c_func
(paren
id|len
)paren
suffix:semicolon
id|m
op_assign
id|n
op_plus
id|len
(paren
id|nlen
op_plus
l_int|1
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|m
comma
id|name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|path
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;up
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;elem_len
)paren
(brace
id|m
op_sub_assign
id|p-&gt;elem_len
op_plus
l_int|1
suffix:semicolon
id|memcpy
c_func
(paren
id|m
comma
id|p-&gt;elem
comma
id|p-&gt;elem_len
)paren
suffix:semicolon
id|m
(braket
id|p-&gt;elem_len
)braket
op_assign
l_char|&squot;/&squot;
suffix:semicolon
)brace
)brace
r_return
id|n
suffix:semicolon
)brace
DECL|function|add_object
r_void
id|add_object
c_func
(paren
r_struct
id|object
op_star
id|obj
comma
r_struct
id|object_array
op_star
id|p
comma
r_struct
id|name_path
op_star
id|path
comma
r_const
r_char
op_star
id|name
)paren
(brace
id|add_object_array
c_func
(paren
id|obj
comma
id|path_name
c_func
(paren
id|path
comma
id|name
)paren
comma
id|p
)paren
suffix:semicolon
)brace
DECL|function|mark_blob_uninteresting
r_static
r_void
id|mark_blob_uninteresting
c_func
(paren
r_struct
id|blob
op_star
id|blob
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|blob
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|blob-&gt;object.flags
op_amp
id|UNINTERESTING
)paren
r_return
suffix:semicolon
id|blob-&gt;object.flags
op_or_assign
id|UNINTERESTING
suffix:semicolon
)brace
DECL|function|mark_tree_uninteresting
r_void
id|mark_tree_uninteresting
c_func
(paren
r_struct
id|tree
op_star
id|tree
)paren
(brace
r_struct
id|tree_desc
id|desc
suffix:semicolon
r_struct
id|name_entry
id|entry
suffix:semicolon
r_struct
id|object
op_star
id|obj
op_assign
op_amp
id|tree-&gt;object
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tree
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|obj-&gt;flags
op_amp
id|UNINTERESTING
)paren
r_return
suffix:semicolon
id|obj-&gt;flags
op_or_assign
id|UNINTERESTING
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|has_sha1_file
c_func
(paren
id|obj-&gt;sha1
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|parse_tree
c_func
(paren
id|tree
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;bad tree %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|obj-&gt;sha1
)paren
)paren
suffix:semicolon
id|init_tree_desc
c_func
(paren
op_amp
id|desc
comma
id|tree-&gt;buffer
comma
id|tree-&gt;size
)paren
suffix:semicolon
r_while
c_loop
(paren
id|tree_entry
c_func
(paren
op_amp
id|desc
comma
op_amp
id|entry
)paren
)paren
(brace
r_switch
c_cond
(paren
id|object_type
c_func
(paren
id|entry.mode
)paren
)paren
(brace
r_case
id|OBJ_TREE
suffix:colon
id|mark_tree_uninteresting
c_func
(paren
id|lookup_tree
c_func
(paren
id|entry.sha1
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OBJ_BLOB
suffix:colon
id|mark_blob_uninteresting
c_func
(paren
id|lookup_blob
c_func
(paren
id|entry.sha1
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Subproject commit - not in this repository */
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * We don&squot;t care about the tree any more&n;&t; * after it has been marked uninteresting.&n;&t; */
id|free
c_func
(paren
id|tree-&gt;buffer
)paren
suffix:semicolon
id|tree-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|mark_parents_uninteresting
r_void
id|mark_parents_uninteresting
c_func
(paren
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_struct
id|commit_list
op_star
id|parents
op_assign
id|commit-&gt;parents
suffix:semicolon
r_while
c_loop
(paren
id|parents
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
id|parents-&gt;item
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|commit-&gt;object.flags
op_amp
id|UNINTERESTING
)paren
)paren
(brace
id|commit-&gt;object.flags
op_or_assign
id|UNINTERESTING
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Normally we haven&squot;t parsed the parent&n;&t;&t;&t; * yet, so we won&squot;t have a parent of a parent&n;&t;&t;&t; * here. However, it may turn out that we&squot;ve&n;&t;&t;&t; * reached this commit some other way (where it&n;&t;&t;&t; * wasn&squot;t uninteresting), in which case we need&n;&t;&t;&t; * to mark its parents recursively too..&n;&t;&t;&t; */
r_if
c_cond
(paren
id|commit-&gt;parents
)paren
id|mark_parents_uninteresting
c_func
(paren
id|commit
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * A missing commit is ok iff its parent is marked&n;&t;&t; * uninteresting.&n;&t;&t; *&n;&t;&t; * We just mark such a thing parsed, so that when&n;&t;&t; * it is popped next time around, we won&squot;t be trying&n;&t;&t; * to parse it and get an error.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|has_sha1_file
c_func
(paren
id|commit-&gt;object.sha1
)paren
)paren
id|commit-&gt;object.parsed
op_assign
l_int|1
suffix:semicolon
id|parents
op_assign
id|parents-&gt;next
suffix:semicolon
)brace
)brace
DECL|function|add_pending_object_with_mode
r_static
r_void
id|add_pending_object_with_mode
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_struct
id|object
op_star
id|obj
comma
r_const
r_char
op_star
id|name
comma
r_int
id|mode
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|obj
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;no_walk
op_logical_and
(paren
id|obj-&gt;flags
op_amp
id|UNINTERESTING
)paren
)paren
id|revs-&gt;no_walk
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;reflog_info
op_logical_and
id|obj-&gt;type
op_eq
id|OBJ_COMMIT
)paren
(brace
r_struct
id|strbuf
id|buf
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|len
op_assign
id|interpret_branch_name
c_func
(paren
id|name
comma
op_amp
id|buf
)paren
suffix:semicolon
r_int
id|st
suffix:semicolon
r_if
c_cond
(paren
l_int|0
OL
id|len
op_logical_and
id|name
(braket
id|len
)braket
op_logical_and
id|buf.len
)paren
id|strbuf_addstr
c_func
(paren
op_amp
id|buf
comma
id|name
op_plus
id|len
)paren
suffix:semicolon
id|st
op_assign
id|add_reflog_for_walk
c_func
(paren
id|revs-&gt;reflog_info
comma
(paren
r_struct
id|commit
op_star
)paren
id|obj
comma
id|buf.buf
(braket
l_int|0
)braket
ques
c_cond
id|buf.buf
suffix:colon
id|name
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
)paren
r_return
suffix:semicolon
)brace
id|add_object_array_with_mode
c_func
(paren
id|obj
comma
id|name
comma
op_amp
id|revs-&gt;pending
comma
id|mode
)paren
suffix:semicolon
)brace
DECL|function|add_pending_object
r_void
id|add_pending_object
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_struct
id|object
op_star
id|obj
comma
r_const
r_char
op_star
id|name
)paren
(brace
id|add_pending_object_with_mode
c_func
(paren
id|revs
comma
id|obj
comma
id|name
comma
id|S_IFINVALID
)paren
suffix:semicolon
)brace
DECL|function|add_head_to_pending
r_void
id|add_head_to_pending
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_struct
id|object
op_star
id|obj
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|sha1
)paren
)paren
r_return
suffix:semicolon
id|obj
op_assign
id|parse_object
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|obj
)paren
r_return
suffix:semicolon
id|add_pending_object
c_func
(paren
id|revs
comma
id|obj
comma
l_string|&quot;HEAD&quot;
)paren
suffix:semicolon
)brace
DECL|function|get_reference
r_static
r_struct
id|object
op_star
id|get_reference
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_const
r_char
op_star
id|name
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
r_int
id|flags
)paren
(brace
r_struct
id|object
op_star
id|object
suffix:semicolon
id|object
op_assign
id|parse_object
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|object
)paren
(brace
r_if
c_cond
(paren
id|revs-&gt;ignore_missing
)paren
r_return
id|object
suffix:semicolon
id|die
c_func
(paren
l_string|&quot;bad object %s&quot;
comma
id|name
)paren
suffix:semicolon
)brace
id|object-&gt;flags
op_or_assign
id|flags
suffix:semicolon
r_return
id|object
suffix:semicolon
)brace
DECL|function|handle_commit
r_static
r_struct
id|commit
op_star
id|handle_commit
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_struct
id|object
op_star
id|object
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_int
r_int
id|flags
op_assign
id|object-&gt;flags
suffix:semicolon
multiline_comment|/*&n;&t; * Tag object? Look what it points to..&n;&t; */
r_while
c_loop
(paren
id|object-&gt;type
op_eq
id|OBJ_TAG
)paren
(brace
r_struct
id|tag
op_star
id|tag
op_assign
(paren
r_struct
id|tag
op_star
)paren
id|object
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;tag_objects
op_logical_and
op_logical_neg
(paren
id|flags
op_amp
id|UNINTERESTING
)paren
)paren
id|add_pending_object
c_func
(paren
id|revs
comma
id|object
comma
id|tag-&gt;tag
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tag-&gt;tagged
)paren
id|die
c_func
(paren
l_string|&quot;bad tag&quot;
)paren
suffix:semicolon
id|object
op_assign
id|parse_object
c_func
(paren
id|tag-&gt;tagged-&gt;sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|object
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|UNINTERESTING
)paren
r_return
l_int|NULL
suffix:semicolon
id|die
c_func
(paren
l_string|&quot;bad object %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|tag-&gt;tagged-&gt;sha1
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Commit object? Just return it, we&squot;ll do all the complex&n;&t; * reachability crud.&n;&t; */
r_if
c_cond
(paren
id|object-&gt;type
op_eq
id|OBJ_COMMIT
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
(paren
r_struct
id|commit
op_star
)paren
id|object
suffix:semicolon
r_if
c_cond
(paren
id|parse_commit
c_func
(paren
id|commit
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;unable to parse commit %s&quot;
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|UNINTERESTING
)paren
(brace
id|commit-&gt;object.flags
op_or_assign
id|UNINTERESTING
suffix:semicolon
id|mark_parents_uninteresting
c_func
(paren
id|commit
)paren
suffix:semicolon
id|revs-&gt;limited
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|revs-&gt;show_source
op_logical_and
op_logical_neg
id|commit-&gt;util
)paren
id|commit-&gt;util
op_assign
(paren
r_void
op_star
)paren
id|name
suffix:semicolon
r_return
id|commit
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Tree object? Either mark it uninteresting, or add it&n;&t; * to the list of objects to look at later..&n;&t; */
r_if
c_cond
(paren
id|object-&gt;type
op_eq
id|OBJ_TREE
)paren
(brace
r_struct
id|tree
op_star
id|tree
op_assign
(paren
r_struct
id|tree
op_star
)paren
id|object
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|revs-&gt;tree_objects
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|UNINTERESTING
)paren
(brace
id|mark_tree_uninteresting
c_func
(paren
id|tree
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|add_pending_object
c_func
(paren
id|revs
comma
id|object
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Blob object? You know the drill by now..&n;&t; */
r_if
c_cond
(paren
id|object-&gt;type
op_eq
id|OBJ_BLOB
)paren
(brace
r_struct
id|blob
op_star
id|blob
op_assign
(paren
r_struct
id|blob
op_star
)paren
id|object
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|revs-&gt;blob_objects
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|UNINTERESTING
)paren
(brace
id|mark_blob_uninteresting
c_func
(paren
id|blob
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|add_pending_object
c_func
(paren
id|revs
comma
id|object
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|die
c_func
(paren
l_string|&quot;%s is unknown object&quot;
comma
id|name
)paren
suffix:semicolon
)brace
DECL|function|everybody_uninteresting
r_static
r_int
id|everybody_uninteresting
c_func
(paren
r_struct
id|commit_list
op_star
id|orig
)paren
(brace
r_struct
id|commit_list
op_star
id|list
op_assign
id|orig
suffix:semicolon
r_while
c_loop
(paren
id|list
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
id|list-&gt;item
suffix:semicolon
id|list
op_assign
id|list-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|commit-&gt;object.flags
op_amp
id|UNINTERESTING
)paren
r_continue
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * The goal is to get REV_TREE_NEW as the result only if the&n; * diff consists of all &squot;+&squot; (and no other changes), REV_TREE_OLD&n; * if the whole diff is removal of old data, and otherwise&n; * REV_TREE_DIFFERENT (of course if the trees are the same we&n; * want REV_TREE_SAME).&n; * That means that once we get to REV_TREE_DIFFERENT, we do not&n; * have to look any further.&n; */
DECL|variable|tree_difference
r_static
r_int
id|tree_difference
op_assign
id|REV_TREE_SAME
suffix:semicolon
DECL|function|file_add_remove
r_static
r_void
id|file_add_remove
c_func
(paren
r_struct
id|diff_options
op_star
id|options
comma
r_int
id|addremove
comma
r_int
id|mode
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_const
r_char
op_star
id|fullpath
comma
r_int
id|dirty_submodule
)paren
(brace
r_int
id|diff
op_assign
id|addremove
op_eq
l_char|&squot;+&squot;
ques
c_cond
id|REV_TREE_NEW
suffix:colon
id|REV_TREE_OLD
suffix:semicolon
id|tree_difference
op_or_assign
id|diff
suffix:semicolon
r_if
c_cond
(paren
id|tree_difference
op_eq
id|REV_TREE_DIFFERENT
)paren
id|DIFF_OPT_SET
c_func
(paren
id|options
comma
id|HAS_CHANGES
)paren
suffix:semicolon
)brace
DECL|function|file_change
r_static
r_void
id|file_change
c_func
(paren
r_struct
id|diff_options
op_star
id|options
comma
r_int
id|old_mode
comma
r_int
id|new_mode
comma
r_const
r_int
r_char
op_star
id|old_sha1
comma
r_const
r_int
r_char
op_star
id|new_sha1
comma
r_const
r_char
op_star
id|fullpath
comma
r_int
id|old_dirty_submodule
comma
r_int
id|new_dirty_submodule
)paren
(brace
id|tree_difference
op_assign
id|REV_TREE_DIFFERENT
suffix:semicolon
id|DIFF_OPT_SET
c_func
(paren
id|options
comma
id|HAS_CHANGES
)paren
suffix:semicolon
)brace
DECL|function|rev_compare_tree
r_static
r_int
id|rev_compare_tree
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_struct
id|commit
op_star
id|parent
comma
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_struct
id|tree
op_star
id|t1
op_assign
id|parent-&gt;tree
suffix:semicolon
r_struct
id|tree
op_star
id|t2
op_assign
id|commit-&gt;tree
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|t1
)paren
r_return
id|REV_TREE_NEW
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|t2
)paren
r_return
id|REV_TREE_OLD
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;simplify_by_decoration
)paren
(brace
multiline_comment|/*&n;&t;&t; * If we are simplifying by decoration, then the commit&n;&t;&t; * is worth showing if it has a tag pointing at it.&n;&t;&t; */
r_if
c_cond
(paren
id|lookup_decoration
c_func
(paren
op_amp
id|name_decoration
comma
op_amp
id|commit-&gt;object
)paren
)paren
r_return
id|REV_TREE_DIFFERENT
suffix:semicolon
multiline_comment|/*&n;&t;&t; * A commit that is not pointed by a tag is uninteresting&n;&t;&t; * if we are not limited by path.  This means that you will&n;&t;&t; * see the usual &quot;commits that touch the paths&quot; plus any&n;&t;&t; * tagged commit by specifying both --simplify-by-decoration&n;&t;&t; * and pathspec.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|revs-&gt;prune_data.nr
)paren
r_return
id|REV_TREE_SAME
suffix:semicolon
)brace
id|tree_difference
op_assign
id|REV_TREE_SAME
suffix:semicolon
id|DIFF_OPT_CLR
c_func
(paren
op_amp
id|revs-&gt;pruning
comma
id|HAS_CHANGES
)paren
suffix:semicolon
r_if
c_cond
(paren
id|diff_tree_sha1
c_func
(paren
id|t1-&gt;object.sha1
comma
id|t2-&gt;object.sha1
comma
l_string|&quot;&quot;
comma
op_amp
id|revs-&gt;pruning
)paren
OL
l_int|0
)paren
r_return
id|REV_TREE_DIFFERENT
suffix:semicolon
r_return
id|tree_difference
suffix:semicolon
)brace
DECL|function|rev_same_tree_as_empty
r_static
r_int
id|rev_same_tree_as_empty
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_int
id|retval
suffix:semicolon
r_void
op_star
id|tree
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_struct
id|tree_desc
id|empty
comma
id|real
suffix:semicolon
r_struct
id|tree
op_star
id|t1
op_assign
id|commit-&gt;tree
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|t1
)paren
r_return
l_int|0
suffix:semicolon
id|tree
op_assign
id|read_object_with_reference
c_func
(paren
id|t1-&gt;object.sha1
comma
id|tree_type
comma
op_amp
id|size
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tree
)paren
r_return
l_int|0
suffix:semicolon
id|init_tree_desc
c_func
(paren
op_amp
id|real
comma
id|tree
comma
id|size
)paren
suffix:semicolon
id|init_tree_desc
c_func
(paren
op_amp
id|empty
comma
l_string|&quot;&quot;
comma
l_int|0
)paren
suffix:semicolon
id|tree_difference
op_assign
id|REV_TREE_SAME
suffix:semicolon
id|DIFF_OPT_CLR
c_func
(paren
op_amp
id|revs-&gt;pruning
comma
id|HAS_CHANGES
)paren
suffix:semicolon
id|retval
op_assign
id|diff_tree
c_func
(paren
op_amp
id|empty
comma
op_amp
id|real
comma
l_string|&quot;&quot;
comma
op_amp
id|revs-&gt;pruning
)paren
suffix:semicolon
id|free
c_func
(paren
id|tree
)paren
suffix:semicolon
r_return
id|retval
op_ge
l_int|0
op_logical_and
(paren
id|tree_difference
op_eq
id|REV_TREE_SAME
)paren
suffix:semicolon
)brace
DECL|function|try_to_simplify_commit
r_static
r_void
id|try_to_simplify_commit
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_struct
id|commit_list
op_star
op_star
id|pp
comma
op_star
id|parent
suffix:semicolon
r_int
id|tree_changed
op_assign
l_int|0
comma
id|tree_same
op_assign
l_int|0
comma
id|nth_parent
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If we don&squot;t do pruning, everything is interesting&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|revs-&gt;prune
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|commit-&gt;tree
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|commit-&gt;parents
)paren
(brace
r_if
c_cond
(paren
id|rev_same_tree_as_empty
c_func
(paren
id|revs
comma
id|commit
)paren
)paren
id|commit-&gt;object.flags
op_or_assign
id|TREESAME
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Normal non-merge commit? If we don&squot;t want to make the&n;&t; * history dense, we consider it always to be a change..&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|revs-&gt;dense
op_logical_and
op_logical_neg
id|commit-&gt;parents-&gt;next
)paren
r_return
suffix:semicolon
id|pp
op_assign
op_amp
id|commit-&gt;parents
suffix:semicolon
r_while
c_loop
(paren
(paren
id|parent
op_assign
op_star
id|pp
)paren
op_ne
l_int|NULL
)paren
(brace
r_struct
id|commit
op_star
id|p
op_assign
id|parent-&gt;item
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Do not compare with later parents when we care only about&n;&t;&t; * the first parent chain, in order to avoid derailing the&n;&t;&t; * traversal to follow a side branch that brought everything&n;&t;&t; * in the path we are limited to by the pathspec.&n;&t;&t; */
r_if
c_cond
(paren
id|revs-&gt;first_parent_only
op_logical_and
id|nth_parent
op_increment
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|parse_commit
c_func
(paren
id|p
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;cannot simplify commit %s (because of %s)&quot;
comma
id|sha1_to_hex
c_func
(paren
id|commit-&gt;object.sha1
)paren
comma
id|sha1_to_hex
c_func
(paren
id|p-&gt;object.sha1
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|rev_compare_tree
c_func
(paren
id|revs
comma
id|p
comma
id|commit
)paren
)paren
(brace
r_case
id|REV_TREE_SAME
suffix:colon
id|tree_same
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|revs-&gt;simplify_history
op_logical_or
(paren
id|p-&gt;object.flags
op_amp
id|UNINTERESTING
)paren
)paren
(brace
multiline_comment|/* Even if a merge with an uninteresting&n;&t;&t;&t;&t; * side branch brought the entire change&n;&t;&t;&t;&t; * we are interested in, we do not want&n;&t;&t;&t;&t; * to lose the other branches of this&n;&t;&t;&t;&t; * merge, so we just keep going.&n;&t;&t;&t;&t; */
id|pp
op_assign
op_amp
id|parent-&gt;next
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|parent-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|commit-&gt;parents
op_assign
id|parent
suffix:semicolon
id|commit-&gt;object.flags
op_or_assign
id|TREESAME
suffix:semicolon
r_return
suffix:semicolon
r_case
id|REV_TREE_NEW
suffix:colon
r_if
c_cond
(paren
id|revs-&gt;remove_empty_trees
op_logical_and
id|rev_same_tree_as_empty
c_func
(paren
id|revs
comma
id|p
)paren
)paren
(brace
multiline_comment|/* We are adding all the specified&n;&t;&t;&t;&t; * paths from this parent, so the&n;&t;&t;&t;&t; * history beyond this parent is not&n;&t;&t;&t;&t; * interesting.  Remove its parents&n;&t;&t;&t;&t; * (they are grandparents for us).&n;&t;&t;&t;&t; * IOW, we pretend this parent is a&n;&t;&t;&t;&t; * &quot;root&quot; commit.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|parse_commit
c_func
(paren
id|p
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;cannot simplify commit %s (invalid %s)&quot;
comma
id|sha1_to_hex
c_func
(paren
id|commit-&gt;object.sha1
)paren
comma
id|sha1_to_hex
c_func
(paren
id|p-&gt;object.sha1
)paren
)paren
suffix:semicolon
id|p-&gt;parents
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* fallthrough */
r_case
id|REV_TREE_OLD
suffix:colon
r_case
id|REV_TREE_DIFFERENT
suffix:colon
id|tree_changed
op_assign
l_int|1
suffix:semicolon
id|pp
op_assign
op_amp
id|parent-&gt;next
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|die
c_func
(paren
l_string|&quot;bad tree compare for commit %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|commit-&gt;object.sha1
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tree_changed
op_logical_and
op_logical_neg
id|tree_same
)paren
r_return
suffix:semicolon
id|commit-&gt;object.flags
op_or_assign
id|TREESAME
suffix:semicolon
)brace
DECL|function|commit_list_insert_by_date_cached
r_static
r_void
id|commit_list_insert_by_date_cached
c_func
(paren
r_struct
id|commit
op_star
id|p
comma
r_struct
id|commit_list
op_star
op_star
id|head
comma
r_struct
id|commit_list
op_star
id|cached_base
comma
r_struct
id|commit_list
op_star
op_star
id|cache
)paren
(brace
r_struct
id|commit_list
op_star
id|new_entry
suffix:semicolon
r_if
c_cond
(paren
id|cached_base
op_logical_and
id|p-&gt;date
OL
id|cached_base-&gt;item-&gt;date
)paren
id|new_entry
op_assign
id|commit_list_insert_by_date
c_func
(paren
id|p
comma
op_amp
id|cached_base-&gt;next
)paren
suffix:semicolon
r_else
id|new_entry
op_assign
id|commit_list_insert_by_date
c_func
(paren
id|p
comma
id|head
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cache
op_logical_and
(paren
op_logical_neg
op_star
id|cache
op_logical_or
id|p-&gt;date
OL
(paren
op_star
id|cache
)paren
op_member_access_from_pointer
id|item-&gt;date
)paren
)paren
op_star
id|cache
op_assign
id|new_entry
suffix:semicolon
)brace
DECL|function|add_parents_to_list
r_static
r_int
id|add_parents_to_list
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_struct
id|commit
op_star
id|commit
comma
r_struct
id|commit_list
op_star
op_star
id|list
comma
r_struct
id|commit_list
op_star
op_star
id|cache_ptr
)paren
(brace
r_struct
id|commit_list
op_star
id|parent
op_assign
id|commit-&gt;parents
suffix:semicolon
r_int
id|left_flag
suffix:semicolon
r_struct
id|commit_list
op_star
id|cached_base
op_assign
id|cache_ptr
ques
c_cond
op_star
id|cache_ptr
suffix:colon
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|commit-&gt;object.flags
op_amp
id|ADDED
)paren
r_return
l_int|0
suffix:semicolon
id|commit-&gt;object.flags
op_or_assign
id|ADDED
suffix:semicolon
multiline_comment|/*&n;&t; * If the commit is uninteresting, don&squot;t try to&n;&t; * prune parents - we want the maximal uninteresting&n;&t; * set.&n;&t; *&n;&t; * Normally we haven&squot;t parsed the parent&n;&t; * yet, so we won&squot;t have a parent of a parent&n;&t; * here. However, it may turn out that we&squot;ve&n;&t; * reached this commit some other way (where it&n;&t; * wasn&squot;t uninteresting), in which case we need&n;&t; * to mark its parents recursively too..&n;&t; */
r_if
c_cond
(paren
id|commit-&gt;object.flags
op_amp
id|UNINTERESTING
)paren
(brace
r_while
c_loop
(paren
id|parent
)paren
(brace
r_struct
id|commit
op_star
id|p
op_assign
id|parent-&gt;item
suffix:semicolon
id|parent
op_assign
id|parent-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
id|p-&gt;object.flags
op_or_assign
id|UNINTERESTING
suffix:semicolon
r_if
c_cond
(paren
id|parse_commit
c_func
(paren
id|p
)paren
OL
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;parents
)paren
id|mark_parents_uninteresting
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;object.flags
op_amp
id|SEEN
)paren
r_continue
suffix:semicolon
id|p-&gt;object.flags
op_or_assign
id|SEEN
suffix:semicolon
id|commit_list_insert_by_date_cached
c_func
(paren
id|p
comma
id|list
comma
id|cached_base
comma
id|cache_ptr
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Ok, the commit wasn&squot;t uninteresting. Try to&n;&t; * simplify the commit history and find the parent&n;&t; * that has no differences in the path set if one exists.&n;&t; */
id|try_to_simplify_commit
c_func
(paren
id|revs
comma
id|commit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;no_walk
)paren
r_return
l_int|0
suffix:semicolon
id|left_flag
op_assign
(paren
id|commit-&gt;object.flags
op_amp
id|SYMMETRIC_LEFT
)paren
suffix:semicolon
r_for
c_loop
(paren
id|parent
op_assign
id|commit-&gt;parents
suffix:semicolon
id|parent
suffix:semicolon
id|parent
op_assign
id|parent-&gt;next
)paren
(brace
r_struct
id|commit
op_star
id|p
op_assign
id|parent-&gt;item
suffix:semicolon
r_if
c_cond
(paren
id|parse_commit
c_func
(paren
id|p
)paren
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;show_source
op_logical_and
op_logical_neg
id|p-&gt;util
)paren
id|p-&gt;util
op_assign
id|commit-&gt;util
suffix:semicolon
id|p-&gt;object.flags
op_or_assign
id|left_flag
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;object.flags
op_amp
id|SEEN
)paren
)paren
(brace
id|p-&gt;object.flags
op_or_assign
id|SEEN
suffix:semicolon
id|commit_list_insert_by_date_cached
c_func
(paren
id|p
comma
id|list
comma
id|cached_base
comma
id|cache_ptr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|revs-&gt;first_parent_only
)paren
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cherry_pick_list
r_static
r_void
id|cherry_pick_list
c_func
(paren
r_struct
id|commit_list
op_star
id|list
comma
r_struct
id|rev_info
op_star
id|revs
)paren
(brace
r_struct
id|commit_list
op_star
id|p
suffix:semicolon
r_int
id|left_count
op_assign
l_int|0
comma
id|right_count
op_assign
l_int|0
suffix:semicolon
r_int
id|left_first
suffix:semicolon
r_struct
id|patch_ids
id|ids
suffix:semicolon
r_int
id|cherry_flag
suffix:semicolon
multiline_comment|/* First count the commits on the left and on the right */
r_for
c_loop
(paren
id|p
op_assign
id|list
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
id|p-&gt;item
suffix:semicolon
r_int
id|flags
op_assign
id|commit-&gt;object.flags
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|BOUNDARY
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|flags
op_amp
id|SYMMETRIC_LEFT
)paren
id|left_count
op_increment
suffix:semicolon
r_else
id|right_count
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|left_count
op_logical_or
op_logical_neg
id|right_count
)paren
r_return
suffix:semicolon
id|left_first
op_assign
id|left_count
OL
id|right_count
suffix:semicolon
id|init_patch_ids
c_func
(paren
op_amp
id|ids
)paren
suffix:semicolon
id|ids.diffopts.pathspec
op_assign
id|revs-&gt;diffopt.pathspec
suffix:semicolon
multiline_comment|/* Compute patch-ids for one side */
r_for
c_loop
(paren
id|p
op_assign
id|list
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
id|p-&gt;item
suffix:semicolon
r_int
id|flags
op_assign
id|commit-&gt;object.flags
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|BOUNDARY
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we have fewer left, left_first is set and we omit&n;&t;&t; * commits on the right branch in this loop.  If we have&n;&t;&t; * fewer right, we skip the left ones.&n;&t;&t; */
r_if
c_cond
(paren
id|left_first
op_ne
op_logical_neg
op_logical_neg
(paren
id|flags
op_amp
id|SYMMETRIC_LEFT
)paren
)paren
r_continue
suffix:semicolon
id|commit-&gt;util
op_assign
id|add_commit_patch_id
c_func
(paren
id|commit
comma
op_amp
id|ids
)paren
suffix:semicolon
)brace
multiline_comment|/* either cherry_mark or cherry_pick are true */
id|cherry_flag
op_assign
id|revs-&gt;cherry_mark
ques
c_cond
id|PATCHSAME
suffix:colon
id|SHOWN
suffix:semicolon
multiline_comment|/* Check the other side */
r_for
c_loop
(paren
id|p
op_assign
id|list
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
id|p-&gt;item
suffix:semicolon
r_struct
id|patch_id
op_star
id|id
suffix:semicolon
r_int
id|flags
op_assign
id|commit-&gt;object.flags
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|BOUNDARY
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we have fewer left, left_first is set and we omit&n;&t;&t; * commits on the left branch in this loop.&n;&t;&t; */
r_if
c_cond
(paren
id|left_first
op_eq
op_logical_neg
op_logical_neg
(paren
id|flags
op_amp
id|SYMMETRIC_LEFT
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Have we seen the same patch id?&n;&t;&t; */
id|id
op_assign
id|has_commit_patch_id
c_func
(paren
id|commit
comma
op_amp
id|ids
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|id
)paren
r_continue
suffix:semicolon
id|id-&gt;seen
op_assign
l_int|1
suffix:semicolon
id|commit-&gt;object.flags
op_or_assign
id|cherry_flag
suffix:semicolon
)brace
multiline_comment|/* Now check the original side for seen ones */
r_for
c_loop
(paren
id|p
op_assign
id|list
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
id|p-&gt;item
suffix:semicolon
r_struct
id|patch_id
op_star
id|ent
suffix:semicolon
id|ent
op_assign
id|commit-&gt;util
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ent
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|ent-&gt;seen
)paren
id|commit-&gt;object.flags
op_or_assign
id|cherry_flag
suffix:semicolon
id|commit-&gt;util
op_assign
l_int|NULL
suffix:semicolon
)brace
id|free_patch_ids
c_func
(paren
op_amp
id|ids
)paren
suffix:semicolon
)brace
multiline_comment|/* How many extra uninteresting commits we want to see.. */
DECL|macro|SLOP
mdefine_line|#define SLOP 5
DECL|function|still_interesting
r_static
r_int
id|still_interesting
c_func
(paren
r_struct
id|commit_list
op_star
id|src
comma
r_int
r_int
id|date
comma
r_int
id|slop
)paren
(brace
multiline_comment|/*&n;&t; * No source list at all? We&squot;re definitely done..&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|src
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Does the destination list contain entries with a date&n;&t; * before the source list? Definitely _not_ done.&n;&t; */
r_if
c_cond
(paren
id|date
OL
id|src-&gt;item-&gt;date
)paren
r_return
id|SLOP
suffix:semicolon
multiline_comment|/*&n;&t; * Does the source list still have interesting commits in&n;&t; * it? Definitely not done..&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|everybody_uninteresting
c_func
(paren
id|src
)paren
)paren
r_return
id|SLOP
suffix:semicolon
multiline_comment|/* Ok, we&squot;re closing in.. */
r_return
id|slop
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * &quot;rev-list --ancestry-path A..B&quot; computes commits that are ancestors&n; * of B but not ancestors of A but further limits the result to those&n; * that are descendants of A.  This takes the list of bottom commits and&n; * the result of &quot;A..B&quot; without --ancestry-path, and limits the latter&n; * further to the ones that can reach one of the commits in &quot;bottom&quot;.&n; */
DECL|function|limit_to_ancestry
r_static
r_void
id|limit_to_ancestry
c_func
(paren
r_struct
id|commit_list
op_star
id|bottom
comma
r_struct
id|commit_list
op_star
id|list
)paren
(brace
r_struct
id|commit_list
op_star
id|p
suffix:semicolon
r_struct
id|commit_list
op_star
id|rlist
op_assign
l_int|NULL
suffix:semicolon
r_int
id|made_progress
suffix:semicolon
multiline_comment|/*&n;&t; * Reverse the list so that it will be likely that we would&n;&t; * process parents before children.&n;&t; */
r_for
c_loop
(paren
id|p
op_assign
id|list
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
id|commit_list_insert
c_func
(paren
id|p-&gt;item
comma
op_amp
id|rlist
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|bottom
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
id|p-&gt;item-&gt;object.flags
op_or_assign
id|TMP_MARK
suffix:semicolon
multiline_comment|/*&n;&t; * Mark the ones that can reach bottom commits in &quot;list&quot;,&n;&t; * in a bottom-up fashion.&n;&t; */
r_do
(brace
id|made_progress
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|rlist
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_struct
id|commit
op_star
id|c
op_assign
id|p-&gt;item
suffix:semicolon
r_struct
id|commit_list
op_star
id|parents
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;object.flags
op_amp
(paren
id|TMP_MARK
op_or
id|UNINTERESTING
)paren
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|parents
op_assign
id|c-&gt;parents
suffix:semicolon
id|parents
suffix:semicolon
id|parents
op_assign
id|parents-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|parents-&gt;item-&gt;object.flags
op_amp
id|TMP_MARK
)paren
)paren
r_continue
suffix:semicolon
id|c-&gt;object.flags
op_or_assign
id|TMP_MARK
suffix:semicolon
id|made_progress
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
id|made_progress
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * NEEDSWORK: decide if we want to remove parents that are&n;&t; * not marked with TMP_MARK from commit-&gt;parents for commits&n;&t; * in the resulting list.  We may not want to do that, though.&n;&t; */
multiline_comment|/*&n;&t; * The ones that are not marked with TMP_MARK are uninteresting&n;&t; */
r_for
c_loop
(paren
id|p
op_assign
id|list
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_struct
id|commit
op_star
id|c
op_assign
id|p-&gt;item
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;object.flags
op_amp
id|TMP_MARK
)paren
r_continue
suffix:semicolon
id|c-&gt;object.flags
op_or_assign
id|UNINTERESTING
suffix:semicolon
)brace
multiline_comment|/* We are done with the TMP_MARK */
r_for
c_loop
(paren
id|p
op_assign
id|list
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
id|p-&gt;item-&gt;object.flags
op_and_assign
op_complement
id|TMP_MARK
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|bottom
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
id|p-&gt;item-&gt;object.flags
op_and_assign
op_complement
id|TMP_MARK
suffix:semicolon
id|free_commit_list
c_func
(paren
id|rlist
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Before walking the history, keep the set of &quot;negative&quot; refs the&n; * caller has asked to exclude.&n; *&n; * This is used to compute &quot;rev-list --ancestry-path A..B&quot;, as we need&n; * to filter the result of &quot;A..B&quot; further to the ones that can actually&n; * reach A.&n; */
DECL|function|collect_bottom_commits
r_static
r_struct
id|commit_list
op_star
id|collect_bottom_commits
c_func
(paren
r_struct
id|commit_list
op_star
id|list
)paren
(brace
r_struct
id|commit_list
op_star
id|elem
comma
op_star
id|bottom
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|elem
op_assign
id|list
suffix:semicolon
id|elem
suffix:semicolon
id|elem
op_assign
id|elem-&gt;next
)paren
r_if
c_cond
(paren
id|elem-&gt;item-&gt;object.flags
op_amp
id|UNINTERESTING
)paren
id|commit_list_insert
c_func
(paren
id|elem-&gt;item
comma
op_amp
id|bottom
)paren
suffix:semicolon
r_return
id|bottom
suffix:semicolon
)brace
multiline_comment|/* Assumes either left_only or right_only is set */
DECL|function|limit_left_right
r_static
r_void
id|limit_left_right
c_func
(paren
r_struct
id|commit_list
op_star
id|list
comma
r_struct
id|rev_info
op_star
id|revs
)paren
(brace
r_struct
id|commit_list
op_star
id|p
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|list
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
id|p-&gt;item
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;right_only
)paren
(brace
r_if
c_cond
(paren
id|commit-&gt;object.flags
op_amp
id|SYMMETRIC_LEFT
)paren
id|commit-&gt;object.flags
op_or_assign
id|SHOWN
suffix:semicolon
)brace
r_else
multiline_comment|/* revs-&gt;left_only is set */
r_if
c_cond
(paren
op_logical_neg
(paren
id|commit-&gt;object.flags
op_amp
id|SYMMETRIC_LEFT
)paren
)paren
id|commit-&gt;object.flags
op_or_assign
id|SHOWN
suffix:semicolon
)brace
)brace
DECL|function|limit_list
r_static
r_int
id|limit_list
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
)paren
(brace
r_int
id|slop
op_assign
id|SLOP
suffix:semicolon
r_int
r_int
id|date
op_assign
op_complement
l_int|0ul
suffix:semicolon
r_struct
id|commit_list
op_star
id|list
op_assign
id|revs-&gt;commits
suffix:semicolon
r_struct
id|commit_list
op_star
id|newlist
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|commit_list
op_star
op_star
id|p
op_assign
op_amp
id|newlist
suffix:semicolon
r_struct
id|commit_list
op_star
id|bottom
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;ancestry_path
)paren
(brace
id|bottom
op_assign
id|collect_bottom_commits
c_func
(paren
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bottom
)paren
id|die
c_func
(paren
l_string|&quot;--ancestry-path given but there are no bottom commits&quot;
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|list
)paren
(brace
r_struct
id|commit_list
op_star
id|entry
op_assign
id|list
suffix:semicolon
r_struct
id|commit
op_star
id|commit
op_assign
id|list-&gt;item
suffix:semicolon
r_struct
id|object
op_star
id|obj
op_assign
op_amp
id|commit-&gt;object
suffix:semicolon
id|show_early_output_fn_t
id|show
suffix:semicolon
id|list
op_assign
id|list-&gt;next
suffix:semicolon
id|free
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;max_age
op_ne
l_int|1
op_logical_and
(paren
id|commit-&gt;date
OL
id|revs-&gt;max_age
)paren
)paren
id|obj-&gt;flags
op_or_assign
id|UNINTERESTING
suffix:semicolon
r_if
c_cond
(paren
id|add_parents_to_list
c_func
(paren
id|revs
comma
id|commit
comma
op_amp
id|list
comma
l_int|NULL
)paren
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|obj-&gt;flags
op_amp
id|UNINTERESTING
)paren
(brace
id|mark_parents_uninteresting
c_func
(paren
id|commit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;show_all
)paren
id|p
op_assign
op_amp
id|commit_list_insert
c_func
(paren
id|commit
comma
id|p
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
id|slop
op_assign
id|still_interesting
c_func
(paren
id|list
comma
id|date
comma
id|slop
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slop
)paren
r_continue
suffix:semicolon
multiline_comment|/* If showing all, add the whole pending list to the end */
r_if
c_cond
(paren
id|revs-&gt;show_all
)paren
op_star
id|p
op_assign
id|list
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|revs-&gt;min_age
op_ne
l_int|1
op_logical_and
(paren
id|commit-&gt;date
OG
id|revs-&gt;min_age
)paren
)paren
r_continue
suffix:semicolon
id|date
op_assign
id|commit-&gt;date
suffix:semicolon
id|p
op_assign
op_amp
id|commit_list_insert
c_func
(paren
id|commit
comma
id|p
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
id|show
op_assign
id|show_early_output
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|show
)paren
r_continue
suffix:semicolon
id|show
c_func
(paren
id|revs
comma
id|newlist
)paren
suffix:semicolon
id|show_early_output
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|revs-&gt;cherry_pick
op_logical_or
id|revs-&gt;cherry_mark
)paren
id|cherry_pick_list
c_func
(paren
id|newlist
comma
id|revs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;left_only
op_logical_or
id|revs-&gt;right_only
)paren
id|limit_left_right
c_func
(paren
id|newlist
comma
id|revs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bottom
)paren
(brace
id|limit_to_ancestry
c_func
(paren
id|bottom
comma
id|newlist
)paren
suffix:semicolon
id|free_commit_list
c_func
(paren
id|bottom
)paren
suffix:semicolon
)brace
id|revs-&gt;commits
op_assign
id|newlist
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|struct|all_refs_cb
r_struct
id|all_refs_cb
(brace
DECL|member|all_flags
r_int
id|all_flags
suffix:semicolon
DECL|member|warned_bad_reflog
r_int
id|warned_bad_reflog
suffix:semicolon
DECL|member|all_revs
r_struct
id|rev_info
op_star
id|all_revs
suffix:semicolon
DECL|member|name_for_errormsg
r_const
r_char
op_star
id|name_for_errormsg
suffix:semicolon
)brace
suffix:semicolon
DECL|function|handle_one_ref
r_static
r_int
id|handle_one_ref
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
id|flag
comma
r_void
op_star
id|cb_data
)paren
(brace
r_struct
id|all_refs_cb
op_star
id|cb
op_assign
id|cb_data
suffix:semicolon
r_struct
id|object
op_star
id|object
op_assign
id|get_reference
c_func
(paren
id|cb-&gt;all_revs
comma
id|path
comma
id|sha1
comma
id|cb-&gt;all_flags
)paren
suffix:semicolon
id|add_pending_object
c_func
(paren
id|cb-&gt;all_revs
comma
id|object
comma
id|path
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|init_all_refs_cb
r_static
r_void
id|init_all_refs_cb
c_func
(paren
r_struct
id|all_refs_cb
op_star
id|cb
comma
r_struct
id|rev_info
op_star
id|revs
comma
r_int
id|flags
)paren
(brace
id|cb-&gt;all_revs
op_assign
id|revs
suffix:semicolon
id|cb-&gt;all_flags
op_assign
id|flags
suffix:semicolon
)brace
DECL|function|handle_refs
r_static
r_void
id|handle_refs
c_func
(paren
r_const
r_char
op_star
id|submodule
comma
r_struct
id|rev_info
op_star
id|revs
comma
r_int
id|flags
comma
r_int
(paren
op_star
id|for_each
)paren
(paren
r_const
r_char
op_star
comma
id|each_ref_fn
comma
r_void
op_star
)paren
)paren
(brace
r_struct
id|all_refs_cb
id|cb
suffix:semicolon
id|init_all_refs_cb
c_func
(paren
op_amp
id|cb
comma
id|revs
comma
id|flags
)paren
suffix:semicolon
id|for_each
c_func
(paren
id|submodule
comma
id|handle_one_ref
comma
op_amp
id|cb
)paren
suffix:semicolon
)brace
DECL|function|handle_one_reflog_commit
r_static
r_void
id|handle_one_reflog_commit
c_func
(paren
r_int
r_char
op_star
id|sha1
comma
r_void
op_star
id|cb_data
)paren
(brace
r_struct
id|all_refs_cb
op_star
id|cb
op_assign
id|cb_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_null_sha1
c_func
(paren
id|sha1
)paren
)paren
(brace
r_struct
id|object
op_star
id|o
op_assign
id|parse_object
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|o
)paren
(brace
id|o-&gt;flags
op_or_assign
id|cb-&gt;all_flags
suffix:semicolon
id|add_pending_object
c_func
(paren
id|cb-&gt;all_revs
comma
id|o
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|cb-&gt;warned_bad_reflog
)paren
(brace
id|warning
c_func
(paren
l_string|&quot;reflog of &squot;%s&squot; references pruned commits&quot;
comma
id|cb-&gt;name_for_errormsg
)paren
suffix:semicolon
id|cb-&gt;warned_bad_reflog
op_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
DECL|function|handle_one_reflog_ent
r_static
r_int
id|handle_one_reflog_ent
c_func
(paren
r_int
r_char
op_star
id|osha1
comma
r_int
r_char
op_star
id|nsha1
comma
r_const
r_char
op_star
id|email
comma
r_int
r_int
id|timestamp
comma
r_int
id|tz
comma
r_const
r_char
op_star
id|message
comma
r_void
op_star
id|cb_data
)paren
(brace
id|handle_one_reflog_commit
c_func
(paren
id|osha1
comma
id|cb_data
)paren
suffix:semicolon
id|handle_one_reflog_commit
c_func
(paren
id|nsha1
comma
id|cb_data
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|handle_one_reflog
r_static
r_int
id|handle_one_reflog
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
id|flag
comma
r_void
op_star
id|cb_data
)paren
(brace
r_struct
id|all_refs_cb
op_star
id|cb
op_assign
id|cb_data
suffix:semicolon
id|cb-&gt;warned_bad_reflog
op_assign
l_int|0
suffix:semicolon
id|cb-&gt;name_for_errormsg
op_assign
id|path
suffix:semicolon
id|for_each_reflog_ent
c_func
(paren
id|path
comma
id|handle_one_reflog_ent
comma
id|cb_data
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|handle_reflog
r_static
r_void
id|handle_reflog
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_int
id|flags
)paren
(brace
r_struct
id|all_refs_cb
id|cb
suffix:semicolon
id|cb.all_revs
op_assign
id|revs
suffix:semicolon
id|cb.all_flags
op_assign
id|flags
suffix:semicolon
id|for_each_reflog
c_func
(paren
id|handle_one_reflog
comma
op_amp
id|cb
)paren
suffix:semicolon
)brace
DECL|function|add_parents_only
r_static
r_int
id|add_parents_only
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_const
r_char
op_star
id|arg
comma
r_int
id|flags
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_struct
id|object
op_star
id|it
suffix:semicolon
r_struct
id|commit
op_star
id|commit
suffix:semicolon
r_struct
id|commit_list
op_star
id|parents
suffix:semicolon
r_if
c_cond
(paren
op_star
id|arg
op_eq
l_char|&squot;^&squot;
)paren
(brace
id|flags
op_xor_assign
id|UNINTERESTING
suffix:semicolon
id|arg
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|get_sha1
c_func
(paren
id|arg
comma
id|sha1
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|it
op_assign
id|get_reference
c_func
(paren
id|revs
comma
id|arg
comma
id|sha1
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|it
op_logical_and
id|revs-&gt;ignore_missing
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|it-&gt;type
op_ne
id|OBJ_TAG
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
r_struct
id|tag
op_star
)paren
id|it
)paren
op_member_access_from_pointer
id|tagged
)paren
r_return
l_int|0
suffix:semicolon
id|hashcpy
c_func
(paren
id|sha1
comma
(paren
(paren
r_struct
id|tag
op_star
)paren
id|it
)paren
op_member_access_from_pointer
id|tagged-&gt;sha1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|it-&gt;type
op_ne
id|OBJ_COMMIT
)paren
r_return
l_int|0
suffix:semicolon
id|commit
op_assign
(paren
r_struct
id|commit
op_star
)paren
id|it
suffix:semicolon
r_for
c_loop
(paren
id|parents
op_assign
id|commit-&gt;parents
suffix:semicolon
id|parents
suffix:semicolon
id|parents
op_assign
id|parents-&gt;next
)paren
(brace
id|it
op_assign
op_amp
id|parents-&gt;item-&gt;object
suffix:semicolon
id|it-&gt;flags
op_or_assign
id|flags
suffix:semicolon
id|add_pending_object
c_func
(paren
id|revs
comma
id|it
comma
id|arg
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|init_revisions
r_void
id|init_revisions
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_const
r_char
op_star
id|prefix
)paren
(brace
id|memset
c_func
(paren
id|revs
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|revs
)paren
)paren
suffix:semicolon
id|revs-&gt;abbrev
op_assign
id|DEFAULT_ABBREV
suffix:semicolon
id|revs-&gt;ignore_merges
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;simplify_history
op_assign
l_int|1
suffix:semicolon
id|DIFF_OPT_SET
c_func
(paren
op_amp
id|revs-&gt;pruning
comma
id|RECURSIVE
)paren
suffix:semicolon
id|DIFF_OPT_SET
c_func
(paren
op_amp
id|revs-&gt;pruning
comma
id|QUICK
)paren
suffix:semicolon
id|revs-&gt;pruning.add_remove
op_assign
id|file_add_remove
suffix:semicolon
id|revs-&gt;pruning.change
op_assign
id|file_change
suffix:semicolon
id|revs-&gt;lifo
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;dense
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;prefix
op_assign
id|prefix
suffix:semicolon
id|revs-&gt;max_age
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;min_age
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;skip_count
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;max_count
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;max_parents
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;commit_format
op_assign
id|CMIT_FMT_DEFAULT
suffix:semicolon
id|revs-&gt;grep_filter.status_only
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;grep_filter.pattern_tail
op_assign
op_amp
(paren
id|revs-&gt;grep_filter.pattern_list
)paren
suffix:semicolon
id|revs-&gt;grep_filter.header_tail
op_assign
op_amp
(paren
id|revs-&gt;grep_filter.header_list
)paren
suffix:semicolon
id|revs-&gt;grep_filter.regflags
op_assign
id|REG_NEWLINE
suffix:semicolon
id|diff_setup
c_func
(paren
op_amp
id|revs-&gt;diffopt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prefix
op_logical_and
op_logical_neg
id|revs-&gt;diffopt.prefix
)paren
(brace
id|revs-&gt;diffopt.prefix
op_assign
id|prefix
suffix:semicolon
id|revs-&gt;diffopt.prefix_length
op_assign
id|strlen
c_func
(paren
id|prefix
)paren
suffix:semicolon
)brace
id|revs-&gt;notes_opt.use_default_notes
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|add_pending_commit_list
r_static
r_void
id|add_pending_commit_list
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_struct
id|commit_list
op_star
id|commit_list
comma
r_int
r_int
id|flags
)paren
(brace
r_while
c_loop
(paren
id|commit_list
)paren
(brace
r_struct
id|object
op_star
id|object
op_assign
op_amp
id|commit_list-&gt;item-&gt;object
suffix:semicolon
id|object-&gt;flags
op_or_assign
id|flags
suffix:semicolon
id|add_pending_object
c_func
(paren
id|revs
comma
id|object
comma
id|sha1_to_hex
c_func
(paren
id|object-&gt;sha1
)paren
)paren
suffix:semicolon
id|commit_list
op_assign
id|commit_list-&gt;next
suffix:semicolon
)brace
)brace
DECL|function|prepare_show_merge
r_static
r_void
id|prepare_show_merge
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
)paren
(brace
r_struct
id|commit_list
op_star
id|bases
suffix:semicolon
r_struct
id|commit
op_star
id|head
comma
op_star
id|other
suffix:semicolon
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_const
r_char
op_star
op_star
id|prune
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
comma
id|prune_num
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* counting terminating NULL */
r_if
c_cond
(paren
id|get_sha1
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|sha1
)paren
op_logical_or
op_logical_neg
(paren
id|head
op_assign
id|lookup_commit
c_func
(paren
id|sha1
)paren
)paren
)paren
id|die
c_func
(paren
l_string|&quot;--merge without HEAD?&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1
c_func
(paren
l_string|&quot;MERGE_HEAD&quot;
comma
id|sha1
)paren
op_logical_or
op_logical_neg
(paren
id|other
op_assign
id|lookup_commit
c_func
(paren
id|sha1
)paren
)paren
)paren
id|die
c_func
(paren
l_string|&quot;--merge without MERGE_HEAD?&quot;
)paren
suffix:semicolon
id|add_pending_object
c_func
(paren
id|revs
comma
op_amp
id|head-&gt;object
comma
l_string|&quot;HEAD&quot;
)paren
suffix:semicolon
id|add_pending_object
c_func
(paren
id|revs
comma
op_amp
id|other-&gt;object
comma
l_string|&quot;MERGE_HEAD&quot;
)paren
suffix:semicolon
id|bases
op_assign
id|get_merge_bases
c_func
(paren
id|head
comma
id|other
comma
l_int|1
)paren
suffix:semicolon
id|add_pending_commit_list
c_func
(paren
id|revs
comma
id|bases
comma
id|UNINTERESTING
)paren
suffix:semicolon
id|free_commit_list
c_func
(paren
id|bases
)paren
suffix:semicolon
id|head-&gt;object.flags
op_or_assign
id|SYMMETRIC_LEFT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|active_nr
)paren
id|read_cache
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|active_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|cache_entry
op_star
id|ce
op_assign
id|active_cache
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ce_stage
c_func
(paren
id|ce
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|ce_path_match
c_func
(paren
id|ce
comma
op_amp
id|revs-&gt;prune_data
)paren
)paren
(brace
id|prune_num
op_increment
suffix:semicolon
id|prune
op_assign
id|xrealloc
c_func
(paren
id|prune
comma
r_sizeof
(paren
op_star
id|prune
)paren
op_star
id|prune_num
)paren
suffix:semicolon
id|prune
(braket
id|prune_num
op_minus
l_int|2
)braket
op_assign
id|ce-&gt;name
suffix:semicolon
id|prune
(braket
id|prune_num
op_minus
l_int|1
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|i
op_plus
l_int|1
OL
id|active_nr
)paren
op_logical_and
id|ce_same_name
c_func
(paren
id|ce
comma
id|active_cache
(braket
id|i
op_plus
l_int|1
)braket
)paren
)paren
id|i
op_increment
suffix:semicolon
)brace
id|free_pathspec
c_func
(paren
op_amp
id|revs-&gt;prune_data
)paren
suffix:semicolon
id|init_pathspec
c_func
(paren
op_amp
id|revs-&gt;prune_data
comma
id|prune
)paren
suffix:semicolon
id|revs-&gt;limited
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|handle_revision_arg
r_int
id|handle_revision_arg
c_func
(paren
r_const
r_char
op_star
id|arg
comma
r_struct
id|rev_info
op_star
id|revs
comma
r_int
id|flags
comma
r_int
id|cant_be_filename
)paren
(brace
r_int
id|mode
suffix:semicolon
r_char
op_star
id|dotdot
suffix:semicolon
r_struct
id|object
op_star
id|object
suffix:semicolon
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_int
id|local_flags
suffix:semicolon
id|dotdot
op_assign
id|strstr
c_func
(paren
id|arg
comma
l_string|&quot;..&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dotdot
)paren
(brace
r_int
r_char
id|from_sha1
(braket
l_int|20
)braket
suffix:semicolon
r_const
r_char
op_star
id|next
op_assign
id|dotdot
op_plus
l_int|2
suffix:semicolon
r_const
r_char
op_star
id|this
op_assign
id|arg
suffix:semicolon
r_int
id|symmetric
op_assign
op_star
id|next
op_eq
l_char|&squot;.&squot;
suffix:semicolon
r_int
r_int
id|flags_exclude
op_assign
id|flags
op_xor
id|UNINTERESTING
suffix:semicolon
op_star
id|dotdot
op_assign
l_int|0
suffix:semicolon
id|next
op_add_assign
id|symmetric
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|next
)paren
id|next
op_assign
l_string|&quot;HEAD&quot;
suffix:semicolon
r_if
c_cond
(paren
id|dotdot
op_eq
id|arg
)paren
id|this
op_assign
l_string|&quot;HEAD&quot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|get_sha1
c_func
(paren
id|this
comma
id|from_sha1
)paren
op_logical_and
op_logical_neg
id|get_sha1
c_func
(paren
id|next
comma
id|sha1
)paren
)paren
(brace
r_struct
id|commit
op_star
id|a
comma
op_star
id|b
suffix:semicolon
r_struct
id|commit_list
op_star
id|exclude
suffix:semicolon
id|a
op_assign
id|lookup_commit_reference
c_func
(paren
id|from_sha1
)paren
suffix:semicolon
id|b
op_assign
id|lookup_commit_reference
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|a
op_logical_or
op_logical_neg
id|b
)paren
(brace
r_if
c_cond
(paren
id|revs-&gt;ignore_missing
)paren
r_return
l_int|0
suffix:semicolon
id|die
c_func
(paren
id|symmetric
ques
c_cond
l_string|&quot;Invalid symmetric difference expression %s...%s&quot;
suffix:colon
l_string|&quot;Invalid revision range %s..%s&quot;
comma
id|arg
comma
id|next
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|cant_be_filename
)paren
(brace
op_star
id|dotdot
op_assign
l_char|&squot;.&squot;
suffix:semicolon
id|verify_non_filename
c_func
(paren
id|revs-&gt;prefix
comma
id|arg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|symmetric
)paren
(brace
id|exclude
op_assign
id|get_merge_bases
c_func
(paren
id|a
comma
id|b
comma
l_int|1
)paren
suffix:semicolon
id|add_pending_commit_list
c_func
(paren
id|revs
comma
id|exclude
comma
id|flags_exclude
)paren
suffix:semicolon
id|free_commit_list
c_func
(paren
id|exclude
)paren
suffix:semicolon
id|a-&gt;object.flags
op_or_assign
id|flags
op_or
id|SYMMETRIC_LEFT
suffix:semicolon
)brace
r_else
id|a-&gt;object.flags
op_or_assign
id|flags_exclude
suffix:semicolon
id|b-&gt;object.flags
op_or_assign
id|flags
suffix:semicolon
id|add_pending_object
c_func
(paren
id|revs
comma
op_amp
id|a-&gt;object
comma
id|this
)paren
suffix:semicolon
id|add_pending_object
c_func
(paren
id|revs
comma
op_amp
id|b-&gt;object
comma
id|next
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
op_star
id|dotdot
op_assign
l_char|&squot;.&squot;
suffix:semicolon
)brace
id|dotdot
op_assign
id|strstr
c_func
(paren
id|arg
comma
l_string|&quot;^@&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dotdot
op_logical_and
op_logical_neg
id|dotdot
(braket
l_int|2
)braket
)paren
(brace
op_star
id|dotdot
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|add_parents_only
c_func
(paren
id|revs
comma
id|arg
comma
id|flags
)paren
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|dotdot
op_assign
l_char|&squot;^&squot;
suffix:semicolon
)brace
id|dotdot
op_assign
id|strstr
c_func
(paren
id|arg
comma
l_string|&quot;^!&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dotdot
op_logical_and
op_logical_neg
id|dotdot
(braket
l_int|2
)braket
)paren
(brace
op_star
id|dotdot
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|add_parents_only
c_func
(paren
id|revs
comma
id|arg
comma
id|flags
op_xor
id|UNINTERESTING
)paren
)paren
op_star
id|dotdot
op_assign
l_char|&squot;^&squot;
suffix:semicolon
)brace
id|local_flags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_star
id|arg
op_eq
l_char|&squot;^&squot;
)paren
(brace
id|local_flags
op_assign
id|UNINTERESTING
suffix:semicolon
id|arg
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|get_sha1_with_mode
c_func
(paren
id|arg
comma
id|sha1
comma
op_amp
id|mode
)paren
)paren
r_return
id|revs-&gt;ignore_missing
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cant_be_filename
)paren
id|verify_non_filename
c_func
(paren
id|revs-&gt;prefix
comma
id|arg
)paren
suffix:semicolon
id|object
op_assign
id|get_reference
c_func
(paren
id|revs
comma
id|arg
comma
id|sha1
comma
id|flags
op_xor
id|local_flags
)paren
suffix:semicolon
id|add_pending_object_with_mode
c_func
(paren
id|revs
comma
id|object
comma
id|arg
comma
id|mode
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|struct|cmdline_pathspec
r_struct
id|cmdline_pathspec
(brace
DECL|member|alloc
r_int
id|alloc
suffix:semicolon
DECL|member|nr
r_int
id|nr
suffix:semicolon
DECL|member|path
r_const
r_char
op_star
op_star
id|path
suffix:semicolon
)brace
suffix:semicolon
DECL|function|append_prune_data
r_static
r_void
id|append_prune_data
c_func
(paren
r_struct
id|cmdline_pathspec
op_star
id|prune
comma
r_const
r_char
op_star
op_star
id|av
)paren
(brace
r_while
c_loop
(paren
op_star
id|av
)paren
(brace
id|ALLOC_GROW
c_func
(paren
id|prune-&gt;path
comma
id|prune-&gt;nr
op_plus
l_int|1
comma
id|prune-&gt;alloc
)paren
suffix:semicolon
id|prune-&gt;path
(braket
id|prune-&gt;nr
op_increment
)braket
op_assign
op_star
(paren
id|av
op_increment
)paren
suffix:semicolon
)brace
)brace
DECL|function|read_pathspec_from_stdin
r_static
r_void
id|read_pathspec_from_stdin
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_struct
id|strbuf
op_star
id|sb
comma
r_struct
id|cmdline_pathspec
op_star
id|prune
)paren
(brace
r_while
c_loop
(paren
id|strbuf_getwholeline
c_func
(paren
id|sb
comma
id|stdin
comma
l_char|&squot;&bslash;n&squot;
)paren
op_ne
id|EOF
)paren
(brace
r_int
id|len
op_assign
id|sb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|len
op_logical_and
id|sb-&gt;buf
(braket
id|len
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|sb-&gt;buf
(braket
op_decrement
id|len
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|ALLOC_GROW
c_func
(paren
id|prune-&gt;path
comma
id|prune-&gt;nr
op_plus
l_int|1
comma
id|prune-&gt;alloc
)paren
suffix:semicolon
id|prune-&gt;path
(braket
id|prune-&gt;nr
op_increment
)braket
op_assign
id|xstrdup
c_func
(paren
id|sb-&gt;buf
)paren
suffix:semicolon
)brace
)brace
DECL|function|read_revisions_from_stdin
r_static
r_void
id|read_revisions_from_stdin
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_struct
id|cmdline_pathspec
op_star
id|prune
)paren
(brace
r_struct
id|strbuf
id|sb
suffix:semicolon
r_int
id|seen_dashdash
op_assign
l_int|0
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|sb
comma
l_int|1000
)paren
suffix:semicolon
r_while
c_loop
(paren
id|strbuf_getwholeline
c_func
(paren
op_amp
id|sb
comma
id|stdin
comma
l_char|&squot;&bslash;n&squot;
)paren
op_ne
id|EOF
)paren
(brace
r_int
id|len
op_assign
id|sb.len
suffix:semicolon
r_if
c_cond
(paren
id|len
op_logical_and
id|sb.buf
(braket
id|len
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|sb.buf
(braket
op_decrement
id|len
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|sb.buf
(braket
l_int|0
)braket
op_eq
l_char|&squot;-&squot;
)paren
(brace
r_if
c_cond
(paren
id|len
op_eq
l_int|2
op_logical_and
id|sb.buf
(braket
l_int|1
)braket
op_eq
l_char|&squot;-&squot;
)paren
(brace
id|seen_dashdash
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|die
c_func
(paren
l_string|&quot;options not supported in --stdin mode&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|handle_revision_arg
c_func
(paren
id|sb.buf
comma
id|revs
comma
l_int|0
comma
l_int|1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;bad revision &squot;%s&squot;&quot;
comma
id|sb.buf
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|seen_dashdash
)paren
id|read_pathspec_from_stdin
c_func
(paren
id|revs
comma
op_amp
id|sb
comma
id|prune
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
)brace
DECL|function|add_grep
r_static
r_void
id|add_grep
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_const
r_char
op_star
id|ptn
comma
r_enum
id|grep_pat_token
id|what
)paren
(brace
id|append_grep_pattern
c_func
(paren
op_amp
id|revs-&gt;grep_filter
comma
id|ptn
comma
l_string|&quot;command line&quot;
comma
l_int|0
comma
id|what
)paren
suffix:semicolon
)brace
DECL|function|add_header_grep
r_static
r_void
id|add_header_grep
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_enum
id|grep_header_field
id|field
comma
r_const
r_char
op_star
id|pattern
)paren
(brace
id|append_header_grep_pattern
c_func
(paren
op_amp
id|revs-&gt;grep_filter
comma
id|field
comma
id|pattern
)paren
suffix:semicolon
)brace
DECL|function|add_message_grep
r_static
r_void
id|add_message_grep
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_const
r_char
op_star
id|pattern
)paren
(brace
id|add_grep
c_func
(paren
id|revs
comma
id|pattern
comma
id|GREP_PATTERN_BODY
)paren
suffix:semicolon
)brace
DECL|function|handle_revision_opt
r_static
r_int
id|handle_revision_opt
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_int
id|argc
comma
r_const
r_char
op_star
op_star
id|argv
comma
r_int
op_star
id|unkc
comma
r_const
r_char
op_star
op_star
id|unkv
)paren
(brace
r_const
r_char
op_star
id|arg
op_assign
id|argv
(braket
l_int|0
)braket
suffix:semicolon
r_const
r_char
op_star
id|optarg
suffix:semicolon
r_int
id|argcount
suffix:semicolon
multiline_comment|/* pseudo revision arguments */
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--all&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--branches&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--tags&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--remotes&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--reflog&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--not&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--no-walk&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--do-walk&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--bisect&quot;
)paren
op_logical_or
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;--glob=&quot;
)paren
op_logical_or
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;--branches=&quot;
)paren
op_logical_or
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;--tags=&quot;
)paren
op_logical_or
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;--remotes=&quot;
)paren
)paren
(brace
id|unkv
(braket
(paren
op_star
id|unkc
)paren
op_increment
)braket
op_assign
id|arg
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|argcount
op_assign
id|parse_long_opt
c_func
(paren
l_string|&quot;max-count&quot;
comma
id|argv
comma
op_amp
id|optarg
)paren
)paren
)paren
(brace
id|revs-&gt;max_count
op_assign
id|atoi
c_func
(paren
id|optarg
)paren
suffix:semicolon
id|revs-&gt;no_walk
op_assign
l_int|0
suffix:semicolon
r_return
id|argcount
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|argcount
op_assign
id|parse_long_opt
c_func
(paren
l_string|&quot;skip&quot;
comma
id|argv
comma
op_amp
id|optarg
)paren
)paren
)paren
(brace
id|revs-&gt;skip_count
op_assign
id|atoi
c_func
(paren
id|optarg
)paren
suffix:semicolon
r_return
id|argcount
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
op_star
id|arg
op_eq
l_char|&squot;-&squot;
)paren
op_logical_and
id|isdigit
c_func
(paren
id|arg
(braket
l_int|1
)braket
)paren
)paren
(brace
multiline_comment|/* accept -&lt;digit&gt;, like traditional &quot;head&quot; */
id|revs-&gt;max_count
op_assign
id|atoi
c_func
(paren
id|arg
op_plus
l_int|1
)paren
suffix:semicolon
id|revs-&gt;no_walk
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;-n&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|argc
op_le
l_int|1
)paren
r_return
id|error
c_func
(paren
l_string|&quot;-n requires an argument&quot;
)paren
suffix:semicolon
id|revs-&gt;max_count
op_assign
id|atoi
c_func
(paren
id|argv
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|revs-&gt;no_walk
op_assign
l_int|0
suffix:semicolon
r_return
l_int|2
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;-n&quot;
)paren
)paren
(brace
id|revs-&gt;max_count
op_assign
id|atoi
c_func
(paren
id|arg
op_plus
l_int|2
)paren
suffix:semicolon
id|revs-&gt;no_walk
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|argcount
op_assign
id|parse_long_opt
c_func
(paren
l_string|&quot;max-age&quot;
comma
id|argv
comma
op_amp
id|optarg
)paren
)paren
)paren
(brace
id|revs-&gt;max_age
op_assign
id|atoi
c_func
(paren
id|optarg
)paren
suffix:semicolon
r_return
id|argcount
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|argcount
op_assign
id|parse_long_opt
c_func
(paren
l_string|&quot;since&quot;
comma
id|argv
comma
op_amp
id|optarg
)paren
)paren
)paren
(brace
id|revs-&gt;max_age
op_assign
id|approxidate
c_func
(paren
id|optarg
)paren
suffix:semicolon
r_return
id|argcount
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|argcount
op_assign
id|parse_long_opt
c_func
(paren
l_string|&quot;after&quot;
comma
id|argv
comma
op_amp
id|optarg
)paren
)paren
)paren
(brace
id|revs-&gt;max_age
op_assign
id|approxidate
c_func
(paren
id|optarg
)paren
suffix:semicolon
r_return
id|argcount
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|argcount
op_assign
id|parse_long_opt
c_func
(paren
l_string|&quot;min-age&quot;
comma
id|argv
comma
op_amp
id|optarg
)paren
)paren
)paren
(brace
id|revs-&gt;min_age
op_assign
id|atoi
c_func
(paren
id|optarg
)paren
suffix:semicolon
r_return
id|argcount
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|argcount
op_assign
id|parse_long_opt
c_func
(paren
l_string|&quot;before&quot;
comma
id|argv
comma
op_amp
id|optarg
)paren
)paren
)paren
(brace
id|revs-&gt;min_age
op_assign
id|approxidate
c_func
(paren
id|optarg
)paren
suffix:semicolon
r_return
id|argcount
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|argcount
op_assign
id|parse_long_opt
c_func
(paren
l_string|&quot;until&quot;
comma
id|argv
comma
op_amp
id|optarg
)paren
)paren
)paren
(brace
id|revs-&gt;min_age
op_assign
id|approxidate
c_func
(paren
id|optarg
)paren
suffix:semicolon
r_return
id|argcount
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--first-parent&quot;
)paren
)paren
(brace
id|revs-&gt;first_parent_only
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--ancestry-path&quot;
)paren
)paren
(brace
id|revs-&gt;ancestry_path
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;simplify_history
op_assign
l_int|0
suffix:semicolon
id|revs-&gt;limited
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;-g&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--walk-reflogs&quot;
)paren
)paren
(brace
id|init_reflog_walk
c_func
(paren
op_amp
id|revs-&gt;reflog_info
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--default&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|argc
op_le
l_int|1
)paren
r_return
id|error
c_func
(paren
l_string|&quot;bad --default argument&quot;
)paren
suffix:semicolon
id|revs-&gt;def
op_assign
id|argv
(braket
l_int|1
)braket
suffix:semicolon
r_return
l_int|2
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--merge&quot;
)paren
)paren
(brace
id|revs-&gt;show_merge
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--topo-order&quot;
)paren
)paren
(brace
id|revs-&gt;lifo
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;topo_order
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--simplify-merges&quot;
)paren
)paren
(brace
id|revs-&gt;simplify_merges
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;rewrite_parents
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;simplify_history
op_assign
l_int|0
suffix:semicolon
id|revs-&gt;limited
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--simplify-by-decoration&quot;
)paren
)paren
(brace
id|revs-&gt;simplify_merges
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;rewrite_parents
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;simplify_history
op_assign
l_int|0
suffix:semicolon
id|revs-&gt;simplify_by_decoration
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;limited
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;prune
op_assign
l_int|1
suffix:semicolon
id|load_ref_decorations
c_func
(paren
id|DECORATE_SHORT_REFS
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--date-order&quot;
)paren
)paren
(brace
id|revs-&gt;lifo
op_assign
l_int|0
suffix:semicolon
id|revs-&gt;topo_order
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;--early-output&quot;
)paren
)paren
(brace
r_int
id|count
op_assign
l_int|100
suffix:semicolon
r_switch
c_cond
(paren
id|arg
(braket
l_int|14
)braket
)paren
(brace
r_case
l_char|&squot;=&squot;
suffix:colon
id|count
op_assign
id|atoi
c_func
(paren
id|arg
op_plus
l_int|15
)paren
suffix:semicolon
multiline_comment|/* Fallthrough */
r_case
l_int|0
suffix:colon
id|revs-&gt;topo_order
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;early_output
op_assign
id|count
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--parents&quot;
)paren
)paren
(brace
id|revs-&gt;rewrite_parents
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;print_parents
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--dense&quot;
)paren
)paren
(brace
id|revs-&gt;dense
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--sparse&quot;
)paren
)paren
(brace
id|revs-&gt;dense
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--show-all&quot;
)paren
)paren
(brace
id|revs-&gt;show_all
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--remove-empty&quot;
)paren
)paren
(brace
id|revs-&gt;remove_empty_trees
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--merges&quot;
)paren
)paren
(brace
id|revs-&gt;min_parents
op_assign
l_int|2
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--no-merges&quot;
)paren
)paren
(brace
id|revs-&gt;max_parents
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;--min-parents=&quot;
)paren
)paren
(brace
id|revs-&gt;min_parents
op_assign
id|atoi
c_func
(paren
id|arg
op_plus
l_int|14
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;--no-min-parents&quot;
)paren
)paren
(brace
id|revs-&gt;min_parents
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;--max-parents=&quot;
)paren
)paren
(brace
id|revs-&gt;max_parents
op_assign
id|atoi
c_func
(paren
id|arg
op_plus
l_int|14
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;--no-max-parents&quot;
)paren
)paren
(brace
id|revs-&gt;max_parents
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--boundary&quot;
)paren
)paren
(brace
id|revs-&gt;boundary
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--left-right&quot;
)paren
)paren
(brace
id|revs-&gt;left_right
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--left-only&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|revs-&gt;right_only
)paren
id|die
c_func
(paren
l_string|&quot;--left-only is incompatible with --right-only&quot;
l_string|&quot; or --cherry&quot;
)paren
suffix:semicolon
id|revs-&gt;left_only
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--right-only&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|revs-&gt;left_only
)paren
id|die
c_func
(paren
l_string|&quot;--right-only is incompatible with --left-only&quot;
)paren
suffix:semicolon
id|revs-&gt;right_only
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--cherry&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|revs-&gt;left_only
)paren
id|die
c_func
(paren
l_string|&quot;--cherry is incompatible with --left-only&quot;
)paren
suffix:semicolon
id|revs-&gt;cherry_mark
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;right_only
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;max_parents
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;limited
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--count&quot;
)paren
)paren
(brace
id|revs-&gt;count
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--cherry-mark&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|revs-&gt;cherry_pick
)paren
id|die
c_func
(paren
l_string|&quot;--cherry-mark is incompatible with --cherry-pick&quot;
)paren
suffix:semicolon
id|revs-&gt;cherry_mark
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;limited
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* needs limit_list() */
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--cherry-pick&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|revs-&gt;cherry_mark
)paren
id|die
c_func
(paren
l_string|&quot;--cherry-pick is incompatible with --cherry-mark&quot;
)paren
suffix:semicolon
id|revs-&gt;cherry_pick
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;limited
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--objects&quot;
)paren
)paren
(brace
id|revs-&gt;tag_objects
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;tree_objects
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;blob_objects
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--objects-edge&quot;
)paren
)paren
(brace
id|revs-&gt;tag_objects
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;tree_objects
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;blob_objects
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;edge_hint
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--unpacked&quot;
)paren
)paren
(brace
id|revs-&gt;unpacked
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;--unpacked=&quot;
)paren
)paren
(brace
id|die
c_func
(paren
l_string|&quot;--unpacked=&lt;packfile&gt; no longer supported.&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;-r&quot;
)paren
)paren
(brace
id|revs-&gt;diff
op_assign
l_int|1
suffix:semicolon
id|DIFF_OPT_SET
c_func
(paren
op_amp
id|revs-&gt;diffopt
comma
id|RECURSIVE
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;-t&quot;
)paren
)paren
(brace
id|revs-&gt;diff
op_assign
l_int|1
suffix:semicolon
id|DIFF_OPT_SET
c_func
(paren
op_amp
id|revs-&gt;diffopt
comma
id|RECURSIVE
)paren
suffix:semicolon
id|DIFF_OPT_SET
c_func
(paren
op_amp
id|revs-&gt;diffopt
comma
id|TREE_IN_RECURSIVE
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;-m&quot;
)paren
)paren
(brace
id|revs-&gt;ignore_merges
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;-c&quot;
)paren
)paren
(brace
id|revs-&gt;diff
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;dense_combined_merges
op_assign
l_int|0
suffix:semicolon
id|revs-&gt;combine_merges
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--cc&quot;
)paren
)paren
(brace
id|revs-&gt;diff
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;dense_combined_merges
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;combine_merges
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;-v&quot;
)paren
)paren
(brace
id|revs-&gt;verbose_header
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--pretty&quot;
)paren
)paren
(brace
id|revs-&gt;verbose_header
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;pretty_given
op_assign
l_int|1
suffix:semicolon
id|get_commit_format
c_func
(paren
id|arg
op_plus
l_int|8
comma
id|revs
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;--pretty=&quot;
)paren
op_logical_or
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;--format=&quot;
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Detached form (&quot;--pretty X&quot; as opposed to &quot;--pretty=X&quot;)&n;&t;&t; * not allowed, since the argument is optional.&n;&t;&t; */
id|revs-&gt;verbose_header
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;pretty_given
op_assign
l_int|1
suffix:semicolon
id|get_commit_format
c_func
(paren
id|arg
op_plus
l_int|9
comma
id|revs
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--show-notes&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--notes&quot;
)paren
)paren
(brace
id|revs-&gt;show_notes
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;show_notes_given
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;notes_opt.use_default_notes
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;--show-notes=&quot;
)paren
op_logical_or
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;--notes=&quot;
)paren
)paren
(brace
r_struct
id|strbuf
id|buf
op_assign
id|STRBUF_INIT
suffix:semicolon
id|revs-&gt;show_notes
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;show_notes_given
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;--show-notes&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|revs-&gt;notes_opt.use_default_notes
OL
l_int|0
)paren
id|revs-&gt;notes_opt.use_default_notes
op_assign
l_int|1
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|buf
comma
id|arg
op_plus
l_int|13
)paren
suffix:semicolon
)brace
r_else
id|strbuf_addstr
c_func
(paren
op_amp
id|buf
comma
id|arg
op_plus
l_int|8
)paren
suffix:semicolon
id|expand_notes_ref
c_func
(paren
op_amp
id|buf
)paren
suffix:semicolon
id|string_list_append
c_func
(paren
op_amp
id|revs-&gt;notes_opt.extra_notes_refs
comma
id|strbuf_detach
c_func
(paren
op_amp
id|buf
comma
l_int|NULL
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--no-notes&quot;
)paren
)paren
(brace
id|revs-&gt;show_notes
op_assign
l_int|0
suffix:semicolon
id|revs-&gt;show_notes_given
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;notes_opt.use_default_notes
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* we have been strdup&squot;ing ourselves, so trick&n;&t;&t; * string_list into free()ing strings */
id|revs-&gt;notes_opt.extra_notes_refs.strdup_strings
op_assign
l_int|1
suffix:semicolon
id|string_list_clear
c_func
(paren
op_amp
id|revs-&gt;notes_opt.extra_notes_refs
comma
l_int|0
)paren
suffix:semicolon
id|revs-&gt;notes_opt.extra_notes_refs.strdup_strings
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--standard-notes&quot;
)paren
)paren
(brace
id|revs-&gt;show_notes_given
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;notes_opt.use_default_notes
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--no-standard-notes&quot;
)paren
)paren
(brace
id|revs-&gt;notes_opt.use_default_notes
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--oneline&quot;
)paren
)paren
(brace
id|revs-&gt;verbose_header
op_assign
l_int|1
suffix:semicolon
id|get_commit_format
c_func
(paren
l_string|&quot;oneline&quot;
comma
id|revs
)paren
suffix:semicolon
id|revs-&gt;pretty_given
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;abbrev_commit
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--graph&quot;
)paren
)paren
(brace
id|revs-&gt;topo_order
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;rewrite_parents
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;graph
op_assign
id|graph_init
c_func
(paren
id|revs
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--root&quot;
)paren
)paren
(brace
id|revs-&gt;show_root_diff
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--no-commit-id&quot;
)paren
)paren
(brace
id|revs-&gt;no_commit_id
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--always&quot;
)paren
)paren
(brace
id|revs-&gt;always_show_header
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--no-abbrev&quot;
)paren
)paren
(brace
id|revs-&gt;abbrev
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--abbrev&quot;
)paren
)paren
(brace
id|revs-&gt;abbrev
op_assign
id|DEFAULT_ABBREV
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;--abbrev=&quot;
)paren
)paren
(brace
id|revs-&gt;abbrev
op_assign
id|strtoul
c_func
(paren
id|arg
op_plus
l_int|9
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;abbrev
OL
id|MINIMUM_ABBREV
)paren
id|revs-&gt;abbrev
op_assign
id|MINIMUM_ABBREV
suffix:semicolon
r_else
r_if
c_cond
(paren
id|revs-&gt;abbrev
OG
l_int|40
)paren
id|revs-&gt;abbrev
op_assign
l_int|40
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--abbrev-commit&quot;
)paren
)paren
(brace
id|revs-&gt;abbrev_commit
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;abbrev_commit_given
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--no-abbrev-commit&quot;
)paren
)paren
(brace
id|revs-&gt;abbrev_commit
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--full-diff&quot;
)paren
)paren
(brace
id|revs-&gt;diff
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;full_diff
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--full-history&quot;
)paren
)paren
(brace
id|revs-&gt;simplify_history
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--relative-date&quot;
)paren
)paren
(brace
id|revs-&gt;date_mode
op_assign
id|DATE_RELATIVE
suffix:semicolon
id|revs-&gt;date_mode_explicit
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|argcount
op_assign
id|parse_long_opt
c_func
(paren
l_string|&quot;date&quot;
comma
id|argv
comma
op_amp
id|optarg
)paren
)paren
)paren
(brace
id|revs-&gt;date_mode
op_assign
id|parse_date_format
c_func
(paren
id|optarg
)paren
suffix:semicolon
id|revs-&gt;date_mode_explicit
op_assign
l_int|1
suffix:semicolon
r_return
id|argcount
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--log-size&quot;
)paren
)paren
(brace
id|revs-&gt;show_log_size
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Grepping the commit log&n;&t; */
r_else
r_if
c_cond
(paren
(paren
id|argcount
op_assign
id|parse_long_opt
c_func
(paren
l_string|&quot;author&quot;
comma
id|argv
comma
op_amp
id|optarg
)paren
)paren
)paren
(brace
id|add_header_grep
c_func
(paren
id|revs
comma
id|GREP_HEADER_AUTHOR
comma
id|optarg
)paren
suffix:semicolon
r_return
id|argcount
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|argcount
op_assign
id|parse_long_opt
c_func
(paren
l_string|&quot;committer&quot;
comma
id|argv
comma
op_amp
id|optarg
)paren
)paren
)paren
(brace
id|add_header_grep
c_func
(paren
id|revs
comma
id|GREP_HEADER_COMMITTER
comma
id|optarg
)paren
suffix:semicolon
r_return
id|argcount
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|argcount
op_assign
id|parse_long_opt
c_func
(paren
l_string|&quot;grep&quot;
comma
id|argv
comma
op_amp
id|optarg
)paren
)paren
)paren
(brace
id|add_message_grep
c_func
(paren
id|revs
comma
id|optarg
)paren
suffix:semicolon
r_return
id|argcount
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--extended-regexp&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;-E&quot;
)paren
)paren
(brace
id|revs-&gt;grep_filter.regflags
op_or_assign
id|REG_EXTENDED
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--regexp-ignore-case&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;-i&quot;
)paren
)paren
(brace
id|revs-&gt;grep_filter.regflags
op_or_assign
id|REG_ICASE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--fixed-strings&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;-F&quot;
)paren
)paren
(brace
id|revs-&gt;grep_filter.fixed
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--all-match&quot;
)paren
)paren
(brace
id|revs-&gt;grep_filter.all_match
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|argcount
op_assign
id|parse_long_opt
c_func
(paren
l_string|&quot;encoding&quot;
comma
id|argv
comma
op_amp
id|optarg
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|optarg
comma
l_string|&quot;none&quot;
)paren
)paren
id|git_log_output_encoding
op_assign
id|xstrdup
c_func
(paren
id|optarg
)paren
suffix:semicolon
r_else
id|git_log_output_encoding
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_return
id|argcount
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--reverse&quot;
)paren
)paren
(brace
id|revs-&gt;reverse
op_xor_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--children&quot;
)paren
)paren
(brace
id|revs-&gt;children.name
op_assign
l_string|&quot;children&quot;
suffix:semicolon
id|revs-&gt;limited
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--ignore-missing&quot;
)paren
)paren
(brace
id|revs-&gt;ignore_missing
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_int
id|opts
op_assign
id|diff_opt_parse
c_func
(paren
op_amp
id|revs-&gt;diffopt
comma
id|argv
comma
id|argc
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|opts
)paren
id|unkv
(braket
(paren
op_star
id|unkc
)paren
op_increment
)braket
op_assign
id|arg
suffix:semicolon
r_return
id|opts
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|parse_revision_opt
r_void
id|parse_revision_opt
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_struct
id|parse_opt_ctx_t
op_star
id|ctx
comma
r_const
r_struct
id|option
op_star
id|options
comma
r_const
r_char
op_star
r_const
id|usagestr
(braket
)braket
)paren
(brace
r_int
id|n
op_assign
id|handle_revision_opt
c_func
(paren
id|revs
comma
id|ctx-&gt;argc
comma
id|ctx-&gt;argv
comma
op_amp
id|ctx-&gt;cpidx
comma
id|ctx-&gt;out
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
op_le
l_int|0
)paren
(brace
id|error
c_func
(paren
l_string|&quot;unknown option `%s&squot;&quot;
comma
id|ctx-&gt;argv
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|usage_with_options
c_func
(paren
id|usagestr
comma
id|options
)paren
suffix:semicolon
)brace
id|ctx-&gt;argv
op_add_assign
id|n
suffix:semicolon
id|ctx-&gt;argc
op_sub_assign
id|n
suffix:semicolon
)brace
DECL|function|for_each_bad_bisect_ref
r_static
r_int
id|for_each_bad_bisect_ref
c_func
(paren
r_const
r_char
op_star
id|submodule
comma
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|for_each_ref_in_submodule
c_func
(paren
id|submodule
comma
l_string|&quot;refs/bisect/bad&quot;
comma
id|fn
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|for_each_good_bisect_ref
r_static
r_int
id|for_each_good_bisect_ref
c_func
(paren
r_const
r_char
op_star
id|submodule
comma
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|for_each_ref_in_submodule
c_func
(paren
id|submodule
comma
l_string|&quot;refs/bisect/good&quot;
comma
id|fn
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|handle_revision_pseudo_opt
r_static
r_int
id|handle_revision_pseudo_opt
c_func
(paren
r_const
r_char
op_star
id|submodule
comma
r_struct
id|rev_info
op_star
id|revs
comma
r_int
id|argc
comma
r_const
r_char
op_star
op_star
id|argv
comma
r_int
op_star
id|flags
)paren
(brace
r_const
r_char
op_star
id|arg
op_assign
id|argv
(braket
l_int|0
)braket
suffix:semicolon
r_const
r_char
op_star
id|optarg
suffix:semicolon
r_int
id|argcount
suffix:semicolon
multiline_comment|/*&n;&t; * NOTE!&n;&t; *&n;&t; * Commands like &quot;git shortlog&quot; will not accept the options below&n;&t; * unless parse_revision_opt queues them (as opposed to erroring&n;&t; * out).&n;&t; *&n;&t; * When implementing your new pseudo-option, remember to&n;&t; * register it in the list at the top of handle_revision_opt.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--all&quot;
)paren
)paren
(brace
id|handle_refs
c_func
(paren
id|submodule
comma
id|revs
comma
op_star
id|flags
comma
id|for_each_ref_submodule
)paren
suffix:semicolon
id|handle_refs
c_func
(paren
id|submodule
comma
id|revs
comma
op_star
id|flags
comma
id|head_ref_submodule
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--branches&quot;
)paren
)paren
(brace
id|handle_refs
c_func
(paren
id|submodule
comma
id|revs
comma
op_star
id|flags
comma
id|for_each_branch_ref_submodule
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--bisect&quot;
)paren
)paren
(brace
id|handle_refs
c_func
(paren
id|submodule
comma
id|revs
comma
op_star
id|flags
comma
id|for_each_bad_bisect_ref
)paren
suffix:semicolon
id|handle_refs
c_func
(paren
id|submodule
comma
id|revs
comma
op_star
id|flags
op_xor
id|UNINTERESTING
comma
id|for_each_good_bisect_ref
)paren
suffix:semicolon
id|revs-&gt;bisect
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--tags&quot;
)paren
)paren
(brace
id|handle_refs
c_func
(paren
id|submodule
comma
id|revs
comma
op_star
id|flags
comma
id|for_each_tag_ref_submodule
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--remotes&quot;
)paren
)paren
(brace
id|handle_refs
c_func
(paren
id|submodule
comma
id|revs
comma
op_star
id|flags
comma
id|for_each_remote_ref_submodule
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|argcount
op_assign
id|parse_long_opt
c_func
(paren
l_string|&quot;glob&quot;
comma
id|argv
comma
op_amp
id|optarg
)paren
)paren
)paren
(brace
r_struct
id|all_refs_cb
id|cb
suffix:semicolon
id|init_all_refs_cb
c_func
(paren
op_amp
id|cb
comma
id|revs
comma
op_star
id|flags
)paren
suffix:semicolon
id|for_each_glob_ref
c_func
(paren
id|handle_one_ref
comma
id|optarg
comma
op_amp
id|cb
)paren
suffix:semicolon
r_return
id|argcount
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;--branches=&quot;
)paren
)paren
(brace
r_struct
id|all_refs_cb
id|cb
suffix:semicolon
id|init_all_refs_cb
c_func
(paren
op_amp
id|cb
comma
id|revs
comma
op_star
id|flags
)paren
suffix:semicolon
id|for_each_glob_ref_in
c_func
(paren
id|handle_one_ref
comma
id|arg
op_plus
l_int|11
comma
l_string|&quot;refs/heads/&quot;
comma
op_amp
id|cb
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;--tags=&quot;
)paren
)paren
(brace
r_struct
id|all_refs_cb
id|cb
suffix:semicolon
id|init_all_refs_cb
c_func
(paren
op_amp
id|cb
comma
id|revs
comma
op_star
id|flags
)paren
suffix:semicolon
id|for_each_glob_ref_in
c_func
(paren
id|handle_one_ref
comma
id|arg
op_plus
l_int|7
comma
l_string|&quot;refs/tags/&quot;
comma
op_amp
id|cb
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;--remotes=&quot;
)paren
)paren
(brace
r_struct
id|all_refs_cb
id|cb
suffix:semicolon
id|init_all_refs_cb
c_func
(paren
op_amp
id|cb
comma
id|revs
comma
op_star
id|flags
)paren
suffix:semicolon
id|for_each_glob_ref_in
c_func
(paren
id|handle_one_ref
comma
id|arg
op_plus
l_int|10
comma
l_string|&quot;refs/remotes/&quot;
comma
op_amp
id|cb
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--reflog&quot;
)paren
)paren
(brace
id|handle_reflog
c_func
(paren
id|revs
comma
op_star
id|flags
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--not&quot;
)paren
)paren
(brace
op_star
id|flags
op_xor_assign
id|UNINTERESTING
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--no-walk&quot;
)paren
)paren
(brace
id|revs-&gt;no_walk
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--do-walk&quot;
)paren
)paren
(brace
id|revs-&gt;no_walk
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Parse revision information, filling in the &quot;rev_info&quot; structure,&n; * and removing the used arguments from the argument list.&n; *&n; * Returns the number of arguments left that weren&squot;t recognized&n; * (which are also moved to the head of the argument list)&n; */
DECL|function|setup_revisions
r_int
id|setup_revisions
c_func
(paren
r_int
id|argc
comma
r_const
r_char
op_star
op_star
id|argv
comma
r_struct
id|rev_info
op_star
id|revs
comma
r_struct
id|setup_revision_opt
op_star
id|opt
)paren
(brace
r_int
id|i
comma
id|flags
comma
id|left
comma
id|seen_dashdash
comma
id|read_from_stdin
comma
id|got_rev_arg
op_assign
l_int|0
suffix:semicolon
r_struct
id|cmdline_pathspec
id|prune_data
suffix:semicolon
r_const
r_char
op_star
id|submodule
op_assign
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|prune_data
comma
l_int|0
comma
r_sizeof
(paren
id|prune_data
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opt
)paren
id|submodule
op_assign
id|opt-&gt;submodule
suffix:semicolon
multiline_comment|/* First, search for &quot;--&quot; */
id|seen_dashdash
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|argc
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_char
op_star
id|arg
op_assign
id|argv
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--&quot;
)paren
)paren
r_continue
suffix:semicolon
id|argv
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|argc
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|argv
(braket
id|i
op_plus
l_int|1
)braket
)paren
id|append_prune_data
c_func
(paren
op_amp
id|prune_data
comma
id|argv
op_plus
id|i
op_plus
l_int|1
)paren
suffix:semicolon
id|seen_dashdash
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Second, deal with arguments and options */
id|flags
op_assign
l_int|0
suffix:semicolon
id|read_from_stdin
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|left
op_assign
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|argc
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_char
op_star
id|arg
op_assign
id|argv
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_star
id|arg
op_eq
l_char|&squot;-&squot;
)paren
(brace
r_int
id|opts
suffix:semicolon
id|opts
op_assign
id|handle_revision_pseudo_opt
c_func
(paren
id|submodule
comma
id|revs
comma
id|argc
id|i
comma
id|argv
op_plus
id|i
comma
op_amp
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opts
OG
l_int|0
)paren
(brace
id|i
op_add_assign
id|opts
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--stdin&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|revs-&gt;disable_stdin
)paren
(brace
id|argv
(braket
id|left
op_increment
)braket
op_assign
id|arg
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|read_from_stdin
op_increment
)paren
id|die
c_func
(paren
l_string|&quot;--stdin given twice?&quot;
)paren
suffix:semicolon
id|read_revisions_from_stdin
c_func
(paren
id|revs
comma
op_amp
id|prune_data
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|opts
op_assign
id|handle_revision_opt
c_func
(paren
id|revs
comma
id|argc
id|i
comma
id|argv
op_plus
id|i
comma
op_amp
id|left
comma
id|argv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opts
OG
l_int|0
)paren
(brace
id|i
op_add_assign
id|opts
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|opts
OL
l_int|0
)paren
m_exit
(paren
l_int|128
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|handle_revision_arg
c_func
(paren
id|arg
comma
id|revs
comma
id|flags
comma
id|seen_dashdash
)paren
)paren
(brace
r_int
id|j
suffix:semicolon
r_if
c_cond
(paren
id|seen_dashdash
op_logical_or
op_star
id|arg
op_eq
l_char|&squot;^&squot;
)paren
id|die
c_func
(paren
l_string|&quot;bad revision &squot;%s&squot;&quot;
comma
id|arg
)paren
suffix:semicolon
multiline_comment|/* If we didn&squot;t have a &quot;--&quot;:&n;&t;&t;&t; * (1) all filenames must exist;&n;&t;&t;&t; * (2) all rev-args must not be interpretable&n;&t;&t;&t; *     as a valid filename.&n;&t;&t;&t; * but the latter we have checked in the main loop.&n;&t;&t;&t; */
r_for
c_loop
(paren
id|j
op_assign
id|i
suffix:semicolon
id|j
OL
id|argc
suffix:semicolon
id|j
op_increment
)paren
id|verify_filename
c_func
(paren
id|revs-&gt;prefix
comma
id|argv
(braket
id|j
)braket
)paren
suffix:semicolon
id|append_prune_data
c_func
(paren
op_amp
id|prune_data
comma
id|argv
op_plus
id|i
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
id|got_rev_arg
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|prune_data.nr
)paren
(brace
multiline_comment|/*&n;&t;&t; * If we need to introduce the magic &quot;a lone &squot;:&squot; means no&n;&t;&t; * pathspec whatsoever&quot;, here is the place to do so.&n;&t;&t; *&n;&t;&t; * if (prune_data.nr == 1 &amp;&amp; !strcmp(prune_data[0], &quot;:&quot;)) {&n;&t;&t; *&t;prune_data.nr = 0;&n;&t;&t; *&t;prune_data.alloc = 0;&n;&t;&t; *&t;free(prune_data.path);&n;&t;&t; *&t;prune_data.path = NULL;&n;&t;&t; * } else {&n;&t;&t; *&t;terminate prune_data.alloc with NULL and&n;&t;&t; *&t;call init_pathspec() to set revs-&gt;prune_data here.&n;&t;&t; * }&n;&t;&t; */
id|ALLOC_GROW
c_func
(paren
id|prune_data.path
comma
id|prune_data.nr
op_plus
l_int|1
comma
id|prune_data.alloc
)paren
suffix:semicolon
id|prune_data.path
(braket
id|prune_data.nr
op_increment
)braket
op_assign
l_int|NULL
suffix:semicolon
id|init_pathspec
c_func
(paren
op_amp
id|revs-&gt;prune_data
comma
id|get_pathspec
c_func
(paren
id|revs-&gt;prefix
comma
id|prune_data.path
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|revs-&gt;def
op_eq
l_int|NULL
)paren
id|revs-&gt;def
op_assign
id|opt
ques
c_cond
id|opt-&gt;def
suffix:colon
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|opt
op_logical_and
id|opt-&gt;tweak
)paren
id|opt
op_member_access_from_pointer
id|tweak
c_func
(paren
id|revs
comma
id|opt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;show_merge
)paren
id|prepare_show_merge
c_func
(paren
id|revs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;def
op_logical_and
op_logical_neg
id|revs-&gt;pending.nr
op_logical_and
op_logical_neg
id|got_rev_arg
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_struct
id|object
op_star
id|object
suffix:semicolon
r_int
id|mode
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1_with_mode
c_func
(paren
id|revs-&gt;def
comma
id|sha1
comma
op_amp
id|mode
)paren
)paren
id|die
c_func
(paren
l_string|&quot;bad default revision &squot;%s&squot;&quot;
comma
id|revs-&gt;def
)paren
suffix:semicolon
id|object
op_assign
id|get_reference
c_func
(paren
id|revs
comma
id|revs-&gt;def
comma
id|sha1
comma
l_int|0
)paren
suffix:semicolon
id|add_pending_object_with_mode
c_func
(paren
id|revs
comma
id|object
comma
id|revs-&gt;def
comma
id|mode
)paren
suffix:semicolon
)brace
multiline_comment|/* Did the user ask for any diff output? Run the diff! */
r_if
c_cond
(paren
id|revs-&gt;diffopt.output_format
op_amp
op_complement
id|DIFF_FORMAT_NO_OUTPUT
)paren
id|revs-&gt;diff
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Pickaxe, diff-filter and rename following need diffs */
r_if
c_cond
(paren
id|revs-&gt;diffopt.pickaxe
op_logical_or
id|revs-&gt;diffopt.filter
op_logical_or
id|DIFF_OPT_TST
c_func
(paren
op_amp
id|revs-&gt;diffopt
comma
id|FOLLOW_RENAMES
)paren
)paren
id|revs-&gt;diff
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;topo_order
)paren
id|revs-&gt;limited
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;prune_data.nr
)paren
(brace
id|diff_tree_setup_paths
c_func
(paren
id|revs-&gt;prune_data.raw
comma
op_amp
id|revs-&gt;pruning
)paren
suffix:semicolon
multiline_comment|/* Can&squot;t prune commits with rename following: the paths change.. */
r_if
c_cond
(paren
op_logical_neg
id|DIFF_OPT_TST
c_func
(paren
op_amp
id|revs-&gt;diffopt
comma
id|FOLLOW_RENAMES
)paren
)paren
id|revs-&gt;prune
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|revs-&gt;full_diff
)paren
id|diff_tree_setup_paths
c_func
(paren
id|revs-&gt;prune_data.raw
comma
op_amp
id|revs-&gt;diffopt
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|revs-&gt;combine_merges
)paren
id|revs-&gt;ignore_merges
op_assign
l_int|0
suffix:semicolon
id|revs-&gt;diffopt.abbrev
op_assign
id|revs-&gt;abbrev
suffix:semicolon
r_if
c_cond
(paren
id|diff_setup_done
c_func
(paren
op_amp
id|revs-&gt;diffopt
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;diff_setup_done failed&quot;
)paren
suffix:semicolon
id|compile_grep_patterns
c_func
(paren
op_amp
id|revs-&gt;grep_filter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;reverse
op_logical_and
id|revs-&gt;reflog_info
)paren
id|die
c_func
(paren
l_string|&quot;cannot combine --reverse with --walk-reflogs&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;rewrite_parents
op_logical_and
id|revs-&gt;children.name
)paren
id|die
c_func
(paren
l_string|&quot;cannot combine --parents and --children&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Limitations on the graph functionality&n;&t; */
r_if
c_cond
(paren
id|revs-&gt;reverse
op_logical_and
id|revs-&gt;graph
)paren
id|die
c_func
(paren
l_string|&quot;cannot combine --reverse with --graph&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;reflog_info
op_logical_and
id|revs-&gt;graph
)paren
id|die
c_func
(paren
l_string|&quot;cannot combine --walk-reflogs with --graph&quot;
)paren
suffix:semicolon
r_return
id|left
suffix:semicolon
)brace
DECL|function|add_child
r_static
r_void
id|add_child
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_struct
id|commit
op_star
id|parent
comma
r_struct
id|commit
op_star
id|child
)paren
(brace
r_struct
id|commit_list
op_star
id|l
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|l
)paren
)paren
suffix:semicolon
id|l-&gt;item
op_assign
id|child
suffix:semicolon
id|l-&gt;next
op_assign
id|add_decoration
c_func
(paren
op_amp
id|revs-&gt;children
comma
op_amp
id|parent-&gt;object
comma
id|l
)paren
suffix:semicolon
)brace
DECL|function|remove_duplicate_parents
r_static
r_int
id|remove_duplicate_parents
c_func
(paren
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_struct
id|commit_list
op_star
op_star
id|pp
comma
op_star
id|p
suffix:semicolon
r_int
id|surviving_parents
suffix:semicolon
multiline_comment|/* Examine existing parents while marking ones we have seen... */
id|pp
op_assign
op_amp
id|commit-&gt;parents
suffix:semicolon
r_while
c_loop
(paren
(paren
id|p
op_assign
op_star
id|pp
)paren
op_ne
l_int|NULL
)paren
(brace
r_struct
id|commit
op_star
id|parent
op_assign
id|p-&gt;item
suffix:semicolon
r_if
c_cond
(paren
id|parent-&gt;object.flags
op_amp
id|TMP_MARK
)paren
(brace
op_star
id|pp
op_assign
id|p-&gt;next
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|parent-&gt;object.flags
op_or_assign
id|TMP_MARK
suffix:semicolon
id|pp
op_assign
op_amp
id|p-&gt;next
suffix:semicolon
)brace
multiline_comment|/* count them while clearing the temporary mark */
id|surviving_parents
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|commit-&gt;parents
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
id|p-&gt;item-&gt;object.flags
op_and_assign
op_complement
id|TMP_MARK
suffix:semicolon
id|surviving_parents
op_increment
suffix:semicolon
)brace
r_return
id|surviving_parents
suffix:semicolon
)brace
DECL|struct|merge_simplify_state
r_struct
id|merge_simplify_state
(brace
DECL|member|simplified
r_struct
id|commit
op_star
id|simplified
suffix:semicolon
)brace
suffix:semicolon
DECL|function|locate_simplify_state
r_static
r_struct
id|merge_simplify_state
op_star
id|locate_simplify_state
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_struct
id|merge_simplify_state
op_star
id|st
suffix:semicolon
id|st
op_assign
id|lookup_decoration
c_func
(paren
op_amp
id|revs-&gt;merge_simplification
comma
op_amp
id|commit-&gt;object
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|st
)paren
(brace
id|st
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|st
)paren
)paren
suffix:semicolon
id|add_decoration
c_func
(paren
op_amp
id|revs-&gt;merge_simplification
comma
op_amp
id|commit-&gt;object
comma
id|st
)paren
suffix:semicolon
)brace
r_return
id|st
suffix:semicolon
)brace
DECL|function|simplify_one
r_static
r_struct
id|commit_list
op_star
op_star
id|simplify_one
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_struct
id|commit
op_star
id|commit
comma
r_struct
id|commit_list
op_star
op_star
id|tail
)paren
(brace
r_struct
id|commit_list
op_star
id|p
suffix:semicolon
r_struct
id|merge_simplify_state
op_star
id|st
comma
op_star
id|pst
suffix:semicolon
r_int
id|cnt
suffix:semicolon
id|st
op_assign
id|locate_simplify_state
c_func
(paren
id|revs
comma
id|commit
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Have we handled this one?&n;&t; */
r_if
c_cond
(paren
id|st-&gt;simplified
)paren
r_return
id|tail
suffix:semicolon
multiline_comment|/*&n;&t; * An UNINTERESTING commit simplifies to itself, so does a&n;&t; * root commit.  We do not rewrite parents of such commit&n;&t; * anyway.&n;&t; */
r_if
c_cond
(paren
(paren
id|commit-&gt;object.flags
op_amp
id|UNINTERESTING
)paren
op_logical_or
op_logical_neg
id|commit-&gt;parents
)paren
(brace
id|st-&gt;simplified
op_assign
id|commit
suffix:semicolon
r_return
id|tail
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Do we know what commit all of our parents should be rewritten to?&n;&t; * Otherwise we are not ready to rewrite this one yet.&n;&t; */
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
comma
id|p
op_assign
id|commit-&gt;parents
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
id|pst
op_assign
id|locate_simplify_state
c_func
(paren
id|revs
comma
id|p-&gt;item
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pst-&gt;simplified
)paren
(brace
id|tail
op_assign
op_amp
id|commit_list_insert
c_func
(paren
id|p-&gt;item
comma
id|tail
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
id|cnt
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|cnt
)paren
(brace
id|tail
op_assign
op_amp
id|commit_list_insert
c_func
(paren
id|commit
comma
id|tail
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
r_return
id|tail
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Rewrite our list of parents.&n;&t; */
r_for
c_loop
(paren
id|p
op_assign
id|commit-&gt;parents
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
id|pst
op_assign
id|locate_simplify_state
c_func
(paren
id|revs
comma
id|p-&gt;item
)paren
suffix:semicolon
id|p-&gt;item
op_assign
id|pst-&gt;simplified
suffix:semicolon
)brace
id|cnt
op_assign
id|remove_duplicate_parents
c_func
(paren
id|commit
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * It is possible that we are a merge and one side branch&n;&t; * does not have any commit that touches the given paths;&n;&t; * in such a case, the immediate parents will be rewritten&n;&t; * to different commits.&n;&t; *&n;&t; *      o----X&t;&t;X: the commit we are looking at;&n;&t; *     /    /&t;&t;o: a commit that touches the paths;&n;&t; * ---o----&squot;&n;&t; *&n;&t; * Further reduce the parents by removing redundant parents.&n;&t; */
r_if
c_cond
(paren
l_int|1
OL
id|cnt
)paren
(brace
r_struct
id|commit_list
op_star
id|h
op_assign
id|reduce_heads
c_func
(paren
id|commit-&gt;parents
)paren
suffix:semicolon
id|cnt
op_assign
id|commit_list_count
c_func
(paren
id|h
)paren
suffix:semicolon
id|free_commit_list
c_func
(paren
id|commit-&gt;parents
)paren
suffix:semicolon
id|commit-&gt;parents
op_assign
id|h
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * A commit simplifies to itself if it is a root, if it is&n;&t; * UNINTERESTING, if it touches the given paths, or if it is a&n;&t; * merge and its parents simplifies to more than one commits&n;&t; * (the first two cases are already handled at the beginning of&n;&t; * this function).&n;&t; *&n;&t; * Otherwise, it simplifies to what its sole parent simplifies to.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|cnt
op_logical_or
(paren
id|commit-&gt;object.flags
op_amp
id|UNINTERESTING
)paren
op_logical_or
op_logical_neg
(paren
id|commit-&gt;object.flags
op_amp
id|TREESAME
)paren
op_logical_or
(paren
l_int|1
OL
id|cnt
)paren
)paren
id|st-&gt;simplified
op_assign
id|commit
suffix:semicolon
r_else
(brace
id|pst
op_assign
id|locate_simplify_state
c_func
(paren
id|revs
comma
id|commit-&gt;parents-&gt;item
)paren
suffix:semicolon
id|st-&gt;simplified
op_assign
id|pst-&gt;simplified
suffix:semicolon
)brace
r_return
id|tail
suffix:semicolon
)brace
DECL|function|simplify_merges
r_static
r_void
id|simplify_merges
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
)paren
(brace
r_struct
id|commit_list
op_star
id|list
suffix:semicolon
r_struct
id|commit_list
op_star
id|yet_to_do
comma
op_star
op_star
id|tail
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|revs-&gt;topo_order
)paren
id|sort_in_topological_order
c_func
(paren
op_amp
id|revs-&gt;commits
comma
id|revs-&gt;lifo
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|revs-&gt;prune
)paren
r_return
suffix:semicolon
multiline_comment|/* feed the list reversed */
id|yet_to_do
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|list
op_assign
id|revs-&gt;commits
suffix:semicolon
id|list
suffix:semicolon
id|list
op_assign
id|list-&gt;next
)paren
id|commit_list_insert
c_func
(paren
id|list-&gt;item
comma
op_amp
id|yet_to_do
)paren
suffix:semicolon
r_while
c_loop
(paren
id|yet_to_do
)paren
(brace
id|list
op_assign
id|yet_to_do
suffix:semicolon
id|yet_to_do
op_assign
l_int|NULL
suffix:semicolon
id|tail
op_assign
op_amp
id|yet_to_do
suffix:semicolon
r_while
c_loop
(paren
id|list
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
id|list-&gt;item
suffix:semicolon
r_struct
id|commit_list
op_star
id|next
op_assign
id|list-&gt;next
suffix:semicolon
id|free
c_func
(paren
id|list
)paren
suffix:semicolon
id|list
op_assign
id|next
suffix:semicolon
id|tail
op_assign
id|simplify_one
c_func
(paren
id|revs
comma
id|commit
comma
id|tail
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* clean up the result, removing the simplified ones */
id|list
op_assign
id|revs-&gt;commits
suffix:semicolon
id|revs-&gt;commits
op_assign
l_int|NULL
suffix:semicolon
id|tail
op_assign
op_amp
id|revs-&gt;commits
suffix:semicolon
r_while
c_loop
(paren
id|list
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
id|list-&gt;item
suffix:semicolon
r_struct
id|commit_list
op_star
id|next
op_assign
id|list-&gt;next
suffix:semicolon
r_struct
id|merge_simplify_state
op_star
id|st
suffix:semicolon
id|free
c_func
(paren
id|list
)paren
suffix:semicolon
id|list
op_assign
id|next
suffix:semicolon
id|st
op_assign
id|locate_simplify_state
c_func
(paren
id|revs
comma
id|commit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st-&gt;simplified
op_eq
id|commit
)paren
id|tail
op_assign
op_amp
id|commit_list_insert
c_func
(paren
id|commit
comma
id|tail
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
)brace
)brace
DECL|function|set_children
r_static
r_void
id|set_children
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
)paren
(brace
r_struct
id|commit_list
op_star
id|l
suffix:semicolon
r_for
c_loop
(paren
id|l
op_assign
id|revs-&gt;commits
suffix:semicolon
id|l
suffix:semicolon
id|l
op_assign
id|l-&gt;next
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
id|l-&gt;item
suffix:semicolon
r_struct
id|commit_list
op_star
id|p
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|commit-&gt;parents
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
id|add_child
c_func
(paren
id|revs
comma
id|p-&gt;item
comma
id|commit
)paren
suffix:semicolon
)brace
)brace
DECL|function|prepare_revision_walk
r_int
id|prepare_revision_walk
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
)paren
(brace
r_int
id|nr
op_assign
id|revs-&gt;pending.nr
suffix:semicolon
r_struct
id|object_array_entry
op_star
id|e
comma
op_star
id|list
suffix:semicolon
id|e
op_assign
id|list
op_assign
id|revs-&gt;pending.objects
suffix:semicolon
id|revs-&gt;pending.nr
op_assign
l_int|0
suffix:semicolon
id|revs-&gt;pending.alloc
op_assign
l_int|0
suffix:semicolon
id|revs-&gt;pending.objects
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|nr
op_ge
l_int|0
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
id|handle_commit
c_func
(paren
id|revs
comma
id|e-&gt;item
comma
id|e-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|commit
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|commit-&gt;object.flags
op_amp
id|SEEN
)paren
)paren
(brace
id|commit-&gt;object.flags
op_or_assign
id|SEEN
suffix:semicolon
id|commit_list_insert_by_date
c_func
(paren
id|commit
comma
op_amp
id|revs-&gt;commits
)paren
suffix:semicolon
)brace
)brace
id|e
op_increment
suffix:semicolon
)brace
id|free
c_func
(paren
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;no_walk
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;limited
)paren
r_if
c_cond
(paren
id|limit_list
c_func
(paren
id|revs
)paren
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;topo_order
)paren
id|sort_in_topological_order
c_func
(paren
op_amp
id|revs-&gt;commits
comma
id|revs-&gt;lifo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;simplify_merges
)paren
id|simplify_merges
c_func
(paren
id|revs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;children.name
)paren
id|set_children
c_func
(paren
id|revs
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|enum|rewrite_result
r_enum
id|rewrite_result
(brace
DECL|enumerator|rewrite_one_ok
id|rewrite_one_ok
comma
DECL|enumerator|rewrite_one_noparents
id|rewrite_one_noparents
comma
DECL|enumerator|rewrite_one_error
id|rewrite_one_error
)brace
suffix:semicolon
DECL|function|rewrite_one
r_static
r_enum
id|rewrite_result
id|rewrite_one
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_struct
id|commit
op_star
op_star
id|pp
)paren
(brace
r_struct
id|commit_list
op_star
id|cache
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|commit
op_star
id|p
op_assign
op_star
id|pp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|revs-&gt;limited
)paren
r_if
c_cond
(paren
id|add_parents_to_list
c_func
(paren
id|revs
comma
id|p
comma
op_amp
id|revs-&gt;commits
comma
op_amp
id|cache
)paren
OL
l_int|0
)paren
r_return
id|rewrite_one_error
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;parents
op_logical_and
id|p-&gt;parents-&gt;next
)paren
r_return
id|rewrite_one_ok
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;object.flags
op_amp
id|UNINTERESTING
)paren
r_return
id|rewrite_one_ok
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;object.flags
op_amp
id|TREESAME
)paren
)paren
r_return
id|rewrite_one_ok
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;parents
)paren
r_return
id|rewrite_one_noparents
suffix:semicolon
op_star
id|pp
op_assign
id|p-&gt;parents-&gt;item
suffix:semicolon
)brace
)brace
DECL|function|rewrite_parents
r_static
r_int
id|rewrite_parents
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_struct
id|commit_list
op_star
op_star
id|pp
op_assign
op_amp
id|commit-&gt;parents
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pp
)paren
(brace
r_struct
id|commit_list
op_star
id|parent
op_assign
op_star
id|pp
suffix:semicolon
r_switch
c_cond
(paren
id|rewrite_one
c_func
(paren
id|revs
comma
op_amp
id|parent-&gt;item
)paren
)paren
(brace
r_case
id|rewrite_one_ok
suffix:colon
r_break
suffix:semicolon
r_case
id|rewrite_one_noparents
suffix:colon
op_star
id|pp
op_assign
id|parent-&gt;next
suffix:semicolon
r_continue
suffix:semicolon
r_case
id|rewrite_one_error
suffix:colon
r_return
l_int|1
suffix:semicolon
)brace
id|pp
op_assign
op_amp
id|parent-&gt;next
suffix:semicolon
)brace
id|remove_duplicate_parents
c_func
(paren
id|commit
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|commit_match
r_static
r_int
id|commit_match
c_func
(paren
r_struct
id|commit
op_star
id|commit
comma
r_struct
id|rev_info
op_star
id|opt
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|opt-&gt;grep_filter.pattern_list
op_logical_and
op_logical_neg
id|opt-&gt;grep_filter.header_list
)paren
r_return
l_int|1
suffix:semicolon
r_return
id|grep_buffer
c_func
(paren
op_amp
id|opt-&gt;grep_filter
comma
l_int|NULL
comma
multiline_comment|/* we say nothing, not even filename */
id|commit-&gt;buffer
comma
id|strlen
c_func
(paren
id|commit-&gt;buffer
)paren
)paren
suffix:semicolon
)brace
DECL|function|want_ancestry
r_static
r_inline
r_int
id|want_ancestry
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
)paren
(brace
r_return
(paren
id|revs-&gt;rewrite_parents
op_logical_or
id|revs-&gt;children.name
)paren
suffix:semicolon
)brace
DECL|function|get_commit_action
r_enum
id|commit_action
id|get_commit_action
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_if
c_cond
(paren
id|commit-&gt;object.flags
op_amp
id|SHOWN
)paren
r_return
id|commit_ignore
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;unpacked
op_logical_and
id|has_sha1_pack
c_func
(paren
id|commit-&gt;object.sha1
)paren
)paren
r_return
id|commit_ignore
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;show_all
)paren
r_return
id|commit_show
suffix:semicolon
r_if
c_cond
(paren
id|commit-&gt;object.flags
op_amp
id|UNINTERESTING
)paren
r_return
id|commit_ignore
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;min_age
op_ne
l_int|1
op_logical_and
(paren
id|commit-&gt;date
OG
id|revs-&gt;min_age
)paren
)paren
r_return
id|commit_ignore
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;min_parents
op_logical_or
(paren
id|revs-&gt;max_parents
op_ge
l_int|0
)paren
)paren
(brace
r_int
id|n
op_assign
l_int|0
suffix:semicolon
r_struct
id|commit_list
op_star
id|p
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|commit-&gt;parents
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
id|n
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|n
OL
id|revs-&gt;min_parents
)paren
op_logical_or
(paren
(paren
id|revs-&gt;max_parents
op_ge
l_int|0
)paren
op_logical_and
(paren
id|n
OG
id|revs-&gt;max_parents
)paren
)paren
)paren
r_return
id|commit_ignore
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|commit_match
c_func
(paren
id|commit
comma
id|revs
)paren
)paren
r_return
id|commit_ignore
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;prune
op_logical_and
id|revs-&gt;dense
)paren
(brace
multiline_comment|/* Commit without changes? */
r_if
c_cond
(paren
id|commit-&gt;object.flags
op_amp
id|TREESAME
)paren
(brace
multiline_comment|/* drop merges unless we want parenthood */
r_if
c_cond
(paren
op_logical_neg
id|want_ancestry
c_func
(paren
id|revs
)paren
)paren
r_return
id|commit_ignore
suffix:semicolon
multiline_comment|/* non-merge - always ignore it */
r_if
c_cond
(paren
op_logical_neg
id|commit-&gt;parents
op_logical_or
op_logical_neg
id|commit-&gt;parents-&gt;next
)paren
r_return
id|commit_ignore
suffix:semicolon
)brace
)brace
r_return
id|commit_show
suffix:semicolon
)brace
DECL|function|simplify_commit
r_enum
id|commit_action
id|simplify_commit
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_enum
id|commit_action
id|action
op_assign
id|get_commit_action
c_func
(paren
id|revs
comma
id|commit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|action
op_eq
id|commit_show
op_logical_and
op_logical_neg
id|revs-&gt;show_all
op_logical_and
id|revs-&gt;prune
op_logical_and
id|revs-&gt;dense
op_logical_and
id|want_ancestry
c_func
(paren
id|revs
)paren
)paren
(brace
r_if
c_cond
(paren
id|rewrite_parents
c_func
(paren
id|revs
comma
id|commit
)paren
OL
l_int|0
)paren
r_return
id|commit_error
suffix:semicolon
)brace
r_return
id|action
suffix:semicolon
)brace
DECL|function|get_revision_1
r_static
r_struct
id|commit
op_star
id|get_revision_1
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|revs-&gt;commits
)paren
r_return
l_int|NULL
suffix:semicolon
r_do
(brace
r_struct
id|commit_list
op_star
id|entry
op_assign
id|revs-&gt;commits
suffix:semicolon
r_struct
id|commit
op_star
id|commit
op_assign
id|entry-&gt;item
suffix:semicolon
id|revs-&gt;commits
op_assign
id|entry-&gt;next
suffix:semicolon
id|free
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;reflog_info
)paren
(brace
id|fake_reflog_parent
c_func
(paren
id|revs-&gt;reflog_info
comma
id|commit
)paren
suffix:semicolon
id|commit-&gt;object.flags
op_and_assign
op_complement
(paren
id|ADDED
op_or
id|SEEN
op_or
id|SHOWN
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If we haven&squot;t done the list limiting, we need to look at&n;&t;&t; * the parents here. We also need to do the date-based limiting&n;&t;&t; * that we&squot;d otherwise have done in limit_list().&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|revs-&gt;limited
)paren
(brace
r_if
c_cond
(paren
id|revs-&gt;max_age
op_ne
l_int|1
op_logical_and
(paren
id|commit-&gt;date
OL
id|revs-&gt;max_age
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|add_parents_to_list
c_func
(paren
id|revs
comma
id|commit
comma
op_amp
id|revs-&gt;commits
comma
l_int|NULL
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;Failed to traverse parents of commit %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|commit-&gt;object.sha1
)paren
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|simplify_commit
c_func
(paren
id|revs
comma
id|commit
)paren
)paren
(brace
r_case
id|commit_ignore
suffix:colon
r_continue
suffix:semicolon
r_case
id|commit_error
suffix:colon
id|die
c_func
(paren
l_string|&quot;Failed to simplify parents of commit %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|commit-&gt;object.sha1
)paren
)paren
suffix:semicolon
r_default
suffix:colon
r_return
id|commit
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|revs-&gt;commits
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|gc_boundary
r_static
r_void
id|gc_boundary
c_func
(paren
r_struct
id|object_array
op_star
id|array
)paren
(brace
r_int
id|nr
op_assign
id|array-&gt;nr
suffix:semicolon
r_int
id|alloc
op_assign
id|array-&gt;alloc
suffix:semicolon
r_struct
id|object_array_entry
op_star
id|objects
op_assign
id|array-&gt;objects
suffix:semicolon
r_if
c_cond
(paren
id|alloc
op_le
id|nr
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|j
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|objects
(braket
id|i
)braket
dot
id|item-&gt;flags
op_amp
id|SHOWN
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
id|j
)paren
id|objects
(braket
id|j
)braket
op_assign
id|objects
(braket
id|i
)braket
suffix:semicolon
id|j
op_increment
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
id|j
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
)paren
id|objects
(braket
id|i
)braket
dot
id|item
op_assign
l_int|NULL
suffix:semicolon
id|array-&gt;nr
op_assign
id|j
suffix:semicolon
)brace
)brace
DECL|function|create_boundary_commit_list
r_static
r_void
id|create_boundary_commit_list
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|commit
op_star
id|c
suffix:semicolon
r_struct
id|object_array
op_star
id|array
op_assign
op_amp
id|revs-&gt;boundary_commits
suffix:semicolon
r_struct
id|object_array_entry
op_star
id|objects
op_assign
id|array-&gt;objects
suffix:semicolon
multiline_comment|/*&n;&t; * If revs-&gt;commits is non-NULL at this point, an error occurred in&n;&t; * get_revision_1().  Ignore the error and continue printing the&n;&t; * boundary commits anyway.  (This is what the code has always&n;&t; * done.)&n;&t; */
r_if
c_cond
(paren
id|revs-&gt;commits
)paren
(brace
id|free_commit_list
c_func
(paren
id|revs-&gt;commits
)paren
suffix:semicolon
id|revs-&gt;commits
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Put all of the actual boundary commits from revs-&gt;boundary_commits&n;&t; * into revs-&gt;commits&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|array-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
id|c
op_assign
(paren
r_struct
id|commit
op_star
)paren
(paren
id|objects
(braket
id|i
)braket
dot
id|item
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|c-&gt;object.flags
op_amp
id|CHILD_SHOWN
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;object.flags
op_amp
(paren
id|SHOWN
op_or
id|BOUNDARY
)paren
)paren
r_continue
suffix:semicolon
id|c-&gt;object.flags
op_or_assign
id|BOUNDARY
suffix:semicolon
id|commit_list_insert
c_func
(paren
id|c
comma
op_amp
id|revs-&gt;commits
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If revs-&gt;topo_order is set, sort the boundary commits&n;&t; * in topological order&n;&t; */
id|sort_in_topological_order
c_func
(paren
op_amp
id|revs-&gt;commits
comma
id|revs-&gt;lifo
)paren
suffix:semicolon
)brace
DECL|function|get_revision_internal
r_static
r_struct
id|commit
op_star
id|get_revision_internal
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
)paren
(brace
r_struct
id|commit
op_star
id|c
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|commit_list
op_star
id|l
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;boundary
op_eq
l_int|2
)paren
(brace
multiline_comment|/*&n;&t;&t; * All of the normal commits have already been returned,&n;&t;&t; * and we are now returning boundary commits.&n;&t;&t; * create_boundary_commit_list() has populated&n;&t;&t; * revs-&gt;commits with the remaining commits to return.&n;&t;&t; */
id|c
op_assign
id|pop_commit
c_func
(paren
op_amp
id|revs-&gt;commits
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
)paren
id|c-&gt;object.flags
op_or_assign
id|SHOWN
suffix:semicolon
r_return
id|c
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now pick up what they want to give us&n;&t; */
id|c
op_assign
id|get_revision_1
c_func
(paren
id|revs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
)paren
(brace
r_while
c_loop
(paren
l_int|0
OL
id|revs-&gt;skip_count
)paren
(brace
id|revs-&gt;skip_count
op_decrement
suffix:semicolon
id|c
op_assign
id|get_revision_1
c_func
(paren
id|revs
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Check the max_count.&n;&t; */
r_switch
c_cond
(paren
id|revs-&gt;max_count
)paren
(brace
r_case
l_int|1
suffix:colon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
id|c
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|revs-&gt;max_count
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
)paren
id|c-&gt;object.flags
op_or_assign
id|SHOWN
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|revs-&gt;boundary
)paren
(brace
r_return
id|c
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
(brace
multiline_comment|/*&n;&t;&t; * get_revision_1() runs out the commits, and&n;&t;&t; * we are done computing the boundaries.&n;&t;&t; * switch to boundary commits output mode.&n;&t;&t; */
id|revs-&gt;boundary
op_assign
l_int|2
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Update revs-&gt;commits to contain the list of&n;&t;&t; * boundary commits.&n;&t;&t; */
id|create_boundary_commit_list
c_func
(paren
id|revs
)paren
suffix:semicolon
r_return
id|get_revision_internal
c_func
(paren
id|revs
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * boundary commits are the commits that are parents of the&n;&t; * ones we got from get_revision_1() but they themselves are&n;&t; * not returned from get_revision_1().  Before returning&n;&t; * &squot;c&squot;, we need to mark its parents that they could be boundaries.&n;&t; */
r_for
c_loop
(paren
id|l
op_assign
id|c-&gt;parents
suffix:semicolon
id|l
suffix:semicolon
id|l
op_assign
id|l-&gt;next
)paren
(brace
r_struct
id|object
op_star
id|p
suffix:semicolon
id|p
op_assign
op_amp
(paren
id|l-&gt;item-&gt;object
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;flags
op_amp
(paren
id|CHILD_SHOWN
op_or
id|SHOWN
)paren
)paren
r_continue
suffix:semicolon
id|p-&gt;flags
op_or_assign
id|CHILD_SHOWN
suffix:semicolon
id|gc_boundary
c_func
(paren
op_amp
id|revs-&gt;boundary_commits
)paren
suffix:semicolon
id|add_object_array
c_func
(paren
id|p
comma
l_int|NULL
comma
op_amp
id|revs-&gt;boundary_commits
)paren
suffix:semicolon
)brace
r_return
id|c
suffix:semicolon
)brace
DECL|function|get_revision
r_struct
id|commit
op_star
id|get_revision
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
)paren
(brace
r_struct
id|commit
op_star
id|c
suffix:semicolon
r_struct
id|commit_list
op_star
id|reversed
suffix:semicolon
r_if
c_cond
(paren
id|revs-&gt;reverse
)paren
(brace
id|reversed
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
id|get_revision_internal
c_func
(paren
id|revs
)paren
)paren
)paren
(brace
id|commit_list_insert
c_func
(paren
id|c
comma
op_amp
id|reversed
)paren
suffix:semicolon
)brace
id|revs-&gt;commits
op_assign
id|reversed
suffix:semicolon
id|revs-&gt;reverse
op_assign
l_int|0
suffix:semicolon
id|revs-&gt;reverse_output_stage
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|revs-&gt;reverse_output_stage
)paren
r_return
id|pop_commit
c_func
(paren
op_amp
id|revs-&gt;commits
)paren
suffix:semicolon
id|c
op_assign
id|get_revision_internal
c_func
(paren
id|revs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_logical_and
id|revs-&gt;graph
)paren
id|graph_update
c_func
(paren
id|revs-&gt;graph
comma
id|c
)paren
suffix:semicolon
r_return
id|c
suffix:semicolon
)brace
DECL|function|get_revision_mark
r_char
op_star
id|get_revision_mark
c_func
(paren
r_const
r_struct
id|rev_info
op_star
id|revs
comma
r_const
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_if
c_cond
(paren
id|commit-&gt;object.flags
op_amp
id|BOUNDARY
)paren
r_return
l_string|&quot;-&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|commit-&gt;object.flags
op_amp
id|UNINTERESTING
)paren
r_return
l_string|&quot;^&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|commit-&gt;object.flags
op_amp
id|PATCHSAME
)paren
r_return
l_string|&quot;=&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|revs
op_logical_or
id|revs-&gt;left_right
)paren
(brace
r_if
c_cond
(paren
id|commit-&gt;object.flags
op_amp
id|SYMMETRIC_LEFT
)paren
r_return
l_string|&quot;&lt;&quot;
suffix:semicolon
r_else
r_return
l_string|&quot;&gt;&quot;
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|revs-&gt;graph
)paren
r_return
l_string|&quot;*&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|revs-&gt;cherry_mark
)paren
r_return
l_string|&quot;+&quot;
suffix:semicolon
r_return
l_string|&quot;&quot;
suffix:semicolon
)brace
DECL|function|put_revision_mark
r_void
id|put_revision_mark
c_func
(paren
r_const
r_struct
id|rev_info
op_star
id|revs
comma
r_const
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_char
op_star
id|mark
op_assign
id|get_revision_mark
c_func
(paren
id|revs
comma
id|commit
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strlen
c_func
(paren
id|mark
)paren
)paren
r_return
suffix:semicolon
id|fputs
c_func
(paren
id|mark
comma
id|stdout
)paren
suffix:semicolon
id|putchar
c_func
(paren
l_char|&squot; &squot;
)paren
suffix:semicolon
)brace
eof
