macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;tag.h&quot;
macro_line|#include &quot;commit.h&quot;
macro_line|#include &quot;pkt-line.h&quot;
macro_line|#include &quot;utf8.h&quot;
macro_line|#include &quot;diff.h&quot;
macro_line|#include &quot;revision.h&quot;
macro_line|#include &quot;notes.h&quot;
DECL|variable|save_commit_buffer
r_int
id|save_commit_buffer
op_assign
l_int|1
suffix:semicolon
DECL|variable|commit_type
r_const
r_char
op_star
id|commit_type
op_assign
l_string|&quot;commit&quot;
suffix:semicolon
DECL|function|check_commit
r_static
r_struct
id|commit
op_star
id|check_commit
c_func
(paren
r_struct
id|object
op_star
id|obj
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
id|quiet
)paren
(brace
r_if
c_cond
(paren
id|obj-&gt;type
op_ne
id|OBJ_COMMIT
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|quiet
)paren
id|error
c_func
(paren
l_string|&quot;Object %s is a %s, not a commit&quot;
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
comma
r_typename
(paren
id|obj-&gt;type
)paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
(paren
r_struct
id|commit
op_star
)paren
id|obj
suffix:semicolon
)brace
DECL|function|lookup_commit_reference_gently
r_struct
id|commit
op_star
id|lookup_commit_reference_gently
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
id|quiet
)paren
(brace
r_struct
id|object
op_star
id|obj
op_assign
id|deref_tag
c_func
(paren
id|parse_object
c_func
(paren
id|sha1
)paren
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|obj
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|check_commit
c_func
(paren
id|obj
comma
id|sha1
comma
id|quiet
)paren
suffix:semicolon
)brace
DECL|function|lookup_commit_reference
r_struct
id|commit
op_star
id|lookup_commit_reference
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_return
id|lookup_commit_reference_gently
c_func
(paren
id|sha1
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|lookup_commit
r_struct
id|commit
op_star
id|lookup_commit
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_struct
id|object
op_star
id|obj
op_assign
id|lookup_object
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|obj
)paren
r_return
id|create_object
c_func
(paren
id|sha1
comma
id|OBJ_COMMIT
comma
id|alloc_commit_node
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|obj-&gt;type
)paren
id|obj-&gt;type
op_assign
id|OBJ_COMMIT
suffix:semicolon
r_return
id|check_commit
c_func
(paren
id|obj
comma
id|sha1
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|lookup_commit_reference_by_name
r_struct
id|commit
op_star
id|lookup_commit_reference_by_name
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_struct
id|commit
op_star
id|commit
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1
c_func
(paren
id|name
comma
id|sha1
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|commit
op_assign
id|lookup_commit_reference
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|commit
op_logical_or
id|parse_commit
c_func
(paren
id|commit
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|commit
suffix:semicolon
)brace
DECL|function|parse_commit_date
r_static
r_int
r_int
id|parse_commit_date
c_func
(paren
r_const
r_char
op_star
id|buf
comma
r_const
r_char
op_star
id|tail
)paren
(brace
r_const
r_char
op_star
id|dateptr
suffix:semicolon
r_if
c_cond
(paren
id|buf
op_plus
l_int|6
op_ge
id|tail
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|buf
comma
l_string|&quot;author&quot;
comma
l_int|6
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|buf
OL
id|tail
op_logical_and
op_star
id|buf
op_increment
op_ne
l_char|&squot;&bslash;n&squot;
)paren
multiline_comment|/* nada */
suffix:semicolon
r_if
c_cond
(paren
id|buf
op_plus
l_int|9
op_ge
id|tail
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|buf
comma
l_string|&quot;committer&quot;
comma
l_int|9
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|buf
OL
id|tail
op_logical_and
op_star
id|buf
op_increment
op_ne
l_char|&squot;&gt;&squot;
)paren
multiline_comment|/* nada */
suffix:semicolon
r_if
c_cond
(paren
id|buf
op_ge
id|tail
)paren
r_return
l_int|0
suffix:semicolon
id|dateptr
op_assign
id|buf
suffix:semicolon
r_while
c_loop
(paren
id|buf
OL
id|tail
op_logical_and
op_star
id|buf
op_increment
op_ne
l_char|&squot;&bslash;n&squot;
)paren
multiline_comment|/* nada */
suffix:semicolon
r_if
c_cond
(paren
id|buf
op_ge
id|tail
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* dateptr &lt; buf &amp;&amp; buf[-1] == &squot;&bslash;n&squot;, so strtoul will stop at buf-1 */
r_return
id|strtoul
c_func
(paren
id|dateptr
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
)brace
DECL|variable|commit_graft
r_static
r_struct
id|commit_graft
op_star
op_star
id|commit_graft
suffix:semicolon
DECL|variable|commit_graft_alloc
DECL|variable|commit_graft_nr
r_static
r_int
id|commit_graft_alloc
comma
id|commit_graft_nr
suffix:semicolon
DECL|function|commit_graft_pos
r_static
r_int
id|commit_graft_pos
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_int
id|lo
comma
id|hi
suffix:semicolon
id|lo
op_assign
l_int|0
suffix:semicolon
id|hi
op_assign
id|commit_graft_nr
suffix:semicolon
r_while
c_loop
(paren
id|lo
OL
id|hi
)paren
(brace
r_int
id|mi
op_assign
(paren
id|lo
op_plus
id|hi
)paren
op_div
l_int|2
suffix:semicolon
r_struct
id|commit_graft
op_star
id|graft
op_assign
id|commit_graft
(braket
id|mi
)braket
suffix:semicolon
r_int
id|cmp
op_assign
id|hashcmp
c_func
(paren
id|sha1
comma
id|graft-&gt;sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmp
)paren
r_return
id|mi
suffix:semicolon
r_if
c_cond
(paren
id|cmp
OL
l_int|0
)paren
id|hi
op_assign
id|mi
suffix:semicolon
r_else
id|lo
op_assign
id|mi
op_plus
l_int|1
suffix:semicolon
)brace
r_return
id|lo
l_int|1
suffix:semicolon
)brace
DECL|function|register_commit_graft
r_int
id|register_commit_graft
c_func
(paren
r_struct
id|commit_graft
op_star
id|graft
comma
r_int
id|ignore_dups
)paren
(brace
r_int
id|pos
op_assign
id|commit_graft_pos
c_func
(paren
id|graft-&gt;sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_le
id|pos
)paren
(brace
r_if
c_cond
(paren
id|ignore_dups
)paren
id|free
c_func
(paren
id|graft
)paren
suffix:semicolon
r_else
(brace
id|free
c_func
(paren
id|commit_graft
(braket
id|pos
)braket
)paren
suffix:semicolon
id|commit_graft
(braket
id|pos
)braket
op_assign
id|graft
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
id|pos
op_assign
id|pos
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|commit_graft_alloc
op_le
op_increment
id|commit_graft_nr
)paren
(brace
id|commit_graft_alloc
op_assign
id|alloc_nr
c_func
(paren
id|commit_graft_alloc
)paren
suffix:semicolon
id|commit_graft
op_assign
id|xrealloc
c_func
(paren
id|commit_graft
comma
r_sizeof
(paren
op_star
id|commit_graft
)paren
op_star
id|commit_graft_alloc
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pos
OL
id|commit_graft_nr
)paren
id|memmove
c_func
(paren
id|commit_graft
op_plus
id|pos
op_plus
l_int|1
comma
id|commit_graft
op_plus
id|pos
comma
(paren
id|commit_graft_nr
id|pos
l_int|1
)paren
op_star
r_sizeof
(paren
op_star
id|commit_graft
)paren
)paren
suffix:semicolon
id|commit_graft
(braket
id|pos
)braket
op_assign
id|graft
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|read_graft_line
r_struct
id|commit_graft
op_star
id|read_graft_line
c_func
(paren
r_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
multiline_comment|/* The format is just &quot;Commit Parent1 Parent2 ...&bslash;n&quot; */
r_int
id|i
suffix:semicolon
r_struct
id|commit_graft
op_star
id|graft
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|len
op_logical_and
id|isspace
c_func
(paren
id|buf
(braket
id|len
op_minus
l_int|1
)braket
)paren
)paren
id|buf
(braket
op_decrement
id|len
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|buf
(braket
l_int|0
)braket
op_eq
l_char|&squot;#&squot;
op_logical_or
id|buf
(braket
l_int|0
)braket
op_eq
l_char|&squot;&bslash;0&squot;
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_plus
l_int|1
)paren
op_mod
l_int|41
)paren
r_goto
id|bad_graft_data
suffix:semicolon
id|i
op_assign
(paren
id|len
op_plus
l_int|1
)paren
op_div
l_int|41
l_int|1
suffix:semicolon
id|graft
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|graft
)paren
op_plus
l_int|20
op_star
id|i
)paren
suffix:semicolon
id|graft-&gt;nr_parent
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|buf
comma
id|graft-&gt;sha1
)paren
)paren
r_goto
id|bad_graft_data
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|40
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_add_assign
l_int|41
)paren
(brace
r_if
c_cond
(paren
id|buf
(braket
id|i
)braket
op_ne
l_char|&squot; &squot;
)paren
r_goto
id|bad_graft_data
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|buf
op_plus
id|i
op_plus
l_int|1
comma
id|graft-&gt;parent
(braket
id|i
op_div
l_int|41
)braket
)paren
)paren
r_goto
id|bad_graft_data
suffix:semicolon
)brace
r_return
id|graft
suffix:semicolon
id|bad_graft_data
suffix:colon
id|error
c_func
(paren
l_string|&quot;bad graft data: %s&quot;
comma
id|buf
)paren
suffix:semicolon
id|free
c_func
(paren
id|graft
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|read_graft_file
r_static
r_int
id|read_graft_file
c_func
(paren
r_const
r_char
op_star
id|graft_file
)paren
(brace
id|FILE
op_star
id|fp
op_assign
id|fopen
c_func
(paren
id|graft_file
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_char
id|buf
(braket
l_int|1024
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fp
)paren
r_return
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|fgets
c_func
(paren
id|buf
comma
r_sizeof
(paren
id|buf
)paren
comma
id|fp
)paren
)paren
(brace
multiline_comment|/* The format is just &quot;Commit Parent1 Parent2 ...&bslash;n&quot; */
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|buf
)paren
suffix:semicolon
r_struct
id|commit_graft
op_star
id|graft
op_assign
id|read_graft_line
c_func
(paren
id|buf
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|graft
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|register_commit_graft
c_func
(paren
id|graft
comma
l_int|1
)paren
)paren
id|error
c_func
(paren
l_string|&quot;duplicate graft data: %s&quot;
comma
id|buf
)paren
suffix:semicolon
)brace
id|fclose
c_func
(paren
id|fp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|prepare_commit_graft
r_static
r_void
id|prepare_commit_graft
c_func
(paren
r_void
)paren
(brace
r_static
r_int
id|commit_graft_prepared
suffix:semicolon
r_char
op_star
id|graft_file
suffix:semicolon
r_if
c_cond
(paren
id|commit_graft_prepared
)paren
r_return
suffix:semicolon
id|graft_file
op_assign
id|get_graft_file
c_func
(paren
)paren
suffix:semicolon
id|read_graft_file
c_func
(paren
id|graft_file
)paren
suffix:semicolon
multiline_comment|/* make sure shallows are read */
id|is_repository_shallow
c_func
(paren
)paren
suffix:semicolon
id|commit_graft_prepared
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|lookup_commit_graft
r_struct
id|commit_graft
op_star
id|lookup_commit_graft
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_int
id|pos
suffix:semicolon
id|prepare_commit_graft
c_func
(paren
)paren
suffix:semicolon
id|pos
op_assign
id|commit_graft_pos
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|commit_graft
(braket
id|pos
)braket
suffix:semicolon
)brace
DECL|function|write_shallow_commits
r_int
id|write_shallow_commits
c_func
(paren
r_struct
id|strbuf
op_star
id|out
comma
r_int
id|use_pack_protocol
)paren
(brace
r_int
id|i
comma
id|count
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|commit_graft_nr
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|commit_graft
(braket
id|i
)braket
op_member_access_from_pointer
id|nr_parent
OL
l_int|0
)paren
(brace
r_const
r_char
op_star
id|hex
op_assign
id|sha1_to_hex
c_func
(paren
id|commit_graft
(braket
id|i
)braket
op_member_access_from_pointer
id|sha1
)paren
suffix:semicolon
id|count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|use_pack_protocol
)paren
id|packet_buf_write
c_func
(paren
id|out
comma
l_string|&quot;shallow %s&quot;
comma
id|hex
)paren
suffix:semicolon
r_else
(brace
id|strbuf_addstr
c_func
(paren
id|out
comma
id|hex
)paren
suffix:semicolon
id|strbuf_addch
c_func
(paren
id|out
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
)brace
r_return
id|count
suffix:semicolon
)brace
DECL|function|unregister_shallow
r_int
id|unregister_shallow
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_int
id|pos
op_assign
id|commit_graft_pos
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_plus
l_int|1
OL
id|commit_graft_nr
)paren
id|memmove
c_func
(paren
id|commit_graft
op_plus
id|pos
comma
id|commit_graft
op_plus
id|pos
op_plus
l_int|1
comma
r_sizeof
(paren
r_struct
id|commit_graft
op_star
)paren
op_star
(paren
id|commit_graft_nr
id|pos
l_int|1
)paren
)paren
suffix:semicolon
id|commit_graft_nr
op_decrement
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|parse_commit_buffer
r_int
id|parse_commit_buffer
c_func
(paren
r_struct
id|commit
op_star
id|item
comma
r_const
r_void
op_star
id|buffer
comma
r_int
r_int
id|size
)paren
(brace
r_const
r_char
op_star
id|tail
op_assign
id|buffer
suffix:semicolon
r_const
r_char
op_star
id|bufptr
op_assign
id|buffer
suffix:semicolon
r_int
r_char
id|parent
(braket
l_int|20
)braket
suffix:semicolon
r_struct
id|commit_list
op_star
op_star
id|pptr
suffix:semicolon
r_struct
id|commit_graft
op_star
id|graft
suffix:semicolon
r_if
c_cond
(paren
id|item-&gt;object.parsed
)paren
r_return
l_int|0
suffix:semicolon
id|item-&gt;object.parsed
op_assign
l_int|1
suffix:semicolon
id|tail
op_add_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|tail
op_le
id|bufptr
op_plus
l_int|46
op_logical_or
id|memcmp
c_func
(paren
id|bufptr
comma
l_string|&quot;tree &quot;
comma
l_int|5
)paren
op_logical_or
id|bufptr
(braket
l_int|45
)braket
op_ne
l_char|&squot;&bslash;n&squot;
)paren
r_return
id|error
c_func
(paren
l_string|&quot;bogus commit object %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|item-&gt;object.sha1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|bufptr
op_plus
l_int|5
comma
id|parent
)paren
OL
l_int|0
)paren
r_return
id|error
c_func
(paren
l_string|&quot;bad tree pointer in commit %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|item-&gt;object.sha1
)paren
)paren
suffix:semicolon
id|item-&gt;tree
op_assign
id|lookup_tree
c_func
(paren
id|parent
)paren
suffix:semicolon
id|bufptr
op_add_assign
l_int|46
suffix:semicolon
multiline_comment|/* &quot;tree &quot; + &quot;hex sha1&quot; + &quot;&bslash;n&quot; */
id|pptr
op_assign
op_amp
id|item-&gt;parents
suffix:semicolon
id|graft
op_assign
id|lookup_commit_graft
c_func
(paren
id|item-&gt;object.sha1
)paren
suffix:semicolon
r_while
c_loop
(paren
id|bufptr
op_plus
l_int|48
OL
id|tail
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|bufptr
comma
l_string|&quot;parent &quot;
comma
l_int|7
)paren
)paren
(brace
r_struct
id|commit
op_star
id|new_parent
suffix:semicolon
r_if
c_cond
(paren
id|tail
op_le
id|bufptr
op_plus
l_int|48
op_logical_or
id|get_sha1_hex
c_func
(paren
id|bufptr
op_plus
l_int|7
comma
id|parent
)paren
op_logical_or
id|bufptr
(braket
l_int|47
)braket
op_ne
l_char|&squot;&bslash;n&squot;
)paren
r_return
id|error
c_func
(paren
l_string|&quot;bad parents in commit %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|item-&gt;object.sha1
)paren
)paren
suffix:semicolon
id|bufptr
op_add_assign
l_int|48
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The clone is shallow if nr_parent &lt; 0, and we must&n;&t;&t; * not traverse its real parents even when we unhide them.&n;&t;&t; */
r_if
c_cond
(paren
id|graft
op_logical_and
(paren
id|graft-&gt;nr_parent
OL
l_int|0
op_logical_or
id|grafts_replace_parents
)paren
)paren
r_continue
suffix:semicolon
id|new_parent
op_assign
id|lookup_commit
c_func
(paren
id|parent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_parent
)paren
id|pptr
op_assign
op_amp
id|commit_list_insert
c_func
(paren
id|new_parent
comma
id|pptr
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|graft
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|commit
op_star
id|new_parent
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|graft-&gt;nr_parent
suffix:semicolon
id|i
op_increment
)paren
(brace
id|new_parent
op_assign
id|lookup_commit
c_func
(paren
id|graft-&gt;parent
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_parent
)paren
r_continue
suffix:semicolon
id|pptr
op_assign
op_amp
id|commit_list_insert
c_func
(paren
id|new_parent
comma
id|pptr
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
)brace
)brace
id|item-&gt;date
op_assign
id|parse_commit_date
c_func
(paren
id|bufptr
comma
id|tail
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|parse_commit
r_int
id|parse_commit
c_func
(paren
r_struct
id|commit
op_star
id|item
)paren
(brace
r_enum
id|object_type
id|type
suffix:semicolon
r_void
op_star
id|buffer
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|item
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|item-&gt;object.parsed
)paren
r_return
l_int|0
suffix:semicolon
id|buffer
op_assign
id|read_sha1_file
c_func
(paren
id|item-&gt;object.sha1
comma
op_amp
id|type
comma
op_amp
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer
)paren
r_return
id|error
c_func
(paren
l_string|&quot;Could not read %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|item-&gt;object.sha1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
id|OBJ_COMMIT
)paren
(brace
id|free
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_return
id|error
c_func
(paren
l_string|&quot;Object %s not a commit&quot;
comma
id|sha1_to_hex
c_func
(paren
id|item-&gt;object.sha1
)paren
)paren
suffix:semicolon
)brace
id|ret
op_assign
id|parse_commit_buffer
c_func
(paren
id|item
comma
id|buffer
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|save_commit_buffer
op_logical_and
op_logical_neg
id|ret
)paren
(brace
id|item-&gt;buffer
op_assign
id|buffer
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|free
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|find_commit_subject
r_int
id|find_commit_subject
c_func
(paren
r_const
r_char
op_star
id|commit_buffer
comma
r_const
r_char
op_star
op_star
id|subject
)paren
(brace
r_const
r_char
op_star
id|eol
suffix:semicolon
r_const
r_char
op_star
id|p
op_assign
id|commit_buffer
suffix:semicolon
r_while
c_loop
(paren
op_star
id|p
op_logical_and
(paren
op_star
id|p
op_ne
l_char|&squot;&bslash;n&squot;
op_logical_or
id|p
(braket
l_int|1
)braket
op_ne
l_char|&squot;&bslash;n&squot;
)paren
)paren
id|p
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p
)paren
(brace
id|p
op_add_assign
l_int|2
suffix:semicolon
r_for
c_loop
(paren
id|eol
op_assign
id|p
suffix:semicolon
op_star
id|eol
op_logical_and
op_star
id|eol
op_ne
l_char|&squot;&bslash;n&squot;
suffix:semicolon
id|eol
op_increment
)paren
suffix:semicolon
multiline_comment|/* do nothing */
)brace
r_else
id|eol
op_assign
id|p
suffix:semicolon
op_star
id|subject
op_assign
id|p
suffix:semicolon
r_return
id|eol
id|p
suffix:semicolon
)brace
DECL|function|commit_list_insert
r_struct
id|commit_list
op_star
id|commit_list_insert
c_func
(paren
r_struct
id|commit
op_star
id|item
comma
r_struct
id|commit_list
op_star
op_star
id|list_p
)paren
(brace
r_struct
id|commit_list
op_star
id|new_list
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|commit_list
)paren
)paren
suffix:semicolon
id|new_list-&gt;item
op_assign
id|item
suffix:semicolon
id|new_list-&gt;next
op_assign
op_star
id|list_p
suffix:semicolon
op_star
id|list_p
op_assign
id|new_list
suffix:semicolon
r_return
id|new_list
suffix:semicolon
)brace
DECL|function|commit_list_count
r_int
id|commit_list_count
c_func
(paren
r_const
r_struct
id|commit_list
op_star
id|l
)paren
(brace
r_int
id|c
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|l
suffix:semicolon
id|l
op_assign
id|l-&gt;next
)paren
id|c
op_increment
suffix:semicolon
r_return
id|c
suffix:semicolon
)brace
DECL|function|free_commit_list
r_void
id|free_commit_list
c_func
(paren
r_struct
id|commit_list
op_star
id|list
)paren
(brace
r_while
c_loop
(paren
id|list
)paren
(brace
r_struct
id|commit_list
op_star
id|temp
op_assign
id|list
suffix:semicolon
id|list
op_assign
id|temp-&gt;next
suffix:semicolon
id|free
c_func
(paren
id|temp
)paren
suffix:semicolon
)brace
)brace
DECL|function|commit_list_insert_by_date
r_struct
id|commit_list
op_star
id|commit_list_insert_by_date
c_func
(paren
r_struct
id|commit
op_star
id|item
comma
r_struct
id|commit_list
op_star
op_star
id|list
)paren
(brace
r_struct
id|commit_list
op_star
op_star
id|pp
op_assign
id|list
suffix:semicolon
r_struct
id|commit_list
op_star
id|p
suffix:semicolon
r_while
c_loop
(paren
(paren
id|p
op_assign
op_star
id|pp
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;item-&gt;date
OL
id|item-&gt;date
)paren
(brace
r_break
suffix:semicolon
)brace
id|pp
op_assign
op_amp
id|p-&gt;next
suffix:semicolon
)brace
r_return
id|commit_list_insert
c_func
(paren
id|item
comma
id|pp
)paren
suffix:semicolon
)brace
DECL|function|commit_list_sort_by_date
r_void
id|commit_list_sort_by_date
c_func
(paren
r_struct
id|commit_list
op_star
op_star
id|list
)paren
(brace
r_struct
id|commit_list
op_star
id|ret
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
op_star
id|list
)paren
(brace
id|commit_list_insert_by_date
c_func
(paren
(paren
op_star
id|list
)paren
op_member_access_from_pointer
id|item
comma
op_amp
id|ret
)paren
suffix:semicolon
op_star
id|list
op_assign
(paren
op_star
id|list
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
)brace
op_star
id|list
op_assign
id|ret
suffix:semicolon
)brace
DECL|function|pop_most_recent_commit
r_struct
id|commit
op_star
id|pop_most_recent_commit
c_func
(paren
r_struct
id|commit_list
op_star
op_star
id|list
comma
r_int
r_int
id|mark
)paren
(brace
r_struct
id|commit
op_star
id|ret
op_assign
(paren
op_star
id|list
)paren
op_member_access_from_pointer
id|item
suffix:semicolon
r_struct
id|commit_list
op_star
id|parents
op_assign
id|ret-&gt;parents
suffix:semicolon
r_struct
id|commit_list
op_star
id|old
op_assign
op_star
id|list
suffix:semicolon
op_star
id|list
op_assign
(paren
op_star
id|list
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
id|free
c_func
(paren
id|old
)paren
suffix:semicolon
r_while
c_loop
(paren
id|parents
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
id|parents-&gt;item
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parse_commit
c_func
(paren
id|commit
)paren
op_logical_and
op_logical_neg
(paren
id|commit-&gt;object.flags
op_amp
id|mark
)paren
)paren
(brace
id|commit-&gt;object.flags
op_or_assign
id|mark
suffix:semicolon
id|commit_list_insert_by_date
c_func
(paren
id|commit
comma
id|list
)paren
suffix:semicolon
)brace
id|parents
op_assign
id|parents-&gt;next
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|clear_commit_marks
r_void
id|clear_commit_marks
c_func
(paren
r_struct
id|commit
op_star
id|commit
comma
r_int
r_int
id|mark
)paren
(brace
r_while
c_loop
(paren
id|commit
)paren
(brace
r_struct
id|commit_list
op_star
id|parents
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|mark
op_amp
id|commit-&gt;object.flags
)paren
)paren
r_return
suffix:semicolon
id|commit-&gt;object.flags
op_and_assign
op_complement
id|mark
suffix:semicolon
id|parents
op_assign
id|commit-&gt;parents
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parents
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
(paren
id|parents
op_assign
id|parents-&gt;next
)paren
)paren
id|clear_commit_marks
c_func
(paren
id|parents-&gt;item
comma
id|mark
)paren
suffix:semicolon
id|commit
op_assign
id|commit-&gt;parents-&gt;item
suffix:semicolon
)brace
)brace
DECL|function|pop_commit
r_struct
id|commit
op_star
id|pop_commit
c_func
(paren
r_struct
id|commit_list
op_star
op_star
id|stack
)paren
(brace
r_struct
id|commit_list
op_star
id|top
op_assign
op_star
id|stack
suffix:semicolon
r_struct
id|commit
op_star
id|item
op_assign
id|top
ques
c_cond
id|top-&gt;item
suffix:colon
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|top
)paren
(brace
op_star
id|stack
op_assign
id|top-&gt;next
suffix:semicolon
id|free
c_func
(paren
id|top
)paren
suffix:semicolon
)brace
r_return
id|item
suffix:semicolon
)brace
multiline_comment|/*&n; * Performs an in-place topological sort on the list supplied.&n; */
DECL|function|sort_in_topological_order
r_void
id|sort_in_topological_order
c_func
(paren
r_struct
id|commit_list
op_star
op_star
id|list
comma
r_int
id|lifo
)paren
(brace
r_struct
id|commit_list
op_star
id|next
comma
op_star
id|orig
op_assign
op_star
id|list
suffix:semicolon
r_struct
id|commit_list
op_star
id|work
comma
op_star
op_star
id|insert
suffix:semicolon
r_struct
id|commit_list
op_star
op_star
id|pptr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|orig
)paren
r_return
suffix:semicolon
op_star
id|list
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Mark them and clear the indegree */
r_for
c_loop
(paren
id|next
op_assign
id|orig
suffix:semicolon
id|next
suffix:semicolon
id|next
op_assign
id|next-&gt;next
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
id|next-&gt;item
suffix:semicolon
id|commit-&gt;indegree
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* update the indegree */
r_for
c_loop
(paren
id|next
op_assign
id|orig
suffix:semicolon
id|next
suffix:semicolon
id|next
op_assign
id|next-&gt;next
)paren
(brace
r_struct
id|commit_list
op_star
id|parents
op_assign
id|next-&gt;item-&gt;parents
suffix:semicolon
r_while
c_loop
(paren
id|parents
)paren
(brace
r_struct
id|commit
op_star
id|parent
op_assign
id|parents-&gt;item
suffix:semicolon
r_if
c_cond
(paren
id|parent-&gt;indegree
)paren
id|parent-&gt;indegree
op_increment
suffix:semicolon
id|parents
op_assign
id|parents-&gt;next
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * find the tips&n;&t; *&n;&t; * tips are nodes not reachable from any other node in the list&n;&t; *&n;&t; * the tips serve as a starting set for the work queue.&n;&t; */
id|work
op_assign
l_int|NULL
suffix:semicolon
id|insert
op_assign
op_amp
id|work
suffix:semicolon
r_for
c_loop
(paren
id|next
op_assign
id|orig
suffix:semicolon
id|next
suffix:semicolon
id|next
op_assign
id|next-&gt;next
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
id|next-&gt;item
suffix:semicolon
r_if
c_cond
(paren
id|commit-&gt;indegree
op_eq
l_int|1
)paren
id|insert
op_assign
op_amp
id|commit_list_insert
c_func
(paren
id|commit
comma
id|insert
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
)brace
multiline_comment|/* process the list in topological order */
r_if
c_cond
(paren
op_logical_neg
id|lifo
)paren
id|commit_list_sort_by_date
c_func
(paren
op_amp
id|work
)paren
suffix:semicolon
id|pptr
op_assign
id|list
suffix:semicolon
op_star
id|list
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|work
)paren
(brace
r_struct
id|commit
op_star
id|commit
suffix:semicolon
r_struct
id|commit_list
op_star
id|parents
comma
op_star
id|work_item
suffix:semicolon
id|work_item
op_assign
id|work
suffix:semicolon
id|work
op_assign
id|work_item-&gt;next
suffix:semicolon
id|work_item-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|commit
op_assign
id|work_item-&gt;item
suffix:semicolon
r_for
c_loop
(paren
id|parents
op_assign
id|commit-&gt;parents
suffix:semicolon
id|parents
suffix:semicolon
id|parents
op_assign
id|parents-&gt;next
)paren
(brace
r_struct
id|commit
op_star
id|parent
op_assign
id|parents-&gt;item
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parent-&gt;indegree
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * parents are only enqueued for emission&n;&t;&t;&t; * when all their children have been emitted thereby&n;&t;&t;&t; * guaranteeing topological order.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_decrement
id|parent-&gt;indegree
op_eq
l_int|1
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|lifo
)paren
id|commit_list_insert_by_date
c_func
(paren
id|parent
comma
op_amp
id|work
)paren
suffix:semicolon
r_else
id|commit_list_insert
c_func
(paren
id|parent
comma
op_amp
id|work
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * work_item is a commit all of whose children&n;&t;&t; * have already been emitted. we can emit it now.&n;&t;&t; */
id|commit-&gt;indegree
op_assign
l_int|0
suffix:semicolon
op_star
id|pptr
op_assign
id|work_item
suffix:semicolon
id|pptr
op_assign
op_amp
id|work_item-&gt;next
suffix:semicolon
)brace
)brace
multiline_comment|/* merge-base stuff */
multiline_comment|/* bits #0..15 in revision.h */
DECL|macro|PARENT1
mdefine_line|#define PARENT1&t;&t;(1u&lt;&lt;16)
DECL|macro|PARENT2
mdefine_line|#define PARENT2&t;&t;(1u&lt;&lt;17)
DECL|macro|STALE
mdefine_line|#define STALE&t;&t;(1u&lt;&lt;18)
DECL|macro|RESULT
mdefine_line|#define RESULT&t;&t;(1u&lt;&lt;19)
DECL|variable|all_flags
r_static
r_const
r_int
id|all_flags
op_assign
(paren
id|PARENT1
op_or
id|PARENT2
op_or
id|STALE
op_or
id|RESULT
)paren
suffix:semicolon
DECL|function|interesting
r_static
r_struct
id|commit
op_star
id|interesting
c_func
(paren
r_struct
id|commit_list
op_star
id|list
)paren
(brace
r_while
c_loop
(paren
id|list
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
id|list-&gt;item
suffix:semicolon
id|list
op_assign
id|list-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|commit-&gt;object.flags
op_amp
id|STALE
)paren
r_continue
suffix:semicolon
r_return
id|commit
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|merge_bases_many
r_static
r_struct
id|commit_list
op_star
id|merge_bases_many
c_func
(paren
r_struct
id|commit
op_star
id|one
comma
r_int
id|n
comma
r_struct
id|commit
op_star
op_star
id|twos
)paren
(brace
r_struct
id|commit_list
op_star
id|list
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|commit_list
op_star
id|result
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|one
op_eq
id|twos
(braket
id|i
)braket
)paren
multiline_comment|/*&n;&t;&t;&t; * We do not mark this even with RESULT so we do not&n;&t;&t;&t; * have to clean it up.&n;&t;&t;&t; */
r_return
id|commit_list_insert
c_func
(paren
id|one
comma
op_amp
id|result
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|parse_commit
c_func
(paren
id|one
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|parse_commit
c_func
(paren
id|twos
(braket
id|i
)braket
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
id|one-&gt;object.flags
op_or_assign
id|PARENT1
suffix:semicolon
id|commit_list_insert_by_date
c_func
(paren
id|one
comma
op_amp
id|list
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
(brace
id|twos
(braket
id|i
)braket
op_member_access_from_pointer
id|object.flags
op_or_assign
id|PARENT2
suffix:semicolon
id|commit_list_insert_by_date
c_func
(paren
id|twos
(braket
id|i
)braket
comma
op_amp
id|list
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|interesting
c_func
(paren
id|list
)paren
)paren
(brace
r_struct
id|commit
op_star
id|commit
suffix:semicolon
r_struct
id|commit_list
op_star
id|parents
suffix:semicolon
r_struct
id|commit_list
op_star
id|next
suffix:semicolon
r_int
id|flags
suffix:semicolon
id|commit
op_assign
id|list-&gt;item
suffix:semicolon
id|next
op_assign
id|list-&gt;next
suffix:semicolon
id|free
c_func
(paren
id|list
)paren
suffix:semicolon
id|list
op_assign
id|next
suffix:semicolon
id|flags
op_assign
id|commit-&gt;object.flags
op_amp
(paren
id|PARENT1
op_or
id|PARENT2
op_or
id|STALE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_eq
(paren
id|PARENT1
op_or
id|PARENT2
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|commit-&gt;object.flags
op_amp
id|RESULT
)paren
)paren
(brace
id|commit-&gt;object.flags
op_or_assign
id|RESULT
suffix:semicolon
id|commit_list_insert_by_date
c_func
(paren
id|commit
comma
op_amp
id|result
)paren
suffix:semicolon
)brace
multiline_comment|/* Mark parents of a found merge stale */
id|flags
op_or_assign
id|STALE
suffix:semicolon
)brace
id|parents
op_assign
id|commit-&gt;parents
suffix:semicolon
r_while
c_loop
(paren
id|parents
)paren
(brace
r_struct
id|commit
op_star
id|p
op_assign
id|parents-&gt;item
suffix:semicolon
id|parents
op_assign
id|parents-&gt;next
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;object.flags
op_amp
id|flags
)paren
op_eq
id|flags
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|parse_commit
c_func
(paren
id|p
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|p-&gt;object.flags
op_or_assign
id|flags
suffix:semicolon
id|commit_list_insert_by_date
c_func
(paren
id|p
comma
op_amp
id|list
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Clean up the result to remove stale ones */
id|free_commit_list
c_func
(paren
id|list
)paren
suffix:semicolon
id|list
op_assign
id|result
suffix:semicolon
id|result
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|list
)paren
(brace
r_struct
id|commit_list
op_star
id|next
op_assign
id|list-&gt;next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|list-&gt;item-&gt;object.flags
op_amp
id|STALE
)paren
)paren
id|commit_list_insert_by_date
c_func
(paren
id|list-&gt;item
comma
op_amp
id|result
)paren
suffix:semicolon
id|free
c_func
(paren
id|list
)paren
suffix:semicolon
id|list
op_assign
id|next
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
DECL|function|get_octopus_merge_bases
r_struct
id|commit_list
op_star
id|get_octopus_merge_bases
c_func
(paren
r_struct
id|commit_list
op_star
id|in
)paren
(brace
r_struct
id|commit_list
op_star
id|i
comma
op_star
id|j
comma
op_star
id|k
comma
op_star
id|ret
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|commit_list
op_star
op_star
id|pptr
op_assign
op_amp
id|ret
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|in
suffix:semicolon
id|i
suffix:semicolon
id|i
op_assign
id|i-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|pptr
op_assign
op_amp
id|commit_list_insert
c_func
(paren
id|i-&gt;item
comma
id|pptr
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
r_else
(brace
r_struct
id|commit_list
op_star
r_new
op_assign
l_int|NULL
comma
op_star
id|end
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|ret
suffix:semicolon
id|j
suffix:semicolon
id|j
op_assign
id|j-&gt;next
)paren
(brace
r_struct
id|commit_list
op_star
id|bases
suffix:semicolon
id|bases
op_assign
id|get_merge_bases
c_func
(paren
id|i-&gt;item
comma
id|j-&gt;item
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
)paren
r_new
op_assign
id|bases
suffix:semicolon
r_else
id|end-&gt;next
op_assign
id|bases
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
id|bases
suffix:semicolon
id|k
suffix:semicolon
id|k
op_assign
id|k-&gt;next
)paren
id|end
op_assign
id|k
suffix:semicolon
)brace
id|ret
op_assign
r_new
suffix:semicolon
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|get_merge_bases_many
r_struct
id|commit_list
op_star
id|get_merge_bases_many
c_func
(paren
r_struct
id|commit
op_star
id|one
comma
r_int
id|n
comma
r_struct
id|commit
op_star
op_star
id|twos
comma
r_int
id|cleanup
)paren
(brace
r_struct
id|commit_list
op_star
id|list
suffix:semicolon
r_struct
id|commit
op_star
op_star
id|rslt
suffix:semicolon
r_struct
id|commit_list
op_star
id|result
suffix:semicolon
r_int
id|cnt
comma
id|i
comma
id|j
suffix:semicolon
id|result
op_assign
id|merge_bases_many
c_func
(paren
id|one
comma
id|n
comma
id|twos
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|one
op_eq
id|twos
(braket
id|i
)braket
)paren
r_return
id|result
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|result
op_logical_or
op_logical_neg
id|result-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|cleanup
)paren
(brace
id|clear_commit_marks
c_func
(paren
id|one
comma
id|all_flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
id|clear_commit_marks
c_func
(paren
id|twos
(braket
id|i
)braket
comma
id|all_flags
)paren
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/* There are more than one */
id|cnt
op_assign
l_int|0
suffix:semicolon
id|list
op_assign
id|result
suffix:semicolon
r_while
c_loop
(paren
id|list
)paren
(brace
id|list
op_assign
id|list-&gt;next
suffix:semicolon
id|cnt
op_increment
suffix:semicolon
)brace
id|rslt
op_assign
id|xcalloc
c_func
(paren
id|cnt
comma
r_sizeof
(paren
op_star
id|rslt
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|list
op_assign
id|result
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|list
suffix:semicolon
id|list
op_assign
id|list-&gt;next
)paren
id|rslt
(braket
id|i
op_increment
)braket
op_assign
id|list-&gt;item
suffix:semicolon
id|free_commit_list
c_func
(paren
id|result
)paren
suffix:semicolon
id|clear_commit_marks
c_func
(paren
id|one
comma
id|all_flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
id|clear_commit_marks
c_func
(paren
id|twos
(braket
id|i
)braket
comma
id|all_flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cnt
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
id|j
OL
id|cnt
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|rslt
(braket
id|i
)braket
op_logical_or
op_logical_neg
id|rslt
(braket
id|j
)braket
)paren
r_continue
suffix:semicolon
id|result
op_assign
id|merge_bases_many
c_func
(paren
id|rslt
(braket
id|i
)braket
comma
l_int|1
comma
op_amp
id|rslt
(braket
id|j
)braket
)paren
suffix:semicolon
id|clear_commit_marks
c_func
(paren
id|rslt
(braket
id|i
)braket
comma
id|all_flags
)paren
suffix:semicolon
id|clear_commit_marks
c_func
(paren
id|rslt
(braket
id|j
)braket
comma
id|all_flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|list
op_assign
id|result
suffix:semicolon
id|list
suffix:semicolon
id|list
op_assign
id|list-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|rslt
(braket
id|i
)braket
op_eq
id|list-&gt;item
)paren
id|rslt
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|rslt
(braket
id|j
)braket
op_eq
id|list-&gt;item
)paren
id|rslt
(braket
id|j
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Surviving ones in rslt[] are the independent results */
id|result
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|rslt
(braket
id|i
)braket
)paren
id|commit_list_insert_by_date
c_func
(paren
id|rslt
(braket
id|i
)braket
comma
op_amp
id|result
)paren
suffix:semicolon
)brace
id|free
c_func
(paren
id|rslt
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|get_merge_bases
r_struct
id|commit_list
op_star
id|get_merge_bases
c_func
(paren
r_struct
id|commit
op_star
id|one
comma
r_struct
id|commit
op_star
id|two
comma
r_int
id|cleanup
)paren
(brace
r_return
id|get_merge_bases_many
c_func
(paren
id|one
comma
l_int|1
comma
op_amp
id|two
comma
id|cleanup
)paren
suffix:semicolon
)brace
DECL|function|is_descendant_of
r_int
id|is_descendant_of
c_func
(paren
r_struct
id|commit
op_star
id|commit
comma
r_struct
id|commit_list
op_star
id|with_commit
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|with_commit
)paren
r_return
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|with_commit
)paren
(brace
r_struct
id|commit
op_star
id|other
suffix:semicolon
id|other
op_assign
id|with_commit-&gt;item
suffix:semicolon
id|with_commit
op_assign
id|with_commit-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|in_merge_bases
c_func
(paren
id|other
comma
op_amp
id|commit
comma
l_int|1
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|in_merge_bases
r_int
id|in_merge_bases
c_func
(paren
r_struct
id|commit
op_star
id|commit
comma
r_struct
id|commit
op_star
op_star
id|reference
comma
r_int
id|num
)paren
(brace
r_struct
id|commit_list
op_star
id|bases
comma
op_star
id|b
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|num
op_eq
l_int|1
)paren
id|bases
op_assign
id|get_merge_bases
c_func
(paren
id|commit
comma
op_star
id|reference
comma
l_int|1
)paren
suffix:semicolon
r_else
id|die
c_func
(paren
l_string|&quot;not yet&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|b
op_assign
id|bases
suffix:semicolon
id|b
suffix:semicolon
id|b
op_assign
id|b-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|hashcmp
c_func
(paren
id|commit-&gt;object.sha1
comma
id|b-&gt;item-&gt;object.sha1
)paren
)paren
(brace
id|ret
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|free_commit_list
c_func
(paren
id|bases
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|reduce_heads
r_struct
id|commit_list
op_star
id|reduce_heads
c_func
(paren
r_struct
id|commit_list
op_star
id|heads
)paren
(brace
r_struct
id|commit_list
op_star
id|p
suffix:semicolon
r_struct
id|commit_list
op_star
id|result
op_assign
l_int|NULL
comma
op_star
op_star
id|tail
op_assign
op_amp
id|result
suffix:semicolon
r_struct
id|commit
op_star
op_star
id|other
suffix:semicolon
r_int
id|num_head
comma
id|num_other
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|heads
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* Avoid unnecessary reallocations */
r_for
c_loop
(paren
id|p
op_assign
id|heads
comma
id|num_head
op_assign
l_int|0
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
id|num_head
op_increment
suffix:semicolon
id|other
op_assign
id|xcalloc
c_func
(paren
r_sizeof
(paren
op_star
id|other
)paren
comma
id|num_head
)paren
suffix:semicolon
multiline_comment|/* For each commit, see if it can be reached by others */
r_for
c_loop
(paren
id|p
op_assign
id|heads
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_struct
id|commit_list
op_star
id|q
comma
op_star
id|base
suffix:semicolon
multiline_comment|/* Do we already have this in the result? */
r_for
c_loop
(paren
id|q
op_assign
id|result
suffix:semicolon
id|q
suffix:semicolon
id|q
op_assign
id|q-&gt;next
)paren
r_if
c_cond
(paren
id|p-&gt;item
op_eq
id|q-&gt;item
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|q
)paren
r_continue
suffix:semicolon
id|num_other
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|q
op_assign
id|heads
suffix:semicolon
id|q
suffix:semicolon
id|q
op_assign
id|q-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;item
op_eq
id|q-&gt;item
)paren
r_continue
suffix:semicolon
id|other
(braket
id|num_other
op_increment
)braket
op_assign
id|q-&gt;item
suffix:semicolon
)brace
r_if
c_cond
(paren
id|num_other
)paren
id|base
op_assign
id|get_merge_bases_many
c_func
(paren
id|p-&gt;item
comma
id|num_other
comma
id|other
comma
l_int|1
)paren
suffix:semicolon
r_else
id|base
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If p-&gt;item does not have anything common with other&n;&t;&t; * commits, there won&squot;t be any merge base.  If it is&n;&t;&t; * reachable from some of the others, p-&gt;item will be&n;&t;&t; * the merge base.  If its history is connected with&n;&t;&t; * others, but p-&gt;item is not reachable by others, we&n;&t;&t; * will get something other than p-&gt;item back.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|base
op_logical_or
(paren
id|base-&gt;item
op_ne
id|p-&gt;item
)paren
)paren
id|tail
op_assign
op_amp
(paren
id|commit_list_insert
c_func
(paren
id|p-&gt;item
comma
id|tail
)paren
op_member_access_from_pointer
id|next
)paren
suffix:semicolon
id|free_commit_list
c_func
(paren
id|base
)paren
suffix:semicolon
)brace
id|free
c_func
(paren
id|other
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|variable|commit_utf8_warn
r_static
r_const
r_char
id|commit_utf8_warn
(braket
)braket
op_assign
l_string|&quot;Warning: commit message does not conform to UTF-8.&bslash;n&quot;
l_string|&quot;You may want to amend it after fixing the message, or set the config&bslash;n&quot;
l_string|&quot;variable i18n.commitencoding to the encoding your project uses.&bslash;n&quot;
suffix:semicolon
DECL|function|commit_tree
r_int
id|commit_tree
c_func
(paren
r_const
r_char
op_star
id|msg
comma
r_int
r_char
op_star
id|tree
comma
r_struct
id|commit_list
op_star
id|parents
comma
r_int
r_char
op_star
id|ret
comma
r_const
r_char
op_star
id|author
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
id|encoding_is_utf8
suffix:semicolon
r_struct
id|strbuf
id|buffer
suffix:semicolon
id|assert_sha1_type
c_func
(paren
id|tree
comma
id|OBJ_TREE
)paren
suffix:semicolon
multiline_comment|/* Not having i18n.commitencoding is the same as having utf-8 */
id|encoding_is_utf8
op_assign
id|is_encoding_utf8
c_func
(paren
id|git_commit_encoding
)paren
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|buffer
comma
l_int|8192
)paren
suffix:semicolon
multiline_comment|/* should avoid reallocs for the headers */
id|strbuf_addf
c_func
(paren
op_amp
id|buffer
comma
l_string|&quot;tree %s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|tree
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * NOTE! This ordering means that the same exact tree merged with a&n;&t; * different order of parents will be a _different_ changeset even&n;&t; * if everything else stays the same.&n;&t; */
r_while
c_loop
(paren
id|parents
)paren
(brace
r_struct
id|commit_list
op_star
id|next
op_assign
id|parents-&gt;next
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
id|buffer
comma
l_string|&quot;parent %s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|parents-&gt;item-&gt;object.sha1
)paren
)paren
suffix:semicolon
id|free
c_func
(paren
id|parents
)paren
suffix:semicolon
id|parents
op_assign
id|next
suffix:semicolon
)brace
multiline_comment|/* Person/date information */
r_if
c_cond
(paren
op_logical_neg
id|author
)paren
id|author
op_assign
id|git_author_info
c_func
(paren
id|IDENT_ERROR_ON_NO_NAME
)paren
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
id|buffer
comma
l_string|&quot;author %s&bslash;n&quot;
comma
id|author
)paren
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
id|buffer
comma
l_string|&quot;committer %s&bslash;n&quot;
comma
id|git_committer_info
c_func
(paren
id|IDENT_ERROR_ON_NO_NAME
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|encoding_is_utf8
)paren
id|strbuf_addf
c_func
(paren
op_amp
id|buffer
comma
l_string|&quot;encoding %s&bslash;n&quot;
comma
id|git_commit_encoding
)paren
suffix:semicolon
id|strbuf_addch
c_func
(paren
op_amp
id|buffer
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
multiline_comment|/* And add the comment */
id|strbuf_addstr
c_func
(paren
op_amp
id|buffer
comma
id|msg
)paren
suffix:semicolon
multiline_comment|/* And check the encoding */
r_if
c_cond
(paren
id|encoding_is_utf8
op_logical_and
op_logical_neg
id|is_utf8
c_func
(paren
id|buffer.buf
)paren
)paren
id|fprintf
c_func
(paren
id|stderr
comma
id|commit_utf8_warn
)paren
suffix:semicolon
id|result
op_assign
id|write_sha1_file
c_func
(paren
id|buffer.buf
comma
id|buffer.len
comma
id|commit_type
comma
id|ret
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|buffer
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
eof
