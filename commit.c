macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;tag.h&quot;
macro_line|#include &quot;commit.h&quot;
macro_line|#include &quot;pkt-line.h&quot;
macro_line|#include &quot;utf8.h&quot;
macro_line|#include &quot;diff.h&quot;
macro_line|#include &quot;revision.h&quot;
macro_line|#include &quot;notes.h&quot;
macro_line|#include &quot;gpg-interface.h&quot;
macro_line|#include &quot;mergesort.h&quot;
macro_line|#include &quot;commit-slab.h&quot;
macro_line|#include &quot;prio-queue.h&quot;
macro_line|#include &quot;sha1-lookup.h&quot;
r_static
r_struct
id|commit_extra_header
op_star
id|read_commit_extra_header_lines
c_func
(paren
r_const
r_char
op_star
id|buf
comma
r_int
id|len
comma
r_const
r_char
op_star
op_star
)paren
suffix:semicolon
DECL|variable|save_commit_buffer
r_int
id|save_commit_buffer
op_assign
l_int|1
suffix:semicolon
DECL|variable|commit_type
r_const
r_char
op_star
id|commit_type
op_assign
l_string|&quot;commit&quot;
suffix:semicolon
DECL|function|lookup_commit_reference_gently
r_struct
id|commit
op_star
id|lookup_commit_reference_gently
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
id|quiet
)paren
(brace
r_struct
id|object
op_star
id|obj
op_assign
id|deref_tag
c_func
(paren
id|parse_object
c_func
(paren
id|sha1
)paren
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|obj
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|object_as_type
c_func
(paren
id|obj
comma
id|OBJ_COMMIT
comma
id|quiet
)paren
suffix:semicolon
)brace
DECL|function|lookup_commit_reference
r_struct
id|commit
op_star
id|lookup_commit_reference
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_return
id|lookup_commit_reference_gently
c_func
(paren
id|sha1
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|lookup_commit_or_die
r_struct
id|commit
op_star
id|lookup_commit_or_die
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
comma
r_const
r_char
op_star
id|ref_name
)paren
(brace
r_struct
id|commit
op_star
id|c
op_assign
id|lookup_commit_reference
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;could not parse %s&quot;
)paren
comma
id|ref_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hashcmp
c_func
(paren
id|sha1
comma
id|c-&gt;object.sha1
)paren
)paren
(brace
id|warning
c_func
(paren
id|_
c_func
(paren
l_string|&quot;%s %s is not a commit!&quot;
)paren
comma
id|ref_name
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
)brace
r_return
id|c
suffix:semicolon
)brace
DECL|function|lookup_commit
r_struct
id|commit
op_star
id|lookup_commit
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_struct
id|object
op_star
id|obj
op_assign
id|lookup_object
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|obj
)paren
r_return
id|create_object
c_func
(paren
id|sha1
comma
id|alloc_commit_node
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|object_as_type
c_func
(paren
id|obj
comma
id|OBJ_COMMIT
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|lookup_commit_reference_by_name
r_struct
id|commit
op_star
id|lookup_commit_reference_by_name
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_struct
id|commit
op_star
id|commit
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1_committish
c_func
(paren
id|name
comma
id|sha1
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|commit
op_assign
id|lookup_commit_reference
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parse_commit
c_func
(paren
id|commit
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|commit
suffix:semicolon
)brace
DECL|function|parse_commit_date
r_static
r_int
r_int
id|parse_commit_date
c_func
(paren
r_const
r_char
op_star
id|buf
comma
r_const
r_char
op_star
id|tail
)paren
(brace
r_const
r_char
op_star
id|dateptr
suffix:semicolon
r_if
c_cond
(paren
id|buf
op_plus
l_int|6
op_ge
id|tail
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|buf
comma
l_string|&quot;author&quot;
comma
l_int|6
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|buf
OL
id|tail
op_logical_and
op_star
id|buf
op_increment
op_ne
l_char|&squot;&bslash;n&squot;
)paren
multiline_comment|/* nada */
suffix:semicolon
r_if
c_cond
(paren
id|buf
op_plus
l_int|9
op_ge
id|tail
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|buf
comma
l_string|&quot;committer&quot;
comma
l_int|9
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|buf
OL
id|tail
op_logical_and
op_star
id|buf
op_increment
op_ne
l_char|&squot;&gt;&squot;
)paren
multiline_comment|/* nada */
suffix:semicolon
r_if
c_cond
(paren
id|buf
op_ge
id|tail
)paren
r_return
l_int|0
suffix:semicolon
id|dateptr
op_assign
id|buf
suffix:semicolon
r_while
c_loop
(paren
id|buf
OL
id|tail
op_logical_and
op_star
id|buf
op_increment
op_ne
l_char|&squot;&bslash;n&squot;
)paren
multiline_comment|/* nada */
suffix:semicolon
r_if
c_cond
(paren
id|buf
op_ge
id|tail
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* dateptr &lt; buf &amp;&amp; buf[-1] == &squot;&bslash;n&squot;, so strtoul will stop at buf-1 */
r_return
id|strtoul
c_func
(paren
id|dateptr
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
)brace
DECL|variable|commit_graft
r_static
r_struct
id|commit_graft
op_star
op_star
id|commit_graft
suffix:semicolon
DECL|variable|commit_graft_alloc
DECL|variable|commit_graft_nr
r_static
r_int
id|commit_graft_alloc
comma
id|commit_graft_nr
suffix:semicolon
DECL|function|commit_graft_sha1_access
r_static
r_const
r_int
r_char
op_star
id|commit_graft_sha1_access
c_func
(paren
r_int
id|index
comma
r_void
op_star
id|table
)paren
(brace
r_struct
id|commit_graft
op_star
op_star
id|commit_graft_table
op_assign
id|table
suffix:semicolon
r_return
id|commit_graft_table
(braket
id|index
)braket
op_member_access_from_pointer
id|sha1
suffix:semicolon
)brace
DECL|function|commit_graft_pos
r_static
r_int
id|commit_graft_pos
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_return
id|sha1_pos
c_func
(paren
id|sha1
comma
id|commit_graft
comma
id|commit_graft_nr
comma
id|commit_graft_sha1_access
)paren
suffix:semicolon
)brace
DECL|function|register_commit_graft
r_int
id|register_commit_graft
c_func
(paren
r_struct
id|commit_graft
op_star
id|graft
comma
r_int
id|ignore_dups
)paren
(brace
r_int
id|pos
op_assign
id|commit_graft_pos
c_func
(paren
id|graft-&gt;sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_le
id|pos
)paren
(brace
r_if
c_cond
(paren
id|ignore_dups
)paren
id|free
c_func
(paren
id|graft
)paren
suffix:semicolon
r_else
(brace
id|free
c_func
(paren
id|commit_graft
(braket
id|pos
)braket
)paren
suffix:semicolon
id|commit_graft
(braket
id|pos
)braket
op_assign
id|graft
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
id|pos
op_assign
id|pos
l_int|1
suffix:semicolon
id|ALLOC_GROW
c_func
(paren
id|commit_graft
comma
id|commit_graft_nr
op_plus
l_int|1
comma
id|commit_graft_alloc
)paren
suffix:semicolon
id|commit_graft_nr
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
id|commit_graft_nr
)paren
id|memmove
c_func
(paren
id|commit_graft
op_plus
id|pos
op_plus
l_int|1
comma
id|commit_graft
op_plus
id|pos
comma
(paren
id|commit_graft_nr
id|pos
l_int|1
)paren
op_star
r_sizeof
(paren
op_star
id|commit_graft
)paren
)paren
suffix:semicolon
id|commit_graft
(braket
id|pos
)braket
op_assign
id|graft
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|read_graft_line
r_struct
id|commit_graft
op_star
id|read_graft_line
c_func
(paren
r_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
multiline_comment|/* The format is just &quot;Commit Parent1 Parent2 ...&bslash;n&quot; */
r_int
id|i
suffix:semicolon
r_struct
id|commit_graft
op_star
id|graft
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|len
op_logical_and
id|isspace
c_func
(paren
id|buf
(braket
id|len
op_minus
l_int|1
)braket
)paren
)paren
id|buf
(braket
op_decrement
id|len
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|buf
(braket
l_int|0
)braket
op_eq
l_char|&squot;#&squot;
op_logical_or
id|buf
(braket
l_int|0
)braket
op_eq
l_char|&squot;&bslash;0&squot;
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_plus
l_int|1
)paren
op_mod
l_int|41
)paren
r_goto
id|bad_graft_data
suffix:semicolon
id|i
op_assign
(paren
id|len
op_plus
l_int|1
)paren
op_div
l_int|41
l_int|1
suffix:semicolon
id|graft
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|graft
)paren
op_plus
l_int|20
op_star
id|i
)paren
suffix:semicolon
id|graft-&gt;nr_parent
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|buf
comma
id|graft-&gt;sha1
)paren
)paren
r_goto
id|bad_graft_data
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|40
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_add_assign
l_int|41
)paren
(brace
r_if
c_cond
(paren
id|buf
(braket
id|i
)braket
op_ne
l_char|&squot; &squot;
)paren
r_goto
id|bad_graft_data
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|buf
op_plus
id|i
op_plus
l_int|1
comma
id|graft-&gt;parent
(braket
id|i
op_div
l_int|41
)braket
)paren
)paren
r_goto
id|bad_graft_data
suffix:semicolon
)brace
r_return
id|graft
suffix:semicolon
id|bad_graft_data
suffix:colon
id|error
c_func
(paren
l_string|&quot;bad graft data: %s&quot;
comma
id|buf
)paren
suffix:semicolon
id|free
c_func
(paren
id|graft
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|read_graft_file
r_static
r_int
id|read_graft_file
c_func
(paren
r_const
r_char
op_star
id|graft_file
)paren
(brace
id|FILE
op_star
id|fp
op_assign
id|fopen
c_func
(paren
id|graft_file
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_struct
id|strbuf
id|buf
op_assign
id|STRBUF_INIT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fp
)paren
r_return
l_int|1
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|strbuf_getwholeline
c_func
(paren
op_amp
id|buf
comma
id|fp
comma
l_char|&squot;&bslash;n&squot;
)paren
)paren
(brace
multiline_comment|/* The format is just &quot;Commit Parent1 Parent2 ...&bslash;n&quot; */
r_struct
id|commit_graft
op_star
id|graft
op_assign
id|read_graft_line
c_func
(paren
id|buf.buf
comma
id|buf.len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|graft
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|register_commit_graft
c_func
(paren
id|graft
comma
l_int|1
)paren
)paren
id|error
c_func
(paren
l_string|&quot;duplicate graft data: %s&quot;
comma
id|buf.buf
)paren
suffix:semicolon
)brace
id|fclose
c_func
(paren
id|fp
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|buf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|prepare_commit_graft
r_static
r_void
id|prepare_commit_graft
c_func
(paren
r_void
)paren
(brace
r_static
r_int
id|commit_graft_prepared
suffix:semicolon
r_char
op_star
id|graft_file
suffix:semicolon
r_if
c_cond
(paren
id|commit_graft_prepared
)paren
r_return
suffix:semicolon
id|graft_file
op_assign
id|get_graft_file
c_func
(paren
)paren
suffix:semicolon
id|read_graft_file
c_func
(paren
id|graft_file
)paren
suffix:semicolon
multiline_comment|/* make sure shallows are read */
id|is_repository_shallow
c_func
(paren
)paren
suffix:semicolon
id|commit_graft_prepared
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|lookup_commit_graft
r_struct
id|commit_graft
op_star
id|lookup_commit_graft
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_int
id|pos
suffix:semicolon
id|prepare_commit_graft
c_func
(paren
)paren
suffix:semicolon
id|pos
op_assign
id|commit_graft_pos
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|commit_graft
(braket
id|pos
)braket
suffix:semicolon
)brace
DECL|function|for_each_commit_graft
r_int
id|for_each_commit_graft
c_func
(paren
id|each_commit_graft_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_int
id|i
comma
id|ret
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|ret
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|commit_graft_nr
op_logical_and
op_logical_neg
id|ret
suffix:semicolon
id|i
op_increment
)paren
id|ret
op_assign
id|fn
c_func
(paren
id|commit_graft
(braket
id|i
)braket
comma
id|cb_data
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|unregister_shallow
r_int
id|unregister_shallow
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_int
id|pos
op_assign
id|commit_graft_pos
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_plus
l_int|1
OL
id|commit_graft_nr
)paren
id|memmove
c_func
(paren
id|commit_graft
op_plus
id|pos
comma
id|commit_graft
op_plus
id|pos
op_plus
l_int|1
comma
r_sizeof
(paren
r_struct
id|commit_graft
op_star
)paren
op_star
(paren
id|commit_graft_nr
id|pos
l_int|1
)paren
)paren
suffix:semicolon
id|commit_graft_nr
op_decrement
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|struct|commit_buffer
r_struct
id|commit_buffer
(brace
DECL|member|buffer
r_void
op_star
id|buffer
suffix:semicolon
DECL|member|size
r_int
r_int
id|size
suffix:semicolon
)brace
suffix:semicolon
id|define_commit_slab
c_func
(paren
id|buffer_slab
comma
r_struct
id|commit_buffer
)paren
suffix:semicolon
DECL|variable|buffer_slab
r_static
r_struct
id|buffer_slab
id|buffer_slab
op_assign
id|COMMIT_SLAB_INIT
c_func
(paren
l_int|1
comma
id|buffer_slab
)paren
suffix:semicolon
DECL|function|set_commit_buffer
r_void
id|set_commit_buffer
c_func
(paren
r_struct
id|commit
op_star
id|commit
comma
r_void
op_star
id|buffer
comma
r_int
r_int
id|size
)paren
(brace
r_struct
id|commit_buffer
op_star
id|v
op_assign
id|buffer_slab_at
c_func
(paren
op_amp
id|buffer_slab
comma
id|commit
)paren
suffix:semicolon
id|v-&gt;buffer
op_assign
id|buffer
suffix:semicolon
id|v-&gt;size
op_assign
id|size
suffix:semicolon
)brace
DECL|function|get_cached_commit_buffer
r_const
r_void
op_star
id|get_cached_commit_buffer
c_func
(paren
r_const
r_struct
id|commit
op_star
id|commit
comma
r_int
r_int
op_star
id|sizep
)paren
(brace
r_struct
id|commit_buffer
op_star
id|v
op_assign
id|buffer_slab_at
c_func
(paren
op_amp
id|buffer_slab
comma
id|commit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sizep
)paren
op_star
id|sizep
op_assign
id|v-&gt;size
suffix:semicolon
r_return
id|v-&gt;buffer
suffix:semicolon
)brace
DECL|function|get_commit_buffer
r_const
r_void
op_star
id|get_commit_buffer
c_func
(paren
r_const
r_struct
id|commit
op_star
id|commit
comma
r_int
r_int
op_star
id|sizep
)paren
(brace
r_const
r_void
op_star
id|ret
op_assign
id|get_cached_commit_buffer
c_func
(paren
id|commit
comma
id|sizep
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
r_enum
id|object_type
id|type
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
id|ret
op_assign
id|read_sha1_file
c_func
(paren
id|commit-&gt;object.sha1
comma
op_amp
id|type
comma
op_amp
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|die
c_func
(paren
l_string|&quot;cannot read commit object %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|commit-&gt;object.sha1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
id|OBJ_COMMIT
)paren
id|die
c_func
(paren
l_string|&quot;expected commit for %s, got %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|commit-&gt;object.sha1
)paren
comma
r_typename
(paren
id|type
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sizep
)paren
op_star
id|sizep
op_assign
id|size
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|unuse_commit_buffer
r_void
id|unuse_commit_buffer
c_func
(paren
r_const
r_struct
id|commit
op_star
id|commit
comma
r_const
r_void
op_star
id|buffer
)paren
(brace
r_struct
id|commit_buffer
op_star
id|v
op_assign
id|buffer_slab_at
c_func
(paren
op_amp
id|buffer_slab
comma
id|commit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|v-&gt;buffer
op_ne
id|buffer
)paren
id|free
c_func
(paren
(paren
r_void
op_star
)paren
id|buffer
)paren
suffix:semicolon
)brace
DECL|function|free_commit_buffer
r_void
id|free_commit_buffer
c_func
(paren
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_struct
id|commit_buffer
op_star
id|v
op_assign
id|buffer_slab_at
c_func
(paren
op_amp
id|buffer_slab
comma
id|commit
)paren
suffix:semicolon
id|free
c_func
(paren
id|v-&gt;buffer
)paren
suffix:semicolon
id|v-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
id|v-&gt;size
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|detach_commit_buffer
r_const
r_void
op_star
id|detach_commit_buffer
c_func
(paren
r_struct
id|commit
op_star
id|commit
comma
r_int
r_int
op_star
id|sizep
)paren
(brace
r_struct
id|commit_buffer
op_star
id|v
op_assign
id|buffer_slab_at
c_func
(paren
op_amp
id|buffer_slab
comma
id|commit
)paren
suffix:semicolon
r_void
op_star
id|ret
suffix:semicolon
id|ret
op_assign
id|v-&gt;buffer
suffix:semicolon
r_if
c_cond
(paren
id|sizep
)paren
op_star
id|sizep
op_assign
id|v-&gt;size
suffix:semicolon
id|v-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
id|v-&gt;size
op_assign
l_int|0
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|parse_commit_buffer
r_int
id|parse_commit_buffer
c_func
(paren
r_struct
id|commit
op_star
id|item
comma
r_const
r_void
op_star
id|buffer
comma
r_int
r_int
id|size
)paren
(brace
r_const
r_char
op_star
id|tail
op_assign
id|buffer
suffix:semicolon
r_const
r_char
op_star
id|bufptr
op_assign
id|buffer
suffix:semicolon
r_int
r_char
id|parent
(braket
l_int|20
)braket
suffix:semicolon
r_struct
id|commit_list
op_star
op_star
id|pptr
suffix:semicolon
r_struct
id|commit_graft
op_star
id|graft
suffix:semicolon
r_if
c_cond
(paren
id|item-&gt;object.parsed
)paren
r_return
l_int|0
suffix:semicolon
id|item-&gt;object.parsed
op_assign
l_int|1
suffix:semicolon
id|tail
op_add_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|tail
op_le
id|bufptr
op_plus
l_int|46
op_logical_or
id|memcmp
c_func
(paren
id|bufptr
comma
l_string|&quot;tree &quot;
comma
l_int|5
)paren
op_logical_or
id|bufptr
(braket
l_int|45
)braket
op_ne
l_char|&squot;&bslash;n&squot;
)paren
r_return
id|error
c_func
(paren
l_string|&quot;bogus commit object %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|item-&gt;object.sha1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|bufptr
op_plus
l_int|5
comma
id|parent
)paren
OL
l_int|0
)paren
r_return
id|error
c_func
(paren
l_string|&quot;bad tree pointer in commit %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|item-&gt;object.sha1
)paren
)paren
suffix:semicolon
id|item-&gt;tree
op_assign
id|lookup_tree
c_func
(paren
id|parent
)paren
suffix:semicolon
id|bufptr
op_add_assign
l_int|46
suffix:semicolon
multiline_comment|/* &quot;tree &quot; + &quot;hex sha1&quot; + &quot;&bslash;n&quot; */
id|pptr
op_assign
op_amp
id|item-&gt;parents
suffix:semicolon
id|graft
op_assign
id|lookup_commit_graft
c_func
(paren
id|item-&gt;object.sha1
)paren
suffix:semicolon
r_while
c_loop
(paren
id|bufptr
op_plus
l_int|48
OL
id|tail
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|bufptr
comma
l_string|&quot;parent &quot;
comma
l_int|7
)paren
)paren
(brace
r_struct
id|commit
op_star
id|new_parent
suffix:semicolon
r_if
c_cond
(paren
id|tail
op_le
id|bufptr
op_plus
l_int|48
op_logical_or
id|get_sha1_hex
c_func
(paren
id|bufptr
op_plus
l_int|7
comma
id|parent
)paren
op_logical_or
id|bufptr
(braket
l_int|47
)braket
op_ne
l_char|&squot;&bslash;n&squot;
)paren
r_return
id|error
c_func
(paren
l_string|&quot;bad parents in commit %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|item-&gt;object.sha1
)paren
)paren
suffix:semicolon
id|bufptr
op_add_assign
l_int|48
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The clone is shallow if nr_parent &lt; 0, and we must&n;&t;&t; * not traverse its real parents even when we unhide them.&n;&t;&t; */
r_if
c_cond
(paren
id|graft
op_logical_and
(paren
id|graft-&gt;nr_parent
OL
l_int|0
op_logical_or
id|grafts_replace_parents
)paren
)paren
r_continue
suffix:semicolon
id|new_parent
op_assign
id|lookup_commit
c_func
(paren
id|parent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_parent
)paren
id|pptr
op_assign
op_amp
id|commit_list_insert
c_func
(paren
id|new_parent
comma
id|pptr
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|graft
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|commit
op_star
id|new_parent
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|graft-&gt;nr_parent
suffix:semicolon
id|i
op_increment
)paren
(brace
id|new_parent
op_assign
id|lookup_commit
c_func
(paren
id|graft-&gt;parent
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_parent
)paren
r_continue
suffix:semicolon
id|pptr
op_assign
op_amp
id|commit_list_insert
c_func
(paren
id|new_parent
comma
id|pptr
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
)brace
)brace
id|item-&gt;date
op_assign
id|parse_commit_date
c_func
(paren
id|bufptr
comma
id|tail
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|parse_commit
r_int
id|parse_commit
c_func
(paren
r_struct
id|commit
op_star
id|item
)paren
(brace
r_enum
id|object_type
id|type
suffix:semicolon
r_void
op_star
id|buffer
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|item
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|item-&gt;object.parsed
)paren
r_return
l_int|0
suffix:semicolon
id|buffer
op_assign
id|read_sha1_file
c_func
(paren
id|item-&gt;object.sha1
comma
op_amp
id|type
comma
op_amp
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer
)paren
r_return
id|error
c_func
(paren
l_string|&quot;Could not read %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|item-&gt;object.sha1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
id|OBJ_COMMIT
)paren
(brace
id|free
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_return
id|error
c_func
(paren
l_string|&quot;Object %s not a commit&quot;
comma
id|sha1_to_hex
c_func
(paren
id|item-&gt;object.sha1
)paren
)paren
suffix:semicolon
)brace
id|ret
op_assign
id|parse_commit_buffer
c_func
(paren
id|item
comma
id|buffer
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|save_commit_buffer
op_logical_and
op_logical_neg
id|ret
)paren
(brace
id|set_commit_buffer
c_func
(paren
id|item
comma
id|buffer
comma
id|size
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|free
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|parse_commit_or_die
r_void
id|parse_commit_or_die
c_func
(paren
r_struct
id|commit
op_star
id|item
)paren
(brace
r_if
c_cond
(paren
id|parse_commit
c_func
(paren
id|item
)paren
)paren
id|die
c_func
(paren
l_string|&quot;unable to parse commit %s&quot;
comma
id|item
ques
c_cond
id|sha1_to_hex
c_func
(paren
id|item-&gt;object.sha1
)paren
suffix:colon
l_string|&quot;(null)&quot;
)paren
suffix:semicolon
)brace
DECL|function|find_commit_subject
r_int
id|find_commit_subject
c_func
(paren
r_const
r_char
op_star
id|commit_buffer
comma
r_const
r_char
op_star
op_star
id|subject
)paren
(brace
r_const
r_char
op_star
id|eol
suffix:semicolon
r_const
r_char
op_star
id|p
op_assign
id|commit_buffer
suffix:semicolon
r_while
c_loop
(paren
op_star
id|p
op_logical_and
(paren
op_star
id|p
op_ne
l_char|&squot;&bslash;n&squot;
op_logical_or
id|p
(braket
l_int|1
)braket
op_ne
l_char|&squot;&bslash;n&squot;
)paren
)paren
id|p
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p
)paren
(brace
id|p
op_add_assign
l_int|2
suffix:semicolon
r_for
c_loop
(paren
id|eol
op_assign
id|p
suffix:semicolon
op_star
id|eol
op_logical_and
op_star
id|eol
op_ne
l_char|&squot;&bslash;n&squot;
suffix:semicolon
id|eol
op_increment
)paren
suffix:semicolon
multiline_comment|/* do nothing */
)brace
r_else
id|eol
op_assign
id|p
suffix:semicolon
op_star
id|subject
op_assign
id|p
suffix:semicolon
r_return
id|eol
id|p
suffix:semicolon
)brace
DECL|function|commit_list_insert
r_struct
id|commit_list
op_star
id|commit_list_insert
c_func
(paren
r_struct
id|commit
op_star
id|item
comma
r_struct
id|commit_list
op_star
op_star
id|list_p
)paren
(brace
r_struct
id|commit_list
op_star
id|new_list
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|commit_list
)paren
)paren
suffix:semicolon
id|new_list-&gt;item
op_assign
id|item
suffix:semicolon
id|new_list-&gt;next
op_assign
op_star
id|list_p
suffix:semicolon
op_star
id|list_p
op_assign
id|new_list
suffix:semicolon
r_return
id|new_list
suffix:semicolon
)brace
DECL|function|commit_list_count
r_int
id|commit_list_count
c_func
(paren
r_const
r_struct
id|commit_list
op_star
id|l
)paren
(brace
r_int
id|c
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|l
suffix:semicolon
id|l
op_assign
id|l-&gt;next
)paren
id|c
op_increment
suffix:semicolon
r_return
id|c
suffix:semicolon
)brace
DECL|function|copy_commit_list
r_struct
id|commit_list
op_star
id|copy_commit_list
c_func
(paren
r_struct
id|commit_list
op_star
id|list
)paren
(brace
r_struct
id|commit_list
op_star
id|head
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|commit_list
op_star
op_star
id|pp
op_assign
op_amp
id|head
suffix:semicolon
r_while
c_loop
(paren
id|list
)paren
(brace
r_struct
id|commit_list
op_star
r_new
suffix:semicolon
r_new
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|commit_list
)paren
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|item
op_assign
id|list-&gt;item
suffix:semicolon
r_new
op_member_access_from_pointer
id|next
op_assign
l_int|NULL
suffix:semicolon
op_star
id|pp
op_assign
r_new
suffix:semicolon
id|pp
op_assign
op_amp
r_new
op_member_access_from_pointer
id|next
suffix:semicolon
id|list
op_assign
id|list-&gt;next
suffix:semicolon
)brace
r_return
id|head
suffix:semicolon
)brace
DECL|function|free_commit_list
r_void
id|free_commit_list
c_func
(paren
r_struct
id|commit_list
op_star
id|list
)paren
(brace
r_while
c_loop
(paren
id|list
)paren
(brace
r_struct
id|commit_list
op_star
id|temp
op_assign
id|list
suffix:semicolon
id|list
op_assign
id|temp-&gt;next
suffix:semicolon
id|free
c_func
(paren
id|temp
)paren
suffix:semicolon
)brace
)brace
DECL|function|commit_list_insert_by_date
r_struct
id|commit_list
op_star
id|commit_list_insert_by_date
c_func
(paren
r_struct
id|commit
op_star
id|item
comma
r_struct
id|commit_list
op_star
op_star
id|list
)paren
(brace
r_struct
id|commit_list
op_star
op_star
id|pp
op_assign
id|list
suffix:semicolon
r_struct
id|commit_list
op_star
id|p
suffix:semicolon
r_while
c_loop
(paren
(paren
id|p
op_assign
op_star
id|pp
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;item-&gt;date
OL
id|item-&gt;date
)paren
(brace
r_break
suffix:semicolon
)brace
id|pp
op_assign
op_amp
id|p-&gt;next
suffix:semicolon
)brace
r_return
id|commit_list_insert
c_func
(paren
id|item
comma
id|pp
)paren
suffix:semicolon
)brace
DECL|function|commit_list_compare_by_date
r_static
r_int
id|commit_list_compare_by_date
c_func
(paren
r_const
r_void
op_star
id|a
comma
r_const
r_void
op_star
id|b
)paren
(brace
r_int
r_int
id|a_date
op_assign
(paren
(paren
r_const
r_struct
id|commit_list
op_star
)paren
id|a
)paren
op_member_access_from_pointer
id|item-&gt;date
suffix:semicolon
r_int
r_int
id|b_date
op_assign
(paren
(paren
r_const
r_struct
id|commit_list
op_star
)paren
id|b
)paren
op_member_access_from_pointer
id|item-&gt;date
suffix:semicolon
r_if
c_cond
(paren
id|a_date
OL
id|b_date
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|a_date
OG
id|b_date
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|commit_list_get_next
r_static
r_void
op_star
id|commit_list_get_next
c_func
(paren
r_const
r_void
op_star
id|a
)paren
(brace
r_return
(paren
(paren
r_const
r_struct
id|commit_list
op_star
)paren
id|a
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
)brace
DECL|function|commit_list_set_next
r_static
r_void
id|commit_list_set_next
c_func
(paren
r_void
op_star
id|a
comma
r_void
op_star
id|next
)paren
(brace
(paren
(paren
r_struct
id|commit_list
op_star
)paren
id|a
)paren
op_member_access_from_pointer
id|next
op_assign
id|next
suffix:semicolon
)brace
DECL|function|commit_list_sort_by_date
r_void
id|commit_list_sort_by_date
c_func
(paren
r_struct
id|commit_list
op_star
op_star
id|list
)paren
(brace
op_star
id|list
op_assign
id|llist_mergesort
c_func
(paren
op_star
id|list
comma
id|commit_list_get_next
comma
id|commit_list_set_next
comma
id|commit_list_compare_by_date
)paren
suffix:semicolon
)brace
DECL|function|pop_most_recent_commit
r_struct
id|commit
op_star
id|pop_most_recent_commit
c_func
(paren
r_struct
id|commit_list
op_star
op_star
id|list
comma
r_int
r_int
id|mark
)paren
(brace
r_struct
id|commit
op_star
id|ret
op_assign
(paren
op_star
id|list
)paren
op_member_access_from_pointer
id|item
suffix:semicolon
r_struct
id|commit_list
op_star
id|parents
op_assign
id|ret-&gt;parents
suffix:semicolon
r_struct
id|commit_list
op_star
id|old
op_assign
op_star
id|list
suffix:semicolon
op_star
id|list
op_assign
(paren
op_star
id|list
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
id|free
c_func
(paren
id|old
)paren
suffix:semicolon
r_while
c_loop
(paren
id|parents
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
id|parents-&gt;item
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parse_commit
c_func
(paren
id|commit
)paren
op_logical_and
op_logical_neg
(paren
id|commit-&gt;object.flags
op_amp
id|mark
)paren
)paren
(brace
id|commit-&gt;object.flags
op_or_assign
id|mark
suffix:semicolon
id|commit_list_insert_by_date
c_func
(paren
id|commit
comma
id|list
)paren
suffix:semicolon
)brace
id|parents
op_assign
id|parents-&gt;next
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|clear_commit_marks_1
r_static
r_void
id|clear_commit_marks_1
c_func
(paren
r_struct
id|commit_list
op_star
op_star
id|plist
comma
r_struct
id|commit
op_star
id|commit
comma
r_int
r_int
id|mark
)paren
(brace
r_while
c_loop
(paren
id|commit
)paren
(brace
r_struct
id|commit_list
op_star
id|parents
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|mark
op_amp
id|commit-&gt;object.flags
)paren
)paren
r_return
suffix:semicolon
id|commit-&gt;object.flags
op_and_assign
op_complement
id|mark
suffix:semicolon
id|parents
op_assign
id|commit-&gt;parents
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parents
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
(paren
id|parents
op_assign
id|parents-&gt;next
)paren
)paren
id|commit_list_insert
c_func
(paren
id|parents-&gt;item
comma
id|plist
)paren
suffix:semicolon
id|commit
op_assign
id|commit-&gt;parents-&gt;item
suffix:semicolon
)brace
)brace
DECL|function|clear_commit_marks_many
r_void
id|clear_commit_marks_many
c_func
(paren
r_int
id|nr
comma
r_struct
id|commit
op_star
op_star
id|commit
comma
r_int
r_int
id|mark
)paren
(brace
r_struct
id|commit_list
op_star
id|list
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|nr
op_decrement
)paren
(brace
id|commit_list_insert
c_func
(paren
op_star
id|commit
comma
op_amp
id|list
)paren
suffix:semicolon
id|commit
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|list
)paren
id|clear_commit_marks_1
c_func
(paren
op_amp
id|list
comma
id|pop_commit
c_func
(paren
op_amp
id|list
)paren
comma
id|mark
)paren
suffix:semicolon
)brace
DECL|function|clear_commit_marks
r_void
id|clear_commit_marks
c_func
(paren
r_struct
id|commit
op_star
id|commit
comma
r_int
r_int
id|mark
)paren
(brace
id|clear_commit_marks_many
c_func
(paren
l_int|1
comma
op_amp
id|commit
comma
id|mark
)paren
suffix:semicolon
)brace
DECL|function|clear_commit_marks_for_object_array
r_void
id|clear_commit_marks_for_object_array
c_func
(paren
r_struct
id|object_array
op_star
id|a
comma
r_int
id|mark
)paren
(brace
r_struct
id|object
op_star
id|object
suffix:semicolon
r_struct
id|commit
op_star
id|commit
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|a-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
id|object
op_assign
id|a-&gt;objects
(braket
id|i
)braket
dot
id|item
suffix:semicolon
id|commit
op_assign
id|lookup_commit_reference_gently
c_func
(paren
id|object-&gt;sha1
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|commit
)paren
id|clear_commit_marks
c_func
(paren
id|commit
comma
id|mark
)paren
suffix:semicolon
)brace
)brace
DECL|function|pop_commit
r_struct
id|commit
op_star
id|pop_commit
c_func
(paren
r_struct
id|commit_list
op_star
op_star
id|stack
)paren
(brace
r_struct
id|commit_list
op_star
id|top
op_assign
op_star
id|stack
suffix:semicolon
r_struct
id|commit
op_star
id|item
op_assign
id|top
ques
c_cond
id|top-&gt;item
suffix:colon
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|top
)paren
(brace
op_star
id|stack
op_assign
id|top-&gt;next
suffix:semicolon
id|free
c_func
(paren
id|top
)paren
suffix:semicolon
)brace
r_return
id|item
suffix:semicolon
)brace
multiline_comment|/*&n; * Topological sort support&n; */
multiline_comment|/* count number of children that have not been emitted */
id|define_commit_slab
c_func
(paren
id|indegree_slab
comma
r_int
)paren
suffix:semicolon
multiline_comment|/* record author-date for each commit object */
id|define_commit_slab
c_func
(paren
id|author_date_slab
comma
r_int
r_int
)paren
suffix:semicolon
DECL|function|record_author_date
r_static
r_void
id|record_author_date
c_func
(paren
r_struct
id|author_date_slab
op_star
id|author_date
comma
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_const
r_char
op_star
id|buf
comma
op_star
id|line_end
comma
op_star
id|ident_line
suffix:semicolon
r_const
r_char
op_star
id|buffer
op_assign
id|get_commit_buffer
c_func
(paren
id|commit
comma
l_int|NULL
)paren
suffix:semicolon
r_struct
id|ident_split
id|ident
suffix:semicolon
r_char
op_star
id|date_end
suffix:semicolon
r_int
r_int
id|date
suffix:semicolon
r_for
c_loop
(paren
id|buf
op_assign
id|buffer
suffix:semicolon
id|buf
suffix:semicolon
id|buf
op_assign
id|line_end
op_plus
l_int|1
)paren
(brace
id|line_end
op_assign
id|strchrnul
c_func
(paren
id|buf
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|ident_line
op_assign
id|skip_prefix
c_func
(paren
id|buf
comma
l_string|&quot;author &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ident_line
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|line_end
(braket
l_int|0
)braket
op_logical_or
id|line_end
(braket
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
r_return
suffix:semicolon
multiline_comment|/* end of header */
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|split_ident_line
c_func
(paren
op_amp
id|ident
comma
id|ident_line
comma
id|line_end
id|ident_line
)paren
op_logical_or
op_logical_neg
id|ident.date_begin
op_logical_or
op_logical_neg
id|ident.date_end
)paren
r_goto
id|fail_exit
suffix:semicolon
multiline_comment|/* malformed &quot;author&quot; line */
r_break
suffix:semicolon
)brace
id|date
op_assign
id|strtoul
c_func
(paren
id|ident.date_begin
comma
op_amp
id|date_end
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|date_end
op_ne
id|ident.date_end
)paren
r_goto
id|fail_exit
suffix:semicolon
multiline_comment|/* malformed date */
op_star
(paren
id|author_date_slab_at
c_func
(paren
id|author_date
comma
id|commit
)paren
)paren
op_assign
id|date
suffix:semicolon
id|fail_exit
suffix:colon
id|unuse_commit_buffer
c_func
(paren
id|commit
comma
id|buffer
)paren
suffix:semicolon
)brace
DECL|function|compare_commits_by_author_date
r_static
r_int
id|compare_commits_by_author_date
c_func
(paren
r_const
r_void
op_star
id|a_
comma
r_const
r_void
op_star
id|b_
comma
r_void
op_star
id|cb_data
)paren
(brace
r_const
r_struct
id|commit
op_star
id|a
op_assign
id|a_
comma
op_star
id|b
op_assign
id|b_
suffix:semicolon
r_struct
id|author_date_slab
op_star
id|author_date
op_assign
id|cb_data
suffix:semicolon
r_int
r_int
id|a_date
op_assign
op_star
(paren
id|author_date_slab_at
c_func
(paren
id|author_date
comma
id|a
)paren
)paren
suffix:semicolon
r_int
r_int
id|b_date
op_assign
op_star
(paren
id|author_date_slab_at
c_func
(paren
id|author_date
comma
id|b
)paren
)paren
suffix:semicolon
multiline_comment|/* newer commits with larger date first */
r_if
c_cond
(paren
id|a_date
OL
id|b_date
)paren
r_return
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|a_date
OG
id|b_date
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|compare_commits_by_commit_date
r_int
id|compare_commits_by_commit_date
c_func
(paren
r_const
r_void
op_star
id|a_
comma
r_const
r_void
op_star
id|b_
comma
r_void
op_star
id|unused
)paren
(brace
r_const
r_struct
id|commit
op_star
id|a
op_assign
id|a_
comma
op_star
id|b
op_assign
id|b_
suffix:semicolon
multiline_comment|/* newer commits with larger date first */
r_if
c_cond
(paren
id|a-&gt;date
OL
id|b-&gt;date
)paren
r_return
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|a-&gt;date
OG
id|b-&gt;date
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Performs an in-place topological sort on the list supplied.&n; */
DECL|function|sort_in_topological_order
r_void
id|sort_in_topological_order
c_func
(paren
r_struct
id|commit_list
op_star
op_star
id|list
comma
r_enum
id|rev_sort_order
id|sort_order
)paren
(brace
r_struct
id|commit_list
op_star
id|next
comma
op_star
id|orig
op_assign
op_star
id|list
suffix:semicolon
r_struct
id|commit_list
op_star
op_star
id|pptr
suffix:semicolon
r_struct
id|indegree_slab
id|indegree
suffix:semicolon
r_struct
id|prio_queue
id|queue
suffix:semicolon
r_struct
id|commit
op_star
id|commit
suffix:semicolon
r_struct
id|author_date_slab
id|author_date
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|orig
)paren
r_return
suffix:semicolon
op_star
id|list
op_assign
l_int|NULL
suffix:semicolon
id|init_indegree_slab
c_func
(paren
op_amp
id|indegree
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|queue
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|queue
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|sort_order
)paren
(brace
r_default
suffix:colon
multiline_comment|/* REV_SORT_IN_GRAPH_ORDER */
id|queue.compare
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|REV_SORT_BY_COMMIT_DATE
suffix:colon
id|queue.compare
op_assign
id|compare_commits_by_commit_date
suffix:semicolon
r_break
suffix:semicolon
r_case
id|REV_SORT_BY_AUTHOR_DATE
suffix:colon
id|init_author_date_slab
c_func
(paren
op_amp
id|author_date
)paren
suffix:semicolon
id|queue.compare
op_assign
id|compare_commits_by_author_date
suffix:semicolon
id|queue.cb_data
op_assign
op_amp
id|author_date
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Mark them and clear the indegree */
r_for
c_loop
(paren
id|next
op_assign
id|orig
suffix:semicolon
id|next
suffix:semicolon
id|next
op_assign
id|next-&gt;next
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
id|next-&gt;item
suffix:semicolon
op_star
(paren
id|indegree_slab_at
c_func
(paren
op_amp
id|indegree
comma
id|commit
)paren
)paren
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* also record the author dates, if needed */
r_if
c_cond
(paren
id|sort_order
op_eq
id|REV_SORT_BY_AUTHOR_DATE
)paren
id|record_author_date
c_func
(paren
op_amp
id|author_date
comma
id|commit
)paren
suffix:semicolon
)brace
multiline_comment|/* update the indegree */
r_for
c_loop
(paren
id|next
op_assign
id|orig
suffix:semicolon
id|next
suffix:semicolon
id|next
op_assign
id|next-&gt;next
)paren
(brace
r_struct
id|commit_list
op_star
id|parents
op_assign
id|next-&gt;item-&gt;parents
suffix:semicolon
r_while
c_loop
(paren
id|parents
)paren
(brace
r_struct
id|commit
op_star
id|parent
op_assign
id|parents-&gt;item
suffix:semicolon
r_int
op_star
id|pi
op_assign
id|indegree_slab_at
c_func
(paren
op_amp
id|indegree
comma
id|parent
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pi
)paren
(paren
op_star
id|pi
)paren
op_increment
suffix:semicolon
id|parents
op_assign
id|parents-&gt;next
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * find the tips&n;&t; *&n;&t; * tips are nodes not reachable from any other node in the list&n;&t; *&n;&t; * the tips serve as a starting set for the work queue.&n;&t; */
r_for
c_loop
(paren
id|next
op_assign
id|orig
suffix:semicolon
id|next
suffix:semicolon
id|next
op_assign
id|next-&gt;next
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
id|next-&gt;item
suffix:semicolon
r_if
c_cond
(paren
op_star
(paren
id|indegree_slab_at
c_func
(paren
op_amp
id|indegree
comma
id|commit
)paren
)paren
op_eq
l_int|1
)paren
id|prio_queue_put
c_func
(paren
op_amp
id|queue
comma
id|commit
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * This is unfortunate; the initial tips need to be shown&n;&t; * in the order given from the revision traversal machinery.&n;&t; */
r_if
c_cond
(paren
id|sort_order
op_eq
id|REV_SORT_IN_GRAPH_ORDER
)paren
id|prio_queue_reverse
c_func
(paren
op_amp
id|queue
)paren
suffix:semicolon
multiline_comment|/* We no longer need the commit list */
id|free_commit_list
c_func
(paren
id|orig
)paren
suffix:semicolon
id|pptr
op_assign
id|list
suffix:semicolon
op_star
id|list
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
(paren
id|commit
op_assign
id|prio_queue_get
c_func
(paren
op_amp
id|queue
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_struct
id|commit_list
op_star
id|parents
suffix:semicolon
r_for
c_loop
(paren
id|parents
op_assign
id|commit-&gt;parents
suffix:semicolon
id|parents
suffix:semicolon
id|parents
op_assign
id|parents-&gt;next
)paren
(brace
r_struct
id|commit
op_star
id|parent
op_assign
id|parents-&gt;item
suffix:semicolon
r_int
op_star
id|pi
op_assign
id|indegree_slab_at
c_func
(paren
op_amp
id|indegree
comma
id|parent
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|pi
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * parents are only enqueued for emission&n;&t;&t;&t; * when all their children have been emitted thereby&n;&t;&t;&t; * guaranteeing topological order.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_decrement
(paren
op_star
id|pi
)paren
op_eq
l_int|1
)paren
id|prio_queue_put
c_func
(paren
op_amp
id|queue
comma
id|parent
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * all children of commit have already been&n;&t;&t; * emitted. we can emit it now.&n;&t;&t; */
op_star
(paren
id|indegree_slab_at
c_func
(paren
op_amp
id|indegree
comma
id|commit
)paren
)paren
op_assign
l_int|0
suffix:semicolon
id|pptr
op_assign
op_amp
id|commit_list_insert
c_func
(paren
id|commit
comma
id|pptr
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
)brace
id|clear_indegree_slab
c_func
(paren
op_amp
id|indegree
)paren
suffix:semicolon
id|clear_prio_queue
c_func
(paren
op_amp
id|queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sort_order
op_eq
id|REV_SORT_BY_AUTHOR_DATE
)paren
id|clear_author_date_slab
c_func
(paren
op_amp
id|author_date
)paren
suffix:semicolon
)brace
multiline_comment|/* merge-base stuff */
multiline_comment|/* Remember to update object flag allocation in object.h */
DECL|macro|PARENT1
mdefine_line|#define PARENT1&t;&t;(1u&lt;&lt;16)
DECL|macro|PARENT2
mdefine_line|#define PARENT2&t;&t;(1u&lt;&lt;17)
DECL|macro|STALE
mdefine_line|#define STALE&t;&t;(1u&lt;&lt;18)
DECL|macro|RESULT
mdefine_line|#define RESULT&t;&t;(1u&lt;&lt;19)
DECL|variable|all_flags
r_static
r_const
r_int
id|all_flags
op_assign
(paren
id|PARENT1
op_or
id|PARENT2
op_or
id|STALE
op_or
id|RESULT
)paren
suffix:semicolon
DECL|function|interesting
r_static
r_struct
id|commit
op_star
id|interesting
c_func
(paren
r_struct
id|commit_list
op_star
id|list
)paren
(brace
r_while
c_loop
(paren
id|list
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
id|list-&gt;item
suffix:semicolon
id|list
op_assign
id|list-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|commit-&gt;object.flags
op_amp
id|STALE
)paren
r_continue
suffix:semicolon
r_return
id|commit
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* all input commits in one and twos[] must have been parsed! */
DECL|function|paint_down_to_common
r_static
r_struct
id|commit_list
op_star
id|paint_down_to_common
c_func
(paren
r_struct
id|commit
op_star
id|one
comma
r_int
id|n
comma
r_struct
id|commit
op_star
op_star
id|twos
)paren
(brace
r_struct
id|commit_list
op_star
id|list
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|commit_list
op_star
id|result
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
suffix:semicolon
id|one-&gt;object.flags
op_or_assign
id|PARENT1
suffix:semicolon
id|commit_list_insert_by_date
c_func
(paren
id|one
comma
op_amp
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n
)paren
r_return
id|list
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
(brace
id|twos
(braket
id|i
)braket
op_member_access_from_pointer
id|object.flags
op_or_assign
id|PARENT2
suffix:semicolon
id|commit_list_insert_by_date
c_func
(paren
id|twos
(braket
id|i
)braket
comma
op_amp
id|list
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|interesting
c_func
(paren
id|list
)paren
)paren
(brace
r_struct
id|commit
op_star
id|commit
suffix:semicolon
r_struct
id|commit_list
op_star
id|parents
suffix:semicolon
r_struct
id|commit_list
op_star
id|next
suffix:semicolon
r_int
id|flags
suffix:semicolon
id|commit
op_assign
id|list-&gt;item
suffix:semicolon
id|next
op_assign
id|list-&gt;next
suffix:semicolon
id|free
c_func
(paren
id|list
)paren
suffix:semicolon
id|list
op_assign
id|next
suffix:semicolon
id|flags
op_assign
id|commit-&gt;object.flags
op_amp
(paren
id|PARENT1
op_or
id|PARENT2
op_or
id|STALE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_eq
(paren
id|PARENT1
op_or
id|PARENT2
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|commit-&gt;object.flags
op_amp
id|RESULT
)paren
)paren
(brace
id|commit-&gt;object.flags
op_or_assign
id|RESULT
suffix:semicolon
id|commit_list_insert_by_date
c_func
(paren
id|commit
comma
op_amp
id|result
)paren
suffix:semicolon
)brace
multiline_comment|/* Mark parents of a found merge stale */
id|flags
op_or_assign
id|STALE
suffix:semicolon
)brace
id|parents
op_assign
id|commit-&gt;parents
suffix:semicolon
r_while
c_loop
(paren
id|parents
)paren
(brace
r_struct
id|commit
op_star
id|p
op_assign
id|parents-&gt;item
suffix:semicolon
id|parents
op_assign
id|parents-&gt;next
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;object.flags
op_amp
id|flags
)paren
op_eq
id|flags
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|parse_commit
c_func
(paren
id|p
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|p-&gt;object.flags
op_or_assign
id|flags
suffix:semicolon
id|commit_list_insert_by_date
c_func
(paren
id|p
comma
op_amp
id|list
)paren
suffix:semicolon
)brace
)brace
id|free_commit_list
c_func
(paren
id|list
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|merge_bases_many
r_static
r_struct
id|commit_list
op_star
id|merge_bases_many
c_func
(paren
r_struct
id|commit
op_star
id|one
comma
r_int
id|n
comma
r_struct
id|commit
op_star
op_star
id|twos
)paren
(brace
r_struct
id|commit_list
op_star
id|list
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|commit_list
op_star
id|result
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|one
op_eq
id|twos
(braket
id|i
)braket
)paren
multiline_comment|/*&n;&t;&t;&t; * We do not mark this even with RESULT so we do not&n;&t;&t;&t; * have to clean it up.&n;&t;&t;&t; */
r_return
id|commit_list_insert
c_func
(paren
id|one
comma
op_amp
id|result
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|parse_commit
c_func
(paren
id|one
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|parse_commit
c_func
(paren
id|twos
(braket
id|i
)braket
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
id|list
op_assign
id|paint_down_to_common
c_func
(paren
id|one
comma
id|n
comma
id|twos
)paren
suffix:semicolon
r_while
c_loop
(paren
id|list
)paren
(brace
r_struct
id|commit_list
op_star
id|next
op_assign
id|list-&gt;next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|list-&gt;item-&gt;object.flags
op_amp
id|STALE
)paren
)paren
id|commit_list_insert_by_date
c_func
(paren
id|list-&gt;item
comma
op_amp
id|result
)paren
suffix:semicolon
id|free
c_func
(paren
id|list
)paren
suffix:semicolon
id|list
op_assign
id|next
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
DECL|function|get_octopus_merge_bases
r_struct
id|commit_list
op_star
id|get_octopus_merge_bases
c_func
(paren
r_struct
id|commit_list
op_star
id|in
)paren
(brace
r_struct
id|commit_list
op_star
id|i
comma
op_star
id|j
comma
op_star
id|k
comma
op_star
id|ret
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|in
)paren
r_return
id|ret
suffix:semicolon
id|commit_list_insert
c_func
(paren
id|in-&gt;item
comma
op_amp
id|ret
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|in-&gt;next
suffix:semicolon
id|i
suffix:semicolon
id|i
op_assign
id|i-&gt;next
)paren
(brace
r_struct
id|commit_list
op_star
r_new
op_assign
l_int|NULL
comma
op_star
id|end
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|ret
suffix:semicolon
id|j
suffix:semicolon
id|j
op_assign
id|j-&gt;next
)paren
(brace
r_struct
id|commit_list
op_star
id|bases
suffix:semicolon
id|bases
op_assign
id|get_merge_bases
c_func
(paren
id|i-&gt;item
comma
id|j-&gt;item
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
)paren
r_new
op_assign
id|bases
suffix:semicolon
r_else
id|end-&gt;next
op_assign
id|bases
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
id|bases
suffix:semicolon
id|k
suffix:semicolon
id|k
op_assign
id|k-&gt;next
)paren
id|end
op_assign
id|k
suffix:semicolon
)brace
id|ret
op_assign
r_new
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|remove_redundant
r_static
r_int
id|remove_redundant
c_func
(paren
r_struct
id|commit
op_star
op_star
id|array
comma
r_int
id|cnt
)paren
(brace
multiline_comment|/*&n;&t; * Some commit in the array may be an ancestor of&n;&t; * another commit.  Move such commit to the end of&n;&t; * the array, and return the number of commits that&n;&t; * are independent from each other.&n;&t; */
r_struct
id|commit
op_star
op_star
id|work
suffix:semicolon
r_int
r_char
op_star
id|redundant
suffix:semicolon
r_int
op_star
id|filled_index
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|filled
suffix:semicolon
id|work
op_assign
id|xcalloc
c_func
(paren
id|cnt
comma
r_sizeof
(paren
op_star
id|work
)paren
)paren
suffix:semicolon
id|redundant
op_assign
id|xcalloc
c_func
(paren
id|cnt
comma
l_int|1
)paren
suffix:semicolon
id|filled_index
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|filled_index
)paren
op_star
(paren
id|cnt
l_int|1
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cnt
suffix:semicolon
id|i
op_increment
)paren
id|parse_commit
c_func
(paren
id|array
(braket
id|i
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|commit_list
op_star
id|common
suffix:semicolon
r_if
c_cond
(paren
id|redundant
(braket
id|i
)braket
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|filled
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|cnt
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
id|j
op_logical_or
id|redundant
(braket
id|j
)braket
)paren
r_continue
suffix:semicolon
id|filled_index
(braket
id|filled
)braket
op_assign
id|j
suffix:semicolon
id|work
(braket
id|filled
op_increment
)braket
op_assign
id|array
(braket
id|j
)braket
suffix:semicolon
)brace
id|common
op_assign
id|paint_down_to_common
c_func
(paren
id|array
(braket
id|i
)braket
comma
id|filled
comma
id|work
)paren
suffix:semicolon
r_if
c_cond
(paren
id|array
(braket
id|i
)braket
op_member_access_from_pointer
id|object.flags
op_amp
id|PARENT2
)paren
id|redundant
(braket
id|i
)braket
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|filled
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
id|work
(braket
id|j
)braket
op_member_access_from_pointer
id|object.flags
op_amp
id|PARENT1
)paren
id|redundant
(braket
id|filled_index
(braket
id|j
)braket
)braket
op_assign
l_int|1
suffix:semicolon
id|clear_commit_marks
c_func
(paren
id|array
(braket
id|i
)braket
comma
id|all_flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|filled
suffix:semicolon
id|j
op_increment
)paren
id|clear_commit_marks
c_func
(paren
id|work
(braket
id|j
)braket
comma
id|all_flags
)paren
suffix:semicolon
id|free_commit_list
c_func
(paren
id|common
)paren
suffix:semicolon
)brace
multiline_comment|/* Now collect the result */
id|memcpy
c_func
(paren
id|work
comma
id|array
comma
r_sizeof
(paren
op_star
id|array
)paren
op_star
id|cnt
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|filled
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cnt
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|redundant
(braket
id|i
)braket
)paren
id|array
(braket
id|filled
op_increment
)braket
op_assign
id|work
(braket
id|i
)braket
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|filled
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cnt
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|redundant
(braket
id|i
)braket
)paren
id|array
(braket
id|j
op_increment
)braket
op_assign
id|work
(braket
id|i
)braket
suffix:semicolon
id|free
c_func
(paren
id|work
)paren
suffix:semicolon
id|free
c_func
(paren
id|redundant
)paren
suffix:semicolon
id|free
c_func
(paren
id|filled_index
)paren
suffix:semicolon
r_return
id|filled
suffix:semicolon
)brace
DECL|function|get_merge_bases_many_0
r_static
r_struct
id|commit_list
op_star
id|get_merge_bases_many_0
c_func
(paren
r_struct
id|commit
op_star
id|one
comma
r_int
id|n
comma
r_struct
id|commit
op_star
op_star
id|twos
comma
r_int
id|cleanup
)paren
(brace
r_struct
id|commit_list
op_star
id|list
suffix:semicolon
r_struct
id|commit
op_star
op_star
id|rslt
suffix:semicolon
r_struct
id|commit_list
op_star
id|result
suffix:semicolon
r_int
id|cnt
comma
id|i
suffix:semicolon
id|result
op_assign
id|merge_bases_many
c_func
(paren
id|one
comma
id|n
comma
id|twos
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|one
op_eq
id|twos
(braket
id|i
)braket
)paren
r_return
id|result
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|result
op_logical_or
op_logical_neg
id|result-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|cleanup
)paren
(brace
id|clear_commit_marks
c_func
(paren
id|one
comma
id|all_flags
)paren
suffix:semicolon
id|clear_commit_marks_many
c_func
(paren
id|n
comma
id|twos
comma
id|all_flags
)paren
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/* There are more than one */
id|cnt
op_assign
l_int|0
suffix:semicolon
id|list
op_assign
id|result
suffix:semicolon
r_while
c_loop
(paren
id|list
)paren
(brace
id|list
op_assign
id|list-&gt;next
suffix:semicolon
id|cnt
op_increment
suffix:semicolon
)brace
id|rslt
op_assign
id|xcalloc
c_func
(paren
id|cnt
comma
r_sizeof
(paren
op_star
id|rslt
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|list
op_assign
id|result
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|list
suffix:semicolon
id|list
op_assign
id|list-&gt;next
)paren
id|rslt
(braket
id|i
op_increment
)braket
op_assign
id|list-&gt;item
suffix:semicolon
id|free_commit_list
c_func
(paren
id|result
)paren
suffix:semicolon
id|clear_commit_marks
c_func
(paren
id|one
comma
id|all_flags
)paren
suffix:semicolon
id|clear_commit_marks_many
c_func
(paren
id|n
comma
id|twos
comma
id|all_flags
)paren
suffix:semicolon
id|cnt
op_assign
id|remove_redundant
c_func
(paren
id|rslt
comma
id|cnt
)paren
suffix:semicolon
id|result
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cnt
suffix:semicolon
id|i
op_increment
)paren
id|commit_list_insert_by_date
c_func
(paren
id|rslt
(braket
id|i
)braket
comma
op_amp
id|result
)paren
suffix:semicolon
id|free
c_func
(paren
id|rslt
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|get_merge_bases_many
r_struct
id|commit_list
op_star
id|get_merge_bases_many
c_func
(paren
r_struct
id|commit
op_star
id|one
comma
r_int
id|n
comma
r_struct
id|commit
op_star
op_star
id|twos
)paren
(brace
r_return
id|get_merge_bases_many_0
c_func
(paren
id|one
comma
id|n
comma
id|twos
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|get_merge_bases_many_dirty
r_struct
id|commit_list
op_star
id|get_merge_bases_many_dirty
c_func
(paren
r_struct
id|commit
op_star
id|one
comma
r_int
id|n
comma
r_struct
id|commit
op_star
op_star
id|twos
)paren
(brace
r_return
id|get_merge_bases_many_0
c_func
(paren
id|one
comma
id|n
comma
id|twos
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|get_merge_bases
r_struct
id|commit_list
op_star
id|get_merge_bases
c_func
(paren
r_struct
id|commit
op_star
id|one
comma
r_struct
id|commit
op_star
id|two
)paren
(brace
r_return
id|get_merge_bases_many_0
c_func
(paren
id|one
comma
l_int|1
comma
op_amp
id|two
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Is &quot;commit&quot; a descendant of one of the elements on the &quot;with_commit&quot; list?&n; */
DECL|function|is_descendant_of
r_int
id|is_descendant_of
c_func
(paren
r_struct
id|commit
op_star
id|commit
comma
r_struct
id|commit_list
op_star
id|with_commit
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|with_commit
)paren
r_return
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|with_commit
)paren
(brace
r_struct
id|commit
op_star
id|other
suffix:semicolon
id|other
op_assign
id|with_commit-&gt;item
suffix:semicolon
id|with_commit
op_assign
id|with_commit-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|in_merge_bases
c_func
(paren
id|other
comma
id|commit
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Is &quot;commit&quot; an ancestor of one of the &quot;references&quot;?&n; */
DECL|function|in_merge_bases_many
r_int
id|in_merge_bases_many
c_func
(paren
r_struct
id|commit
op_star
id|commit
comma
r_int
id|nr_reference
comma
r_struct
id|commit
op_star
op_star
id|reference
)paren
(brace
r_struct
id|commit_list
op_star
id|bases
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
comma
id|i
suffix:semicolon
r_if
c_cond
(paren
id|parse_commit
c_func
(paren
id|commit
)paren
)paren
r_return
id|ret
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_reference
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|parse_commit
c_func
(paren
id|reference
(braket
id|i
)braket
)paren
)paren
r_return
id|ret
suffix:semicolon
id|bases
op_assign
id|paint_down_to_common
c_func
(paren
id|commit
comma
id|nr_reference
comma
id|reference
)paren
suffix:semicolon
r_if
c_cond
(paren
id|commit-&gt;object.flags
op_amp
id|PARENT2
)paren
id|ret
op_assign
l_int|1
suffix:semicolon
id|clear_commit_marks
c_func
(paren
id|commit
comma
id|all_flags
)paren
suffix:semicolon
id|clear_commit_marks_many
c_func
(paren
id|nr_reference
comma
id|reference
comma
id|all_flags
)paren
suffix:semicolon
id|free_commit_list
c_func
(paren
id|bases
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Is &quot;commit&quot; an ancestor of (i.e. reachable from) the &quot;reference&quot;?&n; */
DECL|function|in_merge_bases
r_int
id|in_merge_bases
c_func
(paren
r_struct
id|commit
op_star
id|commit
comma
r_struct
id|commit
op_star
id|reference
)paren
(brace
r_return
id|in_merge_bases_many
c_func
(paren
id|commit
comma
l_int|1
comma
op_amp
id|reference
)paren
suffix:semicolon
)brace
DECL|function|reduce_heads
r_struct
id|commit_list
op_star
id|reduce_heads
c_func
(paren
r_struct
id|commit_list
op_star
id|heads
)paren
(brace
r_struct
id|commit_list
op_star
id|p
suffix:semicolon
r_struct
id|commit_list
op_star
id|result
op_assign
l_int|NULL
comma
op_star
op_star
id|tail
op_assign
op_amp
id|result
suffix:semicolon
r_struct
id|commit
op_star
op_star
id|array
suffix:semicolon
r_int
id|num_head
comma
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|heads
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* Uniquify */
r_for
c_loop
(paren
id|p
op_assign
id|heads
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
id|p-&gt;item-&gt;object.flags
op_and_assign
op_complement
id|STALE
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|heads
comma
id|num_head
op_assign
l_int|0
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;item-&gt;object.flags
op_amp
id|STALE
)paren
r_continue
suffix:semicolon
id|p-&gt;item-&gt;object.flags
op_or_assign
id|STALE
suffix:semicolon
id|num_head
op_increment
suffix:semicolon
)brace
id|array
op_assign
id|xcalloc
c_func
(paren
id|num_head
comma
r_sizeof
(paren
op_star
id|array
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|heads
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;item-&gt;object.flags
op_amp
id|STALE
)paren
(brace
id|array
(braket
id|i
op_increment
)braket
op_assign
id|p-&gt;item
suffix:semicolon
id|p-&gt;item-&gt;object.flags
op_and_assign
op_complement
id|STALE
suffix:semicolon
)brace
)brace
id|num_head
op_assign
id|remove_redundant
c_func
(paren
id|array
comma
id|num_head
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_head
suffix:semicolon
id|i
op_increment
)paren
id|tail
op_assign
op_amp
id|commit_list_insert
c_func
(paren
id|array
(braket
id|i
)braket
comma
id|tail
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|variable|gpg_sig_header
r_static
r_const
r_char
id|gpg_sig_header
(braket
)braket
op_assign
l_string|&quot;gpgsig&quot;
suffix:semicolon
DECL|variable|gpg_sig_header_len
r_static
r_const
r_int
id|gpg_sig_header_len
op_assign
r_sizeof
(paren
id|gpg_sig_header
)paren
l_int|1
suffix:semicolon
DECL|function|do_sign_commit
r_static
r_int
id|do_sign_commit
c_func
(paren
r_struct
id|strbuf
op_star
id|buf
comma
r_const
r_char
op_star
id|keyid
)paren
(brace
r_struct
id|strbuf
id|sig
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|inspos
comma
id|copypos
suffix:semicolon
multiline_comment|/* find the end of the header */
id|inspos
op_assign
id|strstr
c_func
(paren
id|buf-&gt;buf
comma
l_string|&quot;&bslash;n&bslash;n&quot;
)paren
id|buf-&gt;buf
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|keyid
op_logical_or
op_logical_neg
op_star
id|keyid
)paren
id|keyid
op_assign
id|get_signing_key
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sign_buffer
c_func
(paren
id|buf
comma
op_amp
id|sig
comma
id|keyid
)paren
)paren
(brace
id|strbuf_release
c_func
(paren
op_amp
id|sig
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|copypos
op_assign
l_int|0
suffix:semicolon
id|sig.buf
(braket
id|copypos
)braket
suffix:semicolon
)paren
(brace
r_const
r_char
op_star
id|bol
op_assign
id|sig.buf
op_plus
id|copypos
suffix:semicolon
r_const
r_char
op_star
id|eol
op_assign
id|strchrnul
c_func
(paren
id|bol
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_int
id|len
op_assign
(paren
id|eol
id|bol
)paren
op_plus
op_logical_neg
op_logical_neg
op_star
id|eol
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|copypos
)paren
(brace
id|strbuf_insert
c_func
(paren
id|buf
comma
id|inspos
comma
id|gpg_sig_header
comma
id|gpg_sig_header_len
)paren
suffix:semicolon
id|inspos
op_add_assign
id|gpg_sig_header_len
suffix:semicolon
)brace
id|strbuf_insert
c_func
(paren
id|buf
comma
id|inspos
op_increment
comma
l_string|&quot; &quot;
comma
l_int|1
)paren
suffix:semicolon
id|strbuf_insert
c_func
(paren
id|buf
comma
id|inspos
comma
id|bol
comma
id|len
)paren
suffix:semicolon
id|inspos
op_add_assign
id|len
suffix:semicolon
id|copypos
op_add_assign
id|len
suffix:semicolon
)brace
id|strbuf_release
c_func
(paren
op_amp
id|sig
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|parse_signed_commit
r_int
id|parse_signed_commit
c_func
(paren
r_const
r_struct
id|commit
op_star
id|commit
comma
r_struct
id|strbuf
op_star
id|payload
comma
r_struct
id|strbuf
op_star
id|signature
)paren
(brace
r_int
r_int
id|size
suffix:semicolon
r_const
r_char
op_star
id|buffer
op_assign
id|get_commit_buffer
c_func
(paren
id|commit
comma
op_amp
id|size
)paren
suffix:semicolon
r_int
id|in_signature
comma
id|saw_signature
op_assign
l_int|1
suffix:semicolon
r_const
r_char
op_star
id|line
comma
op_star
id|tail
suffix:semicolon
id|line
op_assign
id|buffer
suffix:semicolon
id|tail
op_assign
id|buffer
op_plus
id|size
suffix:semicolon
id|in_signature
op_assign
l_int|0
suffix:semicolon
id|saw_signature
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|line
OL
id|tail
)paren
(brace
r_const
r_char
op_star
id|sig
op_assign
l_int|NULL
suffix:semicolon
r_const
r_char
op_star
id|next
op_assign
id|memchr
c_func
(paren
id|line
comma
l_char|&squot;&bslash;n&squot;
comma
id|tail
id|line
)paren
suffix:semicolon
id|next
op_assign
id|next
ques
c_cond
id|next
op_plus
l_int|1
suffix:colon
id|tail
suffix:semicolon
r_if
c_cond
(paren
id|in_signature
op_logical_and
id|line
(braket
l_int|0
)braket
op_eq
l_char|&squot; &squot;
)paren
id|sig
op_assign
id|line
op_plus
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|line
comma
id|gpg_sig_header
)paren
op_logical_and
id|line
(braket
id|gpg_sig_header_len
)braket
op_eq
l_char|&squot; &squot;
)paren
id|sig
op_assign
id|line
op_plus
id|gpg_sig_header_len
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sig
)paren
(brace
id|strbuf_add
c_func
(paren
id|signature
comma
id|sig
comma
id|next
id|sig
)paren
suffix:semicolon
id|saw_signature
op_assign
l_int|1
suffix:semicolon
id|in_signature
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_star
id|line
op_eq
l_char|&squot;&bslash;n&squot;
)paren
multiline_comment|/* dump the whole remainder of the buffer */
id|next
op_assign
id|tail
suffix:semicolon
id|strbuf_add
c_func
(paren
id|payload
comma
id|line
comma
id|next
id|line
)paren
suffix:semicolon
id|in_signature
op_assign
l_int|0
suffix:semicolon
)brace
id|line
op_assign
id|next
suffix:semicolon
)brace
id|unuse_commit_buffer
c_func
(paren
id|commit
comma
id|buffer
)paren
suffix:semicolon
r_return
id|saw_signature
suffix:semicolon
)brace
DECL|function|handle_signed_tag
r_static
r_void
id|handle_signed_tag
c_func
(paren
r_struct
id|commit
op_star
id|parent
comma
r_struct
id|commit_extra_header
op_star
op_star
op_star
id|tail
)paren
(brace
r_struct
id|merge_remote_desc
op_star
id|desc
suffix:semicolon
r_struct
id|commit_extra_header
op_star
id|mergetag
suffix:semicolon
r_char
op_star
id|buf
suffix:semicolon
r_int
r_int
id|size
comma
id|len
suffix:semicolon
r_enum
id|object_type
id|type
suffix:semicolon
id|desc
op_assign
id|merge_remote_util
c_func
(paren
id|parent
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|desc
op_logical_or
op_logical_neg
id|desc-&gt;obj
)paren
r_return
suffix:semicolon
id|buf
op_assign
id|read_sha1_file
c_func
(paren
id|desc-&gt;obj-&gt;sha1
comma
op_amp
id|type
comma
op_amp
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
op_logical_or
id|type
op_ne
id|OBJ_TAG
)paren
r_goto
id|free_return
suffix:semicolon
id|len
op_assign
id|parse_signature
c_func
(paren
id|buf
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
id|len
)paren
r_goto
id|free_return
suffix:semicolon
multiline_comment|/*&n;&t; * We could verify this signature and either omit the tag when&n;&t; * it does not validate, but the integrator may not have the&n;&t; * public key of the signer of the tag he is merging, while a&n;&t; * later auditor may have it while auditing, so let&squot;s not run&n;&t; * verify-signed-buffer here for now...&n;&t; *&n;&t; * if (verify_signed_buffer(buf, len, buf + len, size - len, ...))&n;&t; *&t;warn(&quot;warning: signed tag unverified.&quot;);&n;&t; */
id|mergetag
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|mergetag
)paren
)paren
suffix:semicolon
id|mergetag-&gt;key
op_assign
id|xstrdup
c_func
(paren
l_string|&quot;mergetag&quot;
)paren
suffix:semicolon
id|mergetag-&gt;value
op_assign
id|buf
suffix:semicolon
id|mergetag-&gt;len
op_assign
id|size
suffix:semicolon
op_star
op_star
id|tail
op_assign
id|mergetag
suffix:semicolon
op_star
id|tail
op_assign
op_amp
id|mergetag-&gt;next
suffix:semicolon
r_return
suffix:semicolon
id|free_return
suffix:colon
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
r_static
r_struct
(brace
DECL|member|result
r_char
id|result
suffix:semicolon
DECL|member|check
r_const
r_char
op_star
id|check
suffix:semicolon
DECL|variable|sigcheck_gpg_status
)brace
id|sigcheck_gpg_status
(braket
)braket
op_assign
(brace
(brace
l_char|&squot;G&squot;
comma
l_string|&quot;&bslash;n[GNUPG:] GOODSIG &quot;
)brace
comma
(brace
l_char|&squot;B&squot;
comma
l_string|&quot;&bslash;n[GNUPG:] BADSIG &quot;
)brace
comma
(brace
l_char|&squot;U&squot;
comma
l_string|&quot;&bslash;n[GNUPG:] TRUST_NEVER&quot;
)brace
comma
(brace
l_char|&squot;U&squot;
comma
l_string|&quot;&bslash;n[GNUPG:] TRUST_UNDEFINED&quot;
)brace
comma
)brace
suffix:semicolon
DECL|function|parse_gpg_output
r_static
r_void
id|parse_gpg_output
c_func
(paren
r_struct
id|signature_check
op_star
id|sigc
)paren
(brace
r_const
r_char
op_star
id|buf
op_assign
id|sigc-&gt;gpg_status
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Iterate over all search strings */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|sigcheck_gpg_status
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_char
op_star
id|found
comma
op_star
id|next
suffix:semicolon
id|found
op_assign
id|skip_prefix
c_func
(paren
id|buf
comma
id|sigcheck_gpg_status
(braket
id|i
)braket
dot
id|check
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
(brace
id|found
op_assign
id|strstr
c_func
(paren
id|buf
comma
id|sigcheck_gpg_status
(braket
id|i
)braket
dot
id|check
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
r_continue
suffix:semicolon
id|found
op_add_assign
id|strlen
c_func
(paren
id|sigcheck_gpg_status
(braket
id|i
)braket
dot
id|check
)paren
suffix:semicolon
)brace
id|sigc-&gt;result
op_assign
id|sigcheck_gpg_status
(braket
id|i
)braket
dot
id|result
suffix:semicolon
multiline_comment|/* The trust messages are not followed by key/signer information */
r_if
c_cond
(paren
id|sigc-&gt;result
op_ne
l_char|&squot;U&squot;
)paren
(brace
id|sigc-&gt;key
op_assign
id|xmemdupz
c_func
(paren
id|found
comma
l_int|16
)paren
suffix:semicolon
id|found
op_add_assign
l_int|17
suffix:semicolon
id|next
op_assign
id|strchrnul
c_func
(paren
id|found
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|sigc-&gt;signer
op_assign
id|xmemdupz
c_func
(paren
id|found
comma
id|next
id|found
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|check_commit_signature
r_void
id|check_commit_signature
c_func
(paren
r_const
r_struct
id|commit
op_star
id|commit
comma
r_struct
id|signature_check
op_star
id|sigc
)paren
(brace
r_struct
id|strbuf
id|payload
op_assign
id|STRBUF_INIT
suffix:semicolon
r_struct
id|strbuf
id|signature
op_assign
id|STRBUF_INIT
suffix:semicolon
r_struct
id|strbuf
id|gpg_output
op_assign
id|STRBUF_INIT
suffix:semicolon
r_struct
id|strbuf
id|gpg_status
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|status
suffix:semicolon
id|sigc-&gt;result
op_assign
l_char|&squot;N&squot;
suffix:semicolon
r_if
c_cond
(paren
id|parse_signed_commit
c_func
(paren
id|commit
comma
op_amp
id|payload
comma
op_amp
id|signature
)paren
op_le
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|status
op_assign
id|verify_signed_buffer
c_func
(paren
id|payload.buf
comma
id|payload.len
comma
id|signature.buf
comma
id|signature.len
comma
op_amp
id|gpg_output
comma
op_amp
id|gpg_status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_logical_and
op_logical_neg
id|gpg_output.len
)paren
r_goto
id|out
suffix:semicolon
id|sigc-&gt;gpg_output
op_assign
id|strbuf_detach
c_func
(paren
op_amp
id|gpg_output
comma
l_int|NULL
)paren
suffix:semicolon
id|sigc-&gt;gpg_status
op_assign
id|strbuf_detach
c_func
(paren
op_amp
id|gpg_status
comma
l_int|NULL
)paren
suffix:semicolon
id|parse_gpg_output
c_func
(paren
id|sigc
)paren
suffix:semicolon
id|out
suffix:colon
id|strbuf_release
c_func
(paren
op_amp
id|gpg_status
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|gpg_output
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|payload
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|signature
)paren
suffix:semicolon
)brace
DECL|function|append_merge_tag_headers
r_void
id|append_merge_tag_headers
c_func
(paren
r_struct
id|commit_list
op_star
id|parents
comma
r_struct
id|commit_extra_header
op_star
op_star
op_star
id|tail
)paren
(brace
r_while
c_loop
(paren
id|parents
)paren
(brace
r_struct
id|commit
op_star
id|parent
op_assign
id|parents-&gt;item
suffix:semicolon
id|handle_signed_tag
c_func
(paren
id|parent
comma
id|tail
)paren
suffix:semicolon
id|parents
op_assign
id|parents-&gt;next
suffix:semicolon
)brace
)brace
DECL|function|add_extra_header
r_static
r_void
id|add_extra_header
c_func
(paren
r_struct
id|strbuf
op_star
id|buffer
comma
r_struct
id|commit_extra_header
op_star
id|extra
)paren
(brace
id|strbuf_addstr
c_func
(paren
id|buffer
comma
id|extra-&gt;key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|extra-&gt;len
)paren
id|strbuf_add_lines
c_func
(paren
id|buffer
comma
l_string|&quot; &quot;
comma
id|extra-&gt;value
comma
id|extra-&gt;len
)paren
suffix:semicolon
r_else
id|strbuf_addch
c_func
(paren
id|buffer
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
DECL|function|read_commit_extra_headers
r_struct
id|commit_extra_header
op_star
id|read_commit_extra_headers
c_func
(paren
r_struct
id|commit
op_star
id|commit
comma
r_const
r_char
op_star
op_star
id|exclude
)paren
(brace
r_struct
id|commit_extra_header
op_star
id|extra
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_const
r_char
op_star
id|buffer
op_assign
id|get_commit_buffer
c_func
(paren
id|commit
comma
op_amp
id|size
)paren
suffix:semicolon
id|extra
op_assign
id|read_commit_extra_header_lines
c_func
(paren
id|buffer
comma
id|size
comma
id|exclude
)paren
suffix:semicolon
id|unuse_commit_buffer
c_func
(paren
id|commit
comma
id|buffer
)paren
suffix:semicolon
r_return
id|extra
suffix:semicolon
)brace
DECL|function|standard_header_field
r_static
r_inline
r_int
id|standard_header_field
c_func
(paren
r_const
r_char
op_star
id|field
comma
r_int
id|len
)paren
(brace
r_return
(paren
(paren
id|len
op_eq
l_int|4
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|field
comma
l_string|&quot;tree &quot;
comma
l_int|5
)paren
)paren
op_logical_or
(paren
id|len
op_eq
l_int|6
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|field
comma
l_string|&quot;parent &quot;
comma
l_int|7
)paren
)paren
op_logical_or
(paren
id|len
op_eq
l_int|6
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|field
comma
l_string|&quot;author &quot;
comma
l_int|7
)paren
)paren
op_logical_or
(paren
id|len
op_eq
l_int|9
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|field
comma
l_string|&quot;committer &quot;
comma
l_int|10
)paren
)paren
op_logical_or
(paren
id|len
op_eq
l_int|8
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|field
comma
l_string|&quot;encoding &quot;
comma
l_int|9
)paren
)paren
)paren
suffix:semicolon
)brace
DECL|function|excluded_header_field
r_static
r_int
id|excluded_header_field
c_func
(paren
r_const
r_char
op_star
id|field
comma
r_int
id|len
comma
r_const
r_char
op_star
op_star
id|exclude
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|exclude
)paren
r_return
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_star
id|exclude
)paren
(brace
r_int
id|xlen
op_assign
id|strlen
c_func
(paren
op_star
id|exclude
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
id|xlen
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|field
comma
op_star
id|exclude
comma
id|xlen
)paren
op_logical_and
id|field
(braket
id|xlen
)braket
op_eq
l_char|&squot; &squot;
)paren
r_return
l_int|1
suffix:semicolon
id|exclude
op_increment
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|read_commit_extra_header_lines
r_static
r_struct
id|commit_extra_header
op_star
id|read_commit_extra_header_lines
c_func
(paren
r_const
r_char
op_star
id|buffer
comma
r_int
id|size
comma
r_const
r_char
op_star
op_star
id|exclude
)paren
(brace
r_struct
id|commit_extra_header
op_star
id|extra
op_assign
l_int|NULL
comma
op_star
op_star
id|tail
op_assign
op_amp
id|extra
comma
op_star
id|it
op_assign
l_int|NULL
suffix:semicolon
r_const
r_char
op_star
id|line
comma
op_star
id|next
comma
op_star
id|eof
comma
op_star
id|eob
suffix:semicolon
r_struct
id|strbuf
id|buf
op_assign
id|STRBUF_INIT
suffix:semicolon
r_for
c_loop
(paren
id|line
op_assign
id|buffer
comma
id|eob
op_assign
id|line
op_plus
id|size
suffix:semicolon
id|line
OL
id|eob
op_logical_and
op_star
id|line
op_ne
l_char|&squot;&bslash;n&squot;
suffix:semicolon
id|line
op_assign
id|next
)paren
(brace
id|next
op_assign
id|memchr
c_func
(paren
id|line
comma
l_char|&squot;&bslash;n&squot;
comma
id|eob
id|line
)paren
suffix:semicolon
id|next
op_assign
id|next
ques
c_cond
id|next
op_plus
l_int|1
suffix:colon
id|eob
suffix:semicolon
r_if
c_cond
(paren
op_star
id|line
op_eq
l_char|&squot; &squot;
)paren
(brace
multiline_comment|/* continuation */
r_if
c_cond
(paren
id|it
)paren
id|strbuf_add
c_func
(paren
op_amp
id|buf
comma
id|line
op_plus
l_int|1
comma
id|next
(paren
id|line
op_plus
l_int|1
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|it
)paren
id|it-&gt;value
op_assign
id|strbuf_detach
c_func
(paren
op_amp
id|buf
comma
op_amp
id|it-&gt;len
)paren
suffix:semicolon
id|strbuf_reset
c_func
(paren
op_amp
id|buf
)paren
suffix:semicolon
id|it
op_assign
l_int|NULL
suffix:semicolon
id|eof
op_assign
id|strchr
c_func
(paren
id|line
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|next
op_le
id|eof
)paren
id|eof
op_assign
id|next
suffix:semicolon
r_if
c_cond
(paren
id|standard_header_field
c_func
(paren
id|line
comma
id|eof
id|line
)paren
op_logical_or
id|excluded_header_field
c_func
(paren
id|line
comma
id|eof
id|line
comma
id|exclude
)paren
)paren
r_continue
suffix:semicolon
id|it
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|it
)paren
)paren
suffix:semicolon
id|it-&gt;key
op_assign
id|xmemdupz
c_func
(paren
id|line
comma
id|eof
op_minus
id|line
)paren
suffix:semicolon
op_star
id|tail
op_assign
id|it
suffix:semicolon
id|tail
op_assign
op_amp
id|it-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|eof
op_plus
l_int|1
OL
id|next
)paren
id|strbuf_add
c_func
(paren
op_amp
id|buf
comma
id|eof
op_plus
l_int|1
comma
id|next
(paren
id|eof
op_plus
l_int|1
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|it
)paren
id|it-&gt;value
op_assign
id|strbuf_detach
c_func
(paren
op_amp
id|buf
comma
op_amp
id|it-&gt;len
)paren
suffix:semicolon
r_return
id|extra
suffix:semicolon
)brace
DECL|function|free_commit_extra_headers
r_void
id|free_commit_extra_headers
c_func
(paren
r_struct
id|commit_extra_header
op_star
id|extra
)paren
(brace
r_while
c_loop
(paren
id|extra
)paren
(brace
r_struct
id|commit_extra_header
op_star
id|next
op_assign
id|extra-&gt;next
suffix:semicolon
id|free
c_func
(paren
id|extra-&gt;key
)paren
suffix:semicolon
id|free
c_func
(paren
id|extra-&gt;value
)paren
suffix:semicolon
id|free
c_func
(paren
id|extra
)paren
suffix:semicolon
id|extra
op_assign
id|next
suffix:semicolon
)brace
)brace
DECL|function|commit_tree
r_int
id|commit_tree
c_func
(paren
r_const
r_char
op_star
id|msg
comma
r_int
id|msg_len
comma
r_const
r_int
r_char
op_star
id|tree
comma
r_struct
id|commit_list
op_star
id|parents
comma
r_int
r_char
op_star
id|ret
comma
r_const
r_char
op_star
id|author
comma
r_const
r_char
op_star
id|sign_commit
)paren
(brace
r_struct
id|commit_extra_header
op_star
id|extra
op_assign
l_int|NULL
comma
op_star
op_star
id|tail
op_assign
op_amp
id|extra
suffix:semicolon
r_int
id|result
suffix:semicolon
id|append_merge_tag_headers
c_func
(paren
id|parents
comma
op_amp
id|tail
)paren
suffix:semicolon
id|result
op_assign
id|commit_tree_extended
c_func
(paren
id|msg
comma
id|msg_len
comma
id|tree
comma
id|parents
comma
id|ret
comma
id|author
comma
id|sign_commit
comma
id|extra
)paren
suffix:semicolon
id|free_commit_extra_headers
c_func
(paren
id|extra
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|find_invalid_utf8
r_static
r_int
id|find_invalid_utf8
c_func
(paren
r_const
r_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_int
id|offset
op_assign
l_int|0
suffix:semicolon
r_static
r_const
r_int
r_int
id|max_codepoint
(braket
)braket
op_assign
(brace
l_int|0x7f
comma
l_int|0x7ff
comma
l_int|0xffff
comma
l_int|0x10ffff
)brace
suffix:semicolon
r_while
c_loop
(paren
id|len
)paren
(brace
r_int
r_char
id|c
op_assign
op_star
id|buf
op_increment
suffix:semicolon
r_int
id|bytes
comma
id|bad_offset
suffix:semicolon
r_int
r_int
id|codepoint
suffix:semicolon
r_int
r_int
id|min_val
comma
id|max_val
suffix:semicolon
id|len
op_decrement
suffix:semicolon
id|offset
op_increment
suffix:semicolon
multiline_comment|/* Simple US-ASCII? No worries. */
r_if
c_cond
(paren
id|c
OL
l_int|0x80
)paren
r_continue
suffix:semicolon
id|bad_offset
op_assign
id|offset
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Count how many more high bits set: that&squot;s how&n;&t;&t; * many more bytes this sequence should have.&n;&t;&t; */
id|bytes
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|c
op_amp
l_int|0x40
)paren
(brace
id|c
op_lshift_assign
l_int|1
suffix:semicolon
id|bytes
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Must be between 1 and 3 more bytes.  Longer sequences result in&n;&t;&t; * codepoints beyond U+10FFFF, which are guaranteed never to exist.&n;&t;&t; */
r_if
c_cond
(paren
id|bytes
OL
l_int|1
op_logical_or
l_int|3
OL
id|bytes
)paren
r_return
id|bad_offset
suffix:semicolon
multiline_comment|/* Do we *have* that many bytes? */
r_if
c_cond
(paren
id|len
OL
id|bytes
)paren
r_return
id|bad_offset
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Place the encoded bits at the bottom of the value and compute the&n;&t;&t; * valid range.&n;&t;&t; */
id|codepoint
op_assign
(paren
id|c
op_amp
l_int|0x7f
)paren
op_rshift
id|bytes
suffix:semicolon
id|min_val
op_assign
id|max_codepoint
(braket
id|bytes
op_minus
l_int|1
)braket
op_plus
l_int|1
suffix:semicolon
id|max_val
op_assign
id|max_codepoint
(braket
id|bytes
)braket
suffix:semicolon
id|offset
op_add_assign
id|bytes
suffix:semicolon
id|len
op_sub_assign
id|bytes
suffix:semicolon
multiline_comment|/* And verify that they are good continuation bytes */
r_do
(brace
id|codepoint
op_lshift_assign
l_int|6
suffix:semicolon
id|codepoint
op_or_assign
op_star
id|buf
op_amp
l_int|0x3f
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|buf
op_increment
op_amp
l_int|0xc0
)paren
op_ne
l_int|0x80
)paren
r_return
id|bad_offset
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|bytes
)paren
suffix:semicolon
multiline_comment|/* Reject codepoints that are out of range for the sequence length. */
r_if
c_cond
(paren
id|codepoint
template_param
id|max_val
)paren
r_return
id|bad_offset
suffix:semicolon
multiline_comment|/* Surrogates are only for UTF-16 and cannot be encoded in UTF-8. */
r_if
c_cond
(paren
(paren
id|codepoint
op_amp
l_int|0x1ff800
)paren
op_eq
l_int|0xd800
)paren
r_return
id|bad_offset
suffix:semicolon
multiline_comment|/* U+xxFFFE and U+xxFFFF are guaranteed non-characters. */
r_if
c_cond
(paren
(paren
id|codepoint
op_amp
l_int|0xfffe
)paren
op_eq
l_int|0xfffe
)paren
r_return
id|bad_offset
suffix:semicolon
multiline_comment|/* So are anything in the range U+FDD0..U+FDEF. */
r_if
c_cond
(paren
id|codepoint
op_ge
l_int|0xfdd0
op_logical_and
id|codepoint
op_le
l_int|0xfdef
)paren
r_return
id|bad_offset
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * This verifies that the buffer is in proper utf8 format.&n; *&n; * If it isn&squot;t, it assumes any non-utf8 characters are Latin1,&n; * and does the conversion.&n; */
DECL|function|verify_utf8
r_static
r_int
id|verify_utf8
c_func
(paren
r_struct
id|strbuf
op_star
id|buf
)paren
(brace
r_int
id|ok
op_assign
l_int|1
suffix:semicolon
r_int
id|pos
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|bad
suffix:semicolon
r_int
r_char
id|c
suffix:semicolon
r_int
r_char
id|replace
(braket
l_int|2
)braket
suffix:semicolon
id|bad
op_assign
id|find_invalid_utf8
c_func
(paren
id|buf-&gt;buf
op_plus
id|pos
comma
id|buf-&gt;len
id|pos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bad
OL
l_int|0
)paren
r_return
id|ok
suffix:semicolon
id|pos
op_add_assign
id|bad
suffix:semicolon
id|ok
op_assign
l_int|0
suffix:semicolon
id|c
op_assign
id|buf-&gt;buf
(braket
id|pos
)braket
suffix:semicolon
id|strbuf_remove
c_func
(paren
id|buf
comma
id|pos
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* We know &squot;c&squot; must be in the range 128-255 */
id|replace
(braket
l_int|0
)braket
op_assign
l_int|0xc0
op_plus
(paren
id|c
op_rshift
l_int|6
)paren
suffix:semicolon
id|replace
(braket
l_int|1
)braket
op_assign
l_int|0x80
op_plus
(paren
id|c
op_amp
l_int|0x3f
)paren
suffix:semicolon
id|strbuf_insert
c_func
(paren
id|buf
comma
id|pos
comma
id|replace
comma
l_int|2
)paren
suffix:semicolon
id|pos
op_add_assign
l_int|2
suffix:semicolon
)brace
)brace
DECL|variable|commit_utf8_warn
r_static
r_const
r_char
id|commit_utf8_warn
(braket
)braket
op_assign
l_string|&quot;Warning: commit message did not conform to UTF-8.&bslash;n&quot;
l_string|&quot;You may want to amend it after fixing the message, or set the config&bslash;n&quot;
l_string|&quot;variable i18n.commitencoding to the encoding your project uses.&bslash;n&quot;
suffix:semicolon
DECL|function|commit_tree_extended
r_int
id|commit_tree_extended
c_func
(paren
r_const
r_char
op_star
id|msg
comma
r_int
id|msg_len
comma
r_const
r_int
r_char
op_star
id|tree
comma
r_struct
id|commit_list
op_star
id|parents
comma
r_int
r_char
op_star
id|ret
comma
r_const
r_char
op_star
id|author
comma
r_const
r_char
op_star
id|sign_commit
comma
r_struct
id|commit_extra_header
op_star
id|extra
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
id|encoding_is_utf8
suffix:semicolon
r_struct
id|strbuf
id|buffer
suffix:semicolon
id|assert_sha1_type
c_func
(paren
id|tree
comma
id|OBJ_TREE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|memchr
c_func
(paren
id|msg
comma
l_char|&squot;&bslash;0&squot;
comma
id|msg_len
)paren
)paren
r_return
id|error
c_func
(paren
l_string|&quot;a NUL byte in commit log message not allowed.&quot;
)paren
suffix:semicolon
multiline_comment|/* Not having i18n.commitencoding is the same as having utf-8 */
id|encoding_is_utf8
op_assign
id|is_encoding_utf8
c_func
(paren
id|git_commit_encoding
)paren
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|buffer
comma
l_int|8192
)paren
suffix:semicolon
multiline_comment|/* should avoid reallocs for the headers */
id|strbuf_addf
c_func
(paren
op_amp
id|buffer
comma
l_string|&quot;tree %s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|tree
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * NOTE! This ordering means that the same exact tree merged with a&n;&t; * different order of parents will be a _different_ changeset even&n;&t; * if everything else stays the same.&n;&t; */
r_while
c_loop
(paren
id|parents
)paren
(brace
r_struct
id|commit_list
op_star
id|next
op_assign
id|parents-&gt;next
suffix:semicolon
r_struct
id|commit
op_star
id|parent
op_assign
id|parents-&gt;item
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
id|buffer
comma
l_string|&quot;parent %s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|parent-&gt;object.sha1
)paren
)paren
suffix:semicolon
id|free
c_func
(paren
id|parents
)paren
suffix:semicolon
id|parents
op_assign
id|next
suffix:semicolon
)brace
multiline_comment|/* Person/date information */
r_if
c_cond
(paren
op_logical_neg
id|author
)paren
id|author
op_assign
id|git_author_info
c_func
(paren
id|IDENT_STRICT
)paren
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
id|buffer
comma
l_string|&quot;author %s&bslash;n&quot;
comma
id|author
)paren
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
id|buffer
comma
l_string|&quot;committer %s&bslash;n&quot;
comma
id|git_committer_info
c_func
(paren
id|IDENT_STRICT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|encoding_is_utf8
)paren
id|strbuf_addf
c_func
(paren
op_amp
id|buffer
comma
l_string|&quot;encoding %s&bslash;n&quot;
comma
id|git_commit_encoding
)paren
suffix:semicolon
r_while
c_loop
(paren
id|extra
)paren
(brace
id|add_extra_header
c_func
(paren
op_amp
id|buffer
comma
id|extra
)paren
suffix:semicolon
id|extra
op_assign
id|extra-&gt;next
suffix:semicolon
)brace
id|strbuf_addch
c_func
(paren
op_amp
id|buffer
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
multiline_comment|/* And add the comment */
id|strbuf_add
c_func
(paren
op_amp
id|buffer
comma
id|msg
comma
id|msg_len
)paren
suffix:semicolon
multiline_comment|/* And check the encoding */
r_if
c_cond
(paren
id|encoding_is_utf8
op_logical_and
op_logical_neg
id|verify_utf8
c_func
(paren
op_amp
id|buffer
)paren
)paren
id|fprintf
c_func
(paren
id|stderr
comma
id|commit_utf8_warn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sign_commit
op_logical_and
id|do_sign_commit
c_func
(paren
op_amp
id|buffer
comma
id|sign_commit
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|result
op_assign
id|write_sha1_file
c_func
(paren
id|buffer.buf
comma
id|buffer.len
comma
id|commit_type
comma
id|ret
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|buffer
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|get_merge_parent
r_struct
id|commit
op_star
id|get_merge_parent
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|object
op_star
id|obj
suffix:semicolon
r_struct
id|commit
op_star
id|commit
suffix:semicolon
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1
c_func
(paren
id|name
comma
id|sha1
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|obj
op_assign
id|parse_object
c_func
(paren
id|sha1
)paren
suffix:semicolon
id|commit
op_assign
(paren
r_struct
id|commit
op_star
)paren
id|peel_to_type
c_func
(paren
id|name
comma
l_int|0
comma
id|obj
comma
id|OBJ_COMMIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|commit
op_logical_and
op_logical_neg
id|commit-&gt;util
)paren
(brace
r_struct
id|merge_remote_desc
op_star
id|desc
suffix:semicolon
id|desc
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|desc
)paren
)paren
suffix:semicolon
id|desc-&gt;obj
op_assign
id|obj
suffix:semicolon
id|desc-&gt;name
op_assign
id|strdup
c_func
(paren
id|name
)paren
suffix:semicolon
id|commit-&gt;util
op_assign
id|desc
suffix:semicolon
)brace
r_return
id|commit
suffix:semicolon
)brace
multiline_comment|/*&n; * Append a commit to the end of the commit_list.&n; *&n; * next starts by pointing to the variable that holds the head of an&n; * empty commit_list, and is updated to point to the &quot;next&quot; field of&n; * the last item on the list as new commits are appended.&n; *&n; * Usage example:&n; *&n; *     struct commit_list *list;&n; *     struct commit_list **next = &amp;list;&n; *&n; *     next = commit_list_append(c1, next);&n; *     next = commit_list_append(c2, next);&n; *     assert(commit_list_count(list) == 2);&n; *     return list;&n; */
DECL|function|commit_list_append
r_struct
id|commit_list
op_star
op_star
id|commit_list_append
c_func
(paren
r_struct
id|commit
op_star
id|commit
comma
r_struct
id|commit_list
op_star
op_star
id|next
)paren
(brace
r_struct
id|commit_list
op_star
r_new
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|commit_list
)paren
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|item
op_assign
id|commit
suffix:semicolon
op_star
id|next
op_assign
r_new
suffix:semicolon
r_new
op_member_access_from_pointer
id|next
op_assign
l_int|NULL
suffix:semicolon
r_return
op_amp
r_new
op_member_access_from_pointer
id|next
suffix:semicolon
)brace
DECL|function|print_commit_list
r_void
id|print_commit_list
c_func
(paren
r_struct
id|commit_list
op_star
id|list
comma
r_const
r_char
op_star
id|format_cur
comma
r_const
r_char
op_star
id|format_last
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|list
suffix:semicolon
id|list
op_assign
id|list-&gt;next
)paren
(brace
r_const
r_char
op_star
id|format
op_assign
id|list-&gt;next
ques
c_cond
id|format_cur
suffix:colon
id|format_last
suffix:semicolon
id|printf
c_func
(paren
id|format
comma
id|sha1_to_hex
c_func
(paren
id|list-&gt;item-&gt;object.sha1
)paren
)paren
suffix:semicolon
)brace
)brace
eof
