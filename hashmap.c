multiline_comment|/*&n; * Generic implementation of hash-based key value mappings.&n; */
macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;hashmap.h&quot;
DECL|macro|FNV32_BASE
mdefine_line|#define FNV32_BASE ((unsigned int) 0x811c9dc5)
DECL|macro|FNV32_PRIME
mdefine_line|#define FNV32_PRIME ((unsigned int) 0x01000193)
DECL|function|strhash
r_int
r_int
id|strhash
c_func
(paren
r_const
r_char
op_star
id|str
)paren
(brace
r_int
r_int
id|c
comma
id|hash
op_assign
id|FNV32_BASE
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
(paren
r_int
r_char
)paren
op_star
id|str
op_increment
)paren
)paren
id|hash
op_assign
(paren
id|hash
op_star
id|FNV32_PRIME
)paren
op_xor
id|c
suffix:semicolon
r_return
id|hash
suffix:semicolon
)brace
DECL|function|strihash
r_int
r_int
id|strihash
c_func
(paren
r_const
r_char
op_star
id|str
)paren
(brace
r_int
r_int
id|c
comma
id|hash
op_assign
id|FNV32_BASE
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
(paren
r_int
r_char
)paren
op_star
id|str
op_increment
)paren
)paren
(brace
r_if
c_cond
(paren
id|c
op_ge
l_char|&squot;a&squot;
op_logical_and
id|c
op_le
l_char|&squot;z&squot;
)paren
id|c
op_sub_assign
l_char|&squot;a&squot;
l_char|&squot;A&squot;
suffix:semicolon
id|hash
op_assign
(paren
id|hash
op_star
id|FNV32_PRIME
)paren
op_xor
id|c
suffix:semicolon
)brace
r_return
id|hash
suffix:semicolon
)brace
DECL|function|memhash
r_int
r_int
id|memhash
c_func
(paren
r_const
r_void
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_int
r_int
id|hash
op_assign
id|FNV32_BASE
suffix:semicolon
r_int
r_char
op_star
id|ucbuf
op_assign
(paren
r_int
r_char
op_star
)paren
id|buf
suffix:semicolon
r_while
c_loop
(paren
id|len
op_decrement
)paren
(brace
r_int
r_int
id|c
op_assign
op_star
id|ucbuf
op_increment
suffix:semicolon
id|hash
op_assign
(paren
id|hash
op_star
id|FNV32_PRIME
)paren
op_xor
id|c
suffix:semicolon
)brace
r_return
id|hash
suffix:semicolon
)brace
DECL|function|memihash
r_int
r_int
id|memihash
c_func
(paren
r_const
r_void
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_int
r_int
id|hash
op_assign
id|FNV32_BASE
suffix:semicolon
r_int
r_char
op_star
id|ucbuf
op_assign
(paren
r_int
r_char
op_star
)paren
id|buf
suffix:semicolon
r_while
c_loop
(paren
id|len
op_decrement
)paren
(brace
r_int
r_int
id|c
op_assign
op_star
id|ucbuf
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|c
op_ge
l_char|&squot;a&squot;
op_logical_and
id|c
op_le
l_char|&squot;z&squot;
)paren
id|c
op_sub_assign
l_char|&squot;a&squot;
l_char|&squot;A&squot;
suffix:semicolon
id|hash
op_assign
(paren
id|hash
op_star
id|FNV32_PRIME
)paren
op_xor
id|c
suffix:semicolon
)brace
r_return
id|hash
suffix:semicolon
)brace
DECL|macro|HASHMAP_INITIAL_SIZE
mdefine_line|#define HASHMAP_INITIAL_SIZE 64
multiline_comment|/* grow / shrink by 2^2 */
DECL|macro|HASHMAP_RESIZE_BITS
mdefine_line|#define HASHMAP_RESIZE_BITS 2
multiline_comment|/* load factor in percent */
DECL|macro|HASHMAP_LOAD_FACTOR
mdefine_line|#define HASHMAP_LOAD_FACTOR 80
DECL|function|alloc_table
r_static
r_void
id|alloc_table
c_func
(paren
r_struct
id|hashmap
op_star
id|map
comma
r_int
r_int
id|size
)paren
(brace
id|map-&gt;tablesize
op_assign
id|size
suffix:semicolon
id|map-&gt;table
op_assign
id|xcalloc
c_func
(paren
id|size
comma
r_sizeof
(paren
r_struct
id|hashmap_entry
op_star
)paren
)paren
suffix:semicolon
multiline_comment|/* calculate resize thresholds for new size */
id|map-&gt;grow_at
op_assign
(paren
r_int
r_int
)paren
(paren
(paren
r_uint64
)paren
id|size
op_star
id|HASHMAP_LOAD_FACTOR
op_div
l_int|100
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_le
id|HASHMAP_INITIAL_SIZE
)paren
id|map-&gt;shrink_at
op_assign
l_int|0
suffix:semicolon
r_else
multiline_comment|/*&n;&t;&t; * The shrink-threshold must be slightly smaller than&n;&t;&t; * (grow-threshold / resize-factor) to prevent erratic resizing,&n;&t;&t; * thus we divide by (resize-factor + 1).&n;&t;&t; */
id|map-&gt;shrink_at
op_assign
id|map-&gt;grow_at
op_div
(paren
(paren
l_int|1
op_lshift
id|HASHMAP_RESIZE_BITS
)paren
op_plus
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|entry_equals
r_static
r_inline
r_int
id|entry_equals
c_func
(paren
r_const
r_struct
id|hashmap
op_star
id|map
comma
r_const
r_struct
id|hashmap_entry
op_star
id|e1
comma
r_const
r_struct
id|hashmap_entry
op_star
id|e2
comma
r_const
r_void
op_star
id|keydata
)paren
(brace
r_return
(paren
id|e1
op_eq
id|e2
)paren
op_logical_or
(paren
id|e1-&gt;hash
op_eq
id|e2-&gt;hash
op_logical_and
op_logical_neg
id|map
op_member_access_from_pointer
id|cmpfn
c_func
(paren
id|e1
comma
id|e2
comma
id|keydata
)paren
)paren
suffix:semicolon
)brace
DECL|function|bucket
r_static
r_inline
r_int
r_int
id|bucket
c_func
(paren
r_const
r_struct
id|hashmap
op_star
id|map
comma
r_const
r_struct
id|hashmap_entry
op_star
id|key
)paren
(brace
r_return
id|key-&gt;hash
op_amp
(paren
id|map-&gt;tablesize
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|rehash
r_static
r_void
id|rehash
c_func
(paren
r_struct
id|hashmap
op_star
id|map
comma
r_int
r_int
id|newsize
)paren
(brace
r_int
r_int
id|i
comma
id|oldsize
op_assign
id|map-&gt;tablesize
suffix:semicolon
r_struct
id|hashmap_entry
op_star
op_star
id|oldtable
op_assign
id|map-&gt;table
suffix:semicolon
id|alloc_table
c_func
(paren
id|map
comma
id|newsize
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|oldsize
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|hashmap_entry
op_star
id|e
op_assign
id|oldtable
(braket
id|i
)braket
suffix:semicolon
r_while
c_loop
(paren
id|e
)paren
(brace
r_struct
id|hashmap_entry
op_star
id|next
op_assign
id|e-&gt;next
suffix:semicolon
r_int
r_int
id|b
op_assign
id|bucket
c_func
(paren
id|map
comma
id|e
)paren
suffix:semicolon
id|e-&gt;next
op_assign
id|map-&gt;table
(braket
id|b
)braket
suffix:semicolon
id|map-&gt;table
(braket
id|b
)braket
op_assign
id|e
suffix:semicolon
id|e
op_assign
id|next
suffix:semicolon
)brace
)brace
id|free
c_func
(paren
id|oldtable
)paren
suffix:semicolon
)brace
DECL|function|find_entry_ptr
r_static
r_inline
r_struct
id|hashmap_entry
op_star
op_star
id|find_entry_ptr
c_func
(paren
r_const
r_struct
id|hashmap
op_star
id|map
comma
r_const
r_struct
id|hashmap_entry
op_star
id|key
comma
r_const
r_void
op_star
id|keydata
)paren
(brace
r_struct
id|hashmap_entry
op_star
op_star
id|e
op_assign
op_amp
id|map-&gt;table
(braket
id|bucket
c_func
(paren
id|map
comma
id|key
)paren
)braket
suffix:semicolon
r_while
c_loop
(paren
op_star
id|e
op_logical_and
op_logical_neg
id|entry_equals
c_func
(paren
id|map
comma
op_star
id|e
comma
id|key
comma
id|keydata
)paren
)paren
id|e
op_assign
op_amp
(paren
op_star
id|e
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
r_return
id|e
suffix:semicolon
)brace
DECL|function|always_equal
r_static
r_int
id|always_equal
c_func
(paren
r_const
r_void
op_star
id|unused1
comma
r_const
r_void
op_star
id|unused2
comma
r_const
r_void
op_star
id|unused3
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|hashmap_init
r_void
id|hashmap_init
c_func
(paren
r_struct
id|hashmap
op_star
id|map
comma
id|hashmap_cmp_fn
id|equals_function
comma
r_int
id|initial_size
)paren
(brace
r_int
r_int
id|size
op_assign
id|HASHMAP_INITIAL_SIZE
suffix:semicolon
id|map-&gt;size
op_assign
l_int|0
suffix:semicolon
id|map-&gt;cmpfn
op_assign
id|equals_function
ques
c_cond
id|equals_function
suffix:colon
id|always_equal
suffix:semicolon
multiline_comment|/* calculate initial table size and allocate the table */
id|initial_size
op_assign
(paren
r_int
r_int
)paren
(paren
(paren
r_uint64
)paren
id|initial_size
op_star
l_int|100
op_div
id|HASHMAP_LOAD_FACTOR
)paren
suffix:semicolon
r_while
c_loop
(paren
id|initial_size
OG
id|size
)paren
id|size
op_lshift_assign
id|HASHMAP_RESIZE_BITS
suffix:semicolon
id|alloc_table
c_func
(paren
id|map
comma
id|size
)paren
suffix:semicolon
)brace
DECL|function|hashmap_free
r_void
id|hashmap_free
c_func
(paren
r_struct
id|hashmap
op_star
id|map
comma
r_int
id|free_entries
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|map
op_logical_or
op_logical_neg
id|map-&gt;table
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|free_entries
)paren
(brace
r_struct
id|hashmap_iter
id|iter
suffix:semicolon
r_struct
id|hashmap_entry
op_star
id|e
suffix:semicolon
id|hashmap_iter_init
c_func
(paren
id|map
comma
op_amp
id|iter
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|e
op_assign
id|hashmap_iter_next
c_func
(paren
op_amp
id|iter
)paren
)paren
)paren
id|free
c_func
(paren
id|e
)paren
suffix:semicolon
)brace
id|free
c_func
(paren
id|map-&gt;table
)paren
suffix:semicolon
id|memset
c_func
(paren
id|map
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|map
)paren
)paren
suffix:semicolon
)brace
DECL|function|hashmap_get
r_void
op_star
id|hashmap_get
c_func
(paren
r_const
r_struct
id|hashmap
op_star
id|map
comma
r_const
r_void
op_star
id|key
comma
r_const
r_void
op_star
id|keydata
)paren
(brace
r_return
op_star
id|find_entry_ptr
c_func
(paren
id|map
comma
id|key
comma
id|keydata
)paren
suffix:semicolon
)brace
DECL|function|hashmap_get_next
r_void
op_star
id|hashmap_get_next
c_func
(paren
r_const
r_struct
id|hashmap
op_star
id|map
comma
r_const
r_void
op_star
id|entry
)paren
(brace
r_struct
id|hashmap_entry
op_star
id|e
op_assign
(paren
(paren
r_struct
id|hashmap_entry
op_star
)paren
id|entry
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|e
suffix:semicolon
id|e
op_assign
id|e-&gt;next
)paren
r_if
c_cond
(paren
id|entry_equals
c_func
(paren
id|map
comma
id|entry
comma
id|e
comma
l_int|NULL
)paren
)paren
r_return
id|e
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|hashmap_add
r_void
id|hashmap_add
c_func
(paren
r_struct
id|hashmap
op_star
id|map
comma
r_void
op_star
id|entry
)paren
(brace
r_int
r_int
id|b
op_assign
id|bucket
c_func
(paren
id|map
comma
id|entry
)paren
suffix:semicolon
multiline_comment|/* add entry */
(paren
(paren
r_struct
id|hashmap_entry
op_star
)paren
id|entry
)paren
op_member_access_from_pointer
id|next
op_assign
id|map-&gt;table
(braket
id|b
)braket
suffix:semicolon
id|map-&gt;table
(braket
id|b
)braket
op_assign
id|entry
suffix:semicolon
multiline_comment|/* fix size and rehash if appropriate */
id|map-&gt;size
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|map-&gt;size
OG
id|map-&gt;grow_at
)paren
id|rehash
c_func
(paren
id|map
comma
id|map-&gt;tablesize
op_lshift
id|HASHMAP_RESIZE_BITS
)paren
suffix:semicolon
)brace
DECL|function|hashmap_remove
r_void
op_star
id|hashmap_remove
c_func
(paren
r_struct
id|hashmap
op_star
id|map
comma
r_const
r_void
op_star
id|key
comma
r_const
r_void
op_star
id|keydata
)paren
(brace
r_struct
id|hashmap_entry
op_star
id|old
suffix:semicolon
r_struct
id|hashmap_entry
op_star
op_star
id|e
op_assign
id|find_entry_ptr
c_func
(paren
id|map
comma
id|key
comma
id|keydata
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|e
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* remove existing entry */
id|old
op_assign
op_star
id|e
suffix:semicolon
op_star
id|e
op_assign
id|old-&gt;next
suffix:semicolon
id|old-&gt;next
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* fix size and rehash if appropriate */
id|map-&gt;size
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|map-&gt;size
OL
id|map-&gt;shrink_at
)paren
id|rehash
c_func
(paren
id|map
comma
id|map-&gt;tablesize
op_rshift
id|HASHMAP_RESIZE_BITS
)paren
suffix:semicolon
r_return
id|old
suffix:semicolon
)brace
DECL|function|hashmap_put
r_void
op_star
id|hashmap_put
c_func
(paren
r_struct
id|hashmap
op_star
id|map
comma
r_void
op_star
id|entry
)paren
(brace
r_struct
id|hashmap_entry
op_star
id|old
op_assign
id|hashmap_remove
c_func
(paren
id|map
comma
id|entry
comma
l_int|NULL
)paren
suffix:semicolon
id|hashmap_add
c_func
(paren
id|map
comma
id|entry
)paren
suffix:semicolon
r_return
id|old
suffix:semicolon
)brace
DECL|function|hashmap_iter_init
r_void
id|hashmap_iter_init
c_func
(paren
r_struct
id|hashmap
op_star
id|map
comma
r_struct
id|hashmap_iter
op_star
id|iter
)paren
(brace
id|iter-&gt;map
op_assign
id|map
suffix:semicolon
id|iter-&gt;tablepos
op_assign
l_int|0
suffix:semicolon
id|iter-&gt;next
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|hashmap_iter_next
r_void
op_star
id|hashmap_iter_next
c_func
(paren
r_struct
id|hashmap_iter
op_star
id|iter
)paren
(brace
r_struct
id|hashmap_entry
op_star
id|current
op_assign
id|iter-&gt;next
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|current
)paren
(brace
id|iter-&gt;next
op_assign
id|current-&gt;next
suffix:semicolon
r_return
id|current
suffix:semicolon
)brace
r_if
c_cond
(paren
id|iter-&gt;tablepos
op_ge
id|iter-&gt;map-&gt;tablesize
)paren
r_return
l_int|NULL
suffix:semicolon
id|current
op_assign
id|iter-&gt;map-&gt;table
(braket
id|iter-&gt;tablepos
op_increment
)braket
suffix:semicolon
)brace
)brace
DECL|struct|pool_entry
r_struct
id|pool_entry
(brace
DECL|member|ent
r_struct
id|hashmap_entry
id|ent
suffix:semicolon
DECL|member|len
r_int
id|len
suffix:semicolon
DECL|member|data
r_int
r_char
id|data
(braket
id|FLEX_ARRAY
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|function|pool_entry_cmp
r_static
r_int
id|pool_entry_cmp
c_func
(paren
r_const
r_struct
id|pool_entry
op_star
id|e1
comma
r_const
r_struct
id|pool_entry
op_star
id|e2
comma
r_const
r_int
r_char
op_star
id|keydata
)paren
(brace
r_return
id|e1-&gt;data
op_ne
id|keydata
op_logical_and
(paren
id|e1-&gt;len
op_ne
id|e2-&gt;len
op_logical_or
id|memcmp
c_func
(paren
id|e1-&gt;data
comma
id|keydata
comma
id|e1-&gt;len
)paren
)paren
suffix:semicolon
)brace
DECL|function|memintern
r_const
r_void
op_star
id|memintern
c_func
(paren
r_const
r_void
op_star
id|data
comma
r_int
id|len
)paren
(brace
r_static
r_struct
id|hashmap
id|map
suffix:semicolon
r_struct
id|pool_entry
id|key
comma
op_star
id|e
suffix:semicolon
multiline_comment|/* initialize string pool hashmap */
r_if
c_cond
(paren
op_logical_neg
id|map.tablesize
)paren
id|hashmap_init
c_func
(paren
op_amp
id|map
comma
(paren
id|hashmap_cmp_fn
)paren
id|pool_entry_cmp
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* lookup interned string in pool */
id|hashmap_entry_init
c_func
(paren
op_amp
id|key
comma
id|memhash
c_func
(paren
id|data
comma
id|len
)paren
)paren
suffix:semicolon
id|key.len
op_assign
id|len
suffix:semicolon
id|e
op_assign
id|hashmap_get
c_func
(paren
op_amp
id|map
comma
op_amp
id|key
comma
id|data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|e
)paren
(brace
multiline_comment|/* not found: create it */
id|e
op_assign
id|xmallocz
c_func
(paren
r_sizeof
(paren
r_struct
id|pool_entry
)paren
op_plus
id|len
)paren
suffix:semicolon
id|hashmap_entry_init
c_func
(paren
id|e
comma
id|key.ent.hash
)paren
suffix:semicolon
id|e-&gt;len
op_assign
id|len
suffix:semicolon
id|memcpy
c_func
(paren
id|e-&gt;data
comma
id|data
comma
id|len
)paren
suffix:semicolon
id|hashmap_add
c_func
(paren
op_amp
id|map
comma
id|e
)paren
suffix:semicolon
)brace
r_return
id|e-&gt;data
suffix:semicolon
)brace
eof
