macro_line|#ifdef USE_WILDMATCH
DECL|macro|USE_WILDMATCH
macro_line|#undef USE_WILDMATCH  /* We need real fnmatch implementation here */
macro_line|#endif
macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;wildmatch.h&quot;
DECL|function|perf
r_static
r_int
id|perf
c_func
(paren
r_int
id|ac
comma
r_char
op_star
op_star
id|av
)paren
(brace
r_struct
id|timeval
id|tv1
comma
id|tv2
suffix:semicolon
r_struct
id|stat
id|st
suffix:semicolon
r_int
id|fd
comma
id|i
comma
id|n
comma
id|flags1
op_assign
l_int|0
comma
id|flags2
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|buffer
comma
op_star
id|p
suffix:semicolon
r_uint32
id|usec1
comma
id|usec2
suffix:semicolon
r_const
r_char
op_star
id|lang
suffix:semicolon
r_const
r_char
op_star
id|file
op_assign
id|av
(braket
l_int|0
)braket
suffix:semicolon
r_const
r_char
op_star
id|pattern
op_assign
id|av
(braket
l_int|1
)braket
suffix:semicolon
id|lang
op_assign
id|getenv
c_func
(paren
l_string|&quot;LANG&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lang
op_logical_and
id|strcmp
c_func
(paren
id|lang
comma
l_string|&quot;C&quot;
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Please test it on C locale.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fd
op_assign
id|open
c_func
(paren
id|file
comma
id|O_RDONLY
)paren
)paren
op_eq
l_int|1
op_logical_or
id|fstat
c_func
(paren
id|fd
comma
op_amp
id|st
)paren
)paren
id|die_errno
c_func
(paren
l_string|&quot;file open&quot;
)paren
suffix:semicolon
id|buffer
op_assign
id|xmalloc
c_func
(paren
id|st.st_size
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read
c_func
(paren
id|fd
comma
id|buffer
comma
id|st.st_size
)paren
op_ne
id|st.st_size
)paren
id|die_errno
c_func
(paren
l_string|&quot;read&quot;
)paren
suffix:semicolon
id|buffer
(braket
id|st.st_size
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|buffer
(braket
id|st.st_size
op_plus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|st.st_size
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|buffer
(braket
id|i
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|buffer
(braket
id|i
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|n
op_assign
id|atoi
c_func
(paren
id|av
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|av
(braket
l_int|3
)braket
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|av
(braket
l_int|3
)braket
comma
l_string|&quot;pathname&quot;
)paren
)paren
(brace
id|flags1
op_assign
id|WM_PATHNAME
suffix:semicolon
id|flags2
op_assign
id|FNM_PATHNAME
suffix:semicolon
)brace
id|gettimeofday
c_func
(paren
op_amp
id|tv1
comma
l_int|NULL
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
(brace
r_for
c_loop
(paren
id|p
op_assign
id|buffer
suffix:semicolon
op_star
id|p
suffix:semicolon
id|p
op_add_assign
id|strlen
c_func
(paren
id|p
)paren
op_plus
l_int|1
)paren
id|wildmatch
c_func
(paren
id|pattern
comma
id|p
comma
id|flags1
comma
l_int|NULL
)paren
suffix:semicolon
)brace
id|gettimeofday
c_func
(paren
op_amp
id|tv2
comma
l_int|NULL
)paren
suffix:semicolon
id|usec1
op_assign
(paren
r_uint32
)paren
id|tv2.tv_sec
op_star
l_int|1000000
op_plus
id|tv2.tv_usec
suffix:semicolon
id|usec1
op_sub_assign
(paren
r_uint32
)paren
id|tv1.tv_sec
op_star
l_int|1000000
op_plus
id|tv1.tv_usec
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;wildmatch %ds %dus&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
id|usec1
op_div
l_int|1000000
)paren
comma
(paren
r_int
)paren
(paren
id|usec1
op_mod
l_int|1000000
)paren
)paren
suffix:semicolon
id|gettimeofday
c_func
(paren
op_amp
id|tv1
comma
l_int|NULL
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
(brace
r_for
c_loop
(paren
id|p
op_assign
id|buffer
suffix:semicolon
op_star
id|p
suffix:semicolon
id|p
op_add_assign
id|strlen
c_func
(paren
id|p
)paren
op_plus
l_int|1
)paren
id|fnmatch
c_func
(paren
id|pattern
comma
id|p
comma
id|flags2
)paren
suffix:semicolon
)brace
id|gettimeofday
c_func
(paren
op_amp
id|tv2
comma
l_int|NULL
)paren
suffix:semicolon
id|usec2
op_assign
(paren
r_uint32
)paren
id|tv2.tv_sec
op_star
l_int|1000000
op_plus
id|tv2.tv_usec
suffix:semicolon
id|usec2
op_sub_assign
(paren
r_uint32
)paren
id|tv1.tv_sec
op_star
l_int|1000000
op_plus
id|tv1.tv_usec
suffix:semicolon
r_if
c_cond
(paren
id|usec2
OG
id|usec1
)paren
id|printf
c_func
(paren
l_string|&quot;fnmatch   %ds %dus or %.2f%% slower&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
(paren
id|usec2
id|usec1
)paren
op_div
l_int|1000000
)paren
comma
(paren
r_int
)paren
(paren
(paren
id|usec2
id|usec1
)paren
op_mod
l_int|1000000
)paren
comma
(paren
r_float
)paren
(paren
id|usec2
id|usec1
)paren
op_div
id|usec1
op_star
l_int|100
)paren
suffix:semicolon
r_else
id|printf
c_func
(paren
l_string|&quot;fnmatch   %ds %dus or %.2f%% faster&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
(paren
id|usec1
id|usec2
)paren
op_div
l_int|1000000
)paren
comma
(paren
r_int
)paren
(paren
(paren
id|usec1
id|usec2
)paren
op_mod
l_int|1000000
)paren
comma
(paren
r_float
)paren
(paren
id|usec1
id|usec2
)paren
op_div
id|usec1
op_star
l_int|100
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|main
r_int
id|main
c_func
(paren
r_int
id|argc
comma
r_char
op_star
op_star
id|argv
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
l_string|&quot;perf&quot;
)paren
)paren
r_return
id|perf
c_func
(paren
id|argc
l_int|2
comma
id|argv
op_plus
l_int|2
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|2
suffix:semicolon
id|i
OL
id|argc
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|argv
(braket
id|i
)braket
(braket
l_int|0
)braket
op_eq
l_char|&squot;/&squot;
)paren
id|die
c_func
(paren
l_string|&quot;Forward slash is not allowed at the beginning of the&bslash;n&quot;
l_string|&quot;pattern because Windows does not like it. Use `XXX/&squot; instead.&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|argv
(braket
id|i
)braket
comma
l_string|&quot;XXX/&quot;
comma
l_int|4
)paren
)paren
id|argv
(braket
id|i
)braket
op_add_assign
l_int|3
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
l_string|&quot;wildmatch&quot;
)paren
)paren
r_return
op_logical_neg
op_logical_neg
id|wildmatch
c_func
(paren
id|argv
(braket
l_int|3
)braket
comma
id|argv
(braket
l_int|2
)braket
comma
id|WM_PATHNAME
comma
l_int|NULL
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
l_string|&quot;iwildmatch&quot;
)paren
)paren
r_return
op_logical_neg
op_logical_neg
id|wildmatch
c_func
(paren
id|argv
(braket
l_int|3
)braket
comma
id|argv
(braket
l_int|2
)braket
comma
id|WM_PATHNAME
op_or
id|WM_CASEFOLD
comma
l_int|NULL
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
l_string|&quot;pathmatch&quot;
)paren
)paren
r_return
op_logical_neg
op_logical_neg
id|wildmatch
c_func
(paren
id|argv
(braket
l_int|3
)braket
comma
id|argv
(braket
l_int|2
)braket
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
l_string|&quot;fnmatch&quot;
)paren
)paren
r_return
op_logical_neg
op_logical_neg
id|fnmatch
c_func
(paren
id|argv
(braket
l_int|3
)braket
comma
id|argv
(braket
l_int|2
)braket
comma
id|FNM_PATHNAME
)paren
suffix:semicolon
r_else
r_return
l_int|1
suffix:semicolon
)brace
eof
