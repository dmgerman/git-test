multiline_comment|/*&n; * Copyright (C) 2005 Junio C Hamano&n; */
macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;quote.h&quot;
macro_line|#include &quot;diff.h&quot;
macro_line|#include &quot;diffcore.h&quot;
macro_line|#include &quot;delta.h&quot;
macro_line|#include &quot;xdiff-interface.h&quot;
macro_line|#include &quot;color.h&quot;
macro_line|#include &quot;attr.h&quot;
macro_line|#include &quot;run-command.h&quot;
macro_line|#include &quot;utf8.h&quot;
macro_line|#include &quot;userdiff.h&quot;
macro_line|#include &quot;sigchain.h&quot;
macro_line|#include &quot;submodule.h&quot;
macro_line|#include &quot;ll-merge.h&quot;
macro_line|#include &quot;string-list.h&quot;
macro_line|#include &quot;argv-array.h&quot;
macro_line|#ifdef NO_FAST_WORKING_DIRECTORY
DECL|macro|FAST_WORKING_DIRECTORY
mdefine_line|#define FAST_WORKING_DIRECTORY 0
macro_line|#else
DECL|macro|FAST_WORKING_DIRECTORY
mdefine_line|#define FAST_WORKING_DIRECTORY 1
macro_line|#endif
DECL|variable|diff_detect_rename_default
r_static
r_int
id|diff_detect_rename_default
suffix:semicolon
DECL|variable|diff_rename_limit_default
r_static
r_int
id|diff_rename_limit_default
op_assign
l_int|400
suffix:semicolon
DECL|variable|diff_suppress_blank_empty
r_static
r_int
id|diff_suppress_blank_empty
suffix:semicolon
DECL|variable|diff_use_color_default
r_static
r_int
id|diff_use_color_default
op_assign
l_int|1
suffix:semicolon
DECL|variable|diff_context_default
r_static
r_int
id|diff_context_default
op_assign
l_int|3
suffix:semicolon
DECL|variable|diff_word_regex_cfg
r_static
r_const
r_char
op_star
id|diff_word_regex_cfg
suffix:semicolon
DECL|variable|external_diff_cmd_cfg
r_static
r_const
r_char
op_star
id|external_diff_cmd_cfg
suffix:semicolon
DECL|variable|diff_order_file_cfg
r_static
r_const
r_char
op_star
id|diff_order_file_cfg
suffix:semicolon
DECL|variable|diff_auto_refresh_index
r_int
id|diff_auto_refresh_index
op_assign
l_int|1
suffix:semicolon
DECL|variable|diff_mnemonic_prefix
r_static
r_int
id|diff_mnemonic_prefix
suffix:semicolon
DECL|variable|diff_no_prefix
r_static
r_int
id|diff_no_prefix
suffix:semicolon
DECL|variable|diff_stat_graph_width
r_static
r_int
id|diff_stat_graph_width
suffix:semicolon
DECL|variable|diff_dirstat_permille_default
r_static
r_int
id|diff_dirstat_permille_default
op_assign
l_int|30
suffix:semicolon
DECL|variable|default_diff_options
r_static
r_struct
id|diff_options
id|default_diff_options
suffix:semicolon
DECL|variable|diff_algorithm
r_static
r_int
id|diff_algorithm
suffix:semicolon
DECL|variable|diff_colors
r_static
r_char
id|diff_colors
(braket
)braket
(braket
id|COLOR_MAXLEN
)braket
op_assign
(brace
id|GIT_COLOR_RESET
comma
id|GIT_COLOR_NORMAL
comma
multiline_comment|/* PLAIN */
id|GIT_COLOR_BOLD
comma
multiline_comment|/* METAINFO */
id|GIT_COLOR_CYAN
comma
multiline_comment|/* FRAGINFO */
id|GIT_COLOR_RED
comma
multiline_comment|/* OLD */
id|GIT_COLOR_GREEN
comma
multiline_comment|/* NEW */
id|GIT_COLOR_YELLOW
comma
multiline_comment|/* COMMIT */
id|GIT_COLOR_BG_RED
comma
multiline_comment|/* WHITESPACE */
id|GIT_COLOR_NORMAL
comma
multiline_comment|/* FUNCINFO */
)brace
suffix:semicolon
DECL|function|parse_diff_color_slot
r_static
r_int
id|parse_diff_color_slot
c_func
(paren
r_const
r_char
op_star
id|var
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcasecmp
c_func
(paren
id|var
comma
l_string|&quot;plain&quot;
)paren
)paren
r_return
id|DIFF_PLAIN
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcasecmp
c_func
(paren
id|var
comma
l_string|&quot;meta&quot;
)paren
)paren
r_return
id|DIFF_METAINFO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcasecmp
c_func
(paren
id|var
comma
l_string|&quot;frag&quot;
)paren
)paren
r_return
id|DIFF_FRAGINFO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcasecmp
c_func
(paren
id|var
comma
l_string|&quot;old&quot;
)paren
)paren
r_return
id|DIFF_FILE_OLD
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcasecmp
c_func
(paren
id|var
comma
l_string|&quot;new&quot;
)paren
)paren
r_return
id|DIFF_FILE_NEW
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcasecmp
c_func
(paren
id|var
comma
l_string|&quot;commit&quot;
)paren
)paren
r_return
id|DIFF_COMMIT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcasecmp
c_func
(paren
id|var
comma
l_string|&quot;whitespace&quot;
)paren
)paren
r_return
id|DIFF_WHITESPACE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcasecmp
c_func
(paren
id|var
comma
l_string|&quot;func&quot;
)paren
)paren
r_return
id|DIFF_FUNCINFO
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|parse_dirstat_params
r_static
r_int
id|parse_dirstat_params
c_func
(paren
r_struct
id|diff_options
op_star
id|options
comma
r_const
r_char
op_star
id|params_string
comma
r_struct
id|strbuf
op_star
id|errmsg
)paren
(brace
r_char
op_star
id|params_copy
op_assign
id|xstrdup
c_func
(paren
id|params_string
)paren
suffix:semicolon
r_struct
id|string_list
id|params
op_assign
id|STRING_LIST_INIT_NODUP
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_star
id|params_copy
)paren
id|string_list_split_in_place
c_func
(paren
op_amp
id|params
comma
id|params_copy
comma
l_char|&squot;,&squot;
comma
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|params.nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_char
op_star
id|p
op_assign
id|params.items
(braket
id|i
)braket
dot
id|string
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|p
comma
l_string|&quot;changes&quot;
)paren
)paren
(brace
id|DIFF_OPT_CLR
c_func
(paren
id|options
comma
id|DIRSTAT_BY_LINE
)paren
suffix:semicolon
id|DIFF_OPT_CLR
c_func
(paren
id|options
comma
id|DIRSTAT_BY_FILE
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|p
comma
l_string|&quot;lines&quot;
)paren
)paren
(brace
id|DIFF_OPT_SET
c_func
(paren
id|options
comma
id|DIRSTAT_BY_LINE
)paren
suffix:semicolon
id|DIFF_OPT_CLR
c_func
(paren
id|options
comma
id|DIRSTAT_BY_FILE
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|p
comma
l_string|&quot;files&quot;
)paren
)paren
(brace
id|DIFF_OPT_CLR
c_func
(paren
id|options
comma
id|DIRSTAT_BY_LINE
)paren
suffix:semicolon
id|DIFF_OPT_SET
c_func
(paren
id|options
comma
id|DIRSTAT_BY_FILE
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|p
comma
l_string|&quot;noncumulative&quot;
)paren
)paren
(brace
id|DIFF_OPT_CLR
c_func
(paren
id|options
comma
id|DIRSTAT_CUMULATIVE
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|p
comma
l_string|&quot;cumulative&quot;
)paren
)paren
(brace
id|DIFF_OPT_SET
c_func
(paren
id|options
comma
id|DIRSTAT_CUMULATIVE
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|isdigit
c_func
(paren
op_star
id|p
)paren
)paren
(brace
r_char
op_star
id|end
suffix:semicolon
r_int
id|permille
op_assign
id|strtoul
c_func
(paren
id|p
comma
op_amp
id|end
comma
l_int|10
)paren
op_star
l_int|10
suffix:semicolon
r_if
c_cond
(paren
op_star
id|end
op_eq
l_char|&squot;.&squot;
op_logical_and
id|isdigit
c_func
(paren
op_star
op_increment
id|end
)paren
)paren
(brace
multiline_comment|/* only use first digit */
id|permille
op_add_assign
op_star
id|end
l_char|&squot;0&squot;
suffix:semicolon
multiline_comment|/* .. and ignore any further digits */
r_while
c_loop
(paren
id|isdigit
c_func
(paren
op_star
op_increment
id|end
)paren
)paren
suffix:semicolon
multiline_comment|/* nothing */
)brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|end
)paren
id|options-&gt;dirstat_permille
op_assign
id|permille
suffix:semicolon
r_else
(brace
id|strbuf_addf
c_func
(paren
id|errmsg
comma
id|_
c_func
(paren
l_string|&quot;  Failed to parse dirstat cut-off percentage &squot;%s&squot;&bslash;n&quot;
)paren
comma
id|p
)paren
suffix:semicolon
id|ret
op_increment
suffix:semicolon
)brace
)brace
r_else
(brace
id|strbuf_addf
c_func
(paren
id|errmsg
comma
id|_
c_func
(paren
l_string|&quot;  Unknown dirstat parameter &squot;%s&squot;&bslash;n&quot;
)paren
comma
id|p
)paren
suffix:semicolon
id|ret
op_increment
suffix:semicolon
)brace
)brace
id|string_list_clear
c_func
(paren
op_amp
id|params
comma
l_int|0
)paren
suffix:semicolon
id|free
c_func
(paren
id|params_copy
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|parse_submodule_params
r_static
r_int
id|parse_submodule_params
c_func
(paren
r_struct
id|diff_options
op_star
id|options
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|value
comma
l_string|&quot;log&quot;
)paren
)paren
id|DIFF_OPT_SET
c_func
(paren
id|options
comma
id|SUBMODULE_LOG
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|value
comma
l_string|&quot;short&quot;
)paren
)paren
id|DIFF_OPT_CLR
c_func
(paren
id|options
comma
id|SUBMODULE_LOG
)paren
suffix:semicolon
r_else
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|git_config_rename
r_static
r_int
id|git_config_rename
c_func
(paren
r_const
r_char
op_star
id|var
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
r_return
id|DIFF_DETECT_RENAME
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;copies&quot;
)paren
op_logical_or
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;copy&quot;
)paren
)paren
r_return
id|DIFF_DETECT_COPY
suffix:semicolon
r_return
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
ques
c_cond
id|DIFF_DETECT_RENAME
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|function|parse_algorithm_value
r_int
id|parse_algorithm_value
c_func
(paren
r_const
r_char
op_star
id|value
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
r_return
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;myers&quot;
)paren
op_logical_or
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;default&quot;
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;minimal&quot;
)paren
)paren
r_return
id|XDF_NEED_MINIMAL
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;patience&quot;
)paren
)paren
r_return
id|XDF_PATIENCE_DIFF
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcasecmp
c_func
(paren
id|value
comma
l_string|&quot;histogram&quot;
)paren
)paren
r_return
id|XDF_HISTOGRAM_DIFF
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * These are to give UI layer defaults.&n; * The core-level commands such as git-diff-files should&n; * never be affected by the setting of diff.renames&n; * the user happens to have in the configuration file.&n; */
DECL|function|git_diff_ui_config
r_int
id|git_diff_ui_config
c_func
(paren
r_const
r_char
op_star
id|var
comma
r_const
r_char
op_star
id|value
comma
r_void
op_star
id|cb
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;diff.color&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;color.diff&quot;
)paren
)paren
(brace
id|diff_use_color_default
op_assign
id|git_config_colorbool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;diff.context&quot;
)paren
)paren
(brace
id|diff_context_default
op_assign
id|git_config_int
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|diff_context_default
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;diff.renames&quot;
)paren
)paren
(brace
id|diff_detect_rename_default
op_assign
id|git_config_rename
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;diff.autorefreshindex&quot;
)paren
)paren
(brace
id|diff_auto_refresh_index
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;diff.mnemonicprefix&quot;
)paren
)paren
(brace
id|diff_mnemonic_prefix
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;diff.noprefix&quot;
)paren
)paren
(brace
id|diff_no_prefix
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;diff.statgraphwidth&quot;
)paren
)paren
(brace
id|diff_stat_graph_width
op_assign
id|git_config_int
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;diff.external&quot;
)paren
)paren
r_return
id|git_config_string
c_func
(paren
op_amp
id|external_diff_cmd_cfg
comma
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;diff.wordregex&quot;
)paren
)paren
r_return
id|git_config_string
c_func
(paren
op_amp
id|diff_word_regex_cfg
comma
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;diff.orderfile&quot;
)paren
)paren
r_return
id|git_config_pathname
c_func
(paren
op_amp
id|diff_order_file_cfg
comma
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;diff.ignoresubmodules&quot;
)paren
)paren
id|handle_ignore_submodules_arg
c_func
(paren
op_amp
id|default_diff_options
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;diff.submodule&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|parse_submodule_params
c_func
(paren
op_amp
id|default_diff_options
comma
id|value
)paren
)paren
id|warning
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Unknown value for &squot;diff.submodule&squot; config variable: &squot;%s&squot;&quot;
)paren
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;diff.algorithm&quot;
)paren
)paren
(brace
id|diff_algorithm
op_assign
id|parse_algorithm_value
c_func
(paren
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|diff_algorithm
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|git_color_config
c_func
(paren
id|var
comma
id|value
comma
id|cb
)paren
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_return
id|git_diff_basic_config
c_func
(paren
id|var
comma
id|value
comma
id|cb
)paren
suffix:semicolon
)brace
DECL|function|git_diff_basic_config
r_int
id|git_diff_basic_config
c_func
(paren
r_const
r_char
op_star
id|var
comma
r_const
r_char
op_star
id|value
comma
r_void
op_star
id|cb
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;diff.renamelimit&quot;
)paren
)paren
(brace
id|diff_rename_limit_default
op_assign
id|git_config_int
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|userdiff_config
c_func
(paren
id|var
comma
id|value
)paren
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|var
comma
l_string|&quot;diff.color.&quot;
)paren
op_logical_or
id|starts_with
c_func
(paren
id|var
comma
l_string|&quot;color.diff.&quot;
)paren
)paren
(brace
r_int
id|slot
op_assign
id|parse_diff_color_slot
c_func
(paren
id|var
op_plus
l_int|11
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slot
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
r_return
id|config_error_nonbool
c_func
(paren
id|var
)paren
suffix:semicolon
id|color_parse
c_func
(paren
id|value
comma
id|var
comma
id|diff_colors
(braket
id|slot
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* like GNU diff&squot;s --suppress-blank-empty option  */
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;diff.suppressblankempty&quot;
)paren
op_logical_or
multiline_comment|/* for backwards compatibility */
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;diff.suppress-blank-empty&quot;
)paren
)paren
(brace
id|diff_suppress_blank_empty
op_assign
id|git_config_bool
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|var
comma
l_string|&quot;diff.dirstat&quot;
)paren
)paren
(brace
r_struct
id|strbuf
id|errmsg
op_assign
id|STRBUF_INIT
suffix:semicolon
id|default_diff_options.dirstat_permille
op_assign
id|diff_dirstat_permille_default
suffix:semicolon
r_if
c_cond
(paren
id|parse_dirstat_params
c_func
(paren
op_amp
id|default_diff_options
comma
id|value
comma
op_amp
id|errmsg
)paren
)paren
id|warning
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Found errors in &squot;diff.dirstat&squot; config variable:&bslash;n%s&quot;
)paren
comma
id|errmsg.buf
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|errmsg
)paren
suffix:semicolon
id|diff_dirstat_permille_default
op_assign
id|default_diff_options.dirstat_permille
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|var
comma
l_string|&quot;submodule.&quot;
)paren
)paren
r_return
id|parse_submodule_config_option
c_func
(paren
id|var
comma
id|value
)paren
suffix:semicolon
r_return
id|git_default_config
c_func
(paren
id|var
comma
id|value
comma
id|cb
)paren
suffix:semicolon
)brace
DECL|function|quote_two
r_static
r_char
op_star
id|quote_two
c_func
(paren
r_const
r_char
op_star
id|one
comma
r_const
r_char
op_star
id|two
)paren
(brace
r_int
id|need_one
op_assign
id|quote_c_style
c_func
(paren
id|one
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|1
)paren
suffix:semicolon
r_int
id|need_two
op_assign
id|quote_c_style
c_func
(paren
id|two
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|1
)paren
suffix:semicolon
r_struct
id|strbuf
id|res
op_assign
id|STRBUF_INIT
suffix:semicolon
r_if
c_cond
(paren
id|need_one
op_plus
id|need_two
)paren
(brace
id|strbuf_addch
c_func
(paren
op_amp
id|res
comma
l_char|&squot;&quot;&squot;
)paren
suffix:semicolon
id|quote_c_style
c_func
(paren
id|one
comma
op_amp
id|res
comma
l_int|NULL
comma
l_int|1
)paren
suffix:semicolon
id|quote_c_style
c_func
(paren
id|two
comma
op_amp
id|res
comma
l_int|NULL
comma
l_int|1
)paren
suffix:semicolon
id|strbuf_addch
c_func
(paren
op_amp
id|res
comma
l_char|&squot;&quot;&squot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|strbuf_addstr
c_func
(paren
op_amp
id|res
comma
id|one
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|res
comma
id|two
)paren
suffix:semicolon
)brace
r_return
id|strbuf_detach
c_func
(paren
op_amp
id|res
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|external_diff
r_static
r_const
r_char
op_star
id|external_diff
c_func
(paren
r_void
)paren
(brace
r_static
r_const
r_char
op_star
id|external_diff_cmd
op_assign
l_int|NULL
suffix:semicolon
r_static
r_int
id|done_preparing
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|done_preparing
)paren
r_return
id|external_diff_cmd
suffix:semicolon
id|external_diff_cmd
op_assign
id|getenv
c_func
(paren
l_string|&quot;GIT_EXTERNAL_DIFF&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|external_diff_cmd
)paren
id|external_diff_cmd
op_assign
id|external_diff_cmd_cfg
suffix:semicolon
id|done_preparing
op_assign
l_int|1
suffix:semicolon
r_return
id|external_diff_cmd
suffix:semicolon
)brace
DECL|struct|diff_tempfile
r_static
r_struct
id|diff_tempfile
(brace
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
multiline_comment|/* filename external diff should read from */
DECL|member|hex
r_char
id|hex
(braket
l_int|41
)braket
suffix:semicolon
DECL|member|mode
r_char
id|mode
(braket
l_int|10
)braket
suffix:semicolon
DECL|member|tmp_path
r_char
id|tmp_path
(braket
id|PATH_MAX
)braket
suffix:semicolon
DECL|variable|diff_temp
)brace
id|diff_temp
(braket
l_int|2
)braket
suffix:semicolon
DECL|typedef|sane_truncate_fn
r_typedef
r_int
r_int
(paren
op_star
id|sane_truncate_fn
)paren
(paren
r_char
op_star
id|line
comma
r_int
r_int
id|len
)paren
suffix:semicolon
DECL|struct|emit_callback
r_struct
id|emit_callback
(brace
DECL|member|color_diff
r_int
id|color_diff
suffix:semicolon
DECL|member|ws_rule
r_int
id|ws_rule
suffix:semicolon
DECL|member|blank_at_eof_in_preimage
r_int
id|blank_at_eof_in_preimage
suffix:semicolon
DECL|member|blank_at_eof_in_postimage
r_int
id|blank_at_eof_in_postimage
suffix:semicolon
DECL|member|lno_in_preimage
r_int
id|lno_in_preimage
suffix:semicolon
DECL|member|lno_in_postimage
r_int
id|lno_in_postimage
suffix:semicolon
DECL|member|truncate
id|sane_truncate_fn
id|truncate
suffix:semicolon
DECL|member|label_path
r_const
r_char
op_star
op_star
id|label_path
suffix:semicolon
DECL|member|diff_words
r_struct
id|diff_words_data
op_star
id|diff_words
suffix:semicolon
DECL|member|opt
r_struct
id|diff_options
op_star
id|opt
suffix:semicolon
DECL|member|found_changesp
r_int
op_star
id|found_changesp
suffix:semicolon
DECL|member|header
r_struct
id|strbuf
op_star
id|header
suffix:semicolon
)brace
suffix:semicolon
DECL|function|count_lines
r_static
r_int
id|count_lines
c_func
(paren
r_const
r_char
op_star
id|data
comma
r_int
id|size
)paren
(brace
r_int
id|count
comma
id|ch
comma
id|completely_empty
op_assign
l_int|1
comma
id|nl_just_seen
op_assign
l_int|0
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
l_int|0
OL
id|size
op_decrement
)paren
(brace
id|ch
op_assign
op_star
id|data
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|count
op_increment
suffix:semicolon
id|nl_just_seen
op_assign
l_int|1
suffix:semicolon
id|completely_empty
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|nl_just_seen
op_assign
l_int|0
suffix:semicolon
id|completely_empty
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|completely_empty
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nl_just_seen
)paren
id|count
op_increment
suffix:semicolon
multiline_comment|/* no trailing newline */
r_return
id|count
suffix:semicolon
)brace
DECL|function|fill_mmfile
r_static
r_int
id|fill_mmfile
c_func
(paren
id|mmfile_t
op_star
id|mf
comma
r_struct
id|diff_filespec
op_star
id|one
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|DIFF_FILE_VALID
c_func
(paren
id|one
)paren
)paren
(brace
id|mf-&gt;ptr
op_assign
(paren
r_char
op_star
)paren
l_string|&quot;&quot;
suffix:semicolon
multiline_comment|/* does not matter */
id|mf-&gt;size
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|diff_populate_filespec
c_func
(paren
id|one
comma
l_int|0
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|mf-&gt;ptr
op_assign
id|one-&gt;data
suffix:semicolon
id|mf-&gt;size
op_assign
id|one-&gt;size
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* like fill_mmfile, but only for size, so we can avoid retrieving blob */
DECL|function|diff_filespec_size
r_static
r_int
r_int
id|diff_filespec_size
c_func
(paren
r_struct
id|diff_filespec
op_star
id|one
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|DIFF_FILE_VALID
c_func
(paren
id|one
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|diff_populate_filespec
c_func
(paren
id|one
comma
l_int|1
)paren
suffix:semicolon
r_return
id|one-&gt;size
suffix:semicolon
)brace
DECL|function|count_trailing_blank
r_static
r_int
id|count_trailing_blank
c_func
(paren
id|mmfile_t
op_star
id|mf
comma
r_int
id|ws_rule
)paren
(brace
r_char
op_star
id|ptr
op_assign
id|mf-&gt;ptr
suffix:semicolon
r_int
id|size
op_assign
id|mf-&gt;size
suffix:semicolon
r_int
id|cnt
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|size
)paren
r_return
id|cnt
suffix:semicolon
id|ptr
op_add_assign
id|size
l_int|1
suffix:semicolon
multiline_comment|/* pointing at the very end */
r_if
c_cond
(paren
op_star
id|ptr
op_ne
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
multiline_comment|/* incomplete line */
r_else
id|ptr
op_decrement
suffix:semicolon
multiline_comment|/* skip the last LF */
r_while
c_loop
(paren
id|mf-&gt;ptr
OL
id|ptr
)paren
(brace
r_char
op_star
id|prev_eol
suffix:semicolon
r_for
c_loop
(paren
id|prev_eol
op_assign
id|ptr
suffix:semicolon
id|mf-&gt;ptr
op_le
id|prev_eol
suffix:semicolon
id|prev_eol
op_decrement
)paren
r_if
c_cond
(paren
op_star
id|prev_eol
op_eq
l_char|&squot;&bslash;n&squot;
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ws_blank_line
c_func
(paren
id|prev_eol
op_plus
l_int|1
comma
id|ptr
id|prev_eol
comma
id|ws_rule
)paren
)paren
r_break
suffix:semicolon
id|cnt
op_increment
suffix:semicolon
id|ptr
op_assign
id|prev_eol
l_int|1
suffix:semicolon
)brace
r_return
id|cnt
suffix:semicolon
)brace
DECL|function|check_blank_at_eof
r_static
r_void
id|check_blank_at_eof
c_func
(paren
id|mmfile_t
op_star
id|mf1
comma
id|mmfile_t
op_star
id|mf2
comma
r_struct
id|emit_callback
op_star
id|ecbdata
)paren
(brace
r_int
id|l1
comma
id|l2
comma
id|at
suffix:semicolon
r_int
id|ws_rule
op_assign
id|ecbdata-&gt;ws_rule
suffix:semicolon
id|l1
op_assign
id|count_trailing_blank
c_func
(paren
id|mf1
comma
id|ws_rule
)paren
suffix:semicolon
id|l2
op_assign
id|count_trailing_blank
c_func
(paren
id|mf2
comma
id|ws_rule
)paren
suffix:semicolon
r_if
c_cond
(paren
id|l2
op_le
id|l1
)paren
(brace
id|ecbdata-&gt;blank_at_eof_in_preimage
op_assign
l_int|0
suffix:semicolon
id|ecbdata-&gt;blank_at_eof_in_postimage
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
id|at
op_assign
id|count_lines
c_func
(paren
id|mf1-&gt;ptr
comma
id|mf1-&gt;size
)paren
suffix:semicolon
id|ecbdata-&gt;blank_at_eof_in_preimage
op_assign
(paren
id|at
id|l1
)paren
op_plus
l_int|1
suffix:semicolon
id|at
op_assign
id|count_lines
c_func
(paren
id|mf2-&gt;ptr
comma
id|mf2-&gt;size
)paren
suffix:semicolon
id|ecbdata-&gt;blank_at_eof_in_postimage
op_assign
(paren
id|at
id|l2
)paren
op_plus
l_int|1
suffix:semicolon
)brace
DECL|function|emit_line_0
r_static
r_void
id|emit_line_0
c_func
(paren
r_struct
id|diff_options
op_star
id|o
comma
r_const
r_char
op_star
id|set
comma
r_const
r_char
op_star
id|reset
comma
r_int
id|first
comma
r_const
r_char
op_star
id|line
comma
r_int
id|len
)paren
(brace
r_int
id|has_trailing_newline
comma
id|has_trailing_carriage_return
suffix:semicolon
r_int
id|nofirst
suffix:semicolon
id|FILE
op_star
id|file
op_assign
id|o-&gt;file
suffix:semicolon
id|fputs
c_func
(paren
id|diff_line_prefix
c_func
(paren
id|o
)paren
comma
id|file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
l_int|0
)paren
(brace
id|has_trailing_newline
op_assign
(paren
id|first
op_eq
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|has_trailing_carriage_return
op_assign
(paren
op_logical_neg
id|has_trailing_newline
op_logical_and
(paren
id|first
op_eq
l_char|&squot;&bslash;r&squot;
)paren
)paren
suffix:semicolon
id|nofirst
op_assign
id|has_trailing_newline
op_logical_or
id|has_trailing_carriage_return
suffix:semicolon
)brace
r_else
(brace
id|has_trailing_newline
op_assign
(paren
id|len
OG
l_int|0
op_logical_and
id|line
(braket
id|len
op_minus
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|has_trailing_newline
)paren
id|len
op_decrement
suffix:semicolon
id|has_trailing_carriage_return
op_assign
(paren
id|len
OG
l_int|0
op_logical_and
id|line
(braket
id|len
op_minus
l_int|1
)braket
op_eq
l_char|&squot;&bslash;r&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|has_trailing_carriage_return
)paren
id|len
op_decrement
suffix:semicolon
id|nofirst
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
op_logical_or
op_logical_neg
id|nofirst
)paren
(brace
id|fputs
c_func
(paren
id|set
comma
id|file
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nofirst
)paren
id|fputc
c_func
(paren
id|first
comma
id|file
)paren
suffix:semicolon
id|fwrite
c_func
(paren
id|line
comma
id|len
comma
l_int|1
comma
id|file
)paren
suffix:semicolon
id|fputs
c_func
(paren
id|reset
comma
id|file
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|has_trailing_carriage_return
)paren
id|fputc
c_func
(paren
l_char|&squot;&bslash;r&squot;
comma
id|file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|has_trailing_newline
)paren
id|fputc
c_func
(paren
l_char|&squot;&bslash;n&squot;
comma
id|file
)paren
suffix:semicolon
)brace
DECL|function|emit_line
r_static
r_void
id|emit_line
c_func
(paren
r_struct
id|diff_options
op_star
id|o
comma
r_const
r_char
op_star
id|set
comma
r_const
r_char
op_star
id|reset
comma
r_const
r_char
op_star
id|line
comma
r_int
id|len
)paren
(brace
id|emit_line_0
c_func
(paren
id|o
comma
id|set
comma
id|reset
comma
id|line
(braket
l_int|0
)braket
comma
id|line
op_plus
l_int|1
comma
id|len
op_minus
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|new_blank_line_at_eof
r_static
r_int
id|new_blank_line_at_eof
c_func
(paren
r_struct
id|emit_callback
op_star
id|ecbdata
comma
r_const
r_char
op_star
id|line
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|ecbdata-&gt;ws_rule
op_amp
id|WS_BLANK_AT_EOF
)paren
op_logical_and
id|ecbdata-&gt;blank_at_eof_in_preimage
op_logical_and
id|ecbdata-&gt;blank_at_eof_in_postimage
op_logical_and
id|ecbdata-&gt;blank_at_eof_in_preimage
op_le
id|ecbdata-&gt;lno_in_preimage
op_logical_and
id|ecbdata-&gt;blank_at_eof_in_postimage
op_le
id|ecbdata-&gt;lno_in_postimage
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|ws_blank_line
c_func
(paren
id|line
comma
id|len
comma
id|ecbdata-&gt;ws_rule
)paren
suffix:semicolon
)brace
DECL|function|emit_add_line
r_static
r_void
id|emit_add_line
c_func
(paren
r_const
r_char
op_star
id|reset
comma
r_struct
id|emit_callback
op_star
id|ecbdata
comma
r_const
r_char
op_star
id|line
comma
r_int
id|len
)paren
(brace
r_const
r_char
op_star
id|ws
op_assign
id|diff_get_color
c_func
(paren
id|ecbdata-&gt;color_diff
comma
id|DIFF_WHITESPACE
)paren
suffix:semicolon
r_const
r_char
op_star
id|set
op_assign
id|diff_get_color
c_func
(paren
id|ecbdata-&gt;color_diff
comma
id|DIFF_FILE_NEW
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|ws
)paren
id|emit_line_0
c_func
(paren
id|ecbdata-&gt;opt
comma
id|set
comma
id|reset
comma
l_char|&squot;+&squot;
comma
id|line
comma
id|len
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|new_blank_line_at_eof
c_func
(paren
id|ecbdata
comma
id|line
comma
id|len
)paren
)paren
multiline_comment|/* Blank line at EOF - paint &squot;+&squot; as well */
id|emit_line_0
c_func
(paren
id|ecbdata-&gt;opt
comma
id|ws
comma
id|reset
comma
l_char|&squot;+&squot;
comma
id|line
comma
id|len
)paren
suffix:semicolon
r_else
(brace
multiline_comment|/* Emit just the prefix, then the rest. */
id|emit_line_0
c_func
(paren
id|ecbdata-&gt;opt
comma
id|set
comma
id|reset
comma
l_char|&squot;+&squot;
comma
l_string|&quot;&quot;
comma
l_int|0
)paren
suffix:semicolon
id|ws_check_emit
c_func
(paren
id|line
comma
id|len
comma
id|ecbdata-&gt;ws_rule
comma
id|ecbdata-&gt;opt-&gt;file
comma
id|set
comma
id|reset
comma
id|ws
)paren
suffix:semicolon
)brace
)brace
DECL|function|emit_hunk_header
r_static
r_void
id|emit_hunk_header
c_func
(paren
r_struct
id|emit_callback
op_star
id|ecbdata
comma
r_const
r_char
op_star
id|line
comma
r_int
id|len
)paren
(brace
r_const
r_char
op_star
id|plain
op_assign
id|diff_get_color
c_func
(paren
id|ecbdata-&gt;color_diff
comma
id|DIFF_PLAIN
)paren
suffix:semicolon
r_const
r_char
op_star
id|frag
op_assign
id|diff_get_color
c_func
(paren
id|ecbdata-&gt;color_diff
comma
id|DIFF_FRAGINFO
)paren
suffix:semicolon
r_const
r_char
op_star
id|func
op_assign
id|diff_get_color
c_func
(paren
id|ecbdata-&gt;color_diff
comma
id|DIFF_FUNCINFO
)paren
suffix:semicolon
r_const
r_char
op_star
id|reset
op_assign
id|diff_get_color
c_func
(paren
id|ecbdata-&gt;color_diff
comma
id|DIFF_RESET
)paren
suffix:semicolon
r_static
r_const
r_char
id|atat
(braket
l_int|2
)braket
op_assign
(brace
l_char|&squot;@&squot;
comma
l_char|&squot;@&squot;
)brace
suffix:semicolon
r_const
r_char
op_star
id|cp
comma
op_star
id|ep
suffix:semicolon
r_struct
id|strbuf
id|msgbuf
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|org_len
op_assign
id|len
suffix:semicolon
r_int
id|i
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * As a hunk header must begin with &quot;@@ -&lt;old&gt;, +&lt;new&gt; @@&quot;,&n;&t; * it always is at least 10 bytes long.&n;&t; */
r_if
c_cond
(paren
id|len
OL
l_int|10
op_logical_or
id|memcmp
c_func
(paren
id|line
comma
id|atat
comma
l_int|2
)paren
op_logical_or
op_logical_neg
(paren
id|ep
op_assign
id|memmem
c_func
(paren
id|line
op_plus
l_int|2
comma
id|len
l_int|2
comma
id|atat
comma
l_int|2
)paren
)paren
)paren
(brace
id|emit_line
c_func
(paren
id|ecbdata-&gt;opt
comma
id|plain
comma
id|reset
comma
id|line
comma
id|len
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ep
op_add_assign
l_int|2
suffix:semicolon
multiline_comment|/* skip over @@ */
multiline_comment|/* The hunk header in fraginfo color */
id|strbuf_add
c_func
(paren
op_amp
id|msgbuf
comma
id|frag
comma
id|strlen
c_func
(paren
id|frag
)paren
)paren
suffix:semicolon
id|strbuf_add
c_func
(paren
op_amp
id|msgbuf
comma
id|line
comma
id|ep
id|line
)paren
suffix:semicolon
id|strbuf_add
c_func
(paren
op_amp
id|msgbuf
comma
id|reset
comma
id|strlen
c_func
(paren
id|reset
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * trailing &quot;&bslash;r&bslash;n&quot;&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|line
(braket
id|len
id|i
)braket
op_eq
l_char|&squot;&bslash;r&squot;
op_logical_or
id|line
(braket
id|len
id|i
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|len
op_decrement
suffix:semicolon
multiline_comment|/* blank before the func header */
r_for
c_loop
(paren
id|cp
op_assign
id|ep
suffix:semicolon
id|ep
id|line
OL
id|len
suffix:semicolon
id|ep
op_increment
)paren
r_if
c_cond
(paren
op_star
id|ep
op_ne
l_char|&squot; &squot;
op_logical_and
op_star
id|ep
op_ne
l_char|&squot;&bslash;t&squot;
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|ep
op_ne
id|cp
)paren
(brace
id|strbuf_add
c_func
(paren
op_amp
id|msgbuf
comma
id|plain
comma
id|strlen
c_func
(paren
id|plain
)paren
)paren
suffix:semicolon
id|strbuf_add
c_func
(paren
op_amp
id|msgbuf
comma
id|cp
comma
id|ep
id|cp
)paren
suffix:semicolon
id|strbuf_add
c_func
(paren
op_amp
id|msgbuf
comma
id|reset
comma
id|strlen
c_func
(paren
id|reset
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ep
OL
id|line
op_plus
id|len
)paren
(brace
id|strbuf_add
c_func
(paren
op_amp
id|msgbuf
comma
id|func
comma
id|strlen
c_func
(paren
id|func
)paren
)paren
suffix:semicolon
id|strbuf_add
c_func
(paren
op_amp
id|msgbuf
comma
id|ep
comma
id|line
op_plus
id|len
id|ep
)paren
suffix:semicolon
id|strbuf_add
c_func
(paren
op_amp
id|msgbuf
comma
id|reset
comma
id|strlen
c_func
(paren
id|reset
)paren
)paren
suffix:semicolon
)brace
id|strbuf_add
c_func
(paren
op_amp
id|msgbuf
comma
id|line
op_plus
id|len
comma
id|org_len
id|len
)paren
suffix:semicolon
id|emit_line
c_func
(paren
id|ecbdata-&gt;opt
comma
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
id|msgbuf.buf
comma
id|msgbuf.len
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|msgbuf
)paren
suffix:semicolon
)brace
DECL|function|claim_diff_tempfile
r_static
r_struct
id|diff_tempfile
op_star
id|claim_diff_tempfile
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|diff_temp
)paren
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|diff_temp
(braket
id|i
)braket
dot
id|name
)paren
r_return
id|diff_temp
op_plus
id|i
suffix:semicolon
id|die
c_func
(paren
l_string|&quot;BUG: diff is failing to clean up its tempfiles&quot;
)paren
suffix:semicolon
)brace
DECL|variable|remove_tempfile_installed
r_static
r_int
id|remove_tempfile_installed
suffix:semicolon
DECL|function|remove_tempfile
r_static
r_void
id|remove_tempfile
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|diff_temp
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|diff_temp
(braket
id|i
)braket
dot
id|name
op_eq
id|diff_temp
(braket
id|i
)braket
dot
id|tmp_path
)paren
id|unlink_or_warn
c_func
(paren
id|diff_temp
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
id|diff_temp
(braket
id|i
)braket
dot
id|name
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
DECL|function|remove_tempfile_on_signal
r_static
r_void
id|remove_tempfile_on_signal
c_func
(paren
r_int
id|signo
)paren
(brace
id|remove_tempfile
c_func
(paren
)paren
suffix:semicolon
id|sigchain_pop
c_func
(paren
id|signo
)paren
suffix:semicolon
id|raise
c_func
(paren
id|signo
)paren
suffix:semicolon
)brace
DECL|function|print_line_count
r_static
r_void
id|print_line_count
c_func
(paren
id|FILE
op_star
id|file
comma
r_int
id|count
)paren
(brace
r_switch
c_cond
(paren
id|count
)paren
(brace
r_case
l_int|0
suffix:colon
id|fprintf
c_func
(paren
id|file
comma
l_string|&quot;0,0&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|fprintf
c_func
(paren
id|file
comma
l_string|&quot;1&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|fprintf
c_func
(paren
id|file
comma
l_string|&quot;1,%d&quot;
comma
id|count
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|function|emit_rewrite_lines
r_static
r_void
id|emit_rewrite_lines
c_func
(paren
r_struct
id|emit_callback
op_star
id|ecb
comma
r_int
id|prefix
comma
r_const
r_char
op_star
id|data
comma
r_int
id|size
)paren
(brace
r_const
r_char
op_star
id|endp
op_assign
l_int|NULL
suffix:semicolon
r_static
r_const
r_char
op_star
id|nneof
op_assign
l_string|&quot; No newline at end of file&bslash;n&quot;
suffix:semicolon
r_const
r_char
op_star
id|old
op_assign
id|diff_get_color
c_func
(paren
id|ecb-&gt;color_diff
comma
id|DIFF_FILE_OLD
)paren
suffix:semicolon
r_const
r_char
op_star
id|reset
op_assign
id|diff_get_color
c_func
(paren
id|ecb-&gt;color_diff
comma
id|DIFF_RESET
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|0
OL
id|size
)paren
(brace
r_int
id|len
suffix:semicolon
id|endp
op_assign
id|memchr
c_func
(paren
id|data
comma
l_char|&squot;&bslash;n&squot;
comma
id|size
)paren
suffix:semicolon
id|len
op_assign
id|endp
ques
c_cond
(paren
id|endp
id|data
op_plus
l_int|1
)paren
suffix:colon
id|size
suffix:semicolon
r_if
c_cond
(paren
id|prefix
op_ne
l_char|&squot;+&squot;
)paren
(brace
id|ecb-&gt;lno_in_preimage
op_increment
suffix:semicolon
id|emit_line_0
c_func
(paren
id|ecb-&gt;opt
comma
id|old
comma
id|reset
comma
l_char|&squot;-&squot;
comma
id|data
comma
id|len
)paren
suffix:semicolon
)brace
r_else
(brace
id|ecb-&gt;lno_in_postimage
op_increment
suffix:semicolon
id|emit_add_line
c_func
(paren
id|reset
comma
id|ecb
comma
id|data
comma
id|len
)paren
suffix:semicolon
)brace
id|size
op_sub_assign
id|len
suffix:semicolon
id|data
op_add_assign
id|len
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|endp
)paren
(brace
r_const
r_char
op_star
id|plain
op_assign
id|diff_get_color
c_func
(paren
id|ecb-&gt;color_diff
comma
id|DIFF_PLAIN
)paren
suffix:semicolon
id|putc
c_func
(paren
l_char|&squot;&bslash;n&squot;
comma
id|ecb-&gt;opt-&gt;file
)paren
suffix:semicolon
id|emit_line_0
c_func
(paren
id|ecb-&gt;opt
comma
id|plain
comma
id|reset
comma
l_char|&squot;&bslash;&bslash;&squot;
comma
id|nneof
comma
id|strlen
c_func
(paren
id|nneof
)paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|emit_rewrite_diff
r_static
r_void
id|emit_rewrite_diff
c_func
(paren
r_const
r_char
op_star
id|name_a
comma
r_const
r_char
op_star
id|name_b
comma
r_struct
id|diff_filespec
op_star
id|one
comma
r_struct
id|diff_filespec
op_star
id|two
comma
r_struct
id|userdiff_driver
op_star
id|textconv_one
comma
r_struct
id|userdiff_driver
op_star
id|textconv_two
comma
r_struct
id|diff_options
op_star
id|o
)paren
(brace
r_int
id|lc_a
comma
id|lc_b
suffix:semicolon
r_const
r_char
op_star
id|name_a_tab
comma
op_star
id|name_b_tab
suffix:semicolon
r_const
r_char
op_star
id|metainfo
op_assign
id|diff_get_color
c_func
(paren
id|o-&gt;use_color
comma
id|DIFF_METAINFO
)paren
suffix:semicolon
r_const
r_char
op_star
id|fraginfo
op_assign
id|diff_get_color
c_func
(paren
id|o-&gt;use_color
comma
id|DIFF_FRAGINFO
)paren
suffix:semicolon
r_const
r_char
op_star
id|reset
op_assign
id|diff_get_color
c_func
(paren
id|o-&gt;use_color
comma
id|DIFF_RESET
)paren
suffix:semicolon
r_static
r_struct
id|strbuf
id|a_name
op_assign
id|STRBUF_INIT
comma
id|b_name
op_assign
id|STRBUF_INIT
suffix:semicolon
r_const
r_char
op_star
id|a_prefix
comma
op_star
id|b_prefix
suffix:semicolon
r_char
op_star
id|data_one
comma
op_star
id|data_two
suffix:semicolon
r_int
id|size_one
comma
id|size_two
suffix:semicolon
r_struct
id|emit_callback
id|ecbdata
suffix:semicolon
r_const
r_char
op_star
id|line_prefix
op_assign
id|diff_line_prefix
c_func
(paren
id|o
)paren
suffix:semicolon
r_if
c_cond
(paren
id|diff_mnemonic_prefix
op_logical_and
id|DIFF_OPT_TST
c_func
(paren
id|o
comma
id|REVERSE_DIFF
)paren
)paren
(brace
id|a_prefix
op_assign
id|o-&gt;b_prefix
suffix:semicolon
id|b_prefix
op_assign
id|o-&gt;a_prefix
suffix:semicolon
)brace
r_else
(brace
id|a_prefix
op_assign
id|o-&gt;a_prefix
suffix:semicolon
id|b_prefix
op_assign
id|o-&gt;b_prefix
suffix:semicolon
)brace
id|name_a
op_add_assign
(paren
op_star
id|name_a
op_eq
l_char|&squot;/&squot;
)paren
suffix:semicolon
id|name_b
op_add_assign
(paren
op_star
id|name_b
op_eq
l_char|&squot;/&squot;
)paren
suffix:semicolon
id|name_a_tab
op_assign
id|strchr
c_func
(paren
id|name_a
comma
l_char|&squot; &squot;
)paren
ques
c_cond
l_string|&quot;&bslash;t&quot;
suffix:colon
l_string|&quot;&quot;
suffix:semicolon
id|name_b_tab
op_assign
id|strchr
c_func
(paren
id|name_b
comma
l_char|&squot; &squot;
)paren
ques
c_cond
l_string|&quot;&bslash;t&quot;
suffix:colon
l_string|&quot;&quot;
suffix:semicolon
id|strbuf_reset
c_func
(paren
op_amp
id|a_name
)paren
suffix:semicolon
id|strbuf_reset
c_func
(paren
op_amp
id|b_name
)paren
suffix:semicolon
id|quote_two_c_style
c_func
(paren
op_amp
id|a_name
comma
id|a_prefix
comma
id|name_a
comma
l_int|0
)paren
suffix:semicolon
id|quote_two_c_style
c_func
(paren
op_amp
id|b_name
comma
id|b_prefix
comma
id|name_b
comma
l_int|0
)paren
suffix:semicolon
id|size_one
op_assign
id|fill_textconv
c_func
(paren
id|textconv_one
comma
id|one
comma
op_amp
id|data_one
)paren
suffix:semicolon
id|size_two
op_assign
id|fill_textconv
c_func
(paren
id|textconv_two
comma
id|two
comma
op_amp
id|data_two
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|ecbdata
comma
l_int|0
comma
r_sizeof
(paren
id|ecbdata
)paren
)paren
suffix:semicolon
id|ecbdata.color_diff
op_assign
id|want_color
c_func
(paren
id|o-&gt;use_color
)paren
suffix:semicolon
id|ecbdata.found_changesp
op_assign
op_amp
id|o-&gt;found_changes
suffix:semicolon
id|ecbdata.ws_rule
op_assign
id|whitespace_rule
c_func
(paren
id|name_b
)paren
suffix:semicolon
id|ecbdata.opt
op_assign
id|o
suffix:semicolon
r_if
c_cond
(paren
id|ecbdata.ws_rule
op_amp
id|WS_BLANK_AT_EOF
)paren
(brace
id|mmfile_t
id|mf1
comma
id|mf2
suffix:semicolon
id|mf1.ptr
op_assign
(paren
r_char
op_star
)paren
id|data_one
suffix:semicolon
id|mf2.ptr
op_assign
(paren
r_char
op_star
)paren
id|data_two
suffix:semicolon
id|mf1.size
op_assign
id|size_one
suffix:semicolon
id|mf2.size
op_assign
id|size_two
suffix:semicolon
id|check_blank_at_eof
c_func
(paren
op_amp
id|mf1
comma
op_amp
id|mf2
comma
op_amp
id|ecbdata
)paren
suffix:semicolon
)brace
id|ecbdata.lno_in_preimage
op_assign
l_int|1
suffix:semicolon
id|ecbdata.lno_in_postimage
op_assign
l_int|1
suffix:semicolon
id|lc_a
op_assign
id|count_lines
c_func
(paren
id|data_one
comma
id|size_one
)paren
suffix:semicolon
id|lc_b
op_assign
id|count_lines
c_func
(paren
id|data_two
comma
id|size_two
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|o-&gt;file
comma
l_string|&quot;%s%s--- %s%s%s&bslash;n%s%s+++ %s%s%s&bslash;n%s%s@@ -&quot;
comma
id|line_prefix
comma
id|metainfo
comma
id|a_name.buf
comma
id|name_a_tab
comma
id|reset
comma
id|line_prefix
comma
id|metainfo
comma
id|b_name.buf
comma
id|name_b_tab
comma
id|reset
comma
id|line_prefix
comma
id|fraginfo
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|o-&gt;irreversible_delete
)paren
id|print_line_count
c_func
(paren
id|o-&gt;file
comma
id|lc_a
)paren
suffix:semicolon
r_else
id|fprintf
c_func
(paren
id|o-&gt;file
comma
l_string|&quot;?,?&quot;
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|o-&gt;file
comma
l_string|&quot; +&quot;
)paren
suffix:semicolon
id|print_line_count
c_func
(paren
id|o-&gt;file
comma
id|lc_b
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|o-&gt;file
comma
l_string|&quot; @@%s&bslash;n&quot;
comma
id|reset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lc_a
op_logical_and
op_logical_neg
id|o-&gt;irreversible_delete
)paren
id|emit_rewrite_lines
c_func
(paren
op_amp
id|ecbdata
comma
l_char|&squot;-&squot;
comma
id|data_one
comma
id|size_one
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lc_b
)paren
id|emit_rewrite_lines
c_func
(paren
op_amp
id|ecbdata
comma
l_char|&squot;+&squot;
comma
id|data_two
comma
id|size_two
)paren
suffix:semicolon
r_if
c_cond
(paren
id|textconv_one
)paren
id|free
c_func
(paren
(paren
r_char
op_star
)paren
id|data_one
)paren
suffix:semicolon
r_if
c_cond
(paren
id|textconv_two
)paren
id|free
c_func
(paren
(paren
r_char
op_star
)paren
id|data_two
)paren
suffix:semicolon
)brace
DECL|struct|diff_words_buffer
r_struct
id|diff_words_buffer
(brace
DECL|member|text
id|mmfile_t
id|text
suffix:semicolon
DECL|member|alloc
r_int
id|alloc
suffix:semicolon
DECL|struct|diff_words_orig
r_struct
id|diff_words_orig
(brace
DECL|member|begin
DECL|member|end
r_const
r_char
op_star
id|begin
comma
op_star
id|end
suffix:semicolon
DECL|member|orig
)brace
op_star
id|orig
suffix:semicolon
DECL|member|orig_nr
DECL|member|orig_alloc
r_int
id|orig_nr
comma
id|orig_alloc
suffix:semicolon
)brace
suffix:semicolon
DECL|function|diff_words_append
r_static
r_void
id|diff_words_append
c_func
(paren
r_char
op_star
id|line
comma
r_int
r_int
id|len
comma
r_struct
id|diff_words_buffer
op_star
id|buffer
)paren
(brace
id|ALLOC_GROW
c_func
(paren
id|buffer-&gt;text.ptr
comma
id|buffer-&gt;text.size
op_plus
id|len
comma
id|buffer-&gt;alloc
)paren
suffix:semicolon
id|line
op_increment
suffix:semicolon
id|len
op_decrement
suffix:semicolon
id|memcpy
c_func
(paren
id|buffer-&gt;text.ptr
op_plus
id|buffer-&gt;text.size
comma
id|line
comma
id|len
)paren
suffix:semicolon
id|buffer-&gt;text.size
op_add_assign
id|len
suffix:semicolon
id|buffer-&gt;text.ptr
(braket
id|buffer-&gt;text.size
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
DECL|struct|diff_words_style_elem
r_struct
id|diff_words_style_elem
(brace
DECL|member|prefix
r_const
r_char
op_star
id|prefix
suffix:semicolon
DECL|member|suffix
r_const
r_char
op_star
id|suffix
suffix:semicolon
DECL|member|color
r_const
r_char
op_star
id|color
suffix:semicolon
multiline_comment|/* NULL; filled in by the setup code if&n;&t;&t;&t;    * color is enabled */
)brace
suffix:semicolon
DECL|struct|diff_words_style
r_struct
id|diff_words_style
(brace
DECL|member|type
r_enum
id|diff_words_type
id|type
suffix:semicolon
DECL|member|new
DECL|member|old
DECL|member|ctx
r_struct
id|diff_words_style_elem
r_new
comma
id|old
comma
id|ctx
suffix:semicolon
DECL|member|newline
r_const
r_char
op_star
id|newline
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|diff_words_styles
r_static
r_struct
id|diff_words_style
id|diff_words_styles
(braket
)braket
op_assign
(brace
(brace
id|DIFF_WORDS_PORCELAIN
comma
(brace
l_string|&quot;+&quot;
comma
l_string|&quot;&bslash;n&quot;
)brace
comma
(brace
l_string|&quot;-&quot;
comma
l_string|&quot;&bslash;n&quot;
)brace
comma
(brace
l_string|&quot; &quot;
comma
l_string|&quot;&bslash;n&quot;
)brace
comma
l_string|&quot;~&bslash;n&quot;
)brace
comma
(brace
id|DIFF_WORDS_PLAIN
comma
(brace
l_string|&quot;{+&quot;
comma
l_string|&quot;+}&quot;
)brace
comma
(brace
l_string|&quot;[-&quot;
comma
l_string|&quot;-]&quot;
)brace
comma
(brace
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
)brace
comma
l_string|&quot;&bslash;n&quot;
)brace
comma
(brace
id|DIFF_WORDS_COLOR
comma
(brace
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
)brace
comma
(brace
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
)brace
comma
(brace
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
)brace
comma
l_string|&quot;&bslash;n&quot;
)brace
)brace
suffix:semicolon
DECL|struct|diff_words_data
r_struct
id|diff_words_data
(brace
DECL|member|minus
DECL|member|plus
r_struct
id|diff_words_buffer
id|minus
comma
id|plus
suffix:semicolon
DECL|member|current_plus
r_const
r_char
op_star
id|current_plus
suffix:semicolon
DECL|member|last_minus
r_int
id|last_minus
suffix:semicolon
DECL|member|opt
r_struct
id|diff_options
op_star
id|opt
suffix:semicolon
DECL|member|word_regex
id|regex_t
op_star
id|word_regex
suffix:semicolon
DECL|member|type
r_enum
id|diff_words_type
id|type
suffix:semicolon
DECL|member|style
r_struct
id|diff_words_style
op_star
id|style
suffix:semicolon
)brace
suffix:semicolon
DECL|function|fn_out_diff_words_write_helper
r_static
r_int
id|fn_out_diff_words_write_helper
c_func
(paren
id|FILE
op_star
id|fp
comma
r_struct
id|diff_words_style_elem
op_star
id|st_el
comma
r_const
r_char
op_star
id|newline
comma
r_int
id|count
comma
r_const
r_char
op_star
id|buf
comma
r_const
r_char
op_star
id|line_prefix
)paren
(brace
r_int
id|print
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|count
)paren
(brace
r_char
op_star
id|p
op_assign
id|memchr
c_func
(paren
id|buf
comma
l_char|&squot;&bslash;n&squot;
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|print
)paren
id|fputs
c_func
(paren
id|line_prefix
comma
id|fp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_ne
id|buf
)paren
(brace
r_if
c_cond
(paren
id|st_el-&gt;color
op_logical_and
id|fputs
c_func
(paren
id|st_el-&gt;color
comma
id|fp
)paren
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|fputs
c_func
(paren
id|st_el-&gt;prefix
comma
id|fp
)paren
OL
l_int|0
op_logical_or
id|fwrite
c_func
(paren
id|buf
comma
id|p
ques
c_cond
id|p
id|buf
suffix:colon
id|count
comma
l_int|1
comma
id|fp
)paren
op_ne
l_int|1
op_logical_or
id|fputs
c_func
(paren
id|st_el-&gt;suffix
comma
id|fp
)paren
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|st_el-&gt;color
op_logical_and
op_star
id|st_el-&gt;color
op_logical_and
id|fputs
c_func
(paren
id|GIT_COLOR_RESET
comma
id|fp
)paren
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|fputs
c_func
(paren
id|newline
comma
id|fp
)paren
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
id|count
op_sub_assign
id|p
op_plus
l_int|1
id|buf
suffix:semicolon
id|buf
op_assign
id|p
op_plus
l_int|1
suffix:semicolon
id|print
op_assign
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * &squot;--color-words&squot; algorithm can be described as:&n; *&n; *   1. collect a the minus/plus lines of a diff hunk, divided into&n; *      minus-lines and plus-lines;&n; *&n; *   2. break both minus-lines and plus-lines into words and&n; *      place them into two mmfile_t with one word for each line;&n; *&n; *   3. use xdiff to run diff on the two mmfile_t to get the words level diff;&n; *&n; * And for the common parts of the both file, we output the plus side text.&n; * diff_words-&gt;current_plus is used to trace the current position of the plus file&n; * which printed. diff_words-&gt;last_minus is used to trace the last minus word&n; * printed.&n; *&n; * For &squot;--graph&squot; to work with &squot;--color-words&squot;, we need to output the graph prefix&n; * on each line of color words output. Generally, there are two conditions on&n; * which we should output the prefix.&n; *&n; *   1. diff_words-&gt;last_minus == 0 &amp;&amp;&n; *      diff_words-&gt;current_plus == diff_words-&gt;plus.text.ptr&n; *&n; *      that is: the plus text must start as a new line, and if there is no minus&n; *      word printed, a graph prefix must be printed.&n; *&n; *   2. diff_words-&gt;current_plus &gt; diff_words-&gt;plus.text.ptr &amp;&amp;&n; *      *(diff_words-&gt;current_plus - 1) == &squot;&bslash;n&squot;&n; *&n; *      that is: a graph prefix must be printed following a &squot;&bslash;n&squot;&n; */
DECL|function|color_words_output_graph_prefix
r_static
r_int
id|color_words_output_graph_prefix
c_func
(paren
r_struct
id|diff_words_data
op_star
id|diff_words
)paren
(brace
r_if
c_cond
(paren
(paren
id|diff_words-&gt;last_minus
op_eq
l_int|0
op_logical_and
id|diff_words-&gt;current_plus
op_eq
id|diff_words-&gt;plus.text.ptr
)paren
op_logical_or
(paren
id|diff_words-&gt;current_plus
OG
id|diff_words-&gt;plus.text.ptr
op_logical_and
op_star
(paren
id|diff_words-&gt;current_plus
l_int|1
)paren
op_eq
l_char|&squot;&bslash;n&squot;
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|fn_out_diff_words_aux
r_static
r_void
id|fn_out_diff_words_aux
c_func
(paren
r_void
op_star
id|priv
comma
r_char
op_star
id|line
comma
r_int
r_int
id|len
)paren
(brace
r_struct
id|diff_words_data
op_star
id|diff_words
op_assign
id|priv
suffix:semicolon
r_struct
id|diff_words_style
op_star
id|style
op_assign
id|diff_words-&gt;style
suffix:semicolon
r_int
id|minus_first
comma
id|minus_len
comma
id|plus_first
comma
id|plus_len
suffix:semicolon
r_const
r_char
op_star
id|minus_begin
comma
op_star
id|minus_end
comma
op_star
id|plus_begin
comma
op_star
id|plus_end
suffix:semicolon
r_struct
id|diff_options
op_star
id|opt
op_assign
id|diff_words-&gt;opt
suffix:semicolon
r_const
r_char
op_star
id|line_prefix
suffix:semicolon
r_if
c_cond
(paren
id|line
(braket
l_int|0
)braket
op_ne
l_char|&squot;@&squot;
op_logical_or
id|parse_hunk_header
c_func
(paren
id|line
comma
id|len
comma
op_amp
id|minus_first
comma
op_amp
id|minus_len
comma
op_amp
id|plus_first
comma
op_amp
id|plus_len
)paren
)paren
r_return
suffix:semicolon
m_assert
(paren
id|opt
)paren
suffix:semicolon
id|line_prefix
op_assign
id|diff_line_prefix
c_func
(paren
id|opt
)paren
suffix:semicolon
multiline_comment|/* POSIX requires that first be decremented by one if len == 0... */
r_if
c_cond
(paren
id|minus_len
)paren
(brace
id|minus_begin
op_assign
id|diff_words-&gt;minus.orig
(braket
id|minus_first
)braket
dot
id|begin
suffix:semicolon
id|minus_end
op_assign
id|diff_words-&gt;minus.orig
(braket
id|minus_first
op_plus
id|minus_len
l_int|1
)braket
dot
id|end
suffix:semicolon
)brace
r_else
id|minus_begin
op_assign
id|minus_end
op_assign
id|diff_words-&gt;minus.orig
(braket
id|minus_first
)braket
dot
id|end
suffix:semicolon
r_if
c_cond
(paren
id|plus_len
)paren
(brace
id|plus_begin
op_assign
id|diff_words-&gt;plus.orig
(braket
id|plus_first
)braket
dot
id|begin
suffix:semicolon
id|plus_end
op_assign
id|diff_words-&gt;plus.orig
(braket
id|plus_first
op_plus
id|plus_len
l_int|1
)braket
dot
id|end
suffix:semicolon
)brace
r_else
id|plus_begin
op_assign
id|plus_end
op_assign
id|diff_words-&gt;plus.orig
(braket
id|plus_first
)braket
dot
id|end
suffix:semicolon
r_if
c_cond
(paren
id|color_words_output_graph_prefix
c_func
(paren
id|diff_words
)paren
)paren
(brace
id|fputs
c_func
(paren
id|line_prefix
comma
id|diff_words-&gt;opt-&gt;file
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|diff_words-&gt;current_plus
op_ne
id|plus_begin
)paren
(brace
id|fn_out_diff_words_write_helper
c_func
(paren
id|diff_words-&gt;opt-&gt;file
comma
op_amp
id|style-&gt;ctx
comma
id|style-&gt;newline
comma
id|plus_begin
id|diff_words-&gt;current_plus
comma
id|diff_words-&gt;current_plus
comma
id|line_prefix
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
(paren
id|plus_begin
l_int|1
)paren
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|fputs
c_func
(paren
id|line_prefix
comma
id|diff_words-&gt;opt-&gt;file
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|minus_begin
op_ne
id|minus_end
)paren
(brace
id|fn_out_diff_words_write_helper
c_func
(paren
id|diff_words-&gt;opt-&gt;file
comma
op_amp
id|style-&gt;old
comma
id|style-&gt;newline
comma
id|minus_end
id|minus_begin
comma
id|minus_begin
comma
id|line_prefix
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|plus_begin
op_ne
id|plus_end
)paren
(brace
id|fn_out_diff_words_write_helper
c_func
(paren
id|diff_words-&gt;opt-&gt;file
comma
op_amp
id|style
op_member_access_from_pointer
r_new
comma
id|style-&gt;newline
comma
id|plus_end
id|plus_begin
comma
id|plus_begin
comma
id|line_prefix
)paren
suffix:semicolon
)brace
id|diff_words-&gt;current_plus
op_assign
id|plus_end
suffix:semicolon
id|diff_words-&gt;last_minus
op_assign
id|minus_first
suffix:semicolon
)brace
multiline_comment|/* This function starts looking at *begin, and returns 0 iff a word was found. */
DECL|function|find_word_boundaries
r_static
r_int
id|find_word_boundaries
c_func
(paren
id|mmfile_t
op_star
id|buffer
comma
id|regex_t
op_star
id|word_regex
comma
r_int
op_star
id|begin
comma
r_int
op_star
id|end
)paren
(brace
r_if
c_cond
(paren
id|word_regex
op_logical_and
op_star
id|begin
OL
id|buffer-&gt;size
)paren
(brace
id|regmatch_t
id|match
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|regexec
c_func
(paren
id|word_regex
comma
id|buffer-&gt;ptr
op_plus
op_star
id|begin
comma
l_int|1
comma
id|match
comma
l_int|0
)paren
)paren
(brace
r_char
op_star
id|p
op_assign
id|memchr
c_func
(paren
id|buffer-&gt;ptr
op_plus
op_star
id|begin
op_plus
id|match
(braket
l_int|0
)braket
dot
id|rm_so
comma
l_char|&squot;&bslash;n&squot;
comma
id|match
(braket
l_int|0
)braket
dot
id|rm_eo
id|match
(braket
l_int|0
)braket
dot
id|rm_so
)paren
suffix:semicolon
op_star
id|end
op_assign
id|p
ques
c_cond
id|p
id|buffer-&gt;ptr
suffix:colon
id|match
(braket
l_int|0
)braket
dot
id|rm_eo
op_plus
op_star
id|begin
suffix:semicolon
op_star
id|begin
op_add_assign
id|match
(braket
l_int|0
)braket
dot
id|rm_so
suffix:semicolon
r_return
op_star
id|begin
op_ge
op_star
id|end
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* find the next word */
r_while
c_loop
(paren
op_star
id|begin
OL
id|buffer-&gt;size
op_logical_and
id|isspace
c_func
(paren
id|buffer-&gt;ptr
(braket
op_star
id|begin
)braket
)paren
)paren
(paren
op_star
id|begin
)paren
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|begin
op_ge
id|buffer-&gt;size
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* find the end of the word */
op_star
id|end
op_assign
op_star
id|begin
op_plus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
op_star
id|end
OL
id|buffer-&gt;size
op_logical_and
op_logical_neg
id|isspace
c_func
(paren
id|buffer-&gt;ptr
(braket
op_star
id|end
)braket
)paren
)paren
(paren
op_star
id|end
)paren
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function splits the words in buffer-&gt;text, stores the list with&n; * newline separator into out, and saves the offsets of the original words&n; * in buffer-&gt;orig.&n; */
DECL|function|diff_words_fill
r_static
r_void
id|diff_words_fill
c_func
(paren
r_struct
id|diff_words_buffer
op_star
id|buffer
comma
id|mmfile_t
op_star
id|out
comma
id|regex_t
op_star
id|word_regex
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_int
id|alloc
op_assign
l_int|0
suffix:semicolon
id|out-&gt;size
op_assign
l_int|0
suffix:semicolon
id|out-&gt;ptr
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* fake an empty &quot;0th&quot; word */
id|ALLOC_GROW
c_func
(paren
id|buffer-&gt;orig
comma
l_int|1
comma
id|buffer-&gt;orig_alloc
)paren
suffix:semicolon
id|buffer-&gt;orig
(braket
l_int|0
)braket
dot
id|begin
op_assign
id|buffer-&gt;orig
(braket
l_int|0
)braket
dot
id|end
op_assign
id|buffer-&gt;text.ptr
suffix:semicolon
id|buffer-&gt;orig_nr
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|buffer-&gt;text.size
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|find_word_boundaries
c_func
(paren
op_amp
id|buffer-&gt;text
comma
id|word_regex
comma
op_amp
id|i
comma
op_amp
id|j
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* store original boundaries */
id|ALLOC_GROW
c_func
(paren
id|buffer-&gt;orig
comma
id|buffer-&gt;orig_nr
op_plus
l_int|1
comma
id|buffer-&gt;orig_alloc
)paren
suffix:semicolon
id|buffer-&gt;orig
(braket
id|buffer-&gt;orig_nr
)braket
dot
id|begin
op_assign
id|buffer-&gt;text.ptr
op_plus
id|i
suffix:semicolon
id|buffer-&gt;orig
(braket
id|buffer-&gt;orig_nr
)braket
dot
id|end
op_assign
id|buffer-&gt;text.ptr
op_plus
id|j
suffix:semicolon
id|buffer-&gt;orig_nr
op_increment
suffix:semicolon
multiline_comment|/* store one word */
id|ALLOC_GROW
c_func
(paren
id|out-&gt;ptr
comma
id|out-&gt;size
op_plus
id|j
id|i
op_plus
l_int|1
comma
id|alloc
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|out-&gt;ptr
op_plus
id|out-&gt;size
comma
id|buffer-&gt;text.ptr
op_plus
id|i
comma
id|j
id|i
)paren
suffix:semicolon
id|out-&gt;ptr
(braket
id|out-&gt;size
op_plus
id|j
id|i
)braket
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
id|out-&gt;size
op_add_assign
id|j
id|i
op_plus
l_int|1
suffix:semicolon
id|i
op_assign
id|j
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* this executes the word diff on the accumulated buffers */
DECL|function|diff_words_show
r_static
r_void
id|diff_words_show
c_func
(paren
r_struct
id|diff_words_data
op_star
id|diff_words
)paren
(brace
id|xpparam_t
id|xpp
suffix:semicolon
id|xdemitconf_t
id|xecfg
suffix:semicolon
id|mmfile_t
id|minus
comma
id|plus
suffix:semicolon
r_struct
id|diff_words_style
op_star
id|style
op_assign
id|diff_words-&gt;style
suffix:semicolon
r_struct
id|diff_options
op_star
id|opt
op_assign
id|diff_words-&gt;opt
suffix:semicolon
r_const
r_char
op_star
id|line_prefix
suffix:semicolon
m_assert
(paren
id|opt
)paren
suffix:semicolon
id|line_prefix
op_assign
id|diff_line_prefix
c_func
(paren
id|opt
)paren
suffix:semicolon
multiline_comment|/* special case: only removal */
r_if
c_cond
(paren
op_logical_neg
id|diff_words-&gt;plus.text.size
)paren
(brace
id|fputs
c_func
(paren
id|line_prefix
comma
id|diff_words-&gt;opt-&gt;file
)paren
suffix:semicolon
id|fn_out_diff_words_write_helper
c_func
(paren
id|diff_words-&gt;opt-&gt;file
comma
op_amp
id|style-&gt;old
comma
id|style-&gt;newline
comma
id|diff_words-&gt;minus.text.size
comma
id|diff_words-&gt;minus.text.ptr
comma
id|line_prefix
)paren
suffix:semicolon
id|diff_words-&gt;minus.text.size
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
id|diff_words-&gt;current_plus
op_assign
id|diff_words-&gt;plus.text.ptr
suffix:semicolon
id|diff_words-&gt;last_minus
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|xpp
comma
l_int|0
comma
r_sizeof
(paren
id|xpp
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|xecfg
comma
l_int|0
comma
r_sizeof
(paren
id|xecfg
)paren
)paren
suffix:semicolon
id|diff_words_fill
c_func
(paren
op_amp
id|diff_words-&gt;minus
comma
op_amp
id|minus
comma
id|diff_words-&gt;word_regex
)paren
suffix:semicolon
id|diff_words_fill
c_func
(paren
op_amp
id|diff_words-&gt;plus
comma
op_amp
id|plus
comma
id|diff_words-&gt;word_regex
)paren
suffix:semicolon
id|xpp.flags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* as only the hunk header will be parsed, we need a 0-context */
id|xecfg.ctxlen
op_assign
l_int|0
suffix:semicolon
id|xdi_diff_outf
c_func
(paren
op_amp
id|minus
comma
op_amp
id|plus
comma
id|fn_out_diff_words_aux
comma
id|diff_words
comma
op_amp
id|xpp
comma
op_amp
id|xecfg
)paren
suffix:semicolon
id|free
c_func
(paren
id|minus.ptr
)paren
suffix:semicolon
id|free
c_func
(paren
id|plus.ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|diff_words-&gt;current_plus
op_ne
id|diff_words-&gt;plus.text.ptr
op_plus
id|diff_words-&gt;plus.text.size
)paren
(brace
r_if
c_cond
(paren
id|color_words_output_graph_prefix
c_func
(paren
id|diff_words
)paren
)paren
id|fputs
c_func
(paren
id|line_prefix
comma
id|diff_words-&gt;opt-&gt;file
)paren
suffix:semicolon
id|fn_out_diff_words_write_helper
c_func
(paren
id|diff_words-&gt;opt-&gt;file
comma
op_amp
id|style-&gt;ctx
comma
id|style-&gt;newline
comma
id|diff_words-&gt;plus.text.ptr
op_plus
id|diff_words-&gt;plus.text.size
id|diff_words-&gt;current_plus
comma
id|diff_words-&gt;current_plus
comma
id|line_prefix
)paren
suffix:semicolon
)brace
id|diff_words-&gt;minus.text.size
op_assign
id|diff_words-&gt;plus.text.size
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* In &quot;color-words&quot; mode, show word-diff of words accumulated in the buffer */
DECL|function|diff_words_flush
r_static
r_void
id|diff_words_flush
c_func
(paren
r_struct
id|emit_callback
op_star
id|ecbdata
)paren
(brace
r_if
c_cond
(paren
id|ecbdata-&gt;diff_words-&gt;minus.text.size
op_logical_or
id|ecbdata-&gt;diff_words-&gt;plus.text.size
)paren
id|diff_words_show
c_func
(paren
id|ecbdata-&gt;diff_words
)paren
suffix:semicolon
)brace
DECL|function|diff_filespec_load_driver
r_static
r_void
id|diff_filespec_load_driver
c_func
(paren
r_struct
id|diff_filespec
op_star
id|one
)paren
(brace
multiline_comment|/* Use already-loaded driver */
r_if
c_cond
(paren
id|one-&gt;driver
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|one-&gt;mode
)paren
)paren
id|one-&gt;driver
op_assign
id|userdiff_find_by_path
c_func
(paren
id|one-&gt;path
)paren
suffix:semicolon
multiline_comment|/* Fallback to default settings */
r_if
c_cond
(paren
op_logical_neg
id|one-&gt;driver
)paren
id|one-&gt;driver
op_assign
id|userdiff_find_by_name
c_func
(paren
l_string|&quot;default&quot;
)paren
suffix:semicolon
)brace
DECL|function|userdiff_word_regex
r_static
r_const
r_char
op_star
id|userdiff_word_regex
c_func
(paren
r_struct
id|diff_filespec
op_star
id|one
)paren
(brace
id|diff_filespec_load_driver
c_func
(paren
id|one
)paren
suffix:semicolon
r_return
id|one-&gt;driver-&gt;word_regex
suffix:semicolon
)brace
DECL|function|init_diff_words_data
r_static
r_void
id|init_diff_words_data
c_func
(paren
r_struct
id|emit_callback
op_star
id|ecbdata
comma
r_struct
id|diff_options
op_star
id|orig_opts
comma
r_struct
id|diff_filespec
op_star
id|one
comma
r_struct
id|diff_filespec
op_star
id|two
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|diff_options
op_star
id|o
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|diff_options
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|o
comma
id|orig_opts
comma
r_sizeof
(paren
r_struct
id|diff_options
)paren
)paren
suffix:semicolon
id|ecbdata-&gt;diff_words
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|diff_words_data
)paren
)paren
suffix:semicolon
id|ecbdata-&gt;diff_words-&gt;type
op_assign
id|o-&gt;word_diff
suffix:semicolon
id|ecbdata-&gt;diff_words-&gt;opt
op_assign
id|o
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|o-&gt;word_regex
)paren
id|o-&gt;word_regex
op_assign
id|userdiff_word_regex
c_func
(paren
id|one
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|o-&gt;word_regex
)paren
id|o-&gt;word_regex
op_assign
id|userdiff_word_regex
c_func
(paren
id|two
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|o-&gt;word_regex
)paren
id|o-&gt;word_regex
op_assign
id|diff_word_regex_cfg
suffix:semicolon
r_if
c_cond
(paren
id|o-&gt;word_regex
)paren
(brace
id|ecbdata-&gt;diff_words-&gt;word_regex
op_assign
(paren
id|regex_t
op_star
)paren
id|xmalloc
c_func
(paren
r_sizeof
(paren
id|regex_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|regcomp
c_func
(paren
id|ecbdata-&gt;diff_words-&gt;word_regex
comma
id|o-&gt;word_regex
comma
id|REG_EXTENDED
op_or
id|REG_NEWLINE
)paren
)paren
id|die
(paren
l_string|&quot;Invalid regular expression: %s&quot;
comma
id|o-&gt;word_regex
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|diff_words_styles
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|o-&gt;word_diff
op_eq
id|diff_words_styles
(braket
id|i
)braket
dot
id|type
)paren
(brace
id|ecbdata-&gt;diff_words-&gt;style
op_assign
op_amp
id|diff_words_styles
(braket
id|i
)braket
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|want_color
c_func
(paren
id|o-&gt;use_color
)paren
)paren
(brace
r_struct
id|diff_words_style
op_star
id|st
op_assign
id|ecbdata-&gt;diff_words-&gt;style
suffix:semicolon
id|st-&gt;old.color
op_assign
id|diff_get_color_opt
c_func
(paren
id|o
comma
id|DIFF_FILE_OLD
)paren
suffix:semicolon
id|st
op_member_access_from_pointer
r_new
dot
id|color
op_assign
id|diff_get_color_opt
c_func
(paren
id|o
comma
id|DIFF_FILE_NEW
)paren
suffix:semicolon
id|st-&gt;ctx.color
op_assign
id|diff_get_color_opt
c_func
(paren
id|o
comma
id|DIFF_PLAIN
)paren
suffix:semicolon
)brace
)brace
DECL|function|free_diff_words_data
r_static
r_void
id|free_diff_words_data
c_func
(paren
r_struct
id|emit_callback
op_star
id|ecbdata
)paren
(brace
r_if
c_cond
(paren
id|ecbdata-&gt;diff_words
)paren
(brace
id|diff_words_flush
c_func
(paren
id|ecbdata
)paren
suffix:semicolon
id|free
(paren
id|ecbdata-&gt;diff_words-&gt;opt
)paren
suffix:semicolon
id|free
(paren
id|ecbdata-&gt;diff_words-&gt;minus.text.ptr
)paren
suffix:semicolon
id|free
(paren
id|ecbdata-&gt;diff_words-&gt;minus.orig
)paren
suffix:semicolon
id|free
(paren
id|ecbdata-&gt;diff_words-&gt;plus.text.ptr
)paren
suffix:semicolon
id|free
(paren
id|ecbdata-&gt;diff_words-&gt;plus.orig
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ecbdata-&gt;diff_words-&gt;word_regex
)paren
(brace
id|regfree
c_func
(paren
id|ecbdata-&gt;diff_words-&gt;word_regex
)paren
suffix:semicolon
id|free
c_func
(paren
id|ecbdata-&gt;diff_words-&gt;word_regex
)paren
suffix:semicolon
)brace
id|free
c_func
(paren
id|ecbdata-&gt;diff_words
)paren
suffix:semicolon
id|ecbdata-&gt;diff_words
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
DECL|function|diff_get_color
r_const
r_char
op_star
id|diff_get_color
c_func
(paren
r_int
id|diff_use_color
comma
r_enum
id|color_diff
id|ix
)paren
(brace
r_if
c_cond
(paren
id|want_color
c_func
(paren
id|diff_use_color
)paren
)paren
r_return
id|diff_colors
(braket
id|ix
)braket
suffix:semicolon
r_return
l_string|&quot;&quot;
suffix:semicolon
)brace
DECL|function|diff_line_prefix
r_const
r_char
op_star
id|diff_line_prefix
c_func
(paren
r_struct
id|diff_options
op_star
id|opt
)paren
(brace
r_struct
id|strbuf
op_star
id|msgbuf
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|opt-&gt;output_prefix
)paren
r_return
l_string|&quot;&quot;
suffix:semicolon
id|msgbuf
op_assign
id|opt
op_member_access_from_pointer
id|output_prefix
c_func
(paren
id|opt
comma
id|opt-&gt;output_prefix_data
)paren
suffix:semicolon
r_return
id|msgbuf-&gt;buf
suffix:semicolon
)brace
DECL|function|sane_truncate_line
r_static
r_int
r_int
id|sane_truncate_line
c_func
(paren
r_struct
id|emit_callback
op_star
id|ecb
comma
r_char
op_star
id|line
comma
r_int
r_int
id|len
)paren
(brace
r_const
r_char
op_star
id|cp
suffix:semicolon
r_int
r_int
id|allot
suffix:semicolon
r_int
id|l
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|ecb-&gt;truncate
)paren
r_return
id|ecb
op_member_access_from_pointer
id|truncate
c_func
(paren
id|line
comma
id|len
)paren
suffix:semicolon
id|cp
op_assign
id|line
suffix:semicolon
id|allot
op_assign
id|l
suffix:semicolon
r_while
c_loop
(paren
l_int|0
OL
id|l
)paren
(brace
(paren
r_void
)paren
id|utf8_width
c_func
(paren
op_amp
id|cp
comma
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_break
suffix:semicolon
multiline_comment|/* truncated in the middle? */
)brace
r_return
id|allot
id|l
suffix:semicolon
)brace
DECL|function|find_lno
r_static
r_void
id|find_lno
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_struct
id|emit_callback
op_star
id|ecbdata
)paren
(brace
r_const
r_char
op_star
id|p
suffix:semicolon
id|ecbdata-&gt;lno_in_preimage
op_assign
l_int|0
suffix:semicolon
id|ecbdata-&gt;lno_in_postimage
op_assign
l_int|0
suffix:semicolon
id|p
op_assign
id|strchr
c_func
(paren
id|line
comma
l_char|&squot;-&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_return
suffix:semicolon
multiline_comment|/* cannot happen */
id|ecbdata-&gt;lno_in_preimage
op_assign
id|strtol
c_func
(paren
id|p
op_plus
l_int|1
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
id|p
op_assign
id|strchr
c_func
(paren
id|p
comma
l_char|&squot;+&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_return
suffix:semicolon
multiline_comment|/* cannot happen */
id|ecbdata-&gt;lno_in_postimage
op_assign
id|strtol
c_func
(paren
id|p
op_plus
l_int|1
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
)brace
DECL|function|fn_out_consume
r_static
r_void
id|fn_out_consume
c_func
(paren
r_void
op_star
id|priv
comma
r_char
op_star
id|line
comma
r_int
r_int
id|len
)paren
(brace
r_struct
id|emit_callback
op_star
id|ecbdata
op_assign
id|priv
suffix:semicolon
r_const
r_char
op_star
id|meta
op_assign
id|diff_get_color
c_func
(paren
id|ecbdata-&gt;color_diff
comma
id|DIFF_METAINFO
)paren
suffix:semicolon
r_const
r_char
op_star
id|plain
op_assign
id|diff_get_color
c_func
(paren
id|ecbdata-&gt;color_diff
comma
id|DIFF_PLAIN
)paren
suffix:semicolon
r_const
r_char
op_star
id|reset
op_assign
id|diff_get_color
c_func
(paren
id|ecbdata-&gt;color_diff
comma
id|DIFF_RESET
)paren
suffix:semicolon
r_struct
id|diff_options
op_star
id|o
op_assign
id|ecbdata-&gt;opt
suffix:semicolon
r_const
r_char
op_star
id|line_prefix
op_assign
id|diff_line_prefix
c_func
(paren
id|o
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ecbdata-&gt;header
)paren
(brace
id|fprintf
c_func
(paren
id|ecbdata-&gt;opt-&gt;file
comma
l_string|&quot;%s&quot;
comma
id|ecbdata-&gt;header-&gt;buf
)paren
suffix:semicolon
id|strbuf_reset
c_func
(paren
id|ecbdata-&gt;header
)paren
suffix:semicolon
id|ecbdata-&gt;header
op_assign
l_int|NULL
suffix:semicolon
)brace
op_star
(paren
id|ecbdata-&gt;found_changesp
)paren
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ecbdata-&gt;label_path
(braket
l_int|0
)braket
)paren
(brace
r_const
r_char
op_star
id|name_a_tab
comma
op_star
id|name_b_tab
suffix:semicolon
id|name_a_tab
op_assign
id|strchr
c_func
(paren
id|ecbdata-&gt;label_path
(braket
l_int|0
)braket
comma
l_char|&squot; &squot;
)paren
ques
c_cond
l_string|&quot;&bslash;t&quot;
suffix:colon
l_string|&quot;&quot;
suffix:semicolon
id|name_b_tab
op_assign
id|strchr
c_func
(paren
id|ecbdata-&gt;label_path
(braket
l_int|1
)braket
comma
l_char|&squot; &squot;
)paren
ques
c_cond
l_string|&quot;&bslash;t&quot;
suffix:colon
l_string|&quot;&quot;
suffix:semicolon
id|fprintf
c_func
(paren
id|ecbdata-&gt;opt-&gt;file
comma
l_string|&quot;%s%s--- %s%s%s&bslash;n&quot;
comma
id|line_prefix
comma
id|meta
comma
id|ecbdata-&gt;label_path
(braket
l_int|0
)braket
comma
id|reset
comma
id|name_a_tab
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|ecbdata-&gt;opt-&gt;file
comma
l_string|&quot;%s%s+++ %s%s%s&bslash;n&quot;
comma
id|line_prefix
comma
id|meta
comma
id|ecbdata-&gt;label_path
(braket
l_int|1
)braket
comma
id|reset
comma
id|name_b_tab
)paren
suffix:semicolon
id|ecbdata-&gt;label_path
(braket
l_int|0
)braket
op_assign
id|ecbdata-&gt;label_path
(braket
l_int|1
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|diff_suppress_blank_empty
op_logical_and
id|len
op_eq
l_int|2
op_logical_and
id|line
(braket
l_int|0
)braket
op_eq
l_char|&squot; &squot;
op_logical_and
id|line
(braket
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|line
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
id|len
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|line
(braket
l_int|0
)braket
op_eq
l_char|&squot;@&squot;
)paren
(brace
r_if
c_cond
(paren
id|ecbdata-&gt;diff_words
)paren
id|diff_words_flush
c_func
(paren
id|ecbdata
)paren
suffix:semicolon
id|len
op_assign
id|sane_truncate_line
c_func
(paren
id|ecbdata
comma
id|line
comma
id|len
)paren
suffix:semicolon
id|find_lno
c_func
(paren
id|line
comma
id|ecbdata
)paren
suffix:semicolon
id|emit_hunk_header
c_func
(paren
id|ecbdata
comma
id|line
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|line
(braket
id|len
op_minus
l_int|1
)braket
op_ne
l_char|&squot;&bslash;n&squot;
)paren
id|putc
c_func
(paren
l_char|&squot;&bslash;n&squot;
comma
id|ecbdata-&gt;opt-&gt;file
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OL
l_int|1
)paren
(brace
id|emit_line
c_func
(paren
id|ecbdata-&gt;opt
comma
id|reset
comma
id|reset
comma
id|line
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ecbdata-&gt;diff_words
op_logical_and
id|ecbdata-&gt;diff_words-&gt;type
op_eq
id|DIFF_WORDS_PORCELAIN
)paren
id|fputs
c_func
(paren
l_string|&quot;~&bslash;n&quot;
comma
id|ecbdata-&gt;opt-&gt;file
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ecbdata-&gt;diff_words
)paren
(brace
r_if
c_cond
(paren
id|line
(braket
l_int|0
)braket
op_eq
l_char|&squot;-&squot;
)paren
(brace
id|diff_words_append
c_func
(paren
id|line
comma
id|len
comma
op_amp
id|ecbdata-&gt;diff_words-&gt;minus
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|line
(braket
l_int|0
)braket
op_eq
l_char|&squot;+&squot;
)paren
(brace
id|diff_words_append
c_func
(paren
id|line
comma
id|len
comma
op_amp
id|ecbdata-&gt;diff_words-&gt;plus
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|line
comma
l_string|&quot;&bslash;&bslash; &quot;
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Eat the &quot;no newline at eof&quot; marker as if we&n;&t;&t;&t; * saw a &quot;+&quot; or &quot;-&quot; line with nothing on it,&n;&t;&t;&t; * and return without diff_words_flush() to&n;&t;&t;&t; * defer processing. If this is the end of&n;&t;&t;&t; * preimage, more &quot;+&quot; lines may come after it.&n;&t;&t;&t; */
r_return
suffix:semicolon
)brace
id|diff_words_flush
c_func
(paren
id|ecbdata
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ecbdata-&gt;diff_words-&gt;type
op_eq
id|DIFF_WORDS_PORCELAIN
)paren
(brace
id|emit_line
c_func
(paren
id|ecbdata-&gt;opt
comma
id|plain
comma
id|reset
comma
id|line
comma
id|len
)paren
suffix:semicolon
id|fputs
c_func
(paren
l_string|&quot;~&bslash;n&quot;
comma
id|ecbdata-&gt;opt-&gt;file
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Skip the prefix character, if any.  With&n;&t;&t;&t; * diff_suppress_blank_empty, there may be&n;&t;&t;&t; * none.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|line
(braket
l_int|0
)braket
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|line
op_increment
suffix:semicolon
id|len
op_decrement
suffix:semicolon
)brace
id|emit_line
c_func
(paren
id|ecbdata-&gt;opt
comma
id|plain
comma
id|reset
comma
id|line
comma
id|len
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|line
(braket
l_int|0
)braket
op_ne
l_char|&squot;+&squot;
)paren
(brace
r_const
r_char
op_star
id|color
op_assign
id|diff_get_color
c_func
(paren
id|ecbdata-&gt;color_diff
comma
id|line
(braket
l_int|0
)braket
op_eq
l_char|&squot;-&squot;
ques
c_cond
id|DIFF_FILE_OLD
suffix:colon
id|DIFF_PLAIN
)paren
suffix:semicolon
id|ecbdata-&gt;lno_in_preimage
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|line
(braket
l_int|0
)braket
op_eq
l_char|&squot; &squot;
)paren
id|ecbdata-&gt;lno_in_postimage
op_increment
suffix:semicolon
id|emit_line
c_func
(paren
id|ecbdata-&gt;opt
comma
id|color
comma
id|reset
comma
id|line
comma
id|len
)paren
suffix:semicolon
)brace
r_else
(brace
id|ecbdata-&gt;lno_in_postimage
op_increment
suffix:semicolon
id|emit_add_line
c_func
(paren
id|reset
comma
id|ecbdata
comma
id|line
op_plus
l_int|1
comma
id|len
l_int|1
)paren
suffix:semicolon
)brace
)brace
DECL|function|pprint_rename
r_static
r_char
op_star
id|pprint_rename
c_func
(paren
r_const
r_char
op_star
id|a
comma
r_const
r_char
op_star
id|b
)paren
(brace
r_const
r_char
op_star
id|old
op_assign
id|a
suffix:semicolon
r_const
r_char
op_star
r_new
op_assign
id|b
suffix:semicolon
r_struct
id|strbuf
id|name
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|pfx_length
comma
id|sfx_length
suffix:semicolon
r_int
id|pfx_adjust_for_slash
suffix:semicolon
r_int
id|len_a
op_assign
id|strlen
c_func
(paren
id|a
)paren
suffix:semicolon
r_int
id|len_b
op_assign
id|strlen
c_func
(paren
id|b
)paren
suffix:semicolon
r_int
id|a_midlen
comma
id|b_midlen
suffix:semicolon
r_int
id|qlen_a
op_assign
id|quote_c_style
c_func
(paren
id|a
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_int
id|qlen_b
op_assign
id|quote_c_style
c_func
(paren
id|b
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|qlen_a
op_logical_or
id|qlen_b
)paren
(brace
id|quote_c_style
c_func
(paren
id|a
comma
op_amp
id|name
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|name
comma
l_string|&quot; =&gt; &quot;
)paren
suffix:semicolon
id|quote_c_style
c_func
(paren
id|b
comma
op_amp
id|name
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_return
id|strbuf_detach
c_func
(paren
op_amp
id|name
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/* Find common prefix */
id|pfx_length
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_star
id|old
op_logical_and
op_star
r_new
op_logical_and
op_star
id|old
op_eq
op_star
r_new
)paren
(brace
r_if
c_cond
(paren
op_star
id|old
op_eq
l_char|&squot;/&squot;
)paren
id|pfx_length
op_assign
id|old
id|a
op_plus
l_int|1
suffix:semicolon
id|old
op_increment
suffix:semicolon
r_new
op_increment
suffix:semicolon
)brace
multiline_comment|/* Find common suffix */
id|old
op_assign
id|a
op_plus
id|len_a
suffix:semicolon
r_new
op_assign
id|b
op_plus
id|len_b
suffix:semicolon
id|sfx_length
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If there is a common prefix, it must end in a slash.  In&n;&t; * that case we let this loop run 1 into the prefix to see the&n;&t; * same slash.&n;&t; *&n;&t; * If there is no common prefix, we cannot do this as it would&n;&t; * underrun the input strings.&n;&t; */
id|pfx_adjust_for_slash
op_assign
(paren
id|pfx_length
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
r_while
c_loop
(paren
id|a
op_plus
id|pfx_length
id|pfx_adjust_for_slash
op_le
id|old
op_logical_and
id|b
op_plus
id|pfx_length
id|pfx_adjust_for_slash
op_le
r_new
op_logical_and
op_star
id|old
op_eq
op_star
r_new
)paren
(brace
r_if
c_cond
(paren
op_star
id|old
op_eq
l_char|&squot;/&squot;
)paren
id|sfx_length
op_assign
id|len_a
(paren
id|old
id|a
)paren
suffix:semicolon
id|old
op_decrement
suffix:semicolon
r_new
op_decrement
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * pfx{mid-a =&gt; mid-b}sfx&n;&t; * {pfx-a =&gt; pfx-b}sfx&n;&t; * pfx{sfx-a =&gt; sfx-b}&n;&t; * name-a =&gt; name-b&n;&t; */
id|a_midlen
op_assign
id|len_a
id|pfx_length
id|sfx_length
suffix:semicolon
id|b_midlen
op_assign
id|len_b
id|pfx_length
id|sfx_length
suffix:semicolon
r_if
c_cond
(paren
id|a_midlen
OL
l_int|0
)paren
id|a_midlen
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|b_midlen
OL
l_int|0
)paren
id|b_midlen
op_assign
l_int|0
suffix:semicolon
id|strbuf_grow
c_func
(paren
op_amp
id|name
comma
id|pfx_length
op_plus
id|a_midlen
op_plus
id|b_midlen
op_plus
id|sfx_length
op_plus
l_int|7
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pfx_length
op_plus
id|sfx_length
)paren
(brace
id|strbuf_add
c_func
(paren
op_amp
id|name
comma
id|a
comma
id|pfx_length
)paren
suffix:semicolon
id|strbuf_addch
c_func
(paren
op_amp
id|name
comma
l_char|&squot;{&squot;
)paren
suffix:semicolon
)brace
id|strbuf_add
c_func
(paren
op_amp
id|name
comma
id|a
op_plus
id|pfx_length
comma
id|a_midlen
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|name
comma
l_string|&quot; =&gt; &quot;
)paren
suffix:semicolon
id|strbuf_add
c_func
(paren
op_amp
id|name
comma
id|b
op_plus
id|pfx_length
comma
id|b_midlen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pfx_length
op_plus
id|sfx_length
)paren
(brace
id|strbuf_addch
c_func
(paren
op_amp
id|name
comma
l_char|&squot;}&squot;
)paren
suffix:semicolon
id|strbuf_add
c_func
(paren
op_amp
id|name
comma
id|a
op_plus
id|len_a
id|sfx_length
comma
id|sfx_length
)paren
suffix:semicolon
)brace
r_return
id|strbuf_detach
c_func
(paren
op_amp
id|name
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|struct|diffstat_t
r_struct
id|diffstat_t
(brace
DECL|member|nr
r_int
id|nr
suffix:semicolon
DECL|member|alloc
r_int
id|alloc
suffix:semicolon
DECL|struct|diffstat_file
r_struct
id|diffstat_file
(brace
DECL|member|from_name
r_char
op_star
id|from_name
suffix:semicolon
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|member|print_name
r_char
op_star
id|print_name
suffix:semicolon
DECL|member|is_unmerged
r_int
id|is_unmerged
suffix:colon
l_int|1
suffix:semicolon
DECL|member|is_binary
r_int
id|is_binary
suffix:colon
l_int|1
suffix:semicolon
DECL|member|is_renamed
r_int
id|is_renamed
suffix:colon
l_int|1
suffix:semicolon
DECL|member|is_interesting
r_int
id|is_interesting
suffix:colon
l_int|1
suffix:semicolon
DECL|member|added
DECL|member|deleted
r_uintmax
id|added
comma
id|deleted
suffix:semicolon
DECL|member|files
)brace
op_star
op_star
id|files
suffix:semicolon
)brace
suffix:semicolon
DECL|function|diffstat_add
r_static
r_struct
id|diffstat_file
op_star
id|diffstat_add
c_func
(paren
r_struct
id|diffstat_t
op_star
id|diffstat
comma
r_const
r_char
op_star
id|name_a
comma
r_const
r_char
op_star
id|name_b
)paren
(brace
r_struct
id|diffstat_file
op_star
id|x
suffix:semicolon
id|x
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|x
)paren
)paren
suffix:semicolon
id|ALLOC_GROW
c_func
(paren
id|diffstat-&gt;files
comma
id|diffstat-&gt;nr
op_plus
l_int|1
comma
id|diffstat-&gt;alloc
)paren
suffix:semicolon
id|diffstat-&gt;files
(braket
id|diffstat-&gt;nr
op_increment
)braket
op_assign
id|x
suffix:semicolon
r_if
c_cond
(paren
id|name_b
)paren
(brace
id|x-&gt;from_name
op_assign
id|xstrdup
c_func
(paren
id|name_a
)paren
suffix:semicolon
id|x-&gt;name
op_assign
id|xstrdup
c_func
(paren
id|name_b
)paren
suffix:semicolon
id|x-&gt;is_renamed
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|x-&gt;from_name
op_assign
l_int|NULL
suffix:semicolon
id|x-&gt;name
op_assign
id|xstrdup
c_func
(paren
id|name_a
)paren
suffix:semicolon
)brace
r_return
id|x
suffix:semicolon
)brace
DECL|function|diffstat_consume
r_static
r_void
id|diffstat_consume
c_func
(paren
r_void
op_star
id|priv
comma
r_char
op_star
id|line
comma
r_int
r_int
id|len
)paren
(brace
r_struct
id|diffstat_t
op_star
id|diffstat
op_assign
id|priv
suffix:semicolon
r_struct
id|diffstat_file
op_star
id|x
op_assign
id|diffstat-&gt;files
(braket
id|diffstat-&gt;nr
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|line
(braket
l_int|0
)braket
op_eq
l_char|&squot;+&squot;
)paren
id|x-&gt;added
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|line
(braket
l_int|0
)braket
op_eq
l_char|&squot;-&squot;
)paren
id|x-&gt;deleted
op_increment
suffix:semicolon
)brace
DECL|variable|mime_boundary_leader
r_const
r_char
id|mime_boundary_leader
(braket
)braket
op_assign
l_string|&quot;------------&quot;
suffix:semicolon
DECL|function|scale_linear
r_static
r_int
id|scale_linear
c_func
(paren
r_int
id|it
comma
r_int
id|width
comma
r_int
id|max_change
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|it
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * make sure that at least one &squot;-&squot; or &squot;+&squot; is printed if&n;&t; * there is any change to this path. The easiest way is to&n;&t; * scale linearly as if the alloted width is one column shorter&n;&t; * than it is, and then add 1 to the result.&n;&t; */
r_return
l_int|1
op_plus
(paren
id|it
op_star
(paren
id|width
l_int|1
)paren
op_div
id|max_change
)paren
suffix:semicolon
)brace
DECL|function|show_name
r_static
r_void
id|show_name
c_func
(paren
id|FILE
op_star
id|file
comma
r_const
r_char
op_star
id|prefix
comma
r_const
r_char
op_star
id|name
comma
r_int
id|len
)paren
(brace
id|fprintf
c_func
(paren
id|file
comma
l_string|&quot; %s%-*s |&quot;
comma
id|prefix
comma
id|len
comma
id|name
)paren
suffix:semicolon
)brace
DECL|function|show_graph
r_static
r_void
id|show_graph
c_func
(paren
id|FILE
op_star
id|file
comma
r_char
id|ch
comma
r_int
id|cnt
comma
r_const
r_char
op_star
id|set
comma
r_const
r_char
op_star
id|reset
)paren
(brace
r_if
c_cond
(paren
id|cnt
op_le
l_int|0
)paren
r_return
suffix:semicolon
id|fprintf
c_func
(paren
id|file
comma
l_string|&quot;%s&quot;
comma
id|set
)paren
suffix:semicolon
r_while
c_loop
(paren
id|cnt
op_decrement
)paren
id|putc
c_func
(paren
id|ch
comma
id|file
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|file
comma
l_string|&quot;%s&quot;
comma
id|reset
)paren
suffix:semicolon
)brace
DECL|function|fill_print_name
r_static
r_void
id|fill_print_name
c_func
(paren
r_struct
id|diffstat_file
op_star
id|file
)paren
(brace
r_char
op_star
id|pname
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;print_name
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file-&gt;is_renamed
)paren
(brace
r_struct
id|strbuf
id|buf
op_assign
id|STRBUF_INIT
suffix:semicolon
r_if
c_cond
(paren
id|quote_c_style
c_func
(paren
id|file-&gt;name
comma
op_amp
id|buf
comma
l_int|NULL
comma
l_int|0
)paren
)paren
(brace
id|pname
op_assign
id|strbuf_detach
c_func
(paren
op_amp
id|buf
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_else
(brace
id|pname
op_assign
id|file-&gt;name
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|buf
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|pname
op_assign
id|pprint_rename
c_func
(paren
id|file-&gt;from_name
comma
id|file-&gt;name
)paren
suffix:semicolon
)brace
id|file-&gt;print_name
op_assign
id|pname
suffix:semicolon
)brace
DECL|function|print_stat_summary
r_int
id|print_stat_summary
c_func
(paren
id|FILE
op_star
id|fp
comma
r_int
id|files
comma
r_int
id|insertions
comma
r_int
id|deletions
)paren
(brace
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|files
)paren
(brace
m_assert
(paren
id|insertions
op_eq
l_int|0
op_logical_and
id|deletions
op_eq
l_int|0
)paren
suffix:semicolon
r_return
id|fprintf
c_func
(paren
id|fp
comma
l_string|&quot;%s&bslash;n&quot;
comma
l_string|&quot; 0 files changed&quot;
)paren
suffix:semicolon
)brace
id|strbuf_addf
c_func
(paren
op_amp
id|sb
comma
(paren
id|files
op_eq
l_int|1
)paren
ques
c_cond
l_string|&quot; %d file changed&quot;
suffix:colon
l_string|&quot; %d files changed&quot;
comma
id|files
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * For binary diff, the caller may want to print &quot;x files&n;&t; * changed&quot; with insertions == 0 &amp;&amp; deletions == 0.&n;&t; *&n;&t; * Not omitting &quot;0 insertions(+), 0 deletions(-)&quot; in this case&n;&t; * is probably less confusing (i.e skip over &quot;2 files changed&n;&t; * but nothing about added/removed lines? Is this a bug in Git?&quot;).&n;&t; */
r_if
c_cond
(paren
id|insertions
op_logical_or
id|deletions
op_eq
l_int|0
)paren
(brace
id|strbuf_addf
c_func
(paren
op_amp
id|sb
comma
(paren
id|insertions
op_eq
l_int|1
)paren
ques
c_cond
l_string|&quot;, %d insertion(+)&quot;
suffix:colon
l_string|&quot;, %d insertions(+)&quot;
comma
id|insertions
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|deletions
op_logical_or
id|insertions
op_eq
l_int|0
)paren
(brace
id|strbuf_addf
c_func
(paren
op_amp
id|sb
comma
(paren
id|deletions
op_eq
l_int|1
)paren
ques
c_cond
l_string|&quot;, %d deletion(-)&quot;
suffix:colon
l_string|&quot;, %d deletions(-)&quot;
comma
id|deletions
)paren
suffix:semicolon
)brace
id|strbuf_addch
c_func
(paren
op_amp
id|sb
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|ret
op_assign
id|fputs
c_func
(paren
id|sb.buf
comma
id|fp
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|show_stats
r_static
r_void
id|show_stats
c_func
(paren
r_struct
id|diffstat_t
op_star
id|data
comma
r_struct
id|diff_options
op_star
id|options
)paren
(brace
r_int
id|i
comma
id|len
comma
id|add
comma
id|del
comma
id|adds
op_assign
l_int|0
comma
id|dels
op_assign
l_int|0
suffix:semicolon
r_uintmax
id|max_change
op_assign
l_int|0
comma
id|max_len
op_assign
l_int|0
suffix:semicolon
r_int
id|total_files
op_assign
id|data-&gt;nr
comma
id|count
suffix:semicolon
r_int
id|width
comma
id|name_width
comma
id|graph_width
comma
id|number_width
op_assign
l_int|0
comma
id|bin_width
op_assign
l_int|0
suffix:semicolon
r_const
r_char
op_star
id|reset
comma
op_star
id|add_c
comma
op_star
id|del_c
suffix:semicolon
r_const
r_char
op_star
id|line_prefix
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_int
id|extra_shown
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|data-&gt;nr
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|line_prefix
op_assign
id|diff_line_prefix
c_func
(paren
id|options
)paren
suffix:semicolon
id|count
op_assign
id|options-&gt;stat_count
ques
c_cond
id|options-&gt;stat_count
suffix:colon
id|data-&gt;nr
suffix:semicolon
id|reset
op_assign
id|diff_get_color_opt
c_func
(paren
id|options
comma
id|DIFF_RESET
)paren
suffix:semicolon
id|add_c
op_assign
id|diff_get_color_opt
c_func
(paren
id|options
comma
id|DIFF_FILE_NEW
)paren
suffix:semicolon
id|del_c
op_assign
id|diff_get_color_opt
c_func
(paren
id|options
comma
id|DIFF_FILE_OLD
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Find the longest filename and max number of changes&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
id|count
)paren
op_logical_and
(paren
id|i
OL
id|data-&gt;nr
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|diffstat_file
op_star
id|file
op_assign
id|data-&gt;files
(braket
id|i
)braket
suffix:semicolon
r_uintmax
id|change
op_assign
id|file-&gt;added
op_plus
id|file-&gt;deleted
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file-&gt;is_interesting
op_logical_and
(paren
id|change
op_eq
l_int|0
)paren
)paren
(brace
id|count
op_increment
suffix:semicolon
multiline_comment|/* not shown == room for one more */
r_continue
suffix:semicolon
)brace
id|fill_print_name
c_func
(paren
id|file
)paren
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|file-&gt;print_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|max_len
OL
id|len
)paren
id|max_len
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;is_unmerged
)paren
(brace
multiline_comment|/* &quot;Unmerged&quot; is 8 characters */
id|bin_width
op_assign
id|bin_width
OL
l_int|8
ques
c_cond
l_int|8
suffix:colon
id|bin_width
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;is_binary
)paren
(brace
multiline_comment|/* &quot;Bin XXX -&gt; YYY bytes&quot; */
r_int
id|w
op_assign
l_int|14
op_plus
id|decimal_width
c_func
(paren
id|file-&gt;added
)paren
op_plus
id|decimal_width
c_func
(paren
id|file-&gt;deleted
)paren
suffix:semicolon
id|bin_width
op_assign
id|bin_width
OL
id|w
ques
c_cond
id|w
suffix:colon
id|bin_width
suffix:semicolon
multiline_comment|/* Display change counts aligned with &quot;Bin&quot; */
id|number_width
op_assign
l_int|3
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|max_change
OL
id|change
)paren
id|max_change
op_assign
id|change
suffix:semicolon
)brace
id|count
op_assign
id|i
suffix:semicolon
multiline_comment|/* where we can stop scanning in data-&gt;files[] */
multiline_comment|/*&n;&t; * We have width = stat_width or term_columns() columns total.&n;&t; * We want a maximum of min(max_len, stat_name_width) for the name part.&n;&t; * We want a maximum of min(max_change, stat_graph_width) for the +- part.&n;&t; * We also need 1 for &quot; &quot; and 4 + decimal_width(max_change)&n;&t; * for &quot; | NNNN &quot; and one the empty column at the end, altogether&n;&t; * 6 + decimal_width(max_change).&n;&t; *&n;&t; * If there&squot;s not enough space, we will use the smaller of&n;&t; * stat_name_width (if set) and 5/8*width for the filename,&n;&t; * and the rest for constant elements + graph part, but no more&n;&t; * than stat_graph_width for the graph part.&n;&t; * (5/8 gives 50 for filename and 30 for the constant parts + graph&n;&t; * for the standard terminal size).&n;&t; *&n;&t; * In other words: stat_width limits the maximum width, and&n;&t; * stat_name_width fixes the maximum width of the filename,&n;&t; * and is also used to divide available columns if there&n;&t; * aren&squot;t enough.&n;&t; *&n;&t; * Binary files are displayed with &quot;Bin XXX -&gt; YYY bytes&quot;&n;&t; * instead of the change count and graph. This part is treated&n;&t; * similarly to the graph part, except that it is not&n;&t; * &quot;scaled&quot;. If total width is too small to accommodate the&n;&t; * guaranteed minimum width of the filename part and the&n;&t; * separators and this message, this message will &quot;overflow&quot;&n;&t; * making the line longer than the maximum width.&n;&t; */
r_if
c_cond
(paren
id|options-&gt;stat_width
op_eq
l_int|1
)paren
id|width
op_assign
id|term_columns
c_func
(paren
)paren
id|options-&gt;output_prefix_length
suffix:semicolon
r_else
id|width
op_assign
id|options-&gt;stat_width
ques
c_cond
id|options-&gt;stat_width
suffix:colon
l_int|80
suffix:semicolon
id|number_width
op_assign
id|decimal_width
c_func
(paren
id|max_change
)paren
OG
id|number_width
ques
c_cond
id|decimal_width
c_func
(paren
id|max_change
)paren
suffix:colon
id|number_width
suffix:semicolon
r_if
c_cond
(paren
id|options-&gt;stat_graph_width
op_eq
l_int|1
)paren
id|options-&gt;stat_graph_width
op_assign
id|diff_stat_graph_width
suffix:semicolon
multiline_comment|/*&n;&t; * Guarantee 3/8*16==6 for the graph part&n;&t; * and 5/8*16==10 for the filename part&n;&t; */
r_if
c_cond
(paren
id|width
OL
l_int|16
op_plus
l_int|6
op_plus
id|number_width
)paren
id|width
op_assign
l_int|16
op_plus
l_int|6
op_plus
id|number_width
suffix:semicolon
multiline_comment|/*&n;&t; * First assign sizes that are wanted, ignoring available width.&n;&t; * strlen(&quot;Bin XXX -&gt; YYY bytes&quot;) == bin_width, and the part&n;&t; * starting from &quot;XXX&quot; should fit in graph_width.&n;&t; */
id|graph_width
op_assign
id|max_change
op_plus
l_int|4
OG
id|bin_width
ques
c_cond
id|max_change
suffix:colon
id|bin_width
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|options-&gt;stat_graph_width
op_logical_and
id|options-&gt;stat_graph_width
OL
id|graph_width
)paren
id|graph_width
op_assign
id|options-&gt;stat_graph_width
suffix:semicolon
id|name_width
op_assign
(paren
id|options-&gt;stat_name_width
OG
l_int|0
op_logical_and
id|options-&gt;stat_name_width
OL
id|max_len
)paren
ques
c_cond
id|options-&gt;stat_name_width
suffix:colon
id|max_len
suffix:semicolon
multiline_comment|/*&n;&t; * Adjust adjustable widths not to exceed maximum width&n;&t; */
r_if
c_cond
(paren
id|name_width
op_plus
id|number_width
op_plus
l_int|6
op_plus
id|graph_width
OG
id|width
)paren
(brace
r_if
c_cond
(paren
id|graph_width
OG
id|width
op_star
l_int|3
op_div
l_int|8
id|number_width
l_int|6
)paren
(brace
id|graph_width
op_assign
id|width
op_star
l_int|3
op_div
l_int|8
id|number_width
l_int|6
suffix:semicolon
r_if
c_cond
(paren
id|graph_width
OL
l_int|6
)paren
id|graph_width
op_assign
l_int|6
suffix:semicolon
)brace
r_if
c_cond
(paren
id|options-&gt;stat_graph_width
op_logical_and
id|graph_width
OG
id|options-&gt;stat_graph_width
)paren
id|graph_width
op_assign
id|options-&gt;stat_graph_width
suffix:semicolon
r_if
c_cond
(paren
id|name_width
OG
id|width
id|number_width
l_int|6
id|graph_width
)paren
id|name_width
op_assign
id|width
id|number_width
l_int|6
id|graph_width
suffix:semicolon
r_else
id|graph_width
op_assign
id|width
id|number_width
l_int|6
id|name_width
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * From here name_width is the width of the name area,&n;&t; * and graph_width is the width of the graph area.&n;&t; * max_change is used to scale graph properly.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_char
op_star
id|prefix
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_struct
id|diffstat_file
op_star
id|file
op_assign
id|data-&gt;files
(braket
id|i
)braket
suffix:semicolon
r_char
op_star
id|name
op_assign
id|file-&gt;print_name
suffix:semicolon
r_uintmax
id|added
op_assign
id|file-&gt;added
suffix:semicolon
r_uintmax
id|deleted
op_assign
id|file-&gt;deleted
suffix:semicolon
r_int
id|name_len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file-&gt;is_interesting
op_logical_and
(paren
id|added
op_plus
id|deleted
op_eq
l_int|0
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * &quot;scale&quot; the filename&n;&t;&t; */
id|len
op_assign
id|name_width
suffix:semicolon
id|name_len
op_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|name_width
OL
id|name_len
)paren
(brace
r_char
op_star
id|slash
suffix:semicolon
id|prefix
op_assign
l_string|&quot;...&quot;
suffix:semicolon
id|len
op_sub_assign
l_int|3
suffix:semicolon
id|name
op_add_assign
id|name_len
id|len
suffix:semicolon
id|slash
op_assign
id|strchr
c_func
(paren
id|name
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slash
)paren
id|name
op_assign
id|slash
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;is_binary
)paren
(brace
id|fprintf
c_func
(paren
id|options-&gt;file
comma
l_string|&quot;%s&quot;
comma
id|line_prefix
)paren
suffix:semicolon
id|show_name
c_func
(paren
id|options-&gt;file
comma
id|prefix
comma
id|name
comma
id|len
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|options-&gt;file
comma
l_string|&quot; %*s&quot;
comma
id|number_width
comma
l_string|&quot;Bin&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|added
op_logical_and
op_logical_neg
id|deleted
)paren
(brace
id|putc
c_func
(paren
l_char|&squot;&bslash;n&squot;
comma
id|options-&gt;file
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|fprintf
c_func
(paren
id|options-&gt;file
comma
l_string|&quot; %s%&quot;
id|PRIuMAX
l_string|&quot;%s&quot;
comma
id|del_c
comma
id|deleted
comma
id|reset
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|options-&gt;file
comma
l_string|&quot; -&gt; &quot;
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|options-&gt;file
comma
l_string|&quot;%s%&quot;
id|PRIuMAX
l_string|&quot;%s&quot;
comma
id|add_c
comma
id|added
comma
id|reset
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|options-&gt;file
comma
l_string|&quot; bytes&quot;
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|options-&gt;file
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|file-&gt;is_unmerged
)paren
(brace
id|fprintf
c_func
(paren
id|options-&gt;file
comma
l_string|&quot;%s&quot;
comma
id|line_prefix
)paren
suffix:semicolon
id|show_name
c_func
(paren
id|options-&gt;file
comma
id|prefix
comma
id|name
comma
id|len
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|options-&gt;file
comma
l_string|&quot; Unmerged&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * scale the add/delete&n;&t;&t; */
id|add
op_assign
id|added
suffix:semicolon
id|del
op_assign
id|deleted
suffix:semicolon
r_if
c_cond
(paren
id|graph_width
op_le
id|max_change
)paren
(brace
r_int
id|total
op_assign
id|scale_linear
c_func
(paren
id|add
op_plus
id|del
comma
id|graph_width
comma
id|max_change
)paren
suffix:semicolon
r_if
c_cond
(paren
id|total
OL
l_int|2
op_logical_and
id|add
op_logical_and
id|del
)paren
multiline_comment|/* width &gt;= 2 due to the sanity check */
id|total
op_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|add
OL
id|del
)paren
(brace
id|add
op_assign
id|scale_linear
c_func
(paren
id|add
comma
id|graph_width
comma
id|max_change
)paren
suffix:semicolon
id|del
op_assign
id|total
id|add
suffix:semicolon
)brace
r_else
(brace
id|del
op_assign
id|scale_linear
c_func
(paren
id|del
comma
id|graph_width
comma
id|max_change
)paren
suffix:semicolon
id|add
op_assign
id|total
id|del
suffix:semicolon
)brace
)brace
id|fprintf
c_func
(paren
id|options-&gt;file
comma
l_string|&quot;%s&quot;
comma
id|line_prefix
)paren
suffix:semicolon
id|show_name
c_func
(paren
id|options-&gt;file
comma
id|prefix
comma
id|name
comma
id|len
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|options-&gt;file
comma
l_string|&quot; %*&quot;
id|PRIuMAX
l_string|&quot;%s&quot;
comma
id|number_width
comma
id|added
op_plus
id|deleted
comma
id|added
op_plus
id|deleted
ques
c_cond
l_string|&quot; &quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|show_graph
c_func
(paren
id|options-&gt;file
comma
l_char|&squot;+&squot;
comma
id|add
comma
id|add_c
comma
id|reset
)paren
suffix:semicolon
id|show_graph
c_func
(paren
id|options-&gt;file
comma
l_char|&squot;-&squot;
comma
id|del
comma
id|del_c
comma
id|reset
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|options-&gt;file
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|data-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|diffstat_file
op_star
id|file
op_assign
id|data-&gt;files
(braket
id|i
)braket
suffix:semicolon
r_uintmax
id|added
op_assign
id|file-&gt;added
suffix:semicolon
r_uintmax
id|deleted
op_assign
id|file-&gt;deleted
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;is_unmerged
op_logical_or
(paren
op_logical_neg
id|file-&gt;is_interesting
op_logical_and
(paren
id|added
op_plus
id|deleted
op_eq
l_int|0
)paren
)paren
)paren
(brace
id|total_files
op_decrement
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|file-&gt;is_binary
)paren
(brace
id|adds
op_add_assign
id|added
suffix:semicolon
id|dels
op_add_assign
id|deleted
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
OL
id|count
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|extra_shown
)paren
id|fprintf
c_func
(paren
id|options-&gt;file
comma
l_string|&quot;%s ...&bslash;n&quot;
comma
id|line_prefix
)paren
suffix:semicolon
id|extra_shown
op_assign
l_int|1
suffix:semicolon
)brace
id|fprintf
c_func
(paren
id|options-&gt;file
comma
l_string|&quot;%s&quot;
comma
id|line_prefix
)paren
suffix:semicolon
id|print_stat_summary
c_func
(paren
id|options-&gt;file
comma
id|total_files
comma
id|adds
comma
id|dels
)paren
suffix:semicolon
)brace
DECL|function|show_shortstats
r_static
r_void
id|show_shortstats
c_func
(paren
r_struct
id|diffstat_t
op_star
id|data
comma
r_struct
id|diff_options
op_star
id|options
)paren
(brace
r_int
id|i
comma
id|adds
op_assign
l_int|0
comma
id|dels
op_assign
l_int|0
comma
id|total_files
op_assign
id|data-&gt;nr
suffix:semicolon
r_if
c_cond
(paren
id|data-&gt;nr
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|data-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|added
op_assign
id|data-&gt;files
(braket
id|i
)braket
op_member_access_from_pointer
id|added
suffix:semicolon
r_int
id|deleted
op_assign
id|data-&gt;files
(braket
id|i
)braket
op_member_access_from_pointer
id|deleted
suffix:semicolon
r_if
c_cond
(paren
id|data-&gt;files
(braket
id|i
)braket
op_member_access_from_pointer
id|is_unmerged
op_logical_or
(paren
op_logical_neg
id|data-&gt;files
(braket
id|i
)braket
op_member_access_from_pointer
id|is_interesting
op_logical_and
(paren
id|added
op_plus
id|deleted
op_eq
l_int|0
)paren
)paren
)paren
(brace
id|total_files
op_decrement
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|data-&gt;files
(braket
id|i
)braket
op_member_access_from_pointer
id|is_binary
)paren
(brace
multiline_comment|/* don&squot;t count bytes */
id|adds
op_add_assign
id|added
suffix:semicolon
id|dels
op_add_assign
id|deleted
suffix:semicolon
)brace
)brace
id|fprintf
c_func
(paren
id|options-&gt;file
comma
l_string|&quot;%s&quot;
comma
id|diff_line_prefix
c_func
(paren
id|options
)paren
)paren
suffix:semicolon
id|print_stat_summary
c_func
(paren
id|options-&gt;file
comma
id|total_files
comma
id|adds
comma
id|dels
)paren
suffix:semicolon
)brace
DECL|function|show_numstat
r_static
r_void
id|show_numstat
c_func
(paren
r_struct
id|diffstat_t
op_star
id|data
comma
r_struct
id|diff_options
op_star
id|options
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|data-&gt;nr
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|data-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|diffstat_file
op_star
id|file
op_assign
id|data-&gt;files
(braket
id|i
)braket
suffix:semicolon
id|fprintf
c_func
(paren
id|options-&gt;file
comma
l_string|&quot;%s&quot;
comma
id|diff_line_prefix
c_func
(paren
id|options
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;is_binary
)paren
id|fprintf
c_func
(paren
id|options-&gt;file
comma
l_string|&quot;-&bslash;t-&bslash;t&quot;
)paren
suffix:semicolon
r_else
id|fprintf
c_func
(paren
id|options-&gt;file
comma
l_string|&quot;%&quot;
id|PRIuMAX
l_string|&quot;&bslash;t%&quot;
id|PRIuMAX
l_string|&quot;&bslash;t&quot;
comma
id|file-&gt;added
comma
id|file-&gt;deleted
)paren
suffix:semicolon
r_if
c_cond
(paren
id|options-&gt;line_termination
)paren
(brace
id|fill_print_name
c_func
(paren
id|file
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file-&gt;is_renamed
)paren
id|write_name_quoted
c_func
(paren
id|file-&gt;name
comma
id|options-&gt;file
comma
id|options-&gt;line_termination
)paren
suffix:semicolon
r_else
(brace
id|fputs
c_func
(paren
id|file-&gt;print_name
comma
id|options-&gt;file
)paren
suffix:semicolon
id|putc
c_func
(paren
id|options-&gt;line_termination
comma
id|options-&gt;file
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|file-&gt;is_renamed
)paren
(brace
id|putc
c_func
(paren
l_char|&squot;&bslash;0&squot;
comma
id|options-&gt;file
)paren
suffix:semicolon
id|write_name_quoted
c_func
(paren
id|file-&gt;from_name
comma
id|options-&gt;file
comma
l_char|&squot;&bslash;0&squot;
)paren
suffix:semicolon
)brace
id|write_name_quoted
c_func
(paren
id|file-&gt;name
comma
id|options-&gt;file
comma
l_char|&squot;&bslash;0&squot;
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|struct|dirstat_file
r_struct
id|dirstat_file
(brace
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
DECL|member|changed
r_int
r_int
id|changed
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|dirstat_dir
r_struct
id|dirstat_dir
(brace
DECL|member|files
r_struct
id|dirstat_file
op_star
id|files
suffix:semicolon
DECL|member|alloc
DECL|member|nr
DECL|member|permille
DECL|member|cumulative
r_int
id|alloc
comma
id|nr
comma
id|permille
comma
id|cumulative
suffix:semicolon
)brace
suffix:semicolon
DECL|function|gather_dirstat
r_static
r_int
id|gather_dirstat
c_func
(paren
r_struct
id|diff_options
op_star
id|opt
comma
r_struct
id|dirstat_dir
op_star
id|dir
comma
r_int
r_int
id|changed
comma
r_const
r_char
op_star
id|base
comma
r_int
id|baselen
)paren
(brace
r_int
r_int
id|this_dir
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|sources
op_assign
l_int|0
suffix:semicolon
r_const
r_char
op_star
id|line_prefix
op_assign
id|diff_line_prefix
c_func
(paren
id|opt
)paren
suffix:semicolon
r_while
c_loop
(paren
id|dir-&gt;nr
)paren
(brace
r_struct
id|dirstat_file
op_star
id|f
op_assign
id|dir-&gt;files
suffix:semicolon
r_int
id|namelen
op_assign
id|strlen
c_func
(paren
id|f-&gt;name
)paren
suffix:semicolon
r_int
r_int
id|this
suffix:semicolon
r_char
op_star
id|slash
suffix:semicolon
r_if
c_cond
(paren
id|namelen
OL
id|baselen
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|f-&gt;name
comma
id|base
comma
id|baselen
)paren
)paren
r_break
suffix:semicolon
id|slash
op_assign
id|strchr
c_func
(paren
id|f-&gt;name
op_plus
id|baselen
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slash
)paren
(brace
r_int
id|newbaselen
op_assign
id|slash
op_plus
l_int|1
id|f-&gt;name
suffix:semicolon
id|this
op_assign
id|gather_dirstat
c_func
(paren
id|opt
comma
id|dir
comma
id|changed
comma
id|f-&gt;name
comma
id|newbaselen
)paren
suffix:semicolon
id|sources
op_increment
suffix:semicolon
)brace
r_else
(brace
id|this
op_assign
id|f-&gt;changed
suffix:semicolon
id|dir-&gt;files
op_increment
suffix:semicolon
id|dir-&gt;nr
op_decrement
suffix:semicolon
id|sources
op_add_assign
l_int|2
suffix:semicolon
)brace
id|this_dir
op_add_assign
id|this
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We don&squot;t report dirstat&squot;s for&n;&t; *  - the top level&n;&t; *  - or cases where everything came from a single directory&n;&t; *    under this directory (sources == 1).&n;&t; */
r_if
c_cond
(paren
id|baselen
op_logical_and
id|sources
op_ne
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|this_dir
)paren
(brace
r_int
id|permille
op_assign
id|this_dir
op_star
l_int|1000
op_div
id|changed
suffix:semicolon
r_if
c_cond
(paren
id|permille
op_ge
id|dir-&gt;permille
)paren
(brace
id|fprintf
c_func
(paren
id|opt-&gt;file
comma
l_string|&quot;%s%4d.%01d%% %.*s&bslash;n&quot;
comma
id|line_prefix
comma
id|permille
op_div
l_int|10
comma
id|permille
op_mod
l_int|10
comma
id|baselen
comma
id|base
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir-&gt;cumulative
)paren
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_return
id|this_dir
suffix:semicolon
)brace
DECL|function|dirstat_compare
r_static
r_int
id|dirstat_compare
c_func
(paren
r_const
r_void
op_star
id|_a
comma
r_const
r_void
op_star
id|_b
)paren
(brace
r_const
r_struct
id|dirstat_file
op_star
id|a
op_assign
id|_a
suffix:semicolon
r_const
r_struct
id|dirstat_file
op_star
id|b
op_assign
id|_b
suffix:semicolon
r_return
id|strcmp
c_func
(paren
id|a-&gt;name
comma
id|b-&gt;name
)paren
suffix:semicolon
)brace
DECL|function|show_dirstat
r_static
r_void
id|show_dirstat
c_func
(paren
r_struct
id|diff_options
op_star
id|options
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|changed
suffix:semicolon
r_struct
id|dirstat_dir
id|dir
suffix:semicolon
r_struct
id|diff_queue_struct
op_star
id|q
op_assign
op_amp
id|diff_queued_diff
suffix:semicolon
id|dir.files
op_assign
l_int|NULL
suffix:semicolon
id|dir.alloc
op_assign
l_int|0
suffix:semicolon
id|dir.nr
op_assign
l_int|0
suffix:semicolon
id|dir.permille
op_assign
id|options-&gt;dirstat_permille
suffix:semicolon
id|dir.cumulative
op_assign
id|DIFF_OPT_TST
c_func
(paren
id|options
comma
id|DIRSTAT_CUMULATIVE
)paren
suffix:semicolon
id|changed
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|q-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|diff_filepair
op_star
id|p
op_assign
id|q-&gt;queue
(braket
id|i
)braket
suffix:semicolon
r_const
r_char
op_star
id|name
suffix:semicolon
r_int
r_int
id|copied
comma
id|added
comma
id|damage
suffix:semicolon
r_int
id|content_changed
suffix:semicolon
id|name
op_assign
id|p-&gt;two-&gt;path
ques
c_cond
id|p-&gt;two-&gt;path
suffix:colon
id|p-&gt;one-&gt;path
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;one-&gt;sha1_valid
op_logical_and
id|p-&gt;two-&gt;sha1_valid
)paren
id|content_changed
op_assign
id|hashcmp
c_func
(paren
id|p-&gt;one-&gt;sha1
comma
id|p-&gt;two-&gt;sha1
)paren
suffix:semicolon
r_else
id|content_changed
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|content_changed
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * The SHA1 has not changed, so pre-/post-content is&n;&t;&t;&t; * identical. We can therefore skip looking at the&n;&t;&t;&t; * file contents altogether.&n;&t;&t;&t; */
id|damage
op_assign
l_int|0
suffix:semicolon
r_goto
id|found_damage
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DIFF_OPT_TST
c_func
(paren
id|options
comma
id|DIRSTAT_BY_FILE
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * In --dirstat-by-file mode, we don&squot;t really need to&n;&t;&t;&t; * look at the actual file contents at all.&n;&t;&t;&t; * The fact that the SHA1 changed is enough for us to&n;&t;&t;&t; * add this file to the list of results&n;&t;&t;&t; * (with each file contributing equal damage).&n;&t;&t;&t; */
id|damage
op_assign
l_int|1
suffix:semicolon
r_goto
id|found_damage
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DIFF_FILE_VALID
c_func
(paren
id|p-&gt;one
)paren
op_logical_and
id|DIFF_FILE_VALID
c_func
(paren
id|p-&gt;two
)paren
)paren
(brace
id|diff_populate_filespec
c_func
(paren
id|p-&gt;one
comma
l_int|0
)paren
suffix:semicolon
id|diff_populate_filespec
c_func
(paren
id|p-&gt;two
comma
l_int|0
)paren
suffix:semicolon
id|diffcore_count_changes
c_func
(paren
id|p-&gt;one
comma
id|p-&gt;two
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
op_amp
id|copied
comma
op_amp
id|added
)paren
suffix:semicolon
id|diff_free_filespec_data
c_func
(paren
id|p-&gt;one
)paren
suffix:semicolon
id|diff_free_filespec_data
c_func
(paren
id|p-&gt;two
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|DIFF_FILE_VALID
c_func
(paren
id|p-&gt;one
)paren
)paren
(brace
id|diff_populate_filespec
c_func
(paren
id|p-&gt;one
comma
l_int|1
)paren
suffix:semicolon
id|copied
op_assign
id|added
op_assign
l_int|0
suffix:semicolon
id|diff_free_filespec_data
c_func
(paren
id|p-&gt;one
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|DIFF_FILE_VALID
c_func
(paren
id|p-&gt;two
)paren
)paren
(brace
id|diff_populate_filespec
c_func
(paren
id|p-&gt;two
comma
l_int|1
)paren
suffix:semicolon
id|copied
op_assign
l_int|0
suffix:semicolon
id|added
op_assign
id|p-&gt;two-&gt;size
suffix:semicolon
id|diff_free_filespec_data
c_func
(paren
id|p-&gt;two
)paren
suffix:semicolon
)brace
r_else
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Original minus copied is the removed material,&n;&t;&t; * added is the new material.  They are both damages&n;&t;&t; * made to the preimage.&n;&t;&t; * If the resulting damage is zero, we know that&n;&t;&t; * diffcore_count_changes() considers the two entries to&n;&t;&t; * be identical, but since content_changed is true, we&n;&t;&t; * know that there must have been _some_ kind of change,&n;&t;&t; * so we force all entries to have damage &gt; 0.&n;&t;&t; */
id|damage
op_assign
(paren
id|p-&gt;one-&gt;size
id|copied
)paren
op_plus
id|added
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|damage
)paren
id|damage
op_assign
l_int|1
suffix:semicolon
id|found_damage
suffix:colon
id|ALLOC_GROW
c_func
(paren
id|dir.files
comma
id|dir.nr
op_plus
l_int|1
comma
id|dir.alloc
)paren
suffix:semicolon
id|dir.files
(braket
id|dir.nr
)braket
dot
id|name
op_assign
id|name
suffix:semicolon
id|dir.files
(braket
id|dir.nr
)braket
dot
id|changed
op_assign
id|damage
suffix:semicolon
id|changed
op_add_assign
id|damage
suffix:semicolon
id|dir.nr
op_increment
suffix:semicolon
)brace
multiline_comment|/* This can happen even with many files, if everything was renames */
r_if
c_cond
(paren
op_logical_neg
id|changed
)paren
r_return
suffix:semicolon
multiline_comment|/* Show all directories with more than x% of the changes */
id|qsort
c_func
(paren
id|dir.files
comma
id|dir.nr
comma
r_sizeof
(paren
id|dir.files
(braket
l_int|0
)braket
)paren
comma
id|dirstat_compare
)paren
suffix:semicolon
id|gather_dirstat
c_func
(paren
id|options
comma
op_amp
id|dir
comma
id|changed
comma
l_string|&quot;&quot;
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|show_dirstat_by_line
r_static
r_void
id|show_dirstat_by_line
c_func
(paren
r_struct
id|diffstat_t
op_star
id|data
comma
r_struct
id|diff_options
op_star
id|options
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|changed
suffix:semicolon
r_struct
id|dirstat_dir
id|dir
suffix:semicolon
r_if
c_cond
(paren
id|data-&gt;nr
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|dir.files
op_assign
l_int|NULL
suffix:semicolon
id|dir.alloc
op_assign
l_int|0
suffix:semicolon
id|dir.nr
op_assign
l_int|0
suffix:semicolon
id|dir.permille
op_assign
id|options-&gt;dirstat_permille
suffix:semicolon
id|dir.cumulative
op_assign
id|DIFF_OPT_TST
c_func
(paren
id|options
comma
id|DIRSTAT_CUMULATIVE
)paren
suffix:semicolon
id|changed
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|data-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|diffstat_file
op_star
id|file
op_assign
id|data-&gt;files
(braket
id|i
)braket
suffix:semicolon
r_int
r_int
id|damage
op_assign
id|file-&gt;added
op_plus
id|file-&gt;deleted
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;is_binary
)paren
multiline_comment|/*&n;&t;&t;&t; * binary files counts bytes, not lines. Must find some&n;&t;&t;&t; * way to normalize binary bytes vs. textual lines.&n;&t;&t;&t; * The following heuristic assumes that there are 64&n;&t;&t;&t; * bytes per &quot;line&quot;.&n;&t;&t;&t; * This is stupid and ugly, but very cheap...&n;&t;&t;&t; */
id|damage
op_assign
(paren
id|damage
op_plus
l_int|63
)paren
op_div
l_int|64
suffix:semicolon
id|ALLOC_GROW
c_func
(paren
id|dir.files
comma
id|dir.nr
op_plus
l_int|1
comma
id|dir.alloc
)paren
suffix:semicolon
id|dir.files
(braket
id|dir.nr
)braket
dot
id|name
op_assign
id|file-&gt;name
suffix:semicolon
id|dir.files
(braket
id|dir.nr
)braket
dot
id|changed
op_assign
id|damage
suffix:semicolon
id|changed
op_add_assign
id|damage
suffix:semicolon
id|dir.nr
op_increment
suffix:semicolon
)brace
multiline_comment|/* This can happen even with many files, if everything was renames */
r_if
c_cond
(paren
op_logical_neg
id|changed
)paren
r_return
suffix:semicolon
multiline_comment|/* Show all directories with more than x% of the changes */
id|qsort
c_func
(paren
id|dir.files
comma
id|dir.nr
comma
r_sizeof
(paren
id|dir.files
(braket
l_int|0
)braket
)paren
comma
id|dirstat_compare
)paren
suffix:semicolon
id|gather_dirstat
c_func
(paren
id|options
comma
op_amp
id|dir
comma
id|changed
comma
l_string|&quot;&quot;
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|free_diffstat_info
r_static
r_void
id|free_diffstat_info
c_func
(paren
r_struct
id|diffstat_t
op_star
id|diffstat
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|diffstat-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|diffstat_file
op_star
id|f
op_assign
id|diffstat-&gt;files
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|f-&gt;name
op_ne
id|f-&gt;print_name
)paren
id|free
c_func
(paren
id|f-&gt;print_name
)paren
suffix:semicolon
id|free
c_func
(paren
id|f-&gt;name
)paren
suffix:semicolon
id|free
c_func
(paren
id|f-&gt;from_name
)paren
suffix:semicolon
id|free
c_func
(paren
id|f
)paren
suffix:semicolon
)brace
id|free
c_func
(paren
id|diffstat-&gt;files
)paren
suffix:semicolon
)brace
DECL|struct|checkdiff_t
r_struct
id|checkdiff_t
(brace
DECL|member|filename
r_const
r_char
op_star
id|filename
suffix:semicolon
DECL|member|lineno
r_int
id|lineno
suffix:semicolon
DECL|member|conflict_marker_size
r_int
id|conflict_marker_size
suffix:semicolon
DECL|member|o
r_struct
id|diff_options
op_star
id|o
suffix:semicolon
DECL|member|ws_rule
r_int
id|ws_rule
suffix:semicolon
DECL|member|status
r_int
id|status
suffix:semicolon
)brace
suffix:semicolon
DECL|function|is_conflict_marker
r_static
r_int
id|is_conflict_marker
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_int
id|marker_size
comma
r_int
r_int
id|len
)paren
(brace
r_char
id|firstchar
suffix:semicolon
r_int
id|cnt
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
id|marker_size
op_plus
l_int|1
)paren
r_return
l_int|0
suffix:semicolon
id|firstchar
op_assign
id|line
(braket
l_int|0
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|firstchar
)paren
(brace
r_case
l_char|&squot;=&squot;
suffix:colon
r_case
l_char|&squot;&gt;&squot;
suffix:colon
r_case
l_char|&squot;&lt;&squot;
suffix:colon
r_case
l_char|&squot;|&squot;
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|cnt
op_assign
l_int|1
suffix:semicolon
id|cnt
OL
id|marker_size
suffix:semicolon
id|cnt
op_increment
)paren
r_if
c_cond
(paren
id|line
(braket
id|cnt
)braket
op_ne
id|firstchar
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* line[1] thru line[marker_size-1] are same as firstchar */
r_if
c_cond
(paren
id|len
OL
id|marker_size
op_plus
l_int|1
op_logical_or
op_logical_neg
id|isspace
c_func
(paren
id|line
(braket
id|marker_size
)braket
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|checkdiff_consume
r_static
r_void
id|checkdiff_consume
c_func
(paren
r_void
op_star
id|priv
comma
r_char
op_star
id|line
comma
r_int
r_int
id|len
)paren
(brace
r_struct
id|checkdiff_t
op_star
id|data
op_assign
id|priv
suffix:semicolon
r_int
id|marker_size
op_assign
id|data-&gt;conflict_marker_size
suffix:semicolon
r_const
r_char
op_star
id|ws
op_assign
id|diff_get_color
c_func
(paren
id|data-&gt;o-&gt;use_color
comma
id|DIFF_WHITESPACE
)paren
suffix:semicolon
r_const
r_char
op_star
id|reset
op_assign
id|diff_get_color
c_func
(paren
id|data-&gt;o-&gt;use_color
comma
id|DIFF_RESET
)paren
suffix:semicolon
r_const
r_char
op_star
id|set
op_assign
id|diff_get_color
c_func
(paren
id|data-&gt;o-&gt;use_color
comma
id|DIFF_FILE_NEW
)paren
suffix:semicolon
r_char
op_star
id|err
suffix:semicolon
r_const
r_char
op_star
id|line_prefix
suffix:semicolon
m_assert
(paren
id|data-&gt;o
)paren
suffix:semicolon
id|line_prefix
op_assign
id|diff_line_prefix
c_func
(paren
id|data-&gt;o
)paren
suffix:semicolon
r_if
c_cond
(paren
id|line
(braket
l_int|0
)braket
op_eq
l_char|&squot;+&squot;
)paren
(brace
r_int
id|bad
suffix:semicolon
id|data-&gt;lineno
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|is_conflict_marker
c_func
(paren
id|line
op_plus
l_int|1
comma
id|marker_size
comma
id|len
l_int|1
)paren
)paren
(brace
id|data-&gt;status
op_or_assign
l_int|1
suffix:semicolon
id|fprintf
c_func
(paren
id|data-&gt;o-&gt;file
comma
l_string|&quot;%s%s:%d: leftover conflict marker&bslash;n&quot;
comma
id|line_prefix
comma
id|data-&gt;filename
comma
id|data-&gt;lineno
)paren
suffix:semicolon
)brace
id|bad
op_assign
id|ws_check
c_func
(paren
id|line
op_plus
l_int|1
comma
id|len
l_int|1
comma
id|data-&gt;ws_rule
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bad
)paren
r_return
suffix:semicolon
id|data-&gt;status
op_or_assign
id|bad
suffix:semicolon
id|err
op_assign
id|whitespace_error_string
c_func
(paren
id|bad
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|data-&gt;o-&gt;file
comma
l_string|&quot;%s%s:%d: %s.&bslash;n&quot;
comma
id|line_prefix
comma
id|data-&gt;filename
comma
id|data-&gt;lineno
comma
id|err
)paren
suffix:semicolon
id|free
c_func
(paren
id|err
)paren
suffix:semicolon
id|emit_line
c_func
(paren
id|data-&gt;o
comma
id|set
comma
id|reset
comma
id|line
comma
l_int|1
)paren
suffix:semicolon
id|ws_check_emit
c_func
(paren
id|line
op_plus
l_int|1
comma
id|len
l_int|1
comma
id|data-&gt;ws_rule
comma
id|data-&gt;o-&gt;file
comma
id|set
comma
id|reset
comma
id|ws
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|line
(braket
l_int|0
)braket
op_eq
l_char|&squot; &squot;
)paren
(brace
id|data-&gt;lineno
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|line
(braket
l_int|0
)braket
op_eq
l_char|&squot;@&squot;
)paren
(brace
r_char
op_star
id|plus
op_assign
id|strchr
c_func
(paren
id|line
comma
l_char|&squot;+&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|plus
)paren
id|data-&gt;lineno
op_assign
id|strtol
c_func
(paren
id|plus
comma
l_int|NULL
comma
l_int|10
)paren
l_int|1
suffix:semicolon
r_else
id|die
c_func
(paren
l_string|&quot;invalid diff&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|function|deflate_it
r_static
r_int
r_char
op_star
id|deflate_it
c_func
(paren
r_char
op_star
id|data
comma
r_int
r_int
id|size
comma
r_int
r_int
op_star
id|result_size
)paren
(brace
r_int
id|bound
suffix:semicolon
r_int
r_char
op_star
id|deflated
suffix:semicolon
id|git_zstream
id|stream
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|stream
comma
l_int|0
comma
r_sizeof
(paren
id|stream
)paren
)paren
suffix:semicolon
id|git_deflate_init
c_func
(paren
op_amp
id|stream
comma
id|zlib_compression_level
)paren
suffix:semicolon
id|bound
op_assign
id|git_deflate_bound
c_func
(paren
op_amp
id|stream
comma
id|size
)paren
suffix:semicolon
id|deflated
op_assign
id|xmalloc
c_func
(paren
id|bound
)paren
suffix:semicolon
id|stream.next_out
op_assign
id|deflated
suffix:semicolon
id|stream.avail_out
op_assign
id|bound
suffix:semicolon
id|stream.next_in
op_assign
(paren
r_int
r_char
op_star
)paren
id|data
suffix:semicolon
id|stream.avail_in
op_assign
id|size
suffix:semicolon
r_while
c_loop
(paren
id|git_deflate
c_func
(paren
op_amp
id|stream
comma
id|Z_FINISH
)paren
op_eq
id|Z_OK
)paren
suffix:semicolon
multiline_comment|/* nothing */
id|git_deflate_end
c_func
(paren
op_amp
id|stream
)paren
suffix:semicolon
op_star
id|result_size
op_assign
id|stream.total_out
suffix:semicolon
r_return
id|deflated
suffix:semicolon
)brace
DECL|function|emit_binary_diff_body
r_static
r_void
id|emit_binary_diff_body
c_func
(paren
id|FILE
op_star
id|file
comma
id|mmfile_t
op_star
id|one
comma
id|mmfile_t
op_star
id|two
comma
r_const
r_char
op_star
id|prefix
)paren
(brace
r_void
op_star
id|cp
suffix:semicolon
r_void
op_star
id|delta
suffix:semicolon
r_void
op_star
id|deflated
suffix:semicolon
r_void
op_star
id|data
suffix:semicolon
r_int
r_int
id|orig_size
suffix:semicolon
r_int
r_int
id|delta_size
suffix:semicolon
r_int
r_int
id|deflate_size
suffix:semicolon
r_int
r_int
id|data_size
suffix:semicolon
multiline_comment|/* We could do deflated delta, or we could do just deflated two,&n;&t; * whichever is smaller.&n;&t; */
id|delta
op_assign
l_int|NULL
suffix:semicolon
id|deflated
op_assign
id|deflate_it
c_func
(paren
id|two-&gt;ptr
comma
id|two-&gt;size
comma
op_amp
id|deflate_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|one-&gt;size
op_logical_and
id|two-&gt;size
)paren
(brace
id|delta
op_assign
id|diff_delta
c_func
(paren
id|one-&gt;ptr
comma
id|one-&gt;size
comma
id|two-&gt;ptr
comma
id|two-&gt;size
comma
op_amp
id|delta_size
comma
id|deflate_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|delta
)paren
(brace
r_void
op_star
id|to_free
op_assign
id|delta
suffix:semicolon
id|orig_size
op_assign
id|delta_size
suffix:semicolon
id|delta
op_assign
id|deflate_it
c_func
(paren
id|delta
comma
id|delta_size
comma
op_amp
id|delta_size
)paren
suffix:semicolon
id|free
c_func
(paren
id|to_free
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|delta
op_logical_and
id|delta_size
OL
id|deflate_size
)paren
(brace
id|fprintf
c_func
(paren
id|file
comma
l_string|&quot;%sdelta %lu&bslash;n&quot;
comma
id|prefix
comma
id|orig_size
)paren
suffix:semicolon
id|free
c_func
(paren
id|deflated
)paren
suffix:semicolon
id|data
op_assign
id|delta
suffix:semicolon
id|data_size
op_assign
id|delta_size
suffix:semicolon
)brace
r_else
(brace
id|fprintf
c_func
(paren
id|file
comma
l_string|&quot;%sliteral %lu&bslash;n&quot;
comma
id|prefix
comma
id|two-&gt;size
)paren
suffix:semicolon
id|free
c_func
(paren
id|delta
)paren
suffix:semicolon
id|data
op_assign
id|deflated
suffix:semicolon
id|data_size
op_assign
id|deflate_size
suffix:semicolon
)brace
multiline_comment|/* emit data encoded in base85 */
id|cp
op_assign
id|data
suffix:semicolon
r_while
c_loop
(paren
id|data_size
)paren
(brace
r_int
id|bytes
op_assign
(paren
l_int|52
OL
id|data_size
)paren
ques
c_cond
l_int|52
suffix:colon
id|data_size
suffix:semicolon
r_char
id|line
(braket
l_int|70
)braket
suffix:semicolon
id|data_size
op_sub_assign
id|bytes
suffix:semicolon
r_if
c_cond
(paren
id|bytes
op_le
l_int|26
)paren
id|line
(braket
l_int|0
)braket
op_assign
id|bytes
op_plus
l_char|&squot;A&squot;
l_int|1
suffix:semicolon
r_else
id|line
(braket
l_int|0
)braket
op_assign
id|bytes
l_int|26
op_plus
l_char|&squot;a&squot;
l_int|1
suffix:semicolon
id|encode_85
c_func
(paren
id|line
op_plus
l_int|1
comma
id|cp
comma
id|bytes
)paren
suffix:semicolon
id|cp
op_assign
(paren
r_char
op_star
)paren
id|cp
op_plus
id|bytes
suffix:semicolon
id|fprintf
c_func
(paren
id|file
comma
l_string|&quot;%s&quot;
comma
id|prefix
)paren
suffix:semicolon
id|fputs
c_func
(paren
id|line
comma
id|file
)paren
suffix:semicolon
id|fputc
c_func
(paren
l_char|&squot;&bslash;n&squot;
comma
id|file
)paren
suffix:semicolon
)brace
id|fprintf
c_func
(paren
id|file
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|prefix
)paren
suffix:semicolon
id|free
c_func
(paren
id|data
)paren
suffix:semicolon
)brace
DECL|function|emit_binary_diff
r_static
r_void
id|emit_binary_diff
c_func
(paren
id|FILE
op_star
id|file
comma
id|mmfile_t
op_star
id|one
comma
id|mmfile_t
op_star
id|two
comma
r_const
r_char
op_star
id|prefix
)paren
(brace
id|fprintf
c_func
(paren
id|file
comma
l_string|&quot;%sGIT binary patch&bslash;n&quot;
comma
id|prefix
)paren
suffix:semicolon
id|emit_binary_diff_body
c_func
(paren
id|file
comma
id|one
comma
id|two
comma
id|prefix
)paren
suffix:semicolon
id|emit_binary_diff_body
c_func
(paren
id|file
comma
id|two
comma
id|one
comma
id|prefix
)paren
suffix:semicolon
)brace
DECL|function|diff_filespec_is_binary
r_int
id|diff_filespec_is_binary
c_func
(paren
r_struct
id|diff_filespec
op_star
id|one
)paren
(brace
r_if
c_cond
(paren
id|one-&gt;is_binary
op_eq
l_int|1
)paren
(brace
id|diff_filespec_load_driver
c_func
(paren
id|one
)paren
suffix:semicolon
r_if
c_cond
(paren
id|one-&gt;driver-&gt;binary
op_ne
l_int|1
)paren
id|one-&gt;is_binary
op_assign
id|one-&gt;driver-&gt;binary
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|one-&gt;data
op_logical_and
id|DIFF_FILE_VALID
c_func
(paren
id|one
)paren
)paren
id|diff_populate_filespec
c_func
(paren
id|one
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|one-&gt;data
)paren
id|one-&gt;is_binary
op_assign
id|buffer_is_binary
c_func
(paren
id|one-&gt;data
comma
id|one-&gt;size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|one-&gt;is_binary
op_eq
l_int|1
)paren
id|one-&gt;is_binary
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_return
id|one-&gt;is_binary
suffix:semicolon
)brace
DECL|function|diff_funcname_pattern
r_static
r_const
r_struct
id|userdiff_funcname
op_star
id|diff_funcname_pattern
c_func
(paren
r_struct
id|diff_filespec
op_star
id|one
)paren
(brace
id|diff_filespec_load_driver
c_func
(paren
id|one
)paren
suffix:semicolon
r_return
id|one-&gt;driver-&gt;funcname.pattern
ques
c_cond
op_amp
id|one-&gt;driver-&gt;funcname
suffix:colon
l_int|NULL
suffix:semicolon
)brace
DECL|function|diff_set_mnemonic_prefix
r_void
id|diff_set_mnemonic_prefix
c_func
(paren
r_struct
id|diff_options
op_star
id|options
comma
r_const
r_char
op_star
id|a
comma
r_const
r_char
op_star
id|b
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|options-&gt;a_prefix
)paren
id|options-&gt;a_prefix
op_assign
id|a
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|options-&gt;b_prefix
)paren
id|options-&gt;b_prefix
op_assign
id|b
suffix:semicolon
)brace
DECL|function|get_textconv
r_struct
id|userdiff_driver
op_star
id|get_textconv
c_func
(paren
r_struct
id|diff_filespec
op_star
id|one
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|DIFF_FILE_VALID
c_func
(paren
id|one
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|diff_filespec_load_driver
c_func
(paren
id|one
)paren
suffix:semicolon
r_return
id|userdiff_get_textconv
c_func
(paren
id|one-&gt;driver
)paren
suffix:semicolon
)brace
DECL|function|builtin_diff
r_static
r_void
id|builtin_diff
c_func
(paren
r_const
r_char
op_star
id|name_a
comma
r_const
r_char
op_star
id|name_b
comma
r_struct
id|diff_filespec
op_star
id|one
comma
r_struct
id|diff_filespec
op_star
id|two
comma
r_const
r_char
op_star
id|xfrm_msg
comma
r_int
id|must_show_header
comma
r_struct
id|diff_options
op_star
id|o
comma
r_int
id|complete_rewrite
)paren
(brace
id|mmfile_t
id|mf1
comma
id|mf2
suffix:semicolon
r_const
r_char
op_star
id|lbl
(braket
l_int|2
)braket
suffix:semicolon
r_char
op_star
id|a_one
comma
op_star
id|b_two
suffix:semicolon
r_const
r_char
op_star
id|meta
op_assign
id|diff_get_color_opt
c_func
(paren
id|o
comma
id|DIFF_METAINFO
)paren
suffix:semicolon
r_const
r_char
op_star
id|reset
op_assign
id|diff_get_color_opt
c_func
(paren
id|o
comma
id|DIFF_RESET
)paren
suffix:semicolon
r_const
r_char
op_star
id|a_prefix
comma
op_star
id|b_prefix
suffix:semicolon
r_struct
id|userdiff_driver
op_star
id|textconv_one
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|userdiff_driver
op_star
id|textconv_two
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|strbuf
id|header
op_assign
id|STRBUF_INIT
suffix:semicolon
r_const
r_char
op_star
id|line_prefix
op_assign
id|diff_line_prefix
c_func
(paren
id|o
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DIFF_OPT_TST
c_func
(paren
id|o
comma
id|SUBMODULE_LOG
)paren
op_logical_and
(paren
op_logical_neg
id|one-&gt;mode
op_logical_or
id|S_ISGITLINK
c_func
(paren
id|one-&gt;mode
)paren
)paren
op_logical_and
(paren
op_logical_neg
id|two-&gt;mode
op_logical_or
id|S_ISGITLINK
c_func
(paren
id|two-&gt;mode
)paren
)paren
)paren
(brace
r_const
r_char
op_star
id|del
op_assign
id|diff_get_color_opt
c_func
(paren
id|o
comma
id|DIFF_FILE_OLD
)paren
suffix:semicolon
r_const
r_char
op_star
id|add
op_assign
id|diff_get_color_opt
c_func
(paren
id|o
comma
id|DIFF_FILE_NEW
)paren
suffix:semicolon
id|show_submodule_summary
c_func
(paren
id|o-&gt;file
comma
id|one-&gt;path
ques
c_cond
id|one-&gt;path
suffix:colon
id|two-&gt;path
comma
id|line_prefix
comma
id|one-&gt;sha1
comma
id|two-&gt;sha1
comma
id|two-&gt;dirty_submodule
comma
id|meta
comma
id|del
comma
id|add
comma
id|reset
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DIFF_OPT_TST
c_func
(paren
id|o
comma
id|ALLOW_TEXTCONV
)paren
)paren
(brace
id|textconv_one
op_assign
id|get_textconv
c_func
(paren
id|one
)paren
suffix:semicolon
id|textconv_two
op_assign
id|get_textconv
c_func
(paren
id|two
)paren
suffix:semicolon
)brace
id|diff_set_mnemonic_prefix
c_func
(paren
id|o
comma
l_string|&quot;a/&quot;
comma
l_string|&quot;b/&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DIFF_OPT_TST
c_func
(paren
id|o
comma
id|REVERSE_DIFF
)paren
)paren
(brace
id|a_prefix
op_assign
id|o-&gt;b_prefix
suffix:semicolon
id|b_prefix
op_assign
id|o-&gt;a_prefix
suffix:semicolon
)brace
r_else
(brace
id|a_prefix
op_assign
id|o-&gt;a_prefix
suffix:semicolon
id|b_prefix
op_assign
id|o-&gt;b_prefix
suffix:semicolon
)brace
multiline_comment|/* Never use a non-valid filename anywhere if at all possible */
id|name_a
op_assign
id|DIFF_FILE_VALID
c_func
(paren
id|one
)paren
ques
c_cond
id|name_a
suffix:colon
id|name_b
suffix:semicolon
id|name_b
op_assign
id|DIFF_FILE_VALID
c_func
(paren
id|two
)paren
ques
c_cond
id|name_b
suffix:colon
id|name_a
suffix:semicolon
id|a_one
op_assign
id|quote_two
c_func
(paren
id|a_prefix
comma
id|name_a
op_plus
(paren
op_star
id|name_a
op_eq
l_char|&squot;/&squot;
)paren
)paren
suffix:semicolon
id|b_two
op_assign
id|quote_two
c_func
(paren
id|b_prefix
comma
id|name_b
op_plus
(paren
op_star
id|name_b
op_eq
l_char|&squot;/&squot;
)paren
)paren
suffix:semicolon
id|lbl
(braket
l_int|0
)braket
op_assign
id|DIFF_FILE_VALID
c_func
(paren
id|one
)paren
ques
c_cond
id|a_one
suffix:colon
l_string|&quot;/dev/null&quot;
suffix:semicolon
id|lbl
(braket
l_int|1
)braket
op_assign
id|DIFF_FILE_VALID
c_func
(paren
id|two
)paren
ques
c_cond
id|b_two
suffix:colon
l_string|&quot;/dev/null&quot;
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
id|header
comma
l_string|&quot;%s%sdiff --git %s %s%s&bslash;n&quot;
comma
id|line_prefix
comma
id|meta
comma
id|a_one
comma
id|b_two
comma
id|reset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lbl
(braket
l_int|0
)braket
(braket
l_int|0
)braket
op_eq
l_char|&squot;/&squot;
)paren
(brace
multiline_comment|/* /dev/null */
id|strbuf_addf
c_func
(paren
op_amp
id|header
comma
l_string|&quot;%s%snew file mode %06o%s&bslash;n&quot;
comma
id|line_prefix
comma
id|meta
comma
id|two-&gt;mode
comma
id|reset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xfrm_msg
)paren
id|strbuf_addstr
c_func
(paren
op_amp
id|header
comma
id|xfrm_msg
)paren
suffix:semicolon
id|must_show_header
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lbl
(braket
l_int|1
)braket
(braket
l_int|0
)braket
op_eq
l_char|&squot;/&squot;
)paren
(brace
id|strbuf_addf
c_func
(paren
op_amp
id|header
comma
l_string|&quot;%s%sdeleted file mode %06o%s&bslash;n&quot;
comma
id|line_prefix
comma
id|meta
comma
id|one-&gt;mode
comma
id|reset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xfrm_msg
)paren
id|strbuf_addstr
c_func
(paren
op_amp
id|header
comma
id|xfrm_msg
)paren
suffix:semicolon
id|must_show_header
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|one-&gt;mode
op_ne
id|two-&gt;mode
)paren
(brace
id|strbuf_addf
c_func
(paren
op_amp
id|header
comma
l_string|&quot;%s%sold mode %06o%s&bslash;n&quot;
comma
id|line_prefix
comma
id|meta
comma
id|one-&gt;mode
comma
id|reset
)paren
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
id|header
comma
l_string|&quot;%s%snew mode %06o%s&bslash;n&quot;
comma
id|line_prefix
comma
id|meta
comma
id|two-&gt;mode
comma
id|reset
)paren
suffix:semicolon
id|must_show_header
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|xfrm_msg
)paren
id|strbuf_addstr
c_func
(paren
op_amp
id|header
comma
id|xfrm_msg
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * we do not run diff between different kind&n;&t;&t; * of objects.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|one-&gt;mode
op_xor
id|two-&gt;mode
)paren
op_amp
id|S_IFMT
)paren
r_goto
id|free_ab_and_return
suffix:semicolon
r_if
c_cond
(paren
id|complete_rewrite
op_logical_and
(paren
id|textconv_one
op_logical_or
op_logical_neg
id|diff_filespec_is_binary
c_func
(paren
id|one
)paren
)paren
op_logical_and
(paren
id|textconv_two
op_logical_or
op_logical_neg
id|diff_filespec_is_binary
c_func
(paren
id|two
)paren
)paren
)paren
(brace
id|fprintf
c_func
(paren
id|o-&gt;file
comma
l_string|&quot;%s&quot;
comma
id|header.buf
)paren
suffix:semicolon
id|strbuf_reset
c_func
(paren
op_amp
id|header
)paren
suffix:semicolon
id|emit_rewrite_diff
c_func
(paren
id|name_a
comma
id|name_b
comma
id|one
comma
id|two
comma
id|textconv_one
comma
id|textconv_two
comma
id|o
)paren
suffix:semicolon
id|o-&gt;found_changes
op_assign
l_int|1
suffix:semicolon
r_goto
id|free_ab_and_return
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|o-&gt;irreversible_delete
op_logical_and
id|lbl
(braket
l_int|1
)braket
(braket
l_int|0
)braket
op_eq
l_char|&squot;/&squot;
)paren
(brace
id|fprintf
c_func
(paren
id|o-&gt;file
comma
l_string|&quot;%s&quot;
comma
id|header.buf
)paren
suffix:semicolon
id|strbuf_reset
c_func
(paren
op_amp
id|header
)paren
suffix:semicolon
r_goto
id|free_ab_and_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|DIFF_OPT_TST
c_func
(paren
id|o
comma
id|TEXT
)paren
op_logical_and
(paren
(paren
op_logical_neg
id|textconv_one
op_logical_and
id|diff_filespec_is_binary
c_func
(paren
id|one
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|textconv_two
op_logical_and
id|diff_filespec_is_binary
c_func
(paren
id|two
)paren
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|fill_mmfile
c_func
(paren
op_amp
id|mf1
comma
id|one
)paren
OL
l_int|0
op_logical_or
id|fill_mmfile
c_func
(paren
op_amp
id|mf2
comma
id|two
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;unable to read files to diff&quot;
)paren
suffix:semicolon
multiline_comment|/* Quite common confusing case */
r_if
c_cond
(paren
id|mf1.size
op_eq
id|mf2.size
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|mf1.ptr
comma
id|mf2.ptr
comma
id|mf1.size
)paren
)paren
(brace
r_if
c_cond
(paren
id|must_show_header
)paren
id|fprintf
c_func
(paren
id|o-&gt;file
comma
l_string|&quot;%s&quot;
comma
id|header.buf
)paren
suffix:semicolon
r_goto
id|free_ab_and_return
suffix:semicolon
)brace
id|fprintf
c_func
(paren
id|o-&gt;file
comma
l_string|&quot;%s&quot;
comma
id|header.buf
)paren
suffix:semicolon
id|strbuf_reset
c_func
(paren
op_amp
id|header
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DIFF_OPT_TST
c_func
(paren
id|o
comma
id|BINARY
)paren
)paren
id|emit_binary_diff
c_func
(paren
id|o-&gt;file
comma
op_amp
id|mf1
comma
op_amp
id|mf2
comma
id|line_prefix
)paren
suffix:semicolon
r_else
id|fprintf
c_func
(paren
id|o-&gt;file
comma
l_string|&quot;%sBinary files %s and %s differ&bslash;n&quot;
comma
id|line_prefix
comma
id|lbl
(braket
l_int|0
)braket
comma
id|lbl
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|o-&gt;found_changes
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Crazy xdl interfaces.. */
r_const
r_char
op_star
id|diffopts
op_assign
id|getenv
c_func
(paren
l_string|&quot;GIT_DIFF_OPTS&quot;
)paren
suffix:semicolon
id|xpparam_t
id|xpp
suffix:semicolon
id|xdemitconf_t
id|xecfg
suffix:semicolon
r_struct
id|emit_callback
id|ecbdata
suffix:semicolon
r_const
r_struct
id|userdiff_funcname
op_star
id|pe
suffix:semicolon
r_if
c_cond
(paren
id|must_show_header
)paren
(brace
id|fprintf
c_func
(paren
id|o-&gt;file
comma
l_string|&quot;%s&quot;
comma
id|header.buf
)paren
suffix:semicolon
id|strbuf_reset
c_func
(paren
op_amp
id|header
)paren
suffix:semicolon
)brace
id|mf1.size
op_assign
id|fill_textconv
c_func
(paren
id|textconv_one
comma
id|one
comma
op_amp
id|mf1.ptr
)paren
suffix:semicolon
id|mf2.size
op_assign
id|fill_textconv
c_func
(paren
id|textconv_two
comma
id|two
comma
op_amp
id|mf2.ptr
)paren
suffix:semicolon
id|pe
op_assign
id|diff_funcname_pattern
c_func
(paren
id|one
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pe
)paren
id|pe
op_assign
id|diff_funcname_pattern
c_func
(paren
id|two
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|xpp
comma
l_int|0
comma
r_sizeof
(paren
id|xpp
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|xecfg
comma
l_int|0
comma
r_sizeof
(paren
id|xecfg
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|ecbdata
comma
l_int|0
comma
r_sizeof
(paren
id|ecbdata
)paren
)paren
suffix:semicolon
id|ecbdata.label_path
op_assign
id|lbl
suffix:semicolon
id|ecbdata.color_diff
op_assign
id|want_color
c_func
(paren
id|o-&gt;use_color
)paren
suffix:semicolon
id|ecbdata.found_changesp
op_assign
op_amp
id|o-&gt;found_changes
suffix:semicolon
id|ecbdata.ws_rule
op_assign
id|whitespace_rule
c_func
(paren
id|name_b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ecbdata.ws_rule
op_amp
id|WS_BLANK_AT_EOF
)paren
id|check_blank_at_eof
c_func
(paren
op_amp
id|mf1
comma
op_amp
id|mf2
comma
op_amp
id|ecbdata
)paren
suffix:semicolon
id|ecbdata.opt
op_assign
id|o
suffix:semicolon
id|ecbdata.header
op_assign
id|header.len
ques
c_cond
op_amp
id|header
suffix:colon
l_int|NULL
suffix:semicolon
id|xpp.flags
op_assign
id|o-&gt;xdl_opts
suffix:semicolon
id|xecfg.ctxlen
op_assign
id|o-&gt;context
suffix:semicolon
id|xecfg.interhunkctxlen
op_assign
id|o-&gt;interhunkcontext
suffix:semicolon
id|xecfg.flags
op_assign
id|XDL_EMIT_FUNCNAMES
suffix:semicolon
r_if
c_cond
(paren
id|DIFF_OPT_TST
c_func
(paren
id|o
comma
id|FUNCCONTEXT
)paren
)paren
id|xecfg.flags
op_or_assign
id|XDL_EMIT_FUNCCONTEXT
suffix:semicolon
r_if
c_cond
(paren
id|pe
)paren
id|xdiff_set_find_func
c_func
(paren
op_amp
id|xecfg
comma
id|pe-&gt;pattern
comma
id|pe-&gt;cflags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|diffopts
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|diffopts
comma
l_string|&quot;--unified=&quot;
)paren
)paren
id|xecfg.ctxlen
op_assign
id|strtoul
c_func
(paren
id|diffopts
op_plus
l_int|10
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|diffopts
comma
l_string|&quot;-u&quot;
)paren
)paren
id|xecfg.ctxlen
op_assign
id|strtoul
c_func
(paren
id|diffopts
op_plus
l_int|2
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|o-&gt;word_diff
)paren
id|init_diff_words_data
c_func
(paren
op_amp
id|ecbdata
comma
id|o
comma
id|one
comma
id|two
)paren
suffix:semicolon
id|xdi_diff_outf
c_func
(paren
op_amp
id|mf1
comma
op_amp
id|mf2
comma
id|fn_out_consume
comma
op_amp
id|ecbdata
comma
op_amp
id|xpp
comma
op_amp
id|xecfg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|o-&gt;word_diff
)paren
id|free_diff_words_data
c_func
(paren
op_amp
id|ecbdata
)paren
suffix:semicolon
r_if
c_cond
(paren
id|textconv_one
)paren
id|free
c_func
(paren
id|mf1.ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|textconv_two
)paren
id|free
c_func
(paren
id|mf2.ptr
)paren
suffix:semicolon
id|xdiff_clear_find_func
c_func
(paren
op_amp
id|xecfg
)paren
suffix:semicolon
)brace
id|free_ab_and_return
suffix:colon
id|strbuf_release
c_func
(paren
op_amp
id|header
)paren
suffix:semicolon
id|diff_free_filespec_data
c_func
(paren
id|one
)paren
suffix:semicolon
id|diff_free_filespec_data
c_func
(paren
id|two
)paren
suffix:semicolon
id|free
c_func
(paren
id|a_one
)paren
suffix:semicolon
id|free
c_func
(paren
id|b_two
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|builtin_diffstat
r_static
r_void
id|builtin_diffstat
c_func
(paren
r_const
r_char
op_star
id|name_a
comma
r_const
r_char
op_star
id|name_b
comma
r_struct
id|diff_filespec
op_star
id|one
comma
r_struct
id|diff_filespec
op_star
id|two
comma
r_struct
id|diffstat_t
op_star
id|diffstat
comma
r_struct
id|diff_options
op_star
id|o
comma
r_struct
id|diff_filepair
op_star
id|p
)paren
(brace
id|mmfile_t
id|mf1
comma
id|mf2
suffix:semicolon
r_struct
id|diffstat_file
op_star
id|data
suffix:semicolon
r_int
id|same_contents
suffix:semicolon
r_int
id|complete_rewrite
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|DIFF_PAIR_UNMERGED
c_func
(paren
id|p
)paren
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;status
op_eq
id|DIFF_STATUS_MODIFIED
op_logical_and
id|p-&gt;score
)paren
id|complete_rewrite
op_assign
l_int|1
suffix:semicolon
)brace
id|data
op_assign
id|diffstat_add
c_func
(paren
id|diffstat
comma
id|name_a
comma
id|name_b
)paren
suffix:semicolon
id|data-&gt;is_interesting
op_assign
id|p-&gt;status
op_ne
id|DIFF_STATUS_UNKNOWN
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|one
op_logical_or
op_logical_neg
id|two
)paren
(brace
id|data-&gt;is_unmerged
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
id|same_contents
op_assign
op_logical_neg
id|hashcmp
c_func
(paren
id|one-&gt;sha1
comma
id|two-&gt;sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|diff_filespec_is_binary
c_func
(paren
id|one
)paren
op_logical_or
id|diff_filespec_is_binary
c_func
(paren
id|two
)paren
)paren
(brace
id|data-&gt;is_binary
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|same_contents
)paren
(brace
id|data-&gt;added
op_assign
l_int|0
suffix:semicolon
id|data-&gt;deleted
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|data-&gt;added
op_assign
id|diff_filespec_size
c_func
(paren
id|two
)paren
suffix:semicolon
id|data-&gt;deleted
op_assign
id|diff_filespec_size
c_func
(paren
id|one
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|complete_rewrite
)paren
(brace
id|diff_populate_filespec
c_func
(paren
id|one
comma
l_int|0
)paren
suffix:semicolon
id|diff_populate_filespec
c_func
(paren
id|two
comma
l_int|0
)paren
suffix:semicolon
id|data-&gt;deleted
op_assign
id|count_lines
c_func
(paren
id|one-&gt;data
comma
id|one-&gt;size
)paren
suffix:semicolon
id|data-&gt;added
op_assign
id|count_lines
c_func
(paren
id|two-&gt;data
comma
id|two-&gt;size
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|same_contents
)paren
(brace
multiline_comment|/* Crazy xdl interfaces.. */
id|xpparam_t
id|xpp
suffix:semicolon
id|xdemitconf_t
id|xecfg
suffix:semicolon
r_if
c_cond
(paren
id|fill_mmfile
c_func
(paren
op_amp
id|mf1
comma
id|one
)paren
OL
l_int|0
op_logical_or
id|fill_mmfile
c_func
(paren
op_amp
id|mf2
comma
id|two
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;unable to read files to diff&quot;
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|xpp
comma
l_int|0
comma
r_sizeof
(paren
id|xpp
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|xecfg
comma
l_int|0
comma
r_sizeof
(paren
id|xecfg
)paren
)paren
suffix:semicolon
id|xpp.flags
op_assign
id|o-&gt;xdl_opts
suffix:semicolon
id|xecfg.ctxlen
op_assign
id|o-&gt;context
suffix:semicolon
id|xecfg.interhunkctxlen
op_assign
id|o-&gt;interhunkcontext
suffix:semicolon
id|xdi_diff_outf
c_func
(paren
op_amp
id|mf1
comma
op_amp
id|mf2
comma
id|diffstat_consume
comma
id|diffstat
comma
op_amp
id|xpp
comma
op_amp
id|xecfg
)paren
suffix:semicolon
)brace
id|diff_free_filespec_data
c_func
(paren
id|one
)paren
suffix:semicolon
id|diff_free_filespec_data
c_func
(paren
id|two
)paren
suffix:semicolon
)brace
DECL|function|builtin_checkdiff
r_static
r_void
id|builtin_checkdiff
c_func
(paren
r_const
r_char
op_star
id|name_a
comma
r_const
r_char
op_star
id|name_b
comma
r_const
r_char
op_star
id|attr_path
comma
r_struct
id|diff_filespec
op_star
id|one
comma
r_struct
id|diff_filespec
op_star
id|two
comma
r_struct
id|diff_options
op_star
id|o
)paren
(brace
id|mmfile_t
id|mf1
comma
id|mf2
suffix:semicolon
r_struct
id|checkdiff_t
id|data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|two
)paren
r_return
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|data
comma
l_int|0
comma
r_sizeof
(paren
id|data
)paren
)paren
suffix:semicolon
id|data.filename
op_assign
id|name_b
ques
c_cond
id|name_b
suffix:colon
id|name_a
suffix:semicolon
id|data.lineno
op_assign
l_int|0
suffix:semicolon
id|data.o
op_assign
id|o
suffix:semicolon
id|data.ws_rule
op_assign
id|whitespace_rule
c_func
(paren
id|attr_path
)paren
suffix:semicolon
id|data.conflict_marker_size
op_assign
id|ll_merge_marker_size
c_func
(paren
id|attr_path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fill_mmfile
c_func
(paren
op_amp
id|mf1
comma
id|one
)paren
OL
l_int|0
op_logical_or
id|fill_mmfile
c_func
(paren
op_amp
id|mf2
comma
id|two
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;unable to read files to diff&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * All the other codepaths check both sides, but not checking&n;&t; * the &quot;old&quot; side here is deliberate.  We are checking the newly&n;&t; * introduced changes, and as long as the &quot;new&quot; side is text, we&n;&t; * can and should check what it introduces.&n;&t; */
r_if
c_cond
(paren
id|diff_filespec_is_binary
c_func
(paren
id|two
)paren
)paren
r_goto
id|free_and_return
suffix:semicolon
r_else
(brace
multiline_comment|/* Crazy xdl interfaces.. */
id|xpparam_t
id|xpp
suffix:semicolon
id|xdemitconf_t
id|xecfg
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|xpp
comma
l_int|0
comma
r_sizeof
(paren
id|xpp
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|xecfg
comma
l_int|0
comma
r_sizeof
(paren
id|xecfg
)paren
)paren
suffix:semicolon
id|xecfg.ctxlen
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* at least one context line */
id|xpp.flags
op_assign
l_int|0
suffix:semicolon
id|xdi_diff_outf
c_func
(paren
op_amp
id|mf1
comma
op_amp
id|mf2
comma
id|checkdiff_consume
comma
op_amp
id|data
comma
op_amp
id|xpp
comma
op_amp
id|xecfg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data.ws_rule
op_amp
id|WS_BLANK_AT_EOF
)paren
(brace
r_struct
id|emit_callback
id|ecbdata
suffix:semicolon
r_int
id|blank_at_eof
suffix:semicolon
id|ecbdata.ws_rule
op_assign
id|data.ws_rule
suffix:semicolon
id|check_blank_at_eof
c_func
(paren
op_amp
id|mf1
comma
op_amp
id|mf2
comma
op_amp
id|ecbdata
)paren
suffix:semicolon
id|blank_at_eof
op_assign
id|ecbdata.blank_at_eof_in_postimage
suffix:semicolon
r_if
c_cond
(paren
id|blank_at_eof
)paren
(brace
r_static
r_char
op_star
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|err
op_assign
id|whitespace_error_string
c_func
(paren
id|WS_BLANK_AT_EOF
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|o-&gt;file
comma
l_string|&quot;%s:%d: %s.&bslash;n&quot;
comma
id|data.filename
comma
id|blank_at_eof
comma
id|err
)paren
suffix:semicolon
id|data.status
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* report errors */
)brace
)brace
)brace
id|free_and_return
suffix:colon
id|diff_free_filespec_data
c_func
(paren
id|one
)paren
suffix:semicolon
id|diff_free_filespec_data
c_func
(paren
id|two
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data.status
)paren
id|DIFF_OPT_SET
c_func
(paren
id|o
comma
id|CHECK_FAILED
)paren
suffix:semicolon
)brace
DECL|function|alloc_filespec
r_struct
id|diff_filespec
op_star
id|alloc_filespec
c_func
(paren
r_const
r_char
op_star
id|path
)paren
(brace
r_int
id|namelen
op_assign
id|strlen
c_func
(paren
id|path
)paren
suffix:semicolon
r_struct
id|diff_filespec
op_star
id|spec
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|spec
)paren
op_plus
id|namelen
op_plus
l_int|1
)paren
suffix:semicolon
id|memset
c_func
(paren
id|spec
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|spec
)paren
)paren
suffix:semicolon
id|spec-&gt;path
op_assign
(paren
r_char
op_star
)paren
(paren
id|spec
op_plus
l_int|1
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|spec-&gt;path
comma
id|path
comma
id|namelen
op_plus
l_int|1
)paren
suffix:semicolon
id|spec-&gt;count
op_assign
l_int|1
suffix:semicolon
id|spec-&gt;is_binary
op_assign
l_int|1
suffix:semicolon
r_return
id|spec
suffix:semicolon
)brace
DECL|function|free_filespec
r_void
id|free_filespec
c_func
(paren
r_struct
id|diff_filespec
op_star
id|spec
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|spec-&gt;count
)paren
(brace
id|diff_free_filespec_data
c_func
(paren
id|spec
)paren
suffix:semicolon
id|free
c_func
(paren
id|spec
)paren
suffix:semicolon
)brace
)brace
DECL|function|fill_filespec
r_void
id|fill_filespec
c_func
(paren
r_struct
id|diff_filespec
op_star
id|spec
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
id|sha1_valid
comma
r_int
r_int
id|mode
)paren
(brace
r_if
c_cond
(paren
id|mode
)paren
(brace
id|spec-&gt;mode
op_assign
id|canon_mode
c_func
(paren
id|mode
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|spec-&gt;sha1
comma
id|sha1
)paren
suffix:semicolon
id|spec-&gt;sha1_valid
op_assign
id|sha1_valid
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Given a name and sha1 pair, if the index tells us the file in&n; * the work tree has that object contents, return true, so that&n; * prepare_temp_file() does not have to inflate and extract.&n; */
DECL|function|reuse_worktree_file
r_static
r_int
id|reuse_worktree_file
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
id|want_file
)paren
(brace
r_const
r_struct
id|cache_entry
op_star
id|ce
suffix:semicolon
r_struct
id|stat
id|st
suffix:semicolon
r_int
id|pos
comma
id|len
suffix:semicolon
multiline_comment|/*&n;&t; * We do not read the cache ourselves here, because the&n;&t; * benchmark with my previous version that always reads cache&n;&t; * shows that it makes things worse for diff-tree comparing&n;&t; * two linux-2.6 kernel trees in an already checked out work&n;&t; * tree.  This is because most diff-tree comparisons deal with&n;&t; * only a small number of files, while reading the cache is&n;&t; * expensive for a large project, and its cost outweighs the&n;&t; * savings we get by not inflating the object to a temporary&n;&t; * file.  Practically, this code only helps when we are used&n;&t; * by diff-cache --cached, which does read the cache before&n;&t; * calling us.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|active_cache
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* We want to avoid the working directory if our caller&n;&t; * doesn&squot;t need the data in a normal file, this system&n;&t; * is rather slow with its stat/open/mmap/close syscalls,&n;&t; * and the object is contained in a pack file.  The pack&n;&t; * is probably already open and will be faster to obtain&n;&t; * the data through than the working directory.  Loose&n;&t; * objects however would tend to be slower as they need&n;&t; * to be individually opened and inflated.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|FAST_WORKING_DIRECTORY
op_logical_and
op_logical_neg
id|want_file
op_logical_and
id|has_sha1_pack
c_func
(paren
id|sha1
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
id|pos
op_assign
id|cache_name_pos
c_func
(paren
id|name
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|ce
op_assign
id|active_cache
(braket
id|pos
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * This is not the sha1 we are looking for, or&n;&t; * unreusable because it is not a regular file.&n;&t; */
r_if
c_cond
(paren
id|hashcmp
c_func
(paren
id|sha1
comma
id|ce-&gt;sha1
)paren
op_logical_or
op_logical_neg
id|S_ISREG
c_func
(paren
id|ce-&gt;ce_mode
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If ce is marked as &quot;assume unchanged&quot;, there is no&n;&t; * guarantee that work tree matches what we are looking for.&n;&t; */
r_if
c_cond
(paren
(paren
id|ce-&gt;ce_flags
op_amp
id|CE_VALID
)paren
op_logical_or
id|ce_skip_worktree
c_func
(paren
id|ce
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If ce matches the file in the work tree, we can reuse it.&n;&t; */
r_if
c_cond
(paren
id|ce_uptodate
c_func
(paren
id|ce
)paren
op_logical_or
(paren
op_logical_neg
id|lstat
c_func
(paren
id|name
comma
op_amp
id|st
)paren
op_logical_and
op_logical_neg
id|ce_match_stat
c_func
(paren
id|ce
comma
op_amp
id|st
comma
l_int|0
)paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|diff_populate_gitlink
r_static
r_int
id|diff_populate_gitlink
c_func
(paren
r_struct
id|diff_filespec
op_star
id|s
comma
r_int
id|size_only
)paren
(brace
r_int
id|len
suffix:semicolon
r_char
op_star
id|data
op_assign
id|xmalloc
c_func
(paren
l_int|100
)paren
comma
op_star
id|dirty
op_assign
l_string|&quot;&quot;
suffix:semicolon
multiline_comment|/* Are we looking at the work tree? */
r_if
c_cond
(paren
id|s-&gt;dirty_submodule
)paren
id|dirty
op_assign
l_string|&quot;-dirty&quot;
suffix:semicolon
id|len
op_assign
id|snprintf
c_func
(paren
id|data
comma
l_int|100
comma
l_string|&quot;Subproject commit %s%s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|s-&gt;sha1
)paren
comma
id|dirty
)paren
suffix:semicolon
id|s-&gt;data
op_assign
id|data
suffix:semicolon
id|s-&gt;size
op_assign
id|len
suffix:semicolon
id|s-&gt;should_free
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|size_only
)paren
(brace
id|s-&gt;data
op_assign
l_int|NULL
suffix:semicolon
id|free
c_func
(paren
id|data
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * While doing rename detection and pickaxe operation, we may need to&n; * grab the data for the blob (or file) for our own in-core comparison.&n; * diff_filespec has data and size fields for this purpose.&n; */
DECL|function|diff_populate_filespec
r_int
id|diff_populate_filespec
c_func
(paren
r_struct
id|diff_filespec
op_star
id|s
comma
r_int
id|size_only
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * demote FAIL to WARN to allow inspecting the situation&n;&t; * instead of refusing.&n;&t; */
r_enum
id|safe_crlf
id|crlf_warn
op_assign
(paren
id|safe_crlf
op_eq
id|SAFE_CRLF_FAIL
ques
c_cond
id|SAFE_CRLF_WARN
suffix:colon
id|safe_crlf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|DIFF_FILE_VALID
c_func
(paren
id|s
)paren
)paren
id|die
c_func
(paren
l_string|&quot;internal error: asking to populate invalid file.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|s-&gt;mode
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;data
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|size_only
op_logical_and
l_int|0
OL
id|s-&gt;size
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|S_ISGITLINK
c_func
(paren
id|s-&gt;mode
)paren
)paren
r_return
id|diff_populate_gitlink
c_func
(paren
id|s
comma
id|size_only
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;sha1_valid
op_logical_or
id|reuse_worktree_file
c_func
(paren
id|s-&gt;path
comma
id|s-&gt;sha1
comma
l_int|0
)paren
)paren
(brace
r_struct
id|strbuf
id|buf
op_assign
id|STRBUF_INIT
suffix:semicolon
r_struct
id|stat
id|st
suffix:semicolon
r_int
id|fd
suffix:semicolon
r_if
c_cond
(paren
id|lstat
c_func
(paren
id|s-&gt;path
comma
op_amp
id|st
)paren
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|errno
op_eq
id|ENOENT
)paren
(brace
id|err_empty
suffix:colon
id|err
op_assign
l_int|1
suffix:semicolon
id|empty
suffix:colon
id|s-&gt;data
op_assign
(paren
r_char
op_star
)paren
l_string|&quot;&quot;
suffix:semicolon
id|s-&gt;size
op_assign
l_int|0
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
)brace
id|s-&gt;size
op_assign
id|xsize_t
c_func
(paren
id|st.st_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;size
)paren
r_goto
id|empty
suffix:semicolon
r_if
c_cond
(paren
id|S_ISLNK
c_func
(paren
id|st.st_mode
)paren
)paren
(brace
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
r_if
c_cond
(paren
id|strbuf_readlink
c_func
(paren
op_amp
id|sb
comma
id|s-&gt;path
comma
id|s-&gt;size
)paren
)paren
r_goto
id|err_empty
suffix:semicolon
id|s-&gt;size
op_assign
id|sb.len
suffix:semicolon
id|s-&gt;data
op_assign
id|strbuf_detach
c_func
(paren
op_amp
id|sb
comma
l_int|NULL
)paren
suffix:semicolon
id|s-&gt;should_free
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|size_only
)paren
r_return
l_int|0
suffix:semicolon
id|fd
op_assign
id|open
c_func
(paren
id|s-&gt;path
comma
id|O_RDONLY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
r_goto
id|err_empty
suffix:semicolon
id|s-&gt;data
op_assign
id|xmmap
c_func
(paren
l_int|NULL
comma
id|s-&gt;size
comma
id|PROT_READ
comma
id|MAP_PRIVATE
comma
id|fd
comma
l_int|0
)paren
suffix:semicolon
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
id|s-&gt;should_munmap
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Convert from working tree format to canonical git format&n;&t;&t; */
r_if
c_cond
(paren
id|convert_to_git
c_func
(paren
id|s-&gt;path
comma
id|s-&gt;data
comma
id|s-&gt;size
comma
op_amp
id|buf
comma
id|crlf_warn
)paren
)paren
(brace
r_int
id|size
op_assign
l_int|0
suffix:semicolon
id|munmap
c_func
(paren
id|s-&gt;data
comma
id|s-&gt;size
)paren
suffix:semicolon
id|s-&gt;should_munmap
op_assign
l_int|0
suffix:semicolon
id|s-&gt;data
op_assign
id|strbuf_detach
c_func
(paren
op_amp
id|buf
comma
op_amp
id|size
)paren
suffix:semicolon
id|s-&gt;size
op_assign
id|size
suffix:semicolon
id|s-&gt;should_free
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
r_enum
id|object_type
id|type
suffix:semicolon
r_if
c_cond
(paren
id|size_only
)paren
(brace
id|type
op_assign
id|sha1_object_info
c_func
(paren
id|s-&gt;sha1
comma
op_amp
id|s-&gt;size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;unable to read %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|s-&gt;sha1
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|s-&gt;data
op_assign
id|read_sha1_file
c_func
(paren
id|s-&gt;sha1
comma
op_amp
id|type
comma
op_amp
id|s-&gt;size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;data
)paren
id|die
c_func
(paren
l_string|&quot;unable to read %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|s-&gt;sha1
)paren
)paren
suffix:semicolon
id|s-&gt;should_free
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|diff_free_filespec_blob
r_void
id|diff_free_filespec_blob
c_func
(paren
r_struct
id|diff_filespec
op_star
id|s
)paren
(brace
r_if
c_cond
(paren
id|s-&gt;should_free
)paren
id|free
c_func
(paren
id|s-&gt;data
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|s-&gt;should_munmap
)paren
id|munmap
c_func
(paren
id|s-&gt;data
comma
id|s-&gt;size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;should_free
op_logical_or
id|s-&gt;should_munmap
)paren
(brace
id|s-&gt;should_free
op_assign
id|s-&gt;should_munmap
op_assign
l_int|0
suffix:semicolon
id|s-&gt;data
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
DECL|function|diff_free_filespec_data
r_void
id|diff_free_filespec_data
c_func
(paren
r_struct
id|diff_filespec
op_star
id|s
)paren
(brace
id|diff_free_filespec_blob
c_func
(paren
id|s
)paren
suffix:semicolon
id|free
c_func
(paren
id|s-&gt;cnt_data
)paren
suffix:semicolon
id|s-&gt;cnt_data
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|prep_temp_blob
r_static
r_void
id|prep_temp_blob
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_struct
id|diff_tempfile
op_star
id|temp
comma
r_void
op_star
id|blob
comma
r_int
r_int
id|size
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
id|mode
)paren
(brace
r_int
id|fd
suffix:semicolon
r_struct
id|strbuf
id|buf
op_assign
id|STRBUF_INIT
suffix:semicolon
r_struct
id|strbuf
r_template
op_assign
id|STRBUF_INIT
suffix:semicolon
r_char
op_star
id|path_dup
op_assign
id|xstrdup
c_func
(paren
id|path
)paren
suffix:semicolon
r_const
r_char
op_star
id|base
op_assign
id|basename
c_func
(paren
id|path_dup
)paren
suffix:semicolon
multiline_comment|/* Generate &quot;XXXXXX_basename.ext&quot; */
id|strbuf_addstr
c_func
(paren
op_amp
r_template
comma
l_string|&quot;XXXXXX_&quot;
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
r_template
comma
id|base
)paren
suffix:semicolon
id|fd
op_assign
id|git_mkstemps
c_func
(paren
id|temp-&gt;tmp_path
comma
id|PATH_MAX
comma
r_template
dot
id|buf
comma
id|strlen
c_func
(paren
id|base
)paren
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
id|die_errno
c_func
(paren
l_string|&quot;unable to create temp-file&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|convert_to_working_tree
c_func
(paren
id|path
comma
(paren
r_const
r_char
op_star
)paren
id|blob
comma
(paren
r_int
)paren
id|size
comma
op_amp
id|buf
)paren
)paren
(brace
id|blob
op_assign
id|buf.buf
suffix:semicolon
id|size
op_assign
id|buf.len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|write_in_full
c_func
(paren
id|fd
comma
id|blob
comma
id|size
)paren
op_ne
id|size
)paren
id|die_errno
c_func
(paren
l_string|&quot;unable to write temp-file&quot;
)paren
suffix:semicolon
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
id|temp-&gt;name
op_assign
id|temp-&gt;tmp_path
suffix:semicolon
id|strcpy
c_func
(paren
id|temp-&gt;hex
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
id|temp-&gt;hex
(braket
l_int|40
)braket
op_assign
l_int|0
suffix:semicolon
id|sprintf
c_func
(paren
id|temp-&gt;mode
comma
l_string|&quot;%06o&quot;
comma
id|mode
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|buf
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
r_template
)paren
suffix:semicolon
id|free
c_func
(paren
id|path_dup
)paren
suffix:semicolon
)brace
DECL|function|prepare_temp_file
r_static
r_struct
id|diff_tempfile
op_star
id|prepare_temp_file
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_struct
id|diff_filespec
op_star
id|one
)paren
(brace
r_struct
id|diff_tempfile
op_star
id|temp
op_assign
id|claim_diff_tempfile
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|DIFF_FILE_VALID
c_func
(paren
id|one
)paren
)paren
(brace
id|not_a_valid_file
suffix:colon
multiline_comment|/* A &squot;-&squot; entry produces this for file-2, and&n;&t;&t; * a &squot;+&squot; entry produces this for file-1.&n;&t;&t; */
id|temp-&gt;name
op_assign
l_string|&quot;/dev/null&quot;
suffix:semicolon
id|strcpy
c_func
(paren
id|temp-&gt;hex
comma
l_string|&quot;.&quot;
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|temp-&gt;mode
comma
l_string|&quot;.&quot;
)paren
suffix:semicolon
r_return
id|temp
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|remove_tempfile_installed
)paren
(brace
id|atexit
c_func
(paren
id|remove_tempfile
)paren
suffix:semicolon
id|sigchain_push_common
c_func
(paren
id|remove_tempfile_on_signal
)paren
suffix:semicolon
id|remove_tempfile_installed
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|S_ISGITLINK
c_func
(paren
id|one-&gt;mode
)paren
op_logical_and
(paren
op_logical_neg
id|one-&gt;sha1_valid
op_logical_or
id|reuse_worktree_file
c_func
(paren
id|name
comma
id|one-&gt;sha1
comma
l_int|1
)paren
)paren
)paren
(brace
r_struct
id|stat
id|st
suffix:semicolon
r_if
c_cond
(paren
id|lstat
c_func
(paren
id|name
comma
op_amp
id|st
)paren
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|errno
op_eq
id|ENOENT
)paren
r_goto
id|not_a_valid_file
suffix:semicolon
id|die_errno
c_func
(paren
l_string|&quot;stat(%s)&quot;
comma
id|name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|S_ISLNK
c_func
(paren
id|st.st_mode
)paren
)paren
(brace
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
r_if
c_cond
(paren
id|strbuf_readlink
c_func
(paren
op_amp
id|sb
comma
id|name
comma
id|st.st_size
)paren
OL
l_int|0
)paren
id|die_errno
c_func
(paren
l_string|&quot;readlink(%s)&quot;
comma
id|name
)paren
suffix:semicolon
id|prep_temp_blob
c_func
(paren
id|name
comma
id|temp
comma
id|sb.buf
comma
id|sb.len
comma
(paren
id|one-&gt;sha1_valid
ques
c_cond
id|one-&gt;sha1
suffix:colon
id|null_sha1
)paren
comma
(paren
id|one-&gt;sha1_valid
ques
c_cond
id|one-&gt;mode
suffix:colon
id|S_IFLNK
)paren
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* we can borrow from the file in the work tree */
id|temp-&gt;name
op_assign
id|name
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|one-&gt;sha1_valid
)paren
id|strcpy
c_func
(paren
id|temp-&gt;hex
comma
id|sha1_to_hex
c_func
(paren
id|null_sha1
)paren
)paren
suffix:semicolon
r_else
id|strcpy
c_func
(paren
id|temp-&gt;hex
comma
id|sha1_to_hex
c_func
(paren
id|one-&gt;sha1
)paren
)paren
suffix:semicolon
multiline_comment|/* Even though we may sometimes borrow the&n;&t;&t;&t; * contents from the work tree, we always want&n;&t;&t;&t; * one-&gt;mode.  mode is trustworthy even when&n;&t;&t;&t; * !(one-&gt;sha1_valid), as long as&n;&t;&t;&t; * DIFF_FILE_VALID(one).&n;&t;&t;&t; */
id|sprintf
c_func
(paren
id|temp-&gt;mode
comma
l_string|&quot;%06o&quot;
comma
id|one-&gt;mode
)paren
suffix:semicolon
)brace
r_return
id|temp
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|diff_populate_filespec
c_func
(paren
id|one
comma
l_int|0
)paren
)paren
id|die
c_func
(paren
l_string|&quot;cannot read data blob for %s&quot;
comma
id|one-&gt;path
)paren
suffix:semicolon
id|prep_temp_blob
c_func
(paren
id|name
comma
id|temp
comma
id|one-&gt;data
comma
id|one-&gt;size
comma
id|one-&gt;sha1
comma
id|one-&gt;mode
)paren
suffix:semicolon
)brace
r_return
id|temp
suffix:semicolon
)brace
DECL|function|add_external_diff_name
r_static
r_void
id|add_external_diff_name
c_func
(paren
r_struct
id|argv_array
op_star
id|argv
comma
r_const
r_char
op_star
id|name
comma
r_struct
id|diff_filespec
op_star
id|df
)paren
(brace
r_struct
id|diff_tempfile
op_star
id|temp
op_assign
id|prepare_temp_file
c_func
(paren
id|name
comma
id|df
)paren
suffix:semicolon
id|argv_array_push
c_func
(paren
id|argv
comma
id|temp-&gt;name
)paren
suffix:semicolon
id|argv_array_push
c_func
(paren
id|argv
comma
id|temp-&gt;hex
)paren
suffix:semicolon
id|argv_array_push
c_func
(paren
id|argv
comma
id|temp-&gt;mode
)paren
suffix:semicolon
)brace
multiline_comment|/* An external diff command takes:&n; *&n; * diff-cmd name infile1 infile1-sha1 infile1-mode &bslash;&n; *               infile2 infile2-sha1 infile2-mode [ rename-to ]&n; *&n; */
DECL|function|run_external_diff
r_static
r_void
id|run_external_diff
c_func
(paren
r_const
r_char
op_star
id|pgm
comma
r_const
r_char
op_star
id|name
comma
r_const
r_char
op_star
id|other
comma
r_struct
id|diff_filespec
op_star
id|one
comma
r_struct
id|diff_filespec
op_star
id|two
comma
r_const
r_char
op_star
id|xfrm_msg
comma
r_int
id|complete_rewrite
comma
r_struct
id|diff_options
op_star
id|o
)paren
(brace
r_struct
id|argv_array
id|argv
op_assign
id|ARGV_ARRAY_INIT
suffix:semicolon
r_struct
id|argv_array
id|env
op_assign
id|ARGV_ARRAY_INIT
suffix:semicolon
r_struct
id|diff_queue_struct
op_star
id|q
op_assign
op_amp
id|diff_queued_diff
suffix:semicolon
id|argv_array_push
c_func
(paren
op_amp
id|argv
comma
id|pgm
)paren
suffix:semicolon
id|argv_array_push
c_func
(paren
op_amp
id|argv
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|one
op_logical_and
id|two
)paren
(brace
id|add_external_diff_name
c_func
(paren
op_amp
id|argv
comma
id|name
comma
id|one
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|other
)paren
id|add_external_diff_name
c_func
(paren
op_amp
id|argv
comma
id|name
comma
id|two
)paren
suffix:semicolon
r_else
(brace
id|add_external_diff_name
c_func
(paren
op_amp
id|argv
comma
id|other
comma
id|two
)paren
suffix:semicolon
id|argv_array_push
c_func
(paren
op_amp
id|argv
comma
id|other
)paren
suffix:semicolon
id|argv_array_push
c_func
(paren
op_amp
id|argv
comma
id|xfrm_msg
)paren
suffix:semicolon
)brace
)brace
id|argv_array_pushf
c_func
(paren
op_amp
id|env
comma
l_string|&quot;GIT_DIFF_PATH_COUNTER=%d&quot;
comma
op_increment
id|o-&gt;diff_path_counter
)paren
suffix:semicolon
id|argv_array_pushf
c_func
(paren
op_amp
id|env
comma
l_string|&quot;GIT_DIFF_PATH_TOTAL=%d&quot;
comma
id|q-&gt;nr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|run_command_v_opt_cd_env
c_func
(paren
id|argv.argv
comma
id|RUN_USING_SHELL
comma
l_int|NULL
comma
id|env.argv
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;external diff died, stopping at %s&quot;
)paren
comma
id|name
)paren
suffix:semicolon
id|remove_tempfile
c_func
(paren
)paren
suffix:semicolon
id|argv_array_clear
c_func
(paren
op_amp
id|argv
)paren
suffix:semicolon
id|argv_array_clear
c_func
(paren
op_amp
id|env
)paren
suffix:semicolon
)brace
DECL|function|similarity_index
r_static
r_int
id|similarity_index
c_func
(paren
r_struct
id|diff_filepair
op_star
id|p
)paren
(brace
r_return
id|p-&gt;score
op_star
l_int|100
op_div
id|MAX_SCORE
suffix:semicolon
)brace
DECL|function|fill_metainfo
r_static
r_void
id|fill_metainfo
c_func
(paren
r_struct
id|strbuf
op_star
id|msg
comma
r_const
r_char
op_star
id|name
comma
r_const
r_char
op_star
id|other
comma
r_struct
id|diff_filespec
op_star
id|one
comma
r_struct
id|diff_filespec
op_star
id|two
comma
r_struct
id|diff_options
op_star
id|o
comma
r_struct
id|diff_filepair
op_star
id|p
comma
r_int
op_star
id|must_show_header
comma
r_int
id|use_color
)paren
(brace
r_const
r_char
op_star
id|set
op_assign
id|diff_get_color
c_func
(paren
id|use_color
comma
id|DIFF_METAINFO
)paren
suffix:semicolon
r_const
r_char
op_star
id|reset
op_assign
id|diff_get_color
c_func
(paren
id|use_color
comma
id|DIFF_RESET
)paren
suffix:semicolon
r_const
r_char
op_star
id|line_prefix
op_assign
id|diff_line_prefix
c_func
(paren
id|o
)paren
suffix:semicolon
op_star
id|must_show_header
op_assign
l_int|1
suffix:semicolon
id|strbuf_init
c_func
(paren
id|msg
comma
id|PATH_MAX
op_star
l_int|2
op_plus
l_int|300
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|p-&gt;status
)paren
(brace
r_case
id|DIFF_STATUS_COPIED
suffix:colon
id|strbuf_addf
c_func
(paren
id|msg
comma
l_string|&quot;%s%ssimilarity index %d%%&quot;
comma
id|line_prefix
comma
id|set
comma
id|similarity_index
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
id|strbuf_addf
c_func
(paren
id|msg
comma
l_string|&quot;%s&bslash;n%s%scopy from &quot;
comma
id|reset
comma
id|line_prefix
comma
id|set
)paren
suffix:semicolon
id|quote_c_style
c_func
(paren
id|name
comma
id|msg
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|strbuf_addf
c_func
(paren
id|msg
comma
l_string|&quot;%s&bslash;n%s%scopy to &quot;
comma
id|reset
comma
id|line_prefix
comma
id|set
)paren
suffix:semicolon
id|quote_c_style
c_func
(paren
id|other
comma
id|msg
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|strbuf_addf
c_func
(paren
id|msg
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|reset
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DIFF_STATUS_RENAMED
suffix:colon
id|strbuf_addf
c_func
(paren
id|msg
comma
l_string|&quot;%s%ssimilarity index %d%%&quot;
comma
id|line_prefix
comma
id|set
comma
id|similarity_index
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
id|strbuf_addf
c_func
(paren
id|msg
comma
l_string|&quot;%s&bslash;n%s%srename from &quot;
comma
id|reset
comma
id|line_prefix
comma
id|set
)paren
suffix:semicolon
id|quote_c_style
c_func
(paren
id|name
comma
id|msg
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|strbuf_addf
c_func
(paren
id|msg
comma
l_string|&quot;%s&bslash;n%s%srename to &quot;
comma
id|reset
comma
id|line_prefix
comma
id|set
)paren
suffix:semicolon
id|quote_c_style
c_func
(paren
id|other
comma
id|msg
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|strbuf_addf
c_func
(paren
id|msg
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|reset
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DIFF_STATUS_MODIFIED
suffix:colon
r_if
c_cond
(paren
id|p-&gt;score
)paren
(brace
id|strbuf_addf
c_func
(paren
id|msg
comma
l_string|&quot;%s%sdissimilarity index %d%%%s&bslash;n&quot;
comma
id|line_prefix
comma
id|set
comma
id|similarity_index
c_func
(paren
id|p
)paren
comma
id|reset
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* fallthru */
r_default
suffix:colon
op_star
id|must_show_header
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|one
op_logical_and
id|two
op_logical_and
id|hashcmp
c_func
(paren
id|one-&gt;sha1
comma
id|two-&gt;sha1
)paren
)paren
(brace
r_int
id|abbrev
op_assign
id|DIFF_OPT_TST
c_func
(paren
id|o
comma
id|FULL_INDEX
)paren
ques
c_cond
l_int|40
suffix:colon
id|DEFAULT_ABBREV
suffix:semicolon
r_if
c_cond
(paren
id|DIFF_OPT_TST
c_func
(paren
id|o
comma
id|BINARY
)paren
)paren
(brace
id|mmfile_t
id|mf
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|fill_mmfile
c_func
(paren
op_amp
id|mf
comma
id|one
)paren
op_logical_and
id|diff_filespec_is_binary
c_func
(paren
id|one
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|fill_mmfile
c_func
(paren
op_amp
id|mf
comma
id|two
)paren
op_logical_and
id|diff_filespec_is_binary
c_func
(paren
id|two
)paren
)paren
)paren
id|abbrev
op_assign
l_int|40
suffix:semicolon
)brace
id|strbuf_addf
c_func
(paren
id|msg
comma
l_string|&quot;%s%sindex %s..&quot;
comma
id|line_prefix
comma
id|set
comma
id|find_unique_abbrev
c_func
(paren
id|one-&gt;sha1
comma
id|abbrev
)paren
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
id|msg
comma
id|find_unique_abbrev
c_func
(paren
id|two-&gt;sha1
comma
id|abbrev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|one-&gt;mode
op_eq
id|two-&gt;mode
)paren
id|strbuf_addf
c_func
(paren
id|msg
comma
l_string|&quot; %06o&quot;
comma
id|one-&gt;mode
)paren
suffix:semicolon
id|strbuf_addf
c_func
(paren
id|msg
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|reset
)paren
suffix:semicolon
)brace
)brace
DECL|function|run_diff_cmd
r_static
r_void
id|run_diff_cmd
c_func
(paren
r_const
r_char
op_star
id|pgm
comma
r_const
r_char
op_star
id|name
comma
r_const
r_char
op_star
id|other
comma
r_const
r_char
op_star
id|attr_path
comma
r_struct
id|diff_filespec
op_star
id|one
comma
r_struct
id|diff_filespec
op_star
id|two
comma
r_struct
id|strbuf
op_star
id|msg
comma
r_struct
id|diff_options
op_star
id|o
comma
r_struct
id|diff_filepair
op_star
id|p
)paren
(brace
r_const
r_char
op_star
id|xfrm_msg
op_assign
l_int|NULL
suffix:semicolon
r_int
id|complete_rewrite
op_assign
(paren
id|p-&gt;status
op_eq
id|DIFF_STATUS_MODIFIED
)paren
op_logical_and
id|p-&gt;score
suffix:semicolon
r_int
id|must_show_header
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|DIFF_OPT_TST
c_func
(paren
id|o
comma
id|ALLOW_EXTERNAL
)paren
)paren
(brace
r_struct
id|userdiff_driver
op_star
id|drv
op_assign
id|userdiff_find_by_path
c_func
(paren
id|attr_path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv
op_logical_and
id|drv-&gt;external
)paren
id|pgm
op_assign
id|drv-&gt;external
suffix:semicolon
)brace
r_if
c_cond
(paren
id|msg
)paren
(brace
multiline_comment|/*&n;&t;&t; * don&squot;t use colors when the header is intended for an&n;&t;&t; * external diff driver&n;&t;&t; */
id|fill_metainfo
c_func
(paren
id|msg
comma
id|name
comma
id|other
comma
id|one
comma
id|two
comma
id|o
comma
id|p
comma
op_amp
id|must_show_header
comma
id|want_color
c_func
(paren
id|o-&gt;use_color
)paren
op_logical_and
op_logical_neg
id|pgm
)paren
suffix:semicolon
id|xfrm_msg
op_assign
id|msg-&gt;len
ques
c_cond
id|msg-&gt;buf
suffix:colon
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pgm
)paren
(brace
id|run_external_diff
c_func
(paren
id|pgm
comma
id|name
comma
id|other
comma
id|one
comma
id|two
comma
id|xfrm_msg
comma
id|complete_rewrite
comma
id|o
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|one
op_logical_and
id|two
)paren
id|builtin_diff
c_func
(paren
id|name
comma
id|other
ques
c_cond
id|other
suffix:colon
id|name
comma
id|one
comma
id|two
comma
id|xfrm_msg
comma
id|must_show_header
comma
id|o
comma
id|complete_rewrite
)paren
suffix:semicolon
r_else
id|fprintf
c_func
(paren
id|o-&gt;file
comma
l_string|&quot;* Unmerged path %s&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
)brace
DECL|function|diff_fill_sha1_info
r_static
r_void
id|diff_fill_sha1_info
c_func
(paren
r_struct
id|diff_filespec
op_star
id|one
)paren
(brace
r_if
c_cond
(paren
id|DIFF_FILE_VALID
c_func
(paren
id|one
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|one-&gt;sha1_valid
)paren
(brace
r_struct
id|stat
id|st
suffix:semicolon
r_if
c_cond
(paren
id|one-&gt;is_stdin
)paren
(brace
id|hashcpy
c_func
(paren
id|one-&gt;sha1
comma
id|null_sha1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lstat
c_func
(paren
id|one-&gt;path
comma
op_amp
id|st
)paren
OL
l_int|0
)paren
id|die_errno
c_func
(paren
l_string|&quot;stat &squot;%s&squot;&quot;
comma
id|one-&gt;path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index_path
c_func
(paren
id|one-&gt;sha1
comma
id|one-&gt;path
comma
op_amp
id|st
comma
l_int|0
)paren
)paren
id|die
c_func
(paren
l_string|&quot;cannot hash %s&quot;
comma
id|one-&gt;path
)paren
suffix:semicolon
)brace
)brace
r_else
id|hashclr
c_func
(paren
id|one-&gt;sha1
)paren
suffix:semicolon
)brace
DECL|function|strip_prefix
r_static
r_void
id|strip_prefix
c_func
(paren
r_int
id|prefix_length
comma
r_const
r_char
op_star
op_star
id|namep
comma
r_const
r_char
op_star
op_star
id|otherp
)paren
(brace
multiline_comment|/* Strip the prefix but do not molest /dev/null and absolute paths */
r_if
c_cond
(paren
op_star
id|namep
op_logical_and
op_star
op_star
id|namep
op_ne
l_char|&squot;/&squot;
)paren
(brace
op_star
id|namep
op_add_assign
id|prefix_length
suffix:semicolon
r_if
c_cond
(paren
op_star
op_star
id|namep
op_eq
l_char|&squot;/&squot;
)paren
op_increment
op_star
id|namep
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|otherp
op_logical_and
op_star
op_star
id|otherp
op_ne
l_char|&squot;/&squot;
)paren
(brace
op_star
id|otherp
op_add_assign
id|prefix_length
suffix:semicolon
r_if
c_cond
(paren
op_star
op_star
id|otherp
op_eq
l_char|&squot;/&squot;
)paren
op_increment
op_star
id|otherp
suffix:semicolon
)brace
)brace
DECL|function|run_diff
r_static
r_void
id|run_diff
c_func
(paren
r_struct
id|diff_filepair
op_star
id|p
comma
r_struct
id|diff_options
op_star
id|o
)paren
(brace
r_const
r_char
op_star
id|pgm
op_assign
id|external_diff
c_func
(paren
)paren
suffix:semicolon
r_struct
id|strbuf
id|msg
suffix:semicolon
r_struct
id|diff_filespec
op_star
id|one
op_assign
id|p-&gt;one
suffix:semicolon
r_struct
id|diff_filespec
op_star
id|two
op_assign
id|p-&gt;two
suffix:semicolon
r_const
r_char
op_star
id|name
suffix:semicolon
r_const
r_char
op_star
id|other
suffix:semicolon
r_const
r_char
op_star
id|attr_path
suffix:semicolon
id|name
op_assign
id|p-&gt;one-&gt;path
suffix:semicolon
id|other
op_assign
(paren
id|strcmp
c_func
(paren
id|name
comma
id|p-&gt;two-&gt;path
)paren
ques
c_cond
id|p-&gt;two-&gt;path
suffix:colon
l_int|NULL
)paren
suffix:semicolon
id|attr_path
op_assign
id|name
suffix:semicolon
r_if
c_cond
(paren
id|o-&gt;prefix_length
)paren
id|strip_prefix
c_func
(paren
id|o-&gt;prefix_length
comma
op_amp
id|name
comma
op_amp
id|other
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|DIFF_OPT_TST
c_func
(paren
id|o
comma
id|ALLOW_EXTERNAL
)paren
)paren
id|pgm
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|DIFF_PAIR_UNMERGED
c_func
(paren
id|p
)paren
)paren
(brace
id|run_diff_cmd
c_func
(paren
id|pgm
comma
id|name
comma
l_int|NULL
comma
id|attr_path
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
id|o
comma
id|p
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|diff_fill_sha1_info
c_func
(paren
id|one
)paren
suffix:semicolon
id|diff_fill_sha1_info
c_func
(paren
id|two
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pgm
op_logical_and
id|DIFF_FILE_VALID
c_func
(paren
id|one
)paren
op_logical_and
id|DIFF_FILE_VALID
c_func
(paren
id|two
)paren
op_logical_and
(paren
id|S_IFMT
op_amp
id|one-&gt;mode
)paren
op_ne
(paren
id|S_IFMT
op_amp
id|two-&gt;mode
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * a filepair that changes between file and symlink&n;&t;&t; * needs to be split into deletion and creation.&n;&t;&t; */
r_struct
id|diff_filespec
op_star
id|null
op_assign
id|alloc_filespec
c_func
(paren
id|two-&gt;path
)paren
suffix:semicolon
id|run_diff_cmd
c_func
(paren
l_int|NULL
comma
id|name
comma
id|other
comma
id|attr_path
comma
id|one
comma
id|null
comma
op_amp
id|msg
comma
id|o
comma
id|p
)paren
suffix:semicolon
id|free
c_func
(paren
id|null
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|msg
)paren
suffix:semicolon
id|null
op_assign
id|alloc_filespec
c_func
(paren
id|one-&gt;path
)paren
suffix:semicolon
id|run_diff_cmd
c_func
(paren
l_int|NULL
comma
id|name
comma
id|other
comma
id|attr_path
comma
id|null
comma
id|two
comma
op_amp
id|msg
comma
id|o
comma
id|p
)paren
suffix:semicolon
id|free
c_func
(paren
id|null
)paren
suffix:semicolon
)brace
r_else
id|run_diff_cmd
c_func
(paren
id|pgm
comma
id|name
comma
id|other
comma
id|attr_path
comma
id|one
comma
id|two
comma
op_amp
id|msg
comma
id|o
comma
id|p
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|msg
)paren
suffix:semicolon
)brace
DECL|function|run_diffstat
r_static
r_void
id|run_diffstat
c_func
(paren
r_struct
id|diff_filepair
op_star
id|p
comma
r_struct
id|diff_options
op_star
id|o
comma
r_struct
id|diffstat_t
op_star
id|diffstat
)paren
(brace
r_const
r_char
op_star
id|name
suffix:semicolon
r_const
r_char
op_star
id|other
suffix:semicolon
r_if
c_cond
(paren
id|DIFF_PAIR_UNMERGED
c_func
(paren
id|p
)paren
)paren
(brace
multiline_comment|/* unmerged */
id|builtin_diffstat
c_func
(paren
id|p-&gt;one-&gt;path
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
id|diffstat
comma
id|o
comma
id|p
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|name
op_assign
id|p-&gt;one-&gt;path
suffix:semicolon
id|other
op_assign
(paren
id|strcmp
c_func
(paren
id|name
comma
id|p-&gt;two-&gt;path
)paren
ques
c_cond
id|p-&gt;two-&gt;path
suffix:colon
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|o-&gt;prefix_length
)paren
id|strip_prefix
c_func
(paren
id|o-&gt;prefix_length
comma
op_amp
id|name
comma
op_amp
id|other
)paren
suffix:semicolon
id|diff_fill_sha1_info
c_func
(paren
id|p-&gt;one
)paren
suffix:semicolon
id|diff_fill_sha1_info
c_func
(paren
id|p-&gt;two
)paren
suffix:semicolon
id|builtin_diffstat
c_func
(paren
id|name
comma
id|other
comma
id|p-&gt;one
comma
id|p-&gt;two
comma
id|diffstat
comma
id|o
comma
id|p
)paren
suffix:semicolon
)brace
DECL|function|run_checkdiff
r_static
r_void
id|run_checkdiff
c_func
(paren
r_struct
id|diff_filepair
op_star
id|p
comma
r_struct
id|diff_options
op_star
id|o
)paren
(brace
r_const
r_char
op_star
id|name
suffix:semicolon
r_const
r_char
op_star
id|other
suffix:semicolon
r_const
r_char
op_star
id|attr_path
suffix:semicolon
r_if
c_cond
(paren
id|DIFF_PAIR_UNMERGED
c_func
(paren
id|p
)paren
)paren
(brace
multiline_comment|/* unmerged */
r_return
suffix:semicolon
)brace
id|name
op_assign
id|p-&gt;one-&gt;path
suffix:semicolon
id|other
op_assign
(paren
id|strcmp
c_func
(paren
id|name
comma
id|p-&gt;two-&gt;path
)paren
ques
c_cond
id|p-&gt;two-&gt;path
suffix:colon
l_int|NULL
)paren
suffix:semicolon
id|attr_path
op_assign
id|other
ques
c_cond
id|other
suffix:colon
id|name
suffix:semicolon
r_if
c_cond
(paren
id|o-&gt;prefix_length
)paren
id|strip_prefix
c_func
(paren
id|o-&gt;prefix_length
comma
op_amp
id|name
comma
op_amp
id|other
)paren
suffix:semicolon
id|diff_fill_sha1_info
c_func
(paren
id|p-&gt;one
)paren
suffix:semicolon
id|diff_fill_sha1_info
c_func
(paren
id|p-&gt;two
)paren
suffix:semicolon
id|builtin_checkdiff
c_func
(paren
id|name
comma
id|other
comma
id|attr_path
comma
id|p-&gt;one
comma
id|p-&gt;two
comma
id|o
)paren
suffix:semicolon
)brace
DECL|function|diff_setup
r_void
id|diff_setup
c_func
(paren
r_struct
id|diff_options
op_star
id|options
)paren
(brace
id|memcpy
c_func
(paren
id|options
comma
op_amp
id|default_diff_options
comma
r_sizeof
(paren
op_star
id|options
)paren
)paren
suffix:semicolon
id|options-&gt;file
op_assign
id|stdout
suffix:semicolon
id|options-&gt;line_termination
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
id|options-&gt;break_opt
op_assign
l_int|1
suffix:semicolon
id|options-&gt;rename_limit
op_assign
l_int|1
suffix:semicolon
id|options-&gt;dirstat_permille
op_assign
id|diff_dirstat_permille_default
suffix:semicolon
id|options-&gt;context
op_assign
id|diff_context_default
suffix:semicolon
id|DIFF_OPT_SET
c_func
(paren
id|options
comma
id|RENAME_EMPTY
)paren
suffix:semicolon
multiline_comment|/* pathchange left =NULL by default */
id|options-&gt;change
op_assign
id|diff_change
suffix:semicolon
id|options-&gt;add_remove
op_assign
id|diff_addremove
suffix:semicolon
id|options-&gt;use_color
op_assign
id|diff_use_color_default
suffix:semicolon
id|options-&gt;detect_rename
op_assign
id|diff_detect_rename_default
suffix:semicolon
id|options-&gt;xdl_opts
op_or_assign
id|diff_algorithm
suffix:semicolon
id|options-&gt;orderfile
op_assign
id|diff_order_file_cfg
suffix:semicolon
r_if
c_cond
(paren
id|diff_no_prefix
)paren
(brace
id|options-&gt;a_prefix
op_assign
id|options-&gt;b_prefix
op_assign
l_string|&quot;&quot;
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|diff_mnemonic_prefix
)paren
(brace
id|options-&gt;a_prefix
op_assign
l_string|&quot;a/&quot;
suffix:semicolon
id|options-&gt;b_prefix
op_assign
l_string|&quot;b/&quot;
suffix:semicolon
)brace
)brace
DECL|function|diff_setup_done
r_void
id|diff_setup_done
c_func
(paren
r_struct
id|diff_options
op_star
id|options
)paren
(brace
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|options-&gt;set_default
)paren
id|options
op_member_access_from_pointer
id|set_default
c_func
(paren
id|options
)paren
suffix:semicolon
r_if
c_cond
(paren
id|options-&gt;output_format
op_amp
id|DIFF_FORMAT_NAME
)paren
id|count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|options-&gt;output_format
op_amp
id|DIFF_FORMAT_NAME_STATUS
)paren
id|count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|options-&gt;output_format
op_amp
id|DIFF_FORMAT_CHECKDIFF
)paren
id|count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|options-&gt;output_format
op_amp
id|DIFF_FORMAT_NO_OUTPUT
)paren
id|count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
l_int|1
)paren
id|die
c_func
(paren
l_string|&quot;--name-only, --name-status, --check and -s are mutually exclusive&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Most of the time we can say &quot;there are changes&quot;&n;&t; * only by checking if there are changed paths, but&n;&t; * --ignore-whitespace* options force us to look&n;&t; * inside contents.&n;&t; */
r_if
c_cond
(paren
id|DIFF_XDL_TST
c_func
(paren
id|options
comma
id|IGNORE_WHITESPACE
)paren
op_logical_or
id|DIFF_XDL_TST
c_func
(paren
id|options
comma
id|IGNORE_WHITESPACE_CHANGE
)paren
op_logical_or
id|DIFF_XDL_TST
c_func
(paren
id|options
comma
id|IGNORE_WHITESPACE_AT_EOL
)paren
)paren
id|DIFF_OPT_SET
c_func
(paren
id|options
comma
id|DIFF_FROM_CONTENTS
)paren
suffix:semicolon
r_else
id|DIFF_OPT_CLR
c_func
(paren
id|options
comma
id|DIFF_FROM_CONTENTS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DIFF_OPT_TST
c_func
(paren
id|options
comma
id|FIND_COPIES_HARDER
)paren
)paren
id|options-&gt;detect_rename
op_assign
id|DIFF_DETECT_COPY
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|DIFF_OPT_TST
c_func
(paren
id|options
comma
id|RELATIVE_NAME
)paren
)paren
id|options-&gt;prefix
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|options-&gt;prefix
)paren
id|options-&gt;prefix_length
op_assign
id|strlen
c_func
(paren
id|options-&gt;prefix
)paren
suffix:semicolon
r_else
id|options-&gt;prefix_length
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|options-&gt;output_format
op_amp
(paren
id|DIFF_FORMAT_NAME
op_or
id|DIFF_FORMAT_NAME_STATUS
op_or
id|DIFF_FORMAT_CHECKDIFF
op_or
id|DIFF_FORMAT_NO_OUTPUT
)paren
)paren
id|options-&gt;output_format
op_and_assign
op_complement
(paren
id|DIFF_FORMAT_RAW
op_or
id|DIFF_FORMAT_NUMSTAT
op_or
id|DIFF_FORMAT_DIFFSTAT
op_or
id|DIFF_FORMAT_SHORTSTAT
op_or
id|DIFF_FORMAT_DIRSTAT
op_or
id|DIFF_FORMAT_SUMMARY
op_or
id|DIFF_FORMAT_PATCH
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * These cases always need recursive; we do not drop caller-supplied&n;&t; * recursive bits for other formats here.&n;&t; */
r_if
c_cond
(paren
id|options-&gt;output_format
op_amp
(paren
id|DIFF_FORMAT_PATCH
op_or
id|DIFF_FORMAT_NUMSTAT
op_or
id|DIFF_FORMAT_DIFFSTAT
op_or
id|DIFF_FORMAT_SHORTSTAT
op_or
id|DIFF_FORMAT_DIRSTAT
op_or
id|DIFF_FORMAT_SUMMARY
op_or
id|DIFF_FORMAT_CHECKDIFF
)paren
)paren
id|DIFF_OPT_SET
c_func
(paren
id|options
comma
id|RECURSIVE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Also pickaxe would not work very well if you do not say recursive&n;&t; */
r_if
c_cond
(paren
id|options-&gt;pickaxe
)paren
id|DIFF_OPT_SET
c_func
(paren
id|options
comma
id|RECURSIVE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * When patches are generated, submodules diffed against the work tree&n;&t; * must be checked for dirtiness too so it can be shown in the output&n;&t; */
r_if
c_cond
(paren
id|options-&gt;output_format
op_amp
id|DIFF_FORMAT_PATCH
)paren
id|DIFF_OPT_SET
c_func
(paren
id|options
comma
id|DIRTY_SUBMODULES
)paren
suffix:semicolon
r_if
c_cond
(paren
id|options-&gt;detect_rename
op_logical_and
id|options-&gt;rename_limit
OL
l_int|0
)paren
id|options-&gt;rename_limit
op_assign
id|diff_rename_limit_default
suffix:semicolon
r_if
c_cond
(paren
id|options-&gt;setup
op_amp
id|DIFF_SETUP_USE_CACHE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|active_cache
)paren
multiline_comment|/* read-cache does not die even when it fails&n;&t;&t;&t; * so it is safe for us to do this here.  Also&n;&t;&t;&t; * it does not smudge active_cache or active_nr&n;&t;&t;&t; * when it fails, so we do not have to worry about&n;&t;&t;&t; * cleaning it up ourselves either.&n;&t;&t;&t; */
id|read_cache
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|options-&gt;abbrev
op_le
l_int|0
op_logical_or
l_int|40
OL
id|options-&gt;abbrev
)paren
id|options-&gt;abbrev
op_assign
l_int|40
suffix:semicolon
multiline_comment|/* full */
multiline_comment|/*&n;&t; * It does not make sense to show the first hit we happened&n;&t; * to have found.  It does not make sense not to return with&n;&t; * exit code in such a case either.&n;&t; */
r_if
c_cond
(paren
id|DIFF_OPT_TST
c_func
(paren
id|options
comma
id|QUICK
)paren
)paren
(brace
id|options-&gt;output_format
op_assign
id|DIFF_FORMAT_NO_OUTPUT
suffix:semicolon
id|DIFF_OPT_SET
c_func
(paren
id|options
comma
id|EXIT_WITH_STATUS
)paren
suffix:semicolon
)brace
id|options-&gt;diff_path_counter
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|DIFF_OPT_TST
c_func
(paren
id|options
comma
id|FOLLOW_RENAMES
)paren
op_logical_and
id|options-&gt;pathspec.nr
op_ne
l_int|1
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;--follow requires exactly one pathspec&quot;
)paren
)paren
suffix:semicolon
)brace
DECL|function|opt_arg
r_static
r_int
id|opt_arg
c_func
(paren
r_const
r_char
op_star
id|arg
comma
r_int
id|arg_short
comma
r_const
r_char
op_star
id|arg_long
comma
r_int
op_star
id|val
)paren
(brace
r_char
id|c
comma
op_star
id|eq
suffix:semicolon
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
op_star
id|arg
op_ne
l_char|&squot;-&squot;
)paren
r_return
l_int|0
suffix:semicolon
id|c
op_assign
op_star
op_increment
id|arg
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
id|arg_short
)paren
(brace
id|c
op_assign
op_star
op_increment
id|arg
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|val
op_logical_and
id|isdigit
c_func
(paren
id|c
)paren
)paren
(brace
r_char
op_star
id|end
suffix:semicolon
r_int
id|n
op_assign
id|strtoul
c_func
(paren
id|arg
comma
op_amp
id|end
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|end
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|val
op_assign
id|n
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_ne
l_char|&squot;-&squot;
)paren
r_return
l_int|0
suffix:semicolon
id|arg
op_increment
suffix:semicolon
id|eq
op_assign
id|strchrnul
c_func
(paren
id|arg
comma
l_char|&squot;=&squot;
)paren
suffix:semicolon
id|len
op_assign
id|eq
id|arg
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
op_logical_or
id|strncmp
c_func
(paren
id|arg
comma
id|arg_long
comma
id|len
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_star
id|eq
)paren
(brace
r_int
id|n
suffix:semicolon
r_char
op_star
id|end
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|isdigit
c_func
(paren
op_star
op_increment
id|eq
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|n
op_assign
id|strtoul
c_func
(paren
id|eq
comma
op_amp
id|end
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|end
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|val
op_assign
id|n
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_int
id|diff_scoreopt_parse
c_func
(paren
r_const
r_char
op_star
id|opt
)paren
suffix:semicolon
DECL|function|short_opt
r_static
r_inline
r_int
id|short_opt
c_func
(paren
r_char
id|opt
comma
r_const
r_char
op_star
op_star
id|argv
comma
r_const
r_char
op_star
op_star
id|optarg
)paren
(brace
r_const
r_char
op_star
id|arg
op_assign
id|argv
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|arg
(braket
l_int|0
)braket
op_ne
l_char|&squot;-&squot;
op_logical_or
id|arg
(braket
l_int|1
)braket
op_ne
id|opt
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|arg
(braket
l_int|2
)braket
op_ne
l_char|&squot;&bslash;0&squot;
)paren
(brace
op_star
id|optarg
op_assign
id|arg
op_plus
l_int|2
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|argv
(braket
l_int|1
)braket
)paren
id|die
c_func
(paren
l_string|&quot;Option &squot;%c&squot; requires a value&quot;
comma
id|opt
)paren
suffix:semicolon
op_star
id|optarg
op_assign
id|argv
(braket
l_int|1
)braket
suffix:semicolon
r_return
l_int|2
suffix:semicolon
)brace
DECL|function|parse_long_opt
r_int
id|parse_long_opt
c_func
(paren
r_const
r_char
op_star
id|opt
comma
r_const
r_char
op_star
op_star
id|argv
comma
r_const
r_char
op_star
op_star
id|optarg
)paren
(brace
r_const
r_char
op_star
id|arg
op_assign
id|argv
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|arg
(braket
l_int|0
)braket
op_ne
l_char|&squot;-&squot;
op_logical_or
id|arg
(braket
l_int|1
)braket
op_ne
l_char|&squot;-&squot;
)paren
r_return
l_int|0
suffix:semicolon
id|arg
op_add_assign
id|strlen
c_func
(paren
l_string|&quot;--&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|starts_with
c_func
(paren
id|arg
comma
id|opt
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|arg
op_add_assign
id|strlen
c_func
(paren
id|opt
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|arg
op_eq
l_char|&squot;=&squot;
)paren
(brace
multiline_comment|/* stuck form: --option=value */
op_star
id|optarg
op_assign
id|arg
op_plus
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|arg
op_ne
l_char|&squot;&bslash;0&squot;
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* separate form: --option value */
r_if
c_cond
(paren
op_logical_neg
id|argv
(braket
l_int|1
)braket
)paren
id|die
c_func
(paren
l_string|&quot;Option &squot;--%s&squot; requires a value&quot;
comma
id|opt
)paren
suffix:semicolon
op_star
id|optarg
op_assign
id|argv
(braket
l_int|1
)braket
suffix:semicolon
r_return
l_int|2
suffix:semicolon
)brace
DECL|function|stat_opt
r_static
r_int
id|stat_opt
c_func
(paren
r_struct
id|diff_options
op_star
id|options
comma
r_const
r_char
op_star
op_star
id|av
)paren
(brace
r_const
r_char
op_star
id|arg
op_assign
id|av
(braket
l_int|0
)braket
suffix:semicolon
r_char
op_star
id|end
suffix:semicolon
r_int
id|width
op_assign
id|options-&gt;stat_width
suffix:semicolon
r_int
id|name_width
op_assign
id|options-&gt;stat_name_width
suffix:semicolon
r_int
id|graph_width
op_assign
id|options-&gt;stat_graph_width
suffix:semicolon
r_int
id|count
op_assign
id|options-&gt;stat_count
suffix:semicolon
r_int
id|argcount
op_assign
l_int|1
suffix:semicolon
id|arg
op_add_assign
id|strlen
c_func
(paren
l_string|&quot;--stat&quot;
)paren
suffix:semicolon
id|end
op_assign
(paren
r_char
op_star
)paren
id|arg
suffix:semicolon
r_switch
c_cond
(paren
op_star
id|arg
)paren
(brace
r_case
l_char|&squot;-&squot;
suffix:colon
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|arg
comma
l_string|&quot;-width&quot;
)paren
)paren
(brace
id|arg
op_add_assign
id|strlen
c_func
(paren
l_string|&quot;-width&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|arg
op_eq
l_char|&squot;=&squot;
)paren
id|width
op_assign
id|strtoul
c_func
(paren
id|arg
op_plus
l_int|1
comma
op_amp
id|end
comma
l_int|10
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
op_star
id|arg
op_logical_and
op_logical_neg
id|av
(braket
l_int|1
)braket
)paren
id|die
c_func
(paren
l_string|&quot;Option &squot;--stat-width&squot; requires a value&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
op_star
id|arg
)paren
(brace
id|width
op_assign
id|strtoul
c_func
(paren
id|av
(braket
l_int|1
)braket
comma
op_amp
id|end
comma
l_int|10
)paren
suffix:semicolon
id|argcount
op_assign
l_int|2
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|arg
comma
l_string|&quot;-name-width&quot;
)paren
)paren
(brace
id|arg
op_add_assign
id|strlen
c_func
(paren
l_string|&quot;-name-width&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|arg
op_eq
l_char|&squot;=&squot;
)paren
id|name_width
op_assign
id|strtoul
c_func
(paren
id|arg
op_plus
l_int|1
comma
op_amp
id|end
comma
l_int|10
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
op_star
id|arg
op_logical_and
op_logical_neg
id|av
(braket
l_int|1
)braket
)paren
id|die
c_func
(paren
l_string|&quot;Option &squot;--stat-name-width&squot; requires a value&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
op_star
id|arg
)paren
(brace
id|name_width
op_assign
id|strtoul
c_func
(paren
id|av
(braket
l_int|1
)braket
comma
op_amp
id|end
comma
l_int|10
)paren
suffix:semicolon
id|argcount
op_assign
l_int|2
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|arg
comma
l_string|&quot;-graph-width&quot;
)paren
)paren
(brace
id|arg
op_add_assign
id|strlen
c_func
(paren
l_string|&quot;-graph-width&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|arg
op_eq
l_char|&squot;=&squot;
)paren
id|graph_width
op_assign
id|strtoul
c_func
(paren
id|arg
op_plus
l_int|1
comma
op_amp
id|end
comma
l_int|10
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
op_star
id|arg
op_logical_and
op_logical_neg
id|av
(braket
l_int|1
)braket
)paren
id|die
c_func
(paren
l_string|&quot;Option &squot;--stat-graph-width&squot; requires a value&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
op_star
id|arg
)paren
(brace
id|graph_width
op_assign
id|strtoul
c_func
(paren
id|av
(braket
l_int|1
)braket
comma
op_amp
id|end
comma
l_int|10
)paren
suffix:semicolon
id|argcount
op_assign
l_int|2
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|arg
comma
l_string|&quot;-count&quot;
)paren
)paren
(brace
id|arg
op_add_assign
id|strlen
c_func
(paren
l_string|&quot;-count&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|arg
op_eq
l_char|&squot;=&squot;
)paren
id|count
op_assign
id|strtoul
c_func
(paren
id|arg
op_plus
l_int|1
comma
op_amp
id|end
comma
l_int|10
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
op_star
id|arg
op_logical_and
op_logical_neg
id|av
(braket
l_int|1
)braket
)paren
id|die
c_func
(paren
l_string|&quot;Option &squot;--stat-count&squot; requires a value&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
op_star
id|arg
)paren
(brace
id|count
op_assign
id|strtoul
c_func
(paren
id|av
(braket
l_int|1
)braket
comma
op_amp
id|end
comma
l_int|10
)paren
suffix:semicolon
id|argcount
op_assign
l_int|2
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;=&squot;
suffix:colon
id|width
op_assign
id|strtoul
c_func
(paren
id|arg
op_plus
l_int|1
comma
op_amp
id|end
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|end
op_eq
l_char|&squot;,&squot;
)paren
id|name_width
op_assign
id|strtoul
c_func
(paren
id|end
op_plus
l_int|1
comma
op_amp
id|end
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|end
op_eq
l_char|&squot;,&squot;
)paren
id|count
op_assign
id|strtoul
c_func
(paren
id|end
op_plus
l_int|1
comma
op_amp
id|end
comma
l_int|10
)paren
suffix:semicolon
)brace
multiline_comment|/* Important! This checks all the error cases! */
r_if
c_cond
(paren
op_star
id|end
)paren
r_return
l_int|0
suffix:semicolon
id|options-&gt;output_format
op_or_assign
id|DIFF_FORMAT_DIFFSTAT
suffix:semicolon
id|options-&gt;stat_name_width
op_assign
id|name_width
suffix:semicolon
id|options-&gt;stat_graph_width
op_assign
id|graph_width
suffix:semicolon
id|options-&gt;stat_width
op_assign
id|width
suffix:semicolon
id|options-&gt;stat_count
op_assign
id|count
suffix:semicolon
r_return
id|argcount
suffix:semicolon
)brace
DECL|function|parse_dirstat_opt
r_static
r_int
id|parse_dirstat_opt
c_func
(paren
r_struct
id|diff_options
op_star
id|options
comma
r_const
r_char
op_star
id|params
)paren
(brace
r_struct
id|strbuf
id|errmsg
op_assign
id|STRBUF_INIT
suffix:semicolon
r_if
c_cond
(paren
id|parse_dirstat_params
c_func
(paren
id|options
comma
id|params
comma
op_amp
id|errmsg
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Failed to parse --dirstat/-X option parameter:&bslash;n%s&quot;
)paren
comma
id|errmsg.buf
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|errmsg
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The caller knows a dirstat-related option is given from the command&n;&t; * line; allow it to say &quot;return this_function();&quot;&n;&t; */
id|options-&gt;output_format
op_or_assign
id|DIFF_FORMAT_DIRSTAT
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|parse_submodule_opt
r_static
r_int
id|parse_submodule_opt
c_func
(paren
r_struct
id|diff_options
op_star
id|options
comma
r_const
r_char
op_star
id|value
)paren
(brace
r_if
c_cond
(paren
id|parse_submodule_params
c_func
(paren
id|options
comma
id|value
)paren
)paren
id|die
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Failed to parse --submodule option parameter: &squot;%s&squot;&quot;
)paren
comma
id|value
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|variable|diff_status_letters
r_static
r_const
r_char
id|diff_status_letters
(braket
)braket
op_assign
(brace
id|DIFF_STATUS_ADDED
comma
id|DIFF_STATUS_COPIED
comma
id|DIFF_STATUS_DELETED
comma
id|DIFF_STATUS_MODIFIED
comma
id|DIFF_STATUS_RENAMED
comma
id|DIFF_STATUS_TYPE_CHANGED
comma
id|DIFF_STATUS_UNKNOWN
comma
id|DIFF_STATUS_UNMERGED
comma
id|DIFF_STATUS_FILTER_AON
comma
id|DIFF_STATUS_FILTER_BROKEN
comma
l_char|&squot;&bslash;0&squot;
comma
)brace
suffix:semicolon
DECL|variable|filter_bit
r_static
r_int
r_int
id|filter_bit
(braket
l_char|&squot;Z&squot;
op_plus
l_int|1
)braket
suffix:semicolon
DECL|function|prepare_filter_bits
r_static
r_void
id|prepare_filter_bits
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|filter_bit
(braket
id|DIFF_STATUS_ADDED
)braket
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|diff_status_letters
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
id|filter_bit
(braket
(paren
r_int
)paren
id|diff_status_letters
(braket
id|i
)braket
)braket
op_assign
(paren
l_int|1
op_lshift
id|i
)paren
suffix:semicolon
)brace
)brace
DECL|function|filter_bit_tst
r_static
r_int
id|filter_bit_tst
c_func
(paren
r_char
id|status
comma
r_const
r_struct
id|diff_options
op_star
id|opt
)paren
(brace
r_return
id|opt-&gt;filter
op_amp
id|filter_bit
(braket
(paren
r_int
)paren
id|status
)braket
suffix:semicolon
)brace
DECL|function|parse_diff_filter_opt
r_static
r_int
id|parse_diff_filter_opt
c_func
(paren
r_const
r_char
op_star
id|optarg
comma
r_struct
id|diff_options
op_star
id|opt
)paren
(brace
r_int
id|i
comma
id|optch
suffix:semicolon
id|prepare_filter_bits
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If there is a negation e.g. &squot;d&squot; in the input, and we haven&squot;t&n;&t; * initialized the filter field with another --diff-filter, start&n;&t; * from full set of bits, except for AON.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|opt-&gt;filter
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|optch
op_assign
id|optarg
(braket
id|i
)braket
)paren
op_ne
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|optch
OL
l_char|&squot;a&squot;
op_logical_or
l_char|&squot;z&squot;
OL
id|optch
)paren
r_continue
suffix:semicolon
id|opt-&gt;filter
op_assign
(paren
l_int|1
op_lshift
(paren
id|ARRAY_SIZE
c_func
(paren
id|diff_status_letters
)paren
l_int|1
)paren
)paren
l_int|1
suffix:semicolon
id|opt-&gt;filter
op_and_assign
op_complement
id|filter_bit
(braket
id|DIFF_STATUS_FILTER_AON
)braket
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|optch
op_assign
id|optarg
(braket
id|i
)braket
)paren
op_ne
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|bit
suffix:semicolon
r_int
id|negate
suffix:semicolon
r_if
c_cond
(paren
l_char|&squot;a&squot;
op_le
id|optch
op_logical_and
id|optch
op_le
l_char|&squot;z&squot;
)paren
(brace
id|negate
op_assign
l_int|1
suffix:semicolon
id|optch
op_assign
id|toupper
c_func
(paren
id|optch
)paren
suffix:semicolon
)brace
r_else
(brace
id|negate
op_assign
l_int|0
suffix:semicolon
)brace
id|bit
op_assign
(paren
l_int|0
op_le
id|optch
op_logical_and
id|optch
op_le
l_char|&squot;Z&squot;
)paren
ques
c_cond
id|filter_bit
(braket
id|optch
)braket
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bit
)paren
r_return
id|optarg
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|negate
)paren
id|opt-&gt;filter
op_and_assign
op_complement
id|bit
suffix:semicolon
r_else
id|opt-&gt;filter
op_or_assign
id|bit
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|enable_patch_output
r_static
r_void
id|enable_patch_output
c_func
(paren
r_int
op_star
id|fmt
)paren
(brace
op_star
id|fmt
op_and_assign
op_complement
id|DIFF_FORMAT_NO_OUTPUT
suffix:semicolon
op_star
id|fmt
op_or_assign
id|DIFF_FORMAT_PATCH
suffix:semicolon
)brace
DECL|function|diff_opt_parse
r_int
id|diff_opt_parse
c_func
(paren
r_struct
id|diff_options
op_star
id|options
comma
r_const
r_char
op_star
op_star
id|av
comma
r_int
id|ac
)paren
(brace
r_const
r_char
op_star
id|arg
op_assign
id|av
(braket
l_int|0
)braket
suffix:semicolon
r_const
r_char
op_star
id|optarg
suffix:semicolon
r_int
id|argcount
suffix:semicolon
multiline_comment|/* Output format options */
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;-p&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;-u&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--patch&quot;
)paren
op_logical_or
id|opt_arg
c_func
(paren
id|arg
comma
l_char|&squot;U&squot;
comma
l_string|&quot;unified&quot;
comma
op_amp
id|options-&gt;context
)paren
)paren
id|enable_patch_output
c_func
(paren
op_amp
id|options-&gt;output_format
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--raw&quot;
)paren
)paren
id|options-&gt;output_format
op_or_assign
id|DIFF_FORMAT_RAW
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--patch-with-raw&quot;
)paren
)paren
(brace
id|enable_patch_output
c_func
(paren
op_amp
id|options-&gt;output_format
)paren
suffix:semicolon
id|options-&gt;output_format
op_or_assign
id|DIFF_FORMAT_RAW
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--numstat&quot;
)paren
)paren
id|options-&gt;output_format
op_or_assign
id|DIFF_FORMAT_NUMSTAT
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--shortstat&quot;
)paren
)paren
id|options-&gt;output_format
op_or_assign
id|DIFF_FORMAT_SHORTSTAT
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;-X&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--dirstat&quot;
)paren
)paren
r_return
id|parse_dirstat_opt
c_func
(paren
id|options
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|arg
comma
l_string|&quot;-X&quot;
)paren
)paren
r_return
id|parse_dirstat_opt
c_func
(paren
id|options
comma
id|arg
op_plus
l_int|2
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|arg
comma
l_string|&quot;--dirstat=&quot;
)paren
)paren
r_return
id|parse_dirstat_opt
c_func
(paren
id|options
comma
id|arg
op_plus
l_int|10
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--cumulative&quot;
)paren
)paren
r_return
id|parse_dirstat_opt
c_func
(paren
id|options
comma
l_string|&quot;cumulative&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--dirstat-by-file&quot;
)paren
)paren
r_return
id|parse_dirstat_opt
c_func
(paren
id|options
comma
l_string|&quot;files&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|arg
comma
l_string|&quot;--dirstat-by-file=&quot;
)paren
)paren
(brace
id|parse_dirstat_opt
c_func
(paren
id|options
comma
l_string|&quot;files&quot;
)paren
suffix:semicolon
r_return
id|parse_dirstat_opt
c_func
(paren
id|options
comma
id|arg
op_plus
l_int|18
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--check&quot;
)paren
)paren
id|options-&gt;output_format
op_or_assign
id|DIFF_FORMAT_CHECKDIFF
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--summary&quot;
)paren
)paren
id|options-&gt;output_format
op_or_assign
id|DIFF_FORMAT_SUMMARY
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--patch-with-stat&quot;
)paren
)paren
(brace
id|enable_patch_output
c_func
(paren
op_amp
id|options-&gt;output_format
)paren
suffix:semicolon
id|options-&gt;output_format
op_or_assign
id|DIFF_FORMAT_DIFFSTAT
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--name-only&quot;
)paren
)paren
id|options-&gt;output_format
op_or_assign
id|DIFF_FORMAT_NAME
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--name-status&quot;
)paren
)paren
id|options-&gt;output_format
op_or_assign
id|DIFF_FORMAT_NAME_STATUS
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;-s&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--no-patch&quot;
)paren
)paren
id|options-&gt;output_format
op_or_assign
id|DIFF_FORMAT_NO_OUTPUT
suffix:semicolon
r_else
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|arg
comma
l_string|&quot;--stat&quot;
)paren
)paren
multiline_comment|/* --stat, --stat-width, --stat-name-width, or --stat-count */
r_return
id|stat_opt
c_func
(paren
id|options
comma
id|av
)paren
suffix:semicolon
multiline_comment|/* renames options */
r_else
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|arg
comma
l_string|&quot;-B&quot;
)paren
op_logical_or
id|starts_with
c_func
(paren
id|arg
comma
l_string|&quot;--break-rewrites=&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--break-rewrites&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|options-&gt;break_opt
op_assign
id|diff_scoreopt_parse
c_func
(paren
id|arg
)paren
)paren
op_eq
l_int|1
)paren
r_return
id|error
c_func
(paren
l_string|&quot;invalid argument to -B: %s&quot;
comma
id|arg
op_plus
l_int|2
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|arg
comma
l_string|&quot;-M&quot;
)paren
op_logical_or
id|starts_with
c_func
(paren
id|arg
comma
l_string|&quot;--find-renames=&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--find-renames&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|options-&gt;rename_score
op_assign
id|diff_scoreopt_parse
c_func
(paren
id|arg
)paren
)paren
op_eq
l_int|1
)paren
r_return
id|error
c_func
(paren
l_string|&quot;invalid argument to -M: %s&quot;
comma
id|arg
op_plus
l_int|2
)paren
suffix:semicolon
id|options-&gt;detect_rename
op_assign
id|DIFF_DETECT_RENAME
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;-D&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--irreversible-delete&quot;
)paren
)paren
(brace
id|options-&gt;irreversible_delete
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|arg
comma
l_string|&quot;-C&quot;
)paren
op_logical_or
id|starts_with
c_func
(paren
id|arg
comma
l_string|&quot;--find-copies=&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--find-copies&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|options-&gt;detect_rename
op_eq
id|DIFF_DETECT_COPY
)paren
id|DIFF_OPT_SET
c_func
(paren
id|options
comma
id|FIND_COPIES_HARDER
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|options-&gt;rename_score
op_assign
id|diff_scoreopt_parse
c_func
(paren
id|arg
)paren
)paren
op_eq
l_int|1
)paren
r_return
id|error
c_func
(paren
l_string|&quot;invalid argument to -C: %s&quot;
comma
id|arg
op_plus
l_int|2
)paren
suffix:semicolon
id|options-&gt;detect_rename
op_assign
id|DIFF_DETECT_COPY
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--no-renames&quot;
)paren
)paren
id|options-&gt;detect_rename
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--rename-empty&quot;
)paren
)paren
id|DIFF_OPT_SET
c_func
(paren
id|options
comma
id|RENAME_EMPTY
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--no-rename-empty&quot;
)paren
)paren
id|DIFF_OPT_CLR
c_func
(paren
id|options
comma
id|RENAME_EMPTY
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--relative&quot;
)paren
)paren
id|DIFF_OPT_SET
c_func
(paren
id|options
comma
id|RELATIVE_NAME
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|arg
comma
l_string|&quot;--relative=&quot;
)paren
)paren
(brace
id|DIFF_OPT_SET
c_func
(paren
id|options
comma
id|RELATIVE_NAME
)paren
suffix:semicolon
id|options-&gt;prefix
op_assign
id|arg
op_plus
l_int|11
suffix:semicolon
)brace
multiline_comment|/* xdiff options */
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--minimal&quot;
)paren
)paren
id|DIFF_XDL_SET
c_func
(paren
id|options
comma
id|NEED_MINIMAL
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--no-minimal&quot;
)paren
)paren
id|DIFF_XDL_CLR
c_func
(paren
id|options
comma
id|NEED_MINIMAL
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;-w&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--ignore-all-space&quot;
)paren
)paren
id|DIFF_XDL_SET
c_func
(paren
id|options
comma
id|IGNORE_WHITESPACE
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;-b&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--ignore-space-change&quot;
)paren
)paren
id|DIFF_XDL_SET
c_func
(paren
id|options
comma
id|IGNORE_WHITESPACE_CHANGE
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--ignore-space-at-eol&quot;
)paren
)paren
id|DIFF_XDL_SET
c_func
(paren
id|options
comma
id|IGNORE_WHITESPACE_AT_EOL
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--ignore-blank-lines&quot;
)paren
)paren
id|DIFF_XDL_SET
c_func
(paren
id|options
comma
id|IGNORE_BLANK_LINES
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--patience&quot;
)paren
)paren
id|options-&gt;xdl_opts
op_assign
id|DIFF_WITH_ALG
c_func
(paren
id|options
comma
id|PATIENCE_DIFF
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--histogram&quot;
)paren
)paren
id|options-&gt;xdl_opts
op_assign
id|DIFF_WITH_ALG
c_func
(paren
id|options
comma
id|HISTOGRAM_DIFF
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|argcount
op_assign
id|parse_long_opt
c_func
(paren
l_string|&quot;diff-algorithm&quot;
comma
id|av
comma
op_amp
id|optarg
)paren
)paren
)paren
(brace
r_int
id|value
op_assign
id|parse_algorithm_value
c_func
(paren
id|optarg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
OL
l_int|0
)paren
r_return
id|error
c_func
(paren
l_string|&quot;option diff-algorithm accepts &bslash;&quot;myers&bslash;&quot;, &quot;
l_string|&quot;&bslash;&quot;minimal&bslash;&quot;, &bslash;&quot;patience&bslash;&quot; and &bslash;&quot;histogram&bslash;&quot;&quot;
)paren
suffix:semicolon
multiline_comment|/* clear out previous settings */
id|DIFF_XDL_CLR
c_func
(paren
id|options
comma
id|NEED_MINIMAL
)paren
suffix:semicolon
id|options-&gt;xdl_opts
op_and_assign
op_complement
id|XDF_DIFF_ALGORITHM_MASK
suffix:semicolon
id|options-&gt;xdl_opts
op_or_assign
id|value
suffix:semicolon
r_return
id|argcount
suffix:semicolon
)brace
multiline_comment|/* flags options */
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--binary&quot;
)paren
)paren
(brace
id|enable_patch_output
c_func
(paren
op_amp
id|options-&gt;output_format
)paren
suffix:semicolon
id|DIFF_OPT_SET
c_func
(paren
id|options
comma
id|BINARY
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--full-index&quot;
)paren
)paren
id|DIFF_OPT_SET
c_func
(paren
id|options
comma
id|FULL_INDEX
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;-a&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--text&quot;
)paren
)paren
id|DIFF_OPT_SET
c_func
(paren
id|options
comma
id|TEXT
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;-R&quot;
)paren
)paren
id|DIFF_OPT_SET
c_func
(paren
id|options
comma
id|REVERSE_DIFF
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--find-copies-harder&quot;
)paren
)paren
id|DIFF_OPT_SET
c_func
(paren
id|options
comma
id|FIND_COPIES_HARDER
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--follow&quot;
)paren
)paren
id|DIFF_OPT_SET
c_func
(paren
id|options
comma
id|FOLLOW_RENAMES
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--no-follow&quot;
)paren
)paren
id|DIFF_OPT_CLR
c_func
(paren
id|options
comma
id|FOLLOW_RENAMES
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--color&quot;
)paren
)paren
id|options-&gt;use_color
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|arg
comma
l_string|&quot;--color=&quot;
)paren
)paren
(brace
r_int
id|value
op_assign
id|git_config_colorbool
c_func
(paren
l_int|NULL
comma
id|arg
op_plus
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
OL
l_int|0
)paren
r_return
id|error
c_func
(paren
l_string|&quot;option `color&squot; expects &bslash;&quot;always&bslash;&quot;, &bslash;&quot;auto&bslash;&quot;, or &bslash;&quot;never&bslash;&quot;&quot;
)paren
suffix:semicolon
id|options-&gt;use_color
op_assign
id|value
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--no-color&quot;
)paren
)paren
id|options-&gt;use_color
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--color-words&quot;
)paren
)paren
(brace
id|options-&gt;use_color
op_assign
l_int|1
suffix:semicolon
id|options-&gt;word_diff
op_assign
id|DIFF_WORDS_COLOR
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|arg
comma
l_string|&quot;--color-words=&quot;
)paren
)paren
(brace
id|options-&gt;use_color
op_assign
l_int|1
suffix:semicolon
id|options-&gt;word_diff
op_assign
id|DIFF_WORDS_COLOR
suffix:semicolon
id|options-&gt;word_regex
op_assign
id|arg
op_plus
l_int|14
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--word-diff&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|options-&gt;word_diff
op_eq
id|DIFF_WORDS_NONE
)paren
id|options-&gt;word_diff
op_assign
id|DIFF_WORDS_PLAIN
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|arg
comma
l_string|&quot;--word-diff=&quot;
)paren
)paren
(brace
r_const
r_char
op_star
id|type
op_assign
id|arg
op_plus
l_int|12
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|type
comma
l_string|&quot;plain&quot;
)paren
)paren
id|options-&gt;word_diff
op_assign
id|DIFF_WORDS_PLAIN
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|type
comma
l_string|&quot;color&quot;
)paren
)paren
(brace
id|options-&gt;use_color
op_assign
l_int|1
suffix:semicolon
id|options-&gt;word_diff
op_assign
id|DIFF_WORDS_COLOR
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|type
comma
l_string|&quot;porcelain&quot;
)paren
)paren
id|options-&gt;word_diff
op_assign
id|DIFF_WORDS_PORCELAIN
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|type
comma
l_string|&quot;none&quot;
)paren
)paren
id|options-&gt;word_diff
op_assign
id|DIFF_WORDS_NONE
suffix:semicolon
r_else
id|die
c_func
(paren
l_string|&quot;bad --word-diff argument: %s&quot;
comma
id|type
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|argcount
op_assign
id|parse_long_opt
c_func
(paren
l_string|&quot;word-diff-regex&quot;
comma
id|av
comma
op_amp
id|optarg
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|options-&gt;word_diff
op_eq
id|DIFF_WORDS_NONE
)paren
id|options-&gt;word_diff
op_assign
id|DIFF_WORDS_PLAIN
suffix:semicolon
id|options-&gt;word_regex
op_assign
id|optarg
suffix:semicolon
r_return
id|argcount
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--exit-code&quot;
)paren
)paren
id|DIFF_OPT_SET
c_func
(paren
id|options
comma
id|EXIT_WITH_STATUS
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--quiet&quot;
)paren
)paren
id|DIFF_OPT_SET
c_func
(paren
id|options
comma
id|QUICK
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--ext-diff&quot;
)paren
)paren
id|DIFF_OPT_SET
c_func
(paren
id|options
comma
id|ALLOW_EXTERNAL
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--no-ext-diff&quot;
)paren
)paren
id|DIFF_OPT_CLR
c_func
(paren
id|options
comma
id|ALLOW_EXTERNAL
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--textconv&quot;
)paren
)paren
id|DIFF_OPT_SET
c_func
(paren
id|options
comma
id|ALLOW_TEXTCONV
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--no-textconv&quot;
)paren
)paren
id|DIFF_OPT_CLR
c_func
(paren
id|options
comma
id|ALLOW_TEXTCONV
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--ignore-submodules&quot;
)paren
)paren
(brace
id|DIFF_OPT_SET
c_func
(paren
id|options
comma
id|OVERRIDE_SUBMODULE_CONFIG
)paren
suffix:semicolon
id|handle_ignore_submodules_arg
c_func
(paren
id|options
comma
l_string|&quot;all&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|arg
comma
l_string|&quot;--ignore-submodules=&quot;
)paren
)paren
(brace
id|DIFF_OPT_SET
c_func
(paren
id|options
comma
id|OVERRIDE_SUBMODULE_CONFIG
)paren
suffix:semicolon
id|handle_ignore_submodules_arg
c_func
(paren
id|options
comma
id|arg
op_plus
l_int|20
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--submodule&quot;
)paren
)paren
id|DIFF_OPT_SET
c_func
(paren
id|options
comma
id|SUBMODULE_LOG
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|arg
comma
l_string|&quot;--submodule=&quot;
)paren
)paren
r_return
id|parse_submodule_opt
c_func
(paren
id|options
comma
id|arg
op_plus
l_int|12
)paren
suffix:semicolon
multiline_comment|/* misc options */
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;-z&quot;
)paren
)paren
id|options-&gt;line_termination
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|argcount
op_assign
id|short_opt
c_func
(paren
l_char|&squot;l&squot;
comma
id|av
comma
op_amp
id|optarg
)paren
)paren
)paren
(brace
id|options-&gt;rename_limit
op_assign
id|strtoul
c_func
(paren
id|optarg
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_return
id|argcount
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|argcount
op_assign
id|short_opt
c_func
(paren
l_char|&squot;S&squot;
comma
id|av
comma
op_amp
id|optarg
)paren
)paren
)paren
(brace
id|options-&gt;pickaxe
op_assign
id|optarg
suffix:semicolon
id|options-&gt;pickaxe_opts
op_or_assign
id|DIFF_PICKAXE_KIND_S
suffix:semicolon
r_return
id|argcount
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|argcount
op_assign
id|short_opt
c_func
(paren
l_char|&squot;G&squot;
comma
id|av
comma
op_amp
id|optarg
)paren
)paren
)paren
(brace
id|options-&gt;pickaxe
op_assign
id|optarg
suffix:semicolon
id|options-&gt;pickaxe_opts
op_or_assign
id|DIFF_PICKAXE_KIND_G
suffix:semicolon
r_return
id|argcount
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--pickaxe-all&quot;
)paren
)paren
id|options-&gt;pickaxe_opts
op_or_assign
id|DIFF_PICKAXE_ALL
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--pickaxe-regex&quot;
)paren
)paren
id|options-&gt;pickaxe_opts
op_or_assign
id|DIFF_PICKAXE_REGEX
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|argcount
op_assign
id|short_opt
c_func
(paren
l_char|&squot;O&squot;
comma
id|av
comma
op_amp
id|optarg
)paren
)paren
)paren
(brace
id|options-&gt;orderfile
op_assign
id|optarg
suffix:semicolon
r_return
id|argcount
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|argcount
op_assign
id|parse_long_opt
c_func
(paren
l_string|&quot;diff-filter&quot;
comma
id|av
comma
op_amp
id|optarg
)paren
)paren
)paren
(brace
r_int
id|offending
op_assign
id|parse_diff_filter_opt
c_func
(paren
id|optarg
comma
id|options
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offending
)paren
id|die
c_func
(paren
l_string|&quot;unknown change class &squot;%c&squot; in --diff-filter=%s&quot;
comma
id|offending
comma
id|optarg
)paren
suffix:semicolon
r_return
id|argcount
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--abbrev&quot;
)paren
)paren
id|options-&gt;abbrev
op_assign
id|DEFAULT_ABBREV
suffix:semicolon
r_else
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|arg
comma
l_string|&quot;--abbrev=&quot;
)paren
)paren
(brace
id|options-&gt;abbrev
op_assign
id|strtoul
c_func
(paren
id|arg
op_plus
l_int|9
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|options-&gt;abbrev
OL
id|MINIMUM_ABBREV
)paren
id|options-&gt;abbrev
op_assign
id|MINIMUM_ABBREV
suffix:semicolon
r_else
r_if
c_cond
(paren
l_int|40
OL
id|options-&gt;abbrev
)paren
id|options-&gt;abbrev
op_assign
l_int|40
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|argcount
op_assign
id|parse_long_opt
c_func
(paren
l_string|&quot;src-prefix&quot;
comma
id|av
comma
op_amp
id|optarg
)paren
)paren
)paren
(brace
id|options-&gt;a_prefix
op_assign
id|optarg
suffix:semicolon
r_return
id|argcount
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|argcount
op_assign
id|parse_long_opt
c_func
(paren
l_string|&quot;dst-prefix&quot;
comma
id|av
comma
op_amp
id|optarg
)paren
)paren
)paren
(brace
id|options-&gt;b_prefix
op_assign
id|optarg
suffix:semicolon
r_return
id|argcount
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--no-prefix&quot;
)paren
)paren
id|options-&gt;a_prefix
op_assign
id|options-&gt;b_prefix
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|opt_arg
c_func
(paren
id|arg
comma
l_char|&squot;&bslash;0&squot;
comma
l_string|&quot;inter-hunk-context&quot;
comma
op_amp
id|options-&gt;interhunkcontext
)paren
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;-W&quot;
)paren
)paren
id|DIFF_OPT_SET
c_func
(paren
id|options
comma
id|FUNCCONTEXT
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--function-context&quot;
)paren
)paren
id|DIFF_OPT_SET
c_func
(paren
id|options
comma
id|FUNCCONTEXT
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--no-function-context&quot;
)paren
)paren
id|DIFF_OPT_CLR
c_func
(paren
id|options
comma
id|FUNCCONTEXT
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|argcount
op_assign
id|parse_long_opt
c_func
(paren
l_string|&quot;output&quot;
comma
id|av
comma
op_amp
id|optarg
)paren
)paren
)paren
(brace
id|options-&gt;file
op_assign
id|fopen
c_func
(paren
id|optarg
comma
l_string|&quot;w&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|options-&gt;file
)paren
id|die_errno
c_func
(paren
l_string|&quot;Could not open &squot;%s&squot;&quot;
comma
id|optarg
)paren
suffix:semicolon
id|options-&gt;close_file
op_assign
l_int|1
suffix:semicolon
r_return
id|argcount
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|parse_rename_score
r_int
id|parse_rename_score
c_func
(paren
r_const
r_char
op_star
op_star
id|cp_p
)paren
(brace
r_int
r_int
id|num
comma
id|scale
suffix:semicolon
r_int
id|ch
comma
id|dot
suffix:semicolon
r_const
r_char
op_star
id|cp
op_assign
op_star
id|cp_p
suffix:semicolon
id|num
op_assign
l_int|0
suffix:semicolon
id|scale
op_assign
l_int|1
suffix:semicolon
id|dot
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|ch
op_assign
op_star
id|cp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dot
op_logical_and
id|ch
op_eq
l_char|&squot;.&squot;
)paren
(brace
id|scale
op_assign
l_int|1
suffix:semicolon
id|dot
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;%&squot;
)paren
(brace
id|scale
op_assign
id|dot
ques
c_cond
id|scale
op_star
l_int|100
suffix:colon
l_int|100
suffix:semicolon
id|cp
op_increment
suffix:semicolon
multiline_comment|/* % is always at the end */
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ch
op_ge
l_char|&squot;0&squot;
op_logical_and
id|ch
op_le
l_char|&squot;9&squot;
)paren
(brace
r_if
c_cond
(paren
id|scale
OL
l_int|100000
)paren
(brace
id|scale
op_mul_assign
l_int|10
suffix:semicolon
id|num
op_assign
(paren
id|num
op_star
l_int|10
)paren
op_plus
(paren
id|ch
op_minus
l_char|&squot;0&squot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_break
suffix:semicolon
)brace
id|cp
op_increment
suffix:semicolon
)brace
op_star
id|cp_p
op_assign
id|cp
suffix:semicolon
multiline_comment|/* user says num divided by scale and we say internally that&n;&t; * is MAX_SCORE * num / scale.&n;&t; */
r_return
(paren
r_int
)paren
(paren
(paren
id|num
op_ge
id|scale
)paren
ques
c_cond
id|MAX_SCORE
suffix:colon
(paren
id|MAX_SCORE
op_star
id|num
op_div
id|scale
)paren
)paren
suffix:semicolon
)brace
DECL|function|diff_scoreopt_parse
r_static
r_int
id|diff_scoreopt_parse
c_func
(paren
r_const
r_char
op_star
id|opt
)paren
(brace
r_int
id|opt1
comma
id|opt2
comma
id|cmd
suffix:semicolon
r_if
c_cond
(paren
op_star
id|opt
op_increment
op_ne
l_char|&squot;-&squot;
)paren
r_return
l_int|1
suffix:semicolon
id|cmd
op_assign
op_star
id|opt
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot;-&squot;
)paren
(brace
multiline_comment|/* convert the long-form arguments into short-form versions */
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|opt
comma
l_string|&quot;break-rewrites&quot;
)paren
)paren
(brace
id|opt
op_add_assign
id|strlen
c_func
(paren
l_string|&quot;break-rewrites&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|opt
op_eq
l_int|0
op_logical_or
op_star
id|opt
op_increment
op_eq
l_char|&squot;=&squot;
)paren
id|cmd
op_assign
l_char|&squot;B&squot;
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|opt
comma
l_string|&quot;find-copies&quot;
)paren
)paren
(brace
id|opt
op_add_assign
id|strlen
c_func
(paren
l_string|&quot;find-copies&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|opt
op_eq
l_int|0
op_logical_or
op_star
id|opt
op_increment
op_eq
l_char|&squot;=&squot;
)paren
id|cmd
op_assign
l_char|&squot;C&squot;
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|opt
comma
l_string|&quot;find-renames&quot;
)paren
)paren
(brace
id|opt
op_add_assign
id|strlen
c_func
(paren
l_string|&quot;find-renames&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|opt
op_eq
l_int|0
op_logical_or
op_star
id|opt
op_increment
op_eq
l_char|&squot;=&squot;
)paren
id|cmd
op_assign
l_char|&squot;M&squot;
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|cmd
op_ne
l_char|&squot;M&squot;
op_logical_and
id|cmd
op_ne
l_char|&squot;C&squot;
op_logical_and
id|cmd
op_ne
l_char|&squot;B&squot;
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* that is not a -M, -C, or -B option */
id|opt1
op_assign
id|parse_rename_score
c_func
(paren
op_amp
id|opt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_ne
l_char|&squot;B&squot;
)paren
id|opt2
op_assign
l_int|0
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
op_star
id|opt
op_eq
l_int|0
)paren
id|opt2
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
op_star
id|opt
op_ne
l_char|&squot;/&squot;
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* we expect -B80/99 or -B80 */
r_else
(brace
id|opt
op_increment
suffix:semicolon
id|opt2
op_assign
id|parse_rename_score
c_func
(paren
op_amp
id|opt
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_star
id|opt
op_ne
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_return
id|opt1
op_or
(paren
id|opt2
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
DECL|variable|diff_queued_diff
r_struct
id|diff_queue_struct
id|diff_queued_diff
suffix:semicolon
DECL|function|diff_q
r_void
id|diff_q
c_func
(paren
r_struct
id|diff_queue_struct
op_star
id|queue
comma
r_struct
id|diff_filepair
op_star
id|dp
)paren
(brace
id|ALLOC_GROW
c_func
(paren
id|queue-&gt;queue
comma
id|queue-&gt;nr
op_plus
l_int|1
comma
id|queue-&gt;alloc
)paren
suffix:semicolon
id|queue-&gt;queue
(braket
id|queue-&gt;nr
op_increment
)braket
op_assign
id|dp
suffix:semicolon
)brace
DECL|function|diff_queue
r_struct
id|diff_filepair
op_star
id|diff_queue
c_func
(paren
r_struct
id|diff_queue_struct
op_star
id|queue
comma
r_struct
id|diff_filespec
op_star
id|one
comma
r_struct
id|diff_filespec
op_star
id|two
)paren
(brace
r_struct
id|diff_filepair
op_star
id|dp
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|dp
)paren
)paren
suffix:semicolon
id|dp-&gt;one
op_assign
id|one
suffix:semicolon
id|dp-&gt;two
op_assign
id|two
suffix:semicolon
r_if
c_cond
(paren
id|queue
)paren
id|diff_q
c_func
(paren
id|queue
comma
id|dp
)paren
suffix:semicolon
r_return
id|dp
suffix:semicolon
)brace
DECL|function|diff_free_filepair
r_void
id|diff_free_filepair
c_func
(paren
r_struct
id|diff_filepair
op_star
id|p
)paren
(brace
id|free_filespec
c_func
(paren
id|p-&gt;one
)paren
suffix:semicolon
id|free_filespec
c_func
(paren
id|p-&gt;two
)paren
suffix:semicolon
id|free
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/* This is different from find_unique_abbrev() in that&n; * it stuffs the result with dots for alignment.&n; */
DECL|function|diff_unique_abbrev
r_const
r_char
op_star
id|diff_unique_abbrev
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
id|len
)paren
(brace
r_int
id|abblen
suffix:semicolon
r_const
r_char
op_star
id|abbrev
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
l_int|40
)paren
r_return
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
suffix:semicolon
id|abbrev
op_assign
id|find_unique_abbrev
c_func
(paren
id|sha1
comma
id|len
)paren
suffix:semicolon
id|abblen
op_assign
id|strlen
c_func
(paren
id|abbrev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|abblen
OL
l_int|37
)paren
(brace
r_static
r_char
id|hex
(braket
l_int|41
)braket
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
id|abblen
op_logical_and
id|abblen
op_le
id|len
op_plus
l_int|2
)paren
id|sprintf
c_func
(paren
id|hex
comma
l_string|&quot;%s%.*s&quot;
comma
id|abbrev
comma
id|len
op_plus
l_int|3
op_minus
id|abblen
comma
l_string|&quot;..&quot;
)paren
suffix:semicolon
r_else
id|sprintf
c_func
(paren
id|hex
comma
l_string|&quot;%s...&quot;
comma
id|abbrev
)paren
suffix:semicolon
r_return
id|hex
suffix:semicolon
)brace
r_return
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
suffix:semicolon
)brace
DECL|function|diff_flush_raw
r_static
r_void
id|diff_flush_raw
c_func
(paren
r_struct
id|diff_filepair
op_star
id|p
comma
r_struct
id|diff_options
op_star
id|opt
)paren
(brace
r_int
id|line_termination
op_assign
id|opt-&gt;line_termination
suffix:semicolon
r_int
id|inter_name_termination
op_assign
id|line_termination
ques
c_cond
l_char|&squot;&bslash;t&squot;
suffix:colon
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|fprintf
c_func
(paren
id|opt-&gt;file
comma
l_string|&quot;%s&quot;
comma
id|diff_line_prefix
c_func
(paren
id|opt
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|opt-&gt;output_format
op_amp
id|DIFF_FORMAT_NAME_STATUS
)paren
)paren
(brace
id|fprintf
c_func
(paren
id|opt-&gt;file
comma
l_string|&quot;:%06o %06o %s &quot;
comma
id|p-&gt;one-&gt;mode
comma
id|p-&gt;two-&gt;mode
comma
id|diff_unique_abbrev
c_func
(paren
id|p-&gt;one-&gt;sha1
comma
id|opt-&gt;abbrev
)paren
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|opt-&gt;file
comma
l_string|&quot;%s &quot;
comma
id|diff_unique_abbrev
c_func
(paren
id|p-&gt;two-&gt;sha1
comma
id|opt-&gt;abbrev
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;score
)paren
(brace
id|fprintf
c_func
(paren
id|opt-&gt;file
comma
l_string|&quot;%c%03d%c&quot;
comma
id|p-&gt;status
comma
id|similarity_index
c_func
(paren
id|p
)paren
comma
id|inter_name_termination
)paren
suffix:semicolon
)brace
r_else
(brace
id|fprintf
c_func
(paren
id|opt-&gt;file
comma
l_string|&quot;%c%c&quot;
comma
id|p-&gt;status
comma
id|inter_name_termination
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;status
op_eq
id|DIFF_STATUS_COPIED
op_logical_or
id|p-&gt;status
op_eq
id|DIFF_STATUS_RENAMED
)paren
(brace
r_const
r_char
op_star
id|name_a
comma
op_star
id|name_b
suffix:semicolon
id|name_a
op_assign
id|p-&gt;one-&gt;path
suffix:semicolon
id|name_b
op_assign
id|p-&gt;two-&gt;path
suffix:semicolon
id|strip_prefix
c_func
(paren
id|opt-&gt;prefix_length
comma
op_amp
id|name_a
comma
op_amp
id|name_b
)paren
suffix:semicolon
id|write_name_quoted
c_func
(paren
id|name_a
comma
id|opt-&gt;file
comma
id|inter_name_termination
)paren
suffix:semicolon
id|write_name_quoted
c_func
(paren
id|name_b
comma
id|opt-&gt;file
comma
id|line_termination
)paren
suffix:semicolon
)brace
r_else
(brace
r_const
r_char
op_star
id|name_a
comma
op_star
id|name_b
suffix:semicolon
id|name_a
op_assign
id|p-&gt;one-&gt;mode
ques
c_cond
id|p-&gt;one-&gt;path
suffix:colon
id|p-&gt;two-&gt;path
suffix:semicolon
id|name_b
op_assign
l_int|NULL
suffix:semicolon
id|strip_prefix
c_func
(paren
id|opt-&gt;prefix_length
comma
op_amp
id|name_a
comma
op_amp
id|name_b
)paren
suffix:semicolon
id|write_name_quoted
c_func
(paren
id|name_a
comma
id|opt-&gt;file
comma
id|line_termination
)paren
suffix:semicolon
)brace
)brace
DECL|function|diff_unmodified_pair
r_int
id|diff_unmodified_pair
c_func
(paren
r_struct
id|diff_filepair
op_star
id|p
)paren
(brace
multiline_comment|/* This function is written stricter than necessary to support&n;&t; * the currently implemented transformers, but the idea is to&n;&t; * let transformers to produce diff_filepairs any way they want,&n;&t; * and filter and clean them up here before producing the output.&n;&t; */
r_struct
id|diff_filespec
op_star
id|one
op_assign
id|p-&gt;one
comma
op_star
id|two
op_assign
id|p-&gt;two
suffix:semicolon
r_if
c_cond
(paren
id|DIFF_PAIR_UNMERGED
c_func
(paren
id|p
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* unmerged is interesting */
multiline_comment|/* deletion, addition, mode or type change&n;&t; * and rename are all interesting.&n;&t; */
r_if
c_cond
(paren
id|DIFF_FILE_VALID
c_func
(paren
id|one
)paren
op_ne
id|DIFF_FILE_VALID
c_func
(paren
id|two
)paren
op_logical_or
id|DIFF_PAIR_MODE_CHANGED
c_func
(paren
id|p
)paren
op_logical_or
id|strcmp
c_func
(paren
id|one-&gt;path
comma
id|two-&gt;path
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* both are valid and point at the same path.  that is, we are&n;&t; * dealing with a change.&n;&t; */
r_if
c_cond
(paren
id|one-&gt;sha1_valid
op_logical_and
id|two-&gt;sha1_valid
op_logical_and
op_logical_neg
id|hashcmp
c_func
(paren
id|one-&gt;sha1
comma
id|two-&gt;sha1
)paren
op_logical_and
op_logical_neg
id|one-&gt;dirty_submodule
op_logical_and
op_logical_neg
id|two-&gt;dirty_submodule
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* no change */
r_if
c_cond
(paren
op_logical_neg
id|one-&gt;sha1_valid
op_logical_and
op_logical_neg
id|two-&gt;sha1_valid
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* both look at the same file on the filesystem. */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|diff_flush_patch
r_static
r_void
id|diff_flush_patch
c_func
(paren
r_struct
id|diff_filepair
op_star
id|p
comma
r_struct
id|diff_options
op_star
id|o
)paren
(brace
r_if
c_cond
(paren
id|diff_unmodified_pair
c_func
(paren
id|p
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
(paren
id|DIFF_FILE_VALID
c_func
(paren
id|p-&gt;one
)paren
op_logical_and
id|S_ISDIR
c_func
(paren
id|p-&gt;one-&gt;mode
)paren
)paren
op_logical_or
(paren
id|DIFF_FILE_VALID
c_func
(paren
id|p-&gt;two
)paren
op_logical_and
id|S_ISDIR
c_func
(paren
id|p-&gt;two-&gt;mode
)paren
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* no tree diffs in patch format */
id|run_diff
c_func
(paren
id|p
comma
id|o
)paren
suffix:semicolon
)brace
DECL|function|diff_flush_stat
r_static
r_void
id|diff_flush_stat
c_func
(paren
r_struct
id|diff_filepair
op_star
id|p
comma
r_struct
id|diff_options
op_star
id|o
comma
r_struct
id|diffstat_t
op_star
id|diffstat
)paren
(brace
r_if
c_cond
(paren
id|diff_unmodified_pair
c_func
(paren
id|p
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
(paren
id|DIFF_FILE_VALID
c_func
(paren
id|p-&gt;one
)paren
op_logical_and
id|S_ISDIR
c_func
(paren
id|p-&gt;one-&gt;mode
)paren
)paren
op_logical_or
(paren
id|DIFF_FILE_VALID
c_func
(paren
id|p-&gt;two
)paren
op_logical_and
id|S_ISDIR
c_func
(paren
id|p-&gt;two-&gt;mode
)paren
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* no useful stat for tree diffs */
id|run_diffstat
c_func
(paren
id|p
comma
id|o
comma
id|diffstat
)paren
suffix:semicolon
)brace
DECL|function|diff_flush_checkdiff
r_static
r_void
id|diff_flush_checkdiff
c_func
(paren
r_struct
id|diff_filepair
op_star
id|p
comma
r_struct
id|diff_options
op_star
id|o
)paren
(brace
r_if
c_cond
(paren
id|diff_unmodified_pair
c_func
(paren
id|p
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
(paren
id|DIFF_FILE_VALID
c_func
(paren
id|p-&gt;one
)paren
op_logical_and
id|S_ISDIR
c_func
(paren
id|p-&gt;one-&gt;mode
)paren
)paren
op_logical_or
(paren
id|DIFF_FILE_VALID
c_func
(paren
id|p-&gt;two
)paren
op_logical_and
id|S_ISDIR
c_func
(paren
id|p-&gt;two-&gt;mode
)paren
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* nothing to check in tree diffs */
id|run_checkdiff
c_func
(paren
id|p
comma
id|o
)paren
suffix:semicolon
)brace
DECL|function|diff_queue_is_empty
r_int
id|diff_queue_is_empty
c_func
(paren
r_void
)paren
(brace
r_struct
id|diff_queue_struct
op_star
id|q
op_assign
op_amp
id|diff_queued_diff
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|q-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|diff_unmodified_pair
c_func
(paren
id|q-&gt;queue
(braket
id|i
)braket
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#if DIFF_DEBUG
DECL|function|diff_debug_filespec
r_void
id|diff_debug_filespec
c_func
(paren
r_struct
id|diff_filespec
op_star
id|s
comma
r_int
id|x
comma
r_const
r_char
op_star
id|one
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;queue[%d] %s (%s) %s %06o %s&bslash;n&quot;
comma
id|x
comma
id|one
ques
c_cond
id|one
suffix:colon
l_string|&quot;&quot;
comma
id|s-&gt;path
comma
id|DIFF_FILE_VALID
c_func
(paren
id|s
)paren
ques
c_cond
l_string|&quot;valid&quot;
suffix:colon
l_string|&quot;invalid&quot;
comma
id|s-&gt;mode
comma
id|s-&gt;sha1_valid
ques
c_cond
id|sha1_to_hex
c_func
(paren
id|s-&gt;sha1
)paren
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;queue[%d] %s size %lu&bslash;n&quot;
comma
id|x
comma
id|one
ques
c_cond
id|one
suffix:colon
l_string|&quot;&quot;
comma
id|s-&gt;size
)paren
suffix:semicolon
)brace
DECL|function|diff_debug_filepair
r_void
id|diff_debug_filepair
c_func
(paren
r_const
r_struct
id|diff_filepair
op_star
id|p
comma
r_int
id|i
)paren
(brace
id|diff_debug_filespec
c_func
(paren
id|p-&gt;one
comma
id|i
comma
l_string|&quot;one&quot;
)paren
suffix:semicolon
id|diff_debug_filespec
c_func
(paren
id|p-&gt;two
comma
id|i
comma
l_string|&quot;two&quot;
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;score %d, status %c rename_used %d broken %d&bslash;n&quot;
comma
id|p-&gt;score
comma
id|p-&gt;status
ques
c_cond
id|p-&gt;status
suffix:colon
l_char|&squot;?&squot;
comma
id|p-&gt;one-&gt;rename_used
comma
id|p-&gt;broken_pair
)paren
suffix:semicolon
)brace
DECL|function|diff_debug_queue
r_void
id|diff_debug_queue
c_func
(paren
r_const
r_char
op_star
id|msg
comma
r_struct
id|diff_queue_struct
op_star
id|q
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|msg
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|msg
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;q-&gt;nr = %d&bslash;n&quot;
comma
id|q-&gt;nr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|q-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|diff_filepair
op_star
id|p
op_assign
id|q-&gt;queue
(braket
id|i
)braket
suffix:semicolon
id|diff_debug_filepair
c_func
(paren
id|p
comma
id|i
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
DECL|function|diff_resolve_rename_copy
r_static
r_void
id|diff_resolve_rename_copy
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|diff_filepair
op_star
id|p
suffix:semicolon
r_struct
id|diff_queue_struct
op_star
id|q
op_assign
op_amp
id|diff_queued_diff
suffix:semicolon
id|diff_debug_queue
c_func
(paren
l_string|&quot;resolve-rename-copy&quot;
comma
id|q
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|q-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
id|p
op_assign
id|q-&gt;queue
(braket
id|i
)braket
suffix:semicolon
id|p-&gt;status
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* undecided */
r_if
c_cond
(paren
id|DIFF_PAIR_UNMERGED
c_func
(paren
id|p
)paren
)paren
id|p-&gt;status
op_assign
id|DIFF_STATUS_UNMERGED
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|DIFF_FILE_VALID
c_func
(paren
id|p-&gt;one
)paren
)paren
id|p-&gt;status
op_assign
id|DIFF_STATUS_ADDED
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|DIFF_FILE_VALID
c_func
(paren
id|p-&gt;two
)paren
)paren
id|p-&gt;status
op_assign
id|DIFF_STATUS_DELETED
suffix:semicolon
r_else
r_if
c_cond
(paren
id|DIFF_PAIR_TYPE_CHANGED
c_func
(paren
id|p
)paren
)paren
id|p-&gt;status
op_assign
id|DIFF_STATUS_TYPE_CHANGED
suffix:semicolon
multiline_comment|/* from this point on, we are dealing with a pair&n;&t;&t; * whose both sides are valid and of the same type, i.e.&n;&t;&t; * either in-place edit or rename/copy edit.&n;&t;&t; */
r_else
r_if
c_cond
(paren
id|DIFF_PAIR_RENAME
c_func
(paren
id|p
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * A rename might have re-connected a broken&n;&t;&t;&t; * pair up, causing the pathnames to be the&n;&t;&t;&t; * same again. If so, that&squot;s not a rename at&n;&t;&t;&t; * all, just a modification..&n;&t;&t;&t; *&n;&t;&t;&t; * Otherwise, see if this source was used for&n;&t;&t;&t; * multiple renames, in which case we decrement&n;&t;&t;&t; * the count, and call it a copy.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|p-&gt;one-&gt;path
comma
id|p-&gt;two-&gt;path
)paren
)paren
id|p-&gt;status
op_assign
id|DIFF_STATUS_MODIFIED
suffix:semicolon
r_else
r_if
c_cond
(paren
op_decrement
id|p-&gt;one-&gt;rename_used
OG
l_int|0
)paren
id|p-&gt;status
op_assign
id|DIFF_STATUS_COPIED
suffix:semicolon
r_else
id|p-&gt;status
op_assign
id|DIFF_STATUS_RENAMED
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|hashcmp
c_func
(paren
id|p-&gt;one-&gt;sha1
comma
id|p-&gt;two-&gt;sha1
)paren
op_logical_or
id|p-&gt;one-&gt;mode
op_ne
id|p-&gt;two-&gt;mode
op_logical_or
id|p-&gt;one-&gt;dirty_submodule
op_logical_or
id|p-&gt;two-&gt;dirty_submodule
op_logical_or
id|is_null_sha1
c_func
(paren
id|p-&gt;one-&gt;sha1
)paren
)paren
id|p-&gt;status
op_assign
id|DIFF_STATUS_MODIFIED
suffix:semicolon
r_else
(brace
multiline_comment|/* This is a &quot;no-change&quot; entry and should not&n;&t;&t;&t; * happen anymore, but prepare for broken callers.&n;&t;&t;&t; */
id|error
c_func
(paren
l_string|&quot;feeding unmodified %s to diffcore&quot;
comma
id|p-&gt;one-&gt;path
)paren
suffix:semicolon
id|p-&gt;status
op_assign
id|DIFF_STATUS_UNKNOWN
suffix:semicolon
)brace
)brace
id|diff_debug_queue
c_func
(paren
l_string|&quot;resolve-rename-copy done&quot;
comma
id|q
)paren
suffix:semicolon
)brace
DECL|function|check_pair_status
r_static
r_int
id|check_pair_status
c_func
(paren
r_struct
id|diff_filepair
op_star
id|p
)paren
(brace
r_switch
c_cond
(paren
id|p-&gt;status
)paren
(brace
r_case
id|DIFF_STATUS_UNKNOWN
suffix:colon
r_return
l_int|0
suffix:semicolon
r_case
l_int|0
suffix:colon
id|die
c_func
(paren
l_string|&quot;internal error in diff-resolve-rename-copy&quot;
)paren
suffix:semicolon
r_default
suffix:colon
r_return
l_int|1
suffix:semicolon
)brace
)brace
DECL|function|flush_one_pair
r_static
r_void
id|flush_one_pair
c_func
(paren
r_struct
id|diff_filepair
op_star
id|p
comma
r_struct
id|diff_options
op_star
id|opt
)paren
(brace
r_int
id|fmt
op_assign
id|opt-&gt;output_format
suffix:semicolon
r_if
c_cond
(paren
id|fmt
op_amp
id|DIFF_FORMAT_CHECKDIFF
)paren
id|diff_flush_checkdiff
c_func
(paren
id|p
comma
id|opt
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|fmt
op_amp
(paren
id|DIFF_FORMAT_RAW
op_or
id|DIFF_FORMAT_NAME_STATUS
)paren
)paren
id|diff_flush_raw
c_func
(paren
id|p
comma
id|opt
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|fmt
op_amp
id|DIFF_FORMAT_NAME
)paren
(brace
r_const
r_char
op_star
id|name_a
comma
op_star
id|name_b
suffix:semicolon
id|name_a
op_assign
id|p-&gt;two-&gt;path
suffix:semicolon
id|name_b
op_assign
l_int|NULL
suffix:semicolon
id|strip_prefix
c_func
(paren
id|opt-&gt;prefix_length
comma
op_amp
id|name_a
comma
op_amp
id|name_b
)paren
suffix:semicolon
id|write_name_quoted
c_func
(paren
id|name_a
comma
id|opt-&gt;file
comma
id|opt-&gt;line_termination
)paren
suffix:semicolon
)brace
)brace
DECL|function|show_file_mode_name
r_static
r_void
id|show_file_mode_name
c_func
(paren
id|FILE
op_star
id|file
comma
r_const
r_char
op_star
id|newdelete
comma
r_struct
id|diff_filespec
op_star
id|fs
)paren
(brace
r_if
c_cond
(paren
id|fs-&gt;mode
)paren
id|fprintf
c_func
(paren
id|file
comma
l_string|&quot; %s mode %06o &quot;
comma
id|newdelete
comma
id|fs-&gt;mode
)paren
suffix:semicolon
r_else
id|fprintf
c_func
(paren
id|file
comma
l_string|&quot; %s &quot;
comma
id|newdelete
)paren
suffix:semicolon
id|write_name_quoted
c_func
(paren
id|fs-&gt;path
comma
id|file
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
DECL|function|show_mode_change
r_static
r_void
id|show_mode_change
c_func
(paren
id|FILE
op_star
id|file
comma
r_struct
id|diff_filepair
op_star
id|p
comma
r_int
id|show_name
comma
r_const
r_char
op_star
id|line_prefix
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;one-&gt;mode
op_logical_and
id|p-&gt;two-&gt;mode
op_logical_and
id|p-&gt;one-&gt;mode
op_ne
id|p-&gt;two-&gt;mode
)paren
(brace
id|fprintf
c_func
(paren
id|file
comma
l_string|&quot;%s mode change %06o =&gt; %06o%c&quot;
comma
id|line_prefix
comma
id|p-&gt;one-&gt;mode
comma
id|p-&gt;two-&gt;mode
comma
id|show_name
ques
c_cond
l_char|&squot; &squot;
suffix:colon
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|show_name
)paren
(brace
id|write_name_quoted
c_func
(paren
id|p-&gt;two-&gt;path
comma
id|file
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|show_rename_copy
r_static
r_void
id|show_rename_copy
c_func
(paren
id|FILE
op_star
id|file
comma
r_const
r_char
op_star
id|renamecopy
comma
r_struct
id|diff_filepair
op_star
id|p
comma
r_const
r_char
op_star
id|line_prefix
)paren
(brace
r_char
op_star
id|names
op_assign
id|pprint_rename
c_func
(paren
id|p-&gt;one-&gt;path
comma
id|p-&gt;two-&gt;path
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|file
comma
l_string|&quot; %s %s (%d%%)&bslash;n&quot;
comma
id|renamecopy
comma
id|names
comma
id|similarity_index
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
id|free
c_func
(paren
id|names
)paren
suffix:semicolon
id|show_mode_change
c_func
(paren
id|file
comma
id|p
comma
l_int|0
comma
id|line_prefix
)paren
suffix:semicolon
)brace
DECL|function|diff_summary
r_static
r_void
id|diff_summary
c_func
(paren
r_struct
id|diff_options
op_star
id|opt
comma
r_struct
id|diff_filepair
op_star
id|p
)paren
(brace
id|FILE
op_star
id|file
op_assign
id|opt-&gt;file
suffix:semicolon
r_const
r_char
op_star
id|line_prefix
op_assign
id|diff_line_prefix
c_func
(paren
id|opt
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|p-&gt;status
)paren
(brace
r_case
id|DIFF_STATUS_DELETED
suffix:colon
id|fputs
c_func
(paren
id|line_prefix
comma
id|file
)paren
suffix:semicolon
id|show_file_mode_name
c_func
(paren
id|file
comma
l_string|&quot;delete&quot;
comma
id|p-&gt;one
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DIFF_STATUS_ADDED
suffix:colon
id|fputs
c_func
(paren
id|line_prefix
comma
id|file
)paren
suffix:semicolon
id|show_file_mode_name
c_func
(paren
id|file
comma
l_string|&quot;create&quot;
comma
id|p-&gt;two
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DIFF_STATUS_COPIED
suffix:colon
id|fputs
c_func
(paren
id|line_prefix
comma
id|file
)paren
suffix:semicolon
id|show_rename_copy
c_func
(paren
id|file
comma
l_string|&quot;copy&quot;
comma
id|p
comma
id|line_prefix
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DIFF_STATUS_RENAMED
suffix:colon
id|fputs
c_func
(paren
id|line_prefix
comma
id|file
)paren
suffix:semicolon
id|show_rename_copy
c_func
(paren
id|file
comma
l_string|&quot;rename&quot;
comma
id|p
comma
id|line_prefix
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|p-&gt;score
)paren
(brace
id|fprintf
c_func
(paren
id|file
comma
l_string|&quot;%s rewrite &quot;
comma
id|line_prefix
)paren
suffix:semicolon
id|write_name_quoted
c_func
(paren
id|p-&gt;two-&gt;path
comma
id|file
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|file
comma
l_string|&quot;(%d%%)&bslash;n&quot;
comma
id|similarity_index
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
)brace
id|show_mode_change
c_func
(paren
id|file
comma
id|p
comma
op_logical_neg
id|p-&gt;score
comma
id|line_prefix
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|struct|patch_id_t
r_struct
id|patch_id_t
(brace
DECL|member|ctx
id|git_SHA_CTX
op_star
id|ctx
suffix:semicolon
DECL|member|patchlen
r_int
id|patchlen
suffix:semicolon
)brace
suffix:semicolon
DECL|function|remove_space
r_static
r_int
id|remove_space
c_func
(paren
r_char
op_star
id|line
comma
r_int
id|len
)paren
(brace
r_int
id|i
suffix:semicolon
r_char
op_star
id|dst
op_assign
id|line
suffix:semicolon
r_int
r_char
id|c
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|isspace
c_func
(paren
(paren
id|c
op_assign
id|line
(braket
id|i
)braket
)paren
)paren
)paren
op_star
id|dst
op_increment
op_assign
id|c
suffix:semicolon
r_return
id|dst
id|line
suffix:semicolon
)brace
DECL|function|patch_id_consume
r_static
r_void
id|patch_id_consume
c_func
(paren
r_void
op_star
id|priv
comma
r_char
op_star
id|line
comma
r_int
r_int
id|len
)paren
(brace
r_struct
id|patch_id_t
op_star
id|data
op_assign
id|priv
suffix:semicolon
r_int
id|new_len
suffix:semicolon
multiline_comment|/* Ignore line numbers when computing the SHA1 of the patch */
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|line
comma
l_string|&quot;@@ -&quot;
)paren
)paren
r_return
suffix:semicolon
id|new_len
op_assign
id|remove_space
c_func
(paren
id|line
comma
id|len
)paren
suffix:semicolon
id|git_SHA1_Update
c_func
(paren
id|data-&gt;ctx
comma
id|line
comma
id|new_len
)paren
suffix:semicolon
id|data-&gt;patchlen
op_add_assign
id|new_len
suffix:semicolon
)brace
multiline_comment|/* returns 0 upon success, and writes result into sha1 */
DECL|function|diff_get_patch_id
r_static
r_int
id|diff_get_patch_id
c_func
(paren
r_struct
id|diff_options
op_star
id|options
comma
r_int
r_char
op_star
id|sha1
)paren
(brace
r_struct
id|diff_queue_struct
op_star
id|q
op_assign
op_amp
id|diff_queued_diff
suffix:semicolon
r_int
id|i
suffix:semicolon
id|git_SHA_CTX
id|ctx
suffix:semicolon
r_struct
id|patch_id_t
id|data
suffix:semicolon
r_char
id|buffer
(braket
id|PATH_MAX
op_star
l_int|4
op_plus
l_int|20
)braket
suffix:semicolon
id|git_SHA1_Init
c_func
(paren
op_amp
id|ctx
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|data
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|patch_id_t
)paren
)paren
suffix:semicolon
id|data.ctx
op_assign
op_amp
id|ctx
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|q-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
id|xpparam_t
id|xpp
suffix:semicolon
id|xdemitconf_t
id|xecfg
suffix:semicolon
id|mmfile_t
id|mf1
comma
id|mf2
suffix:semicolon
r_struct
id|diff_filepair
op_star
id|p
op_assign
id|q-&gt;queue
(braket
id|i
)braket
suffix:semicolon
r_int
id|len1
comma
id|len2
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|xpp
comma
l_int|0
comma
r_sizeof
(paren
id|xpp
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|xecfg
comma
l_int|0
comma
r_sizeof
(paren
id|xecfg
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;status
op_eq
l_int|0
)paren
r_return
id|error
c_func
(paren
l_string|&quot;internal diff status error&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;status
op_eq
id|DIFF_STATUS_UNKNOWN
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|diff_unmodified_pair
c_func
(paren
id|p
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|DIFF_FILE_VALID
c_func
(paren
id|p-&gt;one
)paren
op_logical_and
id|S_ISDIR
c_func
(paren
id|p-&gt;one-&gt;mode
)paren
)paren
op_logical_or
(paren
id|DIFF_FILE_VALID
c_func
(paren
id|p-&gt;two
)paren
op_logical_and
id|S_ISDIR
c_func
(paren
id|p-&gt;two-&gt;mode
)paren
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|DIFF_PAIR_UNMERGED
c_func
(paren
id|p
)paren
)paren
r_continue
suffix:semicolon
id|diff_fill_sha1_info
c_func
(paren
id|p-&gt;one
)paren
suffix:semicolon
id|diff_fill_sha1_info
c_func
(paren
id|p-&gt;two
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fill_mmfile
c_func
(paren
op_amp
id|mf1
comma
id|p-&gt;one
)paren
OL
l_int|0
op_logical_or
id|fill_mmfile
c_func
(paren
op_amp
id|mf2
comma
id|p-&gt;two
)paren
OL
l_int|0
)paren
r_return
id|error
c_func
(paren
l_string|&quot;unable to read files to diff&quot;
)paren
suffix:semicolon
id|len1
op_assign
id|remove_space
c_func
(paren
id|p-&gt;one-&gt;path
comma
id|strlen
c_func
(paren
id|p-&gt;one-&gt;path
)paren
)paren
suffix:semicolon
id|len2
op_assign
id|remove_space
c_func
(paren
id|p-&gt;two-&gt;path
comma
id|strlen
c_func
(paren
id|p-&gt;two-&gt;path
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;one-&gt;mode
op_eq
l_int|0
)paren
id|len1
op_assign
id|snprintf
c_func
(paren
id|buffer
comma
r_sizeof
(paren
id|buffer
)paren
comma
l_string|&quot;diff--gita/%.*sb/%.*s&quot;
l_string|&quot;newfilemode%06o&quot;
l_string|&quot;---/dev/null&quot;
l_string|&quot;+++b/%.*s&quot;
comma
id|len1
comma
id|p-&gt;one-&gt;path
comma
id|len2
comma
id|p-&gt;two-&gt;path
comma
id|p-&gt;two-&gt;mode
comma
id|len2
comma
id|p-&gt;two-&gt;path
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|p-&gt;two-&gt;mode
op_eq
l_int|0
)paren
id|len1
op_assign
id|snprintf
c_func
(paren
id|buffer
comma
r_sizeof
(paren
id|buffer
)paren
comma
l_string|&quot;diff--gita/%.*sb/%.*s&quot;
l_string|&quot;deletedfilemode%06o&quot;
l_string|&quot;---a/%.*s&quot;
l_string|&quot;+++/dev/null&quot;
comma
id|len1
comma
id|p-&gt;one-&gt;path
comma
id|len2
comma
id|p-&gt;two-&gt;path
comma
id|p-&gt;one-&gt;mode
comma
id|len1
comma
id|p-&gt;one-&gt;path
)paren
suffix:semicolon
r_else
id|len1
op_assign
id|snprintf
c_func
(paren
id|buffer
comma
r_sizeof
(paren
id|buffer
)paren
comma
l_string|&quot;diff--gita/%.*sb/%.*s&quot;
l_string|&quot;---a/%.*s&quot;
l_string|&quot;+++b/%.*s&quot;
comma
id|len1
comma
id|p-&gt;one-&gt;path
comma
id|len2
comma
id|p-&gt;two-&gt;path
comma
id|len1
comma
id|p-&gt;one-&gt;path
comma
id|len2
comma
id|p-&gt;two-&gt;path
)paren
suffix:semicolon
id|git_SHA1_Update
c_func
(paren
op_amp
id|ctx
comma
id|buffer
comma
id|len1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|diff_filespec_is_binary
c_func
(paren
id|p-&gt;one
)paren
op_logical_or
id|diff_filespec_is_binary
c_func
(paren
id|p-&gt;two
)paren
)paren
(brace
id|git_SHA1_Update
c_func
(paren
op_amp
id|ctx
comma
id|sha1_to_hex
c_func
(paren
id|p-&gt;one-&gt;sha1
)paren
comma
l_int|40
)paren
suffix:semicolon
id|git_SHA1_Update
c_func
(paren
op_amp
id|ctx
comma
id|sha1_to_hex
c_func
(paren
id|p-&gt;two-&gt;sha1
)paren
comma
l_int|40
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|xpp.flags
op_assign
l_int|0
suffix:semicolon
id|xecfg.ctxlen
op_assign
l_int|3
suffix:semicolon
id|xecfg.flags
op_assign
l_int|0
suffix:semicolon
id|xdi_diff_outf
c_func
(paren
op_amp
id|mf1
comma
op_amp
id|mf2
comma
id|patch_id_consume
comma
op_amp
id|data
comma
op_amp
id|xpp
comma
op_amp
id|xecfg
)paren
suffix:semicolon
)brace
id|git_SHA1_Final
c_func
(paren
id|sha1
comma
op_amp
id|ctx
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|diff_flush_patch_id
r_int
id|diff_flush_patch_id
c_func
(paren
r_struct
id|diff_options
op_star
id|options
comma
r_int
r_char
op_star
id|sha1
)paren
(brace
r_struct
id|diff_queue_struct
op_star
id|q
op_assign
op_amp
id|diff_queued_diff
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|result
op_assign
id|diff_get_patch_id
c_func
(paren
id|options
comma
id|sha1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|q-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
id|diff_free_filepair
c_func
(paren
id|q-&gt;queue
(braket
id|i
)braket
)paren
suffix:semicolon
id|free
c_func
(paren
id|q-&gt;queue
)paren
suffix:semicolon
id|DIFF_QUEUE_CLEAR
c_func
(paren
id|q
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|is_summary_empty
r_static
r_int
id|is_summary_empty
c_func
(paren
r_const
r_struct
id|diff_queue_struct
op_star
id|q
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|q-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_struct
id|diff_filepair
op_star
id|p
op_assign
id|q-&gt;queue
(braket
id|i
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|p-&gt;status
)paren
(brace
r_case
id|DIFF_STATUS_DELETED
suffix:colon
r_case
id|DIFF_STATUS_ADDED
suffix:colon
r_case
id|DIFF_STATUS_COPIED
suffix:colon
r_case
id|DIFF_STATUS_RENAMED
suffix:colon
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|p-&gt;score
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;one-&gt;mode
op_logical_and
id|p-&gt;two-&gt;mode
op_logical_and
id|p-&gt;one-&gt;mode
op_ne
id|p-&gt;two-&gt;mode
)paren
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|variable|rename_limit_warning
r_static
r_const
r_char
id|rename_limit_warning
(braket
)braket
op_assign
l_string|&quot;inexact rename detection was skipped due to too many files.&quot;
suffix:semicolon
DECL|variable|degrade_cc_to_c_warning
r_static
r_const
r_char
id|degrade_cc_to_c_warning
(braket
)braket
op_assign
l_string|&quot;only found copies from modified paths due to too many files.&quot;
suffix:semicolon
DECL|variable|rename_limit_advice
r_static
r_const
r_char
id|rename_limit_advice
(braket
)braket
op_assign
l_string|&quot;you may want to set your %s variable to at least &quot;
l_string|&quot;%d and retry the command.&quot;
suffix:semicolon
DECL|function|diff_warn_rename_limit
r_void
id|diff_warn_rename_limit
c_func
(paren
r_const
r_char
op_star
id|varname
comma
r_int
id|needed
comma
r_int
id|degraded_cc
)paren
(brace
r_if
c_cond
(paren
id|degraded_cc
)paren
id|warning
c_func
(paren
id|degrade_cc_to_c_warning
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|needed
)paren
id|warning
c_func
(paren
id|rename_limit_warning
)paren
suffix:semicolon
r_else
r_return
suffix:semicolon
r_if
c_cond
(paren
l_int|0
OL
id|needed
op_logical_and
id|needed
OL
l_int|32767
)paren
id|warning
c_func
(paren
id|rename_limit_advice
comma
id|varname
comma
id|needed
)paren
suffix:semicolon
)brace
DECL|function|diff_flush
r_void
id|diff_flush
c_func
(paren
r_struct
id|diff_options
op_star
id|options
)paren
(brace
r_struct
id|diff_queue_struct
op_star
id|q
op_assign
op_amp
id|diff_queued_diff
suffix:semicolon
r_int
id|i
comma
id|output_format
op_assign
id|options-&gt;output_format
suffix:semicolon
r_int
id|separator
op_assign
l_int|0
suffix:semicolon
r_int
id|dirstat_by_line
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Order: raw, stat, summary, patch&n;&t; * or:    name/name-status/checkdiff (other bits clear)&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|q-&gt;nr
)paren
r_goto
id|free_queue
suffix:semicolon
r_if
c_cond
(paren
id|output_format
op_amp
(paren
id|DIFF_FORMAT_RAW
op_or
id|DIFF_FORMAT_NAME
op_or
id|DIFF_FORMAT_NAME_STATUS
op_or
id|DIFF_FORMAT_CHECKDIFF
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|q-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|diff_filepair
op_star
id|p
op_assign
id|q-&gt;queue
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|check_pair_status
c_func
(paren
id|p
)paren
)paren
id|flush_one_pair
c_func
(paren
id|p
comma
id|options
)paren
suffix:semicolon
)brace
id|separator
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|output_format
op_amp
id|DIFF_FORMAT_DIRSTAT
op_logical_and
id|DIFF_OPT_TST
c_func
(paren
id|options
comma
id|DIRSTAT_BY_LINE
)paren
)paren
id|dirstat_by_line
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|output_format
op_amp
(paren
id|DIFF_FORMAT_DIFFSTAT
op_or
id|DIFF_FORMAT_SHORTSTAT
op_or
id|DIFF_FORMAT_NUMSTAT
)paren
op_logical_or
id|dirstat_by_line
)paren
(brace
r_struct
id|diffstat_t
id|diffstat
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|diffstat
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|diffstat_t
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|q-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|diff_filepair
op_star
id|p
op_assign
id|q-&gt;queue
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|check_pair_status
c_func
(paren
id|p
)paren
)paren
id|diff_flush_stat
c_func
(paren
id|p
comma
id|options
comma
op_amp
id|diffstat
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|output_format
op_amp
id|DIFF_FORMAT_NUMSTAT
)paren
id|show_numstat
c_func
(paren
op_amp
id|diffstat
comma
id|options
)paren
suffix:semicolon
r_if
c_cond
(paren
id|output_format
op_amp
id|DIFF_FORMAT_DIFFSTAT
)paren
id|show_stats
c_func
(paren
op_amp
id|diffstat
comma
id|options
)paren
suffix:semicolon
r_if
c_cond
(paren
id|output_format
op_amp
id|DIFF_FORMAT_SHORTSTAT
)paren
id|show_shortstats
c_func
(paren
op_amp
id|diffstat
comma
id|options
)paren
suffix:semicolon
r_if
c_cond
(paren
id|output_format
op_amp
id|DIFF_FORMAT_DIRSTAT
)paren
id|show_dirstat_by_line
c_func
(paren
op_amp
id|diffstat
comma
id|options
)paren
suffix:semicolon
id|free_diffstat_info
c_func
(paren
op_amp
id|diffstat
)paren
suffix:semicolon
id|separator
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|output_format
op_amp
id|DIFF_FORMAT_DIRSTAT
)paren
op_logical_and
op_logical_neg
id|dirstat_by_line
)paren
id|show_dirstat
c_func
(paren
id|options
)paren
suffix:semicolon
r_if
c_cond
(paren
id|output_format
op_amp
id|DIFF_FORMAT_SUMMARY
op_logical_and
op_logical_neg
id|is_summary_empty
c_func
(paren
id|q
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|q-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
id|diff_summary
c_func
(paren
id|options
comma
id|q-&gt;queue
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|separator
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|output_format
op_amp
id|DIFF_FORMAT_NO_OUTPUT
op_logical_and
id|DIFF_OPT_TST
c_func
(paren
id|options
comma
id|EXIT_WITH_STATUS
)paren
op_logical_and
id|DIFF_OPT_TST
c_func
(paren
id|options
comma
id|DIFF_FROM_CONTENTS
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * run diff_flush_patch for the exit status. setting&n;&t;&t; * options-&gt;file to /dev/null should be safe, because we&n;&t;&t; * aren&squot;t supposed to produce any output anyway.&n;&t;&t; */
r_if
c_cond
(paren
id|options-&gt;close_file
)paren
id|fclose
c_func
(paren
id|options-&gt;file
)paren
suffix:semicolon
id|options-&gt;file
op_assign
id|fopen
c_func
(paren
l_string|&quot;/dev/null&quot;
comma
l_string|&quot;w&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|options-&gt;file
)paren
id|die_errno
c_func
(paren
l_string|&quot;Could not open /dev/null&quot;
)paren
suffix:semicolon
id|options-&gt;close_file
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|q-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|diff_filepair
op_star
id|p
op_assign
id|q-&gt;queue
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|check_pair_status
c_func
(paren
id|p
)paren
)paren
id|diff_flush_patch
c_func
(paren
id|p
comma
id|options
)paren
suffix:semicolon
r_if
c_cond
(paren
id|options-&gt;found_changes
)paren
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|output_format
op_amp
id|DIFF_FORMAT_PATCH
)paren
(brace
r_if
c_cond
(paren
id|separator
)paren
(brace
id|fprintf
c_func
(paren
id|options-&gt;file
comma
l_string|&quot;%s%c&quot;
comma
id|diff_line_prefix
c_func
(paren
id|options
)paren
comma
id|options-&gt;line_termination
)paren
suffix:semicolon
r_if
c_cond
(paren
id|options-&gt;stat_sep
)paren
(brace
multiline_comment|/* attach patch instead of inline */
id|fputs
c_func
(paren
id|options-&gt;stat_sep
comma
id|options-&gt;file
)paren
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|q-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|diff_filepair
op_star
id|p
op_assign
id|q-&gt;queue
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|check_pair_status
c_func
(paren
id|p
)paren
)paren
id|diff_flush_patch
c_func
(paren
id|p
comma
id|options
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|output_format
op_amp
id|DIFF_FORMAT_CALLBACK
)paren
id|options
op_member_access_from_pointer
id|format_callback
c_func
(paren
id|q
comma
id|options
comma
id|options-&gt;format_callback_data
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|q-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
id|diff_free_filepair
c_func
(paren
id|q-&gt;queue
(braket
id|i
)braket
)paren
suffix:semicolon
id|free_queue
suffix:colon
id|free
c_func
(paren
id|q-&gt;queue
)paren
suffix:semicolon
id|DIFF_QUEUE_CLEAR
c_func
(paren
id|q
)paren
suffix:semicolon
r_if
c_cond
(paren
id|options-&gt;close_file
)paren
id|fclose
c_func
(paren
id|options-&gt;file
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Report the content-level differences with HAS_CHANGES;&n;&t; * diff_addremove/diff_change does not set the bit when&n;&t; * DIFF_FROM_CONTENTS is in effect (e.g. with -w).&n;&t; */
r_if
c_cond
(paren
id|DIFF_OPT_TST
c_func
(paren
id|options
comma
id|DIFF_FROM_CONTENTS
)paren
)paren
(brace
r_if
c_cond
(paren
id|options-&gt;found_changes
)paren
id|DIFF_OPT_SET
c_func
(paren
id|options
comma
id|HAS_CHANGES
)paren
suffix:semicolon
r_else
id|DIFF_OPT_CLR
c_func
(paren
id|options
comma
id|HAS_CHANGES
)paren
suffix:semicolon
)brace
)brace
DECL|function|match_filter
r_static
r_int
id|match_filter
c_func
(paren
r_const
r_struct
id|diff_options
op_star
id|options
comma
r_const
r_struct
id|diff_filepair
op_star
id|p
)paren
(brace
r_return
(paren
(paren
(paren
id|p-&gt;status
op_eq
id|DIFF_STATUS_MODIFIED
)paren
op_logical_and
(paren
(paren
id|p-&gt;score
op_logical_and
id|filter_bit_tst
c_func
(paren
id|DIFF_STATUS_FILTER_BROKEN
comma
id|options
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|p-&gt;score
op_logical_and
id|filter_bit_tst
c_func
(paren
id|DIFF_STATUS_MODIFIED
comma
id|options
)paren
)paren
)paren
)paren
op_logical_or
(paren
(paren
id|p-&gt;status
op_ne
id|DIFF_STATUS_MODIFIED
)paren
op_logical_and
id|filter_bit_tst
c_func
(paren
id|p-&gt;status
comma
id|options
)paren
)paren
)paren
suffix:semicolon
)brace
DECL|function|diffcore_apply_filter
r_static
r_void
id|diffcore_apply_filter
c_func
(paren
r_struct
id|diff_options
op_star
id|options
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|diff_queue_struct
op_star
id|q
op_assign
op_amp
id|diff_queued_diff
suffix:semicolon
r_struct
id|diff_queue_struct
id|outq
suffix:semicolon
id|DIFF_QUEUE_CLEAR
c_func
(paren
op_amp
id|outq
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|options-&gt;filter
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|filter_bit_tst
c_func
(paren
id|DIFF_STATUS_FILTER_AON
comma
id|options
)paren
)paren
(brace
r_int
id|found
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|found
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|found
op_logical_and
id|i
OL
id|q-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|match_filter
c_func
(paren
id|options
comma
id|q-&gt;queue
(braket
id|i
)braket
)paren
)paren
id|found
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|found
)paren
r_return
suffix:semicolon
multiline_comment|/* otherwise we will clear the whole queue&n;&t;&t; * by copying the empty outq at the end of this&n;&t;&t; * function, but first clear the current entries&n;&t;&t; * in the queue.&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|q-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
id|diff_free_filepair
c_func
(paren
id|q-&gt;queue
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Only the matching ones */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|q-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|diff_filepair
op_star
id|p
op_assign
id|q-&gt;queue
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|match_filter
c_func
(paren
id|options
comma
id|p
)paren
)paren
id|diff_q
c_func
(paren
op_amp
id|outq
comma
id|p
)paren
suffix:semicolon
r_else
id|diff_free_filepair
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
)brace
id|free
c_func
(paren
id|q-&gt;queue
)paren
suffix:semicolon
op_star
id|q
op_assign
id|outq
suffix:semicolon
)brace
multiline_comment|/* Check whether two filespecs with the same mode and size are identical */
DECL|function|diff_filespec_is_identical
r_static
r_int
id|diff_filespec_is_identical
c_func
(paren
r_struct
id|diff_filespec
op_star
id|one
comma
r_struct
id|diff_filespec
op_star
id|two
)paren
(brace
r_if
c_cond
(paren
id|S_ISGITLINK
c_func
(paren
id|one-&gt;mode
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|diff_populate_filespec
c_func
(paren
id|one
comma
l_int|0
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|diff_populate_filespec
c_func
(paren
id|two
comma
l_int|0
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
op_logical_neg
id|memcmp
c_func
(paren
id|one-&gt;data
comma
id|two-&gt;data
comma
id|one-&gt;size
)paren
suffix:semicolon
)brace
DECL|function|diff_filespec_check_stat_unmatch
r_static
r_int
id|diff_filespec_check_stat_unmatch
c_func
(paren
r_struct
id|diff_filepair
op_star
id|p
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;done_skip_stat_unmatch
)paren
r_return
id|p-&gt;skip_stat_unmatch_result
suffix:semicolon
id|p-&gt;done_skip_stat_unmatch
op_assign
l_int|1
suffix:semicolon
id|p-&gt;skip_stat_unmatch_result
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * 1. Entries that come from stat info dirtiness&n;&t; *    always have both sides (iow, not create/delete),&n;&t; *    one side of the object name is unknown, with&n;&t; *    the same mode and size.  Keep the ones that&n;&t; *    do not match these criteria.  They have real&n;&t; *    differences.&n;&t; *&n;&t; * 2. At this point, the file is known to be modified,&n;&t; *    with the same mode and size, and the object&n;&t; *    name of one side is unknown.  Need to inspect&n;&t; *    the identical contents.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|DIFF_FILE_VALID
c_func
(paren
id|p-&gt;one
)paren
op_logical_or
multiline_comment|/* (1) */
op_logical_neg
id|DIFF_FILE_VALID
c_func
(paren
id|p-&gt;two
)paren
op_logical_or
(paren
id|p-&gt;one-&gt;sha1_valid
op_logical_and
id|p-&gt;two-&gt;sha1_valid
)paren
op_logical_or
(paren
id|p-&gt;one-&gt;mode
op_ne
id|p-&gt;two-&gt;mode
)paren
op_logical_or
id|diff_populate_filespec
c_func
(paren
id|p-&gt;one
comma
l_int|1
)paren
op_logical_or
id|diff_populate_filespec
c_func
(paren
id|p-&gt;two
comma
l_int|1
)paren
op_logical_or
(paren
id|p-&gt;one-&gt;size
op_ne
id|p-&gt;two-&gt;size
)paren
op_logical_or
op_logical_neg
id|diff_filespec_is_identical
c_func
(paren
id|p-&gt;one
comma
id|p-&gt;two
)paren
)paren
multiline_comment|/* (2) */
id|p-&gt;skip_stat_unmatch_result
op_assign
l_int|1
suffix:semicolon
r_return
id|p-&gt;skip_stat_unmatch_result
suffix:semicolon
)brace
DECL|function|diffcore_skip_stat_unmatch
r_static
r_void
id|diffcore_skip_stat_unmatch
c_func
(paren
r_struct
id|diff_options
op_star
id|diffopt
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|diff_queue_struct
op_star
id|q
op_assign
op_amp
id|diff_queued_diff
suffix:semicolon
r_struct
id|diff_queue_struct
id|outq
suffix:semicolon
id|DIFF_QUEUE_CLEAR
c_func
(paren
op_amp
id|outq
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|q-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|diff_filepair
op_star
id|p
op_assign
id|q-&gt;queue
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|diff_filespec_check_stat_unmatch
c_func
(paren
id|p
)paren
)paren
id|diff_q
c_func
(paren
op_amp
id|outq
comma
id|p
)paren
suffix:semicolon
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * The caller can subtract 1 from skip_stat_unmatch&n;&t;&t;&t; * to determine how many paths were dirty only&n;&t;&t;&t; * due to stat info mismatch.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|DIFF_OPT_TST
c_func
(paren
id|diffopt
comma
id|NO_INDEX
)paren
)paren
id|diffopt-&gt;skip_stat_unmatch
op_increment
suffix:semicolon
id|diff_free_filepair
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
)brace
id|free
c_func
(paren
id|q-&gt;queue
)paren
suffix:semicolon
op_star
id|q
op_assign
id|outq
suffix:semicolon
)brace
DECL|function|diffnamecmp
r_static
r_int
id|diffnamecmp
c_func
(paren
r_const
r_void
op_star
id|a_
comma
r_const
r_void
op_star
id|b_
)paren
(brace
r_const
r_struct
id|diff_filepair
op_star
id|a
op_assign
op_star
(paren
(paren
r_const
r_struct
id|diff_filepair
op_star
op_star
)paren
id|a_
)paren
suffix:semicolon
r_const
r_struct
id|diff_filepair
op_star
id|b
op_assign
op_star
(paren
(paren
r_const
r_struct
id|diff_filepair
op_star
op_star
)paren
id|b_
)paren
suffix:semicolon
r_const
r_char
op_star
id|name_a
comma
op_star
id|name_b
suffix:semicolon
id|name_a
op_assign
id|a-&gt;one
ques
c_cond
id|a-&gt;one-&gt;path
suffix:colon
id|a-&gt;two-&gt;path
suffix:semicolon
id|name_b
op_assign
id|b-&gt;one
ques
c_cond
id|b-&gt;one-&gt;path
suffix:colon
id|b-&gt;two-&gt;path
suffix:semicolon
r_return
id|strcmp
c_func
(paren
id|name_a
comma
id|name_b
)paren
suffix:semicolon
)brace
DECL|function|diffcore_fix_diff_index
r_void
id|diffcore_fix_diff_index
c_func
(paren
r_struct
id|diff_options
op_star
id|options
)paren
(brace
r_struct
id|diff_queue_struct
op_star
id|q
op_assign
op_amp
id|diff_queued_diff
suffix:semicolon
id|qsort
c_func
(paren
id|q-&gt;queue
comma
id|q-&gt;nr
comma
r_sizeof
(paren
id|q-&gt;queue
(braket
l_int|0
)braket
)paren
comma
id|diffnamecmp
)paren
suffix:semicolon
)brace
DECL|function|diffcore_std
r_void
id|diffcore_std
c_func
(paren
r_struct
id|diff_options
op_star
id|options
)paren
(brace
multiline_comment|/* NOTE please keep the following in sync with diff_tree_combined() */
r_if
c_cond
(paren
id|options-&gt;skip_stat_unmatch
)paren
id|diffcore_skip_stat_unmatch
c_func
(paren
id|options
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|options-&gt;found_follow
)paren
(brace
multiline_comment|/* See try_to_follow_renames() in tree-diff.c */
r_if
c_cond
(paren
id|options-&gt;break_opt
op_ne
l_int|1
)paren
id|diffcore_break
c_func
(paren
id|options-&gt;break_opt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|options-&gt;detect_rename
)paren
id|diffcore_rename
c_func
(paren
id|options
)paren
suffix:semicolon
r_if
c_cond
(paren
id|options-&gt;break_opt
op_ne
l_int|1
)paren
id|diffcore_merge_broken
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|options-&gt;pickaxe
)paren
id|diffcore_pickaxe
c_func
(paren
id|options
)paren
suffix:semicolon
r_if
c_cond
(paren
id|options-&gt;orderfile
)paren
id|diffcore_order
c_func
(paren
id|options-&gt;orderfile
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|options-&gt;found_follow
)paren
multiline_comment|/* See try_to_follow_renames() in tree-diff.c */
id|diff_resolve_rename_copy
c_func
(paren
)paren
suffix:semicolon
id|diffcore_apply_filter
c_func
(paren
id|options
)paren
suffix:semicolon
r_if
c_cond
(paren
id|diff_queued_diff.nr
op_logical_and
op_logical_neg
id|DIFF_OPT_TST
c_func
(paren
id|options
comma
id|DIFF_FROM_CONTENTS
)paren
)paren
id|DIFF_OPT_SET
c_func
(paren
id|options
comma
id|HAS_CHANGES
)paren
suffix:semicolon
r_else
id|DIFF_OPT_CLR
c_func
(paren
id|options
comma
id|HAS_CHANGES
)paren
suffix:semicolon
id|options-&gt;found_follow
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|diff_result_code
r_int
id|diff_result_code
c_func
(paren
r_struct
id|diff_options
op_star
id|opt
comma
r_int
id|status
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
id|diff_warn_rename_limit
c_func
(paren
l_string|&quot;diff.renameLimit&quot;
comma
id|opt-&gt;needed_rename_limit
comma
id|opt-&gt;degraded_cc_to_c
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|DIFF_OPT_TST
c_func
(paren
id|opt
comma
id|EXIT_WITH_STATUS
)paren
op_logical_and
op_logical_neg
(paren
id|opt-&gt;output_format
op_amp
id|DIFF_FORMAT_CHECKDIFF
)paren
)paren
r_return
id|status
suffix:semicolon
r_if
c_cond
(paren
id|DIFF_OPT_TST
c_func
(paren
id|opt
comma
id|EXIT_WITH_STATUS
)paren
op_logical_and
id|DIFF_OPT_TST
c_func
(paren
id|opt
comma
id|HAS_CHANGES
)paren
)paren
id|result
op_or_assign
l_int|01
suffix:semicolon
r_if
c_cond
(paren
(paren
id|opt-&gt;output_format
op_amp
id|DIFF_FORMAT_CHECKDIFF
)paren
op_logical_and
id|DIFF_OPT_TST
c_func
(paren
id|opt
comma
id|CHECK_FAILED
)paren
)paren
id|result
op_or_assign
l_int|02
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|diff_can_quit_early
r_int
id|diff_can_quit_early
c_func
(paren
r_struct
id|diff_options
op_star
id|opt
)paren
(brace
r_return
(paren
id|DIFF_OPT_TST
c_func
(paren
id|opt
comma
id|QUICK
)paren
op_logical_and
op_logical_neg
id|opt-&gt;filter
op_logical_and
id|DIFF_OPT_TST
c_func
(paren
id|opt
comma
id|HAS_CHANGES
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Shall changes to this submodule be ignored?&n; *&n; * Submodule changes can be configured to be ignored separately for each path,&n; * but that configuration can be overridden from the command line.&n; */
DECL|function|is_submodule_ignored
r_static
r_int
id|is_submodule_ignored
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_struct
id|diff_options
op_star
id|options
)paren
(brace
r_int
id|ignored
op_assign
l_int|0
suffix:semicolon
r_int
id|orig_flags
op_assign
id|options-&gt;flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|DIFF_OPT_TST
c_func
(paren
id|options
comma
id|OVERRIDE_SUBMODULE_CONFIG
)paren
)paren
id|set_diffopt_flags_from_submodule_config
c_func
(paren
id|options
comma
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DIFF_OPT_TST
c_func
(paren
id|options
comma
id|IGNORE_SUBMODULES
)paren
)paren
id|ignored
op_assign
l_int|1
suffix:semicolon
id|options-&gt;flags
op_assign
id|orig_flags
suffix:semicolon
r_return
id|ignored
suffix:semicolon
)brace
DECL|function|diff_addremove
r_void
id|diff_addremove
c_func
(paren
r_struct
id|diff_options
op_star
id|options
comma
r_int
id|addremove
comma
r_int
id|mode
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
id|sha1_valid
comma
r_const
r_char
op_star
id|concatpath
comma
r_int
id|dirty_submodule
)paren
(brace
r_struct
id|diff_filespec
op_star
id|one
comma
op_star
id|two
suffix:semicolon
r_if
c_cond
(paren
id|S_ISGITLINK
c_func
(paren
id|mode
)paren
op_logical_and
id|is_submodule_ignored
c_func
(paren
id|concatpath
comma
id|options
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* This may look odd, but it is a preparation for&n;&t; * feeding &quot;there are unchanged files which should&n;&t; * not produce diffs, but when you are doing copy&n;&t; * detection you would need them, so here they are&quot;&n;&t; * entries to the diff-core.  They will be prefixed&n;&t; * with something like &squot;=&squot; or &squot;*&squot; (I haven&squot;t decided&n;&t; * which but should not make any difference).&n;&t; * Feeding the same new and old to diff_change()&n;&t; * also has the same effect.&n;&t; * Before the final output happens, they are pruned after&n;&t; * merged into rename/copy pairs as appropriate.&n;&t; */
r_if
c_cond
(paren
id|DIFF_OPT_TST
c_func
(paren
id|options
comma
id|REVERSE_DIFF
)paren
)paren
id|addremove
op_assign
(paren
id|addremove
op_eq
l_char|&squot;+&squot;
ques
c_cond
l_char|&squot;-&squot;
suffix:colon
id|addremove
op_eq
l_char|&squot;-&squot;
ques
c_cond
l_char|&squot;+&squot;
suffix:colon
id|addremove
)paren
suffix:semicolon
r_if
c_cond
(paren
id|options-&gt;prefix
op_logical_and
id|strncmp
c_func
(paren
id|concatpath
comma
id|options-&gt;prefix
comma
id|options-&gt;prefix_length
)paren
)paren
r_return
suffix:semicolon
id|one
op_assign
id|alloc_filespec
c_func
(paren
id|concatpath
)paren
suffix:semicolon
id|two
op_assign
id|alloc_filespec
c_func
(paren
id|concatpath
)paren
suffix:semicolon
r_if
c_cond
(paren
id|addremove
op_ne
l_char|&squot;+&squot;
)paren
id|fill_filespec
c_func
(paren
id|one
comma
id|sha1
comma
id|sha1_valid
comma
id|mode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|addremove
op_ne
l_char|&squot;-&squot;
)paren
(brace
id|fill_filespec
c_func
(paren
id|two
comma
id|sha1
comma
id|sha1_valid
comma
id|mode
)paren
suffix:semicolon
id|two-&gt;dirty_submodule
op_assign
id|dirty_submodule
suffix:semicolon
)brace
id|diff_queue
c_func
(paren
op_amp
id|diff_queued_diff
comma
id|one
comma
id|two
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|DIFF_OPT_TST
c_func
(paren
id|options
comma
id|DIFF_FROM_CONTENTS
)paren
)paren
id|DIFF_OPT_SET
c_func
(paren
id|options
comma
id|HAS_CHANGES
)paren
suffix:semicolon
)brace
DECL|function|diff_change
r_void
id|diff_change
c_func
(paren
r_struct
id|diff_options
op_star
id|options
comma
r_int
id|old_mode
comma
r_int
id|new_mode
comma
r_const
r_int
r_char
op_star
id|old_sha1
comma
r_const
r_int
r_char
op_star
id|new_sha1
comma
r_int
id|old_sha1_valid
comma
r_int
id|new_sha1_valid
comma
r_const
r_char
op_star
id|concatpath
comma
r_int
id|old_dirty_submodule
comma
r_int
id|new_dirty_submodule
)paren
(brace
r_struct
id|diff_filespec
op_star
id|one
comma
op_star
id|two
suffix:semicolon
r_struct
id|diff_filepair
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|S_ISGITLINK
c_func
(paren
id|old_mode
)paren
op_logical_and
id|S_ISGITLINK
c_func
(paren
id|new_mode
)paren
op_logical_and
id|is_submodule_ignored
c_func
(paren
id|concatpath
comma
id|options
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|DIFF_OPT_TST
c_func
(paren
id|options
comma
id|REVERSE_DIFF
)paren
)paren
(brace
r_int
id|tmp
suffix:semicolon
r_const
r_int
r_char
op_star
id|tmp_c
suffix:semicolon
id|tmp
op_assign
id|old_mode
suffix:semicolon
id|old_mode
op_assign
id|new_mode
suffix:semicolon
id|new_mode
op_assign
id|tmp
suffix:semicolon
id|tmp_c
op_assign
id|old_sha1
suffix:semicolon
id|old_sha1
op_assign
id|new_sha1
suffix:semicolon
id|new_sha1
op_assign
id|tmp_c
suffix:semicolon
id|tmp
op_assign
id|old_sha1_valid
suffix:semicolon
id|old_sha1_valid
op_assign
id|new_sha1_valid
suffix:semicolon
id|new_sha1_valid
op_assign
id|tmp
suffix:semicolon
id|tmp
op_assign
id|old_dirty_submodule
suffix:semicolon
id|old_dirty_submodule
op_assign
id|new_dirty_submodule
suffix:semicolon
id|new_dirty_submodule
op_assign
id|tmp
suffix:semicolon
)brace
r_if
c_cond
(paren
id|options-&gt;prefix
op_logical_and
id|strncmp
c_func
(paren
id|concatpath
comma
id|options-&gt;prefix
comma
id|options-&gt;prefix_length
)paren
)paren
r_return
suffix:semicolon
id|one
op_assign
id|alloc_filespec
c_func
(paren
id|concatpath
)paren
suffix:semicolon
id|two
op_assign
id|alloc_filespec
c_func
(paren
id|concatpath
)paren
suffix:semicolon
id|fill_filespec
c_func
(paren
id|one
comma
id|old_sha1
comma
id|old_sha1_valid
comma
id|old_mode
)paren
suffix:semicolon
id|fill_filespec
c_func
(paren
id|two
comma
id|new_sha1
comma
id|new_sha1_valid
comma
id|new_mode
)paren
suffix:semicolon
id|one-&gt;dirty_submodule
op_assign
id|old_dirty_submodule
suffix:semicolon
id|two-&gt;dirty_submodule
op_assign
id|new_dirty_submodule
suffix:semicolon
id|p
op_assign
id|diff_queue
c_func
(paren
op_amp
id|diff_queued_diff
comma
id|one
comma
id|two
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DIFF_OPT_TST
c_func
(paren
id|options
comma
id|DIFF_FROM_CONTENTS
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|DIFF_OPT_TST
c_func
(paren
id|options
comma
id|QUICK
)paren
op_logical_and
id|options-&gt;skip_stat_unmatch
op_logical_and
op_logical_neg
id|diff_filespec_check_stat_unmatch
c_func
(paren
id|p
)paren
)paren
r_return
suffix:semicolon
id|DIFF_OPT_SET
c_func
(paren
id|options
comma
id|HAS_CHANGES
)paren
suffix:semicolon
)brace
DECL|function|diff_unmerge
r_struct
id|diff_filepair
op_star
id|diff_unmerge
c_func
(paren
r_struct
id|diff_options
op_star
id|options
comma
r_const
r_char
op_star
id|path
)paren
(brace
r_struct
id|diff_filepair
op_star
id|pair
suffix:semicolon
r_struct
id|diff_filespec
op_star
id|one
comma
op_star
id|two
suffix:semicolon
r_if
c_cond
(paren
id|options-&gt;prefix
op_logical_and
id|strncmp
c_func
(paren
id|path
comma
id|options-&gt;prefix
comma
id|options-&gt;prefix_length
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|one
op_assign
id|alloc_filespec
c_func
(paren
id|path
)paren
suffix:semicolon
id|two
op_assign
id|alloc_filespec
c_func
(paren
id|path
)paren
suffix:semicolon
id|pair
op_assign
id|diff_queue
c_func
(paren
op_amp
id|diff_queued_diff
comma
id|one
comma
id|two
)paren
suffix:semicolon
id|pair-&gt;is_unmerged
op_assign
l_int|1
suffix:semicolon
r_return
id|pair
suffix:semicolon
)brace
DECL|function|run_textconv
r_static
r_char
op_star
id|run_textconv
c_func
(paren
r_const
r_char
op_star
id|pgm
comma
r_struct
id|diff_filespec
op_star
id|spec
comma
r_int
op_star
id|outsize
)paren
(brace
r_struct
id|diff_tempfile
op_star
id|temp
suffix:semicolon
r_const
r_char
op_star
id|argv
(braket
l_int|3
)braket
suffix:semicolon
r_const
r_char
op_star
op_star
id|arg
op_assign
id|argv
suffix:semicolon
r_struct
id|child_process
id|child
suffix:semicolon
r_struct
id|strbuf
id|buf
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|temp
op_assign
id|prepare_temp_file
c_func
(paren
id|spec-&gt;path
comma
id|spec
)paren
suffix:semicolon
op_star
id|arg
op_increment
op_assign
id|pgm
suffix:semicolon
op_star
id|arg
op_increment
op_assign
id|temp-&gt;name
suffix:semicolon
op_star
id|arg
op_assign
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|child
comma
l_int|0
comma
r_sizeof
(paren
id|child
)paren
)paren
suffix:semicolon
id|child.use_shell
op_assign
l_int|1
suffix:semicolon
id|child.argv
op_assign
id|argv
suffix:semicolon
id|child.out
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|start_command
c_func
(paren
op_amp
id|child
)paren
)paren
(brace
id|remove_tempfile
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strbuf_read
c_func
(paren
op_amp
id|buf
comma
id|child.out
comma
l_int|0
)paren
OL
l_int|0
)paren
id|err
op_assign
id|error
c_func
(paren
l_string|&quot;error reading from textconv command &squot;%s&squot;&quot;
comma
id|pgm
)paren
suffix:semicolon
id|close
c_func
(paren
id|child.out
)paren
suffix:semicolon
r_if
c_cond
(paren
id|finish_command
c_func
(paren
op_amp
id|child
)paren
op_logical_or
id|err
)paren
(brace
id|strbuf_release
c_func
(paren
op_amp
id|buf
)paren
suffix:semicolon
id|remove_tempfile
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|remove_tempfile
c_func
(paren
)paren
suffix:semicolon
r_return
id|strbuf_detach
c_func
(paren
op_amp
id|buf
comma
id|outsize
)paren
suffix:semicolon
)brace
DECL|function|fill_textconv
r_int
id|fill_textconv
c_func
(paren
r_struct
id|userdiff_driver
op_star
id|driver
comma
r_struct
id|diff_filespec
op_star
id|df
comma
r_char
op_star
op_star
id|outbuf
)paren
(brace
r_int
id|size
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|driver
op_logical_or
op_logical_neg
id|driver-&gt;textconv
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|DIFF_FILE_VALID
c_func
(paren
id|df
)paren
)paren
(brace
op_star
id|outbuf
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|diff_populate_filespec
c_func
(paren
id|df
comma
l_int|0
)paren
)paren
id|die
c_func
(paren
l_string|&quot;unable to read files to diff&quot;
)paren
suffix:semicolon
op_star
id|outbuf
op_assign
id|df-&gt;data
suffix:semicolon
r_return
id|df-&gt;size
suffix:semicolon
)brace
r_if
c_cond
(paren
id|driver-&gt;textconv_cache
op_logical_and
id|df-&gt;sha1_valid
)paren
(brace
op_star
id|outbuf
op_assign
id|notes_cache_get
c_func
(paren
id|driver-&gt;textconv_cache
comma
id|df-&gt;sha1
comma
op_amp
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|outbuf
)paren
r_return
id|size
suffix:semicolon
)brace
op_star
id|outbuf
op_assign
id|run_textconv
c_func
(paren
id|driver-&gt;textconv
comma
id|df
comma
op_amp
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|outbuf
)paren
id|die
c_func
(paren
l_string|&quot;unable to read files to diff&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|driver-&gt;textconv_cache
op_logical_and
id|df-&gt;sha1_valid
)paren
(brace
multiline_comment|/* ignore errors, as we might be in a readonly repository */
id|notes_cache_put
c_func
(paren
id|driver-&gt;textconv_cache
comma
id|df-&gt;sha1
comma
op_star
id|outbuf
comma
id|size
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * we could save up changes and flush them all at the end,&n;&t;&t; * but we would need an extra call after all diffing is done.&n;&t;&t; * Since generating a cache entry is the slow path anyway,&n;&t;&t; * this extra overhead probably isn&squot;t a big deal.&n;&t;&t; */
id|notes_cache_write
c_func
(paren
id|driver-&gt;textconv_cache
)paren
suffix:semicolon
)brace
r_return
id|size
suffix:semicolon
)brace
DECL|function|setup_diff_pager
r_void
id|setup_diff_pager
c_func
(paren
r_struct
id|diff_options
op_star
id|opt
)paren
(brace
multiline_comment|/*&n;&t; * If the user asked for our exit code, then either they want --quiet&n;&t; * or --exit-code. We should definitely not bother with a pager in the&n;&t; * former case, as we will generate no output. Since we still properly&n;&t; * report our exit code even when a pager is run, we _could_ run a&n;&t; * pager with --exit-code. But since we have not done so historically,&n;&t; * and because it is easy to find people oneline advising &quot;git diff&n;&t; * --exit-code&quot; in hooks and other scripts, we do not do so.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|DIFF_OPT_TST
c_func
(paren
id|opt
comma
id|EXIT_WITH_STATUS
)paren
op_logical_and
id|check_pager_config
c_func
(paren
l_string|&quot;diff&quot;
)paren
op_ne
l_int|0
)paren
id|setup_pager
c_func
(paren
)paren
suffix:semicolon
)brace
eof
