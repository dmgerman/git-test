macro_line|#include &quot;refs.h&quot;
macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;object.h&quot;
macro_line|#include &quot;tag.h&quot;
macro_line|#include &lt;errno.h&gt;
multiline_comment|/* ISSYMREF=01 and ISPACKED=02 are public interfaces */
DECL|macro|REF_KNOWS_PEELED
mdefine_line|#define REF_KNOWS_PEELED 04
DECL|struct|ref_list
r_struct
id|ref_list
(brace
DECL|member|next
r_struct
id|ref_list
op_star
id|next
suffix:semicolon
DECL|member|flag
r_int
r_char
id|flag
suffix:semicolon
multiline_comment|/* ISSYMREF? ISPACKED? */
DECL|member|sha1
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
DECL|member|peeled
r_int
r_char
id|peeled
(braket
l_int|20
)braket
suffix:semicolon
DECL|member|name
r_char
id|name
(braket
id|FLEX_ARRAY
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|function|parse_ref_line
r_static
r_const
r_char
op_star
id|parse_ref_line
c_func
(paren
r_char
op_star
id|line
comma
r_int
r_char
op_star
id|sha1
)paren
(brace
multiline_comment|/*&n;&t; * 42: the answer to everything.&n;&t; *&n;&t; * In this case, it happens to be the answer to&n;&t; *  40 (length of sha1 hex representation)&n;&t; *  +1 (space in between hex and name)&n;&t; *  +1 (newline at the end of the line)&n;&t; */
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|line
)paren
l_int|42
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|line
comma
id|sha1
)paren
OL
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|isspace
c_func
(paren
id|line
(braket
l_int|40
)braket
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|line
op_add_assign
l_int|41
suffix:semicolon
r_if
c_cond
(paren
id|isspace
c_func
(paren
op_star
id|line
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|line
(braket
id|len
)braket
op_ne
l_char|&squot;&bslash;n&squot;
)paren
r_return
l_int|NULL
suffix:semicolon
id|line
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
r_return
id|line
suffix:semicolon
)brace
DECL|function|add_ref
r_static
r_struct
id|ref_list
op_star
id|add_ref
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
id|flag
comma
r_struct
id|ref_list
op_star
id|list
comma
r_struct
id|ref_list
op_star
op_star
id|new_entry
)paren
(brace
r_int
id|len
suffix:semicolon
r_struct
id|ref_list
op_star
op_star
id|p
op_assign
op_amp
id|list
comma
op_star
id|entry
suffix:semicolon
multiline_comment|/* Find the place to insert the ref into.. */
r_while
c_loop
(paren
(paren
id|entry
op_assign
op_star
id|p
)paren
op_ne
l_int|NULL
)paren
(brace
r_int
id|cmp
op_assign
id|strcmp
c_func
(paren
id|entry-&gt;name
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmp
OG
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* Same as existing entry? */
r_if
c_cond
(paren
op_logical_neg
id|cmp
)paren
(brace
r_if
c_cond
(paren
id|new_entry
)paren
op_star
id|new_entry
op_assign
id|entry
suffix:semicolon
r_return
id|list
suffix:semicolon
)brace
id|p
op_assign
op_amp
id|entry-&gt;next
suffix:semicolon
)brace
multiline_comment|/* Allocate it and add it in.. */
id|len
op_assign
id|strlen
c_func
(paren
id|name
)paren
op_plus
l_int|1
suffix:semicolon
id|entry
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ref_list
)paren
op_plus
id|len
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|entry-&gt;sha1
comma
id|sha1
)paren
suffix:semicolon
id|hashclr
c_func
(paren
id|entry-&gt;peeled
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|entry-&gt;name
comma
id|name
comma
id|len
)paren
suffix:semicolon
id|entry-&gt;flag
op_assign
id|flag
suffix:semicolon
id|entry-&gt;next
op_assign
op_star
id|p
suffix:semicolon
op_star
id|p
op_assign
id|entry
suffix:semicolon
r_if
c_cond
(paren
id|new_entry
)paren
op_star
id|new_entry
op_assign
id|entry
suffix:semicolon
r_return
id|list
suffix:semicolon
)brace
multiline_comment|/*&n; * Future: need to be in &quot;struct repository&quot;&n; * when doing a full libification.&n; */
DECL|struct|cached_refs
r_struct
id|cached_refs
(brace
DECL|member|did_loose
r_char
id|did_loose
suffix:semicolon
DECL|member|did_packed
r_char
id|did_packed
suffix:semicolon
DECL|member|loose
r_struct
id|ref_list
op_star
id|loose
suffix:semicolon
DECL|member|packed
r_struct
id|ref_list
op_star
id|packed
suffix:semicolon
DECL|variable|cached_refs
)brace
id|cached_refs
suffix:semicolon
DECL|function|free_ref_list
r_static
r_void
id|free_ref_list
c_func
(paren
r_struct
id|ref_list
op_star
id|list
)paren
(brace
r_struct
id|ref_list
op_star
id|next
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|list
suffix:semicolon
id|list
op_assign
id|next
)paren
(brace
id|next
op_assign
id|list-&gt;next
suffix:semicolon
id|free
c_func
(paren
id|list
)paren
suffix:semicolon
)brace
)brace
DECL|function|invalidate_cached_refs
r_static
r_void
id|invalidate_cached_refs
c_func
(paren
r_void
)paren
(brace
r_struct
id|cached_refs
op_star
id|ca
op_assign
op_amp
id|cached_refs
suffix:semicolon
r_if
c_cond
(paren
id|ca-&gt;did_loose
op_logical_and
id|ca-&gt;loose
)paren
id|free_ref_list
c_func
(paren
id|ca-&gt;loose
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ca-&gt;did_packed
op_logical_and
id|ca-&gt;packed
)paren
id|free_ref_list
c_func
(paren
id|ca-&gt;packed
)paren
suffix:semicolon
id|ca-&gt;loose
op_assign
id|ca-&gt;packed
op_assign
l_int|NULL
suffix:semicolon
id|ca-&gt;did_loose
op_assign
id|ca-&gt;did_packed
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|read_packed_refs
r_static
r_void
id|read_packed_refs
c_func
(paren
id|FILE
op_star
id|f
comma
r_struct
id|cached_refs
op_star
id|cached_refs
)paren
(brace
r_struct
id|ref_list
op_star
id|list
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|ref_list
op_star
id|last
op_assign
l_int|NULL
suffix:semicolon
r_char
id|refline
(braket
id|PATH_MAX
)braket
suffix:semicolon
r_int
id|flag
op_assign
id|REF_ISPACKED
suffix:semicolon
r_while
c_loop
(paren
id|fgets
c_func
(paren
id|refline
comma
r_sizeof
(paren
id|refline
)paren
comma
id|f
)paren
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_const
r_char
op_star
id|name
suffix:semicolon
r_static
r_const
r_char
id|header
(braket
)braket
op_assign
l_string|&quot;# pack-refs with:&quot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|refline
comma
id|header
comma
r_sizeof
(paren
id|header
)paren
op_minus
l_int|1
)paren
)paren
(brace
r_const
r_char
op_star
id|traits
op_assign
id|refline
op_plus
r_sizeof
(paren
id|header
)paren
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|traits
comma
l_string|&quot; peeled &quot;
)paren
)paren
id|flag
op_or_assign
id|REF_KNOWS_PEELED
suffix:semicolon
multiline_comment|/* perhaps other traits later as well */
r_continue
suffix:semicolon
)brace
id|name
op_assign
id|parse_ref_line
c_func
(paren
id|refline
comma
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|name
)paren
(brace
id|list
op_assign
id|add_ref
c_func
(paren
id|name
comma
id|sha1
comma
id|flag
comma
id|list
comma
op_amp
id|last
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|last
op_logical_and
id|refline
(braket
l_int|0
)braket
op_eq
l_char|&squot;^&squot;
op_logical_and
id|strlen
c_func
(paren
id|refline
)paren
op_eq
l_int|42
op_logical_and
id|refline
(braket
l_int|41
)braket
op_eq
l_char|&squot;&bslash;n&squot;
op_logical_and
op_logical_neg
id|get_sha1_hex
c_func
(paren
id|refline
op_plus
l_int|1
comma
id|sha1
)paren
)paren
id|hashcpy
c_func
(paren
id|last-&gt;peeled
comma
id|sha1
)paren
suffix:semicolon
)brace
id|cached_refs-&gt;packed
op_assign
id|list
suffix:semicolon
)brace
DECL|function|get_packed_refs
r_static
r_struct
id|ref_list
op_star
id|get_packed_refs
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cached_refs.did_packed
)paren
(brace
id|FILE
op_star
id|f
op_assign
id|fopen
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;packed-refs&quot;
)paren
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
id|cached_refs.packed
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|f
)paren
(brace
id|read_packed_refs
c_func
(paren
id|f
comma
op_amp
id|cached_refs
)paren
suffix:semicolon
id|fclose
c_func
(paren
id|f
)paren
suffix:semicolon
)brace
id|cached_refs.did_packed
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|cached_refs.packed
suffix:semicolon
)brace
DECL|function|get_ref_dir
r_static
r_struct
id|ref_list
op_star
id|get_ref_dir
c_func
(paren
r_const
r_char
op_star
id|base
comma
r_struct
id|ref_list
op_star
id|list
)paren
(brace
id|DIR
op_star
id|dir
op_assign
id|opendir
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;%s&quot;
comma
id|base
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dir
)paren
(brace
r_struct
id|dirent
op_star
id|de
suffix:semicolon
r_int
id|baselen
op_assign
id|strlen
c_func
(paren
id|base
)paren
suffix:semicolon
r_char
op_star
id|ref
op_assign
id|xmalloc
c_func
(paren
id|baselen
op_plus
l_int|257
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ref
comma
id|base
comma
id|baselen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|baselen
op_logical_and
id|base
(braket
id|baselen
op_minus
l_int|1
)braket
op_ne
l_char|&squot;/&squot;
)paren
id|ref
(braket
id|baselen
op_increment
)braket
op_assign
l_char|&squot;/&squot;
suffix:semicolon
r_while
c_loop
(paren
(paren
id|de
op_assign
id|readdir
c_func
(paren
id|dir
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_struct
id|stat
id|st
suffix:semicolon
r_int
id|flag
suffix:semicolon
r_int
id|namelen
suffix:semicolon
r_if
c_cond
(paren
id|de-&gt;d_name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
)paren
r_continue
suffix:semicolon
id|namelen
op_assign
id|strlen
c_func
(paren
id|de-&gt;d_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|namelen
OG
l_int|255
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|has_extension
c_func
(paren
id|de-&gt;d_name
comma
l_string|&quot;.lock&quot;
)paren
)paren
r_continue
suffix:semicolon
id|memcpy
c_func
(paren
id|ref
op_plus
id|baselen
comma
id|de-&gt;d_name
comma
id|namelen
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;%s&quot;
comma
id|ref
)paren
comma
op_amp
id|st
)paren
OL
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|st.st_mode
)paren
)paren
(brace
id|list
op_assign
id|get_ref_dir
c_func
(paren
id|ref
comma
id|list
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|resolve_ref
c_func
(paren
id|ref
comma
id|sha1
comma
l_int|1
comma
op_amp
id|flag
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;%s points nowhere!&quot;
comma
id|ref
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|list
op_assign
id|add_ref
c_func
(paren
id|ref
comma
id|sha1
comma
id|flag
comma
id|list
comma
l_int|NULL
)paren
suffix:semicolon
)brace
id|free
c_func
(paren
id|ref
)paren
suffix:semicolon
id|closedir
c_func
(paren
id|dir
)paren
suffix:semicolon
)brace
r_return
id|list
suffix:semicolon
)brace
DECL|function|get_loose_refs
r_static
r_struct
id|ref_list
op_star
id|get_loose_refs
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cached_refs.did_loose
)paren
(brace
id|cached_refs.loose
op_assign
id|get_ref_dir
c_func
(paren
l_string|&quot;refs&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|cached_refs.did_loose
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|cached_refs.loose
suffix:semicolon
)brace
multiline_comment|/* We allow &quot;recursive&quot; symbolic refs. Only within reason, though */
DECL|macro|MAXDEPTH
mdefine_line|#define MAXDEPTH 5
DECL|function|resolve_ref
r_const
r_char
op_star
id|resolve_ref
c_func
(paren
r_const
r_char
op_star
id|ref
comma
r_int
r_char
op_star
id|sha1
comma
r_int
id|reading
comma
r_int
op_star
id|flag
)paren
(brace
r_int
id|depth
op_assign
id|MAXDEPTH
comma
id|len
suffix:semicolon
r_char
id|buffer
(braket
l_int|256
)braket
suffix:semicolon
r_static
r_char
id|ref_buffer
(braket
l_int|256
)braket
suffix:semicolon
r_if
c_cond
(paren
id|flag
)paren
op_star
id|flag
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_const
r_char
op_star
id|path
op_assign
id|git_path
c_func
(paren
l_string|&quot;%s&quot;
comma
id|ref
)paren
suffix:semicolon
r_struct
id|stat
id|st
suffix:semicolon
r_char
op_star
id|buf
suffix:semicolon
r_int
id|fd
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|depth
OL
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* Special case: non-existing file.&n;&t;&t; * Not having the refs/heads/new-branch is OK&n;&t;&t; * if we are writing into it, so is .git/HEAD&n;&t;&t; * that points at refs/heads/master still to be&n;&t;&t; * born.  It is NOT OK if we are resolving for&n;&t;&t; * reading.&n;&t;&t; */
r_if
c_cond
(paren
id|lstat
c_func
(paren
id|path
comma
op_amp
id|st
)paren
OL
l_int|0
)paren
(brace
r_struct
id|ref_list
op_star
id|list
op_assign
id|get_packed_refs
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|list
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|ref
comma
id|list-&gt;name
)paren
)paren
(brace
id|hashcpy
c_func
(paren
id|sha1
comma
id|list-&gt;sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flag
)paren
op_star
id|flag
op_or_assign
id|REF_ISPACKED
suffix:semicolon
r_return
id|ref
suffix:semicolon
)brace
id|list
op_assign
id|list-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|reading
op_logical_or
id|errno
op_ne
id|ENOENT
)paren
r_return
l_int|NULL
suffix:semicolon
id|hashclr
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_return
id|ref
suffix:semicolon
)brace
multiline_comment|/* Follow &quot;normalized&quot; - ie &quot;refs/..&quot; symlinks by hand */
r_if
c_cond
(paren
id|S_ISLNK
c_func
(paren
id|st.st_mode
)paren
)paren
(brace
id|len
op_assign
id|readlink
c_func
(paren
id|path
comma
id|buffer
comma
r_sizeof
(paren
id|buffer
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ge
l_int|5
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;refs/&quot;
comma
id|buffer
comma
l_int|5
)paren
)paren
(brace
id|buffer
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
id|strcpy
c_func
(paren
id|ref_buffer
comma
id|buffer
)paren
suffix:semicolon
id|ref
op_assign
id|ref_buffer
suffix:semicolon
r_if
c_cond
(paren
id|flag
)paren
op_star
id|flag
op_or_assign
id|REF_ISSYMREF
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
multiline_comment|/* Is it a directory? */
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|st.st_mode
)paren
)paren
(brace
id|errno
op_assign
id|EISDIR
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Anything else, just open it and try to use it as&n;&t;&t; * a ref&n;&t;&t; */
id|fd
op_assign
id|open
c_func
(paren
id|path
comma
id|O_RDONLY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
id|len
op_assign
id|read
c_func
(paren
id|fd
comma
id|buffer
comma
r_sizeof
(paren
id|buffer
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Is it a symbolic ref?&n;&t;&t; */
r_if
c_cond
(paren
id|len
OL
l_int|4
op_logical_or
id|memcmp
c_func
(paren
l_string|&quot;ref:&quot;
comma
id|buffer
comma
l_int|4
)paren
)paren
r_break
suffix:semicolon
id|buf
op_assign
id|buffer
op_plus
l_int|4
suffix:semicolon
id|len
op_sub_assign
l_int|4
suffix:semicolon
r_while
c_loop
(paren
id|len
op_logical_and
id|isspace
c_func
(paren
op_star
id|buf
)paren
)paren
id|buf
op_increment
comma
id|len
op_decrement
suffix:semicolon
r_while
c_loop
(paren
id|len
op_logical_and
id|isspace
c_func
(paren
id|buf
(braket
id|len
op_minus
l_int|1
)braket
)paren
)paren
id|len
op_decrement
suffix:semicolon
id|buf
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
id|memcpy
c_func
(paren
id|ref_buffer
comma
id|buf
comma
id|len
op_plus
l_int|1
)paren
suffix:semicolon
id|ref
op_assign
id|ref_buffer
suffix:semicolon
r_if
c_cond
(paren
id|flag
)paren
op_star
id|flag
op_or_assign
id|REF_ISSYMREF
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OL
l_int|40
op_logical_or
id|get_sha1_hex
c_func
(paren
id|buffer
comma
id|sha1
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|ref
suffix:semicolon
)brace
DECL|function|create_symref
r_int
id|create_symref
c_func
(paren
r_const
r_char
op_star
id|ref_target
comma
r_const
r_char
op_star
id|refs_heads_master
)paren
(brace
r_const
r_char
op_star
id|lockpath
suffix:semicolon
r_char
id|ref
(braket
l_int|1000
)braket
suffix:semicolon
r_int
id|fd
comma
id|len
comma
id|written
suffix:semicolon
r_const
r_char
op_star
id|git_HEAD
op_assign
id|git_path
c_func
(paren
l_string|&quot;%s&quot;
comma
id|ref_target
)paren
suffix:semicolon
macro_line|#ifndef NO_SYMLINK_HEAD
r_if
c_cond
(paren
id|prefer_symlink_refs
)paren
(brace
id|unlink
c_func
(paren
id|git_HEAD
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|symlink
c_func
(paren
id|refs_heads_master
comma
id|git_HEAD
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;no symlink - falling back to symbolic ref&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|len
op_assign
id|snprintf
c_func
(paren
id|ref
comma
r_sizeof
(paren
id|ref
)paren
comma
l_string|&quot;ref: %s&bslash;n&quot;
comma
id|refs_heads_master
)paren
suffix:semicolon
r_if
c_cond
(paren
r_sizeof
(paren
id|ref
)paren
op_le
id|len
)paren
(brace
id|error
c_func
(paren
l_string|&quot;refname too long: %s&quot;
comma
id|refs_heads_master
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|lockpath
op_assign
id|mkpath
c_func
(paren
l_string|&quot;%s.lock&quot;
comma
id|git_HEAD
)paren
suffix:semicolon
id|fd
op_assign
id|open
c_func
(paren
id|lockpath
comma
id|O_CREAT
op_or
id|O_EXCL
op_or
id|O_WRONLY
comma
l_int|0666
)paren
suffix:semicolon
id|written
op_assign
id|write
c_func
(paren
id|fd
comma
id|ref
comma
id|len
)paren
suffix:semicolon
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|written
op_ne
id|len
)paren
(brace
id|unlink
c_func
(paren
id|lockpath
)paren
suffix:semicolon
id|error
c_func
(paren
l_string|&quot;Unable to write to %s&quot;
comma
id|lockpath
)paren
suffix:semicolon
r_return
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rename
c_func
(paren
id|lockpath
comma
id|git_HEAD
)paren
OL
l_int|0
)paren
(brace
id|unlink
c_func
(paren
id|lockpath
)paren
suffix:semicolon
id|error
c_func
(paren
l_string|&quot;Unable to create %s&quot;
comma
id|git_HEAD
)paren
suffix:semicolon
r_return
l_int|3
suffix:semicolon
)brace
r_if
c_cond
(paren
id|adjust_shared_perm
c_func
(paren
id|git_HEAD
)paren
)paren
(brace
id|unlink
c_func
(paren
id|lockpath
)paren
suffix:semicolon
id|error
c_func
(paren
l_string|&quot;Unable to fix permissions on %s&quot;
comma
id|lockpath
)paren
suffix:semicolon
r_return
l_int|4
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|read_ref
r_int
id|read_ref
c_func
(paren
r_const
r_char
op_star
id|ref
comma
r_int
r_char
op_star
id|sha1
)paren
(brace
r_if
c_cond
(paren
id|resolve_ref
c_func
(paren
id|ref
comma
id|sha1
comma
l_int|1
comma
l_int|NULL
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|do_one_ref
r_static
r_int
id|do_one_ref
c_func
(paren
r_const
r_char
op_star
id|base
comma
id|each_ref_fn
id|fn
comma
r_int
id|trim
comma
r_void
op_star
id|cb_data
comma
r_struct
id|ref_list
op_star
id|entry
)paren
(brace
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|base
comma
id|entry-&gt;name
comma
id|trim
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|is_null_sha1
c_func
(paren
id|entry-&gt;sha1
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|has_sha1_file
c_func
(paren
id|entry-&gt;sha1
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;%s does not point to a valid object!&quot;
comma
id|entry-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|fn
c_func
(paren
id|entry-&gt;name
op_plus
id|trim
comma
id|entry-&gt;sha1
comma
id|entry-&gt;flag
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|peel_ref
r_int
id|peel_ref
c_func
(paren
r_const
r_char
op_star
id|ref
comma
r_int
r_char
op_star
id|sha1
)paren
(brace
r_int
id|flag
suffix:semicolon
r_int
r_char
id|base
(braket
l_int|20
)braket
suffix:semicolon
r_struct
id|object
op_star
id|o
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|resolve_ref
c_func
(paren
id|ref
comma
id|base
comma
l_int|1
comma
op_amp
id|flag
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flag
op_amp
id|REF_ISPACKED
)paren
)paren
(brace
r_struct
id|ref_list
op_star
id|list
op_assign
id|get_packed_refs
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|list
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|list-&gt;name
comma
id|ref
)paren
)paren
(brace
r_if
c_cond
(paren
id|list-&gt;flag
op_amp
id|REF_KNOWS_PEELED
)paren
(brace
id|hashcpy
c_func
(paren
id|sha1
comma
id|list-&gt;peeled
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* older pack-refs did not leave peeled ones */
r_break
suffix:semicolon
)brace
id|list
op_assign
id|list-&gt;next
suffix:semicolon
)brace
)brace
multiline_comment|/* fallback - callers should not call this for unpacked refs */
id|o
op_assign
id|parse_object
c_func
(paren
id|base
)paren
suffix:semicolon
r_if
c_cond
(paren
id|o-&gt;type
op_eq
id|OBJ_TAG
)paren
(brace
id|o
op_assign
id|deref_tag
c_func
(paren
id|o
comma
id|ref
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|o
)paren
(brace
id|hashcpy
c_func
(paren
id|sha1
comma
id|o-&gt;sha1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|do_for_each_ref
r_static
r_int
id|do_for_each_ref
c_func
(paren
r_const
r_char
op_star
id|base
comma
id|each_ref_fn
id|fn
comma
r_int
id|trim
comma
r_void
op_star
id|cb_data
)paren
(brace
r_int
id|retval
suffix:semicolon
r_struct
id|ref_list
op_star
id|packed
op_assign
id|get_packed_refs
c_func
(paren
)paren
suffix:semicolon
r_struct
id|ref_list
op_star
id|loose
op_assign
id|get_loose_refs
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|packed
op_logical_and
id|loose
)paren
(brace
r_struct
id|ref_list
op_star
id|entry
suffix:semicolon
r_int
id|cmp
op_assign
id|strcmp
c_func
(paren
id|packed-&gt;name
comma
id|loose-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmp
)paren
(brace
id|packed
op_assign
id|packed-&gt;next
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmp
OG
l_int|0
)paren
(brace
id|entry
op_assign
id|loose
suffix:semicolon
id|loose
op_assign
id|loose-&gt;next
suffix:semicolon
)brace
r_else
(brace
id|entry
op_assign
id|packed
suffix:semicolon
id|packed
op_assign
id|packed-&gt;next
suffix:semicolon
)brace
id|retval
op_assign
id|do_one_ref
c_func
(paren
id|base
comma
id|fn
comma
id|trim
comma
id|cb_data
comma
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
)brace
r_for
c_loop
(paren
id|packed
op_assign
id|packed
ques
c_cond
id|packed
suffix:colon
id|loose
suffix:semicolon
id|packed
suffix:semicolon
id|packed
op_assign
id|packed-&gt;next
)paren
(brace
id|retval
op_assign
id|do_one_ref
c_func
(paren
id|base
comma
id|fn
comma
id|trim
comma
id|cb_data
comma
id|packed
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|head_ref
r_int
id|head_ref
c_func
(paren
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_int
id|flag
suffix:semicolon
r_if
c_cond
(paren
id|resolve_ref
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|sha1
comma
l_int|1
comma
op_amp
id|flag
)paren
)paren
r_return
id|fn
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|sha1
comma
id|flag
comma
id|cb_data
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|for_each_ref
r_int
id|for_each_ref
c_func
(paren
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|do_for_each_ref
c_func
(paren
l_string|&quot;refs/&quot;
comma
id|fn
comma
l_int|0
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|for_each_tag_ref
r_int
id|for_each_tag_ref
c_func
(paren
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|do_for_each_ref
c_func
(paren
l_string|&quot;refs/tags/&quot;
comma
id|fn
comma
l_int|10
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|for_each_branch_ref
r_int
id|for_each_branch_ref
c_func
(paren
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|do_for_each_ref
c_func
(paren
l_string|&quot;refs/heads/&quot;
comma
id|fn
comma
l_int|11
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|for_each_remote_ref
r_int
id|for_each_remote_ref
c_func
(paren
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|do_for_each_ref
c_func
(paren
l_string|&quot;refs/remotes/&quot;
comma
id|fn
comma
l_int|13
comma
id|cb_data
)paren
suffix:semicolon
)brace
multiline_comment|/* NEEDSWORK: This is only used by ssh-upload and it should go; the&n; * caller should do resolve_ref or read_ref like everybody else.  Or&n; * maybe everybody else should use get_ref_sha1() instead of doing&n; * read_ref().&n; */
DECL|function|get_ref_sha1
r_int
id|get_ref_sha1
c_func
(paren
r_const
r_char
op_star
id|ref
comma
r_int
r_char
op_star
id|sha1
)paren
(brace
r_if
c_cond
(paren
id|check_ref_format
c_func
(paren
id|ref
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
id|read_ref
c_func
(paren
id|mkpath
c_func
(paren
l_string|&quot;refs/%s&quot;
comma
id|ref
)paren
comma
id|sha1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Make sure &quot;ref&quot; is something reasonable to have under &quot;.git/refs/&quot;;&n; * We do not like it if:&n; *&n; * - any path component of it begins with &quot;.&quot;, or&n; * - it has double dots &quot;..&quot;, or&n; * - it has ASCII control character, &quot;~&quot;, &quot;^&quot;, &quot;:&quot; or SP, anywhere, or&n; * - it ends with a &quot;/&quot;.&n; */
DECL|function|bad_ref_char
r_static
r_inline
r_int
id|bad_ref_char
c_func
(paren
r_int
id|ch
)paren
(brace
r_return
(paren
(paren
(paren
r_int
)paren
id|ch
)paren
op_le
l_char|&squot; &squot;
op_logical_or
id|ch
op_eq
l_char|&squot;~&squot;
op_logical_or
id|ch
op_eq
l_char|&squot;^&squot;
op_logical_or
id|ch
op_eq
l_char|&squot;:&squot;
op_logical_or
multiline_comment|/* 2.13 Pattern Matching Notation */
id|ch
op_eq
l_char|&squot;?&squot;
op_logical_or
id|ch
op_eq
l_char|&squot;*&squot;
op_logical_or
id|ch
op_eq
l_char|&squot;[&squot;
)paren
suffix:semicolon
)brace
DECL|function|check_ref_format
r_int
id|check_ref_format
c_func
(paren
r_const
r_char
op_star
id|ref
)paren
(brace
r_int
id|ch
comma
id|level
suffix:semicolon
r_const
r_char
op_star
id|cp
op_assign
id|ref
suffix:semicolon
id|level
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_while
c_loop
(paren
(paren
id|ch
op_assign
op_star
id|cp
op_increment
)paren
op_eq
l_char|&squot;/&squot;
)paren
suffix:semicolon
multiline_comment|/* tolerate duplicated slashes */
r_if
c_cond
(paren
op_logical_neg
id|ch
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* should not end with slashes */
multiline_comment|/* we are at the beginning of the path component */
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;.&squot;
op_logical_or
id|bad_ref_char
c_func
(paren
id|ch
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* scan the rest of the path component */
r_while
c_loop
(paren
(paren
id|ch
op_assign
op_star
id|cp
op_increment
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|bad_ref_char
c_func
(paren
id|ch
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;/&squot;
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;.&squot;
op_logical_and
op_star
id|cp
op_eq
l_char|&squot;.&squot;
)paren
r_return
l_int|1
suffix:semicolon
)brace
id|level
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ch
)paren
(brace
r_if
c_cond
(paren
id|level
OL
l_int|2
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* at least of form &quot;heads/blah&quot; */
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
DECL|function|verify_lock
r_static
r_struct
id|ref_lock
op_star
id|verify_lock
c_func
(paren
r_struct
id|ref_lock
op_star
id|lock
comma
r_const
r_int
r_char
op_star
id|old_sha1
comma
r_int
id|mustexist
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|resolve_ref
c_func
(paren
id|lock-&gt;ref_name
comma
id|lock-&gt;old_sha1
comma
id|mustexist
comma
l_int|NULL
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Can&squot;t verify ref %s&quot;
comma
id|lock-&gt;ref_name
)paren
suffix:semicolon
id|unlock_ref
c_func
(paren
id|lock
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hashcmp
c_func
(paren
id|lock-&gt;old_sha1
comma
id|old_sha1
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Ref %s is at %s but expected %s&quot;
comma
id|lock-&gt;ref_name
comma
id|sha1_to_hex
c_func
(paren
id|lock-&gt;old_sha1
)paren
comma
id|sha1_to_hex
c_func
(paren
id|old_sha1
)paren
)paren
suffix:semicolon
id|unlock_ref
c_func
(paren
id|lock
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|lock
suffix:semicolon
)brace
DECL|function|remove_empty_dir_recursive
r_static
r_int
id|remove_empty_dir_recursive
c_func
(paren
r_char
op_star
id|path
comma
r_int
id|len
)paren
(brace
id|DIR
op_star
id|dir
op_assign
id|opendir
c_func
(paren
id|path
)paren
suffix:semicolon
r_struct
id|dirent
op_star
id|e
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|path
(braket
id|len
op_minus
l_int|1
)braket
op_ne
l_char|&squot;/&squot;
)paren
id|path
(braket
id|len
op_increment
)braket
op_assign
l_char|&squot;/&squot;
suffix:semicolon
r_while
c_loop
(paren
(paren
id|e
op_assign
id|readdir
c_func
(paren
id|dir
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_struct
id|stat
id|st
suffix:semicolon
r_int
id|namlen
suffix:semicolon
r_if
c_cond
(paren
(paren
id|e-&gt;d_name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
)paren
op_logical_and
(paren
(paren
id|e-&gt;d_name
(braket
l_int|1
)braket
op_eq
l_int|0
)paren
op_logical_or
(paren
(paren
id|e-&gt;d_name
(braket
l_int|1
)braket
op_eq
l_char|&squot;.&squot;
)paren
op_logical_and
id|e-&gt;d_name
(braket
l_int|2
)braket
op_eq
l_int|0
)paren
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* &quot;.&quot; and &quot;..&quot; */
id|namlen
op_assign
id|strlen
c_func
(paren
id|e-&gt;d_name
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_plus
id|namlen
OL
id|PATH_MAX
)paren
op_logical_and
id|strcpy
c_func
(paren
id|path
op_plus
id|len
comma
id|e-&gt;d_name
)paren
op_logical_and
op_logical_neg
id|lstat
c_func
(paren
id|path
comma
op_amp
id|st
)paren
op_logical_and
id|S_ISDIR
c_func
(paren
id|st.st_mode
)paren
op_logical_and
op_logical_neg
id|remove_empty_dir_recursive
c_func
(paren
id|path
comma
id|len
op_plus
id|namlen
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* happy */
multiline_comment|/* path too long, stat fails, or non-directory still exists */
id|ret
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|closedir
c_func
(paren
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
id|path
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
id|rmdir
c_func
(paren
id|path
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|remove_empty_directories
r_static
r_int
id|remove_empty_directories
c_func
(paren
r_char
op_star
id|file
)paren
(brace
multiline_comment|/* we want to create a file but there is a directory there;&n;&t; * if that is an empty directory (or a directory that contains&n;&t; * only empty directories), remove them.&n;&t; */
r_char
id|path
(braket
id|PATH_MAX
)braket
suffix:semicolon
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ge
id|PATH_MAX
)paren
multiline_comment|/* path too long ;-) */
r_return
l_int|1
suffix:semicolon
id|strcpy
c_func
(paren
id|path
comma
id|file
)paren
suffix:semicolon
r_return
id|remove_empty_dir_recursive
c_func
(paren
id|path
comma
id|len
)paren
suffix:semicolon
)brace
DECL|function|is_refname_available
r_static
r_int
id|is_refname_available
c_func
(paren
r_const
r_char
op_star
id|ref
comma
r_const
r_char
op_star
id|oldref
comma
r_struct
id|ref_list
op_star
id|list
comma
r_int
id|quiet
)paren
(brace
r_int
id|namlen
op_assign
id|strlen
c_func
(paren
id|ref
)paren
suffix:semicolon
multiline_comment|/* e.g. &squot;foo/bar&squot; */
r_while
c_loop
(paren
id|list
)paren
(brace
multiline_comment|/* list-&gt;name could be &squot;foo&squot; or &squot;foo/bar/baz&squot; */
r_if
c_cond
(paren
op_logical_neg
id|oldref
op_logical_or
id|strcmp
c_func
(paren
id|oldref
comma
id|list-&gt;name
)paren
)paren
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|list-&gt;name
)paren
suffix:semicolon
r_int
id|cmplen
op_assign
(paren
id|namlen
OL
id|len
)paren
ques
c_cond
id|namlen
suffix:colon
id|len
suffix:semicolon
r_const
r_char
op_star
id|lead
op_assign
(paren
id|namlen
OL
id|len
)paren
ques
c_cond
id|list-&gt;name
suffix:colon
id|ref
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|ref
comma
id|list-&gt;name
comma
id|cmplen
)paren
op_logical_and
id|lead
(braket
id|cmplen
)braket
op_eq
l_char|&squot;/&squot;
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|quiet
)paren
id|error
c_func
(paren
l_string|&quot;&squot;%s&squot; exists; cannot create &squot;%s&squot;&quot;
comma
id|list-&gt;name
comma
id|ref
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|list
op_assign
id|list-&gt;next
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|lock_ref_sha1_basic
r_static
r_struct
id|ref_lock
op_star
id|lock_ref_sha1_basic
c_func
(paren
r_const
r_char
op_star
id|ref
comma
r_const
r_int
r_char
op_star
id|old_sha1
comma
r_int
op_star
id|flag
)paren
(brace
r_char
op_star
id|ref_file
suffix:semicolon
r_const
r_char
op_star
id|orig_ref
op_assign
id|ref
suffix:semicolon
r_struct
id|ref_lock
op_star
id|lock
suffix:semicolon
r_struct
id|stat
id|st
suffix:semicolon
r_int
id|last_errno
op_assign
l_int|0
suffix:semicolon
r_int
id|mustexist
op_assign
(paren
id|old_sha1
op_logical_and
op_logical_neg
id|is_null_sha1
c_func
(paren
id|old_sha1
)paren
)paren
suffix:semicolon
id|lock
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|ref_lock
)paren
)paren
suffix:semicolon
id|lock-&gt;lock_fd
op_assign
l_int|1
suffix:semicolon
id|ref
op_assign
id|resolve_ref
c_func
(paren
id|ref
comma
id|lock-&gt;old_sha1
comma
id|mustexist
comma
id|flag
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ref
op_logical_and
id|errno
op_eq
id|EISDIR
)paren
(brace
multiline_comment|/* we are trying to lock foo but we used to&n;&t;&t; * have foo/bar which now does not exist;&n;&t;&t; * it is normal for the empty directory &squot;foo&squot;&n;&t;&t; * to remain.&n;&t;&t; */
id|ref_file
op_assign
id|git_path
c_func
(paren
l_string|&quot;%s&quot;
comma
id|orig_ref
)paren
suffix:semicolon
r_if
c_cond
(paren
id|remove_empty_directories
c_func
(paren
id|ref_file
)paren
)paren
(brace
id|last_errno
op_assign
id|errno
suffix:semicolon
id|error
c_func
(paren
l_string|&quot;there are still refs under &squot;%s&squot;&quot;
comma
id|orig_ref
)paren
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
id|ref
op_assign
id|resolve_ref
c_func
(paren
id|orig_ref
comma
id|lock-&gt;old_sha1
comma
id|mustexist
comma
id|flag
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ref
)paren
(brace
id|last_errno
op_assign
id|errno
suffix:semicolon
id|error
c_func
(paren
l_string|&quot;unable to resolve reference %s: %s&quot;
comma
id|orig_ref
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
multiline_comment|/* When the ref did not exist and we are creating it,&n;&t; * make sure there is no existing ref that is packed&n;&t; * whose name begins with our refname, nor a ref whose&n;&t; * name is a proper prefix of our refname.&n;&t; */
r_if
c_cond
(paren
id|is_null_sha1
c_func
(paren
id|lock-&gt;old_sha1
)paren
op_logical_and
op_logical_neg
id|is_refname_available
c_func
(paren
id|ref
comma
l_int|NULL
comma
id|get_packed_refs
c_func
(paren
)paren
comma
l_int|0
)paren
)paren
r_goto
id|error_return
suffix:semicolon
id|lock-&gt;lk
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|lock_file
)paren
)paren
suffix:semicolon
id|lock-&gt;ref_name
op_assign
id|xstrdup
c_func
(paren
id|ref
)paren
suffix:semicolon
id|lock-&gt;log_file
op_assign
id|xstrdup
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|ref
)paren
)paren
suffix:semicolon
id|ref_file
op_assign
id|git_path
c_func
(paren
l_string|&quot;%s&quot;
comma
id|ref
)paren
suffix:semicolon
id|lock-&gt;force_write
op_assign
id|lstat
c_func
(paren
id|ref_file
comma
op_amp
id|st
)paren
op_logical_and
id|errno
op_eq
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
id|safe_create_leading_directories
c_func
(paren
id|ref_file
)paren
)paren
(brace
id|last_errno
op_assign
id|errno
suffix:semicolon
id|error
c_func
(paren
l_string|&quot;unable to create directory for %s&quot;
comma
id|ref_file
)paren
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
id|lock-&gt;lock_fd
op_assign
id|hold_lock_file_for_update
c_func
(paren
id|lock-&gt;lk
comma
id|ref_file
comma
l_int|1
)paren
suffix:semicolon
r_return
id|old_sha1
ques
c_cond
id|verify_lock
c_func
(paren
id|lock
comma
id|old_sha1
comma
id|mustexist
)paren
suffix:colon
id|lock
suffix:semicolon
id|error_return
suffix:colon
id|unlock_ref
c_func
(paren
id|lock
)paren
suffix:semicolon
id|errno
op_assign
id|last_errno
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|lock_ref_sha1
r_struct
id|ref_lock
op_star
id|lock_ref_sha1
c_func
(paren
r_const
r_char
op_star
id|ref
comma
r_const
r_int
r_char
op_star
id|old_sha1
)paren
(brace
r_char
id|refpath
(braket
id|PATH_MAX
)braket
suffix:semicolon
r_if
c_cond
(paren
id|check_ref_format
c_func
(paren
id|ref
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|strcpy
c_func
(paren
id|refpath
comma
id|mkpath
c_func
(paren
l_string|&quot;refs/%s&quot;
comma
id|ref
)paren
)paren
suffix:semicolon
r_return
id|lock_ref_sha1_basic
c_func
(paren
id|refpath
comma
id|old_sha1
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|lock_any_ref_for_update
r_struct
id|ref_lock
op_star
id|lock_any_ref_for_update
c_func
(paren
r_const
r_char
op_star
id|ref
comma
r_const
r_int
r_char
op_star
id|old_sha1
)paren
(brace
r_return
id|lock_ref_sha1_basic
c_func
(paren
id|ref
comma
id|old_sha1
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|variable|packlock
r_static
r_struct
id|lock_file
id|packlock
suffix:semicolon
DECL|function|repack_without_ref
r_static
r_int
id|repack_without_ref
c_func
(paren
r_const
r_char
op_star
id|refname
)paren
(brace
r_struct
id|ref_list
op_star
id|list
comma
op_star
id|packed_ref_list
suffix:semicolon
r_int
id|fd
suffix:semicolon
r_int
id|found
op_assign
l_int|0
suffix:semicolon
id|packed_ref_list
op_assign
id|get_packed_refs
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|list
op_assign
id|packed_ref_list
suffix:semicolon
id|list
suffix:semicolon
id|list
op_assign
id|list-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|refname
comma
id|list-&gt;name
)paren
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
r_return
l_int|0
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|packlock
comma
l_int|0
comma
r_sizeof
(paren
id|packlock
)paren
)paren
suffix:semicolon
id|fd
op_assign
id|hold_lock_file_for_update
c_func
(paren
op_amp
id|packlock
comma
id|git_path
c_func
(paren
l_string|&quot;packed-refs&quot;
)paren
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
r_return
id|error
c_func
(paren
l_string|&quot;cannot delete &squot;%s&squot; from packed refs&quot;
comma
id|refname
)paren
suffix:semicolon
r_for
c_loop
(paren
id|list
op_assign
id|packed_ref_list
suffix:semicolon
id|list
suffix:semicolon
id|list
op_assign
id|list-&gt;next
)paren
(brace
r_char
id|line
(braket
id|PATH_MAX
op_plus
l_int|100
)braket
suffix:semicolon
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|refname
comma
id|list-&gt;name
)paren
)paren
r_continue
suffix:semicolon
id|len
op_assign
id|snprintf
c_func
(paren
id|line
comma
r_sizeof
(paren
id|line
)paren
comma
l_string|&quot;%s %s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|list-&gt;sha1
)paren
comma
id|list-&gt;name
)paren
suffix:semicolon
multiline_comment|/* this should not happen but just being defensive */
r_if
c_cond
(paren
id|len
OG
r_sizeof
(paren
id|line
)paren
)paren
id|die
c_func
(paren
l_string|&quot;too long a refname &squot;%s&squot;&quot;
comma
id|list-&gt;name
)paren
suffix:semicolon
id|write_or_die
c_func
(paren
id|fd
comma
id|line
comma
id|len
)paren
suffix:semicolon
)brace
r_return
id|commit_lock_file
c_func
(paren
op_amp
id|packlock
)paren
suffix:semicolon
)brace
DECL|function|delete_ref
r_int
id|delete_ref
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_int
r_char
op_star
id|sha1
)paren
(brace
r_struct
id|ref_lock
op_star
id|lock
suffix:semicolon
r_int
id|err
comma
id|i
comma
id|ret
op_assign
l_int|0
comma
id|flag
op_assign
l_int|0
suffix:semicolon
id|lock
op_assign
id|lock_ref_sha1_basic
c_func
(paren
id|refname
comma
id|sha1
comma
op_amp
id|flag
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lock
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flag
op_amp
id|REF_ISPACKED
)paren
)paren
(brace
multiline_comment|/* loose */
id|i
op_assign
id|strlen
c_func
(paren
id|lock-&gt;lk-&gt;filename
)paren
l_int|5
suffix:semicolon
multiline_comment|/* .lock */
id|lock-&gt;lk-&gt;filename
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|err
op_assign
id|unlink
c_func
(paren
id|lock-&gt;lk-&gt;filename
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|ret
op_assign
l_int|1
suffix:semicolon
id|error
c_func
(paren
l_string|&quot;unlink(%s) failed: %s&quot;
comma
id|lock-&gt;lk-&gt;filename
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
)brace
id|lock-&gt;lk-&gt;filename
(braket
id|i
)braket
op_assign
l_char|&squot;.&squot;
suffix:semicolon
)brace
multiline_comment|/* removing the loose one could have resurrected an earlier&n;&t; * packed one.  Also, if it was not loose we need to repack&n;&t; * without it.&n;&t; */
id|ret
op_or_assign
id|repack_without_ref
c_func
(paren
id|refname
)paren
suffix:semicolon
id|err
op_assign
id|unlink
c_func
(paren
id|lock-&gt;log_file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_logical_and
id|errno
op_ne
id|ENOENT
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;warning: unlink(%s) failed: %s&quot;
comma
id|lock-&gt;log_file
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
id|invalidate_cached_refs
c_func
(paren
)paren
suffix:semicolon
id|unlock_ref
c_func
(paren
id|lock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|rename_ref
r_int
id|rename_ref
c_func
(paren
r_const
r_char
op_star
id|oldref
comma
r_const
r_char
op_star
id|newref
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
comma
id|orig_sha1
(braket
l_int|20
)braket
suffix:semicolon
r_int
id|flag
op_assign
l_int|0
comma
id|logmoved
op_assign
l_int|0
suffix:semicolon
r_struct
id|ref_lock
op_star
id|lock
suffix:semicolon
r_char
id|msg
(braket
id|PATH_MAX
op_star
l_int|2
op_plus
l_int|100
)braket
suffix:semicolon
r_struct
id|stat
id|loginfo
suffix:semicolon
r_int
id|log
op_assign
op_logical_neg
id|stat
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|oldref
)paren
comma
op_amp
id|loginfo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|S_ISLNK
c_func
(paren
id|loginfo.st_mode
)paren
)paren
r_return
id|error
c_func
(paren
l_string|&quot;reflog for %s is a symlink&quot;
comma
id|oldref
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|resolve_ref
c_func
(paren
id|oldref
comma
id|orig_sha1
comma
l_int|1
comma
op_amp
id|flag
)paren
)paren
r_return
id|error
c_func
(paren
l_string|&quot;refname %s not found&quot;
comma
id|oldref
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_refname_available
c_func
(paren
id|newref
comma
id|oldref
comma
id|get_packed_refs
c_func
(paren
)paren
comma
l_int|0
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_refname_available
c_func
(paren
id|newref
comma
id|oldref
comma
id|get_loose_refs
c_func
(paren
)paren
comma
l_int|0
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|snprintf
c_func
(paren
id|msg
comma
r_sizeof
(paren
id|msg
)paren
comma
l_string|&quot;renamed %s to %s&quot;
comma
id|oldref
comma
id|newref
)paren
OG
r_sizeof
(paren
id|msg
)paren
)paren
r_return
id|error
c_func
(paren
l_string|&quot;Refnames to long&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|log
op_logical_and
id|rename
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|oldref
)paren
comma
id|git_path
c_func
(paren
l_string|&quot;tmp-renamed-log&quot;
)paren
)paren
)paren
r_return
id|error
c_func
(paren
l_string|&quot;unable to move logfile logs/%s to tmp-renamed-log: %s&quot;
comma
id|oldref
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|delete_ref
c_func
(paren
id|oldref
comma
id|orig_sha1
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;unable to delete old %s&quot;
comma
id|oldref
)paren
suffix:semicolon
r_goto
id|rollback
suffix:semicolon
)brace
r_if
c_cond
(paren
id|resolve_ref
c_func
(paren
id|newref
comma
id|sha1
comma
l_int|1
comma
op_amp
id|flag
)paren
op_logical_and
id|delete_ref
c_func
(paren
id|newref
comma
id|sha1
)paren
)paren
(brace
r_if
c_cond
(paren
id|errno
op_eq
id|EISDIR
)paren
(brace
r_if
c_cond
(paren
id|remove_empty_directories
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;%s&quot;
comma
id|newref
)paren
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Directory not empty: %s&quot;
comma
id|newref
)paren
suffix:semicolon
r_goto
id|rollback
suffix:semicolon
)brace
)brace
r_else
(brace
id|error
c_func
(paren
l_string|&quot;unable to delete existing %s&quot;
comma
id|newref
)paren
suffix:semicolon
r_goto
id|rollback
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|log
op_logical_and
id|safe_create_leading_directories
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|newref
)paren
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;unable to create directory for %s&quot;
comma
id|newref
)paren
suffix:semicolon
r_goto
id|rollback
suffix:semicolon
)brace
id|retry
suffix:colon
r_if
c_cond
(paren
id|log
op_logical_and
id|rename
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;tmp-renamed-log&quot;
)paren
comma
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|newref
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|errno
op_eq
id|EISDIR
)paren
(brace
r_if
c_cond
(paren
id|remove_empty_directories
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|newref
)paren
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Directory not empty: logs/%s&quot;
comma
id|newref
)paren
suffix:semicolon
r_goto
id|rollback
suffix:semicolon
)brace
r_goto
id|retry
suffix:semicolon
)brace
r_else
(brace
id|error
c_func
(paren
l_string|&quot;unable to move logfile tmp-renamed-log to logs/%s: %s&quot;
comma
id|newref
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_goto
id|rollback
suffix:semicolon
)brace
)brace
id|logmoved
op_assign
id|log
suffix:semicolon
id|lock
op_assign
id|lock_ref_sha1_basic
c_func
(paren
id|newref
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lock
)paren
(brace
id|error
c_func
(paren
l_string|&quot;unable to lock %s for update&quot;
comma
id|newref
)paren
suffix:semicolon
r_goto
id|rollback
suffix:semicolon
)brace
id|lock-&gt;force_write
op_assign
l_int|1
suffix:semicolon
id|hashcpy
c_func
(paren
id|lock-&gt;old_sha1
comma
id|orig_sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write_ref_sha1
c_func
(paren
id|lock
comma
id|orig_sha1
comma
id|msg
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;unable to write current sha1 into %s&quot;
comma
id|newref
)paren
suffix:semicolon
r_goto
id|rollback
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|rollback
suffix:colon
id|lock
op_assign
id|lock_ref_sha1_basic
c_func
(paren
id|oldref
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lock
)paren
(brace
id|error
c_func
(paren
l_string|&quot;unable to lock %s for rollback&quot;
comma
id|oldref
)paren
suffix:semicolon
r_goto
id|rollbacklog
suffix:semicolon
)brace
id|lock-&gt;force_write
op_assign
l_int|1
suffix:semicolon
id|flag
op_assign
id|log_all_ref_updates
suffix:semicolon
id|log_all_ref_updates
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|write_ref_sha1
c_func
(paren
id|lock
comma
id|orig_sha1
comma
l_int|NULL
)paren
)paren
id|error
c_func
(paren
l_string|&quot;unable to write current sha1 into %s&quot;
comma
id|oldref
)paren
suffix:semicolon
id|log_all_ref_updates
op_assign
id|flag
suffix:semicolon
id|rollbacklog
suffix:colon
r_if
c_cond
(paren
id|logmoved
op_logical_and
id|rename
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|newref
)paren
comma
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|oldref
)paren
)paren
)paren
id|error
c_func
(paren
l_string|&quot;unable to restore logfile %s from %s: %s&quot;
comma
id|oldref
comma
id|newref
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|logmoved
op_logical_and
id|log
op_logical_and
id|rename
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;tmp-renamed-log&quot;
)paren
comma
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|oldref
)paren
)paren
)paren
id|error
c_func
(paren
l_string|&quot;unable to restore logfile %s from tmp-renamed-log: %s&quot;
comma
id|oldref
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|unlock_ref
r_void
id|unlock_ref
c_func
(paren
r_struct
id|ref_lock
op_star
id|lock
)paren
(brace
r_if
c_cond
(paren
id|lock-&gt;lock_fd
op_ge
l_int|0
)paren
(brace
id|close
c_func
(paren
id|lock-&gt;lock_fd
)paren
suffix:semicolon
multiline_comment|/* Do not free lock-&gt;lk -- atexit() still looks at them */
r_if
c_cond
(paren
id|lock-&gt;lk
)paren
id|rollback_lock_file
c_func
(paren
id|lock-&gt;lk
)paren
suffix:semicolon
)brace
id|free
c_func
(paren
id|lock-&gt;ref_name
)paren
suffix:semicolon
id|free
c_func
(paren
id|lock-&gt;log_file
)paren
suffix:semicolon
id|free
c_func
(paren
id|lock
)paren
suffix:semicolon
)brace
DECL|function|log_ref_write
r_static
r_int
id|log_ref_write
c_func
(paren
r_struct
id|ref_lock
op_star
id|lock
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_const
r_char
op_star
id|msg
)paren
(brace
r_int
id|logfd
comma
id|written
comma
id|oflags
op_assign
id|O_APPEND
op_or
id|O_WRONLY
suffix:semicolon
r_int
id|maxlen
comma
id|len
suffix:semicolon
r_char
op_star
id|logrec
suffix:semicolon
r_const
r_char
op_star
id|committer
suffix:semicolon
r_if
c_cond
(paren
id|log_all_ref_updates
op_logical_and
op_logical_neg
id|strncmp
c_func
(paren
id|lock-&gt;ref_name
comma
l_string|&quot;refs/heads/&quot;
comma
l_int|11
)paren
)paren
(brace
r_if
c_cond
(paren
id|safe_create_leading_directories
c_func
(paren
id|lock-&gt;log_file
)paren
OL
l_int|0
)paren
r_return
id|error
c_func
(paren
l_string|&quot;unable to create directory for %s&quot;
comma
id|lock-&gt;log_file
)paren
suffix:semicolon
id|oflags
op_or_assign
id|O_CREAT
suffix:semicolon
)brace
id|logfd
op_assign
id|open
c_func
(paren
id|lock-&gt;log_file
comma
id|oflags
comma
l_int|0666
)paren
suffix:semicolon
r_if
c_cond
(paren
id|logfd
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|oflags
op_amp
id|O_CREAT
)paren
op_logical_and
id|errno
op_eq
id|ENOENT
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|oflags
op_amp
id|O_CREAT
)paren
op_logical_and
id|errno
op_eq
id|EISDIR
)paren
(brace
r_if
c_cond
(paren
id|remove_empty_directories
c_func
(paren
id|lock-&gt;log_file
)paren
)paren
(brace
r_return
id|error
c_func
(paren
l_string|&quot;There are still logs under &squot;%s&squot;&quot;
comma
id|lock-&gt;log_file
)paren
suffix:semicolon
)brace
id|logfd
op_assign
id|open
c_func
(paren
id|lock-&gt;log_file
comma
id|oflags
comma
l_int|0666
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|logfd
OL
l_int|0
)paren
r_return
id|error
c_func
(paren
l_string|&quot;Unable to append to %s: %s&quot;
comma
id|lock-&gt;log_file
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
)brace
id|committer
op_assign
id|git_committer_info
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg
)paren
(brace
id|maxlen
op_assign
id|strlen
c_func
(paren
id|committer
)paren
op_plus
id|strlen
c_func
(paren
id|msg
)paren
op_plus
l_int|2
op_star
l_int|40
op_plus
l_int|5
suffix:semicolon
id|logrec
op_assign
id|xmalloc
c_func
(paren
id|maxlen
)paren
suffix:semicolon
id|len
op_assign
id|snprintf
c_func
(paren
id|logrec
comma
id|maxlen
comma
l_string|&quot;%s %s %s&bslash;t%s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|lock-&gt;old_sha1
)paren
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
comma
id|committer
comma
id|msg
)paren
suffix:semicolon
)brace
r_else
(brace
id|maxlen
op_assign
id|strlen
c_func
(paren
id|committer
)paren
op_plus
l_int|2
op_star
l_int|40
op_plus
l_int|4
suffix:semicolon
id|logrec
op_assign
id|xmalloc
c_func
(paren
id|maxlen
)paren
suffix:semicolon
id|len
op_assign
id|snprintf
c_func
(paren
id|logrec
comma
id|maxlen
comma
l_string|&quot;%s %s %s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|lock-&gt;old_sha1
)paren
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
comma
id|committer
)paren
suffix:semicolon
)brace
id|written
op_assign
id|len
op_le
id|maxlen
ques
c_cond
id|write
c_func
(paren
id|logfd
comma
id|logrec
comma
id|len
)paren
suffix:colon
l_int|1
suffix:semicolon
id|free
c_func
(paren
id|logrec
)paren
suffix:semicolon
id|close
c_func
(paren
id|logfd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|written
op_ne
id|len
)paren
r_return
id|error
c_func
(paren
l_string|&quot;Unable to append to %s&quot;
comma
id|lock-&gt;log_file
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|write_ref_sha1
r_int
id|write_ref_sha1
c_func
(paren
r_struct
id|ref_lock
op_star
id|lock
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_const
r_char
op_star
id|logmsg
)paren
(brace
r_static
r_char
id|term
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lock
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lock-&gt;force_write
op_logical_and
op_logical_neg
id|hashcmp
c_func
(paren
id|lock-&gt;old_sha1
comma
id|sha1
)paren
)paren
(brace
id|unlock_ref
c_func
(paren
id|lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|write
c_func
(paren
id|lock-&gt;lock_fd
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
comma
l_int|40
)paren
op_ne
l_int|40
op_logical_or
id|write
c_func
(paren
id|lock-&gt;lock_fd
comma
op_amp
id|term
comma
l_int|1
)paren
op_ne
l_int|1
op_logical_or
id|close
c_func
(paren
id|lock-&gt;lock_fd
)paren
OL
l_int|0
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Couldn&squot;t write %s&quot;
comma
id|lock-&gt;lk-&gt;filename
)paren
suffix:semicolon
id|unlock_ref
c_func
(paren
id|lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|invalidate_cached_refs
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|log_ref_write
c_func
(paren
id|lock
comma
id|sha1
comma
id|logmsg
)paren
OL
l_int|0
)paren
(brace
id|unlock_ref
c_func
(paren
id|lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|commit_lock_file
c_func
(paren
id|lock-&gt;lk
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Couldn&squot;t set %s&quot;
comma
id|lock-&gt;ref_name
)paren
suffix:semicolon
id|unlock_ref
c_func
(paren
id|lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|lock-&gt;lock_fd
op_assign
l_int|1
suffix:semicolon
id|unlock_ref
c_func
(paren
id|lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|read_ref_at
r_int
id|read_ref_at
c_func
(paren
r_const
r_char
op_star
id|ref
comma
r_int
r_int
id|at_time
comma
r_int
id|cnt
comma
r_int
r_char
op_star
id|sha1
)paren
(brace
r_const
r_char
op_star
id|logfile
comma
op_star
id|logdata
comma
op_star
id|logend
comma
op_star
id|rec
comma
op_star
id|lastgt
comma
op_star
id|lastrec
suffix:semicolon
r_char
op_star
id|tz_c
suffix:semicolon
r_int
id|logfd
comma
id|tz
suffix:semicolon
r_struct
id|stat
id|st
suffix:semicolon
r_int
r_int
id|date
suffix:semicolon
r_int
r_char
id|logged_sha1
(braket
l_int|20
)braket
suffix:semicolon
id|logfile
op_assign
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|ref
)paren
suffix:semicolon
id|logfd
op_assign
id|open
c_func
(paren
id|logfile
comma
id|O_RDONLY
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|logfd
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;Unable to read log %s: %s&quot;
comma
id|logfile
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
id|fstat
c_func
(paren
id|logfd
comma
op_amp
id|st
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|st.st_size
)paren
id|die
c_func
(paren
l_string|&quot;Log %s is empty.&quot;
comma
id|logfile
)paren
suffix:semicolon
id|logdata
op_assign
id|mmap
c_func
(paren
l_int|NULL
comma
id|st.st_size
comma
id|PROT_READ
comma
id|MAP_PRIVATE
comma
id|logfd
comma
l_int|0
)paren
suffix:semicolon
id|close
c_func
(paren
id|logfd
)paren
suffix:semicolon
id|lastrec
op_assign
l_int|NULL
suffix:semicolon
id|rec
op_assign
id|logend
op_assign
id|logdata
op_plus
id|st.st_size
suffix:semicolon
r_while
c_loop
(paren
id|logdata
OL
id|rec
)paren
(brace
r_if
c_cond
(paren
id|logdata
OL
id|rec
op_logical_and
op_star
(paren
id|rec
op_minus
l_int|1
)paren
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|rec
op_decrement
suffix:semicolon
id|lastgt
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|logdata
OL
id|rec
op_logical_and
op_star
(paren
id|rec
op_minus
l_int|1
)paren
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|rec
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_star
id|rec
op_eq
l_char|&squot;&gt;&squot;
)paren
id|lastgt
op_assign
id|rec
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|lastgt
)paren
id|die
c_func
(paren
l_string|&quot;Log %s is corrupt.&quot;
comma
id|logfile
)paren
suffix:semicolon
id|date
op_assign
id|strtoul
c_func
(paren
id|lastgt
op_plus
l_int|1
comma
op_amp
id|tz_c
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|date
op_le
id|at_time
op_logical_or
id|cnt
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|lastrec
)paren
(brace
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|lastrec
comma
id|logged_sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Log %s is corrupt.&quot;
comma
id|logfile
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|rec
op_plus
l_int|41
comma
id|sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Log %s is corrupt.&quot;
comma
id|logfile
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hashcmp
c_func
(paren
id|logged_sha1
comma
id|sha1
)paren
)paren
(brace
id|tz
op_assign
id|strtoul
c_func
(paren
id|tz_c
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;warning: Log %s has gap after %s.&bslash;n&quot;
comma
id|logfile
comma
id|show_rfc2822_date
c_func
(paren
id|date
comma
id|tz
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|date
op_eq
id|at_time
)paren
(brace
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|rec
op_plus
l_int|41
comma
id|sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Log %s is corrupt.&quot;
comma
id|logfile
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|rec
op_plus
l_int|41
comma
id|logged_sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Log %s is corrupt.&quot;
comma
id|logfile
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hashcmp
c_func
(paren
id|logged_sha1
comma
id|sha1
)paren
)paren
(brace
id|tz
op_assign
id|strtoul
c_func
(paren
id|tz_c
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;warning: Log %s unexpectedly ended on %s.&bslash;n&quot;
comma
id|logfile
comma
id|show_rfc2822_date
c_func
(paren
id|date
comma
id|tz
)paren
)paren
suffix:semicolon
)brace
)brace
id|munmap
c_func
(paren
(paren
r_void
op_star
)paren
id|logdata
comma
id|st.st_size
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|lastrec
op_assign
id|rec
suffix:semicolon
r_if
c_cond
(paren
id|cnt
OG
l_int|0
)paren
id|cnt
op_decrement
suffix:semicolon
)brace
id|rec
op_assign
id|logdata
suffix:semicolon
r_while
c_loop
(paren
id|rec
OL
id|logend
op_logical_and
op_star
id|rec
op_ne
l_char|&squot;&gt;&squot;
op_logical_and
op_star
id|rec
op_ne
l_char|&squot;&bslash;n&squot;
)paren
id|rec
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|rec
op_eq
id|logend
op_logical_or
op_star
id|rec
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|die
c_func
(paren
l_string|&quot;Log %s is corrupt.&quot;
comma
id|logfile
)paren
suffix:semicolon
id|date
op_assign
id|strtoul
c_func
(paren
id|rec
op_plus
l_int|1
comma
op_amp
id|tz_c
comma
l_int|10
)paren
suffix:semicolon
id|tz
op_assign
id|strtoul
c_func
(paren
id|tz_c
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|logdata
comma
id|sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Log %s is corrupt.&quot;
comma
id|logfile
)paren
suffix:semicolon
id|munmap
c_func
(paren
(paren
r_void
op_star
)paren
id|logdata
comma
id|st.st_size
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;warning: Log %s only goes back to %s.&bslash;n&quot;
comma
id|logfile
comma
id|show_rfc2822_date
c_func
(paren
id|date
comma
id|tz
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
