macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;refs.h&quot;
macro_line|#include &quot;object.h&quot;
macro_line|#include &quot;tag.h&quot;
macro_line|#include &quot;dir.h&quot;
multiline_comment|/* ISSYMREF=01 and ISPACKED=02 are public interfaces */
DECL|macro|REF_KNOWS_PEELED
mdefine_line|#define REF_KNOWS_PEELED 04
DECL|macro|REF_BROKEN
mdefine_line|#define REF_BROKEN 010
DECL|struct|ref_entry
r_struct
id|ref_entry
(brace
DECL|member|flag
r_int
r_char
id|flag
suffix:semicolon
multiline_comment|/* ISSYMREF? ISPACKED? */
DECL|member|sha1
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
DECL|member|peeled
r_int
r_char
id|peeled
(braket
l_int|20
)braket
suffix:semicolon
DECL|member|name
r_char
id|name
(braket
id|FLEX_ARRAY
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|ref_array
r_struct
id|ref_array
(brace
DECL|member|nr
DECL|member|alloc
r_int
id|nr
comma
id|alloc
suffix:semicolon
DECL|member|refs
r_struct
id|ref_entry
op_star
op_star
id|refs
suffix:semicolon
)brace
suffix:semicolon
DECL|function|parse_ref_line
r_static
r_const
r_char
op_star
id|parse_ref_line
c_func
(paren
r_char
op_star
id|line
comma
r_int
r_char
op_star
id|sha1
)paren
(brace
multiline_comment|/*&n;&t; * 42: the answer to everything.&n;&t; *&n;&t; * In this case, it happens to be the answer to&n;&t; *  40 (length of sha1 hex representation)&n;&t; *  +1 (space in between hex and name)&n;&t; *  +1 (newline at the end of the line)&n;&t; */
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|line
)paren
l_int|42
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|line
comma
id|sha1
)paren
OL
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|isspace
c_func
(paren
id|line
(braket
l_int|40
)braket
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|line
op_add_assign
l_int|41
suffix:semicolon
r_if
c_cond
(paren
id|isspace
c_func
(paren
op_star
id|line
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|line
(braket
id|len
)braket
op_ne
l_char|&squot;&bslash;n&squot;
)paren
r_return
l_int|NULL
suffix:semicolon
id|line
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
r_return
id|line
suffix:semicolon
)brace
DECL|function|add_ref
r_static
r_void
id|add_ref
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
id|flag
comma
r_struct
id|ref_array
op_star
id|refs
comma
r_struct
id|ref_entry
op_star
op_star
id|new_entry
)paren
(brace
r_int
id|len
suffix:semicolon
r_struct
id|ref_entry
op_star
id|entry
suffix:semicolon
multiline_comment|/* Allocate it and add it in.. */
id|len
op_assign
id|strlen
c_func
(paren
id|name
)paren
op_plus
l_int|1
suffix:semicolon
id|entry
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ref_entry
)paren
op_plus
id|len
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|entry-&gt;sha1
comma
id|sha1
)paren
suffix:semicolon
id|hashclr
c_func
(paren
id|entry-&gt;peeled
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|entry-&gt;name
comma
id|name
comma
id|len
)paren
suffix:semicolon
id|entry-&gt;flag
op_assign
id|flag
suffix:semicolon
r_if
c_cond
(paren
id|new_entry
)paren
op_star
id|new_entry
op_assign
id|entry
suffix:semicolon
id|ALLOC_GROW
c_func
(paren
id|refs-&gt;refs
comma
id|refs-&gt;nr
op_plus
l_int|1
comma
id|refs-&gt;alloc
)paren
suffix:semicolon
id|refs-&gt;refs
(braket
id|refs-&gt;nr
op_increment
)braket
op_assign
id|entry
suffix:semicolon
)brace
DECL|function|ref_entry_cmp
r_static
r_int
id|ref_entry_cmp
c_func
(paren
r_const
r_void
op_star
id|a
comma
r_const
r_void
op_star
id|b
)paren
(brace
r_struct
id|ref_entry
op_star
id|one
op_assign
op_star
(paren
r_struct
id|ref_entry
op_star
op_star
)paren
id|a
suffix:semicolon
r_struct
id|ref_entry
op_star
id|two
op_assign
op_star
(paren
r_struct
id|ref_entry
op_star
op_star
)paren
id|b
suffix:semicolon
r_return
id|strcmp
c_func
(paren
id|one-&gt;name
comma
id|two-&gt;name
)paren
suffix:semicolon
)brace
DECL|function|sort_ref_array
r_static
r_void
id|sort_ref_array
c_func
(paren
r_struct
id|ref_array
op_star
id|array
)paren
(brace
r_int
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Nothing to sort unless there are at least two entries */
r_if
c_cond
(paren
id|array-&gt;nr
OL
l_int|2
)paren
r_return
suffix:semicolon
id|qsort
c_func
(paren
id|array-&gt;refs
comma
id|array-&gt;nr
comma
r_sizeof
(paren
op_star
id|array-&gt;refs
)paren
comma
id|ref_entry_cmp
)paren
suffix:semicolon
multiline_comment|/* Remove any duplicates from the ref_array */
r_for
c_loop
(paren
suffix:semicolon
id|j
OL
id|array-&gt;nr
suffix:semicolon
id|j
op_increment
)paren
(brace
r_struct
id|ref_entry
op_star
id|a
op_assign
id|array-&gt;refs
(braket
id|i
)braket
suffix:semicolon
r_struct
id|ref_entry
op_star
id|b
op_assign
id|array-&gt;refs
(braket
id|j
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|a-&gt;name
comma
id|b-&gt;name
)paren
)paren
(brace
r_if
c_cond
(paren
id|hashcmp
c_func
(paren
id|a-&gt;sha1
comma
id|b-&gt;sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Duplicated ref, and SHA1s don&squot;t match: %s&quot;
comma
id|a-&gt;name
)paren
suffix:semicolon
id|warning
c_func
(paren
l_string|&quot;Duplicated ref: %s&quot;
comma
id|a-&gt;name
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|i
op_increment
suffix:semicolon
id|array-&gt;refs
(braket
id|i
)braket
op_assign
id|array-&gt;refs
(braket
id|j
)braket
suffix:semicolon
)brace
id|array-&gt;nr
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
)brace
DECL|function|search_ref_array
r_static
r_struct
id|ref_entry
op_star
id|search_ref_array
c_func
(paren
r_struct
id|ref_array
op_star
id|array
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|ref_entry
op_star
id|e
comma
op_star
op_star
id|r
suffix:semicolon
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
id|name
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|name
)paren
op_plus
l_int|1
suffix:semicolon
id|e
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ref_entry
)paren
op_plus
id|len
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|e-&gt;name
comma
id|name
comma
id|len
)paren
suffix:semicolon
id|r
op_assign
id|bsearch
c_func
(paren
op_amp
id|e
comma
id|array-&gt;refs
comma
id|array-&gt;nr
comma
r_sizeof
(paren
op_star
id|array-&gt;refs
)paren
comma
id|ref_entry_cmp
)paren
suffix:semicolon
id|free
c_func
(paren
id|e
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
op_star
id|r
suffix:semicolon
)brace
multiline_comment|/*&n; * Future: need to be in &quot;struct repository&quot;&n; * when doing a full libification.&n; */
DECL|struct|cached_refs
r_static
r_struct
id|cached_refs
(brace
DECL|member|did_loose
r_char
id|did_loose
suffix:semicolon
DECL|member|did_packed
r_char
id|did_packed
suffix:semicolon
DECL|member|loose
r_struct
id|ref_array
id|loose
suffix:semicolon
DECL|member|packed
r_struct
id|ref_array
id|packed
suffix:semicolon
DECL|variable|cached_refs
DECL|variable|submodule_refs
)brace
id|cached_refs
comma
id|submodule_refs
suffix:semicolon
DECL|variable|current_ref
r_static
r_struct
id|ref_entry
op_star
id|current_ref
suffix:semicolon
DECL|variable|extra_refs
r_static
r_struct
id|ref_array
id|extra_refs
suffix:semicolon
DECL|function|free_ref_array
r_static
r_void
id|free_ref_array
c_func
(paren
r_struct
id|ref_array
op_star
id|array
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|array-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
id|free
c_func
(paren
id|array-&gt;refs
(braket
id|i
)braket
)paren
suffix:semicolon
id|free
c_func
(paren
id|array-&gt;refs
)paren
suffix:semicolon
id|array-&gt;nr
op_assign
id|array-&gt;alloc
op_assign
l_int|0
suffix:semicolon
id|array-&gt;refs
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|invalidate_cached_refs
r_static
r_void
id|invalidate_cached_refs
c_func
(paren
r_void
)paren
(brace
r_struct
id|cached_refs
op_star
id|ca
op_assign
op_amp
id|cached_refs
suffix:semicolon
r_if
c_cond
(paren
id|ca-&gt;did_loose
)paren
id|free_ref_array
c_func
(paren
op_amp
id|ca-&gt;loose
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ca-&gt;did_packed
)paren
id|free_ref_array
c_func
(paren
op_amp
id|ca-&gt;packed
)paren
suffix:semicolon
id|ca-&gt;did_loose
op_assign
id|ca-&gt;did_packed
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|read_packed_refs
r_static
r_void
id|read_packed_refs
c_func
(paren
id|FILE
op_star
id|f
comma
r_struct
id|cached_refs
op_star
id|cached_refs
)paren
(brace
r_struct
id|ref_entry
op_star
id|last
op_assign
l_int|NULL
suffix:semicolon
r_char
id|refline
(braket
id|PATH_MAX
)braket
suffix:semicolon
r_int
id|flag
op_assign
id|REF_ISPACKED
suffix:semicolon
r_while
c_loop
(paren
id|fgets
c_func
(paren
id|refline
comma
r_sizeof
(paren
id|refline
)paren
comma
id|f
)paren
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_const
r_char
op_star
id|name
suffix:semicolon
r_static
r_const
r_char
id|header
(braket
)braket
op_assign
l_string|&quot;# pack-refs with:&quot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|refline
comma
id|header
comma
r_sizeof
(paren
id|header
)paren
op_minus
l_int|1
)paren
)paren
(brace
r_const
r_char
op_star
id|traits
op_assign
id|refline
op_plus
r_sizeof
(paren
id|header
)paren
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|traits
comma
l_string|&quot; peeled &quot;
)paren
)paren
id|flag
op_or_assign
id|REF_KNOWS_PEELED
suffix:semicolon
multiline_comment|/* perhaps other traits later as well */
r_continue
suffix:semicolon
)brace
id|name
op_assign
id|parse_ref_line
c_func
(paren
id|refline
comma
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|name
)paren
(brace
id|add_ref
c_func
(paren
id|name
comma
id|sha1
comma
id|flag
comma
op_amp
id|cached_refs-&gt;packed
comma
op_amp
id|last
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|last
op_logical_and
id|refline
(braket
l_int|0
)braket
op_eq
l_char|&squot;^&squot;
op_logical_and
id|strlen
c_func
(paren
id|refline
)paren
op_eq
l_int|42
op_logical_and
id|refline
(braket
l_int|41
)braket
op_eq
l_char|&squot;&bslash;n&squot;
op_logical_and
op_logical_neg
id|get_sha1_hex
c_func
(paren
id|refline
op_plus
l_int|1
comma
id|sha1
)paren
)paren
id|hashcpy
c_func
(paren
id|last-&gt;peeled
comma
id|sha1
)paren
suffix:semicolon
)brace
id|sort_ref_array
c_func
(paren
op_amp
id|cached_refs-&gt;packed
)paren
suffix:semicolon
)brace
DECL|function|add_extra_ref
r_void
id|add_extra_ref
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
id|flag
)paren
(brace
id|add_ref
c_func
(paren
id|name
comma
id|sha1
comma
id|flag
comma
op_amp
id|extra_refs
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|clear_extra_refs
r_void
id|clear_extra_refs
c_func
(paren
r_void
)paren
(brace
id|free_ref_array
c_func
(paren
op_amp
id|extra_refs
)paren
suffix:semicolon
)brace
DECL|function|get_packed_refs
r_static
r_struct
id|ref_array
op_star
id|get_packed_refs
c_func
(paren
r_const
r_char
op_star
id|submodule
)paren
(brace
r_const
r_char
op_star
id|packed_refs_file
suffix:semicolon
r_struct
id|cached_refs
op_star
id|refs
suffix:semicolon
r_if
c_cond
(paren
id|submodule
)paren
(brace
id|packed_refs_file
op_assign
id|git_path_submodule
c_func
(paren
id|submodule
comma
l_string|&quot;packed-refs&quot;
)paren
suffix:semicolon
id|refs
op_assign
op_amp
id|submodule_refs
suffix:semicolon
id|free_ref_array
c_func
(paren
op_amp
id|refs-&gt;packed
)paren
suffix:semicolon
)brace
r_else
(brace
id|packed_refs_file
op_assign
id|git_path
c_func
(paren
l_string|&quot;packed-refs&quot;
)paren
suffix:semicolon
id|refs
op_assign
op_amp
id|cached_refs
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|refs-&gt;did_packed
op_logical_or
id|submodule
)paren
(brace
id|FILE
op_star
id|f
op_assign
id|fopen
c_func
(paren
id|packed_refs_file
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|f
)paren
(brace
id|read_packed_refs
c_func
(paren
id|f
comma
id|refs
)paren
suffix:semicolon
id|fclose
c_func
(paren
id|f
)paren
suffix:semicolon
)brace
id|refs-&gt;did_packed
op_assign
l_int|1
suffix:semicolon
)brace
r_return
op_amp
id|refs-&gt;packed
suffix:semicolon
)brace
DECL|function|get_ref_dir
r_static
r_void
id|get_ref_dir
c_func
(paren
r_const
r_char
op_star
id|submodule
comma
r_const
r_char
op_star
id|base
comma
r_struct
id|ref_array
op_star
id|array
)paren
(brace
id|DIR
op_star
id|dir
suffix:semicolon
r_const
r_char
op_star
id|path
suffix:semicolon
r_if
c_cond
(paren
id|submodule
)paren
id|path
op_assign
id|git_path_submodule
c_func
(paren
id|submodule
comma
l_string|&quot;%s&quot;
comma
id|base
)paren
suffix:semicolon
r_else
id|path
op_assign
id|git_path
c_func
(paren
l_string|&quot;%s&quot;
comma
id|base
)paren
suffix:semicolon
id|dir
op_assign
id|opendir
c_func
(paren
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dir
)paren
(brace
r_struct
id|dirent
op_star
id|de
suffix:semicolon
r_int
id|baselen
op_assign
id|strlen
c_func
(paren
id|base
)paren
suffix:semicolon
r_char
op_star
id|ref
op_assign
id|xmalloc
c_func
(paren
id|baselen
op_plus
l_int|257
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ref
comma
id|base
comma
id|baselen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|baselen
op_logical_and
id|base
(braket
id|baselen
op_minus
l_int|1
)braket
op_ne
l_char|&squot;/&squot;
)paren
id|ref
(braket
id|baselen
op_increment
)braket
op_assign
l_char|&squot;/&squot;
suffix:semicolon
r_while
c_loop
(paren
(paren
id|de
op_assign
id|readdir
c_func
(paren
id|dir
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_struct
id|stat
id|st
suffix:semicolon
r_int
id|flag
suffix:semicolon
r_int
id|namelen
suffix:semicolon
r_const
r_char
op_star
id|refdir
suffix:semicolon
r_if
c_cond
(paren
id|de-&gt;d_name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
)paren
r_continue
suffix:semicolon
id|namelen
op_assign
id|strlen
c_func
(paren
id|de-&gt;d_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|namelen
OG
l_int|255
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|has_extension
c_func
(paren
id|de-&gt;d_name
comma
l_string|&quot;.lock&quot;
)paren
)paren
r_continue
suffix:semicolon
id|memcpy
c_func
(paren
id|ref
op_plus
id|baselen
comma
id|de-&gt;d_name
comma
id|namelen
op_plus
l_int|1
)paren
suffix:semicolon
id|refdir
op_assign
id|submodule
ques
c_cond
id|git_path_submodule
c_func
(paren
id|submodule
comma
l_string|&quot;%s&quot;
comma
id|ref
)paren
suffix:colon
id|git_path
c_func
(paren
l_string|&quot;%s&quot;
comma
id|ref
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
c_func
(paren
id|refdir
comma
op_amp
id|st
)paren
OL
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|st.st_mode
)paren
)paren
(brace
id|get_ref_dir
c_func
(paren
id|submodule
comma
id|ref
comma
id|array
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|submodule
)paren
(brace
id|hashclr
c_func
(paren
id|sha1
)paren
suffix:semicolon
id|flag
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|resolve_gitlink_ref
c_func
(paren
id|submodule
comma
id|ref
comma
id|sha1
)paren
OL
l_int|0
)paren
(brace
id|hashclr
c_func
(paren
id|sha1
)paren
suffix:semicolon
id|flag
op_or_assign
id|REF_BROKEN
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|resolve_ref
c_func
(paren
id|ref
comma
id|sha1
comma
l_int|1
comma
op_amp
id|flag
)paren
)paren
(brace
id|hashclr
c_func
(paren
id|sha1
)paren
suffix:semicolon
id|flag
op_or_assign
id|REF_BROKEN
suffix:semicolon
)brace
id|add_ref
c_func
(paren
id|ref
comma
id|sha1
comma
id|flag
comma
id|array
comma
l_int|NULL
)paren
suffix:semicolon
)brace
id|free
c_func
(paren
id|ref
)paren
suffix:semicolon
id|closedir
c_func
(paren
id|dir
)paren
suffix:semicolon
)brace
)brace
DECL|struct|warn_if_dangling_data
r_struct
id|warn_if_dangling_data
(brace
DECL|member|fp
id|FILE
op_star
id|fp
suffix:semicolon
DECL|member|refname
r_const
r_char
op_star
id|refname
suffix:semicolon
DECL|member|msg_fmt
r_const
r_char
op_star
id|msg_fmt
suffix:semicolon
)brace
suffix:semicolon
DECL|function|warn_if_dangling_symref
r_static
r_int
id|warn_if_dangling_symref
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
id|flags
comma
r_void
op_star
id|cb_data
)paren
(brace
r_struct
id|warn_if_dangling_data
op_star
id|d
op_assign
id|cb_data
suffix:semicolon
r_const
r_char
op_star
id|resolves_to
suffix:semicolon
r_int
r_char
id|junk
(braket
l_int|20
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|REF_ISSYMREF
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|resolves_to
op_assign
id|resolve_ref
c_func
(paren
id|refname
comma
id|junk
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|resolves_to
op_logical_or
id|strcmp
c_func
(paren
id|resolves_to
comma
id|d-&gt;refname
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|fprintf
c_func
(paren
id|d-&gt;fp
comma
id|d-&gt;msg_fmt
comma
id|refname
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|warn_dangling_symref
r_void
id|warn_dangling_symref
c_func
(paren
id|FILE
op_star
id|fp
comma
r_const
r_char
op_star
id|msg_fmt
comma
r_const
r_char
op_star
id|refname
)paren
(brace
r_struct
id|warn_if_dangling_data
id|data
suffix:semicolon
id|data.fp
op_assign
id|fp
suffix:semicolon
id|data.refname
op_assign
id|refname
suffix:semicolon
id|data.msg_fmt
op_assign
id|msg_fmt
suffix:semicolon
id|for_each_rawref
c_func
(paren
id|warn_if_dangling_symref
comma
op_amp
id|data
)paren
suffix:semicolon
)brace
DECL|function|get_loose_refs
r_static
r_struct
id|ref_array
op_star
id|get_loose_refs
c_func
(paren
r_const
r_char
op_star
id|submodule
)paren
(brace
r_if
c_cond
(paren
id|submodule
)paren
(brace
id|free_ref_array
c_func
(paren
op_amp
id|submodule_refs.loose
)paren
suffix:semicolon
id|get_ref_dir
c_func
(paren
id|submodule
comma
l_string|&quot;refs&quot;
comma
op_amp
id|submodule_refs.loose
)paren
suffix:semicolon
id|sort_ref_array
c_func
(paren
op_amp
id|submodule_refs.loose
)paren
suffix:semicolon
r_return
op_amp
id|submodule_refs.loose
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|cached_refs.did_loose
)paren
(brace
id|get_ref_dir
c_func
(paren
l_int|NULL
comma
l_string|&quot;refs&quot;
comma
op_amp
id|cached_refs.loose
)paren
suffix:semicolon
id|sort_ref_array
c_func
(paren
op_amp
id|cached_refs.loose
)paren
suffix:semicolon
id|cached_refs.did_loose
op_assign
l_int|1
suffix:semicolon
)brace
r_return
op_amp
id|cached_refs.loose
suffix:semicolon
)brace
multiline_comment|/* We allow &quot;recursive&quot; symbolic refs. Only within reason, though */
DECL|macro|MAXDEPTH
mdefine_line|#define MAXDEPTH 5
DECL|macro|MAXREFLEN
mdefine_line|#define MAXREFLEN (1024)
DECL|function|resolve_gitlink_packed_ref
r_static
r_int
id|resolve_gitlink_packed_ref
c_func
(paren
r_char
op_star
id|name
comma
r_int
id|pathlen
comma
r_const
r_char
op_star
id|refname
comma
r_int
r_char
op_star
id|result
)paren
(brace
id|FILE
op_star
id|f
suffix:semicolon
r_struct
id|cached_refs
id|refs
suffix:semicolon
r_struct
id|ref_entry
op_star
id|ref
suffix:semicolon
r_int
id|retval
op_assign
l_int|1
suffix:semicolon
id|strcpy
c_func
(paren
id|name
op_plus
id|pathlen
comma
l_string|&quot;packed-refs&quot;
)paren
suffix:semicolon
id|f
op_assign
id|fopen
c_func
(paren
id|name
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|f
)paren
r_return
l_int|1
suffix:semicolon
id|read_packed_refs
c_func
(paren
id|f
comma
op_amp
id|refs
)paren
suffix:semicolon
id|fclose
c_func
(paren
id|f
)paren
suffix:semicolon
id|ref
op_assign
id|search_ref_array
c_func
(paren
op_amp
id|refs.packed
comma
id|refname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ref
op_ne
l_int|NULL
)paren
(brace
id|memcpy
c_func
(paren
id|result
comma
id|ref-&gt;sha1
comma
l_int|20
)paren
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
)brace
id|free_ref_array
c_func
(paren
op_amp
id|refs.packed
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|resolve_gitlink_ref_recursive
r_static
r_int
id|resolve_gitlink_ref_recursive
c_func
(paren
r_char
op_star
id|name
comma
r_int
id|pathlen
comma
r_const
r_char
op_star
id|refname
comma
r_int
r_char
op_star
id|result
comma
r_int
id|recursion
)paren
(brace
r_int
id|fd
comma
id|len
op_assign
id|strlen
c_func
(paren
id|refname
)paren
suffix:semicolon
r_char
id|buffer
(braket
l_int|128
)braket
comma
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|recursion
OG
id|MAXDEPTH
op_logical_or
id|len
OG
id|MAXREFLEN
)paren
r_return
l_int|1
suffix:semicolon
id|memcpy
c_func
(paren
id|name
op_plus
id|pathlen
comma
id|refname
comma
id|len
op_plus
l_int|1
)paren
suffix:semicolon
id|fd
op_assign
id|open
c_func
(paren
id|name
comma
id|O_RDONLY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
r_return
id|resolve_gitlink_packed_ref
c_func
(paren
id|name
comma
id|pathlen
comma
id|refname
comma
id|result
)paren
suffix:semicolon
id|len
op_assign
id|read
c_func
(paren
id|fd
comma
id|buffer
comma
r_sizeof
(paren
id|buffer
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|len
op_logical_and
id|isspace
c_func
(paren
id|buffer
(braket
id|len
op_minus
l_int|1
)braket
)paren
)paren
id|len
op_decrement
suffix:semicolon
id|buffer
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Was it a detached head or an old-fashioned symlink? */
r_if
c_cond
(paren
op_logical_neg
id|get_sha1_hex
c_func
(paren
id|buffer
comma
id|result
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Symref? */
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|buffer
comma
l_string|&quot;ref:&quot;
comma
l_int|4
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|p
op_assign
id|buffer
op_plus
l_int|4
suffix:semicolon
r_while
c_loop
(paren
id|isspace
c_func
(paren
op_star
id|p
)paren
)paren
id|p
op_increment
suffix:semicolon
r_return
id|resolve_gitlink_ref_recursive
c_func
(paren
id|name
comma
id|pathlen
comma
id|p
comma
id|result
comma
id|recursion
op_plus
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|resolve_gitlink_ref
r_int
id|resolve_gitlink_ref
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_const
r_char
op_star
id|refname
comma
r_int
r_char
op_star
id|result
)paren
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|path
)paren
comma
id|retval
suffix:semicolon
r_char
op_star
id|gitdir
suffix:semicolon
r_const
r_char
op_star
id|tmp
suffix:semicolon
r_while
c_loop
(paren
id|len
op_logical_and
id|path
(braket
id|len
op_minus
l_int|1
)braket
op_eq
l_char|&squot;/&squot;
)paren
id|len
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
r_return
l_int|1
suffix:semicolon
id|gitdir
op_assign
id|xmalloc
c_func
(paren
id|len
op_plus
id|MAXREFLEN
op_plus
l_int|8
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|gitdir
comma
id|path
comma
id|len
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|gitdir
op_plus
id|len
comma
l_string|&quot;/.git&quot;
comma
l_int|6
)paren
suffix:semicolon
id|len
op_add_assign
l_int|5
suffix:semicolon
id|tmp
op_assign
id|read_gitfile_gently
c_func
(paren
id|gitdir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
)paren
(brace
id|free
c_func
(paren
id|gitdir
)paren
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|gitdir
op_assign
id|xmalloc
c_func
(paren
id|len
op_plus
id|MAXREFLEN
op_plus
l_int|3
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|gitdir
comma
id|tmp
comma
id|len
)paren
suffix:semicolon
)brace
id|gitdir
(braket
id|len
)braket
op_assign
l_char|&squot;/&squot;
suffix:semicolon
id|gitdir
(braket
op_increment
id|len
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|retval
op_assign
id|resolve_gitlink_ref_recursive
c_func
(paren
id|gitdir
comma
id|len
comma
id|refname
comma
id|result
comma
l_int|0
)paren
suffix:semicolon
id|free
c_func
(paren
id|gitdir
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * If the &quot;reading&quot; argument is set, this function finds out what _object_&n; * the ref points at by &quot;reading&quot; the ref.  The ref, if it is not symbolic,&n; * has to exist, and if it is symbolic, it has to point at an existing ref,&n; * because the &quot;read&quot; goes through the symref to the ref it points at.&n; *&n; * The access that is not &quot;reading&quot; may often be &quot;writing&quot;, but does not&n; * have to; it can be merely checking _where it leads to_. If it is a&n; * prelude to &quot;writing&quot; to the ref, a write to a symref that points at&n; * yet-to-be-born ref will create the real ref pointed by the symref.&n; * reading=0 allows the caller to check where such a symref leads to.&n; */
DECL|function|resolve_ref
r_const
r_char
op_star
id|resolve_ref
c_func
(paren
r_const
r_char
op_star
id|ref
comma
r_int
r_char
op_star
id|sha1
comma
r_int
id|reading
comma
r_int
op_star
id|flag
)paren
(brace
r_int
id|depth
op_assign
id|MAXDEPTH
suffix:semicolon
id|ssize_t
id|len
suffix:semicolon
r_char
id|buffer
(braket
l_int|256
)braket
suffix:semicolon
r_static
r_char
id|ref_buffer
(braket
l_int|256
)braket
suffix:semicolon
r_if
c_cond
(paren
id|flag
)paren
op_star
id|flag
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_char
id|path
(braket
id|PATH_MAX
)braket
suffix:semicolon
r_struct
id|stat
id|st
suffix:semicolon
r_char
op_star
id|buf
suffix:semicolon
r_int
id|fd
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|depth
OL
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
id|git_snpath
c_func
(paren
id|path
comma
r_sizeof
(paren
id|path
)paren
comma
l_string|&quot;%s&quot;
comma
id|ref
)paren
suffix:semicolon
multiline_comment|/* Special case: non-existing file. */
r_if
c_cond
(paren
id|lstat
c_func
(paren
id|path
comma
op_amp
id|st
)paren
OL
l_int|0
)paren
(brace
r_struct
id|ref_array
op_star
id|packed
op_assign
id|get_packed_refs
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
r_struct
id|ref_entry
op_star
id|r
op_assign
id|search_ref_array
c_func
(paren
id|packed
comma
id|ref
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_ne
l_int|NULL
)paren
(brace
id|hashcpy
c_func
(paren
id|sha1
comma
id|r-&gt;sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flag
)paren
op_star
id|flag
op_or_assign
id|REF_ISPACKED
suffix:semicolon
r_return
id|ref
suffix:semicolon
)brace
r_if
c_cond
(paren
id|reading
op_logical_or
id|errno
op_ne
id|ENOENT
)paren
r_return
l_int|NULL
suffix:semicolon
id|hashclr
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_return
id|ref
suffix:semicolon
)brace
multiline_comment|/* Follow &quot;normalized&quot; - ie &quot;refs/..&quot; symlinks by hand */
r_if
c_cond
(paren
id|S_ISLNK
c_func
(paren
id|st.st_mode
)paren
)paren
(brace
id|len
op_assign
id|readlink
c_func
(paren
id|path
comma
id|buffer
comma
r_sizeof
(paren
id|buffer
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ge
l_int|5
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;refs/&quot;
comma
id|buffer
comma
l_int|5
)paren
)paren
(brace
id|buffer
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
id|strcpy
c_func
(paren
id|ref_buffer
comma
id|buffer
)paren
suffix:semicolon
id|ref
op_assign
id|ref_buffer
suffix:semicolon
r_if
c_cond
(paren
id|flag
)paren
op_star
id|flag
op_or_assign
id|REF_ISSYMREF
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
multiline_comment|/* Is it a directory? */
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|st.st_mode
)paren
)paren
(brace
id|errno
op_assign
id|EISDIR
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Anything else, just open it and try to use it as&n;&t;&t; * a ref&n;&t;&t; */
id|fd
op_assign
id|open
c_func
(paren
id|path
comma
id|O_RDONLY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
id|len
op_assign
id|read_in_full
c_func
(paren
id|fd
comma
id|buffer
comma
r_sizeof
(paren
id|buffer
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Is it a symbolic ref?&n;&t;&t; */
r_if
c_cond
(paren
id|len
OL
l_int|4
op_logical_or
id|memcmp
c_func
(paren
l_string|&quot;ref:&quot;
comma
id|buffer
comma
l_int|4
)paren
)paren
r_break
suffix:semicolon
id|buf
op_assign
id|buffer
op_plus
l_int|4
suffix:semicolon
id|len
op_sub_assign
l_int|4
suffix:semicolon
r_while
c_loop
(paren
id|len
op_logical_and
id|isspace
c_func
(paren
op_star
id|buf
)paren
)paren
id|buf
op_increment
comma
id|len
op_decrement
suffix:semicolon
r_while
c_loop
(paren
id|len
op_logical_and
id|isspace
c_func
(paren
id|buf
(braket
id|len
op_minus
l_int|1
)braket
)paren
)paren
id|len
op_decrement
suffix:semicolon
id|buf
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
id|memcpy
c_func
(paren
id|ref_buffer
comma
id|buf
comma
id|len
op_plus
l_int|1
)paren
suffix:semicolon
id|ref
op_assign
id|ref_buffer
suffix:semicolon
r_if
c_cond
(paren
id|flag
)paren
op_star
id|flag
op_or_assign
id|REF_ISSYMREF
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OL
l_int|40
op_logical_or
id|get_sha1_hex
c_func
(paren
id|buffer
comma
id|sha1
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|ref
suffix:semicolon
)brace
multiline_comment|/* The argument to filter_refs */
DECL|struct|ref_filter
r_struct
id|ref_filter
(brace
DECL|member|pattern
r_const
r_char
op_star
id|pattern
suffix:semicolon
DECL|member|fn
id|each_ref_fn
op_star
id|fn
suffix:semicolon
DECL|member|cb_data
r_void
op_star
id|cb_data
suffix:semicolon
)brace
suffix:semicolon
DECL|function|read_ref
r_int
id|read_ref
c_func
(paren
r_const
r_char
op_star
id|ref
comma
r_int
r_char
op_star
id|sha1
)paren
(brace
r_if
c_cond
(paren
id|resolve_ref
c_func
(paren
id|ref
comma
id|sha1
comma
l_int|1
comma
l_int|NULL
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|macro|DO_FOR_EACH_INCLUDE_BROKEN
mdefine_line|#define DO_FOR_EACH_INCLUDE_BROKEN 01
DECL|function|do_one_ref
r_static
r_int
id|do_one_ref
c_func
(paren
r_const
r_char
op_star
id|base
comma
id|each_ref_fn
id|fn
comma
r_int
id|trim
comma
r_int
id|flags
comma
r_void
op_star
id|cb_data
comma
r_struct
id|ref_entry
op_star
id|entry
)paren
(brace
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|base
comma
id|entry-&gt;name
comma
id|trim
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|DO_FOR_EACH_INCLUDE_BROKEN
)paren
)paren
(brace
r_if
c_cond
(paren
id|entry-&gt;flag
op_amp
id|REF_BROKEN
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* ignore dangling symref */
r_if
c_cond
(paren
op_logical_neg
id|has_sha1_file
c_func
(paren
id|entry-&gt;sha1
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;%s does not point to a valid object!&quot;
comma
id|entry-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|current_ref
op_assign
id|entry
suffix:semicolon
r_return
id|fn
c_func
(paren
id|entry-&gt;name
op_plus
id|trim
comma
id|entry-&gt;sha1
comma
id|entry-&gt;flag
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|filter_refs
r_static
r_int
id|filter_refs
c_func
(paren
r_const
r_char
op_star
id|ref
comma
r_const
r_int
r_char
op_star
id|sha
comma
r_int
id|flags
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|ref_filter
op_star
id|filter
op_assign
(paren
r_struct
id|ref_filter
op_star
)paren
id|data
suffix:semicolon
r_if
c_cond
(paren
id|fnmatch
c_func
(paren
id|filter-&gt;pattern
comma
id|ref
comma
l_int|0
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|filter
op_member_access_from_pointer
id|fn
c_func
(paren
id|ref
comma
id|sha
comma
id|flags
comma
id|filter-&gt;cb_data
)paren
suffix:semicolon
)brace
DECL|function|peel_ref
r_int
id|peel_ref
c_func
(paren
r_const
r_char
op_star
id|ref
comma
r_int
r_char
op_star
id|sha1
)paren
(brace
r_int
id|flag
suffix:semicolon
r_int
r_char
id|base
(braket
l_int|20
)braket
suffix:semicolon
r_struct
id|object
op_star
id|o
suffix:semicolon
r_if
c_cond
(paren
id|current_ref
op_logical_and
(paren
id|current_ref-&gt;name
op_eq
id|ref
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|current_ref-&gt;name
comma
id|ref
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|current_ref-&gt;flag
op_amp
id|REF_KNOWS_PEELED
)paren
(brace
id|hashcpy
c_func
(paren
id|sha1
comma
id|current_ref-&gt;peeled
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|hashcpy
c_func
(paren
id|base
comma
id|current_ref-&gt;sha1
)paren
suffix:semicolon
r_goto
id|fallback
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|resolve_ref
c_func
(paren
id|ref
comma
id|base
comma
l_int|1
comma
op_amp
id|flag
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flag
op_amp
id|REF_ISPACKED
)paren
)paren
(brace
r_struct
id|ref_array
op_star
id|array
op_assign
id|get_packed_refs
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
r_struct
id|ref_entry
op_star
id|r
op_assign
id|search_ref_array
c_func
(paren
id|array
comma
id|ref
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_ne
l_int|NULL
op_logical_and
id|r-&gt;flag
op_amp
id|REF_KNOWS_PEELED
)paren
(brace
id|hashcpy
c_func
(paren
id|sha1
comma
id|r-&gt;peeled
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|fallback
suffix:colon
id|o
op_assign
id|parse_object
c_func
(paren
id|base
)paren
suffix:semicolon
r_if
c_cond
(paren
id|o
op_logical_and
id|o-&gt;type
op_eq
id|OBJ_TAG
)paren
(brace
id|o
op_assign
id|deref_tag
c_func
(paren
id|o
comma
id|ref
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|o
)paren
(brace
id|hashcpy
c_func
(paren
id|sha1
comma
id|o-&gt;sha1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|do_for_each_ref
r_static
r_int
id|do_for_each_ref
c_func
(paren
r_const
r_char
op_star
id|submodule
comma
r_const
r_char
op_star
id|base
comma
id|each_ref_fn
id|fn
comma
r_int
id|trim
comma
r_int
id|flags
comma
r_void
op_star
id|cb_data
)paren
(brace
r_int
id|retval
op_assign
l_int|0
comma
id|i
comma
id|p
op_assign
l_int|0
comma
id|l
op_assign
l_int|0
suffix:semicolon
r_struct
id|ref_array
op_star
id|packed
op_assign
id|get_packed_refs
c_func
(paren
id|submodule
)paren
suffix:semicolon
r_struct
id|ref_array
op_star
id|loose
op_assign
id|get_loose_refs
c_func
(paren
id|submodule
)paren
suffix:semicolon
r_struct
id|ref_array
op_star
id|extra
op_assign
op_amp
id|extra_refs
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|extra-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
id|retval
op_assign
id|do_one_ref
c_func
(paren
id|base
comma
id|fn
comma
id|trim
comma
id|flags
comma
id|cb_data
comma
id|extra-&gt;refs
(braket
id|i
)braket
)paren
suffix:semicolon
r_while
c_loop
(paren
id|p
OL
id|packed-&gt;nr
op_logical_and
id|l
OL
id|loose-&gt;nr
)paren
(brace
r_struct
id|ref_entry
op_star
id|entry
suffix:semicolon
r_int
id|cmp
op_assign
id|strcmp
c_func
(paren
id|packed-&gt;refs
(braket
id|p
)braket
op_member_access_from_pointer
id|name
comma
id|loose-&gt;refs
(braket
id|l
)braket
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmp
)paren
(brace
id|p
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmp
OG
l_int|0
)paren
(brace
id|entry
op_assign
id|loose-&gt;refs
(braket
id|l
op_increment
)braket
suffix:semicolon
)brace
r_else
(brace
id|entry
op_assign
id|packed-&gt;refs
(braket
id|p
op_increment
)braket
suffix:semicolon
)brace
id|retval
op_assign
id|do_one_ref
c_func
(paren
id|base
comma
id|fn
comma
id|trim
comma
id|flags
comma
id|cb_data
comma
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_goto
id|end_each
suffix:semicolon
)brace
r_if
c_cond
(paren
id|l
OL
id|loose-&gt;nr
)paren
(brace
id|p
op_assign
id|l
suffix:semicolon
id|packed
op_assign
id|loose
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
id|p
OL
id|packed-&gt;nr
suffix:semicolon
id|p
op_increment
)paren
(brace
id|retval
op_assign
id|do_one_ref
c_func
(paren
id|base
comma
id|fn
comma
id|trim
comma
id|flags
comma
id|cb_data
comma
id|packed-&gt;refs
(braket
id|p
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_goto
id|end_each
suffix:semicolon
)brace
id|end_each
suffix:colon
id|current_ref
op_assign
l_int|NULL
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|do_head_ref
r_static
r_int
id|do_head_ref
c_func
(paren
r_const
r_char
op_star
id|submodule
comma
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_int
id|flag
suffix:semicolon
r_if
c_cond
(paren
id|submodule
)paren
(brace
r_if
c_cond
(paren
id|resolve_gitlink_ref
c_func
(paren
id|submodule
comma
l_string|&quot;HEAD&quot;
comma
id|sha1
)paren
op_eq
l_int|0
)paren
r_return
id|fn
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|sha1
comma
l_int|0
comma
id|cb_data
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|resolve_ref
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|sha1
comma
l_int|1
comma
op_amp
id|flag
)paren
)paren
r_return
id|fn
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|sha1
comma
id|flag
comma
id|cb_data
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|head_ref
r_int
id|head_ref
c_func
(paren
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|do_head_ref
c_func
(paren
l_int|NULL
comma
id|fn
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|head_ref_submodule
r_int
id|head_ref_submodule
c_func
(paren
r_const
r_char
op_star
id|submodule
comma
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|do_head_ref
c_func
(paren
id|submodule
comma
id|fn
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|for_each_ref
r_int
id|for_each_ref
c_func
(paren
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|do_for_each_ref
c_func
(paren
l_int|NULL
comma
l_string|&quot;refs/&quot;
comma
id|fn
comma
l_int|0
comma
l_int|0
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|for_each_ref_submodule
r_int
id|for_each_ref_submodule
c_func
(paren
r_const
r_char
op_star
id|submodule
comma
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|do_for_each_ref
c_func
(paren
id|submodule
comma
l_string|&quot;refs/&quot;
comma
id|fn
comma
l_int|0
comma
l_int|0
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|for_each_ref_in
r_int
id|for_each_ref_in
c_func
(paren
r_const
r_char
op_star
id|prefix
comma
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|do_for_each_ref
c_func
(paren
l_int|NULL
comma
id|prefix
comma
id|fn
comma
id|strlen
c_func
(paren
id|prefix
)paren
comma
l_int|0
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|for_each_ref_in_submodule
r_int
id|for_each_ref_in_submodule
c_func
(paren
r_const
r_char
op_star
id|submodule
comma
r_const
r_char
op_star
id|prefix
comma
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|do_for_each_ref
c_func
(paren
id|submodule
comma
id|prefix
comma
id|fn
comma
id|strlen
c_func
(paren
id|prefix
)paren
comma
l_int|0
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|for_each_tag_ref
r_int
id|for_each_tag_ref
c_func
(paren
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|for_each_ref_in
c_func
(paren
l_string|&quot;refs/tags/&quot;
comma
id|fn
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|for_each_tag_ref_submodule
r_int
id|for_each_tag_ref_submodule
c_func
(paren
r_const
r_char
op_star
id|submodule
comma
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|for_each_ref_in_submodule
c_func
(paren
id|submodule
comma
l_string|&quot;refs/tags/&quot;
comma
id|fn
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|for_each_branch_ref
r_int
id|for_each_branch_ref
c_func
(paren
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|for_each_ref_in
c_func
(paren
l_string|&quot;refs/heads/&quot;
comma
id|fn
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|for_each_branch_ref_submodule
r_int
id|for_each_branch_ref_submodule
c_func
(paren
r_const
r_char
op_star
id|submodule
comma
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|for_each_ref_in_submodule
c_func
(paren
id|submodule
comma
l_string|&quot;refs/heads/&quot;
comma
id|fn
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|for_each_remote_ref
r_int
id|for_each_remote_ref
c_func
(paren
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|for_each_ref_in
c_func
(paren
l_string|&quot;refs/remotes/&quot;
comma
id|fn
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|for_each_remote_ref_submodule
r_int
id|for_each_remote_ref_submodule
c_func
(paren
r_const
r_char
op_star
id|submodule
comma
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|for_each_ref_in_submodule
c_func
(paren
id|submodule
comma
l_string|&quot;refs/remotes/&quot;
comma
id|fn
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|for_each_replace_ref
r_int
id|for_each_replace_ref
c_func
(paren
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|do_for_each_ref
c_func
(paren
l_int|NULL
comma
l_string|&quot;refs/replace/&quot;
comma
id|fn
comma
l_int|13
comma
l_int|0
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|for_each_glob_ref_in
r_int
id|for_each_glob_ref_in
c_func
(paren
id|each_ref_fn
id|fn
comma
r_const
r_char
op_star
id|pattern
comma
r_const
r_char
op_star
id|prefix
comma
r_void
op_star
id|cb_data
)paren
(brace
r_struct
id|strbuf
id|real_pattern
op_assign
id|STRBUF_INIT
suffix:semicolon
r_struct
id|ref_filter
id|filter
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prefix
op_logical_and
id|prefixcmp
c_func
(paren
id|pattern
comma
l_string|&quot;refs/&quot;
)paren
)paren
id|strbuf_addstr
c_func
(paren
op_amp
id|real_pattern
comma
l_string|&quot;refs/&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|prefix
)paren
id|strbuf_addstr
c_func
(paren
op_amp
id|real_pattern
comma
id|prefix
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|real_pattern
comma
id|pattern
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|has_glob_specials
c_func
(paren
id|pattern
)paren
)paren
(brace
multiline_comment|/* Append implied &squot;/&squot; &squot;*&squot; if not present. */
r_if
c_cond
(paren
id|real_pattern.buf
(braket
id|real_pattern.len
l_int|1
)braket
op_ne
l_char|&squot;/&squot;
)paren
id|strbuf_addch
c_func
(paren
op_amp
id|real_pattern
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
multiline_comment|/* No need to check for &squot;*&squot;, there is none. */
id|strbuf_addch
c_func
(paren
op_amp
id|real_pattern
comma
l_char|&squot;*&squot;
)paren
suffix:semicolon
)brace
id|filter.pattern
op_assign
id|real_pattern.buf
suffix:semicolon
id|filter.fn
op_assign
id|fn
suffix:semicolon
id|filter.cb_data
op_assign
id|cb_data
suffix:semicolon
id|ret
op_assign
id|for_each_ref
c_func
(paren
id|filter_refs
comma
op_amp
id|filter
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|real_pattern
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|for_each_glob_ref
r_int
id|for_each_glob_ref
c_func
(paren
id|each_ref_fn
id|fn
comma
r_const
r_char
op_star
id|pattern
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|for_each_glob_ref_in
c_func
(paren
id|fn
comma
id|pattern
comma
l_int|NULL
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|for_each_rawref
r_int
id|for_each_rawref
c_func
(paren
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|do_for_each_ref
c_func
(paren
l_int|NULL
comma
l_string|&quot;refs/&quot;
comma
id|fn
comma
l_int|0
comma
id|DO_FOR_EACH_INCLUDE_BROKEN
comma
id|cb_data
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Make sure &quot;ref&quot; is something reasonable to have under &quot;.git/refs/&quot;;&n; * We do not like it if:&n; *&n; * - any path component of it begins with &quot;.&quot;, or&n; * - it has double dots &quot;..&quot;, or&n; * - it has ASCII control character, &quot;~&quot;, &quot;^&quot;, &quot;:&quot; or SP, anywhere, or&n; * - it ends with a &quot;/&quot;.&n; * - it ends with &quot;.lock&quot;&n; * - it contains a &quot;&bslash;&quot; (backslash)&n; */
DECL|function|bad_ref_char
r_static
r_inline
r_int
id|bad_ref_char
c_func
(paren
r_int
id|ch
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
r_int
)paren
id|ch
)paren
op_le
l_char|&squot; &squot;
op_logical_or
id|ch
op_eq
l_char|&squot;~&squot;
op_logical_or
id|ch
op_eq
l_char|&squot;^&squot;
op_logical_or
id|ch
op_eq
l_char|&squot;:&squot;
op_logical_or
id|ch
op_eq
l_char|&squot;&bslash;&bslash;&squot;
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* 2.13 Pattern Matching Notation */
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;?&squot;
op_logical_or
id|ch
op_eq
l_char|&squot;[&squot;
)paren
multiline_comment|/* Unsupported */
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;*&squot;
)paren
multiline_comment|/* Supported at the end */
r_return
l_int|2
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|check_ref_format
r_int
id|check_ref_format
c_func
(paren
r_const
r_char
op_star
id|ref
)paren
(brace
r_int
id|ch
comma
id|level
comma
id|bad_type
comma
id|last
suffix:semicolon
r_int
id|ret
op_assign
id|CHECK_REF_FORMAT_OK
suffix:semicolon
r_const
r_char
op_star
id|cp
op_assign
id|ref
suffix:semicolon
id|level
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_while
c_loop
(paren
(paren
id|ch
op_assign
op_star
id|cp
op_increment
)paren
op_eq
l_char|&squot;/&squot;
)paren
suffix:semicolon
multiline_comment|/* tolerate duplicated slashes */
r_if
c_cond
(paren
op_logical_neg
id|ch
)paren
multiline_comment|/* should not end with slashes */
r_return
id|CHECK_REF_FORMAT_ERROR
suffix:semicolon
multiline_comment|/* we are at the beginning of the path component */
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;.&squot;
)paren
r_return
id|CHECK_REF_FORMAT_ERROR
suffix:semicolon
id|bad_type
op_assign
id|bad_ref_char
c_func
(paren
id|ch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bad_type
)paren
(brace
r_if
c_cond
(paren
id|bad_type
op_eq
l_int|2
op_logical_and
(paren
op_logical_neg
op_star
id|cp
op_logical_or
op_star
id|cp
op_eq
l_char|&squot;/&squot;
)paren
op_logical_and
id|ret
op_eq
id|CHECK_REF_FORMAT_OK
)paren
id|ret
op_assign
id|CHECK_REF_FORMAT_WILDCARD
suffix:semicolon
r_else
r_return
id|CHECK_REF_FORMAT_ERROR
suffix:semicolon
)brace
id|last
op_assign
id|ch
suffix:semicolon
multiline_comment|/* scan the rest of the path component */
r_while
c_loop
(paren
(paren
id|ch
op_assign
op_star
id|cp
op_increment
)paren
op_ne
l_int|0
)paren
(brace
id|bad_type
op_assign
id|bad_ref_char
c_func
(paren
id|ch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bad_type
)paren
r_return
id|CHECK_REF_FORMAT_ERROR
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;/&squot;
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|last
op_eq
l_char|&squot;.&squot;
op_logical_and
id|ch
op_eq
l_char|&squot;.&squot;
)paren
r_return
id|CHECK_REF_FORMAT_ERROR
suffix:semicolon
r_if
c_cond
(paren
id|last
op_eq
l_char|&squot;@&squot;
op_logical_and
id|ch
op_eq
l_char|&squot;{&squot;
)paren
r_return
id|CHECK_REF_FORMAT_ERROR
suffix:semicolon
id|last
op_assign
id|ch
suffix:semicolon
)brace
id|level
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ch
)paren
(brace
r_if
c_cond
(paren
id|ref
op_le
id|cp
l_int|2
op_logical_and
id|cp
(braket
l_int|2
)braket
op_eq
l_char|&squot;.&squot;
)paren
r_return
id|CHECK_REF_FORMAT_ERROR
suffix:semicolon
r_if
c_cond
(paren
id|level
OL
l_int|2
)paren
r_return
id|CHECK_REF_FORMAT_ONELEVEL
suffix:semicolon
r_if
c_cond
(paren
id|has_extension
c_func
(paren
id|ref
comma
l_string|&quot;.lock&quot;
)paren
)paren
r_return
id|CHECK_REF_FORMAT_ERROR
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
)brace
)brace
DECL|function|prettify_refname
r_const
r_char
op_star
id|prettify_refname
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_return
id|name
op_plus
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|name
comma
l_string|&quot;refs/heads/&quot;
)paren
ques
c_cond
l_int|11
suffix:colon
op_logical_neg
id|prefixcmp
c_func
(paren
id|name
comma
l_string|&quot;refs/tags/&quot;
)paren
ques
c_cond
l_int|10
suffix:colon
op_logical_neg
id|prefixcmp
c_func
(paren
id|name
comma
l_string|&quot;refs/remotes/&quot;
)paren
ques
c_cond
l_int|13
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
DECL|variable|ref_rev_parse_rules
r_const
r_char
op_star
id|ref_rev_parse_rules
(braket
)braket
op_assign
(brace
l_string|&quot;%.*s&quot;
comma
l_string|&quot;refs/%.*s&quot;
comma
l_string|&quot;refs/tags/%.*s&quot;
comma
l_string|&quot;refs/heads/%.*s&quot;
comma
l_string|&quot;refs/remotes/%.*s&quot;
comma
l_string|&quot;refs/remotes/%.*s/HEAD&quot;
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|ref_fetch_rules
r_const
r_char
op_star
id|ref_fetch_rules
(braket
)braket
op_assign
(brace
l_string|&quot;%.*s&quot;
comma
l_string|&quot;refs/%.*s&quot;
comma
l_string|&quot;refs/heads/%.*s&quot;
comma
l_int|NULL
)brace
suffix:semicolon
DECL|function|refname_match
r_int
id|refname_match
c_func
(paren
r_const
r_char
op_star
id|abbrev_name
comma
r_const
r_char
op_star
id|full_name
comma
r_const
r_char
op_star
op_star
id|rules
)paren
(brace
r_const
r_char
op_star
op_star
id|p
suffix:semicolon
r_const
r_int
id|abbrev_name_len
op_assign
id|strlen
c_func
(paren
id|abbrev_name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|rules
suffix:semicolon
op_star
id|p
suffix:semicolon
id|p
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|full_name
comma
id|mkpath
c_func
(paren
op_star
id|p
comma
id|abbrev_name_len
comma
id|abbrev_name
)paren
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|verify_lock
r_static
r_struct
id|ref_lock
op_star
id|verify_lock
c_func
(paren
r_struct
id|ref_lock
op_star
id|lock
comma
r_const
r_int
r_char
op_star
id|old_sha1
comma
r_int
id|mustexist
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|resolve_ref
c_func
(paren
id|lock-&gt;ref_name
comma
id|lock-&gt;old_sha1
comma
id|mustexist
comma
l_int|NULL
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Can&squot;t verify ref %s&quot;
comma
id|lock-&gt;ref_name
)paren
suffix:semicolon
id|unlock_ref
c_func
(paren
id|lock
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hashcmp
c_func
(paren
id|lock-&gt;old_sha1
comma
id|old_sha1
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Ref %s is at %s but expected %s&quot;
comma
id|lock-&gt;ref_name
comma
id|sha1_to_hex
c_func
(paren
id|lock-&gt;old_sha1
)paren
comma
id|sha1_to_hex
c_func
(paren
id|old_sha1
)paren
)paren
suffix:semicolon
id|unlock_ref
c_func
(paren
id|lock
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|lock
suffix:semicolon
)brace
DECL|function|remove_empty_directories
r_static
r_int
id|remove_empty_directories
c_func
(paren
r_const
r_char
op_star
id|file
)paren
(brace
multiline_comment|/* we want to create a file but there is a directory there;&n;&t; * if that is an empty directory (or a directory that contains&n;&t; * only empty directories), remove them.&n;&t; */
r_struct
id|strbuf
id|path
suffix:semicolon
r_int
id|result
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|path
comma
l_int|20
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|path
comma
id|file
)paren
suffix:semicolon
id|result
op_assign
id|remove_dir_recursively
c_func
(paren
op_amp
id|path
comma
id|REMOVE_DIR_EMPTY_ONLY
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|is_refname_available
r_static
r_int
id|is_refname_available
c_func
(paren
r_const
r_char
op_star
id|ref
comma
r_const
r_char
op_star
id|oldref
comma
r_struct
id|ref_array
op_star
id|array
comma
r_int
id|quiet
)paren
(brace
r_int
id|i
comma
id|namlen
op_assign
id|strlen
c_func
(paren
id|ref
)paren
suffix:semicolon
multiline_comment|/* e.g. &squot;foo/bar&squot; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|array-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|ref_entry
op_star
id|entry
op_assign
id|array-&gt;refs
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* entry-&gt;name could be &squot;foo&squot; or &squot;foo/bar/baz&squot; */
r_if
c_cond
(paren
op_logical_neg
id|oldref
op_logical_or
id|strcmp
c_func
(paren
id|oldref
comma
id|entry-&gt;name
)paren
)paren
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|entry-&gt;name
)paren
suffix:semicolon
r_int
id|cmplen
op_assign
(paren
id|namlen
OL
id|len
)paren
ques
c_cond
id|namlen
suffix:colon
id|len
suffix:semicolon
r_const
r_char
op_star
id|lead
op_assign
(paren
id|namlen
OL
id|len
)paren
ques
c_cond
id|entry-&gt;name
suffix:colon
id|ref
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|ref
comma
id|entry-&gt;name
comma
id|cmplen
)paren
op_logical_and
id|lead
(braket
id|cmplen
)braket
op_eq
l_char|&squot;/&squot;
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|quiet
)paren
id|error
c_func
(paren
l_string|&quot;&squot;%s&squot; exists; cannot create &squot;%s&squot;&quot;
comma
id|entry-&gt;name
comma
id|ref
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|lock_ref_sha1_basic
r_static
r_struct
id|ref_lock
op_star
id|lock_ref_sha1_basic
c_func
(paren
r_const
r_char
op_star
id|ref
comma
r_const
r_int
r_char
op_star
id|old_sha1
comma
r_int
id|flags
comma
r_int
op_star
id|type_p
)paren
(brace
r_char
op_star
id|ref_file
suffix:semicolon
r_const
r_char
op_star
id|orig_ref
op_assign
id|ref
suffix:semicolon
r_struct
id|ref_lock
op_star
id|lock
suffix:semicolon
r_int
id|last_errno
op_assign
l_int|0
suffix:semicolon
r_int
id|type
comma
id|lflags
suffix:semicolon
r_int
id|mustexist
op_assign
(paren
id|old_sha1
op_logical_and
op_logical_neg
id|is_null_sha1
c_func
(paren
id|old_sha1
)paren
)paren
suffix:semicolon
r_int
id|missing
op_assign
l_int|0
suffix:semicolon
id|lock
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|ref_lock
)paren
)paren
suffix:semicolon
id|lock-&gt;lock_fd
op_assign
l_int|1
suffix:semicolon
id|ref
op_assign
id|resolve_ref
c_func
(paren
id|ref
comma
id|lock-&gt;old_sha1
comma
id|mustexist
comma
op_amp
id|type
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ref
op_logical_and
id|errno
op_eq
id|EISDIR
)paren
(brace
multiline_comment|/* we are trying to lock foo but we used to&n;&t;&t; * have foo/bar which now does not exist;&n;&t;&t; * it is normal for the empty directory &squot;foo&squot;&n;&t;&t; * to remain.&n;&t;&t; */
id|ref_file
op_assign
id|git_path
c_func
(paren
l_string|&quot;%s&quot;
comma
id|orig_ref
)paren
suffix:semicolon
r_if
c_cond
(paren
id|remove_empty_directories
c_func
(paren
id|ref_file
)paren
)paren
(brace
id|last_errno
op_assign
id|errno
suffix:semicolon
id|error
c_func
(paren
l_string|&quot;there are still refs under &squot;%s&squot;&quot;
comma
id|orig_ref
)paren
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
id|ref
op_assign
id|resolve_ref
c_func
(paren
id|orig_ref
comma
id|lock-&gt;old_sha1
comma
id|mustexist
comma
op_amp
id|type
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|type_p
)paren
op_star
id|type_p
op_assign
id|type
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ref
)paren
(brace
id|last_errno
op_assign
id|errno
suffix:semicolon
id|error
c_func
(paren
l_string|&quot;unable to resolve reference %s: %s&quot;
comma
id|orig_ref
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
id|missing
op_assign
id|is_null_sha1
c_func
(paren
id|lock-&gt;old_sha1
)paren
suffix:semicolon
multiline_comment|/* When the ref did not exist and we are creating it,&n;&t; * make sure there is no existing ref that is packed&n;&t; * whose name begins with our refname, nor a ref whose&n;&t; * name is a proper prefix of our refname.&n;&t; */
r_if
c_cond
(paren
id|missing
op_logical_and
op_logical_neg
id|is_refname_available
c_func
(paren
id|ref
comma
l_int|NULL
comma
id|get_packed_refs
c_func
(paren
l_int|NULL
)paren
comma
l_int|0
)paren
)paren
(brace
id|last_errno
op_assign
id|ENOTDIR
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
id|lock-&gt;lk
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|lock_file
)paren
)paren
suffix:semicolon
id|lflags
op_assign
id|LOCK_DIE_ON_ERROR
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|REF_NODEREF
)paren
(brace
id|ref
op_assign
id|orig_ref
suffix:semicolon
id|lflags
op_or_assign
id|LOCK_NODEREF
suffix:semicolon
)brace
id|lock-&gt;ref_name
op_assign
id|xstrdup
c_func
(paren
id|ref
)paren
suffix:semicolon
id|lock-&gt;orig_ref_name
op_assign
id|xstrdup
c_func
(paren
id|orig_ref
)paren
suffix:semicolon
id|ref_file
op_assign
id|git_path
c_func
(paren
l_string|&quot;%s&quot;
comma
id|ref
)paren
suffix:semicolon
r_if
c_cond
(paren
id|missing
)paren
id|lock-&gt;force_write
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|REF_NODEREF
)paren
op_logical_and
(paren
id|type
op_amp
id|REF_ISSYMREF
)paren
)paren
id|lock-&gt;force_write
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|safe_create_leading_directories
c_func
(paren
id|ref_file
)paren
)paren
(brace
id|last_errno
op_assign
id|errno
suffix:semicolon
id|error
c_func
(paren
l_string|&quot;unable to create directory for %s&quot;
comma
id|ref_file
)paren
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
id|lock-&gt;lock_fd
op_assign
id|hold_lock_file_for_update
c_func
(paren
id|lock-&gt;lk
comma
id|ref_file
comma
id|lflags
)paren
suffix:semicolon
r_return
id|old_sha1
ques
c_cond
id|verify_lock
c_func
(paren
id|lock
comma
id|old_sha1
comma
id|mustexist
)paren
suffix:colon
id|lock
suffix:semicolon
id|error_return
suffix:colon
id|unlock_ref
c_func
(paren
id|lock
)paren
suffix:semicolon
id|errno
op_assign
id|last_errno
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|lock_ref_sha1
r_struct
id|ref_lock
op_star
id|lock_ref_sha1
c_func
(paren
r_const
r_char
op_star
id|ref
comma
r_const
r_int
r_char
op_star
id|old_sha1
)paren
(brace
r_char
id|refpath
(braket
id|PATH_MAX
)braket
suffix:semicolon
r_if
c_cond
(paren
id|check_ref_format
c_func
(paren
id|ref
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|strcpy
c_func
(paren
id|refpath
comma
id|mkpath
c_func
(paren
l_string|&quot;refs/%s&quot;
comma
id|ref
)paren
)paren
suffix:semicolon
r_return
id|lock_ref_sha1_basic
c_func
(paren
id|refpath
comma
id|old_sha1
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|lock_any_ref_for_update
r_struct
id|ref_lock
op_star
id|lock_any_ref_for_update
c_func
(paren
r_const
r_char
op_star
id|ref
comma
r_const
r_int
r_char
op_star
id|old_sha1
comma
r_int
id|flags
)paren
(brace
r_switch
c_cond
(paren
id|check_ref_format
c_func
(paren
id|ref
)paren
)paren
(brace
r_default
suffix:colon
r_return
l_int|NULL
suffix:semicolon
r_case
l_int|0
suffix:colon
r_case
id|CHECK_REF_FORMAT_ONELEVEL
suffix:colon
r_return
id|lock_ref_sha1_basic
c_func
(paren
id|ref
comma
id|old_sha1
comma
id|flags
comma
l_int|NULL
)paren
suffix:semicolon
)brace
)brace
DECL|variable|packlock
r_static
r_struct
id|lock_file
id|packlock
suffix:semicolon
DECL|function|repack_without_ref
r_static
r_int
id|repack_without_ref
c_func
(paren
r_const
r_char
op_star
id|refname
)paren
(brace
r_struct
id|ref_array
op_star
id|packed
suffix:semicolon
r_struct
id|ref_entry
op_star
id|ref
suffix:semicolon
r_int
id|fd
comma
id|i
suffix:semicolon
id|packed
op_assign
id|get_packed_refs
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
id|ref
op_assign
id|search_ref_array
c_func
(paren
id|packed
comma
id|refname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ref
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|fd
op_assign
id|hold_lock_file_for_update
c_func
(paren
op_amp
id|packlock
comma
id|git_path
c_func
(paren
l_string|&quot;packed-refs&quot;
)paren
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
(brace
id|unable_to_lock_error
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;packed-refs&quot;
)paren
comma
id|errno
)paren
suffix:semicolon
r_return
id|error
c_func
(paren
l_string|&quot;cannot delete &squot;%s&squot; from packed refs&quot;
comma
id|refname
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|packed-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_char
id|line
(braket
id|PATH_MAX
op_plus
l_int|100
)braket
suffix:semicolon
r_int
id|len
suffix:semicolon
id|ref
op_assign
id|packed-&gt;refs
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|refname
comma
id|ref-&gt;name
)paren
)paren
r_continue
suffix:semicolon
id|len
op_assign
id|snprintf
c_func
(paren
id|line
comma
r_sizeof
(paren
id|line
)paren
comma
l_string|&quot;%s %s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|ref-&gt;sha1
)paren
comma
id|ref-&gt;name
)paren
suffix:semicolon
multiline_comment|/* this should not happen but just being defensive */
r_if
c_cond
(paren
id|len
OG
r_sizeof
(paren
id|line
)paren
)paren
id|die
c_func
(paren
l_string|&quot;too long a refname &squot;%s&squot;&quot;
comma
id|ref-&gt;name
)paren
suffix:semicolon
id|write_or_die
c_func
(paren
id|fd
comma
id|line
comma
id|len
)paren
suffix:semicolon
)brace
r_return
id|commit_lock_file
c_func
(paren
op_amp
id|packlock
)paren
suffix:semicolon
)brace
DECL|function|delete_ref
r_int
id|delete_ref
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
id|delopt
)paren
(brace
r_struct
id|ref_lock
op_star
id|lock
suffix:semicolon
r_int
id|err
comma
id|i
op_assign
l_int|0
comma
id|ret
op_assign
l_int|0
comma
id|flag
op_assign
l_int|0
suffix:semicolon
id|lock
op_assign
id|lock_ref_sha1_basic
c_func
(paren
id|refname
comma
id|sha1
comma
l_int|0
comma
op_amp
id|flag
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lock
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flag
op_amp
id|REF_ISPACKED
)paren
op_logical_or
id|flag
op_amp
id|REF_ISSYMREF
)paren
(brace
multiline_comment|/* loose */
r_const
r_char
op_star
id|path
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|delopt
op_amp
id|REF_NODEREF
)paren
)paren
(brace
id|i
op_assign
id|strlen
c_func
(paren
id|lock-&gt;lk-&gt;filename
)paren
l_int|5
suffix:semicolon
multiline_comment|/* .lock */
id|lock-&gt;lk-&gt;filename
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|path
op_assign
id|lock-&gt;lk-&gt;filename
suffix:semicolon
)brace
r_else
(brace
id|path
op_assign
id|git_path
c_func
(paren
l_string|&quot;%s&quot;
comma
id|refname
)paren
suffix:semicolon
)brace
id|err
op_assign
id|unlink_or_warn
c_func
(paren
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_logical_and
id|errno
op_ne
id|ENOENT
)paren
id|ret
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|delopt
op_amp
id|REF_NODEREF
)paren
)paren
id|lock-&gt;lk-&gt;filename
(braket
id|i
)braket
op_assign
l_char|&squot;.&squot;
suffix:semicolon
)brace
multiline_comment|/* removing the loose one could have resurrected an earlier&n;&t; * packed one.  Also, if it was not loose we need to repack&n;&t; * without it.&n;&t; */
id|ret
op_or_assign
id|repack_without_ref
c_func
(paren
id|refname
)paren
suffix:semicolon
id|unlink_or_warn
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|lock-&gt;ref_name
)paren
)paren
suffix:semicolon
id|invalidate_cached_refs
c_func
(paren
)paren
suffix:semicolon
id|unlock_ref
c_func
(paren
id|lock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * People using contrib&squot;s git-new-workdir have .git/logs/refs -&gt;&n; * /some/other/path/.git/logs/refs, and that may live on another device.&n; *&n; * IOW, to avoid cross device rename errors, the temporary renamed log must&n; * live into logs/refs.&n; */
DECL|macro|TMP_RENAMED_LOG
mdefine_line|#define TMP_RENAMED_LOG  &quot;logs/refs/.tmp-renamed-log&quot;
DECL|function|rename_ref
r_int
id|rename_ref
c_func
(paren
r_const
r_char
op_star
id|oldref
comma
r_const
r_char
op_star
id|newref
comma
r_const
r_char
op_star
id|logmsg
)paren
(brace
r_static
r_const
r_char
id|renamed_ref
(braket
)braket
op_assign
l_string|&quot;RENAMED-REF&quot;
suffix:semicolon
r_int
r_char
id|sha1
(braket
l_int|20
)braket
comma
id|orig_sha1
(braket
l_int|20
)braket
suffix:semicolon
r_int
id|flag
op_assign
l_int|0
comma
id|logmoved
op_assign
l_int|0
suffix:semicolon
r_struct
id|ref_lock
op_star
id|lock
suffix:semicolon
r_struct
id|stat
id|loginfo
suffix:semicolon
r_int
id|log
op_assign
op_logical_neg
id|lstat
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|oldref
)paren
comma
op_amp
id|loginfo
)paren
suffix:semicolon
r_const
r_char
op_star
id|symref
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|log
op_logical_and
id|S_ISLNK
c_func
(paren
id|loginfo.st_mode
)paren
)paren
r_return
id|error
c_func
(paren
l_string|&quot;reflog for %s is a symlink&quot;
comma
id|oldref
)paren
suffix:semicolon
id|symref
op_assign
id|resolve_ref
c_func
(paren
id|oldref
comma
id|orig_sha1
comma
l_int|1
comma
op_amp
id|flag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flag
op_amp
id|REF_ISSYMREF
)paren
r_return
id|error
c_func
(paren
l_string|&quot;refname %s is a symbolic ref, renaming it is not supported&quot;
comma
id|oldref
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|symref
)paren
r_return
id|error
c_func
(paren
l_string|&quot;refname %s not found&quot;
comma
id|oldref
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_refname_available
c_func
(paren
id|newref
comma
id|oldref
comma
id|get_packed_refs
c_func
(paren
l_int|NULL
)paren
comma
l_int|0
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_refname_available
c_func
(paren
id|newref
comma
id|oldref
comma
id|get_loose_refs
c_func
(paren
l_int|NULL
)paren
comma
l_int|0
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|lock
op_assign
id|lock_ref_sha1_basic
c_func
(paren
id|renamed_ref
comma
l_int|NULL
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lock
)paren
r_return
id|error
c_func
(paren
l_string|&quot;unable to lock %s&quot;
comma
id|renamed_ref
)paren
suffix:semicolon
id|lock-&gt;force_write
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|write_ref_sha1
c_func
(paren
id|lock
comma
id|orig_sha1
comma
id|logmsg
)paren
)paren
r_return
id|error
c_func
(paren
l_string|&quot;unable to save current sha1 in %s&quot;
comma
id|renamed_ref
)paren
suffix:semicolon
r_if
c_cond
(paren
id|log
op_logical_and
id|rename
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|oldref
)paren
comma
id|git_path
c_func
(paren
id|TMP_RENAMED_LOG
)paren
)paren
)paren
r_return
id|error
c_func
(paren
l_string|&quot;unable to move logfile logs/%s to &quot;
id|TMP_RENAMED_LOG
l_string|&quot;: %s&quot;
comma
id|oldref
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|delete_ref
c_func
(paren
id|oldref
comma
id|orig_sha1
comma
id|REF_NODEREF
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;unable to delete old %s&quot;
comma
id|oldref
)paren
suffix:semicolon
r_goto
id|rollback
suffix:semicolon
)brace
r_if
c_cond
(paren
id|resolve_ref
c_func
(paren
id|newref
comma
id|sha1
comma
l_int|1
comma
op_amp
id|flag
)paren
op_logical_and
id|delete_ref
c_func
(paren
id|newref
comma
id|sha1
comma
id|REF_NODEREF
)paren
)paren
(brace
r_if
c_cond
(paren
id|errno
op_eq
id|EISDIR
)paren
(brace
r_if
c_cond
(paren
id|remove_empty_directories
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;%s&quot;
comma
id|newref
)paren
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Directory not empty: %s&quot;
comma
id|newref
)paren
suffix:semicolon
r_goto
id|rollback
suffix:semicolon
)brace
)brace
r_else
(brace
id|error
c_func
(paren
l_string|&quot;unable to delete existing %s&quot;
comma
id|newref
)paren
suffix:semicolon
r_goto
id|rollback
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|log
op_logical_and
id|safe_create_leading_directories
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|newref
)paren
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;unable to create directory for %s&quot;
comma
id|newref
)paren
suffix:semicolon
r_goto
id|rollback
suffix:semicolon
)brace
id|retry
suffix:colon
r_if
c_cond
(paren
id|log
op_logical_and
id|rename
c_func
(paren
id|git_path
c_func
(paren
id|TMP_RENAMED_LOG
)paren
comma
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|newref
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|errno
op_eq
id|EISDIR
op_logical_or
id|errno
op_eq
id|ENOTDIR
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * rename(a, b) when b is an existing&n;&t;&t;&t; * directory ought to result in ISDIR, but&n;&t;&t;&t; * Solaris 5.8 gives ENOTDIR.  Sheesh.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|remove_empty_directories
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|newref
)paren
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Directory not empty: logs/%s&quot;
comma
id|newref
)paren
suffix:semicolon
r_goto
id|rollback
suffix:semicolon
)brace
r_goto
id|retry
suffix:semicolon
)brace
r_else
(brace
id|error
c_func
(paren
l_string|&quot;unable to move logfile &quot;
id|TMP_RENAMED_LOG
l_string|&quot; to logs/%s: %s&quot;
comma
id|newref
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_goto
id|rollback
suffix:semicolon
)brace
)brace
id|logmoved
op_assign
id|log
suffix:semicolon
id|lock
op_assign
id|lock_ref_sha1_basic
c_func
(paren
id|newref
comma
l_int|NULL
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lock
)paren
(brace
id|error
c_func
(paren
l_string|&quot;unable to lock %s for update&quot;
comma
id|newref
)paren
suffix:semicolon
r_goto
id|rollback
suffix:semicolon
)brace
id|lock-&gt;force_write
op_assign
l_int|1
suffix:semicolon
id|hashcpy
c_func
(paren
id|lock-&gt;old_sha1
comma
id|orig_sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write_ref_sha1
c_func
(paren
id|lock
comma
id|orig_sha1
comma
id|logmsg
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;unable to write current sha1 into %s&quot;
comma
id|newref
)paren
suffix:semicolon
r_goto
id|rollback
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|rollback
suffix:colon
id|lock
op_assign
id|lock_ref_sha1_basic
c_func
(paren
id|oldref
comma
l_int|NULL
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lock
)paren
(brace
id|error
c_func
(paren
l_string|&quot;unable to lock %s for rollback&quot;
comma
id|oldref
)paren
suffix:semicolon
r_goto
id|rollbacklog
suffix:semicolon
)brace
id|lock-&gt;force_write
op_assign
l_int|1
suffix:semicolon
id|flag
op_assign
id|log_all_ref_updates
suffix:semicolon
id|log_all_ref_updates
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|write_ref_sha1
c_func
(paren
id|lock
comma
id|orig_sha1
comma
l_int|NULL
)paren
)paren
id|error
c_func
(paren
l_string|&quot;unable to write current sha1 into %s&quot;
comma
id|oldref
)paren
suffix:semicolon
id|log_all_ref_updates
op_assign
id|flag
suffix:semicolon
id|rollbacklog
suffix:colon
r_if
c_cond
(paren
id|logmoved
op_logical_and
id|rename
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|newref
)paren
comma
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|oldref
)paren
)paren
)paren
id|error
c_func
(paren
l_string|&quot;unable to restore logfile %s from %s: %s&quot;
comma
id|oldref
comma
id|newref
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|logmoved
op_logical_and
id|log
op_logical_and
id|rename
c_func
(paren
id|git_path
c_func
(paren
id|TMP_RENAMED_LOG
)paren
comma
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|oldref
)paren
)paren
)paren
id|error
c_func
(paren
l_string|&quot;unable to restore logfile %s from &quot;
id|TMP_RENAMED_LOG
l_string|&quot;: %s&quot;
comma
id|oldref
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|close_ref
r_int
id|close_ref
c_func
(paren
r_struct
id|ref_lock
op_star
id|lock
)paren
(brace
r_if
c_cond
(paren
id|close_lock_file
c_func
(paren
id|lock-&gt;lk
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|lock-&gt;lock_fd
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|commit_ref
r_int
id|commit_ref
c_func
(paren
r_struct
id|ref_lock
op_star
id|lock
)paren
(brace
r_if
c_cond
(paren
id|commit_lock_file
c_func
(paren
id|lock-&gt;lk
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|lock-&gt;lock_fd
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|unlock_ref
r_void
id|unlock_ref
c_func
(paren
r_struct
id|ref_lock
op_star
id|lock
)paren
(brace
multiline_comment|/* Do not free lock-&gt;lk -- atexit() still looks at them */
r_if
c_cond
(paren
id|lock-&gt;lk
)paren
id|rollback_lock_file
c_func
(paren
id|lock-&gt;lk
)paren
suffix:semicolon
id|free
c_func
(paren
id|lock-&gt;ref_name
)paren
suffix:semicolon
id|free
c_func
(paren
id|lock-&gt;orig_ref_name
)paren
suffix:semicolon
id|free
c_func
(paren
id|lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * copy the reflog message msg to buf, which has been allocated sufficiently&n; * large, while cleaning up the whitespaces.  Especially, convert LF to space,&n; * because reflog file is one line per entry.&n; */
DECL|function|copy_msg
r_static
r_int
id|copy_msg
c_func
(paren
r_char
op_star
id|buf
comma
r_const
r_char
op_star
id|msg
)paren
(brace
r_char
op_star
id|cp
op_assign
id|buf
suffix:semicolon
r_char
id|c
suffix:semicolon
r_int
id|wasspace
op_assign
l_int|1
suffix:semicolon
op_star
id|cp
op_increment
op_assign
l_char|&squot;&bslash;t&squot;
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
op_star
id|msg
op_increment
)paren
)paren
(brace
r_if
c_cond
(paren
id|wasspace
op_logical_and
id|isspace
c_func
(paren
id|c
)paren
)paren
r_continue
suffix:semicolon
id|wasspace
op_assign
id|isspace
c_func
(paren
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wasspace
)paren
id|c
op_assign
l_char|&squot; &squot;
suffix:semicolon
op_star
id|cp
op_increment
op_assign
id|c
suffix:semicolon
)brace
r_while
c_loop
(paren
id|buf
OL
id|cp
op_logical_and
id|isspace
c_func
(paren
id|cp
(braket
l_int|1
)braket
)paren
)paren
id|cp
op_decrement
suffix:semicolon
op_star
id|cp
op_increment
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
r_return
id|cp
id|buf
suffix:semicolon
)brace
DECL|function|log_ref_setup
r_int
id|log_ref_setup
c_func
(paren
r_const
r_char
op_star
id|ref_name
comma
r_char
op_star
id|logfile
comma
r_int
id|bufsize
)paren
(brace
r_int
id|logfd
comma
id|oflags
op_assign
id|O_APPEND
op_or
id|O_WRONLY
suffix:semicolon
id|git_snpath
c_func
(paren
id|logfile
comma
id|bufsize
comma
l_string|&quot;logs/%s&quot;
comma
id|ref_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|log_all_ref_updates
op_logical_and
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|ref_name
comma
l_string|&quot;refs/heads/&quot;
)paren
op_logical_or
op_logical_neg
id|prefixcmp
c_func
(paren
id|ref_name
comma
l_string|&quot;refs/remotes/&quot;
)paren
op_logical_or
op_logical_neg
id|prefixcmp
c_func
(paren
id|ref_name
comma
l_string|&quot;refs/notes/&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|ref_name
comma
l_string|&quot;HEAD&quot;
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|safe_create_leading_directories
c_func
(paren
id|logfile
)paren
OL
l_int|0
)paren
r_return
id|error
c_func
(paren
l_string|&quot;unable to create directory for %s&quot;
comma
id|logfile
)paren
suffix:semicolon
id|oflags
op_or_assign
id|O_CREAT
suffix:semicolon
)brace
id|logfd
op_assign
id|open
c_func
(paren
id|logfile
comma
id|oflags
comma
l_int|0666
)paren
suffix:semicolon
r_if
c_cond
(paren
id|logfd
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|oflags
op_amp
id|O_CREAT
)paren
op_logical_and
id|errno
op_eq
id|ENOENT
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|oflags
op_amp
id|O_CREAT
)paren
op_logical_and
id|errno
op_eq
id|EISDIR
)paren
(brace
r_if
c_cond
(paren
id|remove_empty_directories
c_func
(paren
id|logfile
)paren
)paren
(brace
r_return
id|error
c_func
(paren
l_string|&quot;There are still logs under &squot;%s&squot;&quot;
comma
id|logfile
)paren
suffix:semicolon
)brace
id|logfd
op_assign
id|open
c_func
(paren
id|logfile
comma
id|oflags
comma
l_int|0666
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|logfd
OL
l_int|0
)paren
r_return
id|error
c_func
(paren
l_string|&quot;Unable to append to %s: %s&quot;
comma
id|logfile
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
)brace
id|adjust_shared_perm
c_func
(paren
id|logfile
)paren
suffix:semicolon
id|close
c_func
(paren
id|logfd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|log_ref_write
r_static
r_int
id|log_ref_write
c_func
(paren
r_const
r_char
op_star
id|ref_name
comma
r_const
r_int
r_char
op_star
id|old_sha1
comma
r_const
r_int
r_char
op_star
id|new_sha1
comma
r_const
r_char
op_star
id|msg
)paren
(brace
r_int
id|logfd
comma
id|result
comma
id|written
comma
id|oflags
op_assign
id|O_APPEND
op_or
id|O_WRONLY
suffix:semicolon
r_int
id|maxlen
comma
id|len
suffix:semicolon
r_int
id|msglen
suffix:semicolon
r_char
id|log_file
(braket
id|PATH_MAX
)braket
suffix:semicolon
r_char
op_star
id|logrec
suffix:semicolon
r_const
r_char
op_star
id|committer
suffix:semicolon
r_if
c_cond
(paren
id|log_all_ref_updates
OL
l_int|0
)paren
id|log_all_ref_updates
op_assign
op_logical_neg
id|is_bare_repository
c_func
(paren
)paren
suffix:semicolon
id|result
op_assign
id|log_ref_setup
c_func
(paren
id|ref_name
comma
id|log_file
comma
r_sizeof
(paren
id|log_file
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
r_return
id|result
suffix:semicolon
id|logfd
op_assign
id|open
c_func
(paren
id|log_file
comma
id|oflags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|logfd
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|msglen
op_assign
id|msg
ques
c_cond
id|strlen
c_func
(paren
id|msg
)paren
suffix:colon
l_int|0
suffix:semicolon
id|committer
op_assign
id|git_committer_info
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|maxlen
op_assign
id|strlen
c_func
(paren
id|committer
)paren
op_plus
id|msglen
op_plus
l_int|100
suffix:semicolon
id|logrec
op_assign
id|xmalloc
c_func
(paren
id|maxlen
)paren
suffix:semicolon
id|len
op_assign
id|sprintf
c_func
(paren
id|logrec
comma
l_string|&quot;%s %s %s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|old_sha1
)paren
comma
id|sha1_to_hex
c_func
(paren
id|new_sha1
)paren
comma
id|committer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msglen
)paren
id|len
op_add_assign
id|copy_msg
c_func
(paren
id|logrec
op_plus
id|len
l_int|1
comma
id|msg
)paren
l_int|1
suffix:semicolon
id|written
op_assign
id|len
op_le
id|maxlen
ques
c_cond
id|write_in_full
c_func
(paren
id|logfd
comma
id|logrec
comma
id|len
)paren
suffix:colon
l_int|1
suffix:semicolon
id|free
c_func
(paren
id|logrec
)paren
suffix:semicolon
r_if
c_cond
(paren
id|close
c_func
(paren
id|logfd
)paren
op_ne
l_int|0
op_logical_or
id|written
op_ne
id|len
)paren
r_return
id|error
c_func
(paren
l_string|&quot;Unable to append to %s&quot;
comma
id|log_file
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|is_branch
r_static
r_int
id|is_branch
c_func
(paren
r_const
r_char
op_star
id|refname
)paren
(brace
r_return
op_logical_neg
id|strcmp
c_func
(paren
id|refname
comma
l_string|&quot;HEAD&quot;
)paren
op_logical_or
op_logical_neg
id|prefixcmp
c_func
(paren
id|refname
comma
l_string|&quot;refs/heads/&quot;
)paren
suffix:semicolon
)brace
DECL|function|write_ref_sha1
r_int
id|write_ref_sha1
c_func
(paren
r_struct
id|ref_lock
op_star
id|lock
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_const
r_char
op_star
id|logmsg
)paren
(brace
r_static
r_char
id|term
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
r_struct
id|object
op_star
id|o
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lock
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lock-&gt;force_write
op_logical_and
op_logical_neg
id|hashcmp
c_func
(paren
id|lock-&gt;old_sha1
comma
id|sha1
)paren
)paren
(brace
id|unlock_ref
c_func
(paren
id|lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|o
op_assign
id|parse_object
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|o
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Trying to write ref %s with nonexistant object %s&quot;
comma
id|lock-&gt;ref_name
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
id|unlock_ref
c_func
(paren
id|lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|o-&gt;type
op_ne
id|OBJ_COMMIT
op_logical_and
id|is_branch
c_func
(paren
id|lock-&gt;ref_name
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Trying to write non-commit object %s to branch %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
comma
id|lock-&gt;ref_name
)paren
suffix:semicolon
id|unlock_ref
c_func
(paren
id|lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|write_in_full
c_func
(paren
id|lock-&gt;lock_fd
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
comma
l_int|40
)paren
op_ne
l_int|40
op_logical_or
id|write_in_full
c_func
(paren
id|lock-&gt;lock_fd
comma
op_amp
id|term
comma
l_int|1
)paren
op_ne
l_int|1
op_logical_or
id|close_ref
c_func
(paren
id|lock
)paren
OL
l_int|0
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Couldn&squot;t write %s&quot;
comma
id|lock-&gt;lk-&gt;filename
)paren
suffix:semicolon
id|unlock_ref
c_func
(paren
id|lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|invalidate_cached_refs
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|log_ref_write
c_func
(paren
id|lock-&gt;ref_name
comma
id|lock-&gt;old_sha1
comma
id|sha1
comma
id|logmsg
)paren
OL
l_int|0
op_logical_or
(paren
id|strcmp
c_func
(paren
id|lock-&gt;ref_name
comma
id|lock-&gt;orig_ref_name
)paren
op_logical_and
id|log_ref_write
c_func
(paren
id|lock-&gt;orig_ref_name
comma
id|lock-&gt;old_sha1
comma
id|sha1
comma
id|logmsg
)paren
OL
l_int|0
)paren
)paren
(brace
id|unlock_ref
c_func
(paren
id|lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|lock-&gt;orig_ref_name
comma
l_string|&quot;HEAD&quot;
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Special hack: If a branch is updated directly and HEAD&n;&t;&t; * points to it (may happen on the remote side of a push&n;&t;&t; * for example) then logically the HEAD reflog should be&n;&t;&t; * updated too.&n;&t;&t; * A generic solution implies reverse symref information,&n;&t;&t; * but finding all symrefs pointing to the given branch&n;&t;&t; * would be rather costly for this rare event (the direct&n;&t;&t; * update of a branch) to be worth it.  So let&squot;s cheat and&n;&t;&t; * check with HEAD only which should cover 99% of all usage&n;&t;&t; * scenarios (even 100% of the default ones).&n;&t;&t; */
r_int
r_char
id|head_sha1
(braket
l_int|20
)braket
suffix:semicolon
r_int
id|head_flag
suffix:semicolon
r_const
r_char
op_star
id|head_ref
suffix:semicolon
id|head_ref
op_assign
id|resolve_ref
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|head_sha1
comma
l_int|1
comma
op_amp
id|head_flag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|head_ref
op_logical_and
(paren
id|head_flag
op_amp
id|REF_ISSYMREF
)paren
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|head_ref
comma
id|lock-&gt;ref_name
)paren
)paren
id|log_ref_write
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|lock-&gt;old_sha1
comma
id|sha1
comma
id|logmsg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|commit_ref
c_func
(paren
id|lock
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Couldn&squot;t set %s&quot;
comma
id|lock-&gt;ref_name
)paren
suffix:semicolon
id|unlock_ref
c_func
(paren
id|lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|unlock_ref
c_func
(paren
id|lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|create_symref
r_int
id|create_symref
c_func
(paren
r_const
r_char
op_star
id|ref_target
comma
r_const
r_char
op_star
id|refs_heads_master
comma
r_const
r_char
op_star
id|logmsg
)paren
(brace
r_const
r_char
op_star
id|lockpath
suffix:semicolon
r_char
id|ref
(braket
l_int|1000
)braket
suffix:semicolon
r_int
id|fd
comma
id|len
comma
id|written
suffix:semicolon
r_char
op_star
id|git_HEAD
op_assign
id|git_pathdup
c_func
(paren
l_string|&quot;%s&quot;
comma
id|ref_target
)paren
suffix:semicolon
r_int
r_char
id|old_sha1
(braket
l_int|20
)braket
comma
id|new_sha1
(braket
l_int|20
)braket
suffix:semicolon
r_if
c_cond
(paren
id|logmsg
op_logical_and
id|read_ref
c_func
(paren
id|ref_target
comma
id|old_sha1
)paren
)paren
id|hashclr
c_func
(paren
id|old_sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|safe_create_leading_directories
c_func
(paren
id|git_HEAD
)paren
OL
l_int|0
)paren
r_return
id|error
c_func
(paren
l_string|&quot;unable to create directory for %s&quot;
comma
id|git_HEAD
)paren
suffix:semicolon
macro_line|#ifndef NO_SYMLINK_HEAD
r_if
c_cond
(paren
id|prefer_symlink_refs
)paren
(brace
id|unlink
c_func
(paren
id|git_HEAD
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|symlink
c_func
(paren
id|refs_heads_master
comma
id|git_HEAD
)paren
)paren
r_goto
id|done
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;no symlink - falling back to symbolic ref&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|len
op_assign
id|snprintf
c_func
(paren
id|ref
comma
r_sizeof
(paren
id|ref
)paren
comma
l_string|&quot;ref: %s&bslash;n&quot;
comma
id|refs_heads_master
)paren
suffix:semicolon
r_if
c_cond
(paren
r_sizeof
(paren
id|ref
)paren
op_le
id|len
)paren
(brace
id|error
c_func
(paren
l_string|&quot;refname too long: %s&quot;
comma
id|refs_heads_master
)paren
suffix:semicolon
r_goto
id|error_free_return
suffix:semicolon
)brace
id|lockpath
op_assign
id|mkpath
c_func
(paren
l_string|&quot;%s.lock&quot;
comma
id|git_HEAD
)paren
suffix:semicolon
id|fd
op_assign
id|open
c_func
(paren
id|lockpath
comma
id|O_CREAT
op_or
id|O_EXCL
op_or
id|O_WRONLY
comma
l_int|0666
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Unable to open %s for writing&quot;
comma
id|lockpath
)paren
suffix:semicolon
r_goto
id|error_free_return
suffix:semicolon
)brace
id|written
op_assign
id|write_in_full
c_func
(paren
id|fd
comma
id|ref
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|close
c_func
(paren
id|fd
)paren
op_ne
l_int|0
op_logical_or
id|written
op_ne
id|len
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Unable to write to %s&quot;
comma
id|lockpath
)paren
suffix:semicolon
r_goto
id|error_unlink_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rename
c_func
(paren
id|lockpath
comma
id|git_HEAD
)paren
OL
l_int|0
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Unable to create %s&quot;
comma
id|git_HEAD
)paren
suffix:semicolon
r_goto
id|error_unlink_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|adjust_shared_perm
c_func
(paren
id|git_HEAD
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Unable to fix permissions on %s&quot;
comma
id|lockpath
)paren
suffix:semicolon
id|error_unlink_return
suffix:colon
id|unlink_or_warn
c_func
(paren
id|lockpath
)paren
suffix:semicolon
id|error_free_return
suffix:colon
id|free
c_func
(paren
id|git_HEAD
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#ifndef NO_SYMLINK_HEAD
id|done
suffix:colon
macro_line|#endif
r_if
c_cond
(paren
id|logmsg
op_logical_and
op_logical_neg
id|read_ref
c_func
(paren
id|refs_heads_master
comma
id|new_sha1
)paren
)paren
id|log_ref_write
c_func
(paren
id|ref_target
comma
id|old_sha1
comma
id|new_sha1
comma
id|logmsg
)paren
suffix:semicolon
id|free
c_func
(paren
id|git_HEAD
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ref_msg
r_static
r_char
op_star
id|ref_msg
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_const
r_char
op_star
id|endp
)paren
(brace
r_const
r_char
op_star
id|ep
suffix:semicolon
id|line
op_add_assign
l_int|82
suffix:semicolon
id|ep
op_assign
id|memchr
c_func
(paren
id|line
comma
l_char|&squot;&bslash;n&squot;
comma
id|endp
id|line
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ep
)paren
id|ep
op_assign
id|endp
suffix:semicolon
r_return
id|xmemdupz
c_func
(paren
id|line
comma
id|ep
id|line
)paren
suffix:semicolon
)brace
DECL|function|read_ref_at
r_int
id|read_ref_at
c_func
(paren
r_const
r_char
op_star
id|ref
comma
r_int
r_int
id|at_time
comma
r_int
id|cnt
comma
r_int
r_char
op_star
id|sha1
comma
r_char
op_star
op_star
id|msg
comma
r_int
r_int
op_star
id|cutoff_time
comma
r_int
op_star
id|cutoff_tz
comma
r_int
op_star
id|cutoff_cnt
)paren
(brace
r_const
r_char
op_star
id|logfile
comma
op_star
id|logdata
comma
op_star
id|logend
comma
op_star
id|rec
comma
op_star
id|lastgt
comma
op_star
id|lastrec
suffix:semicolon
r_char
op_star
id|tz_c
suffix:semicolon
r_int
id|logfd
comma
id|tz
comma
id|reccnt
op_assign
l_int|0
suffix:semicolon
r_struct
id|stat
id|st
suffix:semicolon
r_int
r_int
id|date
suffix:semicolon
r_int
r_char
id|logged_sha1
(braket
l_int|20
)braket
suffix:semicolon
r_void
op_star
id|log_mapped
suffix:semicolon
r_int
id|mapsz
suffix:semicolon
id|logfile
op_assign
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|ref
)paren
suffix:semicolon
id|logfd
op_assign
id|open
c_func
(paren
id|logfile
comma
id|O_RDONLY
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|logfd
OL
l_int|0
)paren
id|die_errno
c_func
(paren
l_string|&quot;Unable to read log &squot;%s&squot;&quot;
comma
id|logfile
)paren
suffix:semicolon
id|fstat
c_func
(paren
id|logfd
comma
op_amp
id|st
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|st.st_size
)paren
id|die
c_func
(paren
l_string|&quot;Log %s is empty.&quot;
comma
id|logfile
)paren
suffix:semicolon
id|mapsz
op_assign
id|xsize_t
c_func
(paren
id|st.st_size
)paren
suffix:semicolon
id|log_mapped
op_assign
id|xmmap
c_func
(paren
l_int|NULL
comma
id|mapsz
comma
id|PROT_READ
comma
id|MAP_PRIVATE
comma
id|logfd
comma
l_int|0
)paren
suffix:semicolon
id|logdata
op_assign
id|log_mapped
suffix:semicolon
id|close
c_func
(paren
id|logfd
)paren
suffix:semicolon
id|lastrec
op_assign
l_int|NULL
suffix:semicolon
id|rec
op_assign
id|logend
op_assign
id|logdata
op_plus
id|st.st_size
suffix:semicolon
r_while
c_loop
(paren
id|logdata
OL
id|rec
)paren
(brace
id|reccnt
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|logdata
OL
id|rec
op_logical_and
op_star
(paren
id|rec
op_minus
l_int|1
)paren
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|rec
op_decrement
suffix:semicolon
id|lastgt
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|logdata
OL
id|rec
op_logical_and
op_star
(paren
id|rec
op_minus
l_int|1
)paren
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|rec
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_star
id|rec
op_eq
l_char|&squot;&gt;&squot;
)paren
id|lastgt
op_assign
id|rec
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|lastgt
)paren
id|die
c_func
(paren
l_string|&quot;Log %s is corrupt.&quot;
comma
id|logfile
)paren
suffix:semicolon
id|date
op_assign
id|strtoul
c_func
(paren
id|lastgt
op_plus
l_int|1
comma
op_amp
id|tz_c
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|date
op_le
id|at_time
op_logical_or
id|cnt
op_eq
l_int|0
)paren
(brace
id|tz
op_assign
id|strtoul
c_func
(paren
id|tz_c
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg
)paren
op_star
id|msg
op_assign
id|ref_msg
c_func
(paren
id|rec
comma
id|logend
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cutoff_time
)paren
op_star
id|cutoff_time
op_assign
id|date
suffix:semicolon
r_if
c_cond
(paren
id|cutoff_tz
)paren
op_star
id|cutoff_tz
op_assign
id|tz
suffix:semicolon
r_if
c_cond
(paren
id|cutoff_cnt
)paren
op_star
id|cutoff_cnt
op_assign
id|reccnt
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|lastrec
)paren
(brace
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|lastrec
comma
id|logged_sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Log %s is corrupt.&quot;
comma
id|logfile
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|rec
op_plus
l_int|41
comma
id|sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Log %s is corrupt.&quot;
comma
id|logfile
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hashcmp
c_func
(paren
id|logged_sha1
comma
id|sha1
)paren
)paren
(brace
id|warning
c_func
(paren
l_string|&quot;Log %s has gap after %s.&quot;
comma
id|logfile
comma
id|show_date
c_func
(paren
id|date
comma
id|tz
comma
id|DATE_RFC2822
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|date
op_eq
id|at_time
)paren
(brace
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|rec
op_plus
l_int|41
comma
id|sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Log %s is corrupt.&quot;
comma
id|logfile
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|rec
op_plus
l_int|41
comma
id|logged_sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Log %s is corrupt.&quot;
comma
id|logfile
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hashcmp
c_func
(paren
id|logged_sha1
comma
id|sha1
)paren
)paren
(brace
id|warning
c_func
(paren
l_string|&quot;Log %s unexpectedly ended on %s.&quot;
comma
id|logfile
comma
id|show_date
c_func
(paren
id|date
comma
id|tz
comma
id|DATE_RFC2822
)paren
)paren
suffix:semicolon
)brace
)brace
id|munmap
c_func
(paren
id|log_mapped
comma
id|mapsz
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|lastrec
op_assign
id|rec
suffix:semicolon
r_if
c_cond
(paren
id|cnt
OG
l_int|0
)paren
id|cnt
op_decrement
suffix:semicolon
)brace
id|rec
op_assign
id|logdata
suffix:semicolon
r_while
c_loop
(paren
id|rec
OL
id|logend
op_logical_and
op_star
id|rec
op_ne
l_char|&squot;&gt;&squot;
op_logical_and
op_star
id|rec
op_ne
l_char|&squot;&bslash;n&squot;
)paren
id|rec
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|rec
op_eq
id|logend
op_logical_or
op_star
id|rec
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|die
c_func
(paren
l_string|&quot;Log %s is corrupt.&quot;
comma
id|logfile
)paren
suffix:semicolon
id|date
op_assign
id|strtoul
c_func
(paren
id|rec
op_plus
l_int|1
comma
op_amp
id|tz_c
comma
l_int|10
)paren
suffix:semicolon
id|tz
op_assign
id|strtoul
c_func
(paren
id|tz_c
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|logdata
comma
id|sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Log %s is corrupt.&quot;
comma
id|logfile
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_null_sha1
c_func
(paren
id|sha1
)paren
)paren
(brace
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|logdata
op_plus
l_int|41
comma
id|sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Log %s is corrupt.&quot;
comma
id|logfile
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|msg
)paren
op_star
id|msg
op_assign
id|ref_msg
c_func
(paren
id|logdata
comma
id|logend
)paren
suffix:semicolon
id|munmap
c_func
(paren
id|log_mapped
comma
id|mapsz
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cutoff_time
)paren
op_star
id|cutoff_time
op_assign
id|date
suffix:semicolon
r_if
c_cond
(paren
id|cutoff_tz
)paren
op_star
id|cutoff_tz
op_assign
id|tz
suffix:semicolon
r_if
c_cond
(paren
id|cutoff_cnt
)paren
op_star
id|cutoff_cnt
op_assign
id|reccnt
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|for_each_recent_reflog_ent
r_int
id|for_each_recent_reflog_ent
c_func
(paren
r_const
r_char
op_star
id|ref
comma
id|each_reflog_ent_fn
id|fn
comma
r_int
id|ofs
comma
r_void
op_star
id|cb_data
)paren
(brace
r_const
r_char
op_star
id|logfile
suffix:semicolon
id|FILE
op_star
id|logfp
suffix:semicolon
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|logfile
op_assign
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|ref
)paren
suffix:semicolon
id|logfp
op_assign
id|fopen
c_func
(paren
id|logfile
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|logfp
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ofs
)paren
(brace
r_struct
id|stat
id|statbuf
suffix:semicolon
r_if
c_cond
(paren
id|fstat
c_func
(paren
id|fileno
c_func
(paren
id|logfp
)paren
comma
op_amp
id|statbuf
)paren
op_logical_or
id|statbuf.st_size
OL
id|ofs
op_logical_or
id|fseek
c_func
(paren
id|logfp
comma
id|ofs
comma
id|SEEK_END
)paren
op_logical_or
id|strbuf_getwholeline
c_func
(paren
op_amp
id|sb
comma
id|logfp
comma
l_char|&squot;&bslash;n&squot;
)paren
)paren
(brace
id|fclose
c_func
(paren
id|logfp
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
op_logical_neg
id|strbuf_getwholeline
c_func
(paren
op_amp
id|sb
comma
id|logfp
comma
l_char|&squot;&bslash;n&squot;
)paren
)paren
(brace
r_int
r_char
id|osha1
(braket
l_int|20
)braket
comma
id|nsha1
(braket
l_int|20
)braket
suffix:semicolon
r_char
op_star
id|email_end
comma
op_star
id|message
suffix:semicolon
r_int
r_int
id|timestamp
suffix:semicolon
r_int
id|tz
suffix:semicolon
multiline_comment|/* old SP new SP name &lt;email&gt; SP time TAB msg LF */
r_if
c_cond
(paren
id|sb.len
OL
l_int|83
op_logical_or
id|sb.buf
(braket
id|sb.len
l_int|1
)braket
op_ne
l_char|&squot;&bslash;n&squot;
op_logical_or
id|get_sha1_hex
c_func
(paren
id|sb.buf
comma
id|osha1
)paren
op_logical_or
id|sb.buf
(braket
l_int|40
)braket
op_ne
l_char|&squot; &squot;
op_logical_or
id|get_sha1_hex
c_func
(paren
id|sb.buf
op_plus
l_int|41
comma
id|nsha1
)paren
op_logical_or
id|sb.buf
(braket
l_int|81
)braket
op_ne
l_char|&squot; &squot;
op_logical_or
op_logical_neg
(paren
id|email_end
op_assign
id|strchr
c_func
(paren
id|sb.buf
op_plus
l_int|82
comma
l_char|&squot;&gt;&squot;
)paren
)paren
op_logical_or
id|email_end
(braket
l_int|1
)braket
op_ne
l_char|&squot; &squot;
op_logical_or
op_logical_neg
(paren
id|timestamp
op_assign
id|strtoul
c_func
(paren
id|email_end
op_plus
l_int|2
comma
op_amp
id|message
comma
l_int|10
)paren
)paren
op_logical_or
op_logical_neg
id|message
op_logical_or
id|message
(braket
l_int|0
)braket
op_ne
l_char|&squot; &squot;
op_logical_or
(paren
id|message
(braket
l_int|1
)braket
op_ne
l_char|&squot;+&squot;
op_logical_and
id|message
(braket
l_int|1
)braket
op_ne
l_char|&squot;-&squot;
)paren
op_logical_or
op_logical_neg
id|isdigit
c_func
(paren
id|message
(braket
l_int|2
)braket
)paren
op_logical_or
op_logical_neg
id|isdigit
c_func
(paren
id|message
(braket
l_int|3
)braket
)paren
op_logical_or
op_logical_neg
id|isdigit
c_func
(paren
id|message
(braket
l_int|4
)braket
)paren
op_logical_or
op_logical_neg
id|isdigit
c_func
(paren
id|message
(braket
l_int|5
)braket
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* corrupt? */
id|email_end
(braket
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|tz
op_assign
id|strtol
c_func
(paren
id|message
op_plus
l_int|1
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|message
(braket
l_int|6
)braket
op_ne
l_char|&squot;&bslash;t&squot;
)paren
id|message
op_add_assign
l_int|6
suffix:semicolon
r_else
id|message
op_add_assign
l_int|7
suffix:semicolon
id|ret
op_assign
id|fn
c_func
(paren
id|osha1
comma
id|nsha1
comma
id|sb.buf
op_plus
l_int|82
comma
id|timestamp
comma
id|tz
comma
id|message
comma
id|cb_data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_break
suffix:semicolon
)brace
id|fclose
c_func
(paren
id|logfp
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|for_each_reflog_ent
r_int
id|for_each_reflog_ent
c_func
(paren
r_const
r_char
op_star
id|ref
comma
id|each_reflog_ent_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|for_each_recent_reflog_ent
c_func
(paren
id|ref
comma
id|fn
comma
l_int|0
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|do_for_each_reflog
r_static
r_int
id|do_for_each_reflog
c_func
(paren
r_const
r_char
op_star
id|base
comma
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
id|DIR
op_star
id|dir
op_assign
id|opendir
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|base
)paren
)paren
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dir
)paren
(brace
r_struct
id|dirent
op_star
id|de
suffix:semicolon
r_int
id|baselen
op_assign
id|strlen
c_func
(paren
id|base
)paren
suffix:semicolon
r_char
op_star
id|log
op_assign
id|xmalloc
c_func
(paren
id|baselen
op_plus
l_int|257
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|log
comma
id|base
comma
id|baselen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|baselen
op_logical_and
id|base
(braket
id|baselen
op_minus
l_int|1
)braket
op_ne
l_char|&squot;/&squot;
)paren
id|log
(braket
id|baselen
op_increment
)braket
op_assign
l_char|&squot;/&squot;
suffix:semicolon
r_while
c_loop
(paren
(paren
id|de
op_assign
id|readdir
c_func
(paren
id|dir
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_struct
id|stat
id|st
suffix:semicolon
r_int
id|namelen
suffix:semicolon
r_if
c_cond
(paren
id|de-&gt;d_name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
)paren
r_continue
suffix:semicolon
id|namelen
op_assign
id|strlen
c_func
(paren
id|de-&gt;d_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|namelen
OG
l_int|255
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|has_extension
c_func
(paren
id|de-&gt;d_name
comma
l_string|&quot;.lock&quot;
)paren
)paren
r_continue
suffix:semicolon
id|memcpy
c_func
(paren
id|log
op_plus
id|baselen
comma
id|de-&gt;d_name
comma
id|namelen
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|log
)paren
comma
op_amp
id|st
)paren
OL
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|st.st_mode
)paren
)paren
(brace
id|retval
op_assign
id|do_for_each_reflog
c_func
(paren
id|log
comma
id|fn
comma
id|cb_data
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|resolve_ref
c_func
(paren
id|log
comma
id|sha1
comma
l_int|0
comma
l_int|NULL
)paren
)paren
id|retval
op_assign
id|error
c_func
(paren
l_string|&quot;bad ref for %s&quot;
comma
id|log
)paren
suffix:semicolon
r_else
id|retval
op_assign
id|fn
c_func
(paren
id|log
comma
id|sha1
comma
l_int|0
comma
id|cb_data
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retval
)paren
r_break
suffix:semicolon
)brace
id|free
c_func
(paren
id|log
)paren
suffix:semicolon
id|closedir
c_func
(paren
id|dir
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_star
id|base
)paren
r_return
id|errno
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|for_each_reflog
r_int
id|for_each_reflog
c_func
(paren
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|do_for_each_reflog
c_func
(paren
l_string|&quot;&quot;
comma
id|fn
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|update_ref
r_int
id|update_ref
c_func
(paren
r_const
r_char
op_star
id|action
comma
r_const
r_char
op_star
id|refname
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_const
r_int
r_char
op_star
id|oldval
comma
r_int
id|flags
comma
r_enum
id|action_on_err
id|onerr
)paren
(brace
r_static
r_struct
id|ref_lock
op_star
id|lock
suffix:semicolon
id|lock
op_assign
id|lock_any_ref_for_update
c_func
(paren
id|refname
comma
id|oldval
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lock
)paren
(brace
r_const
r_char
op_star
id|str
op_assign
l_string|&quot;Cannot lock the ref &squot;%s&squot;.&quot;
suffix:semicolon
r_switch
c_cond
(paren
id|onerr
)paren
(brace
r_case
id|MSG_ON_ERR
suffix:colon
id|error
c_func
(paren
id|str
comma
id|refname
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DIE_ON_ERR
suffix:colon
id|die
c_func
(paren
id|str
comma
id|refname
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QUIET_ON_ERR
suffix:colon
r_break
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|write_ref_sha1
c_func
(paren
id|lock
comma
id|sha1
comma
id|action
)paren
OL
l_int|0
)paren
(brace
r_const
r_char
op_star
id|str
op_assign
l_string|&quot;Cannot update the ref &squot;%s&squot;.&quot;
suffix:semicolon
r_switch
c_cond
(paren
id|onerr
)paren
(brace
r_case
id|MSG_ON_ERR
suffix:colon
id|error
c_func
(paren
id|str
comma
id|refname
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DIE_ON_ERR
suffix:colon
id|die
c_func
(paren
id|str
comma
id|refname
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QUIET_ON_ERR
suffix:colon
r_break
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|find_ref_by_name
r_struct
id|ref
op_star
id|find_ref_by_name
c_func
(paren
r_const
r_struct
id|ref
op_star
id|list
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|list
suffix:semicolon
id|list
op_assign
id|list-&gt;next
)paren
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|list-&gt;name
comma
id|name
)paren
)paren
r_return
(paren
r_struct
id|ref
op_star
)paren
id|list
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * generate a format suitable for scanf from a ref_rev_parse_rules&n; * rule, that is replace the &quot;%.*s&quot; spec with a &quot;%s&quot; spec&n; */
DECL|function|gen_scanf_fmt
r_static
r_void
id|gen_scanf_fmt
c_func
(paren
r_char
op_star
id|scanf_fmt
comma
r_const
r_char
op_star
id|rule
)paren
(brace
r_char
op_star
id|spec
suffix:semicolon
id|spec
op_assign
id|strstr
c_func
(paren
id|rule
comma
l_string|&quot;%.*s&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|spec
op_logical_or
id|strstr
c_func
(paren
id|spec
op_plus
l_int|4
comma
l_string|&quot;%.*s&quot;
)paren
)paren
id|die
c_func
(paren
l_string|&quot;invalid rule in ref_rev_parse_rules: %s&quot;
comma
id|rule
)paren
suffix:semicolon
multiline_comment|/* copy all until spec */
id|strncpy
c_func
(paren
id|scanf_fmt
comma
id|rule
comma
id|spec
id|rule
)paren
suffix:semicolon
id|scanf_fmt
(braket
id|spec
id|rule
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
multiline_comment|/* copy new spec */
id|strcat
c_func
(paren
id|scanf_fmt
comma
l_string|&quot;%s&quot;
)paren
suffix:semicolon
multiline_comment|/* copy remaining rule */
id|strcat
c_func
(paren
id|scanf_fmt
comma
id|spec
op_plus
l_int|4
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|shorten_unambiguous_ref
r_char
op_star
id|shorten_unambiguous_ref
c_func
(paren
r_const
r_char
op_star
id|ref
comma
r_int
id|strict
)paren
(brace
r_int
id|i
suffix:semicolon
r_static
r_char
op_star
op_star
id|scanf_fmts
suffix:semicolon
r_static
r_int
id|nr_rules
suffix:semicolon
r_char
op_star
id|short_name
suffix:semicolon
multiline_comment|/* pre generate scanf formats from ref_rev_parse_rules[] */
r_if
c_cond
(paren
op_logical_neg
id|nr_rules
)paren
(brace
r_int
id|total_len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* the rule list is NULL terminated, count them first */
r_for
c_loop
(paren
suffix:semicolon
id|ref_rev_parse_rules
(braket
id|nr_rules
)braket
suffix:semicolon
id|nr_rules
op_increment
)paren
multiline_comment|/* no +1 because strlen(&quot;%s&quot;) &lt; strlen(&quot;%.*s&quot;) */
id|total_len
op_add_assign
id|strlen
c_func
(paren
id|ref_rev_parse_rules
(braket
id|nr_rules
)braket
)paren
suffix:semicolon
id|scanf_fmts
op_assign
id|xmalloc
c_func
(paren
id|nr_rules
op_star
r_sizeof
(paren
r_char
op_star
)paren
op_plus
id|total_len
)paren
suffix:semicolon
id|total_len
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_rules
suffix:semicolon
id|i
op_increment
)paren
(brace
id|scanf_fmts
(braket
id|i
)braket
op_assign
(paren
r_char
op_star
)paren
op_amp
id|scanf_fmts
(braket
id|nr_rules
)braket
op_plus
id|total_len
suffix:semicolon
id|gen_scanf_fmt
c_func
(paren
id|scanf_fmts
(braket
id|i
)braket
comma
id|ref_rev_parse_rules
(braket
id|i
)braket
)paren
suffix:semicolon
id|total_len
op_add_assign
id|strlen
c_func
(paren
id|ref_rev_parse_rules
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* bail out if there are no rules */
r_if
c_cond
(paren
op_logical_neg
id|nr_rules
)paren
r_return
id|xstrdup
c_func
(paren
id|ref
)paren
suffix:semicolon
multiline_comment|/* buffer for scanf result, at most ref must fit */
id|short_name
op_assign
id|xstrdup
c_func
(paren
id|ref
)paren
suffix:semicolon
multiline_comment|/* skip first rule, it will always match */
r_for
c_loop
(paren
id|i
op_assign
id|nr_rules
l_int|1
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
op_decrement
id|i
)paren
(brace
r_int
id|j
suffix:semicolon
r_int
id|rules_to_fail
op_assign
id|i
suffix:semicolon
r_int
id|short_name_len
suffix:semicolon
r_if
c_cond
(paren
l_int|1
op_ne
id|sscanf
c_func
(paren
id|ref
comma
id|scanf_fmts
(braket
id|i
)braket
comma
id|short_name
)paren
)paren
r_continue
suffix:semicolon
id|short_name_len
op_assign
id|strlen
c_func
(paren
id|short_name
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * in strict mode, all (except the matched one) rules&n;&t;&t; * must fail to resolve to a valid non-ambiguous ref&n;&t;&t; */
r_if
c_cond
(paren
id|strict
)paren
id|rules_to_fail
op_assign
id|nr_rules
suffix:semicolon
multiline_comment|/*&n;&t;&t; * check if the short name resolves to a valid ref,&n;&t;&t; * but use only rules prior to the matched one&n;&t;&t; */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|rules_to_fail
suffix:semicolon
id|j
op_increment
)paren
(brace
r_const
r_char
op_star
id|rule
op_assign
id|ref_rev_parse_rules
(braket
id|j
)braket
suffix:semicolon
r_int
r_char
id|short_objectname
(braket
l_int|20
)braket
suffix:semicolon
r_char
id|refname
(braket
id|PATH_MAX
)braket
suffix:semicolon
multiline_comment|/* skip matched rule */
r_if
c_cond
(paren
id|i
op_eq
id|j
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * the short name is ambiguous, if it resolves&n;&t;&t;&t; * (with this previous rule) to a valid ref&n;&t;&t;&t; * read_ref() returns 0 on success&n;&t;&t;&t; */
id|mksnpath
c_func
(paren
id|refname
comma
r_sizeof
(paren
id|refname
)paren
comma
id|rule
comma
id|short_name_len
comma
id|short_name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|read_ref
c_func
(paren
id|refname
comma
id|short_objectname
)paren
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * short name is non-ambiguous if all previous rules&n;&t;&t; * haven&squot;t resolved to a valid ref&n;&t;&t; */
r_if
c_cond
(paren
id|j
op_eq
id|rules_to_fail
)paren
r_return
id|short_name
suffix:semicolon
)brace
id|free
c_func
(paren
id|short_name
)paren
suffix:semicolon
r_return
id|xstrdup
c_func
(paren
id|ref
)paren
suffix:semicolon
)brace
eof
