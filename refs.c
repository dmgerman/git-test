macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;refs.h&quot;
macro_line|#include &quot;object.h&quot;
macro_line|#include &quot;tag.h&quot;
macro_line|#include &quot;dir.h&quot;
multiline_comment|/*&n; * Make sure &quot;ref&quot; is something reasonable to have under &quot;.git/refs/&quot;;&n; * We do not like it if:&n; *&n; * - any path component of it begins with &quot;.&quot;, or&n; * - it has double dots &quot;..&quot;, or&n; * - it has ASCII control character, &quot;~&quot;, &quot;^&quot;, &quot;:&quot; or SP, anywhere, or&n; * - it ends with a &quot;/&quot;.&n; * - it ends with &quot;.lock&quot;&n; * - it contains a &quot;&bslash;&quot; (backslash)&n; */
multiline_comment|/* Return true iff ch is not allowed in reference names. */
DECL|function|bad_ref_char
r_static
r_inline
r_int
id|bad_ref_char
c_func
(paren
r_int
id|ch
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
r_int
)paren
id|ch
)paren
op_le
l_char|&squot; &squot;
op_logical_or
id|ch
op_eq
l_int|0x7f
op_logical_or
id|ch
op_eq
l_char|&squot;~&squot;
op_logical_or
id|ch
op_eq
l_char|&squot;^&squot;
op_logical_or
id|ch
op_eq
l_char|&squot;:&squot;
op_logical_or
id|ch
op_eq
l_char|&squot;&bslash;&bslash;&squot;
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* 2.13 Pattern Matching Notation */
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;*&squot;
op_logical_or
id|ch
op_eq
l_char|&squot;?&squot;
op_logical_or
id|ch
op_eq
l_char|&squot;[&squot;
)paren
multiline_comment|/* Unsupported */
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Try to read one refname component from the front of refname.  Return&n; * the length of the component found, or -1 if the component is not&n; * legal.&n; */
DECL|function|check_refname_component
r_static
r_int
id|check_refname_component
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_int
id|flags
)paren
(brace
r_const
r_char
op_star
id|cp
suffix:semicolon
r_char
id|last
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_for
c_loop
(paren
id|cp
op_assign
id|refname
suffix:semicolon
suffix:semicolon
id|cp
op_increment
)paren
(brace
r_char
id|ch
op_assign
op_star
id|cp
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;&bslash;0&squot;
op_logical_or
id|ch
op_eq
l_char|&squot;/&squot;
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|bad_ref_char
c_func
(paren
id|ch
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Illegal character in refname. */
r_if
c_cond
(paren
id|last
op_eq
l_char|&squot;.&squot;
op_logical_and
id|ch
op_eq
l_char|&squot;.&squot;
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Refname contains &quot;..&quot;. */
r_if
c_cond
(paren
id|last
op_eq
l_char|&squot;@&squot;
op_logical_and
id|ch
op_eq
l_char|&squot;{&squot;
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Refname contains &quot;@{&quot;. */
id|last
op_assign
id|ch
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cp
op_eq
id|refname
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Component has zero length. */
r_if
c_cond
(paren
id|refname
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|REFNAME_DOT_COMPONENT
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Component starts with &squot;.&squot;. */
multiline_comment|/*&n;&t;&t; * Even if leading dots are allowed, don&squot;t allow &quot;.&quot;&n;&t;&t; * as a component (&quot;..&quot; is prevented by a rule above).&n;&t;&t; */
r_if
c_cond
(paren
id|refname
(braket
l_int|1
)braket
op_eq
l_char|&squot;&bslash;0&squot;
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Component equals &quot;.&quot;. */
)brace
r_if
c_cond
(paren
id|cp
id|refname
op_ge
l_int|5
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|cp
l_int|5
comma
l_string|&quot;.lock&quot;
comma
l_int|5
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Refname ends with &quot;.lock&quot;. */
r_return
id|cp
id|refname
suffix:semicolon
)brace
DECL|function|check_refname_format
r_int
id|check_refname_format
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_int
id|flags
)paren
(brace
r_int
id|component_len
comma
id|component_count
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
multiline_comment|/* We are at the start of a path component. */
id|component_len
op_assign
id|check_refname_component
c_func
(paren
id|refname
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|component_len
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|REFNAME_REFSPEC_PATTERN
)paren
op_logical_and
id|refname
(braket
l_int|0
)braket
op_eq
l_char|&squot;*&squot;
op_logical_and
(paren
id|refname
(braket
l_int|1
)braket
op_eq
l_char|&squot;&bslash;0&squot;
op_logical_or
id|refname
(braket
l_int|1
)braket
op_eq
l_char|&squot;/&squot;
)paren
)paren
(brace
multiline_comment|/* Accept one wildcard as a full refname component. */
id|flags
op_and_assign
op_complement
id|REFNAME_REFSPEC_PATTERN
suffix:semicolon
id|component_len
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_return
l_int|1
suffix:semicolon
)brace
)brace
id|component_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|refname
(braket
id|component_len
)braket
op_eq
l_char|&squot;&bslash;0&squot;
)paren
r_break
suffix:semicolon
multiline_comment|/* Skip to next component. */
id|refname
op_add_assign
id|component_len
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|refname
(braket
id|component_len
l_int|1
)braket
op_eq
l_char|&squot;.&squot;
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Refname ends with &squot;.&squot;. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|REFNAME_ALLOW_ONELEVEL
)paren
op_logical_and
id|component_count
OL
l_int|2
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Refname has only one component. */
r_return
l_int|0
suffix:semicolon
)brace
r_struct
id|ref_entry
suffix:semicolon
DECL|struct|ref_array
r_struct
id|ref_array
(brace
DECL|member|nr
DECL|member|alloc
r_int
id|nr
comma
id|alloc
suffix:semicolon
multiline_comment|/*&n;&t; * Entries with index 0 &lt;= i &lt; sorted are sorted by name.  New&n;&t; * entries are appended to the list unsorted, and are sorted&n;&t; * only when required; thus we avoid the need to sort the list&n;&t; * after the addition of every reference.&n;&t; */
DECL|member|sorted
r_int
id|sorted
suffix:semicolon
DECL|member|refs
r_struct
id|ref_entry
op_star
op_star
id|refs
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* ISSYMREF=0x01, ISPACKED=0x02 and ISBROKEN=0x04 are public interfaces */
DECL|macro|REF_KNOWS_PEELED
mdefine_line|#define REF_KNOWS_PEELED 0x10
DECL|struct|ref_entry
r_struct
id|ref_entry
(brace
DECL|member|flag
r_int
r_char
id|flag
suffix:semicolon
multiline_comment|/* ISSYMREF? ISPACKED? */
DECL|member|sha1
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
DECL|member|peeled
r_int
r_char
id|peeled
(braket
l_int|20
)braket
suffix:semicolon
multiline_comment|/* The full name of the reference (e.g., &quot;refs/heads/master&quot;): */
DECL|member|name
r_char
id|name
(braket
id|FLEX_ARRAY
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|function|create_ref_entry
r_static
r_struct
id|ref_entry
op_star
id|create_ref_entry
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
id|flag
comma
r_int
id|check_name
)paren
(brace
r_int
id|len
suffix:semicolon
r_struct
id|ref_entry
op_star
id|ref
suffix:semicolon
r_if
c_cond
(paren
id|check_name
op_logical_and
id|check_refname_format
c_func
(paren
id|refname
comma
id|REFNAME_ALLOW_ONELEVEL
op_or
id|REFNAME_DOT_COMPONENT
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Reference has invalid format: &squot;%s&squot;&quot;
comma
id|refname
)paren
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|refname
)paren
op_plus
l_int|1
suffix:semicolon
id|ref
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ref_entry
)paren
op_plus
id|len
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|ref-&gt;sha1
comma
id|sha1
)paren
suffix:semicolon
id|hashclr
c_func
(paren
id|ref-&gt;peeled
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ref-&gt;name
comma
id|refname
comma
id|len
)paren
suffix:semicolon
id|ref-&gt;flag
op_assign
id|flag
suffix:semicolon
r_return
id|ref
suffix:semicolon
)brace
multiline_comment|/* Add a ref_entry to the end of the ref_array (unsorted). */
DECL|function|add_ref
r_static
r_void
id|add_ref
c_func
(paren
r_struct
id|ref_array
op_star
id|refs
comma
r_struct
id|ref_entry
op_star
id|ref
)paren
(brace
id|ALLOC_GROW
c_func
(paren
id|refs-&gt;refs
comma
id|refs-&gt;nr
op_plus
l_int|1
comma
id|refs-&gt;alloc
)paren
suffix:semicolon
id|refs-&gt;refs
(braket
id|refs-&gt;nr
op_increment
)braket
op_assign
id|ref
suffix:semicolon
)brace
DECL|function|clear_ref_array
r_static
r_void
id|clear_ref_array
c_func
(paren
r_struct
id|ref_array
op_star
id|array
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|array-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
id|free
c_func
(paren
id|array-&gt;refs
(braket
id|i
)braket
)paren
suffix:semicolon
id|free
c_func
(paren
id|array-&gt;refs
)paren
suffix:semicolon
id|array-&gt;sorted
op_assign
id|array-&gt;nr
op_assign
id|array-&gt;alloc
op_assign
l_int|0
suffix:semicolon
id|array-&gt;refs
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|ref_entry_cmp
r_static
r_int
id|ref_entry_cmp
c_func
(paren
r_const
r_void
op_star
id|a
comma
r_const
r_void
op_star
id|b
)paren
(brace
r_struct
id|ref_entry
op_star
id|one
op_assign
op_star
(paren
r_struct
id|ref_entry
op_star
op_star
)paren
id|a
suffix:semicolon
r_struct
id|ref_entry
op_star
id|two
op_assign
op_star
(paren
r_struct
id|ref_entry
op_star
op_star
)paren
id|b
suffix:semicolon
r_return
id|strcmp
c_func
(paren
id|one-&gt;name
comma
id|two-&gt;name
)paren
suffix:semicolon
)brace
r_static
r_void
id|sort_ref_array
c_func
(paren
r_struct
id|ref_array
op_star
id|array
)paren
suffix:semicolon
DECL|function|search_ref_array
r_static
r_struct
id|ref_entry
op_star
id|search_ref_array
c_func
(paren
r_struct
id|ref_array
op_star
id|array
comma
r_const
r_char
op_star
id|refname
)paren
(brace
r_struct
id|ref_entry
op_star
id|e
comma
op_star
op_star
id|r
suffix:semicolon
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
id|refname
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|array-&gt;nr
)paren
r_return
l_int|NULL
suffix:semicolon
id|sort_ref_array
c_func
(paren
id|array
)paren
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|refname
)paren
op_plus
l_int|1
suffix:semicolon
id|e
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ref_entry
)paren
op_plus
id|len
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|e-&gt;name
comma
id|refname
comma
id|len
)paren
suffix:semicolon
id|r
op_assign
id|bsearch
c_func
(paren
op_amp
id|e
comma
id|array-&gt;refs
comma
id|array-&gt;nr
comma
r_sizeof
(paren
op_star
id|array-&gt;refs
)paren
comma
id|ref_entry_cmp
)paren
suffix:semicolon
id|free
c_func
(paren
id|e
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
op_star
id|r
suffix:semicolon
)brace
multiline_comment|/*&n; * Emit a warning and return true iff ref1 and ref2 have the same name&n; * and the same sha1.  Die if they have the same name but different&n; * sha1s.&n; */
DECL|function|is_dup_ref
r_static
r_int
id|is_dup_ref
c_func
(paren
r_const
r_struct
id|ref_entry
op_star
id|ref1
comma
r_const
r_struct
id|ref_entry
op_star
id|ref2
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|ref1-&gt;name
comma
id|ref2-&gt;name
)paren
)paren
(brace
multiline_comment|/* Duplicate name; make sure that the SHA1s match: */
r_if
c_cond
(paren
id|hashcmp
c_func
(paren
id|ref1-&gt;sha1
comma
id|ref2-&gt;sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Duplicated ref, and SHA1s don&squot;t match: %s&quot;
comma
id|ref1-&gt;name
)paren
suffix:semicolon
id|warning
c_func
(paren
l_string|&quot;Duplicated ref: %s&quot;
comma
id|ref1-&gt;name
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Sort the entries in array (if they are not already sorted).&n; */
DECL|function|sort_ref_array
r_static
r_void
id|sort_ref_array
c_func
(paren
r_struct
id|ref_array
op_star
id|array
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
multiline_comment|/*&n;&t; * This check also prevents passing a zero-length array to qsort(),&n;&t; * which is a problem on some platforms.&n;&t; */
r_if
c_cond
(paren
id|array-&gt;sorted
op_eq
id|array-&gt;nr
)paren
r_return
suffix:semicolon
id|qsort
c_func
(paren
id|array-&gt;refs
comma
id|array-&gt;nr
comma
r_sizeof
(paren
op_star
id|array-&gt;refs
)paren
comma
id|ref_entry_cmp
)paren
suffix:semicolon
multiline_comment|/* Remove any duplicates from the ref_array */
id|i
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|1
suffix:semicolon
id|j
OL
id|array-&gt;nr
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|is_dup_ref
c_func
(paren
id|array-&gt;refs
(braket
id|i
)braket
comma
id|array-&gt;refs
(braket
id|j
)braket
)paren
)paren
(brace
id|free
c_func
(paren
id|array-&gt;refs
(braket
id|j
)braket
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|array-&gt;refs
(braket
op_increment
id|i
)braket
op_assign
id|array-&gt;refs
(braket
id|j
)braket
suffix:semicolon
)brace
id|array-&gt;sorted
op_assign
id|array-&gt;nr
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
)brace
DECL|macro|DO_FOR_EACH_INCLUDE_BROKEN
mdefine_line|#define DO_FOR_EACH_INCLUDE_BROKEN 01
DECL|variable|current_ref
r_static
r_struct
id|ref_entry
op_star
id|current_ref
suffix:semicolon
DECL|function|do_one_ref
r_static
r_int
id|do_one_ref
c_func
(paren
r_const
r_char
op_star
id|base
comma
id|each_ref_fn
id|fn
comma
r_int
id|trim
comma
r_int
id|flags
comma
r_void
op_star
id|cb_data
comma
r_struct
id|ref_entry
op_star
id|entry
)paren
(brace
r_int
id|retval
suffix:semicolon
r_if
c_cond
(paren
id|prefixcmp
c_func
(paren
id|entry-&gt;name
comma
id|base
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|DO_FOR_EACH_INCLUDE_BROKEN
)paren
)paren
(brace
r_if
c_cond
(paren
id|entry-&gt;flag
op_amp
id|REF_ISBROKEN
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* ignore broken refs e.g. dangling symref */
r_if
c_cond
(paren
op_logical_neg
id|has_sha1_file
c_func
(paren
id|entry-&gt;sha1
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;%s does not point to a valid object!&quot;
comma
id|entry-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|current_ref
op_assign
id|entry
suffix:semicolon
id|retval
op_assign
id|fn
c_func
(paren
id|entry-&gt;name
op_plus
id|trim
comma
id|entry-&gt;sha1
comma
id|entry-&gt;flag
comma
id|cb_data
)paren
suffix:semicolon
id|current_ref
op_assign
l_int|NULL
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Call fn for each reference in array that has index in the range&n; * offset &lt;= index &lt; array-&gt;nr.  This function does not sort the&n; * array; sorting should be done by the caller.&n; */
DECL|function|do_for_each_ref_in_array
r_static
r_int
id|do_for_each_ref_in_array
c_func
(paren
r_struct
id|ref_array
op_star
id|array
comma
r_int
id|offset
comma
r_const
r_char
op_star
id|base
comma
id|each_ref_fn
id|fn
comma
r_int
id|trim
comma
r_int
id|flags
comma
r_void
op_star
id|cb_data
)paren
(brace
r_int
id|i
suffix:semicolon
m_assert
(paren
id|array-&gt;sorted
op_eq
id|array-&gt;nr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|offset
suffix:semicolon
id|i
OL
id|array-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|retval
op_assign
id|do_one_ref
c_func
(paren
id|base
comma
id|fn
comma
id|trim
comma
id|flags
comma
id|cb_data
comma
id|array-&gt;refs
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Call fn for each reference in the union of array1 and array2, in&n; * order by refname.  If an entry appears in both array1 and array2,&n; * then only process the version that is in array2.  The input arrays&n; * must already be sorted.&n; */
DECL|function|do_for_each_ref_in_arrays
r_static
r_int
id|do_for_each_ref_in_arrays
c_func
(paren
r_struct
id|ref_array
op_star
id|array1
comma
r_struct
id|ref_array
op_star
id|array2
comma
r_const
r_char
op_star
id|base
comma
id|each_ref_fn
id|fn
comma
r_int
id|trim
comma
r_int
id|flags
comma
r_void
op_star
id|cb_data
)paren
(brace
r_int
id|retval
suffix:semicolon
r_int
id|i1
op_assign
l_int|0
comma
id|i2
op_assign
l_int|0
suffix:semicolon
m_assert
(paren
id|array1-&gt;sorted
op_eq
id|array1-&gt;nr
)paren
suffix:semicolon
m_assert
(paren
id|array2-&gt;sorted
op_eq
id|array2-&gt;nr
)paren
suffix:semicolon
r_while
c_loop
(paren
id|i1
OL
id|array1-&gt;nr
op_logical_and
id|i2
OL
id|array2-&gt;nr
)paren
(brace
r_struct
id|ref_entry
op_star
id|e1
op_assign
id|array1-&gt;refs
(braket
id|i1
)braket
suffix:semicolon
r_struct
id|ref_entry
op_star
id|e2
op_assign
id|array2-&gt;refs
(braket
id|i2
)braket
suffix:semicolon
r_int
id|cmp
op_assign
id|strcmp
c_func
(paren
id|e1-&gt;name
comma
id|e2-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmp
OL
l_int|0
)paren
(brace
id|retval
op_assign
id|do_one_ref
c_func
(paren
id|base
comma
id|fn
comma
id|trim
comma
id|flags
comma
id|cb_data
comma
id|e1
)paren
suffix:semicolon
id|i1
op_increment
suffix:semicolon
)brace
r_else
(brace
id|retval
op_assign
id|do_one_ref
c_func
(paren
id|base
comma
id|fn
comma
id|trim
comma
id|flags
comma
id|cb_data
comma
id|e2
)paren
suffix:semicolon
id|i2
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|cmp
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * There was a ref in array1 with the&n;&t;&t;&t;&t; * same name; ignore it.&n;&t;&t;&t;&t; */
id|i1
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i1
OL
id|array1-&gt;nr
)paren
r_return
id|do_for_each_ref_in_array
c_func
(paren
id|array1
comma
id|i1
comma
id|base
comma
id|fn
comma
id|trim
comma
id|flags
comma
id|cb_data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i2
OL
id|array2-&gt;nr
)paren
r_return
id|do_for_each_ref_in_array
c_func
(paren
id|array2
comma
id|i2
comma
id|base
comma
id|fn
comma
id|trim
comma
id|flags
comma
id|cb_data
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Return true iff refname1 and refname2 conflict with each other.&n; * Two reference names conflict if one of them exactly matches the&n; * leading components of the other; e.g., &quot;foo/bar&quot; conflicts with&n; * both &quot;foo&quot; and with &quot;foo/bar/baz&quot; but not with &quot;foo/bar&quot; or&n; * &quot;foo/barbados&quot;.&n; */
DECL|function|names_conflict
r_static
r_int
id|names_conflict
c_func
(paren
r_const
r_char
op_star
id|refname1
comma
r_const
r_char
op_star
id|refname2
)paren
(brace
r_int
id|len1
op_assign
id|strlen
c_func
(paren
id|refname1
)paren
suffix:semicolon
r_int
id|len2
op_assign
id|strlen
c_func
(paren
id|refname2
)paren
suffix:semicolon
r_int
id|cmplen
suffix:semicolon
r_const
r_char
op_star
id|lead
suffix:semicolon
r_if
c_cond
(paren
id|len1
OL
id|len2
)paren
(brace
id|cmplen
op_assign
id|len1
suffix:semicolon
id|lead
op_assign
id|refname2
suffix:semicolon
)brace
r_else
(brace
id|cmplen
op_assign
id|len2
suffix:semicolon
id|lead
op_assign
id|refname1
suffix:semicolon
)brace
r_return
op_logical_neg
id|strncmp
c_func
(paren
id|refname1
comma
id|refname2
comma
id|cmplen
)paren
op_logical_and
id|lead
(braket
id|cmplen
)braket
op_eq
l_char|&squot;/&squot;
suffix:semicolon
)brace
multiline_comment|/*&n; * Return true iff a reference named refname could be created without&n; * conflicting with the name of an existing reference.  If oldrefname&n; * is non-NULL, ignore potential conflicts with oldrefname (e.g.,&n; * because oldrefname is scheduled for deletion in the same&n; * operation).&n; */
DECL|function|is_refname_available
r_static
r_int
id|is_refname_available
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_const
r_char
op_star
id|oldrefname
comma
r_struct
id|ref_array
op_star
id|array
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|array-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|ref_entry
op_star
id|entry
op_assign
id|array-&gt;refs
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|oldrefname
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|oldrefname
comma
id|entry-&gt;name
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|names_conflict
c_func
(paren
id|refname
comma
id|entry-&gt;name
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;&squot;%s&squot; exists; cannot create &squot;%s&squot;&quot;
comma
id|entry-&gt;name
comma
id|refname
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Future: need to be in &quot;struct repository&quot;&n; * when doing a full libification.&n; */
DECL|struct|ref_cache
r_static
r_struct
id|ref_cache
(brace
DECL|member|next
r_struct
id|ref_cache
op_star
id|next
suffix:semicolon
DECL|member|did_loose
r_char
id|did_loose
suffix:semicolon
DECL|member|did_packed
r_char
id|did_packed
suffix:semicolon
DECL|member|loose
r_struct
id|ref_array
id|loose
suffix:semicolon
DECL|member|packed
r_struct
id|ref_array
id|packed
suffix:semicolon
multiline_comment|/* The submodule name, or &quot;&quot; for the main repo. */
DECL|member|name
r_char
id|name
(braket
id|FLEX_ARRAY
)braket
suffix:semicolon
DECL|variable|ref_cache
)brace
op_star
id|ref_cache
suffix:semicolon
DECL|function|clear_packed_ref_cache
r_static
r_void
id|clear_packed_ref_cache
c_func
(paren
r_struct
id|ref_cache
op_star
id|refs
)paren
(brace
r_if
c_cond
(paren
id|refs-&gt;did_packed
)paren
id|clear_ref_array
c_func
(paren
op_amp
id|refs-&gt;packed
)paren
suffix:semicolon
id|refs-&gt;did_packed
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|clear_loose_ref_cache
r_static
r_void
id|clear_loose_ref_cache
c_func
(paren
r_struct
id|ref_cache
op_star
id|refs
)paren
(brace
r_if
c_cond
(paren
id|refs-&gt;did_loose
)paren
id|clear_ref_array
c_func
(paren
op_amp
id|refs-&gt;loose
)paren
suffix:semicolon
id|refs-&gt;did_loose
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|create_ref_cache
r_static
r_struct
id|ref_cache
op_star
id|create_ref_cache
c_func
(paren
r_const
r_char
op_star
id|submodule
)paren
(brace
r_int
id|len
suffix:semicolon
r_struct
id|ref_cache
op_star
id|refs
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|submodule
)paren
id|submodule
op_assign
l_string|&quot;&quot;
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|submodule
)paren
op_plus
l_int|1
suffix:semicolon
id|refs
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|ref_cache
)paren
op_plus
id|len
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|refs-&gt;name
comma
id|submodule
comma
id|len
)paren
suffix:semicolon
r_return
id|refs
suffix:semicolon
)brace
multiline_comment|/*&n; * Return a pointer to a ref_cache for the specified submodule. For&n; * the main repository, use submodule==NULL. The returned structure&n; * will be allocated and initialized but not necessarily populated; it&n; * should not be freed.&n; */
DECL|function|get_ref_cache
r_static
r_struct
id|ref_cache
op_star
id|get_ref_cache
c_func
(paren
r_const
r_char
op_star
id|submodule
)paren
(brace
r_struct
id|ref_cache
op_star
id|refs
op_assign
id|ref_cache
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|submodule
)paren
id|submodule
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_while
c_loop
(paren
id|refs
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|submodule
comma
id|refs-&gt;name
)paren
)paren
r_return
id|refs
suffix:semicolon
id|refs
op_assign
id|refs-&gt;next
suffix:semicolon
)brace
id|refs
op_assign
id|create_ref_cache
c_func
(paren
id|submodule
)paren
suffix:semicolon
id|refs-&gt;next
op_assign
id|ref_cache
suffix:semicolon
id|ref_cache
op_assign
id|refs
suffix:semicolon
r_return
id|refs
suffix:semicolon
)brace
DECL|function|invalidate_ref_cache
r_void
id|invalidate_ref_cache
c_func
(paren
r_const
r_char
op_star
id|submodule
)paren
(brace
r_struct
id|ref_cache
op_star
id|refs
op_assign
id|get_ref_cache
c_func
(paren
id|submodule
)paren
suffix:semicolon
id|clear_packed_ref_cache
c_func
(paren
id|refs
)paren
suffix:semicolon
id|clear_loose_ref_cache
c_func
(paren
id|refs
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Parse one line from a packed-refs file.  Write the SHA1 to sha1.&n; * Return a pointer to the refname within the line (null-terminated),&n; * or NULL if there was a problem.&n; */
DECL|function|parse_ref_line
r_static
r_const
r_char
op_star
id|parse_ref_line
c_func
(paren
r_char
op_star
id|line
comma
r_int
r_char
op_star
id|sha1
)paren
(brace
multiline_comment|/*&n;&t; * 42: the answer to everything.&n;&t; *&n;&t; * In this case, it happens to be the answer to&n;&t; *  40 (length of sha1 hex representation)&n;&t; *  +1 (space in between hex and name)&n;&t; *  +1 (newline at the end of the line)&n;&t; */
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|line
)paren
l_int|42
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|line
comma
id|sha1
)paren
OL
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|isspace
c_func
(paren
id|line
(braket
l_int|40
)braket
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|line
op_add_assign
l_int|41
suffix:semicolon
r_if
c_cond
(paren
id|isspace
c_func
(paren
op_star
id|line
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|line
(braket
id|len
)braket
op_ne
l_char|&squot;&bslash;n&squot;
)paren
r_return
l_int|NULL
suffix:semicolon
id|line
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
r_return
id|line
suffix:semicolon
)brace
DECL|function|read_packed_refs
r_static
r_void
id|read_packed_refs
c_func
(paren
id|FILE
op_star
id|f
comma
r_struct
id|ref_array
op_star
id|array
)paren
(brace
r_struct
id|ref_entry
op_star
id|last
op_assign
l_int|NULL
suffix:semicolon
r_char
id|refline
(braket
id|PATH_MAX
)braket
suffix:semicolon
r_int
id|flag
op_assign
id|REF_ISPACKED
suffix:semicolon
r_while
c_loop
(paren
id|fgets
c_func
(paren
id|refline
comma
r_sizeof
(paren
id|refline
)paren
comma
id|f
)paren
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_const
r_char
op_star
id|refname
suffix:semicolon
r_static
r_const
r_char
id|header
(braket
)braket
op_assign
l_string|&quot;# pack-refs with:&quot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|refline
comma
id|header
comma
r_sizeof
(paren
id|header
)paren
op_minus
l_int|1
)paren
)paren
(brace
r_const
r_char
op_star
id|traits
op_assign
id|refline
op_plus
r_sizeof
(paren
id|header
)paren
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|traits
comma
l_string|&quot; peeled &quot;
)paren
)paren
id|flag
op_or_assign
id|REF_KNOWS_PEELED
suffix:semicolon
multiline_comment|/* perhaps other traits later as well */
r_continue
suffix:semicolon
)brace
id|refname
op_assign
id|parse_ref_line
c_func
(paren
id|refline
comma
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|refname
)paren
(brace
id|last
op_assign
id|create_ref_entry
c_func
(paren
id|refname
comma
id|sha1
comma
id|flag
comma
l_int|1
)paren
suffix:semicolon
id|add_ref
c_func
(paren
id|array
comma
id|last
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|last
op_logical_and
id|refline
(braket
l_int|0
)braket
op_eq
l_char|&squot;^&squot;
op_logical_and
id|strlen
c_func
(paren
id|refline
)paren
op_eq
l_int|42
op_logical_and
id|refline
(braket
l_int|41
)braket
op_eq
l_char|&squot;&bslash;n&squot;
op_logical_and
op_logical_neg
id|get_sha1_hex
c_func
(paren
id|refline
op_plus
l_int|1
comma
id|sha1
)paren
)paren
id|hashcpy
c_func
(paren
id|last-&gt;peeled
comma
id|sha1
)paren
suffix:semicolon
)brace
)brace
DECL|function|get_packed_refs
r_static
r_struct
id|ref_array
op_star
id|get_packed_refs
c_func
(paren
r_struct
id|ref_cache
op_star
id|refs
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|refs-&gt;did_packed
)paren
(brace
r_const
r_char
op_star
id|packed_refs_file
suffix:semicolon
id|FILE
op_star
id|f
suffix:semicolon
r_if
c_cond
(paren
op_star
id|refs-&gt;name
)paren
id|packed_refs_file
op_assign
id|git_path_submodule
c_func
(paren
id|refs-&gt;name
comma
l_string|&quot;packed-refs&quot;
)paren
suffix:semicolon
r_else
id|packed_refs_file
op_assign
id|git_path
c_func
(paren
l_string|&quot;packed-refs&quot;
)paren
suffix:semicolon
id|f
op_assign
id|fopen
c_func
(paren
id|packed_refs_file
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|f
)paren
(brace
id|read_packed_refs
c_func
(paren
id|f
comma
op_amp
id|refs-&gt;packed
)paren
suffix:semicolon
id|fclose
c_func
(paren
id|f
)paren
suffix:semicolon
)brace
id|refs-&gt;did_packed
op_assign
l_int|1
suffix:semicolon
)brace
r_return
op_amp
id|refs-&gt;packed
suffix:semicolon
)brace
DECL|function|add_packed_ref
r_void
id|add_packed_ref
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
id|add_ref
c_func
(paren
id|get_packed_refs
c_func
(paren
id|get_ref_cache
c_func
(paren
l_int|NULL
)paren
)paren
comma
id|create_ref_entry
c_func
(paren
id|refname
comma
id|sha1
comma
id|REF_ISPACKED
comma
l_int|1
)paren
)paren
suffix:semicolon
)brace
DECL|function|get_ref_dir
r_static
r_void
id|get_ref_dir
c_func
(paren
r_struct
id|ref_cache
op_star
id|refs
comma
r_const
r_char
op_star
id|base
comma
r_struct
id|ref_array
op_star
id|array
)paren
(brace
id|DIR
op_star
id|dir
suffix:semicolon
r_const
r_char
op_star
id|path
suffix:semicolon
r_if
c_cond
(paren
op_star
id|refs-&gt;name
)paren
id|path
op_assign
id|git_path_submodule
c_func
(paren
id|refs-&gt;name
comma
l_string|&quot;%s&quot;
comma
id|base
)paren
suffix:semicolon
r_else
id|path
op_assign
id|git_path
c_func
(paren
l_string|&quot;%s&quot;
comma
id|base
)paren
suffix:semicolon
id|dir
op_assign
id|opendir
c_func
(paren
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dir
)paren
(brace
r_struct
id|dirent
op_star
id|de
suffix:semicolon
r_int
id|baselen
op_assign
id|strlen
c_func
(paren
id|base
)paren
suffix:semicolon
r_char
op_star
id|refname
op_assign
id|xmalloc
c_func
(paren
id|baselen
op_plus
l_int|257
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|refname
comma
id|base
comma
id|baselen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|baselen
op_logical_and
id|base
(braket
id|baselen
op_minus
l_int|1
)braket
op_ne
l_char|&squot;/&squot;
)paren
id|refname
(braket
id|baselen
op_increment
)braket
op_assign
l_char|&squot;/&squot;
suffix:semicolon
r_while
c_loop
(paren
(paren
id|de
op_assign
id|readdir
c_func
(paren
id|dir
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_struct
id|stat
id|st
suffix:semicolon
r_int
id|flag
suffix:semicolon
r_int
id|namelen
suffix:semicolon
r_const
r_char
op_star
id|refdir
suffix:semicolon
r_if
c_cond
(paren
id|de-&gt;d_name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
)paren
r_continue
suffix:semicolon
id|namelen
op_assign
id|strlen
c_func
(paren
id|de-&gt;d_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|namelen
OG
l_int|255
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|has_extension
c_func
(paren
id|de-&gt;d_name
comma
l_string|&quot;.lock&quot;
)paren
)paren
r_continue
suffix:semicolon
id|memcpy
c_func
(paren
id|refname
op_plus
id|baselen
comma
id|de-&gt;d_name
comma
id|namelen
op_plus
l_int|1
)paren
suffix:semicolon
id|refdir
op_assign
op_star
id|refs-&gt;name
ques
c_cond
id|git_path_submodule
c_func
(paren
id|refs-&gt;name
comma
l_string|&quot;%s&quot;
comma
id|refname
)paren
suffix:colon
id|git_path
c_func
(paren
l_string|&quot;%s&quot;
comma
id|refname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
c_func
(paren
id|refdir
comma
op_amp
id|st
)paren
OL
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|st.st_mode
)paren
)paren
(brace
id|get_ref_dir
c_func
(paren
id|refs
comma
id|refname
comma
id|array
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|refs-&gt;name
)paren
(brace
id|hashclr
c_func
(paren
id|sha1
)paren
suffix:semicolon
id|flag
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|resolve_gitlink_ref
c_func
(paren
id|refs-&gt;name
comma
id|refname
comma
id|sha1
)paren
OL
l_int|0
)paren
(brace
id|hashclr
c_func
(paren
id|sha1
)paren
suffix:semicolon
id|flag
op_or_assign
id|REF_ISBROKEN
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|read_ref_full
c_func
(paren
id|refname
comma
id|sha1
comma
l_int|1
comma
op_amp
id|flag
)paren
)paren
(brace
id|hashclr
c_func
(paren
id|sha1
)paren
suffix:semicolon
id|flag
op_or_assign
id|REF_ISBROKEN
suffix:semicolon
)brace
id|add_ref
c_func
(paren
id|array
comma
id|create_ref_entry
c_func
(paren
id|refname
comma
id|sha1
comma
id|flag
comma
l_int|1
)paren
)paren
suffix:semicolon
)brace
id|free
c_func
(paren
id|refname
)paren
suffix:semicolon
id|closedir
c_func
(paren
id|dir
)paren
suffix:semicolon
)brace
)brace
DECL|function|get_loose_refs
r_static
r_struct
id|ref_array
op_star
id|get_loose_refs
c_func
(paren
r_struct
id|ref_cache
op_star
id|refs
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|refs-&gt;did_loose
)paren
(brace
id|get_ref_dir
c_func
(paren
id|refs
comma
l_string|&quot;refs&quot;
comma
op_amp
id|refs-&gt;loose
)paren
suffix:semicolon
id|refs-&gt;did_loose
op_assign
l_int|1
suffix:semicolon
)brace
r_return
op_amp
id|refs-&gt;loose
suffix:semicolon
)brace
multiline_comment|/* We allow &quot;recursive&quot; symbolic refs. Only within reason, though */
DECL|macro|MAXDEPTH
mdefine_line|#define MAXDEPTH 5
DECL|macro|MAXREFLEN
mdefine_line|#define MAXREFLEN (1024)
multiline_comment|/*&n; * Called by resolve_gitlink_ref_recursive() after it failed to read&n; * from the loose refs in ref_cache refs. Find &lt;refname&gt; in the&n; * packed-refs file for the submodule.&n; */
DECL|function|resolve_gitlink_packed_ref
r_static
r_int
id|resolve_gitlink_packed_ref
c_func
(paren
r_struct
id|ref_cache
op_star
id|refs
comma
r_const
r_char
op_star
id|refname
comma
r_int
r_char
op_star
id|sha1
)paren
(brace
r_struct
id|ref_entry
op_star
id|ref
suffix:semicolon
r_struct
id|ref_array
op_star
id|array
op_assign
id|get_packed_refs
c_func
(paren
id|refs
)paren
suffix:semicolon
id|ref
op_assign
id|search_ref_array
c_func
(paren
id|array
comma
id|refname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ref
op_eq
l_int|NULL
)paren
r_return
l_int|1
suffix:semicolon
id|memcpy
c_func
(paren
id|sha1
comma
id|ref-&gt;sha1
comma
l_int|20
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|resolve_gitlink_ref_recursive
r_static
r_int
id|resolve_gitlink_ref_recursive
c_func
(paren
r_struct
id|ref_cache
op_star
id|refs
comma
r_const
r_char
op_star
id|refname
comma
r_int
r_char
op_star
id|sha1
comma
r_int
id|recursion
)paren
(brace
r_int
id|fd
comma
id|len
suffix:semicolon
r_char
id|buffer
(braket
l_int|128
)braket
comma
op_star
id|p
suffix:semicolon
r_char
op_star
id|path
suffix:semicolon
r_if
c_cond
(paren
id|recursion
OG
id|MAXDEPTH
op_logical_or
id|strlen
c_func
(paren
id|refname
)paren
OG
id|MAXREFLEN
)paren
r_return
l_int|1
suffix:semicolon
id|path
op_assign
op_star
id|refs-&gt;name
ques
c_cond
id|git_path_submodule
c_func
(paren
id|refs-&gt;name
comma
l_string|&quot;%s&quot;
comma
id|refname
)paren
suffix:colon
id|git_path
c_func
(paren
l_string|&quot;%s&quot;
comma
id|refname
)paren
suffix:semicolon
id|fd
op_assign
id|open
c_func
(paren
id|path
comma
id|O_RDONLY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
r_return
id|resolve_gitlink_packed_ref
c_func
(paren
id|refs
comma
id|refname
comma
id|sha1
)paren
suffix:semicolon
id|len
op_assign
id|read
c_func
(paren
id|fd
comma
id|buffer
comma
r_sizeof
(paren
id|buffer
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|len
op_logical_and
id|isspace
c_func
(paren
id|buffer
(braket
id|len
op_minus
l_int|1
)braket
)paren
)paren
id|len
op_decrement
suffix:semicolon
id|buffer
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Was it a detached head or an old-fashioned symlink? */
r_if
c_cond
(paren
op_logical_neg
id|get_sha1_hex
c_func
(paren
id|buffer
comma
id|sha1
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Symref? */
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|buffer
comma
l_string|&quot;ref:&quot;
comma
l_int|4
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|p
op_assign
id|buffer
op_plus
l_int|4
suffix:semicolon
r_while
c_loop
(paren
id|isspace
c_func
(paren
op_star
id|p
)paren
)paren
id|p
op_increment
suffix:semicolon
r_return
id|resolve_gitlink_ref_recursive
c_func
(paren
id|refs
comma
id|p
comma
id|sha1
comma
id|recursion
op_plus
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|resolve_gitlink_ref
r_int
id|resolve_gitlink_ref
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_const
r_char
op_star
id|refname
comma
r_int
r_char
op_star
id|sha1
)paren
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|path
)paren
comma
id|retval
suffix:semicolon
r_char
op_star
id|submodule
suffix:semicolon
r_struct
id|ref_cache
op_star
id|refs
suffix:semicolon
r_while
c_loop
(paren
id|len
op_logical_and
id|path
(braket
id|len
op_minus
l_int|1
)braket
op_eq
l_char|&squot;/&squot;
)paren
id|len
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
r_return
l_int|1
suffix:semicolon
id|submodule
op_assign
id|xstrndup
c_func
(paren
id|path
comma
id|len
)paren
suffix:semicolon
id|refs
op_assign
id|get_ref_cache
c_func
(paren
id|submodule
)paren
suffix:semicolon
id|free
c_func
(paren
id|submodule
)paren
suffix:semicolon
id|retval
op_assign
id|resolve_gitlink_ref_recursive
c_func
(paren
id|refs
comma
id|refname
comma
id|sha1
comma
l_int|0
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Try to read ref from the packed references.  On success, set sha1&n; * and return 0; otherwise, return -1.&n; */
DECL|function|get_packed_ref
r_static
r_int
id|get_packed_ref
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_int
r_char
op_star
id|sha1
)paren
(brace
r_struct
id|ref_array
op_star
id|packed
op_assign
id|get_packed_refs
c_func
(paren
id|get_ref_cache
c_func
(paren
l_int|NULL
)paren
)paren
suffix:semicolon
r_struct
id|ref_entry
op_star
id|entry
op_assign
id|search_ref_array
c_func
(paren
id|packed
comma
id|refname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
)paren
(brace
id|hashcpy
c_func
(paren
id|sha1
comma
id|entry-&gt;sha1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|resolve_ref_unsafe
r_const
r_char
op_star
id|resolve_ref_unsafe
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_int
r_char
op_star
id|sha1
comma
r_int
id|reading
comma
r_int
op_star
id|flag
)paren
(brace
r_int
id|depth
op_assign
id|MAXDEPTH
suffix:semicolon
id|ssize_t
id|len
suffix:semicolon
r_char
id|buffer
(braket
l_int|256
)braket
suffix:semicolon
r_static
r_char
id|refname_buffer
(braket
l_int|256
)braket
suffix:semicolon
r_if
c_cond
(paren
id|flag
)paren
op_star
id|flag
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|check_refname_format
c_func
(paren
id|refname
comma
id|REFNAME_ALLOW_ONELEVEL
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_char
id|path
(braket
id|PATH_MAX
)braket
suffix:semicolon
r_struct
id|stat
id|st
suffix:semicolon
r_char
op_star
id|buf
suffix:semicolon
r_int
id|fd
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|depth
OL
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
id|git_snpath
c_func
(paren
id|path
comma
r_sizeof
(paren
id|path
)paren
comma
l_string|&quot;%s&quot;
comma
id|refname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lstat
c_func
(paren
id|path
comma
op_amp
id|st
)paren
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|errno
op_ne
id|ENOENT
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * The loose reference file does not exist;&n;&t;&t;&t; * check for a packed reference.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|get_packed_ref
c_func
(paren
id|refname
comma
id|sha1
)paren
)paren
(brace
r_if
c_cond
(paren
id|flag
)paren
op_star
id|flag
op_or_assign
id|REF_ISPACKED
suffix:semicolon
r_return
id|refname
suffix:semicolon
)brace
multiline_comment|/* The reference is not a packed reference, either. */
r_if
c_cond
(paren
id|reading
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|hashclr
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_return
id|refname
suffix:semicolon
)brace
)brace
multiline_comment|/* Follow &quot;normalized&quot; - ie &quot;refs/..&quot; symlinks by hand */
r_if
c_cond
(paren
id|S_ISLNK
c_func
(paren
id|st.st_mode
)paren
)paren
(brace
id|len
op_assign
id|readlink
c_func
(paren
id|path
comma
id|buffer
comma
r_sizeof
(paren
id|buffer
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
id|buffer
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|buffer
comma
l_string|&quot;refs/&quot;
)paren
op_logical_and
op_logical_neg
id|check_refname_format
c_func
(paren
id|buffer
comma
l_int|0
)paren
)paren
(brace
id|strcpy
c_func
(paren
id|refname_buffer
comma
id|buffer
)paren
suffix:semicolon
id|refname
op_assign
id|refname_buffer
suffix:semicolon
r_if
c_cond
(paren
id|flag
)paren
op_star
id|flag
op_or_assign
id|REF_ISSYMREF
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
multiline_comment|/* Is it a directory? */
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|st.st_mode
)paren
)paren
(brace
id|errno
op_assign
id|EISDIR
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Anything else, just open it and try to use it as&n;&t;&t; * a ref&n;&t;&t; */
id|fd
op_assign
id|open
c_func
(paren
id|path
comma
id|O_RDONLY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
id|len
op_assign
id|read_in_full
c_func
(paren
id|fd
comma
id|buffer
comma
r_sizeof
(paren
id|buffer
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|len
op_logical_and
id|isspace
c_func
(paren
id|buffer
(braket
id|len
op_minus
l_int|1
)braket
)paren
)paren
id|len
op_decrement
suffix:semicolon
id|buffer
(braket
id|len
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Is it a symbolic ref?&n;&t;&t; */
r_if
c_cond
(paren
id|prefixcmp
c_func
(paren
id|buffer
comma
l_string|&quot;ref:&quot;
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|flag
)paren
op_star
id|flag
op_or_assign
id|REF_ISSYMREF
suffix:semicolon
id|buf
op_assign
id|buffer
op_plus
l_int|4
suffix:semicolon
r_while
c_loop
(paren
id|isspace
c_func
(paren
op_star
id|buf
)paren
)paren
id|buf
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|check_refname_format
c_func
(paren
id|buf
comma
id|REFNAME_ALLOW_ONELEVEL
)paren
)paren
(brace
r_if
c_cond
(paren
id|flag
)paren
op_star
id|flag
op_or_assign
id|REF_ISBROKEN
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|refname
op_assign
id|strcpy
c_func
(paren
id|refname_buffer
comma
id|buf
)paren
suffix:semicolon
)brace
multiline_comment|/* Please note that FETCH_HEAD has a second line containing other data. */
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|buffer
comma
id|sha1
)paren
op_logical_or
(paren
id|buffer
(braket
l_int|40
)braket
op_ne
l_char|&squot;&bslash;0&squot;
op_logical_and
op_logical_neg
id|isspace
c_func
(paren
id|buffer
(braket
l_int|40
)braket
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|flag
)paren
op_star
id|flag
op_or_assign
id|REF_ISBROKEN
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|refname
suffix:semicolon
)brace
DECL|function|resolve_refdup
r_char
op_star
id|resolve_refdup
c_func
(paren
r_const
r_char
op_star
id|ref
comma
r_int
r_char
op_star
id|sha1
comma
r_int
id|reading
comma
r_int
op_star
id|flag
)paren
(brace
r_const
r_char
op_star
id|ret
op_assign
id|resolve_ref_unsafe
c_func
(paren
id|ref
comma
id|sha1
comma
id|reading
comma
id|flag
)paren
suffix:semicolon
r_return
id|ret
ques
c_cond
id|xstrdup
c_func
(paren
id|ret
)paren
suffix:colon
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* The argument to filter_refs */
DECL|struct|ref_filter
r_struct
id|ref_filter
(brace
DECL|member|pattern
r_const
r_char
op_star
id|pattern
suffix:semicolon
DECL|member|fn
id|each_ref_fn
op_star
id|fn
suffix:semicolon
DECL|member|cb_data
r_void
op_star
id|cb_data
suffix:semicolon
)brace
suffix:semicolon
DECL|function|read_ref_full
r_int
id|read_ref_full
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_int
r_char
op_star
id|sha1
comma
r_int
id|reading
comma
r_int
op_star
id|flags
)paren
(brace
r_if
c_cond
(paren
id|resolve_ref_unsafe
c_func
(paren
id|refname
comma
id|sha1
comma
id|reading
comma
id|flags
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|read_ref
r_int
id|read_ref
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_int
r_char
op_star
id|sha1
)paren
(brace
r_return
id|read_ref_full
c_func
(paren
id|refname
comma
id|sha1
comma
l_int|1
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|ref_exists
r_int
id|ref_exists
c_func
(paren
r_const
r_char
op_star
id|refname
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_return
op_logical_neg
op_logical_neg
id|resolve_ref_unsafe
c_func
(paren
id|refname
comma
id|sha1
comma
l_int|1
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|filter_refs
r_static
r_int
id|filter_refs
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
id|flags
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|ref_filter
op_star
id|filter
op_assign
(paren
r_struct
id|ref_filter
op_star
)paren
id|data
suffix:semicolon
r_if
c_cond
(paren
id|fnmatch
c_func
(paren
id|filter-&gt;pattern
comma
id|refname
comma
l_int|0
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|filter
op_member_access_from_pointer
id|fn
c_func
(paren
id|refname
comma
id|sha1
comma
id|flags
comma
id|filter-&gt;cb_data
)paren
suffix:semicolon
)brace
DECL|function|peel_ref
r_int
id|peel_ref
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_int
r_char
op_star
id|sha1
)paren
(brace
r_int
id|flag
suffix:semicolon
r_int
r_char
id|base
(braket
l_int|20
)braket
suffix:semicolon
r_struct
id|object
op_star
id|o
suffix:semicolon
r_if
c_cond
(paren
id|current_ref
op_logical_and
(paren
id|current_ref-&gt;name
op_eq
id|refname
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|current_ref-&gt;name
comma
id|refname
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|current_ref-&gt;flag
op_amp
id|REF_KNOWS_PEELED
)paren
(brace
id|hashcpy
c_func
(paren
id|sha1
comma
id|current_ref-&gt;peeled
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|hashcpy
c_func
(paren
id|base
comma
id|current_ref-&gt;sha1
)paren
suffix:semicolon
r_goto
id|fallback
suffix:semicolon
)brace
r_if
c_cond
(paren
id|read_ref_full
c_func
(paren
id|refname
comma
id|base
comma
l_int|1
comma
op_amp
id|flag
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flag
op_amp
id|REF_ISPACKED
)paren
)paren
(brace
r_struct
id|ref_array
op_star
id|array
op_assign
id|get_packed_refs
c_func
(paren
id|get_ref_cache
c_func
(paren
l_int|NULL
)paren
)paren
suffix:semicolon
r_struct
id|ref_entry
op_star
id|r
op_assign
id|search_ref_array
c_func
(paren
id|array
comma
id|refname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_ne
l_int|NULL
op_logical_and
id|r-&gt;flag
op_amp
id|REF_KNOWS_PEELED
)paren
(brace
id|hashcpy
c_func
(paren
id|sha1
comma
id|r-&gt;peeled
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|fallback
suffix:colon
id|o
op_assign
id|parse_object
c_func
(paren
id|base
)paren
suffix:semicolon
r_if
c_cond
(paren
id|o
op_logical_and
id|o-&gt;type
op_eq
id|OBJ_TAG
)paren
(brace
id|o
op_assign
id|deref_tag
c_func
(paren
id|o
comma
id|refname
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|o
)paren
(brace
id|hashcpy
c_func
(paren
id|sha1
comma
id|o-&gt;sha1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|struct|warn_if_dangling_data
r_struct
id|warn_if_dangling_data
(brace
DECL|member|fp
id|FILE
op_star
id|fp
suffix:semicolon
DECL|member|refname
r_const
r_char
op_star
id|refname
suffix:semicolon
DECL|member|msg_fmt
r_const
r_char
op_star
id|msg_fmt
suffix:semicolon
)brace
suffix:semicolon
DECL|function|warn_if_dangling_symref
r_static
r_int
id|warn_if_dangling_symref
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
id|flags
comma
r_void
op_star
id|cb_data
)paren
(brace
r_struct
id|warn_if_dangling_data
op_star
id|d
op_assign
id|cb_data
suffix:semicolon
r_const
r_char
op_star
id|resolves_to
suffix:semicolon
r_int
r_char
id|junk
(braket
l_int|20
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|REF_ISSYMREF
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|resolves_to
op_assign
id|resolve_ref_unsafe
c_func
(paren
id|refname
comma
id|junk
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|resolves_to
op_logical_or
id|strcmp
c_func
(paren
id|resolves_to
comma
id|d-&gt;refname
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|fprintf
c_func
(paren
id|d-&gt;fp
comma
id|d-&gt;msg_fmt
comma
id|refname
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|warn_dangling_symref
r_void
id|warn_dangling_symref
c_func
(paren
id|FILE
op_star
id|fp
comma
r_const
r_char
op_star
id|msg_fmt
comma
r_const
r_char
op_star
id|refname
)paren
(brace
r_struct
id|warn_if_dangling_data
id|data
suffix:semicolon
id|data.fp
op_assign
id|fp
suffix:semicolon
id|data.refname
op_assign
id|refname
suffix:semicolon
id|data.msg_fmt
op_assign
id|msg_fmt
suffix:semicolon
id|for_each_rawref
c_func
(paren
id|warn_if_dangling_symref
comma
op_amp
id|data
)paren
suffix:semicolon
)brace
DECL|function|do_for_each_ref
r_static
r_int
id|do_for_each_ref
c_func
(paren
r_const
r_char
op_star
id|submodule
comma
r_const
r_char
op_star
id|base
comma
id|each_ref_fn
id|fn
comma
r_int
id|trim
comma
r_int
id|flags
comma
r_void
op_star
id|cb_data
)paren
(brace
r_struct
id|ref_cache
op_star
id|refs
op_assign
id|get_ref_cache
c_func
(paren
id|submodule
)paren
suffix:semicolon
r_struct
id|ref_array
op_star
id|packed_refs
op_assign
id|get_packed_refs
c_func
(paren
id|refs
)paren
suffix:semicolon
r_struct
id|ref_array
op_star
id|loose_refs
op_assign
id|get_loose_refs
c_func
(paren
id|refs
)paren
suffix:semicolon
id|sort_ref_array
c_func
(paren
id|packed_refs
)paren
suffix:semicolon
id|sort_ref_array
c_func
(paren
id|loose_refs
)paren
suffix:semicolon
r_return
id|do_for_each_ref_in_arrays
c_func
(paren
id|packed_refs
comma
id|loose_refs
comma
id|base
comma
id|fn
comma
id|trim
comma
id|flags
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|do_head_ref
r_static
r_int
id|do_head_ref
c_func
(paren
r_const
r_char
op_star
id|submodule
comma
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_int
id|flag
suffix:semicolon
r_if
c_cond
(paren
id|submodule
)paren
(brace
r_if
c_cond
(paren
id|resolve_gitlink_ref
c_func
(paren
id|submodule
comma
l_string|&quot;HEAD&quot;
comma
id|sha1
)paren
op_eq
l_int|0
)paren
r_return
id|fn
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|sha1
comma
l_int|0
comma
id|cb_data
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|read_ref_full
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|sha1
comma
l_int|1
comma
op_amp
id|flag
)paren
)paren
r_return
id|fn
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|sha1
comma
id|flag
comma
id|cb_data
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|head_ref
r_int
id|head_ref
c_func
(paren
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|do_head_ref
c_func
(paren
l_int|NULL
comma
id|fn
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|head_ref_submodule
r_int
id|head_ref_submodule
c_func
(paren
r_const
r_char
op_star
id|submodule
comma
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|do_head_ref
c_func
(paren
id|submodule
comma
id|fn
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|for_each_ref
r_int
id|for_each_ref
c_func
(paren
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|do_for_each_ref
c_func
(paren
l_int|NULL
comma
l_string|&quot;&quot;
comma
id|fn
comma
l_int|0
comma
l_int|0
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|for_each_ref_submodule
r_int
id|for_each_ref_submodule
c_func
(paren
r_const
r_char
op_star
id|submodule
comma
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|do_for_each_ref
c_func
(paren
id|submodule
comma
l_string|&quot;&quot;
comma
id|fn
comma
l_int|0
comma
l_int|0
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|for_each_ref_in
r_int
id|for_each_ref_in
c_func
(paren
r_const
r_char
op_star
id|prefix
comma
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|do_for_each_ref
c_func
(paren
l_int|NULL
comma
id|prefix
comma
id|fn
comma
id|strlen
c_func
(paren
id|prefix
)paren
comma
l_int|0
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|for_each_ref_in_submodule
r_int
id|for_each_ref_in_submodule
c_func
(paren
r_const
r_char
op_star
id|submodule
comma
r_const
r_char
op_star
id|prefix
comma
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|do_for_each_ref
c_func
(paren
id|submodule
comma
id|prefix
comma
id|fn
comma
id|strlen
c_func
(paren
id|prefix
)paren
comma
l_int|0
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|for_each_tag_ref
r_int
id|for_each_tag_ref
c_func
(paren
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|for_each_ref_in
c_func
(paren
l_string|&quot;refs/tags/&quot;
comma
id|fn
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|for_each_tag_ref_submodule
r_int
id|for_each_tag_ref_submodule
c_func
(paren
r_const
r_char
op_star
id|submodule
comma
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|for_each_ref_in_submodule
c_func
(paren
id|submodule
comma
l_string|&quot;refs/tags/&quot;
comma
id|fn
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|for_each_branch_ref
r_int
id|for_each_branch_ref
c_func
(paren
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|for_each_ref_in
c_func
(paren
l_string|&quot;refs/heads/&quot;
comma
id|fn
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|for_each_branch_ref_submodule
r_int
id|for_each_branch_ref_submodule
c_func
(paren
r_const
r_char
op_star
id|submodule
comma
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|for_each_ref_in_submodule
c_func
(paren
id|submodule
comma
l_string|&quot;refs/heads/&quot;
comma
id|fn
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|for_each_remote_ref
r_int
id|for_each_remote_ref
c_func
(paren
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|for_each_ref_in
c_func
(paren
l_string|&quot;refs/remotes/&quot;
comma
id|fn
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|for_each_remote_ref_submodule
r_int
id|for_each_remote_ref_submodule
c_func
(paren
r_const
r_char
op_star
id|submodule
comma
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|for_each_ref_in_submodule
c_func
(paren
id|submodule
comma
l_string|&quot;refs/remotes/&quot;
comma
id|fn
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|for_each_replace_ref
r_int
id|for_each_replace_ref
c_func
(paren
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|do_for_each_ref
c_func
(paren
l_int|NULL
comma
l_string|&quot;refs/replace/&quot;
comma
id|fn
comma
l_int|13
comma
l_int|0
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|head_ref_namespaced
r_int
id|head_ref_namespaced
c_func
(paren
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_struct
id|strbuf
id|buf
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_int
id|flag
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
id|buf
comma
l_string|&quot;%sHEAD&quot;
comma
id|get_git_namespace
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|read_ref_full
c_func
(paren
id|buf.buf
comma
id|sha1
comma
l_int|1
comma
op_amp
id|flag
)paren
)paren
id|ret
op_assign
id|fn
c_func
(paren
id|buf.buf
comma
id|sha1
comma
id|flag
comma
id|cb_data
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|buf
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|for_each_namespaced_ref
r_int
id|for_each_namespaced_ref
c_func
(paren
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_struct
id|strbuf
id|buf
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
id|buf
comma
l_string|&quot;%srefs/&quot;
comma
id|get_git_namespace
c_func
(paren
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|do_for_each_ref
c_func
(paren
l_int|NULL
comma
id|buf.buf
comma
id|fn
comma
l_int|0
comma
l_int|0
comma
id|cb_data
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|buf
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|for_each_glob_ref_in
r_int
id|for_each_glob_ref_in
c_func
(paren
id|each_ref_fn
id|fn
comma
r_const
r_char
op_star
id|pattern
comma
r_const
r_char
op_star
id|prefix
comma
r_void
op_star
id|cb_data
)paren
(brace
r_struct
id|strbuf
id|real_pattern
op_assign
id|STRBUF_INIT
suffix:semicolon
r_struct
id|ref_filter
id|filter
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prefix
op_logical_and
id|prefixcmp
c_func
(paren
id|pattern
comma
l_string|&quot;refs/&quot;
)paren
)paren
id|strbuf_addstr
c_func
(paren
op_amp
id|real_pattern
comma
l_string|&quot;refs/&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|prefix
)paren
id|strbuf_addstr
c_func
(paren
op_amp
id|real_pattern
comma
id|prefix
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|real_pattern
comma
id|pattern
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|has_glob_specials
c_func
(paren
id|pattern
)paren
)paren
(brace
multiline_comment|/* Append implied &squot;/&squot; &squot;*&squot; if not present. */
r_if
c_cond
(paren
id|real_pattern.buf
(braket
id|real_pattern.len
l_int|1
)braket
op_ne
l_char|&squot;/&squot;
)paren
id|strbuf_addch
c_func
(paren
op_amp
id|real_pattern
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
multiline_comment|/* No need to check for &squot;*&squot;, there is none. */
id|strbuf_addch
c_func
(paren
op_amp
id|real_pattern
comma
l_char|&squot;*&squot;
)paren
suffix:semicolon
)brace
id|filter.pattern
op_assign
id|real_pattern.buf
suffix:semicolon
id|filter.fn
op_assign
id|fn
suffix:semicolon
id|filter.cb_data
op_assign
id|cb_data
suffix:semicolon
id|ret
op_assign
id|for_each_ref
c_func
(paren
id|filter_refs
comma
op_amp
id|filter
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|real_pattern
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|for_each_glob_ref
r_int
id|for_each_glob_ref
c_func
(paren
id|each_ref_fn
id|fn
comma
r_const
r_char
op_star
id|pattern
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|for_each_glob_ref_in
c_func
(paren
id|fn
comma
id|pattern
comma
l_int|NULL
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|for_each_rawref
r_int
id|for_each_rawref
c_func
(paren
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|do_for_each_ref
c_func
(paren
l_int|NULL
comma
l_string|&quot;&quot;
comma
id|fn
comma
l_int|0
comma
id|DO_FOR_EACH_INCLUDE_BROKEN
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|prettify_refname
r_const
r_char
op_star
id|prettify_refname
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_return
id|name
op_plus
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|name
comma
l_string|&quot;refs/heads/&quot;
)paren
ques
c_cond
l_int|11
suffix:colon
op_logical_neg
id|prefixcmp
c_func
(paren
id|name
comma
l_string|&quot;refs/tags/&quot;
)paren
ques
c_cond
l_int|10
suffix:colon
op_logical_neg
id|prefixcmp
c_func
(paren
id|name
comma
l_string|&quot;refs/remotes/&quot;
)paren
ques
c_cond
l_int|13
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
DECL|variable|ref_rev_parse_rules
r_const
r_char
op_star
id|ref_rev_parse_rules
(braket
)braket
op_assign
(brace
l_string|&quot;%.*s&quot;
comma
l_string|&quot;refs/%.*s&quot;
comma
l_string|&quot;refs/tags/%.*s&quot;
comma
l_string|&quot;refs/heads/%.*s&quot;
comma
l_string|&quot;refs/remotes/%.*s&quot;
comma
l_string|&quot;refs/remotes/%.*s/HEAD&quot;
comma
l_int|NULL
)brace
suffix:semicolon
DECL|function|refname_match
r_int
id|refname_match
c_func
(paren
r_const
r_char
op_star
id|abbrev_name
comma
r_const
r_char
op_star
id|full_name
comma
r_const
r_char
op_star
op_star
id|rules
)paren
(brace
r_const
r_char
op_star
op_star
id|p
suffix:semicolon
r_const
r_int
id|abbrev_name_len
op_assign
id|strlen
c_func
(paren
id|abbrev_name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|rules
suffix:semicolon
op_star
id|p
suffix:semicolon
id|p
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|full_name
comma
id|mkpath
c_func
(paren
op_star
id|p
comma
id|abbrev_name_len
comma
id|abbrev_name
)paren
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|verify_lock
r_static
r_struct
id|ref_lock
op_star
id|verify_lock
c_func
(paren
r_struct
id|ref_lock
op_star
id|lock
comma
r_const
r_int
r_char
op_star
id|old_sha1
comma
r_int
id|mustexist
)paren
(brace
r_if
c_cond
(paren
id|read_ref_full
c_func
(paren
id|lock-&gt;ref_name
comma
id|lock-&gt;old_sha1
comma
id|mustexist
comma
l_int|NULL
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Can&squot;t verify ref %s&quot;
comma
id|lock-&gt;ref_name
)paren
suffix:semicolon
id|unlock_ref
c_func
(paren
id|lock
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hashcmp
c_func
(paren
id|lock-&gt;old_sha1
comma
id|old_sha1
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Ref %s is at %s but expected %s&quot;
comma
id|lock-&gt;ref_name
comma
id|sha1_to_hex
c_func
(paren
id|lock-&gt;old_sha1
)paren
comma
id|sha1_to_hex
c_func
(paren
id|old_sha1
)paren
)paren
suffix:semicolon
id|unlock_ref
c_func
(paren
id|lock
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|lock
suffix:semicolon
)brace
DECL|function|remove_empty_directories
r_static
r_int
id|remove_empty_directories
c_func
(paren
r_const
r_char
op_star
id|file
)paren
(brace
multiline_comment|/* we want to create a file but there is a directory there;&n;&t; * if that is an empty directory (or a directory that contains&n;&t; * only empty directories), remove them.&n;&t; */
r_struct
id|strbuf
id|path
suffix:semicolon
r_int
id|result
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|path
comma
l_int|20
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|path
comma
id|file
)paren
suffix:semicolon
id|result
op_assign
id|remove_dir_recursively
c_func
(paren
op_amp
id|path
comma
id|REMOVE_DIR_EMPTY_ONLY
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * *string and *len will only be substituted, and *string returned (for&n; * later free()ing) if the string passed in is a magic short-hand form&n; * to name a branch.&n; */
DECL|function|substitute_branch_name
r_static
r_char
op_star
id|substitute_branch_name
c_func
(paren
r_const
r_char
op_star
op_star
id|string
comma
r_int
op_star
id|len
)paren
(brace
r_struct
id|strbuf
id|buf
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|ret
op_assign
id|interpret_branch_name
c_func
(paren
op_star
id|string
comma
op_amp
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
op_star
id|len
)paren
(brace
r_int
id|size
suffix:semicolon
op_star
id|string
op_assign
id|strbuf_detach
c_func
(paren
op_amp
id|buf
comma
op_amp
id|size
)paren
suffix:semicolon
op_star
id|len
op_assign
id|size
suffix:semicolon
r_return
(paren
r_char
op_star
)paren
op_star
id|string
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|dwim_ref
r_int
id|dwim_ref
c_func
(paren
r_const
r_char
op_star
id|str
comma
r_int
id|len
comma
r_int
r_char
op_star
id|sha1
comma
r_char
op_star
op_star
id|ref
)paren
(brace
r_char
op_star
id|last_branch
op_assign
id|substitute_branch_name
c_func
(paren
op_amp
id|str
comma
op_amp
id|len
)paren
suffix:semicolon
r_const
r_char
op_star
op_star
id|p
comma
op_star
id|r
suffix:semicolon
r_int
id|refs_found
op_assign
l_int|0
suffix:semicolon
op_star
id|ref
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|ref_rev_parse_rules
suffix:semicolon
op_star
id|p
suffix:semicolon
id|p
op_increment
)paren
(brace
r_char
id|fullref
(braket
id|PATH_MAX
)braket
suffix:semicolon
r_int
r_char
id|sha1_from_ref
(braket
l_int|20
)braket
suffix:semicolon
r_int
r_char
op_star
id|this_result
suffix:semicolon
r_int
id|flag
suffix:semicolon
id|this_result
op_assign
id|refs_found
ques
c_cond
id|sha1_from_ref
suffix:colon
id|sha1
suffix:semicolon
id|mksnpath
c_func
(paren
id|fullref
comma
r_sizeof
(paren
id|fullref
)paren
comma
op_star
id|p
comma
id|len
comma
id|str
)paren
suffix:semicolon
id|r
op_assign
id|resolve_ref_unsafe
c_func
(paren
id|fullref
comma
id|this_result
comma
l_int|1
comma
op_amp
id|flag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|refs_found
op_increment
)paren
op_star
id|ref
op_assign
id|xstrdup
c_func
(paren
id|r
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|warn_ambiguous_refs
)paren
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|flag
op_amp
id|REF_ISSYMREF
)paren
op_logical_and
id|strcmp
c_func
(paren
id|fullref
comma
l_string|&quot;HEAD&quot;
)paren
)paren
(brace
id|warning
c_func
(paren
l_string|&quot;ignoring dangling symref %s.&quot;
comma
id|fullref
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|flag
op_amp
id|REF_ISBROKEN
)paren
op_logical_and
id|strchr
c_func
(paren
id|fullref
comma
l_char|&squot;/&squot;
)paren
)paren
(brace
id|warning
c_func
(paren
l_string|&quot;ignoring broken ref %s.&quot;
comma
id|fullref
)paren
suffix:semicolon
)brace
)brace
id|free
c_func
(paren
id|last_branch
)paren
suffix:semicolon
r_return
id|refs_found
suffix:semicolon
)brace
DECL|function|dwim_log
r_int
id|dwim_log
c_func
(paren
r_const
r_char
op_star
id|str
comma
r_int
id|len
comma
r_int
r_char
op_star
id|sha1
comma
r_char
op_star
op_star
id|log
)paren
(brace
r_char
op_star
id|last_branch
op_assign
id|substitute_branch_name
c_func
(paren
op_amp
id|str
comma
op_amp
id|len
)paren
suffix:semicolon
r_const
r_char
op_star
op_star
id|p
suffix:semicolon
r_int
id|logs_found
op_assign
l_int|0
suffix:semicolon
op_star
id|log
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|ref_rev_parse_rules
suffix:semicolon
op_star
id|p
suffix:semicolon
id|p
op_increment
)paren
(brace
r_struct
id|stat
id|st
suffix:semicolon
r_int
r_char
id|hash
(braket
l_int|20
)braket
suffix:semicolon
r_char
id|path
(braket
id|PATH_MAX
)braket
suffix:semicolon
r_const
r_char
op_star
id|ref
comma
op_star
id|it
suffix:semicolon
id|mksnpath
c_func
(paren
id|path
comma
r_sizeof
(paren
id|path
)paren
comma
op_star
id|p
comma
id|len
comma
id|str
)paren
suffix:semicolon
id|ref
op_assign
id|resolve_ref_unsafe
c_func
(paren
id|path
comma
id|hash
comma
l_int|1
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ref
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stat
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|path
)paren
comma
op_amp
id|st
)paren
op_logical_and
id|S_ISREG
c_func
(paren
id|st.st_mode
)paren
)paren
id|it
op_assign
id|path
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|ref
comma
id|path
)paren
op_logical_and
op_logical_neg
id|stat
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|ref
)paren
comma
op_amp
id|st
)paren
op_logical_and
id|S_ISREG
c_func
(paren
id|st.st_mode
)paren
)paren
id|it
op_assign
id|ref
suffix:semicolon
r_else
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|logs_found
op_increment
)paren
(brace
op_star
id|log
op_assign
id|xstrdup
c_func
(paren
id|it
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|sha1
comma
id|hash
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|warn_ambiguous_refs
)paren
r_break
suffix:semicolon
)brace
id|free
c_func
(paren
id|last_branch
)paren
suffix:semicolon
r_return
id|logs_found
suffix:semicolon
)brace
DECL|function|lock_ref_sha1_basic
r_static
r_struct
id|ref_lock
op_star
id|lock_ref_sha1_basic
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_const
r_int
r_char
op_star
id|old_sha1
comma
r_int
id|flags
comma
r_int
op_star
id|type_p
)paren
(brace
r_char
op_star
id|ref_file
suffix:semicolon
r_const
r_char
op_star
id|orig_refname
op_assign
id|refname
suffix:semicolon
r_struct
id|ref_lock
op_star
id|lock
suffix:semicolon
r_int
id|last_errno
op_assign
l_int|0
suffix:semicolon
r_int
id|type
comma
id|lflags
suffix:semicolon
r_int
id|mustexist
op_assign
(paren
id|old_sha1
op_logical_and
op_logical_neg
id|is_null_sha1
c_func
(paren
id|old_sha1
)paren
)paren
suffix:semicolon
r_int
id|missing
op_assign
l_int|0
suffix:semicolon
id|lock
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|ref_lock
)paren
)paren
suffix:semicolon
id|lock-&gt;lock_fd
op_assign
l_int|1
suffix:semicolon
id|refname
op_assign
id|resolve_ref_unsafe
c_func
(paren
id|refname
comma
id|lock-&gt;old_sha1
comma
id|mustexist
comma
op_amp
id|type
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|refname
op_logical_and
id|errno
op_eq
id|EISDIR
)paren
(brace
multiline_comment|/* we are trying to lock foo but we used to&n;&t;&t; * have foo/bar which now does not exist;&n;&t;&t; * it is normal for the empty directory &squot;foo&squot;&n;&t;&t; * to remain.&n;&t;&t; */
id|ref_file
op_assign
id|git_path
c_func
(paren
l_string|&quot;%s&quot;
comma
id|orig_refname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|remove_empty_directories
c_func
(paren
id|ref_file
)paren
)paren
(brace
id|last_errno
op_assign
id|errno
suffix:semicolon
id|error
c_func
(paren
l_string|&quot;there are still refs under &squot;%s&squot;&quot;
comma
id|orig_refname
)paren
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
id|refname
op_assign
id|resolve_ref_unsafe
c_func
(paren
id|orig_refname
comma
id|lock-&gt;old_sha1
comma
id|mustexist
comma
op_amp
id|type
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|type_p
)paren
op_star
id|type_p
op_assign
id|type
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|refname
)paren
(brace
id|last_errno
op_assign
id|errno
suffix:semicolon
id|error
c_func
(paren
l_string|&quot;unable to resolve reference %s: %s&quot;
comma
id|orig_refname
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
id|missing
op_assign
id|is_null_sha1
c_func
(paren
id|lock-&gt;old_sha1
)paren
suffix:semicolon
multiline_comment|/* When the ref did not exist and we are creating it,&n;&t; * make sure there is no existing ref that is packed&n;&t; * whose name begins with our refname, nor a ref whose&n;&t; * name is a proper prefix of our refname.&n;&t; */
r_if
c_cond
(paren
id|missing
op_logical_and
op_logical_neg
id|is_refname_available
c_func
(paren
id|refname
comma
l_int|NULL
comma
id|get_packed_refs
c_func
(paren
id|get_ref_cache
c_func
(paren
l_int|NULL
)paren
)paren
)paren
)paren
(brace
id|last_errno
op_assign
id|ENOTDIR
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
id|lock-&gt;lk
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|lock_file
)paren
)paren
suffix:semicolon
id|lflags
op_assign
id|LOCK_DIE_ON_ERROR
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|REF_NODEREF
)paren
(brace
id|refname
op_assign
id|orig_refname
suffix:semicolon
id|lflags
op_or_assign
id|LOCK_NODEREF
suffix:semicolon
)brace
id|lock-&gt;ref_name
op_assign
id|xstrdup
c_func
(paren
id|refname
)paren
suffix:semicolon
id|lock-&gt;orig_ref_name
op_assign
id|xstrdup
c_func
(paren
id|orig_refname
)paren
suffix:semicolon
id|ref_file
op_assign
id|git_path
c_func
(paren
l_string|&quot;%s&quot;
comma
id|refname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|missing
)paren
id|lock-&gt;force_write
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|REF_NODEREF
)paren
op_logical_and
(paren
id|type
op_amp
id|REF_ISSYMREF
)paren
)paren
id|lock-&gt;force_write
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|safe_create_leading_directories
c_func
(paren
id|ref_file
)paren
)paren
(brace
id|last_errno
op_assign
id|errno
suffix:semicolon
id|error
c_func
(paren
l_string|&quot;unable to create directory for %s&quot;
comma
id|ref_file
)paren
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
id|lock-&gt;lock_fd
op_assign
id|hold_lock_file_for_update
c_func
(paren
id|lock-&gt;lk
comma
id|ref_file
comma
id|lflags
)paren
suffix:semicolon
r_return
id|old_sha1
ques
c_cond
id|verify_lock
c_func
(paren
id|lock
comma
id|old_sha1
comma
id|mustexist
)paren
suffix:colon
id|lock
suffix:semicolon
id|error_return
suffix:colon
id|unlock_ref
c_func
(paren
id|lock
)paren
suffix:semicolon
id|errno
op_assign
id|last_errno
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|lock_ref_sha1
r_struct
id|ref_lock
op_star
id|lock_ref_sha1
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_const
r_int
r_char
op_star
id|old_sha1
)paren
(brace
r_char
id|refpath
(braket
id|PATH_MAX
)braket
suffix:semicolon
r_if
c_cond
(paren
id|check_refname_format
c_func
(paren
id|refname
comma
l_int|0
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|strcpy
c_func
(paren
id|refpath
comma
id|mkpath
c_func
(paren
l_string|&quot;refs/%s&quot;
comma
id|refname
)paren
)paren
suffix:semicolon
r_return
id|lock_ref_sha1_basic
c_func
(paren
id|refpath
comma
id|old_sha1
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|lock_any_ref_for_update
r_struct
id|ref_lock
op_star
id|lock_any_ref_for_update
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_const
r_int
r_char
op_star
id|old_sha1
comma
r_int
id|flags
)paren
(brace
r_if
c_cond
(paren
id|check_refname_format
c_func
(paren
id|refname
comma
id|REFNAME_ALLOW_ONELEVEL
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|lock_ref_sha1_basic
c_func
(paren
id|refname
comma
id|old_sha1
comma
id|flags
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|struct|repack_without_ref_sb
r_struct
id|repack_without_ref_sb
(brace
DECL|member|refname
r_const
r_char
op_star
id|refname
suffix:semicolon
DECL|member|fd
r_int
id|fd
suffix:semicolon
)brace
suffix:semicolon
DECL|function|repack_without_ref_fn
r_static
r_int
id|repack_without_ref_fn
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
id|flags
comma
r_void
op_star
id|cb_data
)paren
(brace
r_struct
id|repack_without_ref_sb
op_star
id|data
op_assign
id|cb_data
suffix:semicolon
r_char
id|line
(braket
id|PATH_MAX
op_plus
l_int|100
)braket
suffix:semicolon
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|data-&gt;refname
comma
id|refname
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|len
op_assign
id|snprintf
c_func
(paren
id|line
comma
r_sizeof
(paren
id|line
)paren
comma
l_string|&quot;%s %s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
comma
id|refname
)paren
suffix:semicolon
multiline_comment|/* this should not happen but just being defensive */
r_if
c_cond
(paren
id|len
OG
r_sizeof
(paren
id|line
)paren
)paren
id|die
c_func
(paren
l_string|&quot;too long a refname &squot;%s&squot;&quot;
comma
id|refname
)paren
suffix:semicolon
id|write_or_die
c_func
(paren
id|data-&gt;fd
comma
id|line
comma
id|len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|packlock
r_static
r_struct
id|lock_file
id|packlock
suffix:semicolon
DECL|function|repack_without_ref
r_static
r_int
id|repack_without_ref
c_func
(paren
r_const
r_char
op_star
id|refname
)paren
(brace
r_struct
id|repack_without_ref_sb
id|data
suffix:semicolon
r_struct
id|ref_array
op_star
id|packed
op_assign
id|get_packed_refs
c_func
(paren
id|get_ref_cache
c_func
(paren
l_int|NULL
)paren
)paren
suffix:semicolon
id|sort_ref_array
c_func
(paren
id|packed
)paren
suffix:semicolon
r_if
c_cond
(paren
id|search_ref_array
c_func
(paren
id|packed
comma
id|refname
)paren
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|data.refname
op_assign
id|refname
suffix:semicolon
id|data.fd
op_assign
id|hold_lock_file_for_update
c_func
(paren
op_amp
id|packlock
comma
id|git_path
c_func
(paren
l_string|&quot;packed-refs&quot;
)paren
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data.fd
OL
l_int|0
)paren
(brace
id|unable_to_lock_error
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;packed-refs&quot;
)paren
comma
id|errno
)paren
suffix:semicolon
r_return
id|error
c_func
(paren
l_string|&quot;cannot delete &squot;%s&squot; from packed refs&quot;
comma
id|refname
)paren
suffix:semicolon
)brace
id|do_for_each_ref_in_array
c_func
(paren
id|packed
comma
l_int|0
comma
l_string|&quot;&quot;
comma
id|repack_without_ref_fn
comma
l_int|0
comma
l_int|0
comma
op_amp
id|data
)paren
suffix:semicolon
r_return
id|commit_lock_file
c_func
(paren
op_amp
id|packlock
)paren
suffix:semicolon
)brace
DECL|function|delete_ref
r_int
id|delete_ref
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
id|delopt
)paren
(brace
r_struct
id|ref_lock
op_star
id|lock
suffix:semicolon
r_int
id|err
comma
id|i
op_assign
l_int|0
comma
id|ret
op_assign
l_int|0
comma
id|flag
op_assign
l_int|0
suffix:semicolon
id|lock
op_assign
id|lock_ref_sha1_basic
c_func
(paren
id|refname
comma
id|sha1
comma
l_int|0
comma
op_amp
id|flag
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lock
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flag
op_amp
id|REF_ISPACKED
)paren
op_logical_or
id|flag
op_amp
id|REF_ISSYMREF
)paren
(brace
multiline_comment|/* loose */
r_const
r_char
op_star
id|path
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|delopt
op_amp
id|REF_NODEREF
)paren
)paren
(brace
id|i
op_assign
id|strlen
c_func
(paren
id|lock-&gt;lk-&gt;filename
)paren
l_int|5
suffix:semicolon
multiline_comment|/* .lock */
id|lock-&gt;lk-&gt;filename
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|path
op_assign
id|lock-&gt;lk-&gt;filename
suffix:semicolon
)brace
r_else
(brace
id|path
op_assign
id|git_path
c_func
(paren
l_string|&quot;%s&quot;
comma
id|refname
)paren
suffix:semicolon
)brace
id|err
op_assign
id|unlink_or_warn
c_func
(paren
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_logical_and
id|errno
op_ne
id|ENOENT
)paren
id|ret
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|delopt
op_amp
id|REF_NODEREF
)paren
)paren
id|lock-&gt;lk-&gt;filename
(braket
id|i
)braket
op_assign
l_char|&squot;.&squot;
suffix:semicolon
)brace
multiline_comment|/* removing the loose one could have resurrected an earlier&n;&t; * packed one.  Also, if it was not loose we need to repack&n;&t; * without it.&n;&t; */
id|ret
op_or_assign
id|repack_without_ref
c_func
(paren
id|refname
)paren
suffix:semicolon
id|unlink_or_warn
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|lock-&gt;ref_name
)paren
)paren
suffix:semicolon
id|invalidate_ref_cache
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
id|unlock_ref
c_func
(paren
id|lock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * People using contrib&squot;s git-new-workdir have .git/logs/refs -&gt;&n; * /some/other/path/.git/logs/refs, and that may live on another device.&n; *&n; * IOW, to avoid cross device rename errors, the temporary renamed log must&n; * live into logs/refs.&n; */
DECL|macro|TMP_RENAMED_LOG
mdefine_line|#define TMP_RENAMED_LOG  &quot;logs/refs/.tmp-renamed-log&quot;
DECL|function|rename_ref
r_int
id|rename_ref
c_func
(paren
r_const
r_char
op_star
id|oldrefname
comma
r_const
r_char
op_star
id|newrefname
comma
r_const
r_char
op_star
id|logmsg
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
comma
id|orig_sha1
(braket
l_int|20
)braket
suffix:semicolon
r_int
id|flag
op_assign
l_int|0
comma
id|logmoved
op_assign
l_int|0
suffix:semicolon
r_struct
id|ref_lock
op_star
id|lock
suffix:semicolon
r_struct
id|stat
id|loginfo
suffix:semicolon
r_int
id|log
op_assign
op_logical_neg
id|lstat
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|oldrefname
)paren
comma
op_amp
id|loginfo
)paren
suffix:semicolon
r_const
r_char
op_star
id|symref
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|ref_cache
op_star
id|refs
op_assign
id|get_ref_cache
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|log
op_logical_and
id|S_ISLNK
c_func
(paren
id|loginfo.st_mode
)paren
)paren
r_return
id|error
c_func
(paren
l_string|&quot;reflog for %s is a symlink&quot;
comma
id|oldrefname
)paren
suffix:semicolon
id|symref
op_assign
id|resolve_ref_unsafe
c_func
(paren
id|oldrefname
comma
id|orig_sha1
comma
l_int|1
comma
op_amp
id|flag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flag
op_amp
id|REF_ISSYMREF
)paren
r_return
id|error
c_func
(paren
l_string|&quot;refname %s is a symbolic ref, renaming it is not supported&quot;
comma
id|oldrefname
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|symref
)paren
r_return
id|error
c_func
(paren
l_string|&quot;refname %s not found&quot;
comma
id|oldrefname
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_refname_available
c_func
(paren
id|newrefname
comma
id|oldrefname
comma
id|get_packed_refs
c_func
(paren
id|refs
)paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_refname_available
c_func
(paren
id|newrefname
comma
id|oldrefname
comma
id|get_loose_refs
c_func
(paren
id|refs
)paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|log
op_logical_and
id|rename
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|oldrefname
)paren
comma
id|git_path
c_func
(paren
id|TMP_RENAMED_LOG
)paren
)paren
)paren
r_return
id|error
c_func
(paren
l_string|&quot;unable to move logfile logs/%s to &quot;
id|TMP_RENAMED_LOG
l_string|&quot;: %s&quot;
comma
id|oldrefname
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|delete_ref
c_func
(paren
id|oldrefname
comma
id|orig_sha1
comma
id|REF_NODEREF
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;unable to delete old %s&quot;
comma
id|oldrefname
)paren
suffix:semicolon
r_goto
id|rollback
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|read_ref_full
c_func
(paren
id|newrefname
comma
id|sha1
comma
l_int|1
comma
op_amp
id|flag
)paren
op_logical_and
id|delete_ref
c_func
(paren
id|newrefname
comma
id|sha1
comma
id|REF_NODEREF
)paren
)paren
(brace
r_if
c_cond
(paren
id|errno
op_eq
id|EISDIR
)paren
(brace
r_if
c_cond
(paren
id|remove_empty_directories
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;%s&quot;
comma
id|newrefname
)paren
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Directory not empty: %s&quot;
comma
id|newrefname
)paren
suffix:semicolon
r_goto
id|rollback
suffix:semicolon
)brace
)brace
r_else
(brace
id|error
c_func
(paren
l_string|&quot;unable to delete existing %s&quot;
comma
id|newrefname
)paren
suffix:semicolon
r_goto
id|rollback
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|log
op_logical_and
id|safe_create_leading_directories
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|newrefname
)paren
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;unable to create directory for %s&quot;
comma
id|newrefname
)paren
suffix:semicolon
r_goto
id|rollback
suffix:semicolon
)brace
id|retry
suffix:colon
r_if
c_cond
(paren
id|log
op_logical_and
id|rename
c_func
(paren
id|git_path
c_func
(paren
id|TMP_RENAMED_LOG
)paren
comma
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|newrefname
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|errno
op_eq
id|EISDIR
op_logical_or
id|errno
op_eq
id|ENOTDIR
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * rename(a, b) when b is an existing&n;&t;&t;&t; * directory ought to result in ISDIR, but&n;&t;&t;&t; * Solaris 5.8 gives ENOTDIR.  Sheesh.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|remove_empty_directories
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|newrefname
)paren
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Directory not empty: logs/%s&quot;
comma
id|newrefname
)paren
suffix:semicolon
r_goto
id|rollback
suffix:semicolon
)brace
r_goto
id|retry
suffix:semicolon
)brace
r_else
(brace
id|error
c_func
(paren
l_string|&quot;unable to move logfile &quot;
id|TMP_RENAMED_LOG
l_string|&quot; to logs/%s: %s&quot;
comma
id|newrefname
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_goto
id|rollback
suffix:semicolon
)brace
)brace
id|logmoved
op_assign
id|log
suffix:semicolon
id|lock
op_assign
id|lock_ref_sha1_basic
c_func
(paren
id|newrefname
comma
l_int|NULL
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lock
)paren
(brace
id|error
c_func
(paren
l_string|&quot;unable to lock %s for update&quot;
comma
id|newrefname
)paren
suffix:semicolon
r_goto
id|rollback
suffix:semicolon
)brace
id|lock-&gt;force_write
op_assign
l_int|1
suffix:semicolon
id|hashcpy
c_func
(paren
id|lock-&gt;old_sha1
comma
id|orig_sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write_ref_sha1
c_func
(paren
id|lock
comma
id|orig_sha1
comma
id|logmsg
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;unable to write current sha1 into %s&quot;
comma
id|newrefname
)paren
suffix:semicolon
r_goto
id|rollback
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|rollback
suffix:colon
id|lock
op_assign
id|lock_ref_sha1_basic
c_func
(paren
id|oldrefname
comma
l_int|NULL
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lock
)paren
(brace
id|error
c_func
(paren
l_string|&quot;unable to lock %s for rollback&quot;
comma
id|oldrefname
)paren
suffix:semicolon
r_goto
id|rollbacklog
suffix:semicolon
)brace
id|lock-&gt;force_write
op_assign
l_int|1
suffix:semicolon
id|flag
op_assign
id|log_all_ref_updates
suffix:semicolon
id|log_all_ref_updates
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|write_ref_sha1
c_func
(paren
id|lock
comma
id|orig_sha1
comma
l_int|NULL
)paren
)paren
id|error
c_func
(paren
l_string|&quot;unable to write current sha1 into %s&quot;
comma
id|oldrefname
)paren
suffix:semicolon
id|log_all_ref_updates
op_assign
id|flag
suffix:semicolon
id|rollbacklog
suffix:colon
r_if
c_cond
(paren
id|logmoved
op_logical_and
id|rename
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|newrefname
)paren
comma
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|oldrefname
)paren
)paren
)paren
id|error
c_func
(paren
l_string|&quot;unable to restore logfile %s from %s: %s&quot;
comma
id|oldrefname
comma
id|newrefname
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|logmoved
op_logical_and
id|log
op_logical_and
id|rename
c_func
(paren
id|git_path
c_func
(paren
id|TMP_RENAMED_LOG
)paren
comma
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|oldrefname
)paren
)paren
)paren
id|error
c_func
(paren
l_string|&quot;unable to restore logfile %s from &quot;
id|TMP_RENAMED_LOG
l_string|&quot;: %s&quot;
comma
id|oldrefname
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|close_ref
r_int
id|close_ref
c_func
(paren
r_struct
id|ref_lock
op_star
id|lock
)paren
(brace
r_if
c_cond
(paren
id|close_lock_file
c_func
(paren
id|lock-&gt;lk
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|lock-&gt;lock_fd
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|commit_ref
r_int
id|commit_ref
c_func
(paren
r_struct
id|ref_lock
op_star
id|lock
)paren
(brace
r_if
c_cond
(paren
id|commit_lock_file
c_func
(paren
id|lock-&gt;lk
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|lock-&gt;lock_fd
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|unlock_ref
r_void
id|unlock_ref
c_func
(paren
r_struct
id|ref_lock
op_star
id|lock
)paren
(brace
multiline_comment|/* Do not free lock-&gt;lk -- atexit() still looks at them */
r_if
c_cond
(paren
id|lock-&gt;lk
)paren
id|rollback_lock_file
c_func
(paren
id|lock-&gt;lk
)paren
suffix:semicolon
id|free
c_func
(paren
id|lock-&gt;ref_name
)paren
suffix:semicolon
id|free
c_func
(paren
id|lock-&gt;orig_ref_name
)paren
suffix:semicolon
id|free
c_func
(paren
id|lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * copy the reflog message msg to buf, which has been allocated sufficiently&n; * large, while cleaning up the whitespaces.  Especially, convert LF to space,&n; * because reflog file is one line per entry.&n; */
DECL|function|copy_msg
r_static
r_int
id|copy_msg
c_func
(paren
r_char
op_star
id|buf
comma
r_const
r_char
op_star
id|msg
)paren
(brace
r_char
op_star
id|cp
op_assign
id|buf
suffix:semicolon
r_char
id|c
suffix:semicolon
r_int
id|wasspace
op_assign
l_int|1
suffix:semicolon
op_star
id|cp
op_increment
op_assign
l_char|&squot;&bslash;t&squot;
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
op_star
id|msg
op_increment
)paren
)paren
(brace
r_if
c_cond
(paren
id|wasspace
op_logical_and
id|isspace
c_func
(paren
id|c
)paren
)paren
r_continue
suffix:semicolon
id|wasspace
op_assign
id|isspace
c_func
(paren
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wasspace
)paren
id|c
op_assign
l_char|&squot; &squot;
suffix:semicolon
op_star
id|cp
op_increment
op_assign
id|c
suffix:semicolon
)brace
r_while
c_loop
(paren
id|buf
OL
id|cp
op_logical_and
id|isspace
c_func
(paren
id|cp
(braket
l_int|1
)braket
)paren
)paren
id|cp
op_decrement
suffix:semicolon
op_star
id|cp
op_increment
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
r_return
id|cp
id|buf
suffix:semicolon
)brace
DECL|function|log_ref_setup
r_int
id|log_ref_setup
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_char
op_star
id|logfile
comma
r_int
id|bufsize
)paren
(brace
r_int
id|logfd
comma
id|oflags
op_assign
id|O_APPEND
op_or
id|O_WRONLY
suffix:semicolon
id|git_snpath
c_func
(paren
id|logfile
comma
id|bufsize
comma
l_string|&quot;logs/%s&quot;
comma
id|refname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|log_all_ref_updates
op_logical_and
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|refname
comma
l_string|&quot;refs/heads/&quot;
)paren
op_logical_or
op_logical_neg
id|prefixcmp
c_func
(paren
id|refname
comma
l_string|&quot;refs/remotes/&quot;
)paren
op_logical_or
op_logical_neg
id|prefixcmp
c_func
(paren
id|refname
comma
l_string|&quot;refs/notes/&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|refname
comma
l_string|&quot;HEAD&quot;
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|safe_create_leading_directories
c_func
(paren
id|logfile
)paren
OL
l_int|0
)paren
r_return
id|error
c_func
(paren
l_string|&quot;unable to create directory for %s&quot;
comma
id|logfile
)paren
suffix:semicolon
id|oflags
op_or_assign
id|O_CREAT
suffix:semicolon
)brace
id|logfd
op_assign
id|open
c_func
(paren
id|logfile
comma
id|oflags
comma
l_int|0666
)paren
suffix:semicolon
r_if
c_cond
(paren
id|logfd
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|oflags
op_amp
id|O_CREAT
)paren
op_logical_and
id|errno
op_eq
id|ENOENT
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|oflags
op_amp
id|O_CREAT
)paren
op_logical_and
id|errno
op_eq
id|EISDIR
)paren
(brace
r_if
c_cond
(paren
id|remove_empty_directories
c_func
(paren
id|logfile
)paren
)paren
(brace
r_return
id|error
c_func
(paren
l_string|&quot;There are still logs under &squot;%s&squot;&quot;
comma
id|logfile
)paren
suffix:semicolon
)brace
id|logfd
op_assign
id|open
c_func
(paren
id|logfile
comma
id|oflags
comma
l_int|0666
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|logfd
OL
l_int|0
)paren
r_return
id|error
c_func
(paren
l_string|&quot;Unable to append to %s: %s&quot;
comma
id|logfile
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
)brace
id|adjust_shared_perm
c_func
(paren
id|logfile
)paren
suffix:semicolon
id|close
c_func
(paren
id|logfd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|log_ref_write
r_static
r_int
id|log_ref_write
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_const
r_int
r_char
op_star
id|old_sha1
comma
r_const
r_int
r_char
op_star
id|new_sha1
comma
r_const
r_char
op_star
id|msg
)paren
(brace
r_int
id|logfd
comma
id|result
comma
id|written
comma
id|oflags
op_assign
id|O_APPEND
op_or
id|O_WRONLY
suffix:semicolon
r_int
id|maxlen
comma
id|len
suffix:semicolon
r_int
id|msglen
suffix:semicolon
r_char
id|log_file
(braket
id|PATH_MAX
)braket
suffix:semicolon
r_char
op_star
id|logrec
suffix:semicolon
r_const
r_char
op_star
id|committer
suffix:semicolon
r_if
c_cond
(paren
id|log_all_ref_updates
OL
l_int|0
)paren
id|log_all_ref_updates
op_assign
op_logical_neg
id|is_bare_repository
c_func
(paren
)paren
suffix:semicolon
id|result
op_assign
id|log_ref_setup
c_func
(paren
id|refname
comma
id|log_file
comma
r_sizeof
(paren
id|log_file
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
r_return
id|result
suffix:semicolon
id|logfd
op_assign
id|open
c_func
(paren
id|log_file
comma
id|oflags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|logfd
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|msglen
op_assign
id|msg
ques
c_cond
id|strlen
c_func
(paren
id|msg
)paren
suffix:colon
l_int|0
suffix:semicolon
id|committer
op_assign
id|git_committer_info
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|maxlen
op_assign
id|strlen
c_func
(paren
id|committer
)paren
op_plus
id|msglen
op_plus
l_int|100
suffix:semicolon
id|logrec
op_assign
id|xmalloc
c_func
(paren
id|maxlen
)paren
suffix:semicolon
id|len
op_assign
id|sprintf
c_func
(paren
id|logrec
comma
l_string|&quot;%s %s %s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|old_sha1
)paren
comma
id|sha1_to_hex
c_func
(paren
id|new_sha1
)paren
comma
id|committer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msglen
)paren
id|len
op_add_assign
id|copy_msg
c_func
(paren
id|logrec
op_plus
id|len
l_int|1
comma
id|msg
)paren
l_int|1
suffix:semicolon
id|written
op_assign
id|len
op_le
id|maxlen
ques
c_cond
id|write_in_full
c_func
(paren
id|logfd
comma
id|logrec
comma
id|len
)paren
suffix:colon
l_int|1
suffix:semicolon
id|free
c_func
(paren
id|logrec
)paren
suffix:semicolon
r_if
c_cond
(paren
id|close
c_func
(paren
id|logfd
)paren
op_ne
l_int|0
op_logical_or
id|written
op_ne
id|len
)paren
r_return
id|error
c_func
(paren
l_string|&quot;Unable to append to %s&quot;
comma
id|log_file
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|is_branch
r_static
r_int
id|is_branch
c_func
(paren
r_const
r_char
op_star
id|refname
)paren
(brace
r_return
op_logical_neg
id|strcmp
c_func
(paren
id|refname
comma
l_string|&quot;HEAD&quot;
)paren
op_logical_or
op_logical_neg
id|prefixcmp
c_func
(paren
id|refname
comma
l_string|&quot;refs/heads/&quot;
)paren
suffix:semicolon
)brace
DECL|function|write_ref_sha1
r_int
id|write_ref_sha1
c_func
(paren
r_struct
id|ref_lock
op_star
id|lock
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_const
r_char
op_star
id|logmsg
)paren
(brace
r_static
r_char
id|term
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
r_struct
id|object
op_star
id|o
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lock
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lock-&gt;force_write
op_logical_and
op_logical_neg
id|hashcmp
c_func
(paren
id|lock-&gt;old_sha1
comma
id|sha1
)paren
)paren
(brace
id|unlock_ref
c_func
(paren
id|lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|o
op_assign
id|parse_object
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|o
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Trying to write ref %s with nonexistent object %s&quot;
comma
id|lock-&gt;ref_name
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
id|unlock_ref
c_func
(paren
id|lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|o-&gt;type
op_ne
id|OBJ_COMMIT
op_logical_and
id|is_branch
c_func
(paren
id|lock-&gt;ref_name
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Trying to write non-commit object %s to branch %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
comma
id|lock-&gt;ref_name
)paren
suffix:semicolon
id|unlock_ref
c_func
(paren
id|lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|write_in_full
c_func
(paren
id|lock-&gt;lock_fd
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
comma
l_int|40
)paren
op_ne
l_int|40
op_logical_or
id|write_in_full
c_func
(paren
id|lock-&gt;lock_fd
comma
op_amp
id|term
comma
l_int|1
)paren
op_ne
l_int|1
op_logical_or
id|close_ref
c_func
(paren
id|lock
)paren
OL
l_int|0
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Couldn&squot;t write %s&quot;
comma
id|lock-&gt;lk-&gt;filename
)paren
suffix:semicolon
id|unlock_ref
c_func
(paren
id|lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|clear_loose_ref_cache
c_func
(paren
id|get_ref_cache
c_func
(paren
l_int|NULL
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|log_ref_write
c_func
(paren
id|lock-&gt;ref_name
comma
id|lock-&gt;old_sha1
comma
id|sha1
comma
id|logmsg
)paren
OL
l_int|0
op_logical_or
(paren
id|strcmp
c_func
(paren
id|lock-&gt;ref_name
comma
id|lock-&gt;orig_ref_name
)paren
op_logical_and
id|log_ref_write
c_func
(paren
id|lock-&gt;orig_ref_name
comma
id|lock-&gt;old_sha1
comma
id|sha1
comma
id|logmsg
)paren
OL
l_int|0
)paren
)paren
(brace
id|unlock_ref
c_func
(paren
id|lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|lock-&gt;orig_ref_name
comma
l_string|&quot;HEAD&quot;
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Special hack: If a branch is updated directly and HEAD&n;&t;&t; * points to it (may happen on the remote side of a push&n;&t;&t; * for example) then logically the HEAD reflog should be&n;&t;&t; * updated too.&n;&t;&t; * A generic solution implies reverse symref information,&n;&t;&t; * but finding all symrefs pointing to the given branch&n;&t;&t; * would be rather costly for this rare event (the direct&n;&t;&t; * update of a branch) to be worth it.  So let&squot;s cheat and&n;&t;&t; * check with HEAD only which should cover 99% of all usage&n;&t;&t; * scenarios (even 100% of the default ones).&n;&t;&t; */
r_int
r_char
id|head_sha1
(braket
l_int|20
)braket
suffix:semicolon
r_int
id|head_flag
suffix:semicolon
r_const
r_char
op_star
id|head_ref
suffix:semicolon
id|head_ref
op_assign
id|resolve_ref_unsafe
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|head_sha1
comma
l_int|1
comma
op_amp
id|head_flag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|head_ref
op_logical_and
(paren
id|head_flag
op_amp
id|REF_ISSYMREF
)paren
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|head_ref
comma
id|lock-&gt;ref_name
)paren
)paren
id|log_ref_write
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|lock-&gt;old_sha1
comma
id|sha1
comma
id|logmsg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|commit_ref
c_func
(paren
id|lock
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Couldn&squot;t set %s&quot;
comma
id|lock-&gt;ref_name
)paren
suffix:semicolon
id|unlock_ref
c_func
(paren
id|lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|unlock_ref
c_func
(paren
id|lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|create_symref
r_int
id|create_symref
c_func
(paren
r_const
r_char
op_star
id|ref_target
comma
r_const
r_char
op_star
id|refs_heads_master
comma
r_const
r_char
op_star
id|logmsg
)paren
(brace
r_const
r_char
op_star
id|lockpath
suffix:semicolon
r_char
id|ref
(braket
l_int|1000
)braket
suffix:semicolon
r_int
id|fd
comma
id|len
comma
id|written
suffix:semicolon
r_char
op_star
id|git_HEAD
op_assign
id|git_pathdup
c_func
(paren
l_string|&quot;%s&quot;
comma
id|ref_target
)paren
suffix:semicolon
r_int
r_char
id|old_sha1
(braket
l_int|20
)braket
comma
id|new_sha1
(braket
l_int|20
)braket
suffix:semicolon
r_if
c_cond
(paren
id|logmsg
op_logical_and
id|read_ref
c_func
(paren
id|ref_target
comma
id|old_sha1
)paren
)paren
id|hashclr
c_func
(paren
id|old_sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|safe_create_leading_directories
c_func
(paren
id|git_HEAD
)paren
OL
l_int|0
)paren
r_return
id|error
c_func
(paren
l_string|&quot;unable to create directory for %s&quot;
comma
id|git_HEAD
)paren
suffix:semicolon
macro_line|#ifndef NO_SYMLINK_HEAD
r_if
c_cond
(paren
id|prefer_symlink_refs
)paren
(brace
id|unlink
c_func
(paren
id|git_HEAD
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|symlink
c_func
(paren
id|refs_heads_master
comma
id|git_HEAD
)paren
)paren
r_goto
id|done
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;no symlink - falling back to symbolic ref&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|len
op_assign
id|snprintf
c_func
(paren
id|ref
comma
r_sizeof
(paren
id|ref
)paren
comma
l_string|&quot;ref: %s&bslash;n&quot;
comma
id|refs_heads_master
)paren
suffix:semicolon
r_if
c_cond
(paren
r_sizeof
(paren
id|ref
)paren
op_le
id|len
)paren
(brace
id|error
c_func
(paren
l_string|&quot;refname too long: %s&quot;
comma
id|refs_heads_master
)paren
suffix:semicolon
r_goto
id|error_free_return
suffix:semicolon
)brace
id|lockpath
op_assign
id|mkpath
c_func
(paren
l_string|&quot;%s.lock&quot;
comma
id|git_HEAD
)paren
suffix:semicolon
id|fd
op_assign
id|open
c_func
(paren
id|lockpath
comma
id|O_CREAT
op_or
id|O_EXCL
op_or
id|O_WRONLY
comma
l_int|0666
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Unable to open %s for writing&quot;
comma
id|lockpath
)paren
suffix:semicolon
r_goto
id|error_free_return
suffix:semicolon
)brace
id|written
op_assign
id|write_in_full
c_func
(paren
id|fd
comma
id|ref
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|close
c_func
(paren
id|fd
)paren
op_ne
l_int|0
op_logical_or
id|written
op_ne
id|len
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Unable to write to %s&quot;
comma
id|lockpath
)paren
suffix:semicolon
r_goto
id|error_unlink_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rename
c_func
(paren
id|lockpath
comma
id|git_HEAD
)paren
OL
l_int|0
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Unable to create %s&quot;
comma
id|git_HEAD
)paren
suffix:semicolon
r_goto
id|error_unlink_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|adjust_shared_perm
c_func
(paren
id|git_HEAD
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Unable to fix permissions on %s&quot;
comma
id|lockpath
)paren
suffix:semicolon
id|error_unlink_return
suffix:colon
id|unlink_or_warn
c_func
(paren
id|lockpath
)paren
suffix:semicolon
id|error_free_return
suffix:colon
id|free
c_func
(paren
id|git_HEAD
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#ifndef NO_SYMLINK_HEAD
id|done
suffix:colon
macro_line|#endif
r_if
c_cond
(paren
id|logmsg
op_logical_and
op_logical_neg
id|read_ref
c_func
(paren
id|refs_heads_master
comma
id|new_sha1
)paren
)paren
id|log_ref_write
c_func
(paren
id|ref_target
comma
id|old_sha1
comma
id|new_sha1
comma
id|logmsg
)paren
suffix:semicolon
id|free
c_func
(paren
id|git_HEAD
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ref_msg
r_static
r_char
op_star
id|ref_msg
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_const
r_char
op_star
id|endp
)paren
(brace
r_const
r_char
op_star
id|ep
suffix:semicolon
id|line
op_add_assign
l_int|82
suffix:semicolon
id|ep
op_assign
id|memchr
c_func
(paren
id|line
comma
l_char|&squot;&bslash;n&squot;
comma
id|endp
id|line
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ep
)paren
id|ep
op_assign
id|endp
suffix:semicolon
r_return
id|xmemdupz
c_func
(paren
id|line
comma
id|ep
id|line
)paren
suffix:semicolon
)brace
DECL|function|read_ref_at
r_int
id|read_ref_at
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_int
r_int
id|at_time
comma
r_int
id|cnt
comma
r_int
r_char
op_star
id|sha1
comma
r_char
op_star
op_star
id|msg
comma
r_int
r_int
op_star
id|cutoff_time
comma
r_int
op_star
id|cutoff_tz
comma
r_int
op_star
id|cutoff_cnt
)paren
(brace
r_const
r_char
op_star
id|logfile
comma
op_star
id|logdata
comma
op_star
id|logend
comma
op_star
id|rec
comma
op_star
id|lastgt
comma
op_star
id|lastrec
suffix:semicolon
r_char
op_star
id|tz_c
suffix:semicolon
r_int
id|logfd
comma
id|tz
comma
id|reccnt
op_assign
l_int|0
suffix:semicolon
r_struct
id|stat
id|st
suffix:semicolon
r_int
r_int
id|date
suffix:semicolon
r_int
r_char
id|logged_sha1
(braket
l_int|20
)braket
suffix:semicolon
r_void
op_star
id|log_mapped
suffix:semicolon
r_int
id|mapsz
suffix:semicolon
id|logfile
op_assign
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|refname
)paren
suffix:semicolon
id|logfd
op_assign
id|open
c_func
(paren
id|logfile
comma
id|O_RDONLY
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|logfd
OL
l_int|0
)paren
id|die_errno
c_func
(paren
l_string|&quot;Unable to read log &squot;%s&squot;&quot;
comma
id|logfile
)paren
suffix:semicolon
id|fstat
c_func
(paren
id|logfd
comma
op_amp
id|st
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|st.st_size
)paren
id|die
c_func
(paren
l_string|&quot;Log %s is empty.&quot;
comma
id|logfile
)paren
suffix:semicolon
id|mapsz
op_assign
id|xsize_t
c_func
(paren
id|st.st_size
)paren
suffix:semicolon
id|log_mapped
op_assign
id|xmmap
c_func
(paren
l_int|NULL
comma
id|mapsz
comma
id|PROT_READ
comma
id|MAP_PRIVATE
comma
id|logfd
comma
l_int|0
)paren
suffix:semicolon
id|logdata
op_assign
id|log_mapped
suffix:semicolon
id|close
c_func
(paren
id|logfd
)paren
suffix:semicolon
id|lastrec
op_assign
l_int|NULL
suffix:semicolon
id|rec
op_assign
id|logend
op_assign
id|logdata
op_plus
id|st.st_size
suffix:semicolon
r_while
c_loop
(paren
id|logdata
OL
id|rec
)paren
(brace
id|reccnt
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|logdata
OL
id|rec
op_logical_and
op_star
(paren
id|rec
op_minus
l_int|1
)paren
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|rec
op_decrement
suffix:semicolon
id|lastgt
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|logdata
OL
id|rec
op_logical_and
op_star
(paren
id|rec
op_minus
l_int|1
)paren
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|rec
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_star
id|rec
op_eq
l_char|&squot;&gt;&squot;
)paren
id|lastgt
op_assign
id|rec
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|lastgt
)paren
id|die
c_func
(paren
l_string|&quot;Log %s is corrupt.&quot;
comma
id|logfile
)paren
suffix:semicolon
id|date
op_assign
id|strtoul
c_func
(paren
id|lastgt
op_plus
l_int|1
comma
op_amp
id|tz_c
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|date
op_le
id|at_time
op_logical_or
id|cnt
op_eq
l_int|0
)paren
(brace
id|tz
op_assign
id|strtoul
c_func
(paren
id|tz_c
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg
)paren
op_star
id|msg
op_assign
id|ref_msg
c_func
(paren
id|rec
comma
id|logend
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cutoff_time
)paren
op_star
id|cutoff_time
op_assign
id|date
suffix:semicolon
r_if
c_cond
(paren
id|cutoff_tz
)paren
op_star
id|cutoff_tz
op_assign
id|tz
suffix:semicolon
r_if
c_cond
(paren
id|cutoff_cnt
)paren
op_star
id|cutoff_cnt
op_assign
id|reccnt
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|lastrec
)paren
(brace
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|lastrec
comma
id|logged_sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Log %s is corrupt.&quot;
comma
id|logfile
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|rec
op_plus
l_int|41
comma
id|sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Log %s is corrupt.&quot;
comma
id|logfile
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hashcmp
c_func
(paren
id|logged_sha1
comma
id|sha1
)paren
)paren
(brace
id|warning
c_func
(paren
l_string|&quot;Log %s has gap after %s.&quot;
comma
id|logfile
comma
id|show_date
c_func
(paren
id|date
comma
id|tz
comma
id|DATE_RFC2822
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|date
op_eq
id|at_time
)paren
(brace
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|rec
op_plus
l_int|41
comma
id|sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Log %s is corrupt.&quot;
comma
id|logfile
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|rec
op_plus
l_int|41
comma
id|logged_sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Log %s is corrupt.&quot;
comma
id|logfile
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hashcmp
c_func
(paren
id|logged_sha1
comma
id|sha1
)paren
)paren
(brace
id|warning
c_func
(paren
l_string|&quot;Log %s unexpectedly ended on %s.&quot;
comma
id|logfile
comma
id|show_date
c_func
(paren
id|date
comma
id|tz
comma
id|DATE_RFC2822
)paren
)paren
suffix:semicolon
)brace
)brace
id|munmap
c_func
(paren
id|log_mapped
comma
id|mapsz
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|lastrec
op_assign
id|rec
suffix:semicolon
r_if
c_cond
(paren
id|cnt
OG
l_int|0
)paren
id|cnt
op_decrement
suffix:semicolon
)brace
id|rec
op_assign
id|logdata
suffix:semicolon
r_while
c_loop
(paren
id|rec
OL
id|logend
op_logical_and
op_star
id|rec
op_ne
l_char|&squot;&gt;&squot;
op_logical_and
op_star
id|rec
op_ne
l_char|&squot;&bslash;n&squot;
)paren
id|rec
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|rec
op_eq
id|logend
op_logical_or
op_star
id|rec
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|die
c_func
(paren
l_string|&quot;Log %s is corrupt.&quot;
comma
id|logfile
)paren
suffix:semicolon
id|date
op_assign
id|strtoul
c_func
(paren
id|rec
op_plus
l_int|1
comma
op_amp
id|tz_c
comma
l_int|10
)paren
suffix:semicolon
id|tz
op_assign
id|strtoul
c_func
(paren
id|tz_c
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|logdata
comma
id|sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Log %s is corrupt.&quot;
comma
id|logfile
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_null_sha1
c_func
(paren
id|sha1
)paren
)paren
(brace
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|logdata
op_plus
l_int|41
comma
id|sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Log %s is corrupt.&quot;
comma
id|logfile
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|msg
)paren
op_star
id|msg
op_assign
id|ref_msg
c_func
(paren
id|logdata
comma
id|logend
)paren
suffix:semicolon
id|munmap
c_func
(paren
id|log_mapped
comma
id|mapsz
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cutoff_time
)paren
op_star
id|cutoff_time
op_assign
id|date
suffix:semicolon
r_if
c_cond
(paren
id|cutoff_tz
)paren
op_star
id|cutoff_tz
op_assign
id|tz
suffix:semicolon
r_if
c_cond
(paren
id|cutoff_cnt
)paren
op_star
id|cutoff_cnt
op_assign
id|reccnt
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|for_each_recent_reflog_ent
r_int
id|for_each_recent_reflog_ent
c_func
(paren
r_const
r_char
op_star
id|refname
comma
id|each_reflog_ent_fn
id|fn
comma
r_int
id|ofs
comma
r_void
op_star
id|cb_data
)paren
(brace
r_const
r_char
op_star
id|logfile
suffix:semicolon
id|FILE
op_star
id|logfp
suffix:semicolon
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|logfile
op_assign
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|refname
)paren
suffix:semicolon
id|logfp
op_assign
id|fopen
c_func
(paren
id|logfile
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|logfp
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ofs
)paren
(brace
r_struct
id|stat
id|statbuf
suffix:semicolon
r_if
c_cond
(paren
id|fstat
c_func
(paren
id|fileno
c_func
(paren
id|logfp
)paren
comma
op_amp
id|statbuf
)paren
op_logical_or
id|statbuf.st_size
OL
id|ofs
op_logical_or
id|fseek
c_func
(paren
id|logfp
comma
id|ofs
comma
id|SEEK_END
)paren
op_logical_or
id|strbuf_getwholeline
c_func
(paren
op_amp
id|sb
comma
id|logfp
comma
l_char|&squot;&bslash;n&squot;
)paren
)paren
(brace
id|fclose
c_func
(paren
id|logfp
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
op_logical_neg
id|strbuf_getwholeline
c_func
(paren
op_amp
id|sb
comma
id|logfp
comma
l_char|&squot;&bslash;n&squot;
)paren
)paren
(brace
r_int
r_char
id|osha1
(braket
l_int|20
)braket
comma
id|nsha1
(braket
l_int|20
)braket
suffix:semicolon
r_char
op_star
id|email_end
comma
op_star
id|message
suffix:semicolon
r_int
r_int
id|timestamp
suffix:semicolon
r_int
id|tz
suffix:semicolon
multiline_comment|/* old SP new SP name &lt;email&gt; SP time TAB msg LF */
r_if
c_cond
(paren
id|sb.len
OL
l_int|83
op_logical_or
id|sb.buf
(braket
id|sb.len
l_int|1
)braket
op_ne
l_char|&squot;&bslash;n&squot;
op_logical_or
id|get_sha1_hex
c_func
(paren
id|sb.buf
comma
id|osha1
)paren
op_logical_or
id|sb.buf
(braket
l_int|40
)braket
op_ne
l_char|&squot; &squot;
op_logical_or
id|get_sha1_hex
c_func
(paren
id|sb.buf
op_plus
l_int|41
comma
id|nsha1
)paren
op_logical_or
id|sb.buf
(braket
l_int|81
)braket
op_ne
l_char|&squot; &squot;
op_logical_or
op_logical_neg
(paren
id|email_end
op_assign
id|strchr
c_func
(paren
id|sb.buf
op_plus
l_int|82
comma
l_char|&squot;&gt;&squot;
)paren
)paren
op_logical_or
id|email_end
(braket
l_int|1
)braket
op_ne
l_char|&squot; &squot;
op_logical_or
op_logical_neg
(paren
id|timestamp
op_assign
id|strtoul
c_func
(paren
id|email_end
op_plus
l_int|2
comma
op_amp
id|message
comma
l_int|10
)paren
)paren
op_logical_or
op_logical_neg
id|message
op_logical_or
id|message
(braket
l_int|0
)braket
op_ne
l_char|&squot; &squot;
op_logical_or
(paren
id|message
(braket
l_int|1
)braket
op_ne
l_char|&squot;+&squot;
op_logical_and
id|message
(braket
l_int|1
)braket
op_ne
l_char|&squot;-&squot;
)paren
op_logical_or
op_logical_neg
id|isdigit
c_func
(paren
id|message
(braket
l_int|2
)braket
)paren
op_logical_or
op_logical_neg
id|isdigit
c_func
(paren
id|message
(braket
l_int|3
)braket
)paren
op_logical_or
op_logical_neg
id|isdigit
c_func
(paren
id|message
(braket
l_int|4
)braket
)paren
op_logical_or
op_logical_neg
id|isdigit
c_func
(paren
id|message
(braket
l_int|5
)braket
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* corrupt? */
id|email_end
(braket
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|tz
op_assign
id|strtol
c_func
(paren
id|message
op_plus
l_int|1
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|message
(braket
l_int|6
)braket
op_ne
l_char|&squot;&bslash;t&squot;
)paren
id|message
op_add_assign
l_int|6
suffix:semicolon
r_else
id|message
op_add_assign
l_int|7
suffix:semicolon
id|ret
op_assign
id|fn
c_func
(paren
id|osha1
comma
id|nsha1
comma
id|sb.buf
op_plus
l_int|82
comma
id|timestamp
comma
id|tz
comma
id|message
comma
id|cb_data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_break
suffix:semicolon
)brace
id|fclose
c_func
(paren
id|logfp
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|for_each_reflog_ent
r_int
id|for_each_reflog_ent
c_func
(paren
r_const
r_char
op_star
id|refname
comma
id|each_reflog_ent_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|for_each_recent_reflog_ent
c_func
(paren
id|refname
comma
id|fn
comma
l_int|0
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|do_for_each_reflog
r_static
r_int
id|do_for_each_reflog
c_func
(paren
r_const
r_char
op_star
id|base
comma
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
id|DIR
op_star
id|dir
op_assign
id|opendir
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|base
)paren
)paren
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dir
)paren
(brace
r_struct
id|dirent
op_star
id|de
suffix:semicolon
r_int
id|baselen
op_assign
id|strlen
c_func
(paren
id|base
)paren
suffix:semicolon
r_char
op_star
id|log
op_assign
id|xmalloc
c_func
(paren
id|baselen
op_plus
l_int|257
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|log
comma
id|base
comma
id|baselen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|baselen
op_logical_and
id|base
(braket
id|baselen
op_minus
l_int|1
)braket
op_ne
l_char|&squot;/&squot;
)paren
id|log
(braket
id|baselen
op_increment
)braket
op_assign
l_char|&squot;/&squot;
suffix:semicolon
r_while
c_loop
(paren
(paren
id|de
op_assign
id|readdir
c_func
(paren
id|dir
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_struct
id|stat
id|st
suffix:semicolon
r_int
id|namelen
suffix:semicolon
r_if
c_cond
(paren
id|de-&gt;d_name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
)paren
r_continue
suffix:semicolon
id|namelen
op_assign
id|strlen
c_func
(paren
id|de-&gt;d_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|namelen
OG
l_int|255
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|has_extension
c_func
(paren
id|de-&gt;d_name
comma
l_string|&quot;.lock&quot;
)paren
)paren
r_continue
suffix:semicolon
id|memcpy
c_func
(paren
id|log
op_plus
id|baselen
comma
id|de-&gt;d_name
comma
id|namelen
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;logs/%s&quot;
comma
id|log
)paren
comma
op_amp
id|st
)paren
OL
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|st.st_mode
)paren
)paren
(brace
id|retval
op_assign
id|do_for_each_reflog
c_func
(paren
id|log
comma
id|fn
comma
id|cb_data
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_if
c_cond
(paren
id|read_ref_full
c_func
(paren
id|log
comma
id|sha1
comma
l_int|0
comma
l_int|NULL
)paren
)paren
id|retval
op_assign
id|error
c_func
(paren
l_string|&quot;bad ref for %s&quot;
comma
id|log
)paren
suffix:semicolon
r_else
id|retval
op_assign
id|fn
c_func
(paren
id|log
comma
id|sha1
comma
l_int|0
comma
id|cb_data
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retval
)paren
r_break
suffix:semicolon
)brace
id|free
c_func
(paren
id|log
)paren
suffix:semicolon
id|closedir
c_func
(paren
id|dir
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_star
id|base
)paren
r_return
id|errno
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|for_each_reflog
r_int
id|for_each_reflog
c_func
(paren
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|do_for_each_reflog
c_func
(paren
l_string|&quot;&quot;
comma
id|fn
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|update_ref
r_int
id|update_ref
c_func
(paren
r_const
r_char
op_star
id|action
comma
r_const
r_char
op_star
id|refname
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_const
r_int
r_char
op_star
id|oldval
comma
r_int
id|flags
comma
r_enum
id|action_on_err
id|onerr
)paren
(brace
r_static
r_struct
id|ref_lock
op_star
id|lock
suffix:semicolon
id|lock
op_assign
id|lock_any_ref_for_update
c_func
(paren
id|refname
comma
id|oldval
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lock
)paren
(brace
r_const
r_char
op_star
id|str
op_assign
l_string|&quot;Cannot lock the ref &squot;%s&squot;.&quot;
suffix:semicolon
r_switch
c_cond
(paren
id|onerr
)paren
(brace
r_case
id|MSG_ON_ERR
suffix:colon
id|error
c_func
(paren
id|str
comma
id|refname
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DIE_ON_ERR
suffix:colon
id|die
c_func
(paren
id|str
comma
id|refname
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QUIET_ON_ERR
suffix:colon
r_break
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|write_ref_sha1
c_func
(paren
id|lock
comma
id|sha1
comma
id|action
)paren
OL
l_int|0
)paren
(brace
r_const
r_char
op_star
id|str
op_assign
l_string|&quot;Cannot update the ref &squot;%s&squot;.&quot;
suffix:semicolon
r_switch
c_cond
(paren
id|onerr
)paren
(brace
r_case
id|MSG_ON_ERR
suffix:colon
id|error
c_func
(paren
id|str
comma
id|refname
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DIE_ON_ERR
suffix:colon
id|die
c_func
(paren
id|str
comma
id|refname
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QUIET_ON_ERR
suffix:colon
r_break
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|find_ref_by_name
r_struct
id|ref
op_star
id|find_ref_by_name
c_func
(paren
r_const
r_struct
id|ref
op_star
id|list
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|list
suffix:semicolon
id|list
op_assign
id|list-&gt;next
)paren
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|list-&gt;name
comma
id|name
)paren
)paren
r_return
(paren
r_struct
id|ref
op_star
)paren
id|list
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * generate a format suitable for scanf from a ref_rev_parse_rules&n; * rule, that is replace the &quot;%.*s&quot; spec with a &quot;%s&quot; spec&n; */
DECL|function|gen_scanf_fmt
r_static
r_void
id|gen_scanf_fmt
c_func
(paren
r_char
op_star
id|scanf_fmt
comma
r_const
r_char
op_star
id|rule
)paren
(brace
r_char
op_star
id|spec
suffix:semicolon
id|spec
op_assign
id|strstr
c_func
(paren
id|rule
comma
l_string|&quot;%.*s&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|spec
op_logical_or
id|strstr
c_func
(paren
id|spec
op_plus
l_int|4
comma
l_string|&quot;%.*s&quot;
)paren
)paren
id|die
c_func
(paren
l_string|&quot;invalid rule in ref_rev_parse_rules: %s&quot;
comma
id|rule
)paren
suffix:semicolon
multiline_comment|/* copy all until spec */
id|strncpy
c_func
(paren
id|scanf_fmt
comma
id|rule
comma
id|spec
id|rule
)paren
suffix:semicolon
id|scanf_fmt
(braket
id|spec
id|rule
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
multiline_comment|/* copy new spec */
id|strcat
c_func
(paren
id|scanf_fmt
comma
l_string|&quot;%s&quot;
)paren
suffix:semicolon
multiline_comment|/* copy remaining rule */
id|strcat
c_func
(paren
id|scanf_fmt
comma
id|spec
op_plus
l_int|4
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|shorten_unambiguous_ref
r_char
op_star
id|shorten_unambiguous_ref
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_int
id|strict
)paren
(brace
r_int
id|i
suffix:semicolon
r_static
r_char
op_star
op_star
id|scanf_fmts
suffix:semicolon
r_static
r_int
id|nr_rules
suffix:semicolon
r_char
op_star
id|short_name
suffix:semicolon
multiline_comment|/* pre generate scanf formats from ref_rev_parse_rules[] */
r_if
c_cond
(paren
op_logical_neg
id|nr_rules
)paren
(brace
r_int
id|total_len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* the rule list is NULL terminated, count them first */
r_for
c_loop
(paren
suffix:semicolon
id|ref_rev_parse_rules
(braket
id|nr_rules
)braket
suffix:semicolon
id|nr_rules
op_increment
)paren
multiline_comment|/* no +1 because strlen(&quot;%s&quot;) &lt; strlen(&quot;%.*s&quot;) */
id|total_len
op_add_assign
id|strlen
c_func
(paren
id|ref_rev_parse_rules
(braket
id|nr_rules
)braket
)paren
suffix:semicolon
id|scanf_fmts
op_assign
id|xmalloc
c_func
(paren
id|nr_rules
op_star
r_sizeof
(paren
r_char
op_star
)paren
op_plus
id|total_len
)paren
suffix:semicolon
id|total_len
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_rules
suffix:semicolon
id|i
op_increment
)paren
(brace
id|scanf_fmts
(braket
id|i
)braket
op_assign
(paren
r_char
op_star
)paren
op_amp
id|scanf_fmts
(braket
id|nr_rules
)braket
op_plus
id|total_len
suffix:semicolon
id|gen_scanf_fmt
c_func
(paren
id|scanf_fmts
(braket
id|i
)braket
comma
id|ref_rev_parse_rules
(braket
id|i
)braket
)paren
suffix:semicolon
id|total_len
op_add_assign
id|strlen
c_func
(paren
id|ref_rev_parse_rules
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* bail out if there are no rules */
r_if
c_cond
(paren
op_logical_neg
id|nr_rules
)paren
r_return
id|xstrdup
c_func
(paren
id|refname
)paren
suffix:semicolon
multiline_comment|/* buffer for scanf result, at most refname must fit */
id|short_name
op_assign
id|xstrdup
c_func
(paren
id|refname
)paren
suffix:semicolon
multiline_comment|/* skip first rule, it will always match */
r_for
c_loop
(paren
id|i
op_assign
id|nr_rules
l_int|1
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
op_decrement
id|i
)paren
(brace
r_int
id|j
suffix:semicolon
r_int
id|rules_to_fail
op_assign
id|i
suffix:semicolon
r_int
id|short_name_len
suffix:semicolon
r_if
c_cond
(paren
l_int|1
op_ne
id|sscanf
c_func
(paren
id|refname
comma
id|scanf_fmts
(braket
id|i
)braket
comma
id|short_name
)paren
)paren
r_continue
suffix:semicolon
id|short_name_len
op_assign
id|strlen
c_func
(paren
id|short_name
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * in strict mode, all (except the matched one) rules&n;&t;&t; * must fail to resolve to a valid non-ambiguous ref&n;&t;&t; */
r_if
c_cond
(paren
id|strict
)paren
id|rules_to_fail
op_assign
id|nr_rules
suffix:semicolon
multiline_comment|/*&n;&t;&t; * check if the short name resolves to a valid ref,&n;&t;&t; * but use only rules prior to the matched one&n;&t;&t; */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|rules_to_fail
suffix:semicolon
id|j
op_increment
)paren
(brace
r_const
r_char
op_star
id|rule
op_assign
id|ref_rev_parse_rules
(braket
id|j
)braket
suffix:semicolon
r_char
id|refname
(braket
id|PATH_MAX
)braket
suffix:semicolon
multiline_comment|/* skip matched rule */
r_if
c_cond
(paren
id|i
op_eq
id|j
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * the short name is ambiguous, if it resolves&n;&t;&t;&t; * (with this previous rule) to a valid ref&n;&t;&t;&t; * read_ref() returns 0 on success&n;&t;&t;&t; */
id|mksnpath
c_func
(paren
id|refname
comma
r_sizeof
(paren
id|refname
)paren
comma
id|rule
comma
id|short_name_len
comma
id|short_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ref_exists
c_func
(paren
id|refname
)paren
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * short name is non-ambiguous if all previous rules&n;&t;&t; * haven&squot;t resolved to a valid ref&n;&t;&t; */
r_if
c_cond
(paren
id|j
op_eq
id|rules_to_fail
)paren
r_return
id|short_name
suffix:semicolon
)brace
id|free
c_func
(paren
id|short_name
)paren
suffix:semicolon
r_return
id|xstrdup
c_func
(paren
id|refname
)paren
suffix:semicolon
)brace
eof
