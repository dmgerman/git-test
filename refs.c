multiline_comment|/*&n; * The backend-independent part of the reference module.&n; */
macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;lockfile.h&quot;
macro_line|#include &quot;refs.h&quot;
macro_line|#include &quot;refs/refs-internal.h&quot;
macro_line|#include &quot;object.h&quot;
macro_line|#include &quot;tag.h&quot;
multiline_comment|/*&n; * How to handle various characters in refnames:&n; * 0: An acceptable character for refs&n; * 1: End-of-component&n; * 2: ., look for a preceding . to reject .. in refs&n; * 3: {, look for a preceding @ to reject @{ in refs&n; * 4: A bad character: ASCII control characters, and&n; *    &quot;:&quot;, &quot;?&quot;, &quot;[&quot;, &quot;&bslash;&quot;, &quot;^&quot;, &quot;~&quot;, SP, or TAB&n; * 5: *, reject unless REFNAME_REFSPEC_PATTERN is set&n; */
DECL|variable|refname_disposition
r_static
r_int
r_char
id|refname_disposition
(braket
l_int|256
)braket
op_assign
(brace
l_int|1
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|5
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|2
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|4
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|4
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|4
comma
l_int|4
comma
l_int|0
comma
l_int|4
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|3
comma
l_int|0
comma
l_int|0
comma
l_int|4
comma
l_int|4
)brace
suffix:semicolon
multiline_comment|/*&n; * Try to read one refname component from the front of refname.&n; * Return the length of the component found, or -1 if the component is&n; * not legal.  It is legal if it is something reasonable to have under&n; * &quot;.git/refs/&quot;; We do not like it if:&n; *&n; * - any path component of it begins with &quot;.&quot;, or&n; * - it has double dots &quot;..&quot;, or&n; * - it has ASCII control characters, or&n; * - it has &quot;:&quot;, &quot;?&quot;, &quot;[&quot;, &quot;&bslash;&quot;, &quot;^&quot;, &quot;~&quot;, SP, or TAB anywhere, or&n; * - it has &quot;*&quot; anywhere unless REFNAME_REFSPEC_PATTERN is set, or&n; * - it ends with a &quot;/&quot;, or&n; * - it ends with &quot;.lock&quot;, or&n; * - it contains a &quot;@{&quot; portion&n; */
DECL|function|check_refname_component
r_static
r_int
id|check_refname_component
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_int
op_star
id|flags
)paren
(brace
r_const
r_char
op_star
id|cp
suffix:semicolon
r_char
id|last
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_for
c_loop
(paren
id|cp
op_assign
id|refname
suffix:semicolon
suffix:semicolon
id|cp
op_increment
)paren
(brace
r_int
id|ch
op_assign
op_star
id|cp
op_amp
l_int|255
suffix:semicolon
r_int
r_char
id|disp
op_assign
id|refname_disposition
(braket
id|ch
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|disp
)paren
(brace
r_case
l_int|1
suffix:colon
r_goto
id|out
suffix:semicolon
r_case
l_int|2
suffix:colon
r_if
c_cond
(paren
id|last
op_eq
l_char|&squot;.&squot;
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Refname contains &quot;..&quot;. */
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
r_if
c_cond
(paren
id|last
op_eq
l_char|&squot;@&squot;
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Refname contains &quot;@{&quot;. */
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
r_return
l_int|1
suffix:semicolon
r_case
l_int|5
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|flags
op_amp
id|REFNAME_REFSPEC_PATTERN
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* refspec can&squot;t be a pattern */
multiline_comment|/*&n;&t;&t;&t; * Unset the pattern flag so that we only accept&n;&t;&t;&t; * a single asterisk for one side of refspec.&n;&t;&t;&t; */
op_star
id|flags
op_and_assign
op_complement
id|REFNAME_REFSPEC_PATTERN
suffix:semicolon
r_break
suffix:semicolon
)brace
id|last
op_assign
id|ch
suffix:semicolon
)brace
id|out
suffix:colon
r_if
c_cond
(paren
id|cp
op_eq
id|refname
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Component has zero length. */
r_if
c_cond
(paren
id|refname
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Component starts with &squot;.&squot;. */
r_if
c_cond
(paren
id|cp
id|refname
op_ge
id|LOCK_SUFFIX_LEN
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|cp
id|LOCK_SUFFIX_LEN
comma
id|LOCK_SUFFIX
comma
id|LOCK_SUFFIX_LEN
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Refname ends with &quot;.lock&quot;. */
r_return
id|cp
id|refname
suffix:semicolon
)brace
DECL|function|check_refname_format
r_int
id|check_refname_format
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_int
id|flags
)paren
(brace
r_int
id|component_len
comma
id|component_count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|refname
comma
l_string|&quot;@&quot;
)paren
)paren
multiline_comment|/* Refname is a single character &squot;@&squot;. */
r_return
l_int|1
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
multiline_comment|/* We are at the start of a path component. */
id|component_len
op_assign
id|check_refname_component
c_func
(paren
id|refname
comma
op_amp
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|component_len
op_le
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
id|component_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|refname
(braket
id|component_len
)braket
op_eq
l_char|&squot;&bslash;0&squot;
)paren
r_break
suffix:semicolon
multiline_comment|/* Skip to next component. */
id|refname
op_add_assign
id|component_len
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|refname
(braket
id|component_len
l_int|1
)braket
op_eq
l_char|&squot;.&squot;
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Refname ends with &squot;.&squot;. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|REFNAME_ALLOW_ONELEVEL
)paren
op_logical_and
id|component_count
OL
l_int|2
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Refname has only one component. */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|refname_is_safe
r_int
id|refname_is_safe
c_func
(paren
r_const
r_char
op_star
id|refname
)paren
(brace
r_if
c_cond
(paren
id|starts_with
c_func
(paren
id|refname
comma
l_string|&quot;refs/&quot;
)paren
)paren
(brace
r_char
op_star
id|buf
suffix:semicolon
r_int
id|result
suffix:semicolon
id|buf
op_assign
id|xmalloc
c_func
(paren
id|strlen
c_func
(paren
id|refname
)paren
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Does the refname try to escape refs/?&n;&t;&t; * For example: refs/foo/../bar is safe but refs/foo/../../bar&n;&t;&t; * is not.&n;&t;&t; */
id|result
op_assign
op_logical_neg
id|normalize_path_copy
c_func
(paren
id|buf
comma
id|refname
op_plus
id|strlen
c_func
(paren
l_string|&quot;refs/&quot;
)paren
)paren
suffix:semicolon
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
r_while
c_loop
(paren
op_star
id|refname
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|isupper
c_func
(paren
op_star
id|refname
)paren
op_logical_and
op_star
id|refname
op_ne
l_char|&squot;_&squot;
)paren
r_return
l_int|0
suffix:semicolon
id|refname
op_increment
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|resolve_refdup
r_char
op_star
id|resolve_refdup
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_int
id|resolve_flags
comma
r_int
r_char
op_star
id|sha1
comma
r_int
op_star
id|flags
)paren
(brace
r_return
id|xstrdup_or_null
c_func
(paren
id|resolve_ref_unsafe
c_func
(paren
id|refname
comma
id|resolve_flags
comma
id|sha1
comma
id|flags
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* The argument to filter_refs */
DECL|struct|ref_filter
r_struct
id|ref_filter
(brace
DECL|member|pattern
r_const
r_char
op_star
id|pattern
suffix:semicolon
DECL|member|fn
id|each_ref_fn
op_star
id|fn
suffix:semicolon
DECL|member|cb_data
r_void
op_star
id|cb_data
suffix:semicolon
)brace
suffix:semicolon
DECL|function|read_ref_full
r_int
id|read_ref_full
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_int
id|resolve_flags
comma
r_int
r_char
op_star
id|sha1
comma
r_int
op_star
id|flags
)paren
(brace
r_if
c_cond
(paren
id|resolve_ref_unsafe
c_func
(paren
id|refname
comma
id|resolve_flags
comma
id|sha1
comma
id|flags
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|read_ref
r_int
id|read_ref
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_int
r_char
op_star
id|sha1
)paren
(brace
r_return
id|read_ref_full
c_func
(paren
id|refname
comma
id|RESOLVE_REF_READING
comma
id|sha1
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|ref_exists
r_int
id|ref_exists
c_func
(paren
r_const
r_char
op_star
id|refname
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_return
op_logical_neg
op_logical_neg
id|resolve_ref_unsafe
c_func
(paren
id|refname
comma
id|RESOLVE_REF_READING
comma
id|sha1
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|filter_refs
r_static
r_int
id|filter_refs
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_const
r_struct
id|object_id
op_star
id|oid
comma
r_int
id|flags
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|ref_filter
op_star
id|filter
op_assign
(paren
r_struct
id|ref_filter
op_star
)paren
id|data
suffix:semicolon
r_if
c_cond
(paren
id|wildmatch
c_func
(paren
id|filter-&gt;pattern
comma
id|refname
comma
l_int|0
comma
l_int|NULL
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|filter
op_member_access_from_pointer
id|fn
c_func
(paren
id|refname
comma
id|oid
comma
id|flags
comma
id|filter-&gt;cb_data
)paren
suffix:semicolon
)brace
DECL|function|peel_object
r_enum
id|peel_status
id|peel_object
c_func
(paren
r_const
r_int
r_char
op_star
id|name
comma
r_int
r_char
op_star
id|sha1
)paren
(brace
r_struct
id|object
op_star
id|o
op_assign
id|lookup_unknown_object
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|o-&gt;type
op_eq
id|OBJ_NONE
)paren
(brace
r_int
id|type
op_assign
id|sha1_object_info
c_func
(paren
id|name
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
OL
l_int|0
op_logical_or
op_logical_neg
id|object_as_type
c_func
(paren
id|o
comma
id|type
comma
l_int|0
)paren
)paren
r_return
id|PEEL_INVALID
suffix:semicolon
)brace
r_if
c_cond
(paren
id|o-&gt;type
op_ne
id|OBJ_TAG
)paren
r_return
id|PEEL_NON_TAG
suffix:semicolon
id|o
op_assign
id|deref_tag_noverify
c_func
(paren
id|o
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|o
)paren
r_return
id|PEEL_INVALID
suffix:semicolon
id|hashcpy
c_func
(paren
id|sha1
comma
id|o-&gt;oid.hash
)paren
suffix:semicolon
r_return
id|PEEL_PEELED
suffix:semicolon
)brace
DECL|struct|warn_if_dangling_data
r_struct
id|warn_if_dangling_data
(brace
DECL|member|fp
id|FILE
op_star
id|fp
suffix:semicolon
DECL|member|refname
r_const
r_char
op_star
id|refname
suffix:semicolon
DECL|member|refnames
r_const
r_struct
id|string_list
op_star
id|refnames
suffix:semicolon
DECL|member|msg_fmt
r_const
r_char
op_star
id|msg_fmt
suffix:semicolon
)brace
suffix:semicolon
DECL|function|warn_if_dangling_symref
r_static
r_int
id|warn_if_dangling_symref
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_const
r_struct
id|object_id
op_star
id|oid
comma
r_int
id|flags
comma
r_void
op_star
id|cb_data
)paren
(brace
r_struct
id|warn_if_dangling_data
op_star
id|d
op_assign
id|cb_data
suffix:semicolon
r_const
r_char
op_star
id|resolves_to
suffix:semicolon
r_struct
id|object_id
id|junk
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|REF_ISSYMREF
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|resolves_to
op_assign
id|resolve_ref_unsafe
c_func
(paren
id|refname
comma
l_int|0
comma
id|junk.hash
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|resolves_to
op_logical_or
(paren
id|d-&gt;refname
ques
c_cond
id|strcmp
c_func
(paren
id|resolves_to
comma
id|d-&gt;refname
)paren
suffix:colon
op_logical_neg
id|string_list_has_string
c_func
(paren
id|d-&gt;refnames
comma
id|resolves_to
)paren
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|fprintf
c_func
(paren
id|d-&gt;fp
comma
id|d-&gt;msg_fmt
comma
id|refname
)paren
suffix:semicolon
id|fputc
c_func
(paren
l_char|&squot;&bslash;n&squot;
comma
id|d-&gt;fp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|warn_dangling_symref
r_void
id|warn_dangling_symref
c_func
(paren
id|FILE
op_star
id|fp
comma
r_const
r_char
op_star
id|msg_fmt
comma
r_const
r_char
op_star
id|refname
)paren
(brace
r_struct
id|warn_if_dangling_data
id|data
suffix:semicolon
id|data.fp
op_assign
id|fp
suffix:semicolon
id|data.refname
op_assign
id|refname
suffix:semicolon
id|data.refnames
op_assign
l_int|NULL
suffix:semicolon
id|data.msg_fmt
op_assign
id|msg_fmt
suffix:semicolon
id|for_each_rawref
c_func
(paren
id|warn_if_dangling_symref
comma
op_amp
id|data
)paren
suffix:semicolon
)brace
DECL|function|warn_dangling_symrefs
r_void
id|warn_dangling_symrefs
c_func
(paren
id|FILE
op_star
id|fp
comma
r_const
r_char
op_star
id|msg_fmt
comma
r_const
r_struct
id|string_list
op_star
id|refnames
)paren
(brace
r_struct
id|warn_if_dangling_data
id|data
suffix:semicolon
id|data.fp
op_assign
id|fp
suffix:semicolon
id|data.refname
op_assign
l_int|NULL
suffix:semicolon
id|data.refnames
op_assign
id|refnames
suffix:semicolon
id|data.msg_fmt
op_assign
id|msg_fmt
suffix:semicolon
id|for_each_rawref
c_func
(paren
id|warn_if_dangling_symref
comma
op_amp
id|data
)paren
suffix:semicolon
)brace
DECL|function|for_each_tag_ref
r_int
id|for_each_tag_ref
c_func
(paren
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|for_each_ref_in
c_func
(paren
l_string|&quot;refs/tags/&quot;
comma
id|fn
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|for_each_tag_ref_submodule
r_int
id|for_each_tag_ref_submodule
c_func
(paren
r_const
r_char
op_star
id|submodule
comma
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|for_each_ref_in_submodule
c_func
(paren
id|submodule
comma
l_string|&quot;refs/tags/&quot;
comma
id|fn
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|for_each_branch_ref
r_int
id|for_each_branch_ref
c_func
(paren
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|for_each_ref_in
c_func
(paren
l_string|&quot;refs/heads/&quot;
comma
id|fn
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|for_each_branch_ref_submodule
r_int
id|for_each_branch_ref_submodule
c_func
(paren
r_const
r_char
op_star
id|submodule
comma
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|for_each_ref_in_submodule
c_func
(paren
id|submodule
comma
l_string|&quot;refs/heads/&quot;
comma
id|fn
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|for_each_remote_ref
r_int
id|for_each_remote_ref
c_func
(paren
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|for_each_ref_in
c_func
(paren
l_string|&quot;refs/remotes/&quot;
comma
id|fn
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|for_each_remote_ref_submodule
r_int
id|for_each_remote_ref_submodule
c_func
(paren
r_const
r_char
op_star
id|submodule
comma
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|for_each_ref_in_submodule
c_func
(paren
id|submodule
comma
l_string|&quot;refs/remotes/&quot;
comma
id|fn
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|head_ref_namespaced
r_int
id|head_ref_namespaced
c_func
(paren
id|each_ref_fn
id|fn
comma
r_void
op_star
id|cb_data
)paren
(brace
r_struct
id|strbuf
id|buf
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_struct
id|object_id
id|oid
suffix:semicolon
r_int
id|flag
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
id|buf
comma
l_string|&quot;%sHEAD&quot;
comma
id|get_git_namespace
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|read_ref_full
c_func
(paren
id|buf.buf
comma
id|RESOLVE_REF_READING
comma
id|oid.hash
comma
op_amp
id|flag
)paren
)paren
id|ret
op_assign
id|fn
c_func
(paren
id|buf.buf
comma
op_amp
id|oid
comma
id|flag
comma
id|cb_data
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|buf
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|for_each_glob_ref_in
r_int
id|for_each_glob_ref_in
c_func
(paren
id|each_ref_fn
id|fn
comma
r_const
r_char
op_star
id|pattern
comma
r_const
r_char
op_star
id|prefix
comma
r_void
op_star
id|cb_data
)paren
(brace
r_struct
id|strbuf
id|real_pattern
op_assign
id|STRBUF_INIT
suffix:semicolon
r_struct
id|ref_filter
id|filter
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prefix
op_logical_and
op_logical_neg
id|starts_with
c_func
(paren
id|pattern
comma
l_string|&quot;refs/&quot;
)paren
)paren
id|strbuf_addstr
c_func
(paren
op_amp
id|real_pattern
comma
l_string|&quot;refs/&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|prefix
)paren
id|strbuf_addstr
c_func
(paren
op_amp
id|real_pattern
comma
id|prefix
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
op_amp
id|real_pattern
comma
id|pattern
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|has_glob_specials
c_func
(paren
id|pattern
)paren
)paren
(brace
multiline_comment|/* Append implied &squot;/&squot; &squot;*&squot; if not present. */
id|strbuf_complete
c_func
(paren
op_amp
id|real_pattern
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
multiline_comment|/* No need to check for &squot;*&squot;, there is none. */
id|strbuf_addch
c_func
(paren
op_amp
id|real_pattern
comma
l_char|&squot;*&squot;
)paren
suffix:semicolon
)brace
id|filter.pattern
op_assign
id|real_pattern.buf
suffix:semicolon
id|filter.fn
op_assign
id|fn
suffix:semicolon
id|filter.cb_data
op_assign
id|cb_data
suffix:semicolon
id|ret
op_assign
id|for_each_ref
c_func
(paren
id|filter_refs
comma
op_amp
id|filter
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|real_pattern
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|for_each_glob_ref
r_int
id|for_each_glob_ref
c_func
(paren
id|each_ref_fn
id|fn
comma
r_const
r_char
op_star
id|pattern
comma
r_void
op_star
id|cb_data
)paren
(brace
r_return
id|for_each_glob_ref_in
c_func
(paren
id|fn
comma
id|pattern
comma
l_int|NULL
comma
id|cb_data
)paren
suffix:semicolon
)brace
DECL|function|prettify_refname
r_const
r_char
op_star
id|prettify_refname
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_return
id|name
op_plus
(paren
id|starts_with
c_func
(paren
id|name
comma
l_string|&quot;refs/heads/&quot;
)paren
ques
c_cond
l_int|11
suffix:colon
id|starts_with
c_func
(paren
id|name
comma
l_string|&quot;refs/tags/&quot;
)paren
ques
c_cond
l_int|10
suffix:colon
id|starts_with
c_func
(paren
id|name
comma
l_string|&quot;refs/remotes/&quot;
)paren
ques
c_cond
l_int|13
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
DECL|variable|ref_rev_parse_rules
r_static
r_const
r_char
op_star
id|ref_rev_parse_rules
(braket
)braket
op_assign
(brace
l_string|&quot;%.*s&quot;
comma
l_string|&quot;refs/%.*s&quot;
comma
l_string|&quot;refs/tags/%.*s&quot;
comma
l_string|&quot;refs/heads/%.*s&quot;
comma
l_string|&quot;refs/remotes/%.*s&quot;
comma
l_string|&quot;refs/remotes/%.*s/HEAD&quot;
comma
l_int|NULL
)brace
suffix:semicolon
DECL|function|refname_match
r_int
id|refname_match
c_func
(paren
r_const
r_char
op_star
id|abbrev_name
comma
r_const
r_char
op_star
id|full_name
)paren
(brace
r_const
r_char
op_star
op_star
id|p
suffix:semicolon
r_const
r_int
id|abbrev_name_len
op_assign
id|strlen
c_func
(paren
id|abbrev_name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|ref_rev_parse_rules
suffix:semicolon
op_star
id|p
suffix:semicolon
id|p
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|full_name
comma
id|mkpath
c_func
(paren
op_star
id|p
comma
id|abbrev_name_len
comma
id|abbrev_name
)paren
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * *string and *len will only be substituted, and *string returned (for&n; * later free()ing) if the string passed in is a magic short-hand form&n; * to name a branch.&n; */
DECL|function|substitute_branch_name
r_static
r_char
op_star
id|substitute_branch_name
c_func
(paren
r_const
r_char
op_star
op_star
id|string
comma
r_int
op_star
id|len
)paren
(brace
r_struct
id|strbuf
id|buf
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|ret
op_assign
id|interpret_branch_name
c_func
(paren
op_star
id|string
comma
op_star
id|len
comma
op_amp
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
op_star
id|len
)paren
(brace
r_int
id|size
suffix:semicolon
op_star
id|string
op_assign
id|strbuf_detach
c_func
(paren
op_amp
id|buf
comma
op_amp
id|size
)paren
suffix:semicolon
op_star
id|len
op_assign
id|size
suffix:semicolon
r_return
(paren
r_char
op_star
)paren
op_star
id|string
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|dwim_ref
r_int
id|dwim_ref
c_func
(paren
r_const
r_char
op_star
id|str
comma
r_int
id|len
comma
r_int
r_char
op_star
id|sha1
comma
r_char
op_star
op_star
id|ref
)paren
(brace
r_char
op_star
id|last_branch
op_assign
id|substitute_branch_name
c_func
(paren
op_amp
id|str
comma
op_amp
id|len
)paren
suffix:semicolon
r_const
r_char
op_star
op_star
id|p
comma
op_star
id|r
suffix:semicolon
r_int
id|refs_found
op_assign
l_int|0
suffix:semicolon
op_star
id|ref
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|ref_rev_parse_rules
suffix:semicolon
op_star
id|p
suffix:semicolon
id|p
op_increment
)paren
(brace
r_char
id|fullref
(braket
id|PATH_MAX
)braket
suffix:semicolon
r_int
r_char
id|sha1_from_ref
(braket
l_int|20
)braket
suffix:semicolon
r_int
r_char
op_star
id|this_result
suffix:semicolon
r_int
id|flag
suffix:semicolon
id|this_result
op_assign
id|refs_found
ques
c_cond
id|sha1_from_ref
suffix:colon
id|sha1
suffix:semicolon
id|mksnpath
c_func
(paren
id|fullref
comma
r_sizeof
(paren
id|fullref
)paren
comma
op_star
id|p
comma
id|len
comma
id|str
)paren
suffix:semicolon
id|r
op_assign
id|resolve_ref_unsafe
c_func
(paren
id|fullref
comma
id|RESOLVE_REF_READING
comma
id|this_result
comma
op_amp
id|flag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|refs_found
op_increment
)paren
op_star
id|ref
op_assign
id|xstrdup
c_func
(paren
id|r
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|warn_ambiguous_refs
)paren
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|flag
op_amp
id|REF_ISSYMREF
)paren
op_logical_and
id|strcmp
c_func
(paren
id|fullref
comma
l_string|&quot;HEAD&quot;
)paren
)paren
(brace
id|warning
c_func
(paren
l_string|&quot;ignoring dangling symref %s.&quot;
comma
id|fullref
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|flag
op_amp
id|REF_ISBROKEN
)paren
op_logical_and
id|strchr
c_func
(paren
id|fullref
comma
l_char|&squot;/&squot;
)paren
)paren
(brace
id|warning
c_func
(paren
l_string|&quot;ignoring broken ref %s.&quot;
comma
id|fullref
)paren
suffix:semicolon
)brace
)brace
id|free
c_func
(paren
id|last_branch
)paren
suffix:semicolon
r_return
id|refs_found
suffix:semicolon
)brace
DECL|function|dwim_log
r_int
id|dwim_log
c_func
(paren
r_const
r_char
op_star
id|str
comma
r_int
id|len
comma
r_int
r_char
op_star
id|sha1
comma
r_char
op_star
op_star
id|log
)paren
(brace
r_char
op_star
id|last_branch
op_assign
id|substitute_branch_name
c_func
(paren
op_amp
id|str
comma
op_amp
id|len
)paren
suffix:semicolon
r_const
r_char
op_star
op_star
id|p
suffix:semicolon
r_int
id|logs_found
op_assign
l_int|0
suffix:semicolon
op_star
id|log
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|ref_rev_parse_rules
suffix:semicolon
op_star
id|p
suffix:semicolon
id|p
op_increment
)paren
(brace
r_int
r_char
id|hash
(braket
l_int|20
)braket
suffix:semicolon
r_char
id|path
(braket
id|PATH_MAX
)braket
suffix:semicolon
r_const
r_char
op_star
id|ref
comma
op_star
id|it
suffix:semicolon
id|mksnpath
c_func
(paren
id|path
comma
r_sizeof
(paren
id|path
)paren
comma
op_star
id|p
comma
id|len
comma
id|str
)paren
suffix:semicolon
id|ref
op_assign
id|resolve_ref_unsafe
c_func
(paren
id|path
comma
id|RESOLVE_REF_READING
comma
id|hash
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ref
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|reflog_exists
c_func
(paren
id|path
)paren
)paren
id|it
op_assign
id|path
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|ref
comma
id|path
)paren
op_logical_and
id|reflog_exists
c_func
(paren
id|ref
)paren
)paren
id|it
op_assign
id|ref
suffix:semicolon
r_else
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|logs_found
op_increment
)paren
(brace
op_star
id|log
op_assign
id|xstrdup
c_func
(paren
id|it
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|sha1
comma
id|hash
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|warn_ambiguous_refs
)paren
r_break
suffix:semicolon
)brace
id|free
c_func
(paren
id|last_branch
)paren
suffix:semicolon
r_return
id|logs_found
suffix:semicolon
)brace
DECL|function|is_per_worktree_ref
r_static
r_int
id|is_per_worktree_ref
c_func
(paren
r_const
r_char
op_star
id|refname
)paren
(brace
r_return
op_logical_neg
id|strcmp
c_func
(paren
id|refname
comma
l_string|&quot;HEAD&quot;
)paren
op_logical_or
id|starts_with
c_func
(paren
id|refname
comma
l_string|&quot;refs/bisect/&quot;
)paren
suffix:semicolon
)brace
DECL|function|is_pseudoref_syntax
r_static
r_int
id|is_pseudoref_syntax
c_func
(paren
r_const
r_char
op_star
id|refname
)paren
(brace
r_const
r_char
op_star
id|c
suffix:semicolon
r_for
c_loop
(paren
id|c
op_assign
id|refname
suffix:semicolon
op_star
id|c
suffix:semicolon
id|c
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|isupper
c_func
(paren
op_star
id|c
)paren
op_logical_and
op_star
id|c
op_ne
l_char|&squot;-&squot;
op_logical_and
op_star
id|c
op_ne
l_char|&squot;_&squot;
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|ref_type
r_enum
id|ref_type
id|ref_type
c_func
(paren
r_const
r_char
op_star
id|refname
)paren
(brace
r_if
c_cond
(paren
id|is_per_worktree_ref
c_func
(paren
id|refname
)paren
)paren
r_return
id|REF_TYPE_PER_WORKTREE
suffix:semicolon
r_if
c_cond
(paren
id|is_pseudoref_syntax
c_func
(paren
id|refname
)paren
)paren
r_return
id|REF_TYPE_PSEUDOREF
suffix:semicolon
r_return
id|REF_TYPE_NORMAL
suffix:semicolon
)brace
DECL|function|write_pseudoref
r_static
r_int
id|write_pseudoref
c_func
(paren
r_const
r_char
op_star
id|pseudoref
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_const
r_int
r_char
op_star
id|old_sha1
comma
r_struct
id|strbuf
op_star
id|err
)paren
(brace
r_const
r_char
op_star
id|filename
suffix:semicolon
r_int
id|fd
suffix:semicolon
r_static
r_struct
id|lock_file
id|lock
suffix:semicolon
r_struct
id|strbuf
id|buf
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|ret
op_assign
l_int|1
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
id|buf
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
id|filename
op_assign
id|git_path
c_func
(paren
l_string|&quot;%s&quot;
comma
id|pseudoref
)paren
suffix:semicolon
id|fd
op_assign
id|hold_lock_file_for_update
c_func
(paren
op_amp
id|lock
comma
id|filename
comma
id|LOCK_DIE_ON_ERROR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
(brace
id|strbuf_addf
c_func
(paren
id|err
comma
l_string|&quot;Could not open &squot;%s&squot; for writing: %s&quot;
comma
id|filename
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|old_sha1
)paren
(brace
r_int
r_char
id|actual_old_sha1
(braket
l_int|20
)braket
suffix:semicolon
r_if
c_cond
(paren
id|read_ref
c_func
(paren
id|pseudoref
comma
id|actual_old_sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;could not read ref &squot;%s&squot;&quot;
comma
id|pseudoref
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hashcmp
c_func
(paren
id|actual_old_sha1
comma
id|old_sha1
)paren
)paren
(brace
id|strbuf_addf
c_func
(paren
id|err
comma
l_string|&quot;Unexpected sha1 when writing %s&quot;
comma
id|pseudoref
)paren
suffix:semicolon
id|rollback_lock_file
c_func
(paren
op_amp
id|lock
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|write_in_full
c_func
(paren
id|fd
comma
id|buf.buf
comma
id|buf.len
)paren
op_ne
id|buf.len
)paren
(brace
id|strbuf_addf
c_func
(paren
id|err
comma
l_string|&quot;Could not write to &squot;%s&squot;&quot;
comma
id|filename
)paren
suffix:semicolon
id|rollback_lock_file
c_func
(paren
op_amp
id|lock
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|commit_lock_file
c_func
(paren
op_amp
id|lock
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
id|done
suffix:colon
id|strbuf_release
c_func
(paren
op_amp
id|buf
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|delete_pseudoref
r_static
r_int
id|delete_pseudoref
c_func
(paren
r_const
r_char
op_star
id|pseudoref
comma
r_const
r_int
r_char
op_star
id|old_sha1
)paren
(brace
r_static
r_struct
id|lock_file
id|lock
suffix:semicolon
r_const
r_char
op_star
id|filename
suffix:semicolon
id|filename
op_assign
id|git_path
c_func
(paren
l_string|&quot;%s&quot;
comma
id|pseudoref
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old_sha1
op_logical_and
op_logical_neg
id|is_null_sha1
c_func
(paren
id|old_sha1
)paren
)paren
(brace
r_int
id|fd
suffix:semicolon
r_int
r_char
id|actual_old_sha1
(braket
l_int|20
)braket
suffix:semicolon
id|fd
op_assign
id|hold_lock_file_for_update
c_func
(paren
op_amp
id|lock
comma
id|filename
comma
id|LOCK_DIE_ON_ERROR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
id|die_errno
c_func
(paren
id|_
c_func
(paren
l_string|&quot;Could not open &squot;%s&squot; for writing&quot;
)paren
comma
id|filename
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_ref
c_func
(paren
id|pseudoref
comma
id|actual_old_sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;could not read ref &squot;%s&squot;&quot;
comma
id|pseudoref
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hashcmp
c_func
(paren
id|actual_old_sha1
comma
id|old_sha1
)paren
)paren
(brace
id|warning
c_func
(paren
l_string|&quot;Unexpected sha1 when deleting %s&quot;
comma
id|pseudoref
)paren
suffix:semicolon
id|rollback_lock_file
c_func
(paren
op_amp
id|lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|unlink
c_func
(paren
id|filename
)paren
suffix:semicolon
id|rollback_lock_file
c_func
(paren
op_amp
id|lock
)paren
suffix:semicolon
)brace
r_else
(brace
id|unlink
c_func
(paren
id|filename
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|delete_ref
r_int
id|delete_ref
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_const
r_int
r_char
op_star
id|old_sha1
comma
r_int
r_int
id|flags
)paren
(brace
r_struct
id|ref_transaction
op_star
id|transaction
suffix:semicolon
r_struct
id|strbuf
id|err
op_assign
id|STRBUF_INIT
suffix:semicolon
r_if
c_cond
(paren
id|ref_type
c_func
(paren
id|refname
)paren
op_eq
id|REF_TYPE_PSEUDOREF
)paren
r_return
id|delete_pseudoref
c_func
(paren
id|refname
comma
id|old_sha1
)paren
suffix:semicolon
id|transaction
op_assign
id|ref_transaction_begin
c_func
(paren
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|transaction
op_logical_or
id|ref_transaction_delete
c_func
(paren
id|transaction
comma
id|refname
comma
id|old_sha1
comma
id|flags
comma
l_int|NULL
comma
op_amp
id|err
)paren
op_logical_or
id|ref_transaction_commit
c_func
(paren
id|transaction
comma
op_amp
id|err
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;%s&quot;
comma
id|err.buf
)paren
suffix:semicolon
id|ref_transaction_free
c_func
(paren
id|transaction
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|err
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|ref_transaction_free
c_func
(paren
id|transaction
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|err
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|copy_reflog_msg
r_int
id|copy_reflog_msg
c_func
(paren
r_char
op_star
id|buf
comma
r_const
r_char
op_star
id|msg
)paren
(brace
r_char
op_star
id|cp
op_assign
id|buf
suffix:semicolon
r_char
id|c
suffix:semicolon
r_int
id|wasspace
op_assign
l_int|1
suffix:semicolon
op_star
id|cp
op_increment
op_assign
l_char|&squot;&bslash;t&squot;
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
op_star
id|msg
op_increment
)paren
)paren
(brace
r_if
c_cond
(paren
id|wasspace
op_logical_and
id|isspace
c_func
(paren
id|c
)paren
)paren
r_continue
suffix:semicolon
id|wasspace
op_assign
id|isspace
c_func
(paren
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wasspace
)paren
id|c
op_assign
l_char|&squot; &squot;
suffix:semicolon
op_star
id|cp
op_increment
op_assign
id|c
suffix:semicolon
)brace
r_while
c_loop
(paren
id|buf
OL
id|cp
op_logical_and
id|isspace
c_func
(paren
id|cp
(braket
l_int|1
)braket
)paren
)paren
id|cp
op_decrement
suffix:semicolon
op_star
id|cp
op_increment
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
r_return
id|cp
id|buf
suffix:semicolon
)brace
DECL|function|should_autocreate_reflog
r_int
id|should_autocreate_reflog
c_func
(paren
r_const
r_char
op_star
id|refname
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|log_all_ref_updates
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|starts_with
c_func
(paren
id|refname
comma
l_string|&quot;refs/heads/&quot;
)paren
op_logical_or
id|starts_with
c_func
(paren
id|refname
comma
l_string|&quot;refs/remotes/&quot;
)paren
op_logical_or
id|starts_with
c_func
(paren
id|refname
comma
l_string|&quot;refs/notes/&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|refname
comma
l_string|&quot;HEAD&quot;
)paren
suffix:semicolon
)brace
DECL|function|is_branch
r_int
id|is_branch
c_func
(paren
r_const
r_char
op_star
id|refname
)paren
(brace
r_return
op_logical_neg
id|strcmp
c_func
(paren
id|refname
comma
l_string|&quot;HEAD&quot;
)paren
op_logical_or
id|starts_with
c_func
(paren
id|refname
comma
l_string|&quot;refs/heads/&quot;
)paren
suffix:semicolon
)brace
DECL|struct|read_ref_at_cb
r_struct
id|read_ref_at_cb
(brace
DECL|member|refname
r_const
r_char
op_star
id|refname
suffix:semicolon
DECL|member|at_time
r_int
r_int
id|at_time
suffix:semicolon
DECL|member|cnt
r_int
id|cnt
suffix:semicolon
DECL|member|reccnt
r_int
id|reccnt
suffix:semicolon
DECL|member|sha1
r_int
r_char
op_star
id|sha1
suffix:semicolon
DECL|member|found_it
r_int
id|found_it
suffix:semicolon
DECL|member|osha1
r_int
r_char
id|osha1
(braket
l_int|20
)braket
suffix:semicolon
DECL|member|nsha1
r_int
r_char
id|nsha1
(braket
l_int|20
)braket
suffix:semicolon
DECL|member|tz
r_int
id|tz
suffix:semicolon
DECL|member|date
r_int
r_int
id|date
suffix:semicolon
DECL|member|msg
r_char
op_star
op_star
id|msg
suffix:semicolon
DECL|member|cutoff_time
r_int
r_int
op_star
id|cutoff_time
suffix:semicolon
DECL|member|cutoff_tz
r_int
op_star
id|cutoff_tz
suffix:semicolon
DECL|member|cutoff_cnt
r_int
op_star
id|cutoff_cnt
suffix:semicolon
)brace
suffix:semicolon
DECL|function|read_ref_at_ent
r_static
r_int
id|read_ref_at_ent
c_func
(paren
r_int
r_char
op_star
id|osha1
comma
r_int
r_char
op_star
id|nsha1
comma
r_const
r_char
op_star
id|email
comma
r_int
r_int
id|timestamp
comma
r_int
id|tz
comma
r_const
r_char
op_star
id|message
comma
r_void
op_star
id|cb_data
)paren
(brace
r_struct
id|read_ref_at_cb
op_star
id|cb
op_assign
id|cb_data
suffix:semicolon
id|cb-&gt;reccnt
op_increment
suffix:semicolon
id|cb-&gt;tz
op_assign
id|tz
suffix:semicolon
id|cb-&gt;date
op_assign
id|timestamp
suffix:semicolon
r_if
c_cond
(paren
id|timestamp
op_le
id|cb-&gt;at_time
op_logical_or
id|cb-&gt;cnt
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|cb-&gt;msg
)paren
op_star
id|cb-&gt;msg
op_assign
id|xstrdup
c_func
(paren
id|message
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cb-&gt;cutoff_time
)paren
op_star
id|cb-&gt;cutoff_time
op_assign
id|timestamp
suffix:semicolon
r_if
c_cond
(paren
id|cb-&gt;cutoff_tz
)paren
op_star
id|cb-&gt;cutoff_tz
op_assign
id|tz
suffix:semicolon
r_if
c_cond
(paren
id|cb-&gt;cutoff_cnt
)paren
op_star
id|cb-&gt;cutoff_cnt
op_assign
id|cb-&gt;reccnt
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * we have not yet updated cb-&gt;[n|o]sha1 so they still&n;&t;&t; * hold the values for the previous record.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|is_null_sha1
c_func
(paren
id|cb-&gt;osha1
)paren
)paren
(brace
id|hashcpy
c_func
(paren
id|cb-&gt;sha1
comma
id|nsha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hashcmp
c_func
(paren
id|cb-&gt;osha1
comma
id|nsha1
)paren
)paren
id|warning
c_func
(paren
l_string|&quot;Log for ref %s has gap after %s.&quot;
comma
id|cb-&gt;refname
comma
id|show_date
c_func
(paren
id|cb-&gt;date
comma
id|cb-&gt;tz
comma
id|DATE_MODE
c_func
(paren
id|RFC2822
)paren
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cb-&gt;date
op_eq
id|cb-&gt;at_time
)paren
id|hashcpy
c_func
(paren
id|cb-&gt;sha1
comma
id|nsha1
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|hashcmp
c_func
(paren
id|nsha1
comma
id|cb-&gt;sha1
)paren
)paren
id|warning
c_func
(paren
l_string|&quot;Log for ref %s unexpectedly ended on %s.&quot;
comma
id|cb-&gt;refname
comma
id|show_date
c_func
(paren
id|cb-&gt;date
comma
id|cb-&gt;tz
comma
id|DATE_MODE
c_func
(paren
id|RFC2822
)paren
)paren
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|cb-&gt;osha1
comma
id|osha1
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|cb-&gt;nsha1
comma
id|nsha1
)paren
suffix:semicolon
id|cb-&gt;found_it
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|hashcpy
c_func
(paren
id|cb-&gt;osha1
comma
id|osha1
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|cb-&gt;nsha1
comma
id|nsha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cb-&gt;cnt
OG
l_int|0
)paren
id|cb-&gt;cnt
op_decrement
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|read_ref_at_ent_oldest
r_static
r_int
id|read_ref_at_ent_oldest
c_func
(paren
r_int
r_char
op_star
id|osha1
comma
r_int
r_char
op_star
id|nsha1
comma
r_const
r_char
op_star
id|email
comma
r_int
r_int
id|timestamp
comma
r_int
id|tz
comma
r_const
r_char
op_star
id|message
comma
r_void
op_star
id|cb_data
)paren
(brace
r_struct
id|read_ref_at_cb
op_star
id|cb
op_assign
id|cb_data
suffix:semicolon
r_if
c_cond
(paren
id|cb-&gt;msg
)paren
op_star
id|cb-&gt;msg
op_assign
id|xstrdup
c_func
(paren
id|message
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cb-&gt;cutoff_time
)paren
op_star
id|cb-&gt;cutoff_time
op_assign
id|timestamp
suffix:semicolon
r_if
c_cond
(paren
id|cb-&gt;cutoff_tz
)paren
op_star
id|cb-&gt;cutoff_tz
op_assign
id|tz
suffix:semicolon
r_if
c_cond
(paren
id|cb-&gt;cutoff_cnt
)paren
op_star
id|cb-&gt;cutoff_cnt
op_assign
id|cb-&gt;reccnt
suffix:semicolon
id|hashcpy
c_func
(paren
id|cb-&gt;sha1
comma
id|osha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_null_sha1
c_func
(paren
id|cb-&gt;sha1
)paren
)paren
id|hashcpy
c_func
(paren
id|cb-&gt;sha1
comma
id|nsha1
)paren
suffix:semicolon
multiline_comment|/* We just want the first entry */
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|read_ref_at
r_int
id|read_ref_at
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_int
r_int
id|flags
comma
r_int
r_int
id|at_time
comma
r_int
id|cnt
comma
r_int
r_char
op_star
id|sha1
comma
r_char
op_star
op_star
id|msg
comma
r_int
r_int
op_star
id|cutoff_time
comma
r_int
op_star
id|cutoff_tz
comma
r_int
op_star
id|cutoff_cnt
)paren
(brace
r_struct
id|read_ref_at_cb
id|cb
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|cb
comma
l_int|0
comma
r_sizeof
(paren
id|cb
)paren
)paren
suffix:semicolon
id|cb.refname
op_assign
id|refname
suffix:semicolon
id|cb.at_time
op_assign
id|at_time
suffix:semicolon
id|cb.cnt
op_assign
id|cnt
suffix:semicolon
id|cb.msg
op_assign
id|msg
suffix:semicolon
id|cb.cutoff_time
op_assign
id|cutoff_time
suffix:semicolon
id|cb.cutoff_tz
op_assign
id|cutoff_tz
suffix:semicolon
id|cb.cutoff_cnt
op_assign
id|cutoff_cnt
suffix:semicolon
id|cb.sha1
op_assign
id|sha1
suffix:semicolon
id|for_each_reflog_ent_reverse
c_func
(paren
id|refname
comma
id|read_ref_at_ent
comma
op_amp
id|cb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cb.reccnt
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|GET_SHA1_QUIETLY
)paren
m_exit
(paren
l_int|128
)paren
suffix:semicolon
r_else
id|die
c_func
(paren
l_string|&quot;Log for %s is empty.&quot;
comma
id|refname
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cb.found_it
)paren
r_return
l_int|0
suffix:semicolon
id|for_each_reflog_ent
c_func
(paren
id|refname
comma
id|read_ref_at_ent_oldest
comma
op_amp
id|cb
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|ref_transaction_begin
r_struct
id|ref_transaction
op_star
id|ref_transaction_begin
c_func
(paren
r_struct
id|strbuf
op_star
id|err
)paren
(brace
m_assert
(paren
id|err
)paren
suffix:semicolon
r_return
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|ref_transaction
)paren
)paren
suffix:semicolon
)brace
DECL|function|ref_transaction_free
r_void
id|ref_transaction_free
c_func
(paren
r_struct
id|ref_transaction
op_star
id|transaction
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|transaction
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|transaction-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
id|free
c_func
(paren
id|transaction-&gt;updates
(braket
id|i
)braket
op_member_access_from_pointer
id|msg
)paren
suffix:semicolon
id|free
c_func
(paren
id|transaction-&gt;updates
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|free
c_func
(paren
id|transaction-&gt;updates
)paren
suffix:semicolon
id|free
c_func
(paren
id|transaction
)paren
suffix:semicolon
)brace
DECL|function|add_update
r_static
r_struct
id|ref_update
op_star
id|add_update
c_func
(paren
r_struct
id|ref_transaction
op_star
id|transaction
comma
r_const
r_char
op_star
id|refname
)paren
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|refname
)paren
op_plus
l_int|1
suffix:semicolon
r_struct
id|ref_update
op_star
id|update
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|update
)paren
op_plus
id|len
)paren
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_char
op_star
)paren
id|update-&gt;refname
comma
id|refname
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* includes NUL */
id|ALLOC_GROW
c_func
(paren
id|transaction-&gt;updates
comma
id|transaction-&gt;nr
op_plus
l_int|1
comma
id|transaction-&gt;alloc
)paren
suffix:semicolon
id|transaction-&gt;updates
(braket
id|transaction-&gt;nr
op_increment
)braket
op_assign
id|update
suffix:semicolon
r_return
id|update
suffix:semicolon
)brace
DECL|function|ref_transaction_update
r_int
id|ref_transaction_update
c_func
(paren
r_struct
id|ref_transaction
op_star
id|transaction
comma
r_const
r_char
op_star
id|refname
comma
r_const
r_int
r_char
op_star
id|new_sha1
comma
r_const
r_int
r_char
op_star
id|old_sha1
comma
r_int
r_int
id|flags
comma
r_const
r_char
op_star
id|msg
comma
r_struct
id|strbuf
op_star
id|err
)paren
(brace
r_struct
id|ref_update
op_star
id|update
suffix:semicolon
m_assert
(paren
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|transaction-&gt;state
op_ne
id|REF_TRANSACTION_OPEN
)paren
id|die
c_func
(paren
l_string|&quot;BUG: update called for transaction that is not open&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_sha1
op_logical_and
op_logical_neg
id|is_null_sha1
c_func
(paren
id|new_sha1
)paren
op_logical_and
id|check_refname_format
c_func
(paren
id|refname
comma
id|REFNAME_ALLOW_ONELEVEL
)paren
)paren
(brace
id|strbuf_addf
c_func
(paren
id|err
comma
l_string|&quot;refusing to update ref with bad name %s&quot;
comma
id|refname
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|update
op_assign
id|add_update
c_func
(paren
id|transaction
comma
id|refname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_sha1
)paren
(brace
id|hashcpy
c_func
(paren
id|update-&gt;new_sha1
comma
id|new_sha1
)paren
suffix:semicolon
id|flags
op_or_assign
id|REF_HAVE_NEW
suffix:semicolon
)brace
r_if
c_cond
(paren
id|old_sha1
)paren
(brace
id|hashcpy
c_func
(paren
id|update-&gt;old_sha1
comma
id|old_sha1
)paren
suffix:semicolon
id|flags
op_or_assign
id|REF_HAVE_OLD
suffix:semicolon
)brace
id|update-&gt;flags
op_assign
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|msg
)paren
id|update-&gt;msg
op_assign
id|xstrdup
c_func
(paren
id|msg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ref_transaction_create
r_int
id|ref_transaction_create
c_func
(paren
r_struct
id|ref_transaction
op_star
id|transaction
comma
r_const
r_char
op_star
id|refname
comma
r_const
r_int
r_char
op_star
id|new_sha1
comma
r_int
r_int
id|flags
comma
r_const
r_char
op_star
id|msg
comma
r_struct
id|strbuf
op_star
id|err
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|new_sha1
op_logical_or
id|is_null_sha1
c_func
(paren
id|new_sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;BUG: create called without valid new_sha1&quot;
)paren
suffix:semicolon
r_return
id|ref_transaction_update
c_func
(paren
id|transaction
comma
id|refname
comma
id|new_sha1
comma
id|null_sha1
comma
id|flags
comma
id|msg
comma
id|err
)paren
suffix:semicolon
)brace
DECL|function|ref_transaction_delete
r_int
id|ref_transaction_delete
c_func
(paren
r_struct
id|ref_transaction
op_star
id|transaction
comma
r_const
r_char
op_star
id|refname
comma
r_const
r_int
r_char
op_star
id|old_sha1
comma
r_int
r_int
id|flags
comma
r_const
r_char
op_star
id|msg
comma
r_struct
id|strbuf
op_star
id|err
)paren
(brace
r_if
c_cond
(paren
id|old_sha1
op_logical_and
id|is_null_sha1
c_func
(paren
id|old_sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;BUG: delete called with old_sha1 set to zeros&quot;
)paren
suffix:semicolon
r_return
id|ref_transaction_update
c_func
(paren
id|transaction
comma
id|refname
comma
id|null_sha1
comma
id|old_sha1
comma
id|flags
comma
id|msg
comma
id|err
)paren
suffix:semicolon
)brace
DECL|function|ref_transaction_verify
r_int
id|ref_transaction_verify
c_func
(paren
r_struct
id|ref_transaction
op_star
id|transaction
comma
r_const
r_char
op_star
id|refname
comma
r_const
r_int
r_char
op_star
id|old_sha1
comma
r_int
r_int
id|flags
comma
r_struct
id|strbuf
op_star
id|err
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|old_sha1
)paren
id|die
c_func
(paren
l_string|&quot;BUG: verify called with old_sha1 set to NULL&quot;
)paren
suffix:semicolon
r_return
id|ref_transaction_update
c_func
(paren
id|transaction
comma
id|refname
comma
l_int|NULL
comma
id|old_sha1
comma
id|flags
comma
l_int|NULL
comma
id|err
)paren
suffix:semicolon
)brace
DECL|function|update_ref
r_int
id|update_ref
c_func
(paren
r_const
r_char
op_star
id|msg
comma
r_const
r_char
op_star
id|refname
comma
r_const
r_int
r_char
op_star
id|new_sha1
comma
r_const
r_int
r_char
op_star
id|old_sha1
comma
r_int
r_int
id|flags
comma
r_enum
id|action_on_err
id|onerr
)paren
(brace
r_struct
id|ref_transaction
op_star
id|t
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|strbuf
id|err
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ref_type
c_func
(paren
id|refname
)paren
op_eq
id|REF_TYPE_PSEUDOREF
)paren
(brace
id|ret
op_assign
id|write_pseudoref
c_func
(paren
id|refname
comma
id|new_sha1
comma
id|old_sha1
comma
op_amp
id|err
)paren
suffix:semicolon
)brace
r_else
(brace
id|t
op_assign
id|ref_transaction_begin
c_func
(paren
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|t
op_logical_or
id|ref_transaction_update
c_func
(paren
id|t
comma
id|refname
comma
id|new_sha1
comma
id|old_sha1
comma
id|flags
comma
id|msg
comma
op_amp
id|err
)paren
op_logical_or
id|ref_transaction_commit
c_func
(paren
id|t
comma
op_amp
id|err
)paren
)paren
(brace
id|ret
op_assign
l_int|1
suffix:semicolon
id|ref_transaction_free
c_func
(paren
id|t
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ret
)paren
(brace
r_const
r_char
op_star
id|str
op_assign
l_string|&quot;update_ref failed for ref &squot;%s&squot;: %s&quot;
suffix:semicolon
r_switch
c_cond
(paren
id|onerr
)paren
(brace
r_case
id|UPDATE_REFS_MSG_ON_ERR
suffix:colon
id|error
c_func
(paren
id|str
comma
id|refname
comma
id|err.buf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UPDATE_REFS_DIE_ON_ERR
suffix:colon
id|die
c_func
(paren
id|str
comma
id|refname
comma
id|err.buf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UPDATE_REFS_QUIET_ON_ERR
suffix:colon
r_break
suffix:semicolon
)brace
id|strbuf_release
c_func
(paren
op_amp
id|err
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|strbuf_release
c_func
(paren
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
)paren
id|ref_transaction_free
c_func
(paren
id|t
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|shorten_unambiguous_ref
r_char
op_star
id|shorten_unambiguous_ref
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_int
id|strict
)paren
(brace
r_int
id|i
suffix:semicolon
r_static
r_char
op_star
op_star
id|scanf_fmts
suffix:semicolon
r_static
r_int
id|nr_rules
suffix:semicolon
r_char
op_star
id|short_name
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nr_rules
)paren
(brace
multiline_comment|/*&n;&t;&t; * Pre-generate scanf formats from ref_rev_parse_rules[].&n;&t;&t; * Generate a format suitable for scanf from a&n;&t;&t; * ref_rev_parse_rules rule by interpolating &quot;%s&quot; at the&n;&t;&t; * location of the &quot;%.*s&quot;.&n;&t;&t; */
r_int
id|total_len
op_assign
l_int|0
suffix:semicolon
r_int
id|offset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* the rule list is NULL terminated, count them first */
r_for
c_loop
(paren
id|nr_rules
op_assign
l_int|0
suffix:semicolon
id|ref_rev_parse_rules
(braket
id|nr_rules
)braket
suffix:semicolon
id|nr_rules
op_increment
)paren
multiline_comment|/* -2 for strlen(&quot;%.*s&quot;) - strlen(&quot;%s&quot;); +1 for NUL */
id|total_len
op_add_assign
id|strlen
c_func
(paren
id|ref_rev_parse_rules
(braket
id|nr_rules
)braket
)paren
l_int|2
op_plus
l_int|1
suffix:semicolon
id|scanf_fmts
op_assign
id|xmalloc
c_func
(paren
id|nr_rules
op_star
r_sizeof
(paren
r_char
op_star
)paren
op_plus
id|total_len
)paren
suffix:semicolon
id|offset
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_rules
suffix:semicolon
id|i
op_increment
)paren
(brace
m_assert
(paren
id|offset
OL
id|total_len
)paren
suffix:semicolon
id|scanf_fmts
(braket
id|i
)braket
op_assign
(paren
r_char
op_star
)paren
op_amp
id|scanf_fmts
(braket
id|nr_rules
)braket
op_plus
id|offset
suffix:semicolon
id|offset
op_add_assign
id|snprintf
c_func
(paren
id|scanf_fmts
(braket
id|i
)braket
comma
id|total_len
id|offset
comma
id|ref_rev_parse_rules
(braket
id|i
)braket
comma
l_int|2
comma
l_string|&quot;%s&quot;
)paren
op_plus
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* bail out if there are no rules */
r_if
c_cond
(paren
op_logical_neg
id|nr_rules
)paren
r_return
id|xstrdup
c_func
(paren
id|refname
)paren
suffix:semicolon
multiline_comment|/* buffer for scanf result, at most refname must fit */
id|short_name
op_assign
id|xstrdup
c_func
(paren
id|refname
)paren
suffix:semicolon
multiline_comment|/* skip first rule, it will always match */
r_for
c_loop
(paren
id|i
op_assign
id|nr_rules
l_int|1
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
op_decrement
id|i
)paren
(brace
r_int
id|j
suffix:semicolon
r_int
id|rules_to_fail
op_assign
id|i
suffix:semicolon
r_int
id|short_name_len
suffix:semicolon
r_if
c_cond
(paren
l_int|1
op_ne
id|sscanf
c_func
(paren
id|refname
comma
id|scanf_fmts
(braket
id|i
)braket
comma
id|short_name
)paren
)paren
r_continue
suffix:semicolon
id|short_name_len
op_assign
id|strlen
c_func
(paren
id|short_name
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * in strict mode, all (except the matched one) rules&n;&t;&t; * must fail to resolve to a valid non-ambiguous ref&n;&t;&t; */
r_if
c_cond
(paren
id|strict
)paren
id|rules_to_fail
op_assign
id|nr_rules
suffix:semicolon
multiline_comment|/*&n;&t;&t; * check if the short name resolves to a valid ref,&n;&t;&t; * but use only rules prior to the matched one&n;&t;&t; */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|rules_to_fail
suffix:semicolon
id|j
op_increment
)paren
(brace
r_const
r_char
op_star
id|rule
op_assign
id|ref_rev_parse_rules
(braket
id|j
)braket
suffix:semicolon
r_char
id|refname
(braket
id|PATH_MAX
)braket
suffix:semicolon
multiline_comment|/* skip matched rule */
r_if
c_cond
(paren
id|i
op_eq
id|j
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * the short name is ambiguous, if it resolves&n;&t;&t;&t; * (with this previous rule) to a valid ref&n;&t;&t;&t; * read_ref() returns 0 on success&n;&t;&t;&t; */
id|mksnpath
c_func
(paren
id|refname
comma
r_sizeof
(paren
id|refname
)paren
comma
id|rule
comma
id|short_name_len
comma
id|short_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ref_exists
c_func
(paren
id|refname
)paren
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * short name is non-ambiguous if all previous rules&n;&t;&t; * haven&squot;t resolved to a valid ref&n;&t;&t; */
r_if
c_cond
(paren
id|j
op_eq
id|rules_to_fail
)paren
r_return
id|short_name
suffix:semicolon
)brace
id|free
c_func
(paren
id|short_name
)paren
suffix:semicolon
r_return
id|xstrdup
c_func
(paren
id|refname
)paren
suffix:semicolon
)brace
DECL|variable|hide_refs
r_static
r_struct
id|string_list
op_star
id|hide_refs
suffix:semicolon
DECL|function|parse_hide_refs_config
r_int
id|parse_hide_refs_config
c_func
(paren
r_const
r_char
op_star
id|var
comma
r_const
r_char
op_star
id|value
comma
r_const
r_char
op_star
id|section
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;transfer.hiderefs&quot;
comma
id|var
)paren
op_logical_or
multiline_comment|/* NEEDSWORK: use parse_config_key() once both are merged */
(paren
id|starts_with
c_func
(paren
id|var
comma
id|section
)paren
op_logical_and
id|var
(braket
id|strlen
c_func
(paren
id|section
)paren
)braket
op_eq
l_char|&squot;.&squot;
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|var
op_plus
id|strlen
c_func
(paren
id|section
)paren
comma
l_string|&quot;.hiderefs&quot;
)paren
)paren
)paren
(brace
r_char
op_star
id|ref
suffix:semicolon
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
r_return
id|config_error_nonbool
c_func
(paren
id|var
)paren
suffix:semicolon
id|ref
op_assign
id|xstrdup
c_func
(paren
id|value
)paren
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|ref
)paren
suffix:semicolon
r_while
c_loop
(paren
id|len
op_logical_and
id|ref
(braket
id|len
l_int|1
)braket
op_eq
l_char|&squot;/&squot;
)paren
id|ref
(braket
op_decrement
id|len
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hide_refs
)paren
(brace
id|hide_refs
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|hide_refs
)paren
)paren
suffix:semicolon
id|hide_refs-&gt;strdup_strings
op_assign
l_int|1
suffix:semicolon
)brace
id|string_list_append
c_func
(paren
id|hide_refs
comma
id|ref
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ref_is_hidden
r_int
id|ref_is_hidden
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_const
r_char
op_star
id|refname_full
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hide_refs
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|hide_refs-&gt;nr
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_const
r_char
op_star
id|match
op_assign
id|hide_refs-&gt;items
(braket
id|i
)braket
dot
id|string
suffix:semicolon
r_const
r_char
op_star
id|subject
suffix:semicolon
r_int
id|neg
op_assign
l_int|0
suffix:semicolon
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
op_star
id|match
op_eq
l_char|&squot;!&squot;
)paren
(brace
id|neg
op_assign
l_int|1
suffix:semicolon
id|match
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|match
op_eq
l_char|&squot;^&squot;
)paren
(brace
id|subject
op_assign
id|refname_full
suffix:semicolon
id|match
op_increment
suffix:semicolon
)brace
r_else
(brace
id|subject
op_assign
id|refname
suffix:semicolon
)brace
multiline_comment|/* refname can be NULL when namespaces are used. */
r_if
c_cond
(paren
op_logical_neg
id|subject
op_logical_or
op_logical_neg
id|starts_with
c_func
(paren
id|subject
comma
id|match
)paren
)paren
r_continue
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|match
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|subject
(braket
id|len
)braket
op_logical_or
id|subject
(braket
id|len
)braket
op_eq
l_char|&squot;/&squot;
)paren
r_return
op_logical_neg
id|neg
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|find_descendant_ref
r_const
r_char
op_star
id|find_descendant_ref
c_func
(paren
r_const
r_char
op_star
id|dirname
comma
r_const
r_struct
id|string_list
op_star
id|extras
comma
r_const
r_struct
id|string_list
op_star
id|skip
)paren
(brace
r_int
id|pos
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|extras
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Look at the place where dirname would be inserted into&n;&t; * extras. If there is an entry at that position that starts&n;&t; * with dirname (remember, dirname includes the trailing&n;&t; * slash) and is not in skip, then we have a conflict.&n;&t; */
r_for
c_loop
(paren
id|pos
op_assign
id|string_list_find_insert_index
c_func
(paren
id|extras
comma
id|dirname
comma
l_int|0
)paren
suffix:semicolon
id|pos
OL
id|extras-&gt;nr
suffix:semicolon
id|pos
op_increment
)paren
(brace
r_const
r_char
op_star
id|extra_refname
op_assign
id|extras-&gt;items
(braket
id|pos
)braket
dot
id|string
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|starts_with
c_func
(paren
id|extra_refname
comma
id|dirname
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skip
op_logical_or
op_logical_neg
id|string_list_has_string
c_func
(paren
id|skip
comma
id|extra_refname
)paren
)paren
r_return
id|extra_refname
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|rename_ref_available
r_int
id|rename_ref_available
c_func
(paren
r_const
r_char
op_star
id|oldname
comma
r_const
r_char
op_star
id|newname
)paren
(brace
r_struct
id|string_list
id|skip
op_assign
id|STRING_LIST_INIT_NODUP
suffix:semicolon
r_struct
id|strbuf
id|err
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|string_list_insert
c_func
(paren
op_amp
id|skip
comma
id|oldname
)paren
suffix:semicolon
id|ret
op_assign
op_logical_neg
id|verify_refname_available
c_func
(paren
id|newname
comma
l_int|NULL
comma
op_amp
id|skip
comma
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|error
c_func
(paren
l_string|&quot;%s&quot;
comma
id|err.buf
)paren
suffix:semicolon
id|string_list_clear
c_func
(paren
op_amp
id|skip
comma
l_int|0
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|err
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
eof
