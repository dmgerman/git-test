macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;delta.h&quot;
macro_line|#include &quot;pack.h&quot;
macro_line|#include &quot;csum-file.h&quot;
macro_line|#include &quot;blob.h&quot;
macro_line|#include &quot;commit.h&quot;
macro_line|#include &quot;tag.h&quot;
macro_line|#include &quot;tree.h&quot;
macro_line|#include &lt;sys/time.h&gt;
macro_line|#include &lt;signal.h&gt;
DECL|variable|index_pack_usage
r_static
r_const
r_char
id|index_pack_usage
(braket
)braket
op_assign
l_string|&quot;git-index-pack [-v] [-o &lt;index-file&gt;] [{ ---keep | --keep=&lt;msg&gt; }] { &lt;pack-file&gt; | --stdin [--fix-thin] [&lt;pack-file&gt;] }&quot;
suffix:semicolon
DECL|struct|object_entry
r_struct
id|object_entry
(brace
DECL|member|offset
r_int
r_int
id|offset
suffix:semicolon
DECL|member|size
r_int
r_int
id|size
suffix:semicolon
DECL|member|hdr_size
r_int
r_int
id|hdr_size
suffix:semicolon
DECL|member|type
r_enum
id|object_type
id|type
suffix:semicolon
DECL|member|real_type
r_enum
id|object_type
id|real_type
suffix:semicolon
DECL|member|sha1
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|union|delta_base
r_union
id|delta_base
(brace
DECL|member|sha1
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
DECL|member|offset
r_int
r_int
id|offset
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Even if sizeof(union delta_base) == 24 on 64-bit archs, we really want&n; * to memcmp() only the first 20 bytes.&n; */
DECL|macro|UNION_BASE_SZ
mdefine_line|#define UNION_BASE_SZ&t;20
DECL|struct|delta_entry
r_struct
id|delta_entry
(brace
DECL|member|base
r_union
id|delta_base
id|base
suffix:semicolon
DECL|member|obj_no
r_int
id|obj_no
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|objects
r_static
r_struct
id|object_entry
op_star
id|objects
suffix:semicolon
DECL|variable|deltas
r_static
r_struct
id|delta_entry
op_star
id|deltas
suffix:semicolon
DECL|variable|nr_objects
r_static
r_int
id|nr_objects
suffix:semicolon
DECL|variable|nr_deltas
r_static
r_int
id|nr_deltas
suffix:semicolon
DECL|variable|nr_resolved_deltas
r_static
r_int
id|nr_resolved_deltas
suffix:semicolon
DECL|variable|from_stdin
r_static
r_int
id|from_stdin
suffix:semicolon
DECL|variable|verbose
r_static
r_int
id|verbose
suffix:semicolon
DECL|variable|progress_update
r_static
r_volatile
id|sig_atomic_t
id|progress_update
suffix:semicolon
DECL|function|progress_interval
r_static
r_void
id|progress_interval
c_func
(paren
r_int
id|signum
)paren
(brace
id|progress_update
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|setup_progress_signal
r_static
r_void
id|setup_progress_signal
c_func
(paren
r_void
)paren
(brace
r_struct
id|sigaction
id|sa
suffix:semicolon
r_struct
id|itimerval
id|v
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|sa
comma
l_int|0
comma
r_sizeof
(paren
id|sa
)paren
)paren
suffix:semicolon
id|sa.sa_handler
op_assign
id|progress_interval
suffix:semicolon
id|sigemptyset
c_func
(paren
op_amp
id|sa.sa_mask
)paren
suffix:semicolon
id|sa.sa_flags
op_assign
id|SA_RESTART
suffix:semicolon
id|sigaction
c_func
(paren
id|SIGALRM
comma
op_amp
id|sa
comma
l_int|NULL
)paren
suffix:semicolon
id|v.it_interval.tv_sec
op_assign
l_int|1
suffix:semicolon
id|v.it_interval.tv_usec
op_assign
l_int|0
suffix:semicolon
id|v.it_value
op_assign
id|v.it_interval
suffix:semicolon
id|setitimer
c_func
(paren
id|ITIMER_REAL
comma
op_amp
id|v
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|display_progress
r_static
r_int
id|display_progress
c_func
(paren
r_int
id|n
comma
r_int
id|total
comma
r_int
id|last_pc
)paren
(brace
r_int
id|percent
op_assign
id|n
op_star
l_int|100
op_div
id|total
suffix:semicolon
r_if
c_cond
(paren
id|percent
op_ne
id|last_pc
op_logical_or
id|progress_update
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%4u%% (%u/%u) done&bslash;r&quot;
comma
id|percent
comma
id|n
comma
id|total
)paren
suffix:semicolon
id|progress_update
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|percent
suffix:semicolon
)brace
multiline_comment|/* We always read in 4kB chunks. */
DECL|variable|input_buffer
r_static
r_int
r_char
id|input_buffer
(braket
l_int|4096
)braket
suffix:semicolon
DECL|variable|input_offset
DECL|variable|input_len
DECL|variable|consumed_bytes
r_static
r_int
r_int
id|input_offset
comma
id|input_len
comma
id|consumed_bytes
suffix:semicolon
DECL|variable|input_ctx
r_static
id|SHA_CTX
id|input_ctx
suffix:semicolon
DECL|variable|input_fd
DECL|variable|output_fd
DECL|variable|mmap_fd
r_static
r_int
id|input_fd
comma
id|output_fd
comma
id|mmap_fd
suffix:semicolon
multiline_comment|/* Discard current buffer used content. */
DECL|function|flush
r_static
r_void
id|flush
c_func
(paren
)paren
(brace
r_if
c_cond
(paren
id|input_offset
)paren
(brace
r_if
c_cond
(paren
id|output_fd
op_ge
l_int|0
)paren
id|write_or_die
c_func
(paren
id|output_fd
comma
id|input_buffer
comma
id|input_offset
)paren
suffix:semicolon
id|SHA1_Update
c_func
(paren
op_amp
id|input_ctx
comma
id|input_buffer
comma
id|input_offset
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|input_buffer
comma
id|input_buffer
op_plus
id|input_offset
comma
id|input_len
)paren
suffix:semicolon
id|input_offset
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Make sure at least &quot;min&quot; bytes are available in the buffer, and&n; * return the pointer to the buffer.&n; */
DECL|function|fill
r_static
r_void
op_star
id|fill
c_func
(paren
r_int
id|min
)paren
(brace
r_if
c_cond
(paren
id|min
op_le
id|input_len
)paren
r_return
id|input_buffer
op_plus
id|input_offset
suffix:semicolon
r_if
c_cond
(paren
id|min
OG
r_sizeof
(paren
id|input_buffer
)paren
)paren
id|die
c_func
(paren
l_string|&quot;cannot fill %d bytes&quot;
comma
id|min
)paren
suffix:semicolon
id|flush
c_func
(paren
)paren
suffix:semicolon
r_do
(brace
r_int
id|ret
op_assign
id|xread
c_func
(paren
id|input_fd
comma
id|input_buffer
op_plus
id|input_len
comma
r_sizeof
(paren
id|input_buffer
)paren
id|input_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_le
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|die
c_func
(paren
l_string|&quot;early EOF&quot;
)paren
suffix:semicolon
id|die
c_func
(paren
l_string|&quot;read error on input: %s&quot;
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
)brace
id|input_len
op_add_assign
id|ret
suffix:semicolon
)brace
r_while
c_loop
(paren
id|input_len
OL
id|min
)paren
suffix:semicolon
r_return
id|input_buffer
suffix:semicolon
)brace
DECL|function|use
r_static
r_void
id|use
c_func
(paren
r_int
id|bytes
)paren
(brace
r_if
c_cond
(paren
id|bytes
OG
id|input_len
)paren
id|die
c_func
(paren
l_string|&quot;used more bytes than were available&quot;
)paren
suffix:semicolon
id|input_len
op_sub_assign
id|bytes
suffix:semicolon
id|input_offset
op_add_assign
id|bytes
suffix:semicolon
id|consumed_bytes
op_add_assign
id|bytes
suffix:semicolon
)brace
DECL|function|open_pack_file
r_static
r_const
r_char
op_star
id|open_pack_file
c_func
(paren
r_const
r_char
op_star
id|pack_name
)paren
(brace
r_if
c_cond
(paren
id|from_stdin
)paren
(brace
id|input_fd
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pack_name
)paren
(brace
r_static
r_char
id|tmpfile
(braket
id|PATH_MAX
)braket
suffix:semicolon
id|snprintf
c_func
(paren
id|tmpfile
comma
r_sizeof
(paren
id|tmpfile
)paren
comma
l_string|&quot;%s/pack_XXXXXX&quot;
comma
id|get_object_directory
c_func
(paren
)paren
)paren
suffix:semicolon
id|output_fd
op_assign
id|mkstemp
c_func
(paren
id|tmpfile
)paren
suffix:semicolon
id|pack_name
op_assign
id|xstrdup
c_func
(paren
id|tmpfile
)paren
suffix:semicolon
)brace
r_else
id|output_fd
op_assign
id|open
c_func
(paren
id|pack_name
comma
id|O_CREAT
op_or
id|O_EXCL
op_or
id|O_RDWR
comma
l_int|0600
)paren
suffix:semicolon
r_if
c_cond
(paren
id|output_fd
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;unable to create %s: %s&bslash;n&quot;
comma
id|pack_name
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
id|mmap_fd
op_assign
id|output_fd
suffix:semicolon
)brace
r_else
(brace
id|input_fd
op_assign
id|open
c_func
(paren
id|pack_name
comma
id|O_RDONLY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|input_fd
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;cannot open packfile &squot;%s&squot;: %s&quot;
comma
id|pack_name
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
id|output_fd
op_assign
l_int|1
suffix:semicolon
id|mmap_fd
op_assign
id|input_fd
suffix:semicolon
)brace
id|SHA1_Init
c_func
(paren
op_amp
id|input_ctx
)paren
suffix:semicolon
r_return
id|pack_name
suffix:semicolon
)brace
DECL|function|parse_pack_header
r_static
r_void
id|parse_pack_header
c_func
(paren
r_void
)paren
(brace
r_struct
id|pack_header
op_star
id|hdr
op_assign
id|fill
c_func
(paren
r_sizeof
(paren
r_struct
id|pack_header
)paren
)paren
suffix:semicolon
multiline_comment|/* Header consistency check */
r_if
c_cond
(paren
id|hdr-&gt;hdr_signature
op_ne
id|htonl
c_func
(paren
id|PACK_SIGNATURE
)paren
)paren
id|die
c_func
(paren
l_string|&quot;pack signature mismatch&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pack_version_ok
c_func
(paren
id|hdr-&gt;hdr_version
)paren
)paren
id|die
c_func
(paren
l_string|&quot;pack version %d unsupported&quot;
comma
id|ntohl
c_func
(paren
id|hdr-&gt;hdr_version
)paren
)paren
suffix:semicolon
id|nr_objects
op_assign
id|ntohl
c_func
(paren
id|hdr-&gt;hdr_entries
)paren
suffix:semicolon
id|use
c_func
(paren
r_sizeof
(paren
r_struct
id|pack_header
)paren
)paren
suffix:semicolon
)brace
r_static
r_void
id|bad_object
c_func
(paren
r_int
r_int
id|offset
comma
r_const
r_char
op_star
id|format
comma
dot
dot
dot
)paren
id|NORETURN
id|__attribute__
c_func
(paren
(paren
id|format
(paren
id|printf
comma
l_int|2
comma
l_int|3
)paren
)paren
)paren
suffix:semicolon
DECL|function|bad_object
r_static
r_void
id|bad_object
c_func
(paren
r_int
r_int
id|offset
comma
r_const
r_char
op_star
id|format
comma
dot
dot
dot
)paren
(brace
id|va_list
id|params
suffix:semicolon
r_char
id|buf
(braket
l_int|1024
)braket
suffix:semicolon
id|va_start
c_func
(paren
id|params
comma
id|format
)paren
suffix:semicolon
id|vsnprintf
c_func
(paren
id|buf
comma
r_sizeof
(paren
id|buf
)paren
comma
id|format
comma
id|params
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|params
)paren
suffix:semicolon
id|die
c_func
(paren
l_string|&quot;pack has bad object at offset %lu: %s&quot;
comma
id|offset
comma
id|buf
)paren
suffix:semicolon
)brace
DECL|function|unpack_entry_data
r_static
r_void
op_star
id|unpack_entry_data
c_func
(paren
r_int
r_int
id|offset
comma
r_int
r_int
id|size
)paren
(brace
id|z_stream
id|stream
suffix:semicolon
r_void
op_star
id|buf
op_assign
id|xmalloc
c_func
(paren
id|size
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|stream
comma
l_int|0
comma
r_sizeof
(paren
id|stream
)paren
)paren
suffix:semicolon
id|stream.next_out
op_assign
id|buf
suffix:semicolon
id|stream.avail_out
op_assign
id|size
suffix:semicolon
id|stream.next_in
op_assign
id|fill
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|stream.avail_in
op_assign
id|input_len
suffix:semicolon
id|inflateInit
c_func
(paren
op_amp
id|stream
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|ret
op_assign
id|inflate
c_func
(paren
op_amp
id|stream
comma
l_int|0
)paren
suffix:semicolon
id|use
c_func
(paren
id|input_len
id|stream.avail_in
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stream.total_out
op_eq
id|size
op_logical_and
id|ret
op_eq
id|Z_STREAM_END
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
id|Z_OK
)paren
id|bad_object
c_func
(paren
id|offset
comma
l_string|&quot;inflate returned %d&quot;
comma
id|ret
)paren
suffix:semicolon
id|stream.next_in
op_assign
id|fill
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|stream.avail_in
op_assign
id|input_len
suffix:semicolon
)brace
id|inflateEnd
c_func
(paren
op_amp
id|stream
)paren
suffix:semicolon
r_return
id|buf
suffix:semicolon
)brace
DECL|function|unpack_raw_entry
r_static
r_void
op_star
id|unpack_raw_entry
c_func
(paren
r_struct
id|object_entry
op_star
id|obj
comma
r_union
id|delta_base
op_star
id|delta_base
)paren
(brace
r_int
r_char
op_star
id|p
comma
id|c
suffix:semicolon
r_int
r_int
id|size
comma
id|base_offset
suffix:semicolon
r_int
id|shift
suffix:semicolon
id|obj-&gt;offset
op_assign
id|consumed_bytes
suffix:semicolon
id|p
op_assign
id|fill
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|c
op_assign
op_star
id|p
suffix:semicolon
id|use
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|obj-&gt;type
op_assign
(paren
id|c
op_rshift
l_int|4
)paren
op_amp
l_int|7
suffix:semicolon
id|size
op_assign
(paren
id|c
op_amp
l_int|15
)paren
suffix:semicolon
id|shift
op_assign
l_int|4
suffix:semicolon
r_while
c_loop
(paren
id|c
op_amp
l_int|0x80
)paren
(brace
id|p
op_assign
id|fill
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|c
op_assign
op_star
id|p
suffix:semicolon
id|use
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|size
op_add_assign
(paren
id|c
op_amp
l_int|0x7fUL
)paren
op_lshift
id|shift
suffix:semicolon
id|shift
op_add_assign
l_int|7
suffix:semicolon
)brace
id|obj-&gt;size
op_assign
id|size
suffix:semicolon
r_switch
c_cond
(paren
id|obj-&gt;type
)paren
(brace
r_case
id|OBJ_REF_DELTA
suffix:colon
id|hashcpy
c_func
(paren
id|delta_base-&gt;sha1
comma
id|fill
c_func
(paren
l_int|20
)paren
)paren
suffix:semicolon
id|use
c_func
(paren
l_int|20
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OBJ_OFS_DELTA
suffix:colon
id|memset
c_func
(paren
id|delta_base
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|delta_base
)paren
)paren
suffix:semicolon
id|p
op_assign
id|fill
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|c
op_assign
op_star
id|p
suffix:semicolon
id|use
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|base_offset
op_assign
id|c
op_amp
l_int|127
suffix:semicolon
r_while
c_loop
(paren
id|c
op_amp
l_int|128
)paren
(brace
id|base_offset
op_add_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|base_offset
op_logical_or
id|base_offset
op_amp
op_complement
(paren
op_complement
l_int|0UL
op_rshift
l_int|7
)paren
)paren
id|bad_object
c_func
(paren
id|obj-&gt;offset
comma
l_string|&quot;offset value overflow for delta base object&quot;
)paren
suffix:semicolon
id|p
op_assign
id|fill
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|c
op_assign
op_star
id|p
suffix:semicolon
id|use
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|base_offset
op_assign
(paren
id|base_offset
op_lshift
l_int|7
)paren
op_plus
(paren
id|c
op_amp
l_int|127
)paren
suffix:semicolon
)brace
id|delta_base-&gt;offset
op_assign
id|obj-&gt;offset
id|base_offset
suffix:semicolon
r_if
c_cond
(paren
id|delta_base-&gt;offset
op_ge
id|obj-&gt;offset
)paren
id|bad_object
c_func
(paren
id|obj-&gt;offset
comma
l_string|&quot;delta base offset is out of bound&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OBJ_COMMIT
suffix:colon
r_case
id|OBJ_TREE
suffix:colon
r_case
id|OBJ_BLOB
suffix:colon
r_case
id|OBJ_TAG
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|bad_object
c_func
(paren
id|obj-&gt;offset
comma
l_string|&quot;bad object type %d&quot;
comma
id|obj-&gt;type
)paren
suffix:semicolon
)brace
id|obj-&gt;hdr_size
op_assign
id|consumed_bytes
id|obj-&gt;offset
suffix:semicolon
r_return
id|unpack_entry_data
c_func
(paren
id|obj-&gt;offset
comma
id|obj-&gt;size
)paren
suffix:semicolon
)brace
DECL|function|get_data_from_pack
r_static
r_void
op_star
id|get_data_from_pack
c_func
(paren
r_struct
id|object_entry
op_star
id|obj
)paren
(brace
r_int
r_int
id|from
op_assign
id|obj
(braket
l_int|0
)braket
dot
id|offset
op_plus
id|obj
(braket
l_int|0
)braket
dot
id|hdr_size
suffix:semicolon
r_int
r_int
id|len
op_assign
id|obj
(braket
l_int|1
)braket
dot
id|offset
id|from
suffix:semicolon
r_int
id|pg_offset
op_assign
id|from
op_mod
id|getpagesize
c_func
(paren
)paren
suffix:semicolon
r_int
r_char
op_star
id|map
comma
op_star
id|data
suffix:semicolon
id|z_stream
id|stream
suffix:semicolon
r_int
id|st
suffix:semicolon
id|map
op_assign
id|mmap
c_func
(paren
l_int|NULL
comma
id|len
op_plus
id|pg_offset
comma
id|PROT_READ
comma
id|MAP_PRIVATE
comma
id|mmap_fd
comma
id|from
id|pg_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|map
op_eq
id|MAP_FAILED
)paren
id|die
c_func
(paren
l_string|&quot;cannot mmap pack file: %s&quot;
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
id|data
op_assign
id|xmalloc
c_func
(paren
id|obj-&gt;size
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|stream
comma
l_int|0
comma
r_sizeof
(paren
id|stream
)paren
)paren
suffix:semicolon
id|stream.next_out
op_assign
id|data
suffix:semicolon
id|stream.avail_out
op_assign
id|obj-&gt;size
suffix:semicolon
id|stream.next_in
op_assign
id|map
op_plus
id|pg_offset
suffix:semicolon
id|stream.avail_in
op_assign
id|len
suffix:semicolon
id|inflateInit
c_func
(paren
op_amp
id|stream
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|st
op_assign
id|inflate
c_func
(paren
op_amp
id|stream
comma
id|Z_FINISH
)paren
)paren
op_eq
id|Z_OK
)paren
suffix:semicolon
id|inflateEnd
c_func
(paren
op_amp
id|stream
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
op_ne
id|Z_STREAM_END
op_logical_or
id|stream.total_out
op_ne
id|obj-&gt;size
)paren
id|die
c_func
(paren
l_string|&quot;serious inflate inconsistency&quot;
)paren
suffix:semicolon
id|munmap
c_func
(paren
id|map
comma
id|len
op_plus
id|pg_offset
)paren
suffix:semicolon
r_return
id|data
suffix:semicolon
)brace
DECL|function|find_delta
r_static
r_int
id|find_delta
c_func
(paren
r_const
r_union
id|delta_base
op_star
id|base
)paren
(brace
r_int
id|first
op_assign
l_int|0
comma
id|last
op_assign
id|nr_deltas
suffix:semicolon
r_while
c_loop
(paren
id|first
OL
id|last
)paren
(brace
r_int
id|next
op_assign
(paren
id|first
op_plus
id|last
)paren
op_div
l_int|2
suffix:semicolon
r_struct
id|delta_entry
op_star
id|delta
op_assign
op_amp
id|deltas
(braket
id|next
)braket
suffix:semicolon
r_int
id|cmp
suffix:semicolon
id|cmp
op_assign
id|memcmp
c_func
(paren
id|base
comma
op_amp
id|delta-&gt;base
comma
id|UNION_BASE_SZ
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmp
)paren
r_return
id|next
suffix:semicolon
r_if
c_cond
(paren
id|cmp
OL
l_int|0
)paren
(brace
id|last
op_assign
id|next
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|first
op_assign
id|next
op_plus
l_int|1
suffix:semicolon
)brace
r_return
id|first
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|find_delta_children
r_static
r_int
id|find_delta_children
c_func
(paren
r_const
r_union
id|delta_base
op_star
id|base
comma
r_int
op_star
id|first_index
comma
r_int
op_star
id|last_index
)paren
(brace
r_int
id|first
op_assign
id|find_delta
c_func
(paren
id|base
)paren
suffix:semicolon
r_int
id|last
op_assign
id|first
suffix:semicolon
r_int
id|end
op_assign
id|nr_deltas
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|first
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|first
OG
l_int|0
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
op_amp
id|deltas
(braket
id|first
l_int|1
)braket
dot
id|base
comma
id|base
comma
id|UNION_BASE_SZ
)paren
)paren
op_decrement
id|first
suffix:semicolon
r_while
c_loop
(paren
id|last
OL
id|end
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
op_amp
id|deltas
(braket
id|last
op_plus
l_int|1
)braket
dot
id|base
comma
id|base
comma
id|UNION_BASE_SZ
)paren
)paren
op_increment
id|last
suffix:semicolon
op_star
id|first_index
op_assign
id|first
suffix:semicolon
op_star
id|last_index
op_assign
id|last
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sha1_object
r_static
r_void
id|sha1_object
c_func
(paren
r_const
r_void
op_star
id|data
comma
r_int
r_int
id|size
comma
r_enum
id|object_type
id|type
comma
r_int
r_char
op_star
id|sha1
)paren
(brace
id|SHA_CTX
id|ctx
suffix:semicolon
r_char
id|header
(braket
l_int|50
)braket
suffix:semicolon
r_int
id|header_size
suffix:semicolon
r_const
r_char
op_star
id|type_str
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|OBJ_COMMIT
suffix:colon
id|type_str
op_assign
id|commit_type
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OBJ_TREE
suffix:colon
id|type_str
op_assign
id|tree_type
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OBJ_BLOB
suffix:colon
id|type_str
op_assign
id|blob_type
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OBJ_TAG
suffix:colon
id|type_str
op_assign
id|tag_type
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|die
c_func
(paren
l_string|&quot;bad type %d&quot;
comma
id|type
)paren
suffix:semicolon
)brace
id|header_size
op_assign
id|sprintf
c_func
(paren
id|header
comma
l_string|&quot;%s %lu&quot;
comma
id|type_str
comma
id|size
)paren
op_plus
l_int|1
suffix:semicolon
id|SHA1_Init
c_func
(paren
op_amp
id|ctx
)paren
suffix:semicolon
id|SHA1_Update
c_func
(paren
op_amp
id|ctx
comma
id|header
comma
id|header_size
)paren
suffix:semicolon
id|SHA1_Update
c_func
(paren
op_amp
id|ctx
comma
id|data
comma
id|size
)paren
suffix:semicolon
id|SHA1_Final
c_func
(paren
id|sha1
comma
op_amp
id|ctx
)paren
suffix:semicolon
)brace
DECL|function|resolve_delta
r_static
r_void
id|resolve_delta
c_func
(paren
r_struct
id|object_entry
op_star
id|delta_obj
comma
r_void
op_star
id|base_data
comma
r_int
r_int
id|base_size
comma
r_enum
id|object_type
id|type
)paren
(brace
r_void
op_star
id|delta_data
suffix:semicolon
r_int
r_int
id|delta_size
suffix:semicolon
r_void
op_star
id|result
suffix:semicolon
r_int
r_int
id|result_size
suffix:semicolon
r_union
id|delta_base
id|delta_base
suffix:semicolon
r_int
id|j
comma
id|first
comma
id|last
suffix:semicolon
id|delta_obj-&gt;real_type
op_assign
id|type
suffix:semicolon
id|delta_data
op_assign
id|get_data_from_pack
c_func
(paren
id|delta_obj
)paren
suffix:semicolon
id|delta_size
op_assign
id|delta_obj-&gt;size
suffix:semicolon
id|result
op_assign
id|patch_delta
c_func
(paren
id|base_data
comma
id|base_size
comma
id|delta_data
comma
id|delta_size
comma
op_amp
id|result_size
)paren
suffix:semicolon
id|free
c_func
(paren
id|delta_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result
)paren
id|bad_object
c_func
(paren
id|delta_obj-&gt;offset
comma
l_string|&quot;failed to apply delta&quot;
)paren
suffix:semicolon
id|sha1_object
c_func
(paren
id|result
comma
id|result_size
comma
id|type
comma
id|delta_obj-&gt;sha1
)paren
suffix:semicolon
id|nr_resolved_deltas
op_increment
suffix:semicolon
id|hashcpy
c_func
(paren
id|delta_base.sha1
comma
id|delta_obj-&gt;sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|find_delta_children
c_func
(paren
op_amp
id|delta_base
comma
op_amp
id|first
comma
op_amp
id|last
)paren
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
id|first
suffix:semicolon
id|j
op_le
id|last
suffix:semicolon
id|j
op_increment
)paren
(brace
r_struct
id|object_entry
op_star
id|child
op_assign
id|objects
op_plus
id|deltas
(braket
id|j
)braket
dot
id|obj_no
suffix:semicolon
r_if
c_cond
(paren
id|child-&gt;real_type
op_eq
id|OBJ_REF_DELTA
)paren
id|resolve_delta
c_func
(paren
id|child
comma
id|result
comma
id|result_size
comma
id|type
)paren
suffix:semicolon
)brace
)brace
id|memset
c_func
(paren
op_amp
id|delta_base
comma
l_int|0
comma
r_sizeof
(paren
id|delta_base
)paren
)paren
suffix:semicolon
id|delta_base.offset
op_assign
id|delta_obj-&gt;offset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|find_delta_children
c_func
(paren
op_amp
id|delta_base
comma
op_amp
id|first
comma
op_amp
id|last
)paren
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
id|first
suffix:semicolon
id|j
op_le
id|last
suffix:semicolon
id|j
op_increment
)paren
(brace
r_struct
id|object_entry
op_star
id|child
op_assign
id|objects
op_plus
id|deltas
(braket
id|j
)braket
dot
id|obj_no
suffix:semicolon
r_if
c_cond
(paren
id|child-&gt;real_type
op_eq
id|OBJ_OFS_DELTA
)paren
id|resolve_delta
c_func
(paren
id|child
comma
id|result
comma
id|result_size
comma
id|type
)paren
suffix:semicolon
)brace
)brace
id|free
c_func
(paren
id|result
)paren
suffix:semicolon
)brace
DECL|function|compare_delta_entry
r_static
r_int
id|compare_delta_entry
c_func
(paren
r_const
r_void
op_star
id|a
comma
r_const
r_void
op_star
id|b
)paren
(brace
r_const
r_struct
id|delta_entry
op_star
id|delta_a
op_assign
id|a
suffix:semicolon
r_const
r_struct
id|delta_entry
op_star
id|delta_b
op_assign
id|b
suffix:semicolon
r_return
id|memcmp
c_func
(paren
op_amp
id|delta_a-&gt;base
comma
op_amp
id|delta_b-&gt;base
comma
id|UNION_BASE_SZ
)paren
suffix:semicolon
)brace
multiline_comment|/* Parse all objects and return the pack content SHA1 hash */
DECL|function|parse_pack_objects
r_static
r_void
id|parse_pack_objects
c_func
(paren
r_int
r_char
op_star
id|sha1
)paren
(brace
r_int
id|i
comma
id|percent
op_assign
l_int|1
suffix:semicolon
r_struct
id|delta_entry
op_star
id|delta
op_assign
id|deltas
suffix:semicolon
r_void
op_star
id|data
suffix:semicolon
r_struct
id|stat
id|st
suffix:semicolon
multiline_comment|/*&n;&t; * First pass:&n;&t; * - find locations of all objects;&n;&t; * - calculate SHA1 of all non-delta objects;&n;&t; * - remember base (SHA1 or offset) for all deltas.&n;&t; */
r_if
c_cond
(paren
id|verbose
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Indexing %d objects.&bslash;n&quot;
comma
id|nr_objects
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_objects
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|object_entry
op_star
id|obj
op_assign
op_amp
id|objects
(braket
id|i
)braket
suffix:semicolon
id|data
op_assign
id|unpack_raw_entry
c_func
(paren
id|obj
comma
op_amp
id|delta-&gt;base
)paren
suffix:semicolon
id|obj-&gt;real_type
op_assign
id|obj-&gt;type
suffix:semicolon
r_if
c_cond
(paren
id|obj-&gt;type
op_eq
id|OBJ_REF_DELTA
op_logical_or
id|obj-&gt;type
op_eq
id|OBJ_OFS_DELTA
)paren
(brace
id|nr_deltas
op_increment
suffix:semicolon
id|delta-&gt;obj_no
op_assign
id|i
suffix:semicolon
id|delta
op_increment
suffix:semicolon
)brace
r_else
id|sha1_object
c_func
(paren
id|data
comma
id|obj-&gt;size
comma
id|obj-&gt;type
comma
id|obj-&gt;sha1
)paren
suffix:semicolon
id|free
c_func
(paren
id|data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|verbose
)paren
id|percent
op_assign
id|display_progress
c_func
(paren
id|i
op_plus
l_int|1
comma
id|nr_objects
comma
id|percent
)paren
suffix:semicolon
)brace
id|objects
(braket
id|i
)braket
dot
id|offset
op_assign
id|consumed_bytes
suffix:semicolon
r_if
c_cond
(paren
id|verbose
)paren
id|fputc
c_func
(paren
l_char|&squot;&bslash;n&squot;
comma
id|stderr
)paren
suffix:semicolon
multiline_comment|/* Check pack integrity */
id|flush
c_func
(paren
)paren
suffix:semicolon
id|SHA1_Final
c_func
(paren
id|sha1
comma
op_amp
id|input_ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hashcmp
c_func
(paren
id|fill
c_func
(paren
l_int|20
)paren
comma
id|sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;pack is corrupted (SHA1 mismatch)&quot;
)paren
suffix:semicolon
id|use
c_func
(paren
l_int|20
)paren
suffix:semicolon
multiline_comment|/* If input_fd is a file, we should have reached its end now. */
r_if
c_cond
(paren
id|fstat
c_func
(paren
id|input_fd
comma
op_amp
id|st
)paren
)paren
id|die
c_func
(paren
l_string|&quot;cannot fstat packfile: %s&quot;
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|st.st_mode
)paren
op_logical_and
id|st.st_size
op_ne
id|consumed_bytes
)paren
id|die
c_func
(paren
l_string|&quot;pack has junk at the end&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nr_deltas
)paren
r_return
suffix:semicolon
multiline_comment|/* Sort deltas by base SHA1/offset for fast searching */
id|qsort
c_func
(paren
id|deltas
comma
id|nr_deltas
comma
r_sizeof
(paren
r_struct
id|delta_entry
)paren
comma
id|compare_delta_entry
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Second pass:&n;&t; * - for all non-delta objects, look if it is used as a base for&n;&t; *   deltas;&n;&t; * - if used as a base, uncompress the object and apply all deltas,&n;&t; *   recursively checking if the resulting object is used as a base&n;&t; *   for some more deltas.&n;&t; */
r_if
c_cond
(paren
id|verbose
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Resolving %d deltas.&bslash;n&quot;
comma
id|nr_deltas
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_objects
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|object_entry
op_star
id|obj
op_assign
op_amp
id|objects
(braket
id|i
)braket
suffix:semicolon
r_union
id|delta_base
id|base
suffix:semicolon
r_int
id|j
comma
id|ref
comma
id|ref_first
comma
id|ref_last
comma
id|ofs
comma
id|ofs_first
comma
id|ofs_last
suffix:semicolon
r_if
c_cond
(paren
id|obj-&gt;type
op_eq
id|OBJ_REF_DELTA
op_logical_or
id|obj-&gt;type
op_eq
id|OBJ_OFS_DELTA
)paren
r_continue
suffix:semicolon
id|hashcpy
c_func
(paren
id|base.sha1
comma
id|obj-&gt;sha1
)paren
suffix:semicolon
id|ref
op_assign
op_logical_neg
id|find_delta_children
c_func
(paren
op_amp
id|base
comma
op_amp
id|ref_first
comma
op_amp
id|ref_last
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|base
comma
l_int|0
comma
r_sizeof
(paren
id|base
)paren
)paren
suffix:semicolon
id|base.offset
op_assign
id|obj-&gt;offset
suffix:semicolon
id|ofs
op_assign
op_logical_neg
id|find_delta_children
c_func
(paren
op_amp
id|base
comma
op_amp
id|ofs_first
comma
op_amp
id|ofs_last
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ref
op_logical_and
op_logical_neg
id|ofs
)paren
r_continue
suffix:semicolon
id|data
op_assign
id|get_data_from_pack
c_func
(paren
id|obj
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ref
)paren
r_for
c_loop
(paren
id|j
op_assign
id|ref_first
suffix:semicolon
id|j
op_le
id|ref_last
suffix:semicolon
id|j
op_increment
)paren
(brace
r_struct
id|object_entry
op_star
id|child
op_assign
id|objects
op_plus
id|deltas
(braket
id|j
)braket
dot
id|obj_no
suffix:semicolon
r_if
c_cond
(paren
id|child-&gt;real_type
op_eq
id|OBJ_REF_DELTA
)paren
id|resolve_delta
c_func
(paren
id|child
comma
id|data
comma
id|obj-&gt;size
comma
id|obj-&gt;type
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ofs
)paren
r_for
c_loop
(paren
id|j
op_assign
id|ofs_first
suffix:semicolon
id|j
op_le
id|ofs_last
suffix:semicolon
id|j
op_increment
)paren
(brace
r_struct
id|object_entry
op_star
id|child
op_assign
id|objects
op_plus
id|deltas
(braket
id|j
)braket
dot
id|obj_no
suffix:semicolon
r_if
c_cond
(paren
id|child-&gt;real_type
op_eq
id|OBJ_OFS_DELTA
)paren
id|resolve_delta
c_func
(paren
id|child
comma
id|data
comma
id|obj-&gt;size
comma
id|obj-&gt;type
)paren
suffix:semicolon
)brace
id|free
c_func
(paren
id|data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|verbose
)paren
id|percent
op_assign
id|display_progress
c_func
(paren
id|nr_resolved_deltas
comma
id|nr_deltas
comma
id|percent
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|verbose
op_logical_and
id|nr_resolved_deltas
op_eq
id|nr_deltas
)paren
id|fputc
c_func
(paren
l_char|&squot;&bslash;n&squot;
comma
id|stderr
)paren
suffix:semicolon
)brace
DECL|function|write_compressed
r_static
r_int
id|write_compressed
c_func
(paren
r_int
id|fd
comma
r_void
op_star
id|in
comma
r_int
r_int
id|size
)paren
(brace
id|z_stream
id|stream
suffix:semicolon
r_int
r_int
id|maxsize
suffix:semicolon
r_void
op_star
id|out
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|stream
comma
l_int|0
comma
r_sizeof
(paren
id|stream
)paren
)paren
suffix:semicolon
id|deflateInit
c_func
(paren
op_amp
id|stream
comma
id|zlib_compression_level
)paren
suffix:semicolon
id|maxsize
op_assign
id|deflateBound
c_func
(paren
op_amp
id|stream
comma
id|size
)paren
suffix:semicolon
id|out
op_assign
id|xmalloc
c_func
(paren
id|maxsize
)paren
suffix:semicolon
multiline_comment|/* Compress it */
id|stream.next_in
op_assign
id|in
suffix:semicolon
id|stream.avail_in
op_assign
id|size
suffix:semicolon
id|stream.next_out
op_assign
id|out
suffix:semicolon
id|stream.avail_out
op_assign
id|maxsize
suffix:semicolon
r_while
c_loop
(paren
id|deflate
c_func
(paren
op_amp
id|stream
comma
id|Z_FINISH
)paren
op_eq
id|Z_OK
)paren
suffix:semicolon
id|deflateEnd
c_func
(paren
op_amp
id|stream
)paren
suffix:semicolon
id|size
op_assign
id|stream.total_out
suffix:semicolon
id|write_or_die
c_func
(paren
id|fd
comma
id|out
comma
id|size
)paren
suffix:semicolon
id|free
c_func
(paren
id|out
)paren
suffix:semicolon
r_return
id|size
suffix:semicolon
)brace
DECL|function|append_obj_to_pack
r_static
r_void
id|append_obj_to_pack
c_func
(paren
r_void
op_star
id|buf
comma
r_int
r_int
id|size
comma
r_enum
id|object_type
id|type
)paren
(brace
r_struct
id|object_entry
op_star
id|obj
op_assign
op_amp
id|objects
(braket
id|nr_objects
op_increment
)braket
suffix:semicolon
r_int
r_char
id|header
(braket
l_int|10
)braket
suffix:semicolon
r_int
r_int
id|s
op_assign
id|size
suffix:semicolon
r_int
id|n
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|c
op_assign
(paren
id|type
op_lshift
l_int|4
)paren
op_or
(paren
id|s
op_amp
l_int|15
)paren
suffix:semicolon
id|s
op_rshift_assign
l_int|4
suffix:semicolon
r_while
c_loop
(paren
id|s
)paren
(brace
id|header
(braket
id|n
op_increment
)braket
op_assign
id|c
op_or
l_int|0x80
suffix:semicolon
id|c
op_assign
id|s
op_amp
l_int|0x7f
suffix:semicolon
id|s
op_rshift_assign
l_int|7
suffix:semicolon
)brace
id|header
(braket
id|n
op_increment
)braket
op_assign
id|c
suffix:semicolon
id|write_or_die
c_func
(paren
id|output_fd
comma
id|header
comma
id|n
)paren
suffix:semicolon
id|obj
(braket
l_int|1
)braket
dot
id|offset
op_assign
id|obj
(braket
l_int|0
)braket
dot
id|offset
op_plus
id|n
suffix:semicolon
id|obj
(braket
l_int|1
)braket
dot
id|offset
op_add_assign
id|write_compressed
c_func
(paren
id|output_fd
comma
id|buf
comma
id|size
)paren
suffix:semicolon
id|sha1_object
c_func
(paren
id|buf
comma
id|size
comma
id|type
comma
id|obj-&gt;sha1
)paren
suffix:semicolon
)brace
DECL|function|delta_pos_compare
r_static
r_int
id|delta_pos_compare
c_func
(paren
r_const
r_void
op_star
id|_a
comma
r_const
r_void
op_star
id|_b
)paren
(brace
r_struct
id|delta_entry
op_star
id|a
op_assign
op_star
(paren
r_struct
id|delta_entry
op_star
op_star
)paren
id|_a
suffix:semicolon
r_struct
id|delta_entry
op_star
id|b
op_assign
op_star
(paren
r_struct
id|delta_entry
op_star
op_star
)paren
id|_b
suffix:semicolon
r_return
id|a-&gt;obj_no
id|b-&gt;obj_no
suffix:semicolon
)brace
DECL|function|fix_unresolved_deltas
r_static
r_void
id|fix_unresolved_deltas
c_func
(paren
r_int
id|nr_unresolved
)paren
(brace
r_struct
id|delta_entry
op_star
op_star
id|sorted_by_pos
suffix:semicolon
r_int
id|i
comma
id|n
op_assign
l_int|0
comma
id|percent
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Since many unresolved deltas may well be themselves base objects&n;&t; * for more unresolved deltas, we really want to include the&n;&t; * smallest number of base objects that would cover as much delta&n;&t; * as possible by picking the&n;&t; * trunc deltas first, allowing for other deltas to resolve without&n;&t; * additional base objects.  Since most base objects are to be found&n;&t; * before deltas depending on them, a good heuristic is to start&n;&t; * resolving deltas in the same order as their position in the pack.&n;&t; */
id|sorted_by_pos
op_assign
id|xmalloc
c_func
(paren
id|nr_unresolved
op_star
r_sizeof
(paren
op_star
id|sorted_by_pos
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_deltas
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|objects
(braket
id|deltas
(braket
id|i
)braket
dot
id|obj_no
)braket
dot
id|real_type
op_ne
id|OBJ_REF_DELTA
)paren
r_continue
suffix:semicolon
id|sorted_by_pos
(braket
id|n
op_increment
)braket
op_assign
op_amp
id|deltas
(braket
id|i
)braket
suffix:semicolon
)brace
id|qsort
c_func
(paren
id|sorted_by_pos
comma
id|n
comma
r_sizeof
(paren
op_star
id|sorted_by_pos
)paren
comma
id|delta_pos_compare
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|delta_entry
op_star
id|d
op_assign
id|sorted_by_pos
(braket
id|i
)braket
suffix:semicolon
r_void
op_star
id|data
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_char
id|type
(braket
l_int|10
)braket
suffix:semicolon
r_enum
id|object_type
id|obj_type
suffix:semicolon
r_int
id|j
comma
id|first
comma
id|last
suffix:semicolon
r_if
c_cond
(paren
id|objects
(braket
id|d-&gt;obj_no
)braket
dot
id|real_type
op_ne
id|OBJ_REF_DELTA
)paren
r_continue
suffix:semicolon
id|data
op_assign
id|read_sha1_file
c_func
(paren
id|d-&gt;base.sha1
comma
id|type
comma
op_amp
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|type
comma
id|blob_type
)paren
)paren
id|obj_type
op_assign
id|OBJ_BLOB
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|type
comma
id|tree_type
)paren
)paren
id|obj_type
op_assign
id|OBJ_TREE
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|type
comma
id|commit_type
)paren
)paren
id|obj_type
op_assign
id|OBJ_COMMIT
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|type
comma
id|tag_type
)paren
)paren
id|obj_type
op_assign
id|OBJ_TAG
suffix:semicolon
r_else
id|die
c_func
(paren
l_string|&quot;base object %s is of type &squot;%s&squot;&quot;
comma
id|sha1_to_hex
c_func
(paren
id|d-&gt;base.sha1
)paren
comma
id|type
)paren
suffix:semicolon
id|find_delta_children
c_func
(paren
op_amp
id|d-&gt;base
comma
op_amp
id|first
comma
op_amp
id|last
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|first
suffix:semicolon
id|j
op_le
id|last
suffix:semicolon
id|j
op_increment
)paren
(brace
r_struct
id|object_entry
op_star
id|child
op_assign
id|objects
op_plus
id|deltas
(braket
id|j
)braket
dot
id|obj_no
suffix:semicolon
r_if
c_cond
(paren
id|child-&gt;real_type
op_eq
id|OBJ_REF_DELTA
)paren
id|resolve_delta
c_func
(paren
id|child
comma
id|data
comma
id|size
comma
id|obj_type
)paren
suffix:semicolon
)brace
id|append_obj_to_pack
c_func
(paren
id|data
comma
id|size
comma
id|obj_type
)paren
suffix:semicolon
id|free
c_func
(paren
id|data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|verbose
)paren
id|percent
op_assign
id|display_progress
c_func
(paren
id|nr_resolved_deltas
comma
id|nr_deltas
comma
id|percent
)paren
suffix:semicolon
)brace
id|free
c_func
(paren
id|sorted_by_pos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|verbose
)paren
id|fputc
c_func
(paren
l_char|&squot;&bslash;n&squot;
comma
id|stderr
)paren
suffix:semicolon
)brace
DECL|function|readjust_pack_header_and_sha1
r_static
r_void
id|readjust_pack_header_and_sha1
c_func
(paren
r_int
r_char
op_star
id|sha1
)paren
(brace
r_struct
id|pack_header
id|hdr
suffix:semicolon
id|SHA_CTX
id|ctx
suffix:semicolon
r_int
id|size
suffix:semicolon
multiline_comment|/* Rewrite pack header with updated object number */
r_if
c_cond
(paren
id|lseek
c_func
(paren
id|output_fd
comma
l_int|0
comma
id|SEEK_SET
)paren
op_ne
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;cannot seek back: %s&quot;
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xread
c_func
(paren
id|output_fd
comma
op_amp
id|hdr
comma
r_sizeof
(paren
id|hdr
)paren
)paren
op_ne
r_sizeof
(paren
id|hdr
)paren
)paren
id|die
c_func
(paren
l_string|&quot;cannot read pack header back: %s&quot;
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
id|hdr.hdr_entries
op_assign
id|htonl
c_func
(paren
id|nr_objects
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lseek
c_func
(paren
id|output_fd
comma
l_int|0
comma
id|SEEK_SET
)paren
op_ne
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;cannot seek back: %s&quot;
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
id|write_or_die
c_func
(paren
id|output_fd
comma
op_amp
id|hdr
comma
r_sizeof
(paren
id|hdr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lseek
c_func
(paren
id|output_fd
comma
l_int|0
comma
id|SEEK_SET
)paren
op_ne
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;cannot seek back: %s&quot;
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
multiline_comment|/* Recompute and store the new pack&squot;s SHA1 */
id|SHA1_Init
c_func
(paren
op_amp
id|ctx
)paren
suffix:semicolon
r_do
(brace
r_int
r_char
op_star
id|buf
(braket
l_int|4096
)braket
suffix:semicolon
id|size
op_assign
id|xread
c_func
(paren
id|output_fd
comma
id|buf
comma
r_sizeof
(paren
id|buf
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;cannot read pack data back: %s&quot;
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
id|SHA1_Update
c_func
(paren
op_amp
id|ctx
comma
id|buf
comma
id|size
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
suffix:semicolon
id|SHA1_Final
c_func
(paren
id|sha1
comma
op_amp
id|ctx
)paren
suffix:semicolon
id|write_or_die
c_func
(paren
id|output_fd
comma
id|sha1
comma
l_int|20
)paren
suffix:semicolon
)brace
DECL|function|sha1_compare
r_static
r_int
id|sha1_compare
c_func
(paren
r_const
r_void
op_star
id|_a
comma
r_const
r_void
op_star
id|_b
)paren
(brace
r_struct
id|object_entry
op_star
id|a
op_assign
op_star
(paren
r_struct
id|object_entry
op_star
op_star
)paren
id|_a
suffix:semicolon
r_struct
id|object_entry
op_star
id|b
op_assign
op_star
(paren
r_struct
id|object_entry
op_star
op_star
)paren
id|_b
suffix:semicolon
r_return
id|hashcmp
c_func
(paren
id|a-&gt;sha1
comma
id|b-&gt;sha1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * On entry *sha1 contains the pack content SHA1 hash, on exit it is&n; * the SHA1 hash of sorted object names.&n; */
DECL|function|write_index_file
r_static
r_const
r_char
op_star
id|write_index_file
c_func
(paren
r_const
r_char
op_star
id|index_name
comma
r_int
r_char
op_star
id|sha1
)paren
(brace
r_struct
id|sha1file
op_star
id|f
suffix:semicolon
r_struct
id|object_entry
op_star
op_star
id|sorted_by_sha
comma
op_star
op_star
id|list
comma
op_star
op_star
id|last
suffix:semicolon
r_int
r_int
id|array
(braket
l_int|256
)braket
suffix:semicolon
r_int
id|i
comma
id|fd
suffix:semicolon
id|SHA_CTX
id|ctx
suffix:semicolon
r_if
c_cond
(paren
id|nr_objects
)paren
(brace
id|sorted_by_sha
op_assign
id|xcalloc
c_func
(paren
id|nr_objects
comma
r_sizeof
(paren
r_struct
id|object_entry
op_star
)paren
)paren
suffix:semicolon
id|list
op_assign
id|sorted_by_sha
suffix:semicolon
id|last
op_assign
id|sorted_by_sha
op_plus
id|nr_objects
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_objects
suffix:semicolon
op_increment
id|i
)paren
id|sorted_by_sha
(braket
id|i
)braket
op_assign
op_amp
id|objects
(braket
id|i
)braket
suffix:semicolon
id|qsort
c_func
(paren
id|sorted_by_sha
comma
id|nr_objects
comma
r_sizeof
(paren
id|sorted_by_sha
(braket
l_int|0
)braket
)paren
comma
id|sha1_compare
)paren
suffix:semicolon
)brace
r_else
id|sorted_by_sha
op_assign
id|list
op_assign
id|last
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|index_name
)paren
(brace
r_static
r_char
id|tmpfile
(braket
id|PATH_MAX
)braket
suffix:semicolon
id|snprintf
c_func
(paren
id|tmpfile
comma
r_sizeof
(paren
id|tmpfile
)paren
comma
l_string|&quot;%s/index_XXXXXX&quot;
comma
id|get_object_directory
c_func
(paren
)paren
)paren
suffix:semicolon
id|fd
op_assign
id|mkstemp
c_func
(paren
id|tmpfile
)paren
suffix:semicolon
id|index_name
op_assign
id|xstrdup
c_func
(paren
id|tmpfile
)paren
suffix:semicolon
)brace
r_else
(brace
id|unlink
c_func
(paren
id|index_name
)paren
suffix:semicolon
id|fd
op_assign
id|open
c_func
(paren
id|index_name
comma
id|O_CREAT
op_or
id|O_EXCL
op_or
id|O_WRONLY
comma
l_int|0600
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;unable to create %s: %s&quot;
comma
id|index_name
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
id|f
op_assign
id|sha1fd
c_func
(paren
id|fd
comma
id|index_name
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Write the first-level table (the list is sorted,&n;&t; * but we use a 256-entry lookup to be able to avoid&n;&t; * having to do eight extra binary search iterations).&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|256
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|object_entry
op_star
op_star
id|next
op_assign
id|list
suffix:semicolon
r_while
c_loop
(paren
id|next
OL
id|last
)paren
(brace
r_struct
id|object_entry
op_star
id|obj
op_assign
op_star
id|next
suffix:semicolon
r_if
c_cond
(paren
id|obj-&gt;sha1
(braket
l_int|0
)braket
op_ne
id|i
)paren
r_break
suffix:semicolon
id|next
op_increment
suffix:semicolon
)brace
id|array
(braket
id|i
)braket
op_assign
id|htonl
c_func
(paren
id|next
id|sorted_by_sha
)paren
suffix:semicolon
id|list
op_assign
id|next
suffix:semicolon
)brace
id|sha1write
c_func
(paren
id|f
comma
id|array
comma
l_int|256
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
multiline_comment|/* recompute the SHA1 hash of sorted object names.&n;&t; * currently pack-objects does not do this, but that&n;&t; * can be fixed.&n;&t; */
id|SHA1_Init
c_func
(paren
op_amp
id|ctx
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Write the actual SHA1 entries..&n;&t; */
id|list
op_assign
id|sorted_by_sha
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_objects
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|object_entry
op_star
id|obj
op_assign
op_star
id|list
op_increment
suffix:semicolon
r_int
r_int
id|offset
op_assign
id|htonl
c_func
(paren
id|obj-&gt;offset
)paren
suffix:semicolon
id|sha1write
c_func
(paren
id|f
comma
op_amp
id|offset
comma
l_int|4
)paren
suffix:semicolon
id|sha1write
c_func
(paren
id|f
comma
id|obj-&gt;sha1
comma
l_int|20
)paren
suffix:semicolon
id|SHA1_Update
c_func
(paren
op_amp
id|ctx
comma
id|obj-&gt;sha1
comma
l_int|20
)paren
suffix:semicolon
)brace
id|sha1write
c_func
(paren
id|f
comma
id|sha1
comma
l_int|20
)paren
suffix:semicolon
id|sha1close
c_func
(paren
id|f
comma
l_int|NULL
comma
l_int|1
)paren
suffix:semicolon
id|free
c_func
(paren
id|sorted_by_sha
)paren
suffix:semicolon
id|SHA1_Final
c_func
(paren
id|sha1
comma
op_amp
id|ctx
)paren
suffix:semicolon
r_return
id|index_name
suffix:semicolon
)brace
DECL|function|final
r_static
r_void
id|final
c_func
(paren
r_const
r_char
op_star
id|final_pack_name
comma
r_const
r_char
op_star
id|curr_pack_name
comma
r_const
r_char
op_star
id|final_index_name
comma
r_const
r_char
op_star
id|curr_index_name
comma
r_const
r_char
op_star
id|keep_name
comma
r_const
r_char
op_star
id|keep_msg
comma
r_int
r_char
op_star
id|sha1
)paren
(brace
r_char
id|name
(braket
id|PATH_MAX
)braket
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|from_stdin
)paren
(brace
id|close
c_func
(paren
id|input_fd
)paren
suffix:semicolon
)brace
r_else
(brace
id|err
op_assign
id|close
c_func
(paren
id|output_fd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
id|die
c_func
(paren
l_string|&quot;error while closing pack file: %s&quot;
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
id|chmod
c_func
(paren
id|curr_pack_name
comma
l_int|0444
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Let&squot;s just mimic git-unpack-objects here and write&n;&t;&t; * the last part of the buffer to stdout.&n;&t;&t; */
r_while
c_loop
(paren
id|input_len
)paren
(brace
id|err
op_assign
id|xwrite
c_func
(paren
l_int|1
comma
id|input_buffer
op_plus
id|input_offset
comma
id|input_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_le
l_int|0
)paren
r_break
suffix:semicolon
id|input_len
op_sub_assign
id|err
suffix:semicolon
id|input_offset
op_add_assign
id|err
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|keep_msg
)paren
(brace
r_int
id|keep_fd
comma
id|keep_msg_len
op_assign
id|strlen
c_func
(paren
id|keep_msg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|keep_name
)paren
(brace
id|snprintf
c_func
(paren
id|name
comma
r_sizeof
(paren
id|name
)paren
comma
l_string|&quot;%s/pack/pack-%s.keep&quot;
comma
id|get_object_directory
c_func
(paren
)paren
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
id|keep_name
op_assign
id|name
suffix:semicolon
)brace
id|keep_fd
op_assign
id|open
c_func
(paren
id|keep_name
comma
id|O_RDWR
op_or
id|O_CREAT
comma
l_int|0600
)paren
suffix:semicolon
r_if
c_cond
(paren
id|keep_fd
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;cannot write keep file&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|keep_msg_len
OG
l_int|0
)paren
(brace
id|write_or_die
c_func
(paren
id|keep_fd
comma
id|keep_msg
comma
id|keep_msg_len
)paren
suffix:semicolon
id|write_or_die
c_func
(paren
id|keep_fd
comma
l_string|&quot;&bslash;n&quot;
comma
l_int|1
)paren
suffix:semicolon
)brace
id|close
c_func
(paren
id|keep_fd
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|final_pack_name
op_ne
id|curr_pack_name
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|final_pack_name
)paren
(brace
id|snprintf
c_func
(paren
id|name
comma
r_sizeof
(paren
id|name
)paren
comma
l_string|&quot;%s/pack/pack-%s.pack&quot;
comma
id|get_object_directory
c_func
(paren
)paren
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
id|final_pack_name
op_assign
id|name
suffix:semicolon
)brace
r_if
c_cond
(paren
id|move_temp_to_file
c_func
(paren
id|curr_pack_name
comma
id|final_pack_name
)paren
)paren
id|die
c_func
(paren
l_string|&quot;cannot store pack file&quot;
)paren
suffix:semicolon
)brace
id|chmod
c_func
(paren
id|curr_index_name
comma
l_int|0444
)paren
suffix:semicolon
r_if
c_cond
(paren
id|final_index_name
op_ne
id|curr_index_name
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|final_index_name
)paren
(brace
id|snprintf
c_func
(paren
id|name
comma
r_sizeof
(paren
id|name
)paren
comma
l_string|&quot;%s/pack/pack-%s.idx&quot;
comma
id|get_object_directory
c_func
(paren
)paren
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
id|final_index_name
op_assign
id|name
suffix:semicolon
)brace
r_if
c_cond
(paren
id|move_temp_to_file
c_func
(paren
id|curr_index_name
comma
id|final_index_name
)paren
)paren
id|die
c_func
(paren
l_string|&quot;cannot store index file&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|function|main
r_int
id|main
c_func
(paren
r_int
id|argc
comma
r_char
op_star
op_star
id|argv
)paren
(brace
r_int
id|i
comma
id|fix_thin_pack
op_assign
l_int|0
suffix:semicolon
r_const
r_char
op_star
id|curr_pack
comma
op_star
id|pack_name
op_assign
l_int|NULL
suffix:semicolon
r_const
r_char
op_star
id|curr_index
comma
op_star
id|index_name
op_assign
l_int|NULL
suffix:semicolon
r_const
r_char
op_star
id|keep_name
op_assign
l_int|NULL
comma
op_star
id|keep_msg
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
id|index_name_buf
op_assign
l_int|NULL
comma
op_star
id|keep_name_buf
op_assign
l_int|NULL
suffix:semicolon
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|argc
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_char
op_star
id|arg
op_assign
id|argv
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_star
id|arg
op_eq
l_char|&squot;-&squot;
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--stdin&quot;
)paren
)paren
(brace
id|from_stdin
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--fix-thin&quot;
)paren
)paren
(brace
id|fix_thin_pack
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;--keep&quot;
)paren
)paren
(brace
id|keep_msg
op_assign
l_string|&quot;&quot;
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|arg
comma
l_string|&quot;--keep=&quot;
comma
l_int|7
)paren
)paren
(brace
id|keep_msg
op_assign
id|arg
op_plus
l_int|7
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;-v&quot;
)paren
)paren
(brace
id|verbose
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;-o&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|index_name
op_logical_or
(paren
id|i
op_plus
l_int|1
)paren
op_ge
id|argc
)paren
id|usage
c_func
(paren
id|index_pack_usage
)paren
suffix:semicolon
id|index_name
op_assign
id|argv
(braket
op_increment
id|i
)braket
suffix:semicolon
)brace
r_else
id|usage
c_func
(paren
id|index_pack_usage
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pack_name
)paren
id|usage
c_func
(paren
id|index_pack_usage
)paren
suffix:semicolon
id|pack_name
op_assign
id|arg
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|pack_name
op_logical_and
op_logical_neg
id|from_stdin
)paren
id|usage
c_func
(paren
id|index_pack_usage
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fix_thin_pack
op_logical_and
op_logical_neg
id|from_stdin
)paren
id|die
c_func
(paren
l_string|&quot;--fix-thin cannot be used without --stdin&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|index_name
op_logical_and
id|pack_name
)paren
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|pack_name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|has_extension
c_func
(paren
id|pack_name
comma
l_string|&quot;.pack&quot;
)paren
)paren
id|die
c_func
(paren
l_string|&quot;packfile name &squot;%s&squot; does not end with &squot;.pack&squot;&quot;
comma
id|pack_name
)paren
suffix:semicolon
id|index_name_buf
op_assign
id|xmalloc
c_func
(paren
id|len
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|index_name_buf
comma
id|pack_name
comma
id|len
l_int|5
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|index_name_buf
op_plus
id|len
l_int|5
comma
l_string|&quot;.idx&quot;
)paren
suffix:semicolon
id|index_name
op_assign
id|index_name_buf
suffix:semicolon
)brace
r_if
c_cond
(paren
id|keep_msg
op_logical_and
op_logical_neg
id|keep_name
op_logical_and
id|pack_name
)paren
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|pack_name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|has_extension
c_func
(paren
id|pack_name
comma
l_string|&quot;.pack&quot;
)paren
)paren
id|die
c_func
(paren
l_string|&quot;packfile name &squot;%s&squot; does not end with &squot;.pack&squot;&quot;
comma
id|pack_name
)paren
suffix:semicolon
id|keep_name_buf
op_assign
id|xmalloc
c_func
(paren
id|len
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|keep_name_buf
comma
id|pack_name
comma
id|len
l_int|5
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|keep_name_buf
op_plus
id|len
l_int|5
comma
l_string|&quot;.keep&quot;
)paren
suffix:semicolon
id|keep_name
op_assign
id|keep_name_buf
suffix:semicolon
)brace
id|curr_pack
op_assign
id|open_pack_file
c_func
(paren
id|pack_name
)paren
suffix:semicolon
id|parse_pack_header
c_func
(paren
)paren
suffix:semicolon
id|objects
op_assign
id|xmalloc
c_func
(paren
(paren
id|nr_objects
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
r_struct
id|object_entry
)paren
)paren
suffix:semicolon
id|deltas
op_assign
id|xmalloc
c_func
(paren
id|nr_objects
op_star
r_sizeof
(paren
r_struct
id|delta_entry
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|verbose
)paren
id|setup_progress_signal
c_func
(paren
)paren
suffix:semicolon
id|parse_pack_objects
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr_deltas
op_ne
id|nr_resolved_deltas
)paren
(brace
r_if
c_cond
(paren
id|fix_thin_pack
)paren
(brace
r_int
id|nr_unresolved
op_assign
id|nr_deltas
id|nr_resolved_deltas
suffix:semicolon
r_int
id|nr_objects_initial
op_assign
id|nr_objects
suffix:semicolon
r_if
c_cond
(paren
id|nr_unresolved
op_le
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;confusion beyond insanity&quot;
)paren
suffix:semicolon
id|objects
op_assign
id|xrealloc
c_func
(paren
id|objects
comma
(paren
id|nr_objects
op_plus
id|nr_unresolved
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
op_star
id|objects
)paren
)paren
suffix:semicolon
id|fix_unresolved_deltas
c_func
(paren
id|nr_unresolved
)paren
suffix:semicolon
r_if
c_cond
(paren
id|verbose
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%d objects were added to complete this thin pack.&bslash;n&quot;
comma
id|nr_objects
id|nr_objects_initial
)paren
suffix:semicolon
id|readjust_pack_header_and_sha1
c_func
(paren
id|sha1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nr_deltas
op_ne
id|nr_resolved_deltas
)paren
id|die
c_func
(paren
l_string|&quot;pack has %d unresolved deltas&quot;
comma
id|nr_deltas
id|nr_resolved_deltas
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Flush remaining pack final 20-byte SHA1. */
id|flush
c_func
(paren
)paren
suffix:semicolon
)brace
id|free
c_func
(paren
id|deltas
)paren
suffix:semicolon
id|curr_index
op_assign
id|write_index_file
c_func
(paren
id|index_name
comma
id|sha1
)paren
suffix:semicolon
id|final
c_func
(paren
id|pack_name
comma
id|curr_pack
comma
id|index_name
comma
id|curr_index
comma
id|keep_name
comma
id|keep_msg
comma
id|sha1
)paren
suffix:semicolon
id|free
c_func
(paren
id|objects
)paren
suffix:semicolon
id|free
c_func
(paren
id|index_name_buf
)paren
suffix:semicolon
id|free
c_func
(paren
id|keep_name_buf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|from_stdin
)paren
id|printf
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
