macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;diff.h&quot;
macro_line|#include &quot;commit.h&quot;
macro_line|#include &quot;patch-ids.h&quot;
DECL|function|commit_patch_id
r_static
r_int
id|commit_patch_id
c_func
(paren
r_struct
id|commit
op_star
id|commit
comma
r_struct
id|diff_options
op_star
id|options
comma
r_int
r_char
op_star
id|sha1
)paren
(brace
r_if
c_cond
(paren
id|commit-&gt;parents
)paren
id|diff_tree_sha1
c_func
(paren
id|commit-&gt;parents-&gt;item-&gt;object.sha1
comma
id|commit-&gt;object.sha1
comma
l_string|&quot;&quot;
comma
id|options
)paren
suffix:semicolon
r_else
id|diff_root_tree_sha1
c_func
(paren
id|commit-&gt;object.sha1
comma
l_string|&quot;&quot;
comma
id|options
)paren
suffix:semicolon
id|diffcore_std
c_func
(paren
id|options
)paren
suffix:semicolon
r_return
id|diff_flush_patch_id
c_func
(paren
id|options
comma
id|sha1
)paren
suffix:semicolon
)brace
DECL|function|take2
r_static
r_uint32
id|take2
c_func
(paren
r_const
r_int
r_char
op_star
id|id
)paren
(brace
r_return
(paren
(paren
id|id
(braket
l_int|0
)braket
op_lshift
l_int|8
)paren
op_or
id|id
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Conventional binary search loop looks like this:&n; *&n; *      do {&n; *              int mi = (lo + hi) / 2;&n; *              int cmp = &quot;entry pointed at by mi&quot; minus &quot;target&quot;;&n; *              if (!cmp)&n; *                      return (mi is the wanted one)&n; *              if (cmp &gt; 0)&n; *                      hi = mi; &quot;mi is larger than target&quot;&n; *              else&n; *                      lo = mi+1; &quot;mi is smaller than target&quot;&n; *      } while (lo &lt; hi);&n; *&n; * The invariants are:&n; *&n; * - When entering the loop, lo points at a slot that is never&n; *   above the target (it could be at the target), hi points at a&n; *   slot that is guaranteed to be above the target (it can never&n; *   be at the target).&n; *&n; * - We find a point &squot;mi&squot; between lo and hi (mi could be the same&n; *   as lo, but never can be the same as hi), and check if it hits&n; *   the target.  There are three cases:&n; *&n; *    - if it is a hit, we are happy.&n; *&n; *    - if it is strictly higher than the target, we update hi with&n; *      it.&n; *&n; *    - if it is strictly lower than the target, we update lo to be&n; *      one slot after it, because we allow lo to be at the target.&n; *&n; * When choosing &squot;mi&squot;, we do not have to take the &quot;middle&quot; but&n; * anywhere in between lo and hi, as long as lo &lt;= mi &lt; hi is&n; * satisfied.  When we somehow know that the distance between the&n; * target and lo is much shorter than the target and hi, we could&n; * pick mi that is much closer to lo than the midway.&n; */
DECL|function|patch_pos
r_static
r_int
id|patch_pos
c_func
(paren
r_struct
id|patch_id
op_star
op_star
id|table
comma
r_int
id|nr
comma
r_const
r_int
r_char
op_star
id|id
)paren
(brace
r_int
id|hi
op_assign
id|nr
suffix:semicolon
r_int
id|lo
op_assign
l_int|0
suffix:semicolon
r_int
id|mi
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nr
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|nr
op_ne
l_int|1
)paren
(brace
r_int
id|lov
comma
id|hiv
comma
id|miv
comma
id|ofs
suffix:semicolon
r_for
c_loop
(paren
id|ofs
op_assign
l_int|0
suffix:semicolon
id|ofs
OL
l_int|18
suffix:semicolon
id|ofs
op_add_assign
l_int|2
)paren
(brace
id|lov
op_assign
id|take2
c_func
(paren
id|table
(braket
l_int|0
)braket
op_member_access_from_pointer
id|patch_id
op_plus
id|ofs
)paren
suffix:semicolon
id|hiv
op_assign
id|take2
c_func
(paren
id|table
(braket
id|nr
op_minus
l_int|1
)braket
op_member_access_from_pointer
id|patch_id
op_plus
id|ofs
)paren
suffix:semicolon
id|miv
op_assign
id|take2
c_func
(paren
id|id
op_plus
id|ofs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|miv
OL
id|lov
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|hiv
OL
id|miv
)paren
r_return
l_int|1
id|nr
suffix:semicolon
r_if
c_cond
(paren
id|lov
op_ne
id|hiv
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * At this point miv could be equal&n;&t;&t;&t;&t; * to hiv (but id could still be higher);&n;&t;&t;&t;&t; * the invariant of (mi &lt; hi) should be&n;&t;&t;&t;&t; * kept.&n;&t;&t;&t;&t; */
id|mi
op_assign
(paren
id|nr
op_minus
l_int|1
)paren
op_star
(paren
id|miv
id|lov
)paren
op_div
(paren
id|hiv
id|lov
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lo
op_le
id|mi
op_logical_and
id|mi
OL
id|hi
)paren
r_break
suffix:semicolon
id|die
c_func
(paren
l_string|&quot;oops&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
l_int|18
op_le
id|ofs
)paren
id|die
c_func
(paren
l_string|&quot;cannot happen -- lo and hi are identical&quot;
)paren
suffix:semicolon
)brace
r_do
(brace
r_int
id|cmp
suffix:semicolon
id|cmp
op_assign
id|hashcmp
c_func
(paren
id|table
(braket
id|mi
)braket
op_member_access_from_pointer
id|patch_id
comma
id|id
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmp
)paren
r_return
id|mi
suffix:semicolon
r_if
c_cond
(paren
id|cmp
OG
l_int|0
)paren
id|hi
op_assign
id|mi
suffix:semicolon
r_else
id|lo
op_assign
id|mi
op_plus
l_int|1
suffix:semicolon
id|mi
op_assign
(paren
id|hi
op_plus
id|lo
)paren
op_div
l_int|2
suffix:semicolon
)brace
r_while
c_loop
(paren
id|lo
OL
id|hi
)paren
suffix:semicolon
r_return
id|lo
op_minus
l_int|1
suffix:semicolon
)brace
DECL|macro|BUCKET_SIZE
mdefine_line|#define BUCKET_SIZE 190 /* 190 * 21 = 3990, with slop close enough to 4K */
DECL|struct|patch_id_bucket
r_struct
id|patch_id_bucket
(brace
DECL|member|next
r_struct
id|patch_id_bucket
op_star
id|next
suffix:semicolon
DECL|member|nr
r_int
id|nr
suffix:semicolon
DECL|member|bucket
r_struct
id|patch_id
id|bucket
(braket
id|BUCKET_SIZE
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|function|init_patch_ids
r_int
id|init_patch_ids
c_func
(paren
r_struct
id|patch_ids
op_star
id|ids
)paren
(brace
id|memset
c_func
(paren
id|ids
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|ids
)paren
)paren
suffix:semicolon
id|diff_setup
c_func
(paren
op_amp
id|ids-&gt;diffopts
)paren
suffix:semicolon
id|DIFF_OPT_SET
c_func
(paren
op_amp
id|ids-&gt;diffopts
comma
id|RECURSIVE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|diff_setup_done
c_func
(paren
op_amp
id|ids-&gt;diffopts
)paren
OL
l_int|0
)paren
r_return
id|error
c_func
(paren
l_string|&quot;diff_setup_done failed&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|free_patch_ids
r_int
id|free_patch_ids
c_func
(paren
r_struct
id|patch_ids
op_star
id|ids
)paren
(brace
r_struct
id|patch_id_bucket
op_star
id|next
comma
op_star
id|patches
suffix:semicolon
id|free
c_func
(paren
id|ids-&gt;table
)paren
suffix:semicolon
r_for
c_loop
(paren
id|patches
op_assign
id|ids-&gt;patches
suffix:semicolon
id|patches
suffix:semicolon
id|patches
op_assign
id|next
)paren
(brace
id|next
op_assign
id|patches-&gt;next
suffix:semicolon
id|free
c_func
(paren
id|patches
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|add_commit
r_static
r_struct
id|patch_id
op_star
id|add_commit
c_func
(paren
r_struct
id|commit
op_star
id|commit
comma
r_struct
id|patch_ids
op_star
id|ids
comma
r_int
id|no_add
)paren
(brace
r_struct
id|patch_id_bucket
op_star
id|bucket
suffix:semicolon
r_struct
id|patch_id
op_star
id|ent
suffix:semicolon
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_int
id|pos
suffix:semicolon
r_if
c_cond
(paren
id|commit_patch_id
c_func
(paren
id|commit
comma
op_amp
id|ids-&gt;diffopts
comma
id|sha1
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|pos
op_assign
id|patch_pos
c_func
(paren
id|ids-&gt;table
comma
id|ids-&gt;nr
comma
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_le
id|pos
)paren
r_return
id|ids-&gt;table
(braket
id|pos
)braket
suffix:semicolon
r_if
c_cond
(paren
id|no_add
)paren
r_return
l_int|NULL
suffix:semicolon
id|pos
op_assign
l_int|1
id|pos
suffix:semicolon
id|bucket
op_assign
id|ids-&gt;patches
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bucket
op_logical_or
(paren
id|BUCKET_SIZE
op_le
id|bucket-&gt;nr
)paren
)paren
(brace
id|bucket
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|bucket
)paren
)paren
suffix:semicolon
id|bucket-&gt;next
op_assign
id|ids-&gt;patches
suffix:semicolon
id|ids-&gt;patches
op_assign
id|bucket
suffix:semicolon
)brace
id|ent
op_assign
op_amp
id|bucket-&gt;bucket
(braket
id|bucket-&gt;nr
op_increment
)braket
suffix:semicolon
id|hashcpy
c_func
(paren
id|ent-&gt;patch_id
comma
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ids-&gt;alloc
op_le
id|ids-&gt;nr
)paren
(brace
id|ids-&gt;alloc
op_assign
id|alloc_nr
c_func
(paren
id|ids-&gt;nr
)paren
suffix:semicolon
id|ids-&gt;table
op_assign
id|xrealloc
c_func
(paren
id|ids-&gt;table
comma
r_sizeof
(paren
id|ent
)paren
op_star
id|ids-&gt;alloc
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pos
OL
id|ids-&gt;nr
)paren
id|memmove
c_func
(paren
id|ids-&gt;table
op_plus
id|pos
op_plus
l_int|1
comma
id|ids-&gt;table
op_plus
id|pos
comma
r_sizeof
(paren
id|ent
)paren
op_star
(paren
id|ids-&gt;nr
id|pos
)paren
)paren
suffix:semicolon
id|ids-&gt;nr
op_increment
suffix:semicolon
id|ids-&gt;table
(braket
id|pos
)braket
op_assign
id|ent
suffix:semicolon
r_return
id|ids-&gt;table
(braket
id|pos
)braket
suffix:semicolon
)brace
DECL|function|has_commit_patch_id
r_struct
id|patch_id
op_star
id|has_commit_patch_id
c_func
(paren
r_struct
id|commit
op_star
id|commit
comma
r_struct
id|patch_ids
op_star
id|ids
)paren
(brace
r_return
id|add_commit
c_func
(paren
id|commit
comma
id|ids
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|add_commit_patch_id
r_struct
id|patch_id
op_star
id|add_commit_patch_id
c_func
(paren
r_struct
id|commit
op_star
id|commit
comma
r_struct
id|patch_ids
op_star
id|ids
)paren
(brace
r_return
id|add_commit
c_func
(paren
id|commit
comma
id|ids
comma
l_int|0
)paren
suffix:semicolon
)brace
eof
