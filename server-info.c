macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;refs.h&quot;
macro_line|#include &quot;object.h&quot;
macro_line|#include &quot;commit.h&quot;
macro_line|#include &quot;rev-cache.h&quot;
multiline_comment|/* refs */
DECL|variable|info_ref_fp
r_static
id|FILE
op_star
id|info_ref_fp
suffix:semicolon
DECL|variable|info_ref_time
r_static
r_int
r_int
id|info_ref_time
suffix:semicolon
DECL|variable|info_ref_is_stale
r_static
r_int
id|info_ref_is_stale
op_assign
l_int|0
suffix:semicolon
DECL|function|stat_ref
r_static
r_int
id|stat_ref
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_struct
id|stat
id|st
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stat
c_func
(paren
id|path
comma
op_amp
id|st
)paren
op_logical_and
id|info_ref_time
OL
id|st.st_mtime
)paren
id|info_ref_is_stale
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|add_info_ref
r_static
r_int
id|add_info_ref
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
id|fprintf
c_func
(paren
id|info_ref_fp
comma
l_string|&quot;%s&t;%s&bslash;n&quot;
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
comma
id|path
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|update_info_refs
r_static
r_int
id|update_info_refs
c_func
(paren
r_int
id|force
)paren
(brace
r_struct
id|stat
id|st
suffix:semicolon
r_char
op_star
id|path0
op_assign
id|strdup
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;info/refs&quot;
)paren
)paren
suffix:semicolon
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|path0
)paren
suffix:semicolon
r_char
op_star
id|path1
op_assign
id|xmalloc
c_func
(paren
id|len
op_plus
l_int|2
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|path1
comma
id|path0
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|path1
op_plus
id|len
comma
l_string|&quot;+&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|force
)paren
(brace
r_if
c_cond
(paren
id|stat
c_func
(paren
id|path0
comma
op_amp
id|st
)paren
)paren
(brace
r_if
c_cond
(paren
id|errno
op_eq
id|ENOENT
)paren
id|info_ref_is_stale
op_assign
l_int|1
suffix:semicolon
r_else
r_return
id|error
c_func
(paren
l_string|&quot;cannot stat %s&quot;
comma
id|path0
)paren
suffix:semicolon
)brace
r_else
(brace
id|info_ref_time
op_assign
id|st.st_mtime
suffix:semicolon
id|for_each_ref
c_func
(paren
id|stat_ref
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|info_ref_is_stale
)paren
r_return
l_int|0
suffix:semicolon
)brace
id|safe_create_leading_directories
c_func
(paren
id|path0
)paren
suffix:semicolon
id|info_ref_fp
op_assign
id|fopen
c_func
(paren
id|path1
comma
l_string|&quot;w&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info_ref_fp
)paren
r_return
id|error
c_func
(paren
l_string|&quot;unable to update %s&quot;
comma
id|path0
)paren
suffix:semicolon
id|for_each_ref
c_func
(paren
id|add_info_ref
)paren
suffix:semicolon
id|fclose
c_func
(paren
id|info_ref_fp
)paren
suffix:semicolon
id|rename
c_func
(paren
id|path1
comma
id|path0
)paren
suffix:semicolon
id|free
c_func
(paren
id|path0
)paren
suffix:semicolon
id|free
c_func
(paren
id|path1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* packs */
DECL|struct|pack_info
r_struct
id|pack_info
(brace
DECL|member|latest
r_int
r_int
id|latest
suffix:semicolon
DECL|member|p
r_struct
id|packed_git
op_star
id|p
suffix:semicolon
DECL|member|old_num
r_int
id|old_num
suffix:semicolon
DECL|member|new_num
r_int
id|new_num
suffix:semicolon
DECL|member|nr_alloc
r_int
id|nr_alloc
suffix:semicolon
DECL|member|nr_heads
r_int
id|nr_heads
suffix:semicolon
DECL|member|head
r_int
r_char
(paren
op_star
id|head
)paren
(braket
l_int|20
)braket
suffix:semicolon
DECL|member|dep
r_char
id|dep
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* more */
DECL|variable|info
)brace
op_star
op_star
id|info
suffix:semicolon
DECL|variable|num_pack
r_static
r_int
id|num_pack
suffix:semicolon
DECL|variable|objdir
r_static
r_const
r_char
op_star
id|objdir
suffix:semicolon
DECL|variable|objdirlen
r_static
r_int
id|objdirlen
suffix:semicolon
DECL|function|parse_object_cheap
r_static
r_struct
id|object
op_star
id|parse_object_cheap
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_struct
id|object
op_star
id|o
suffix:semicolon
r_if
c_cond
(paren
(paren
id|o
op_assign
id|parse_object
c_func
(paren
id|sha1
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|o-&gt;type
op_eq
id|commit_type
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
(paren
r_struct
id|commit
op_star
)paren
id|o
suffix:semicolon
id|free
c_func
(paren
id|commit-&gt;buffer
)paren
suffix:semicolon
id|commit-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|o
suffix:semicolon
)brace
DECL|function|find_pack_by_name
r_static
r_struct
id|pack_info
op_star
id|find_pack_by_name
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_pack
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|packed_git
op_star
id|p
op_assign
id|info
(braket
id|i
)braket
op_member_access_from_pointer
id|p
suffix:semicolon
multiline_comment|/* skip &quot;/pack/&quot; after &quot;.git/objects&quot; */
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|p-&gt;pack_name
op_plus
id|objdirlen
op_plus
l_int|6
comma
id|name
)paren
)paren
r_return
id|info
(braket
id|i
)braket
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|find_pack_by_old_num
r_static
r_struct
id|pack_info
op_star
id|find_pack_by_old_num
c_func
(paren
r_int
id|old_num
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_pack
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|info
(braket
id|i
)braket
op_member_access_from_pointer
id|old_num
op_eq
id|old_num
)paren
r_return
id|info
(braket
id|i
)braket
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|add_head_def
r_static
r_int
id|add_head_def
c_func
(paren
r_struct
id|pack_info
op_star
id|this
comma
r_int
r_char
op_star
id|sha1
)paren
(brace
r_if
c_cond
(paren
id|this-&gt;nr_alloc
op_le
id|this-&gt;nr_heads
)paren
(brace
id|this-&gt;nr_alloc
op_assign
id|alloc_nr
c_func
(paren
id|this-&gt;nr_alloc
)paren
suffix:semicolon
id|this-&gt;head
op_assign
id|xrealloc
c_func
(paren
id|this-&gt;head
comma
id|this-&gt;nr_alloc
op_star
l_int|20
)paren
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|this-&gt;head
(braket
id|this-&gt;nr_heads
op_increment
)braket
comma
id|sha1
comma
l_int|20
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Returns non-zero when we detect that the info in the&n; * old file is useless.&n; */
DECL|function|parse_pack_def
r_static
r_int
id|parse_pack_def
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_int
id|old_cnt
)paren
(brace
r_struct
id|pack_info
op_star
id|i
op_assign
id|find_pack_by_name
c_func
(paren
id|line
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
(brace
id|i-&gt;old_num
op_assign
id|old_cnt
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* The file describes a pack that is no longer here;&n;&t;&t; * dependencies between packs needs to be recalculated.&n;&t;&t; */
r_return
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* Returns non-zero when we detect that the info in the&n; * old file is useless.&n; */
DECL|function|parse_depend_def
r_static
r_int
id|parse_depend_def
c_func
(paren
r_char
op_star
id|line
)paren
(brace
r_int
r_int
id|num
suffix:semicolon
r_char
op_star
id|cp
comma
op_star
id|ep
suffix:semicolon
r_struct
id|pack_info
op_star
id|this
comma
op_star
id|that
suffix:semicolon
id|cp
op_assign
id|line
op_plus
l_int|2
suffix:semicolon
id|num
op_assign
id|strtoul
c_func
(paren
id|cp
comma
op_amp
id|ep
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ep
op_eq
id|cp
)paren
r_return
id|error
c_func
(paren
l_string|&quot;invalid input %s&quot;
comma
id|line
)paren
suffix:semicolon
id|this
op_assign
id|find_pack_by_old_num
c_func
(paren
id|num
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|this
)paren
r_return
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|ep
op_logical_and
op_star
(paren
id|cp
op_assign
id|ep
)paren
)paren
(brace
id|num
op_assign
id|strtoul
c_func
(paren
id|cp
comma
op_amp
id|ep
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ep
op_eq
id|cp
)paren
r_break
suffix:semicolon
id|that
op_assign
id|find_pack_by_old_num
c_func
(paren
id|num
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|that
)paren
multiline_comment|/* The pack this one depends on does not&n;&t;&t;&t; * exist; this should not happen because&n;&t;&t;&t; * we write out the list of packs first and&n;&t;&t;&t; * then dependency information, but it means&n;&t;&t;&t; * the file is useless anyway.&n;&t;&t;&t; */
r_return
l_int|1
suffix:semicolon
id|this-&gt;dep
(braket
id|that-&gt;new_num
)braket
op_assign
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Returns non-zero when we detect that the info in the&n; * old file is useless.&n; */
DECL|function|parse_head_def
r_static
r_int
id|parse_head_def
c_func
(paren
r_char
op_star
id|line
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_int
r_int
id|num
suffix:semicolon
r_char
op_star
id|cp
comma
op_star
id|ep
suffix:semicolon
r_struct
id|pack_info
op_star
id|this
suffix:semicolon
r_struct
id|object
op_star
id|o
suffix:semicolon
id|cp
op_assign
id|line
op_plus
l_int|2
suffix:semicolon
id|num
op_assign
id|strtoul
c_func
(paren
id|cp
comma
op_amp
id|ep
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ep
op_eq
id|cp
op_logical_or
op_star
id|ep
op_increment
op_ne
l_char|&squot; &squot;
)paren
r_return
id|error
c_func
(paren
l_string|&quot;invalid input ix %s&quot;
comma
id|line
)paren
suffix:semicolon
id|this
op_assign
id|find_pack_by_old_num
c_func
(paren
id|num
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|this
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* You know the drill. */
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|ep
comma
id|sha1
)paren
op_logical_or
id|ep
(braket
l_int|40
)braket
op_ne
l_char|&squot; &squot;
)paren
r_return
id|error
c_func
(paren
l_string|&quot;invalid input sha1 %s (%s)&quot;
comma
id|line
comma
id|ep
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|o
op_assign
id|parse_object_cheap
c_func
(paren
id|sha1
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
id|error
c_func
(paren
l_string|&quot;no such object: %s&quot;
comma
id|line
)paren
suffix:semicolon
r_return
id|add_head_def
c_func
(paren
id|this
comma
id|sha1
)paren
suffix:semicolon
)brace
multiline_comment|/* Returns non-zero when we detect that the info in the&n; * old file is useless.&n; */
DECL|function|read_pack_info_file
r_static
r_int
id|read_pack_info_file
c_func
(paren
r_const
r_char
op_star
id|infofile
)paren
(brace
id|FILE
op_star
id|fp
suffix:semicolon
r_char
id|line
(braket
l_int|1000
)braket
suffix:semicolon
r_int
id|old_cnt
op_assign
l_int|0
suffix:semicolon
id|fp
op_assign
id|fopen
c_func
(paren
id|infofile
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fp
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* nonexisting is not an error. */
r_while
c_loop
(paren
id|fgets
c_func
(paren
id|line
comma
r_sizeof
(paren
id|line
)paren
comma
id|fp
)paren
)paren
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|line
)paren
suffix:semicolon
r_if
c_cond
(paren
id|line
(braket
id|len
op_minus
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|line
(braket
id|len
op_minus
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|line
(braket
l_int|0
)braket
)paren
(brace
r_case
l_char|&squot;P&squot;
suffix:colon
multiline_comment|/* P name */
r_if
c_cond
(paren
id|parse_pack_def
c_func
(paren
id|line
comma
id|old_cnt
op_increment
)paren
)paren
r_goto
id|out_stale
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;D&squot;
suffix:colon
multiline_comment|/* D ix dep-ix1 dep-ix2... */
r_if
c_cond
(paren
id|parse_depend_def
c_func
(paren
id|line
)paren
)paren
r_goto
id|out_stale
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;T&squot;
suffix:colon
multiline_comment|/* T ix sha1 type */
r_if
c_cond
(paren
id|parse_head_def
c_func
(paren
id|line
)paren
)paren
r_goto
id|out_stale
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|error
c_func
(paren
l_string|&quot;unrecognized: %s&quot;
comma
id|line
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|fclose
c_func
(paren
id|fp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_stale
suffix:colon
id|fclose
c_func
(paren
id|fp
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* We sort the packs according to the date of the latest commit.  That&n; * in turn indicates how young the pack is, and in general we would&n; * want to depend on younger packs.&n; */
DECL|function|get_latest_commit_date
r_static
r_int
r_int
id|get_latest_commit_date
c_func
(paren
r_struct
id|packed_git
op_star
id|p
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_struct
id|object
op_star
id|o
suffix:semicolon
r_int
id|num
op_assign
id|num_packed_objects
c_func
(paren
id|p
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|latest
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|nth_packed_object_sha1
c_func
(paren
id|p
comma
id|i
comma
id|sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;corrupt pack file %s?&quot;
comma
id|p-&gt;pack_name
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|o
op_assign
id|parse_object_cheap
c_func
(paren
id|sha1
)paren
)paren
op_eq
l_int|NULL
)paren
id|die
c_func
(paren
l_string|&quot;cannot parse %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|o-&gt;type
op_eq
id|commit_type
)paren
(brace
r_struct
id|commit
op_star
id|commit
op_assign
(paren
r_struct
id|commit
op_star
)paren
id|o
suffix:semicolon
r_if
c_cond
(paren
id|latest
OL
id|commit-&gt;date
)paren
id|latest
op_assign
id|commit-&gt;date
suffix:semicolon
)brace
)brace
r_return
id|latest
suffix:semicolon
)brace
DECL|function|compare_info
r_static
r_int
id|compare_info
c_func
(paren
r_const
r_void
op_star
id|a_
comma
r_const
r_void
op_star
id|b_
)paren
(brace
r_struct
id|pack_info
op_star
r_const
op_star
id|a
op_assign
id|a_
suffix:semicolon
r_struct
id|pack_info
op_star
r_const
op_star
id|b
op_assign
id|b_
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_le
(paren
op_star
id|a
)paren
op_member_access_from_pointer
id|old_num
op_logical_and
l_int|0
op_le
(paren
op_star
id|b
)paren
op_member_access_from_pointer
id|old_num
)paren
multiline_comment|/* Keep the order in the original */
r_return
(paren
op_star
id|a
)paren
op_member_access_from_pointer
id|old_num
(paren
op_star
id|b
)paren
op_member_access_from_pointer
id|old_num
suffix:semicolon
r_else
r_if
c_cond
(paren
l_int|0
op_le
(paren
op_star
id|a
)paren
op_member_access_from_pointer
id|old_num
)paren
multiline_comment|/* Only A existed in the original so B is obviously newer */
r_return
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
l_int|0
op_le
(paren
op_star
id|b
)paren
op_member_access_from_pointer
id|old_num
)paren
multiline_comment|/* The other way around. */
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|a
)paren
op_member_access_from_pointer
id|latest
OL
(paren
op_star
id|b
)paren
op_member_access_from_pointer
id|latest
)paren
r_return
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
op_star
id|a
)paren
op_member_access_from_pointer
id|latest
op_eq
(paren
op_star
id|b
)paren
op_member_access_from_pointer
id|latest
)paren
r_return
l_int|0
suffix:semicolon
r_else
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|init_pack_info
r_static
r_void
id|init_pack_info
c_func
(paren
r_const
r_char
op_star
id|infofile
comma
r_int
id|force
)paren
(brace
r_struct
id|packed_git
op_star
id|p
suffix:semicolon
r_int
id|stale
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|dep_temp
suffix:semicolon
id|objdir
op_assign
id|get_object_directory
c_func
(paren
)paren
suffix:semicolon
id|objdirlen
op_assign
id|strlen
c_func
(paren
id|objdir
)paren
suffix:semicolon
id|prepare_packed_git
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|packed_git
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
multiline_comment|/* we ignore things on alternate path since they are&n;&t;&t; * not available to the pullers in general.&n;&t;&t; */
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|p-&gt;pack_name
comma
id|objdir
comma
id|objdirlen
)paren
op_logical_or
id|strncmp
c_func
(paren
id|p-&gt;pack_name
op_plus
id|objdirlen
comma
l_string|&quot;/pack/&quot;
comma
l_int|6
)paren
)paren
r_continue
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
id|num_pack
op_assign
id|i
suffix:semicolon
id|info
op_assign
id|xcalloc
c_func
(paren
id|num_pack
comma
r_sizeof
(paren
r_struct
id|pack_info
op_star
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|p
op_assign
id|packed_git
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|p-&gt;pack_name
comma
id|objdir
comma
id|objdirlen
)paren
op_logical_or
id|p-&gt;pack_name
(braket
id|objdirlen
)braket
op_ne
l_char|&squot;/&squot;
)paren
r_continue
suffix:semicolon
id|info
(braket
id|i
)braket
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|pack_info
)paren
op_plus
id|num_pack
)paren
suffix:semicolon
id|info
(braket
id|i
)braket
op_member_access_from_pointer
id|p
op_assign
id|p
suffix:semicolon
id|info
(braket
id|i
)braket
op_member_access_from_pointer
id|old_num
op_assign
l_int|1
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|infofile
op_logical_and
op_logical_neg
id|force
)paren
id|stale
op_assign
id|read_pack_info_file
c_func
(paren
id|infofile
)paren
suffix:semicolon
r_else
id|stale
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_pack
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|stale
)paren
(brace
id|info
(braket
id|i
)braket
op_member_access_from_pointer
id|old_num
op_assign
l_int|1
suffix:semicolon
id|memset
c_func
(paren
id|info
(braket
id|i
)braket
op_member_access_from_pointer
id|dep
comma
l_int|0
comma
id|num_pack
)paren
suffix:semicolon
id|info
(braket
id|i
)braket
op_member_access_from_pointer
id|nr_heads
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info
(braket
id|i
)braket
op_member_access_from_pointer
id|old_num
OL
l_int|0
)paren
id|info
(braket
id|i
)braket
op_member_access_from_pointer
id|latest
op_assign
id|get_latest_commit_date
c_func
(paren
id|info
(braket
id|i
)braket
op_member_access_from_pointer
id|p
)paren
suffix:semicolon
)brace
id|qsort
c_func
(paren
id|info
comma
id|num_pack
comma
r_sizeof
(paren
id|info
(braket
l_int|0
)braket
)paren
comma
id|compare_info
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_pack
suffix:semicolon
id|i
op_increment
)paren
id|info
(braket
id|i
)braket
op_member_access_from_pointer
id|new_num
op_assign
id|i
suffix:semicolon
multiline_comment|/* we need to fix up the dependency information&n;&t; * for the old ones.&n;&t; */
id|dep_temp
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_pack
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|old
suffix:semicolon
r_if
c_cond
(paren
id|info
(braket
id|i
)braket
op_member_access_from_pointer
id|old_num
OL
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dep_temp
)paren
id|dep_temp
op_assign
id|xmalloc
c_func
(paren
id|num_pack
)paren
suffix:semicolon
id|memset
c_func
(paren
id|dep_temp
comma
l_int|0
comma
id|num_pack
)paren
suffix:semicolon
r_for
c_loop
(paren
id|old
op_assign
l_int|0
suffix:semicolon
id|old
OL
id|num_pack
suffix:semicolon
id|old
op_increment
)paren
(brace
r_struct
id|pack_info
op_star
id|base
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info
(braket
id|i
)braket
op_member_access_from_pointer
id|dep
(braket
id|old
)braket
)paren
r_continue
suffix:semicolon
id|base
op_assign
id|find_pack_by_old_num
c_func
(paren
id|old
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|base
)paren
id|die
c_func
(paren
l_string|&quot;internal error renumbering&quot;
)paren
suffix:semicolon
id|dep_temp
(braket
id|base-&gt;new_num
)braket
op_assign
l_int|1
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|info
(braket
id|i
)braket
op_member_access_from_pointer
id|dep
comma
id|dep_temp
comma
id|num_pack
)paren
suffix:semicolon
)brace
id|free
c_func
(paren
id|dep_temp
)paren
suffix:semicolon
)brace
DECL|function|write_pack_info_file
r_static
r_void
id|write_pack_info_file
c_func
(paren
id|FILE
op_star
id|fp
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_pack
suffix:semicolon
id|i
op_increment
)paren
id|fprintf
c_func
(paren
id|fp
comma
l_string|&quot;P %s&bslash;n&quot;
comma
id|info
(braket
id|i
)braket
op_member_access_from_pointer
id|p-&gt;pack_name
op_plus
id|objdirlen
op_plus
l_int|6
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_pack
suffix:semicolon
id|i
op_increment
)paren
(brace
id|fprintf
c_func
(paren
id|fp
comma
l_string|&quot;D %1d&quot;
comma
id|i
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|num_pack
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|i
op_eq
id|j
)paren
op_logical_or
op_logical_neg
(paren
id|info
(braket
id|i
)braket
op_member_access_from_pointer
id|dep
(braket
id|j
)braket
)paren
)paren
r_continue
suffix:semicolon
id|fprintf
c_func
(paren
id|fp
comma
l_string|&quot; %1d&quot;
comma
id|j
)paren
suffix:semicolon
)brace
id|fputc
c_func
(paren
l_char|&squot;&bslash;n&squot;
comma
id|fp
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_pack
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|pack_info
op_star
id|this
op_assign
id|info
(braket
id|i
)braket
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|this-&gt;nr_heads
suffix:semicolon
id|j
op_increment
)paren
(brace
r_struct
id|object
op_star
id|o
op_assign
id|lookup_object
c_func
(paren
id|this-&gt;head
(braket
id|j
)braket
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|fp
comma
l_string|&quot;T %1d %s %s&bslash;n&quot;
comma
id|i
comma
id|sha1_to_hex
c_func
(paren
id|this-&gt;head
(braket
id|j
)braket
)paren
comma
id|o-&gt;type
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|macro|REFERENCED
mdefine_line|#define REFERENCED 01
DECL|macro|INTERNAL
mdefine_line|#define INTERNAL  02
DECL|macro|EMITTED
mdefine_line|#define EMITTED   04
DECL|function|show
r_static
r_void
id|show
c_func
(paren
r_struct
id|object
op_star
id|o
comma
r_int
id|pack_ix
)paren
(brace
multiline_comment|/*&n;&t; * We are interested in objects that are not referenced,&n;&t; * and objects that are referenced but not internal.&n;&t; */
r_if
c_cond
(paren
id|o-&gt;flags
op_amp
id|EMITTED
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|o-&gt;flags
op_amp
id|REFERENCED
)paren
)paren
id|add_head_def
c_func
(paren
id|info
(braket
id|pack_ix
)braket
comma
id|o-&gt;sha1
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|o-&gt;flags
op_amp
id|REFERENCED
)paren
op_logical_and
op_logical_neg
(paren
id|o-&gt;flags
op_amp
id|INTERNAL
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* Which pack contains this object?  That is what&n;&t;&t; * pack_ix can depend on.  We earlier sorted info&n;&t;&t; * array from youngest to oldest, so try newer packs&n;&t;&t; * first to favor them here.&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
id|num_pack
l_int|1
suffix:semicolon
l_int|0
op_le
id|i
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_struct
id|packed_git
op_star
id|p
op_assign
id|info
(braket
id|i
)braket
op_member_access_from_pointer
id|p
suffix:semicolon
r_struct
id|pack_entry
id|ent
suffix:semicolon
r_if
c_cond
(paren
id|find_pack_entry_one
c_func
(paren
id|o-&gt;sha1
comma
op_amp
id|ent
comma
id|p
)paren
)paren
(brace
id|info
(braket
id|pack_ix
)braket
op_member_access_from_pointer
id|dep
(braket
id|i
)braket
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
id|o-&gt;flags
op_or_assign
id|EMITTED
suffix:semicolon
)brace
DECL|function|find_pack_info_one
r_static
r_void
id|find_pack_info_one
c_func
(paren
r_int
id|pack_ix
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_struct
id|object
op_star
id|o
suffix:semicolon
r_struct
id|object_list
op_star
id|ref
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|packed_git
op_star
id|p
op_assign
id|info
(braket
id|pack_ix
)braket
op_member_access_from_pointer
id|p
suffix:semicolon
r_int
id|num
op_assign
id|num_packed_objects
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/* Scan objects, clear flags from all the edge ones and&n;&t; * internal ones, possibly marked in the previous round.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|nth_packed_object_sha1
c_func
(paren
id|p
comma
id|i
comma
id|sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;corrupt pack file %s?&quot;
comma
id|p-&gt;pack_name
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|o
op_assign
id|lookup_object
c_func
(paren
id|sha1
)paren
)paren
op_eq
l_int|NULL
)paren
id|die
c_func
(paren
l_string|&quot;cannot parse %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ref
op_assign
id|o-&gt;refs
suffix:semicolon
id|ref
suffix:semicolon
id|ref
op_assign
id|ref-&gt;next
)paren
id|ref-&gt;item-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|o-&gt;flags
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Mark all the internal ones */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|nth_packed_object_sha1
c_func
(paren
id|p
comma
id|i
comma
id|sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;corrupt pack file %s?&quot;
comma
id|p-&gt;pack_name
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|o
op_assign
id|lookup_object
c_func
(paren
id|sha1
)paren
)paren
op_eq
l_int|NULL
)paren
id|die
c_func
(paren
l_string|&quot;cannot find %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ref
op_assign
id|o-&gt;refs
suffix:semicolon
id|ref
suffix:semicolon
id|ref
op_assign
id|ref-&gt;next
)paren
id|ref-&gt;item-&gt;flags
op_or_assign
id|REFERENCED
suffix:semicolon
id|o-&gt;flags
op_or_assign
id|INTERNAL
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|nth_packed_object_sha1
c_func
(paren
id|p
comma
id|i
comma
id|sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;corrupt pack file %s?&quot;
comma
id|p-&gt;pack_name
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|o
op_assign
id|lookup_object
c_func
(paren
id|sha1
)paren
)paren
op_eq
l_int|NULL
)paren
id|die
c_func
(paren
l_string|&quot;cannot find %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
id|show
c_func
(paren
id|o
comma
id|pack_ix
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ref
op_assign
id|o-&gt;refs
suffix:semicolon
id|ref
suffix:semicolon
id|ref
op_assign
id|ref-&gt;next
)paren
id|show
c_func
(paren
id|ref-&gt;item
comma
id|pack_ix
)paren
suffix:semicolon
)brace
)brace
DECL|function|find_pack_info
r_static
r_void
id|find_pack_info
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_pack
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* The packed objects are cast in stone, and a head&n;&t;&t; * in a pack will stay as head, so is the set of missing&n;&t;&t; * objects.  If the repo has been reorganized and we&n;&t;&t; * are missing some packs available back then, we have&n;&t;&t; * already discarded the info read from the file, so&n;&t;&t; * we will find (old_num &lt; 0) in that case.&n;&t;&t; */
r_if
c_cond
(paren
l_int|0
op_le
id|info
(braket
id|i
)braket
op_member_access_from_pointer
id|old_num
)paren
r_continue
suffix:semicolon
id|find_pack_info_one
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
)brace
DECL|function|update_info_packs
r_static
r_int
id|update_info_packs
c_func
(paren
r_int
id|force
)paren
(brace
r_char
id|infofile
(braket
id|PATH_MAX
)braket
suffix:semicolon
r_char
id|name
(braket
id|PATH_MAX
)braket
suffix:semicolon
r_int
id|namelen
suffix:semicolon
id|FILE
op_star
id|fp
suffix:semicolon
id|namelen
op_assign
id|sprintf
c_func
(paren
id|infofile
comma
l_string|&quot;%s/info/packs&quot;
comma
id|get_object_directory
c_func
(paren
)paren
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|name
comma
id|infofile
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|name
op_plus
id|namelen
comma
l_string|&quot;+&quot;
)paren
suffix:semicolon
id|init_pack_info
c_func
(paren
id|infofile
comma
id|force
)paren
suffix:semicolon
id|find_pack_info
c_func
(paren
)paren
suffix:semicolon
id|safe_create_leading_directories
c_func
(paren
id|name
)paren
suffix:semicolon
id|fp
op_assign
id|fopen
c_func
(paren
id|name
comma
l_string|&quot;w&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fp
)paren
r_return
id|error
c_func
(paren
l_string|&quot;cannot open %s&quot;
comma
id|name
)paren
suffix:semicolon
id|write_pack_info_file
c_func
(paren
id|fp
)paren
suffix:semicolon
id|fclose
c_func
(paren
id|fp
)paren
suffix:semicolon
id|rename
c_func
(paren
id|name
comma
id|infofile
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* rev-cache */
DECL|function|record_rev_cache_ref
r_static
r_int
id|record_rev_cache_ref
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_const
r_int
r_char
op_star
id|sha1
)paren
(brace
r_struct
id|commit
op_star
id|commit
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|commit
op_assign
id|lookup_commit_reference
c_func
(paren
id|sha1
)paren
)paren
)paren
r_return
id|error
c_func
(paren
l_string|&quot;not a commit: %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
r_return
id|record_rev_cache
c_func
(paren
id|commit-&gt;object.sha1
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|update_info_revs
r_static
r_int
id|update_info_revs
c_func
(paren
r_int
id|force
)paren
(brace
r_char
op_star
id|path0
op_assign
id|strdup
c_func
(paren
id|git_path
c_func
(paren
l_string|&quot;info/rev-cache&quot;
)paren
)paren
suffix:semicolon
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|path0
)paren
suffix:semicolon
r_char
op_star
id|path1
op_assign
id|xmalloc
c_func
(paren
id|len
op_plus
l_int|2
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|path1
comma
id|path0
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|path1
op_plus
id|len
comma
l_string|&quot;+&quot;
)paren
suffix:semicolon
multiline_comment|/* read existing rev-cache */
r_if
c_cond
(paren
op_logical_neg
id|force
)paren
id|read_rev_cache
c_func
(paren
id|path0
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|safe_create_leading_directories
c_func
(paren
id|path0
)paren
suffix:semicolon
id|for_each_ref
c_func
(paren
id|record_rev_cache_ref
)paren
suffix:semicolon
multiline_comment|/* update the rev-cache database */
id|write_rev_cache
c_func
(paren
id|path1
comma
id|force
ques
c_cond
l_string|&quot;/dev/null&quot;
suffix:colon
id|path0
)paren
suffix:semicolon
id|rename
c_func
(paren
id|path1
comma
id|path0
)paren
suffix:semicolon
id|free
c_func
(paren
id|path1
)paren
suffix:semicolon
id|free
c_func
(paren
id|path0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* public */
DECL|function|update_server_info
r_int
id|update_server_info
c_func
(paren
r_int
id|force
)paren
(brace
multiline_comment|/* We would add more dumb-server support files later,&n;&t; * including index of available pack files and their&n;&t; * intended audiences.&n;&t; */
r_int
id|errs
op_assign
l_int|0
suffix:semicolon
id|errs
op_assign
id|errs
op_or
id|update_info_refs
c_func
(paren
id|force
)paren
suffix:semicolon
id|errs
op_assign
id|errs
op_or
id|update_info_packs
c_func
(paren
id|force
)paren
suffix:semicolon
id|errs
op_assign
id|errs
op_or
id|update_info_revs
c_func
(paren
id|force
)paren
suffix:semicolon
r_return
id|errs
suffix:semicolon
)brace
eof
