macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;refs.h&quot;
macro_line|#include &quot;tag.h&quot;
macro_line|#include &quot;commit.h&quot;
macro_line|#include &quot;blob.h&quot;
macro_line|#include &quot;diff.h&quot;
macro_line|#include &quot;revision.h&quot;
macro_line|#include &quot;reachable.h&quot;
macro_line|#include &quot;cache-tree.h&quot;
macro_line|#include &quot;progress.h&quot;
macro_line|#include &quot;list-objects.h&quot;
DECL|struct|connectivity_progress
r_struct
id|connectivity_progress
(brace
DECL|member|progress
r_struct
id|progress
op_star
id|progress
suffix:semicolon
DECL|member|count
r_int
r_int
id|count
suffix:semicolon
)brace
suffix:semicolon
DECL|function|update_progress
r_static
r_void
id|update_progress
c_func
(paren
r_struct
id|connectivity_progress
op_star
id|cp
)paren
(brace
id|cp-&gt;count
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cp-&gt;count
op_amp
l_int|1023
)paren
op_eq
l_int|0
)paren
id|display_progress
c_func
(paren
id|cp-&gt;progress
comma
id|cp-&gt;count
)paren
suffix:semicolon
)brace
DECL|function|add_one_ref
r_static
r_int
id|add_one_ref
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
id|flag
comma
r_void
op_star
id|cb_data
)paren
(brace
r_struct
id|object
op_star
id|object
op_assign
id|parse_object_or_die
c_func
(paren
id|sha1
comma
id|path
)paren
suffix:semicolon
r_struct
id|rev_info
op_star
id|revs
op_assign
(paren
r_struct
id|rev_info
op_star
)paren
id|cb_data
suffix:semicolon
id|add_pending_object
c_func
(paren
id|revs
comma
id|object
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|add_one_tree
r_static
r_void
id|add_one_tree
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
comma
r_struct
id|rev_info
op_star
id|revs
)paren
(brace
r_struct
id|tree
op_star
id|tree
op_assign
id|lookup_tree
c_func
(paren
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tree
)paren
id|add_pending_object
c_func
(paren
id|revs
comma
op_amp
id|tree-&gt;object
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
DECL|function|add_cache_tree
r_static
r_void
id|add_cache_tree
c_func
(paren
r_struct
id|cache_tree
op_star
id|it
comma
r_struct
id|rev_info
op_star
id|revs
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|it-&gt;entry_count
op_ge
l_int|0
)paren
id|add_one_tree
c_func
(paren
id|it-&gt;sha1
comma
id|revs
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|it-&gt;subtree_nr
suffix:semicolon
id|i
op_increment
)paren
id|add_cache_tree
c_func
(paren
id|it-&gt;down
(braket
id|i
)braket
op_member_access_from_pointer
id|cache_tree
comma
id|revs
)paren
suffix:semicolon
)brace
DECL|function|add_cache_refs
r_static
r_void
id|add_cache_refs
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
)paren
(brace
r_int
id|i
suffix:semicolon
id|read_cache
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|active_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|blob
op_star
id|blob
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The index can contain blobs and GITLINKs, GITLINKs are hashes&n;&t;&t; * that don&squot;t actually point to objects in the repository, it&squot;s&n;&t;&t; * almost guaranteed that they are NOT blobs, so we don&squot;t call&n;&t;&t; * lookup_blob() on them, to avoid populating the hash table&n;&t;&t; * with invalid information&n;&t;&t; */
r_if
c_cond
(paren
id|S_ISGITLINK
c_func
(paren
id|active_cache
(braket
id|i
)braket
op_member_access_from_pointer
id|ce_mode
)paren
)paren
r_continue
suffix:semicolon
id|blob
op_assign
id|lookup_blob
c_func
(paren
id|active_cache
(braket
id|i
)braket
op_member_access_from_pointer
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blob
)paren
id|blob-&gt;object.flags
op_or_assign
id|SEEN
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We could add the blobs to the pending list, but quite&n;&t;&t; * frankly, we don&squot;t care. Once we&squot;ve looked them up, and&n;&t;&t; * added them as objects, we&squot;ve really done everything&n;&t;&t; * there is to do for a blob&n;&t;&t; */
)brace
r_if
c_cond
(paren
id|active_cache_tree
)paren
id|add_cache_tree
c_func
(paren
id|active_cache_tree
comma
id|revs
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The traversal will have already marked us as SEEN, so we&n; * only need to handle any progress reporting here.&n; */
DECL|function|mark_object
r_static
r_void
id|mark_object
c_func
(paren
r_struct
id|object
op_star
id|obj
comma
r_const
r_struct
id|name_path
op_star
id|path
comma
r_const
r_char
op_star
id|name
comma
r_void
op_star
id|data
)paren
(brace
id|update_progress
c_func
(paren
id|data
)paren
suffix:semicolon
)brace
DECL|function|mark_commit
r_static
r_void
id|mark_commit
c_func
(paren
r_struct
id|commit
op_star
id|c
comma
r_void
op_star
id|data
)paren
(brace
id|mark_object
c_func
(paren
op_amp
id|c-&gt;object
comma
l_int|NULL
comma
l_int|NULL
comma
id|data
)paren
suffix:semicolon
)brace
DECL|function|mark_reachable_objects
r_void
id|mark_reachable_objects
c_func
(paren
r_struct
id|rev_info
op_star
id|revs
comma
r_int
id|mark_reflog
comma
r_struct
id|progress
op_star
id|progress
)paren
(brace
r_struct
id|connectivity_progress
id|cp
suffix:semicolon
multiline_comment|/*&n;&t; * Set up revision parsing, and mark us as being interested&n;&t; * in all object types, not just commits.&n;&t; */
id|revs-&gt;tag_objects
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;blob_objects
op_assign
l_int|1
suffix:semicolon
id|revs-&gt;tree_objects
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Add all refs from the index file */
id|add_cache_refs
c_func
(paren
id|revs
)paren
suffix:semicolon
multiline_comment|/* Add all external refs */
id|for_each_ref
c_func
(paren
id|add_one_ref
comma
id|revs
)paren
suffix:semicolon
multiline_comment|/* detached HEAD is not included in the list above */
id|head_ref
c_func
(paren
id|add_one_ref
comma
id|revs
)paren
suffix:semicolon
multiline_comment|/* Add all reflog info */
r_if
c_cond
(paren
id|mark_reflog
)paren
id|add_reflogs_to_pending
c_func
(paren
id|revs
comma
l_int|0
)paren
suffix:semicolon
id|cp.progress
op_assign
id|progress
suffix:semicolon
id|cp.count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Set up the revision walk - this will move all commits&n;&t; * from the pending list to the commit walking list.&n;&t; */
r_if
c_cond
(paren
id|prepare_revision_walk
c_func
(paren
id|revs
)paren
)paren
id|die
c_func
(paren
l_string|&quot;revision walk setup failed&quot;
)paren
suffix:semicolon
id|traverse_commit_list
c_func
(paren
id|revs
comma
id|mark_commit
comma
id|mark_object
comma
op_amp
id|cp
)paren
suffix:semicolon
id|display_progress
c_func
(paren
id|cp.progress
comma
id|cp.count
)paren
suffix:semicolon
)brace
eof
