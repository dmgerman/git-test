macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;object.h&quot;
macro_line|#include &quot;blob.h&quot;
macro_line|#include &quot;tree.h&quot;
macro_line|#include &quot;tree-walk.h&quot;
macro_line|#include &quot;commit.h&quot;
macro_line|#include &quot;tag.h&quot;
macro_line|#include &quot;fsck.h&quot;
macro_line|#include &quot;refs.h&quot;
macro_line|#include &quot;utf8.h&quot;
macro_line|#include &quot;sha1-array.h&quot;
DECL|macro|FSCK_FATAL
mdefine_line|#define FSCK_FATAL -1
DECL|macro|FSCK_INFO
mdefine_line|#define FSCK_INFO -2
DECL|macro|FOREACH_MSG_ID
mdefine_line|#define FOREACH_MSG_ID(FUNC) &bslash;&n;&t;/* fatal errors */ &bslash;&n;&t;FUNC(NUL_IN_HEADER, FATAL) &bslash;&n;&t;FUNC(UNTERMINATED_HEADER, FATAL) &bslash;&n;&t;/* errors */ &bslash;&n;&t;FUNC(BAD_DATE, ERROR) &bslash;&n;&t;FUNC(BAD_DATE_OVERFLOW, ERROR) &bslash;&n;&t;FUNC(BAD_EMAIL, ERROR) &bslash;&n;&t;FUNC(BAD_NAME, ERROR) &bslash;&n;&t;FUNC(BAD_OBJECT_SHA1, ERROR) &bslash;&n;&t;FUNC(BAD_PARENT_SHA1, ERROR) &bslash;&n;&t;FUNC(BAD_TAG_OBJECT, ERROR) &bslash;&n;&t;FUNC(BAD_TIMEZONE, ERROR) &bslash;&n;&t;FUNC(BAD_TREE, ERROR) &bslash;&n;&t;FUNC(BAD_TREE_SHA1, ERROR) &bslash;&n;&t;FUNC(BAD_TYPE, ERROR) &bslash;&n;&t;FUNC(DUPLICATE_ENTRIES, ERROR) &bslash;&n;&t;FUNC(MISSING_AUTHOR, ERROR) &bslash;&n;&t;FUNC(MISSING_COMMITTER, ERROR) &bslash;&n;&t;FUNC(MISSING_EMAIL, ERROR) &bslash;&n;&t;FUNC(MISSING_GRAFT, ERROR) &bslash;&n;&t;FUNC(MISSING_NAME_BEFORE_EMAIL, ERROR) &bslash;&n;&t;FUNC(MISSING_OBJECT, ERROR) &bslash;&n;&t;FUNC(MISSING_PARENT, ERROR) &bslash;&n;&t;FUNC(MISSING_SPACE_BEFORE_DATE, ERROR) &bslash;&n;&t;FUNC(MISSING_SPACE_BEFORE_EMAIL, ERROR) &bslash;&n;&t;FUNC(MISSING_TAG, ERROR) &bslash;&n;&t;FUNC(MISSING_TAG_ENTRY, ERROR) &bslash;&n;&t;FUNC(MISSING_TAG_OBJECT, ERROR) &bslash;&n;&t;FUNC(MISSING_TREE, ERROR) &bslash;&n;&t;FUNC(MISSING_TYPE, ERROR) &bslash;&n;&t;FUNC(MISSING_TYPE_ENTRY, ERROR) &bslash;&n;&t;FUNC(MULTIPLE_AUTHORS, ERROR) &bslash;&n;&t;FUNC(TAG_OBJECT_NOT_TAG, ERROR) &bslash;&n;&t;FUNC(TREE_NOT_SORTED, ERROR) &bslash;&n;&t;FUNC(UNKNOWN_TYPE, ERROR) &bslash;&n;&t;FUNC(ZERO_PADDED_DATE, ERROR) &bslash;&n;&t;/* warnings */ &bslash;&n;&t;FUNC(BAD_FILEMODE, WARN) &bslash;&n;&t;FUNC(EMPTY_NAME, WARN) &bslash;&n;&t;FUNC(FULL_PATHNAME, WARN) &bslash;&n;&t;FUNC(HAS_DOT, WARN) &bslash;&n;&t;FUNC(HAS_DOTDOT, WARN) &bslash;&n;&t;FUNC(HAS_DOTGIT, WARN) &bslash;&n;&t;FUNC(NULL_SHA1, WARN) &bslash;&n;&t;FUNC(ZERO_PADDED_FILEMODE, WARN) &bslash;&n;&t;/* infos (reported as warnings, but ignored by default) */ &bslash;&n;&t;FUNC(BAD_TAG_NAME, INFO) &bslash;&n;&t;FUNC(MISSING_TAGGER_ENTRY, INFO)
DECL|macro|MSG_ID
mdefine_line|#define MSG_ID(id, msg_type) FSCK_MSG_##id,
DECL|enum|fsck_msg_id
r_enum
id|fsck_msg_id
(brace
DECL|enumerator|FOREACH_MSG_ID
id|FOREACH_MSG_ID
c_func
(paren
id|MSG_ID
)paren
id|FSCK_MSG_MAX
)brace
suffix:semicolon
DECL|macro|MSG_ID
macro_line|#undef MSG_ID
DECL|macro|STR
mdefine_line|#define STR(x) #x
DECL|macro|MSG_ID
mdefine_line|#define MSG_ID(id, msg_type) { STR(id), NULL, FSCK_##msg_type },
r_static
r_struct
(brace
DECL|member|id_string
r_const
r_char
op_star
id|id_string
suffix:semicolon
DECL|member|downcased
r_const
r_char
op_star
id|downcased
suffix:semicolon
DECL|member|msg_type
r_int
id|msg_type
suffix:semicolon
DECL|variable|msg_id_info
)brace
id|msg_id_info
(braket
id|FSCK_MSG_MAX
op_plus
l_int|1
)braket
op_assign
(brace
id|FOREACH_MSG_ID
c_func
(paren
id|MSG_ID
)paren
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|1
)brace
)brace
suffix:semicolon
DECL|macro|MSG_ID
macro_line|#undef MSG_ID
DECL|function|parse_msg_id
r_static
r_int
id|parse_msg_id
c_func
(paren
r_const
r_char
op_star
id|text
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|msg_id_info
(braket
l_int|0
)braket
dot
id|downcased
)paren
(brace
multiline_comment|/* convert id_string to lower case, without underscores. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|FSCK_MSG_MAX
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_char
op_star
id|p
op_assign
id|msg_id_info
(braket
id|i
)braket
dot
id|id_string
suffix:semicolon
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|p
)paren
suffix:semicolon
r_char
op_star
id|q
op_assign
id|xmalloc
c_func
(paren
id|len
)paren
suffix:semicolon
id|msg_id_info
(braket
id|i
)braket
dot
id|downcased
op_assign
id|q
suffix:semicolon
r_while
c_loop
(paren
op_star
id|p
)paren
r_if
c_cond
(paren
op_star
id|p
op_eq
l_char|&squot;_&squot;
)paren
id|p
op_increment
suffix:semicolon
r_else
op_star
(paren
id|q
)paren
op_increment
op_assign
id|tolower
c_func
(paren
op_star
(paren
id|p
)paren
op_increment
)paren
suffix:semicolon
op_star
id|q
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|FSCK_MSG_MAX
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|text
comma
id|msg_id_info
(braket
id|i
)braket
dot
id|downcased
)paren
)paren
r_return
id|i
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|fsck_msg_type
r_static
r_int
id|fsck_msg_type
c_func
(paren
r_enum
id|fsck_msg_id
id|msg_id
comma
r_struct
id|fsck_options
op_star
id|options
)paren
(brace
r_int
id|msg_type
suffix:semicolon
m_assert
(paren
id|msg_id
op_ge
l_int|0
op_logical_and
id|msg_id
OL
id|FSCK_MSG_MAX
)paren
suffix:semicolon
r_if
c_cond
(paren
id|options-&gt;msg_type
)paren
id|msg_type
op_assign
id|options-&gt;msg_type
(braket
id|msg_id
)braket
suffix:semicolon
r_else
(brace
id|msg_type
op_assign
id|msg_id_info
(braket
id|msg_id
)braket
dot
id|msg_type
suffix:semicolon
r_if
c_cond
(paren
id|options-&gt;strict
op_logical_and
id|msg_type
op_eq
id|FSCK_WARN
)paren
id|msg_type
op_assign
id|FSCK_ERROR
suffix:semicolon
)brace
r_return
id|msg_type
suffix:semicolon
)brace
DECL|function|init_skiplist
r_static
r_void
id|init_skiplist
c_func
(paren
r_struct
id|fsck_options
op_star
id|options
comma
r_const
r_char
op_star
id|path
)paren
(brace
r_static
r_struct
id|sha1_array
id|skiplist
op_assign
id|SHA1_ARRAY_INIT
suffix:semicolon
r_int
id|sorted
comma
id|fd
suffix:semicolon
r_char
id|buffer
(braket
l_int|41
)braket
suffix:semicolon
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_if
c_cond
(paren
id|options-&gt;skiplist
)paren
id|sorted
op_assign
id|options-&gt;skiplist-&gt;sorted
suffix:semicolon
r_else
(brace
id|sorted
op_assign
l_int|1
suffix:semicolon
id|options-&gt;skiplist
op_assign
op_amp
id|skiplist
suffix:semicolon
)brace
id|fd
op_assign
id|open
c_func
(paren
id|path
comma
id|O_RDONLY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;Could not open skip list: %s&quot;
comma
id|path
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|result
op_assign
id|read_in_full
c_func
(paren
id|fd
comma
id|buffer
comma
r_sizeof
(paren
id|buffer
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
id|die_errno
c_func
(paren
l_string|&quot;Could not read &squot;%s&squot;&quot;
comma
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|buffer
comma
id|sha1
)paren
op_logical_or
id|buffer
(braket
l_int|40
)braket
op_ne
l_char|&squot;&bslash;n&squot;
)paren
id|die
c_func
(paren
l_string|&quot;Invalid SHA-1: %s&quot;
comma
id|buffer
)paren
suffix:semicolon
id|sha1_array_append
c_func
(paren
op_amp
id|skiplist
comma
id|sha1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sorted
op_logical_and
id|skiplist.nr
OG
l_int|1
op_logical_and
id|hashcmp
c_func
(paren
id|skiplist.sha1
(braket
id|skiplist.nr
l_int|2
)braket
comma
id|sha1
)paren
OG
l_int|0
)paren
id|sorted
op_assign
l_int|0
suffix:semicolon
)brace
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sorted
)paren
id|skiplist.sorted
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|parse_msg_type
r_static
r_int
id|parse_msg_type
c_func
(paren
r_const
r_char
op_star
id|str
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|str
comma
l_string|&quot;error&quot;
)paren
)paren
r_return
id|FSCK_ERROR
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|str
comma
l_string|&quot;warn&quot;
)paren
)paren
r_return
id|FSCK_WARN
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|str
comma
l_string|&quot;ignore&quot;
)paren
)paren
r_return
id|FSCK_IGNORE
suffix:semicolon
r_else
id|die
c_func
(paren
l_string|&quot;Unknown fsck message type: &squot;%s&squot;&quot;
comma
id|str
)paren
suffix:semicolon
)brace
DECL|function|is_valid_msg_type
r_int
id|is_valid_msg_type
c_func
(paren
r_const
r_char
op_star
id|msg_id
comma
r_const
r_char
op_star
id|msg_type
)paren
(brace
r_if
c_cond
(paren
id|parse_msg_id
c_func
(paren
id|msg_id
)paren
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|parse_msg_type
c_func
(paren
id|msg_type
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|fsck_set_msg_type
r_void
id|fsck_set_msg_type
c_func
(paren
r_struct
id|fsck_options
op_star
id|options
comma
r_const
r_char
op_star
id|msg_id
comma
r_const
r_char
op_star
id|msg_type
)paren
(brace
r_int
id|id
op_assign
id|parse_msg_id
c_func
(paren
id|msg_id
)paren
comma
id|type
suffix:semicolon
r_if
c_cond
(paren
id|id
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;Unhandled message id: %s&quot;
comma
id|msg_id
)paren
suffix:semicolon
id|type
op_assign
id|parse_msg_type
c_func
(paren
id|msg_type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
id|FSCK_ERROR
op_logical_and
id|msg_id_info
(braket
id|id
)braket
dot
id|msg_type
op_eq
id|FSCK_FATAL
)paren
id|die
c_func
(paren
l_string|&quot;Cannot demote %s to %s&quot;
comma
id|msg_id
comma
id|msg_type
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|options-&gt;msg_type
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
op_star
id|msg_type
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
r_int
)paren
op_star
id|FSCK_MSG_MAX
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|FSCK_MSG_MAX
suffix:semicolon
id|i
op_increment
)paren
id|msg_type
(braket
id|i
)braket
op_assign
id|fsck_msg_type
c_func
(paren
id|i
comma
id|options
)paren
suffix:semicolon
id|options-&gt;msg_type
op_assign
id|msg_type
suffix:semicolon
)brace
id|options-&gt;msg_type
(braket
id|id
)braket
op_assign
id|type
suffix:semicolon
)brace
DECL|function|fsck_set_msg_types
r_void
id|fsck_set_msg_types
c_func
(paren
r_struct
id|fsck_options
op_star
id|options
comma
r_const
r_char
op_star
id|values
)paren
(brace
r_char
op_star
id|buf
op_assign
id|xstrdup
c_func
(paren
id|values
)paren
comma
op_star
id|to_free
op_assign
id|buf
suffix:semicolon
r_int
id|done
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|done
)paren
(brace
r_int
id|len
op_assign
id|strcspn
c_func
(paren
id|buf
comma
l_string|&quot; ,|&quot;
)paren
comma
id|equal
suffix:semicolon
id|done
op_assign
op_logical_neg
id|buf
(braket
id|len
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
(brace
id|buf
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|buf
(braket
id|len
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_for
c_loop
(paren
id|equal
op_assign
l_int|0
suffix:semicolon
id|equal
OL
id|len
op_logical_and
id|buf
(braket
id|equal
)braket
op_ne
l_char|&squot;=&squot;
op_logical_and
id|buf
(braket
id|equal
)braket
op_ne
l_char|&squot;:&squot;
suffix:semicolon
id|equal
op_increment
)paren
id|buf
(braket
id|equal
)braket
op_assign
id|tolower
c_func
(paren
id|buf
(braket
id|equal
)braket
)paren
suffix:semicolon
id|buf
(braket
id|equal
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|buf
comma
l_string|&quot;skiplist&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|equal
op_eq
id|len
)paren
id|die
c_func
(paren
l_string|&quot;skiplist requires a path&quot;
)paren
suffix:semicolon
id|init_skiplist
c_func
(paren
id|options
comma
id|buf
op_plus
id|equal
op_plus
l_int|1
)paren
suffix:semicolon
id|buf
op_add_assign
id|len
op_plus
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|equal
op_eq
id|len
)paren
id|die
c_func
(paren
l_string|&quot;Missing &squot;=&squot;: &squot;%s&squot;&quot;
comma
id|buf
)paren
suffix:semicolon
id|fsck_set_msg_type
c_func
(paren
id|options
comma
id|buf
comma
id|buf
op_plus
id|equal
op_plus
l_int|1
)paren
suffix:semicolon
id|buf
op_add_assign
id|len
op_plus
l_int|1
suffix:semicolon
)brace
id|free
c_func
(paren
id|to_free
)paren
suffix:semicolon
)brace
DECL|function|append_msg_id
r_static
r_void
id|append_msg_id
c_func
(paren
r_struct
id|strbuf
op_star
id|sb
comma
r_const
r_char
op_star
id|msg_id
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_char
id|c
op_assign
op_star
(paren
id|msg_id
)paren
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|c
op_ne
l_char|&squot;_&squot;
)paren
id|strbuf_addch
c_func
(paren
id|sb
comma
id|tolower
c_func
(paren
id|c
)paren
)paren
suffix:semicolon
r_else
(brace
m_assert
(paren
op_star
id|msg_id
)paren
suffix:semicolon
id|strbuf_addch
c_func
(paren
id|sb
comma
op_star
(paren
id|msg_id
)paren
op_increment
)paren
suffix:semicolon
)brace
)brace
id|strbuf_addstr
c_func
(paren
id|sb
comma
l_string|&quot;: &quot;
)paren
suffix:semicolon
)brace
id|__attribute__
c_func
(paren
(paren
id|format
(paren
id|printf
comma
l_int|4
comma
l_int|5
)paren
)paren
)paren
DECL|function|report
r_static
r_int
id|report
c_func
(paren
r_struct
id|fsck_options
op_star
id|options
comma
r_struct
id|object
op_star
id|object
comma
r_enum
id|fsck_msg_id
id|id
comma
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
id|va_list
id|ap
suffix:semicolon
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|msg_type
op_assign
id|fsck_msg_type
c_func
(paren
id|id
comma
id|options
)paren
comma
id|result
suffix:semicolon
r_if
c_cond
(paren
id|msg_type
op_eq
id|FSCK_IGNORE
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|options-&gt;skiplist
op_logical_and
id|object
op_logical_and
id|sha1_array_lookup
c_func
(paren
id|options-&gt;skiplist
comma
id|get_object_hash
c_func
(paren
op_star
id|object
)paren
)paren
op_ge
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|msg_type
op_eq
id|FSCK_FATAL
)paren
id|msg_type
op_assign
id|FSCK_ERROR
suffix:semicolon
r_else
r_if
c_cond
(paren
id|msg_type
op_eq
id|FSCK_INFO
)paren
id|msg_type
op_assign
id|FSCK_WARN
suffix:semicolon
id|append_msg_id
c_func
(paren
op_amp
id|sb
comma
id|msg_id_info
(braket
id|id
)braket
dot
id|id_string
)paren
suffix:semicolon
id|va_start
c_func
(paren
id|ap
comma
id|fmt
)paren
suffix:semicolon
id|strbuf_vaddf
c_func
(paren
op_amp
id|sb
comma
id|fmt
comma
id|ap
)paren
suffix:semicolon
id|result
op_assign
id|options
op_member_access_from_pointer
id|error_func
c_func
(paren
id|object
comma
id|msg_type
comma
id|sb.buf
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|ap
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|fsck_walk_tree
r_static
r_int
id|fsck_walk_tree
c_func
(paren
r_struct
id|tree
op_star
id|tree
comma
r_void
op_star
id|data
comma
r_struct
id|fsck_options
op_star
id|options
)paren
(brace
r_struct
id|tree_desc
id|desc
suffix:semicolon
r_struct
id|name_entry
id|entry
suffix:semicolon
r_int
id|res
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|parse_tree
c_func
(paren
id|tree
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|init_tree_desc
c_func
(paren
op_amp
id|desc
comma
id|tree-&gt;buffer
comma
id|tree-&gt;size
)paren
suffix:semicolon
r_while
c_loop
(paren
id|tree_entry
c_func
(paren
op_amp
id|desc
comma
op_amp
id|entry
)paren
)paren
(brace
r_int
id|result
suffix:semicolon
r_if
c_cond
(paren
id|S_ISGITLINK
c_func
(paren
id|entry.mode
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|entry.mode
)paren
)paren
id|result
op_assign
id|options
op_member_access_from_pointer
id|walk
c_func
(paren
op_amp
id|lookup_tree
c_func
(paren
id|entry.sha1
)paren
op_member_access_from_pointer
id|object
comma
id|OBJ_TREE
comma
id|data
comma
id|options
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|entry.mode
)paren
op_logical_or
id|S_ISLNK
c_func
(paren
id|entry.mode
)paren
)paren
id|result
op_assign
id|options
op_member_access_from_pointer
id|walk
c_func
(paren
op_amp
id|lookup_blob
c_func
(paren
id|entry.sha1
)paren
op_member_access_from_pointer
id|object
comma
id|OBJ_BLOB
comma
id|data
comma
id|options
)paren
suffix:semicolon
r_else
(brace
id|result
op_assign
id|error
c_func
(paren
l_string|&quot;in tree %s: entry %s has bad mode %.6o&quot;
comma
id|oid_to_hex
c_func
(paren
op_amp
id|tree-&gt;object.oid
)paren
comma
id|entry.path
comma
id|entry.mode
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
r_return
id|result
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|res
)paren
id|res
op_assign
id|result
suffix:semicolon
)brace
r_return
id|res
suffix:semicolon
)brace
DECL|function|fsck_walk_commit
r_static
r_int
id|fsck_walk_commit
c_func
(paren
r_struct
id|commit
op_star
id|commit
comma
r_void
op_star
id|data
comma
r_struct
id|fsck_options
op_star
id|options
)paren
(brace
r_struct
id|commit_list
op_star
id|parents
suffix:semicolon
r_int
id|res
suffix:semicolon
r_int
id|result
suffix:semicolon
r_if
c_cond
(paren
id|parse_commit
c_func
(paren
id|commit
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|result
op_assign
id|options
op_member_access_from_pointer
id|walk
c_func
(paren
(paren
r_struct
id|object
op_star
)paren
id|commit-&gt;tree
comma
id|OBJ_TREE
comma
id|data
comma
id|options
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
r_return
id|result
suffix:semicolon
id|res
op_assign
id|result
suffix:semicolon
id|parents
op_assign
id|commit-&gt;parents
suffix:semicolon
r_while
c_loop
(paren
id|parents
)paren
(brace
id|result
op_assign
id|options
op_member_access_from_pointer
id|walk
c_func
(paren
(paren
r_struct
id|object
op_star
)paren
id|parents-&gt;item
comma
id|OBJ_COMMIT
comma
id|data
comma
id|options
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
r_return
id|result
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|res
)paren
id|res
op_assign
id|result
suffix:semicolon
id|parents
op_assign
id|parents-&gt;next
suffix:semicolon
)brace
r_return
id|res
suffix:semicolon
)brace
DECL|function|fsck_walk_tag
r_static
r_int
id|fsck_walk_tag
c_func
(paren
r_struct
id|tag
op_star
id|tag
comma
r_void
op_star
id|data
comma
r_struct
id|fsck_options
op_star
id|options
)paren
(brace
r_if
c_cond
(paren
id|parse_tag
c_func
(paren
id|tag
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
id|options
op_member_access_from_pointer
id|walk
c_func
(paren
id|tag-&gt;tagged
comma
id|OBJ_ANY
comma
id|data
comma
id|options
)paren
suffix:semicolon
)brace
DECL|function|fsck_walk
r_int
id|fsck_walk
c_func
(paren
r_struct
id|object
op_star
id|obj
comma
r_void
op_star
id|data
comma
r_struct
id|fsck_options
op_star
id|options
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|obj
)paren
r_return
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|obj-&gt;type
)paren
(brace
r_case
id|OBJ_BLOB
suffix:colon
r_return
l_int|0
suffix:semicolon
r_case
id|OBJ_TREE
suffix:colon
r_return
id|fsck_walk_tree
c_func
(paren
(paren
r_struct
id|tree
op_star
)paren
id|obj
comma
id|data
comma
id|options
)paren
suffix:semicolon
r_case
id|OBJ_COMMIT
suffix:colon
r_return
id|fsck_walk_commit
c_func
(paren
(paren
r_struct
id|commit
op_star
)paren
id|obj
comma
id|data
comma
id|options
)paren
suffix:semicolon
r_case
id|OBJ_TAG
suffix:colon
r_return
id|fsck_walk_tag
c_func
(paren
(paren
r_struct
id|tag
op_star
)paren
id|obj
comma
id|data
comma
id|options
)paren
suffix:semicolon
r_default
suffix:colon
id|error
c_func
(paren
l_string|&quot;Unknown object type for %s&quot;
comma
id|oid_to_hex
c_func
(paren
op_amp
id|obj-&gt;oid
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * The entries in a tree are ordered in the _path_ order,&n; * which means that a directory entry is ordered by adding&n; * a slash to the end of it.&n; *&n; * So a directory called &quot;a&quot; is ordered _after_ a file&n; * called &quot;a.c&quot;, because &quot;a/&quot; sorts after &quot;a.c&quot;.&n; */
DECL|macro|TREE_UNORDERED
mdefine_line|#define TREE_UNORDERED (-1)
DECL|macro|TREE_HAS_DUPS
mdefine_line|#define TREE_HAS_DUPS  (-2)
DECL|function|verify_ordered
r_static
r_int
id|verify_ordered
c_func
(paren
r_int
id|mode1
comma
r_const
r_char
op_star
id|name1
comma
r_int
id|mode2
comma
r_const
r_char
op_star
id|name2
)paren
(brace
r_int
id|len1
op_assign
id|strlen
c_func
(paren
id|name1
)paren
suffix:semicolon
r_int
id|len2
op_assign
id|strlen
c_func
(paren
id|name2
)paren
suffix:semicolon
r_int
id|len
op_assign
id|len1
OL
id|len2
ques
c_cond
id|len1
suffix:colon
id|len2
suffix:semicolon
r_int
r_char
id|c1
comma
id|c2
suffix:semicolon
r_int
id|cmp
suffix:semicolon
id|cmp
op_assign
id|memcmp
c_func
(paren
id|name1
comma
id|name2
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmp
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cmp
OG
l_int|0
)paren
r_return
id|TREE_UNORDERED
suffix:semicolon
multiline_comment|/*&n;&t; * Ok, the first &lt;len&gt; characters are the same.&n;&t; * Now we need to order the next one, but turn&n;&t; * a &squot;&bslash;0&squot; into a &squot;/&squot; for a directory entry.&n;&t; */
id|c1
op_assign
id|name1
(braket
id|len
)braket
suffix:semicolon
id|c2
op_assign
id|name2
(braket
id|len
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c1
op_logical_and
op_logical_neg
id|c2
)paren
multiline_comment|/*&n;&t;&t; * git-write-tree used to write out a nonsense tree that has&n;&t;&t; * entries with the same name, one blob and one tree.  Make&n;&t;&t; * sure we do not have duplicate entries.&n;&t;&t; */
r_return
id|TREE_HAS_DUPS
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c1
op_logical_and
id|S_ISDIR
c_func
(paren
id|mode1
)paren
)paren
id|c1
op_assign
l_char|&squot;/&squot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c2
op_logical_and
id|S_ISDIR
c_func
(paren
id|mode2
)paren
)paren
id|c2
op_assign
l_char|&squot;/&squot;
suffix:semicolon
r_return
id|c1
OL
id|c2
ques
c_cond
l_int|0
suffix:colon
id|TREE_UNORDERED
suffix:semicolon
)brace
DECL|function|fsck_tree
r_static
r_int
id|fsck_tree
c_func
(paren
r_struct
id|tree
op_star
id|item
comma
r_struct
id|fsck_options
op_star
id|options
)paren
(brace
r_int
id|retval
suffix:semicolon
r_int
id|has_null_sha1
op_assign
l_int|0
suffix:semicolon
r_int
id|has_full_path
op_assign
l_int|0
suffix:semicolon
r_int
id|has_empty_name
op_assign
l_int|0
suffix:semicolon
r_int
id|has_dot
op_assign
l_int|0
suffix:semicolon
r_int
id|has_dotdot
op_assign
l_int|0
suffix:semicolon
r_int
id|has_dotgit
op_assign
l_int|0
suffix:semicolon
r_int
id|has_zero_pad
op_assign
l_int|0
suffix:semicolon
r_int
id|has_bad_modes
op_assign
l_int|0
suffix:semicolon
r_int
id|has_dup_entries
op_assign
l_int|0
suffix:semicolon
r_int
id|not_properly_sorted
op_assign
l_int|0
suffix:semicolon
r_struct
id|tree_desc
id|desc
suffix:semicolon
r_int
id|o_mode
suffix:semicolon
r_const
r_char
op_star
id|o_name
suffix:semicolon
id|init_tree_desc
c_func
(paren
op_amp
id|desc
comma
id|item-&gt;buffer
comma
id|item-&gt;size
)paren
suffix:semicolon
id|o_mode
op_assign
l_int|0
suffix:semicolon
id|o_name
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|desc.size
)paren
(brace
r_int
id|mode
suffix:semicolon
r_const
r_char
op_star
id|name
suffix:semicolon
r_const
r_int
r_char
op_star
id|sha1
suffix:semicolon
id|sha1
op_assign
id|tree_entry_extract
c_func
(paren
op_amp
id|desc
comma
op_amp
id|name
comma
op_amp
id|mode
)paren
suffix:semicolon
id|has_null_sha1
op_or_assign
id|is_null_sha1
c_func
(paren
id|sha1
)paren
suffix:semicolon
id|has_full_path
op_or_assign
op_logical_neg
op_logical_neg
id|strchr
c_func
(paren
id|name
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
id|has_empty_name
op_or_assign
op_logical_neg
op_star
id|name
suffix:semicolon
id|has_dot
op_or_assign
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;.&quot;
)paren
suffix:semicolon
id|has_dotdot
op_or_assign
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;..&quot;
)paren
suffix:semicolon
id|has_dotgit
op_or_assign
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;.git&quot;
)paren
op_logical_or
id|is_hfs_dotgit
c_func
(paren
id|name
)paren
op_logical_or
id|is_ntfs_dotgit
c_func
(paren
id|name
)paren
)paren
suffix:semicolon
id|has_zero_pad
op_or_assign
op_star
(paren
r_char
op_star
)paren
id|desc.buffer
op_eq
l_char|&squot;0&squot;
suffix:semicolon
id|update_tree_entry
c_func
(paren
op_amp
id|desc
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|mode
)paren
(brace
multiline_comment|/*&n;&t;&t; * Standard modes..&n;&t;&t; */
r_case
id|S_IFREG
op_or
l_int|0755
suffix:colon
r_case
id|S_IFREG
op_or
l_int|0644
suffix:colon
r_case
id|S_IFLNK
suffix:colon
r_case
id|S_IFDIR
suffix:colon
r_case
id|S_IFGITLINK
suffix:colon
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * This is nonstandard, but we had a few of these&n;&t;&t; * early on when we honored the full set of mode&n;&t;&t; * bits..&n;&t;&t; */
r_case
id|S_IFREG
op_or
l_int|0664
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|options-&gt;strict
)paren
r_break
suffix:semicolon
r_default
suffix:colon
id|has_bad_modes
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|o_name
)paren
(brace
r_switch
c_cond
(paren
id|verify_ordered
c_func
(paren
id|o_mode
comma
id|o_name
comma
id|mode
comma
id|name
)paren
)paren
(brace
r_case
id|TREE_UNORDERED
suffix:colon
id|not_properly_sorted
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TREE_HAS_DUPS
suffix:colon
id|has_dup_entries
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
id|o_mode
op_assign
id|mode
suffix:semicolon
id|o_name
op_assign
id|name
suffix:semicolon
)brace
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|has_null_sha1
)paren
id|retval
op_add_assign
id|report
c_func
(paren
id|options
comma
op_amp
id|item-&gt;object
comma
id|FSCK_MSG_NULL_SHA1
comma
l_string|&quot;contains entries pointing to null sha1&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|has_full_path
)paren
id|retval
op_add_assign
id|report
c_func
(paren
id|options
comma
op_amp
id|item-&gt;object
comma
id|FSCK_MSG_FULL_PATHNAME
comma
l_string|&quot;contains full pathnames&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|has_empty_name
)paren
id|retval
op_add_assign
id|report
c_func
(paren
id|options
comma
op_amp
id|item-&gt;object
comma
id|FSCK_MSG_EMPTY_NAME
comma
l_string|&quot;contains empty pathname&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|has_dot
)paren
id|retval
op_add_assign
id|report
c_func
(paren
id|options
comma
op_amp
id|item-&gt;object
comma
id|FSCK_MSG_HAS_DOT
comma
l_string|&quot;contains &squot;.&squot;&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|has_dotdot
)paren
id|retval
op_add_assign
id|report
c_func
(paren
id|options
comma
op_amp
id|item-&gt;object
comma
id|FSCK_MSG_HAS_DOTDOT
comma
l_string|&quot;contains &squot;..&squot;&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|has_dotgit
)paren
id|retval
op_add_assign
id|report
c_func
(paren
id|options
comma
op_amp
id|item-&gt;object
comma
id|FSCK_MSG_HAS_DOTGIT
comma
l_string|&quot;contains &squot;.git&squot;&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|has_zero_pad
)paren
id|retval
op_add_assign
id|report
c_func
(paren
id|options
comma
op_amp
id|item-&gt;object
comma
id|FSCK_MSG_ZERO_PADDED_FILEMODE
comma
l_string|&quot;contains zero-padded file modes&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|has_bad_modes
)paren
id|retval
op_add_assign
id|report
c_func
(paren
id|options
comma
op_amp
id|item-&gt;object
comma
id|FSCK_MSG_BAD_FILEMODE
comma
l_string|&quot;contains bad file modes&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|has_dup_entries
)paren
id|retval
op_add_assign
id|report
c_func
(paren
id|options
comma
op_amp
id|item-&gt;object
comma
id|FSCK_MSG_DUPLICATE_ENTRIES
comma
l_string|&quot;contains duplicate file entries&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|not_properly_sorted
)paren
id|retval
op_add_assign
id|report
c_func
(paren
id|options
comma
op_amp
id|item-&gt;object
comma
id|FSCK_MSG_TREE_NOT_SORTED
comma
l_string|&quot;not properly sorted&quot;
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|verify_headers
r_static
r_int
id|verify_headers
c_func
(paren
r_const
r_void
op_star
id|data
comma
r_int
r_int
id|size
comma
r_struct
id|object
op_star
id|obj
comma
r_struct
id|fsck_options
op_star
id|options
)paren
(brace
r_const
r_char
op_star
id|buffer
op_assign
(paren
r_const
r_char
op_star
)paren
id|data
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|size
suffix:semicolon
id|i
op_increment
)paren
(brace
r_switch
c_cond
(paren
id|buffer
(braket
id|i
)braket
)paren
(brace
r_case
l_char|&squot;&bslash;0&squot;
suffix:colon
r_return
id|report
c_func
(paren
id|options
comma
id|obj
comma
id|FSCK_MSG_NUL_IN_HEADER
comma
l_string|&quot;unterminated header: NUL at offset %ld&quot;
comma
id|i
)paren
suffix:semicolon
r_case
l_char|&squot;&bslash;n&squot;
suffix:colon
r_if
c_cond
(paren
id|i
op_plus
l_int|1
OL
id|size
op_logical_and
id|buffer
(braket
id|i
op_plus
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * We did not find double-LF that separates the header&n;&t; * and the body.  Not having a body is not a crime but&n;&t; * we do want to see the terminating LF for the last header&n;&t; * line.&n;&t; */
r_if
c_cond
(paren
id|size
op_logical_and
id|buffer
(braket
id|size
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|report
c_func
(paren
id|options
comma
id|obj
comma
id|FSCK_MSG_UNTERMINATED_HEADER
comma
l_string|&quot;unterminated header&quot;
)paren
suffix:semicolon
)brace
DECL|function|fsck_ident
r_static
r_int
id|fsck_ident
c_func
(paren
r_const
r_char
op_star
op_star
id|ident
comma
r_struct
id|object
op_star
id|obj
comma
r_struct
id|fsck_options
op_star
id|options
)paren
(brace
r_const
r_char
op_star
id|p
op_assign
op_star
id|ident
suffix:semicolon
r_char
op_star
id|end
suffix:semicolon
op_star
id|ident
op_assign
id|strchrnul
c_func
(paren
op_star
id|ident
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
op_star
id|ident
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(paren
op_star
id|ident
)paren
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p
op_eq
l_char|&squot;&lt;&squot;
)paren
r_return
id|report
c_func
(paren
id|options
comma
id|obj
comma
id|FSCK_MSG_MISSING_NAME_BEFORE_EMAIL
comma
l_string|&quot;invalid author/committer line - missing space before email&quot;
)paren
suffix:semicolon
id|p
op_add_assign
id|strcspn
c_func
(paren
id|p
comma
l_string|&quot;&lt;&gt;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p
op_eq
l_char|&squot;&gt;&squot;
)paren
r_return
id|report
c_func
(paren
id|options
comma
id|obj
comma
id|FSCK_MSG_BAD_NAME
comma
l_string|&quot;invalid author/committer line - bad name&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p
op_ne
l_char|&squot;&lt;&squot;
)paren
r_return
id|report
c_func
(paren
id|options
comma
id|obj
comma
id|FSCK_MSG_MISSING_EMAIL
comma
l_string|&quot;invalid author/committer line - missing email&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
(braket
l_int|1
)braket
op_ne
l_char|&squot; &squot;
)paren
r_return
id|report
c_func
(paren
id|options
comma
id|obj
comma
id|FSCK_MSG_MISSING_SPACE_BEFORE_EMAIL
comma
l_string|&quot;invalid author/committer line - missing space before email&quot;
)paren
suffix:semicolon
id|p
op_increment
suffix:semicolon
id|p
op_add_assign
id|strcspn
c_func
(paren
id|p
comma
l_string|&quot;&lt;&gt;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p
op_ne
l_char|&squot;&gt;&squot;
)paren
r_return
id|report
c_func
(paren
id|options
comma
id|obj
comma
id|FSCK_MSG_BAD_EMAIL
comma
l_string|&quot;invalid author/committer line - bad email&quot;
)paren
suffix:semicolon
id|p
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p
op_ne
l_char|&squot; &squot;
)paren
r_return
id|report
c_func
(paren
id|options
comma
id|obj
comma
id|FSCK_MSG_MISSING_SPACE_BEFORE_DATE
comma
l_string|&quot;invalid author/committer line - missing space before date&quot;
)paren
suffix:semicolon
id|p
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p
op_eq
l_char|&squot;0&squot;
op_logical_and
id|p
(braket
l_int|1
)braket
op_ne
l_char|&squot; &squot;
)paren
r_return
id|report
c_func
(paren
id|options
comma
id|obj
comma
id|FSCK_MSG_ZERO_PADDED_DATE
comma
l_string|&quot;invalid author/committer line - zero-padded date&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|date_overflows
c_func
(paren
id|strtoul
c_func
(paren
id|p
comma
op_amp
id|end
comma
l_int|10
)paren
)paren
)paren
r_return
id|report
c_func
(paren
id|options
comma
id|obj
comma
id|FSCK_MSG_BAD_DATE_OVERFLOW
comma
l_string|&quot;invalid author/committer line - date causes integer overflow&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|end
op_eq
id|p
op_logical_or
op_star
id|end
op_ne
l_char|&squot; &squot;
)paren
)paren
r_return
id|report
c_func
(paren
id|options
comma
id|obj
comma
id|FSCK_MSG_BAD_DATE
comma
l_string|&quot;invalid author/committer line - bad date&quot;
)paren
suffix:semicolon
id|p
op_assign
id|end
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|p
op_ne
l_char|&squot;+&squot;
op_logical_and
op_star
id|p
op_ne
l_char|&squot;-&squot;
)paren
op_logical_or
op_logical_neg
id|isdigit
c_func
(paren
id|p
(braket
l_int|1
)braket
)paren
op_logical_or
op_logical_neg
id|isdigit
c_func
(paren
id|p
(braket
l_int|2
)braket
)paren
op_logical_or
op_logical_neg
id|isdigit
c_func
(paren
id|p
(braket
l_int|3
)braket
)paren
op_logical_or
op_logical_neg
id|isdigit
c_func
(paren
id|p
(braket
l_int|4
)braket
)paren
op_logical_or
(paren
id|p
(braket
l_int|5
)braket
op_ne
l_char|&squot;&bslash;n&squot;
)paren
)paren
r_return
id|report
c_func
(paren
id|options
comma
id|obj
comma
id|FSCK_MSG_BAD_TIMEZONE
comma
l_string|&quot;invalid author/committer line - bad time zone&quot;
)paren
suffix:semicolon
id|p
op_add_assign
l_int|6
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|fsck_commit_buffer
r_static
r_int
id|fsck_commit_buffer
c_func
(paren
r_struct
id|commit
op_star
id|commit
comma
r_const
r_char
op_star
id|buffer
comma
r_int
r_int
id|size
comma
r_struct
id|fsck_options
op_star
id|options
)paren
(brace
r_int
r_char
id|tree_sha1
(braket
l_int|20
)braket
comma
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_struct
id|commit_graft
op_star
id|graft
suffix:semicolon
r_int
id|parent_count
comma
id|parent_line_count
op_assign
l_int|0
comma
id|author_count
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|verify_headers
c_func
(paren
id|buffer
comma
id|size
comma
op_amp
id|commit-&gt;object
comma
id|options
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skip_prefix
c_func
(paren
id|buffer
comma
l_string|&quot;tree &quot;
comma
op_amp
id|buffer
)paren
)paren
r_return
id|report
c_func
(paren
id|options
comma
op_amp
id|commit-&gt;object
comma
id|FSCK_MSG_MISSING_TREE
comma
l_string|&quot;invalid format - expected &squot;tree&squot; line&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|buffer
comma
id|tree_sha1
)paren
op_logical_or
id|buffer
(braket
l_int|40
)braket
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|err
op_assign
id|report
c_func
(paren
id|options
comma
op_amp
id|commit-&gt;object
comma
id|FSCK_MSG_BAD_TREE_SHA1
comma
l_string|&quot;invalid &squot;tree&squot; line format - bad sha1&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
)brace
id|buffer
op_add_assign
l_int|41
suffix:semicolon
r_while
c_loop
(paren
id|skip_prefix
c_func
(paren
id|buffer
comma
l_string|&quot;parent &quot;
comma
op_amp
id|buffer
)paren
)paren
(brace
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|buffer
comma
id|sha1
)paren
op_logical_or
id|buffer
(braket
l_int|40
)braket
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|err
op_assign
id|report
c_func
(paren
id|options
comma
op_amp
id|commit-&gt;object
comma
id|FSCK_MSG_BAD_PARENT_SHA1
comma
l_string|&quot;invalid &squot;parent&squot; line format - bad sha1&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
)brace
id|buffer
op_add_assign
l_int|41
suffix:semicolon
id|parent_line_count
op_increment
suffix:semicolon
)brace
id|graft
op_assign
id|lookup_commit_graft
c_func
(paren
id|get_object_hash
c_func
(paren
id|commit-&gt;object
)paren
)paren
suffix:semicolon
id|parent_count
op_assign
id|commit_list_count
c_func
(paren
id|commit-&gt;parents
)paren
suffix:semicolon
r_if
c_cond
(paren
id|graft
)paren
(brace
r_if
c_cond
(paren
id|graft-&gt;nr_parent
op_eq
l_int|1
op_logical_and
op_logical_neg
id|parent_count
)paren
suffix:semicolon
multiline_comment|/* shallow commit */
r_else
r_if
c_cond
(paren
id|graft-&gt;nr_parent
op_ne
id|parent_count
)paren
(brace
id|err
op_assign
id|report
c_func
(paren
id|options
comma
op_amp
id|commit-&gt;object
comma
id|FSCK_MSG_MISSING_GRAFT
comma
l_string|&quot;graft objects missing&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|parent_count
op_ne
id|parent_line_count
)paren
(brace
id|err
op_assign
id|report
c_func
(paren
id|options
comma
op_amp
id|commit-&gt;object
comma
id|FSCK_MSG_MISSING_PARENT
comma
l_string|&quot;parent objects missing&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
)brace
)brace
id|author_count
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|skip_prefix
c_func
(paren
id|buffer
comma
l_string|&quot;author &quot;
comma
op_amp
id|buffer
)paren
)paren
(brace
id|author_count
op_increment
suffix:semicolon
id|err
op_assign
id|fsck_ident
c_func
(paren
op_amp
id|buffer
comma
op_amp
id|commit-&gt;object
comma
id|options
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
)brace
r_if
c_cond
(paren
id|author_count
OL
l_int|1
)paren
id|err
op_assign
id|report
c_func
(paren
id|options
comma
op_amp
id|commit-&gt;object
comma
id|FSCK_MSG_MISSING_AUTHOR
comma
l_string|&quot;invalid format - expected &squot;author&squot; line&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|author_count
OG
l_int|1
)paren
id|err
op_assign
id|report
c_func
(paren
id|options
comma
op_amp
id|commit-&gt;object
comma
id|FSCK_MSG_MULTIPLE_AUTHORS
comma
l_string|&quot;invalid format - multiple &squot;author&squot; lines&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skip_prefix
c_func
(paren
id|buffer
comma
l_string|&quot;committer &quot;
comma
op_amp
id|buffer
)paren
)paren
r_return
id|report
c_func
(paren
id|options
comma
op_amp
id|commit-&gt;object
comma
id|FSCK_MSG_MISSING_COMMITTER
comma
l_string|&quot;invalid format - expected &squot;committer&squot; line&quot;
)paren
suffix:semicolon
id|err
op_assign
id|fsck_ident
c_func
(paren
op_amp
id|buffer
comma
op_amp
id|commit-&gt;object
comma
id|options
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|commit-&gt;tree
)paren
r_return
id|report
c_func
(paren
id|options
comma
op_amp
id|commit-&gt;object
comma
id|FSCK_MSG_BAD_TREE
comma
l_string|&quot;could not load commit&squot;s tree %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|tree_sha1
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|fsck_commit
r_static
r_int
id|fsck_commit
c_func
(paren
r_struct
id|commit
op_star
id|commit
comma
r_const
r_char
op_star
id|data
comma
r_int
r_int
id|size
comma
r_struct
id|fsck_options
op_star
id|options
)paren
(brace
r_const
r_char
op_star
id|buffer
op_assign
id|data
ques
c_cond
id|data
suffix:colon
id|get_commit_buffer
c_func
(paren
id|commit
comma
op_amp
id|size
)paren
suffix:semicolon
r_int
id|ret
op_assign
id|fsck_commit_buffer
c_func
(paren
id|commit
comma
id|buffer
comma
id|size
comma
id|options
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
id|unuse_commit_buffer
c_func
(paren
id|commit
comma
id|buffer
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|fsck_tag_buffer
r_static
r_int
id|fsck_tag_buffer
c_func
(paren
r_struct
id|tag
op_star
id|tag
comma
r_const
r_char
op_star
id|data
comma
r_int
r_int
id|size
comma
r_struct
id|fsck_options
op_star
id|options
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_const
r_char
op_star
id|buffer
suffix:semicolon
r_char
op_star
id|to_free
op_assign
l_int|NULL
comma
op_star
id|eol
suffix:semicolon
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
r_if
c_cond
(paren
id|data
)paren
id|buffer
op_assign
id|data
suffix:semicolon
r_else
(brace
r_enum
id|object_type
id|type
suffix:semicolon
id|buffer
op_assign
id|to_free
op_assign
id|read_sha1_file
c_func
(paren
id|get_object_hash
c_func
(paren
id|tag-&gt;object
)paren
comma
op_amp
id|type
comma
op_amp
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer
)paren
r_return
id|report
c_func
(paren
id|options
comma
op_amp
id|tag-&gt;object
comma
id|FSCK_MSG_MISSING_TAG_OBJECT
comma
l_string|&quot;cannot read tag object&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
id|OBJ_TAG
)paren
(brace
id|ret
op_assign
id|report
c_func
(paren
id|options
comma
op_amp
id|tag-&gt;object
comma
id|FSCK_MSG_TAG_OBJECT_NOT_TAG
comma
l_string|&quot;expected tag got %s&quot;
comma
r_typename
(paren
id|type
)paren
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|verify_headers
c_func
(paren
id|buffer
comma
id|size
comma
op_amp
id|tag-&gt;object
comma
id|options
)paren
)paren
r_goto
id|done
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skip_prefix
c_func
(paren
id|buffer
comma
l_string|&quot;object &quot;
comma
op_amp
id|buffer
)paren
)paren
(brace
id|ret
op_assign
id|report
c_func
(paren
id|options
comma
op_amp
id|tag-&gt;object
comma
id|FSCK_MSG_MISSING_OBJECT
comma
l_string|&quot;invalid format - expected &squot;object&squot; line&quot;
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_if
c_cond
(paren
id|get_sha1_hex
c_func
(paren
id|buffer
comma
id|sha1
)paren
op_logical_or
id|buffer
(braket
l_int|40
)braket
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|ret
op_assign
id|report
c_func
(paren
id|options
comma
op_amp
id|tag-&gt;object
comma
id|FSCK_MSG_BAD_OBJECT_SHA1
comma
l_string|&quot;invalid &squot;object&squot; line format - bad sha1&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|done
suffix:semicolon
)brace
id|buffer
op_add_assign
l_int|41
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skip_prefix
c_func
(paren
id|buffer
comma
l_string|&quot;type &quot;
comma
op_amp
id|buffer
)paren
)paren
(brace
id|ret
op_assign
id|report
c_func
(paren
id|options
comma
op_amp
id|tag-&gt;object
comma
id|FSCK_MSG_MISSING_TYPE_ENTRY
comma
l_string|&quot;invalid format - expected &squot;type&squot; line&quot;
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|eol
op_assign
id|strchr
c_func
(paren
id|buffer
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|eol
)paren
(brace
id|ret
op_assign
id|report
c_func
(paren
id|options
comma
op_amp
id|tag-&gt;object
comma
id|FSCK_MSG_MISSING_TYPE
comma
l_string|&quot;invalid format - unexpected end after &squot;type&squot; line&quot;
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_if
c_cond
(paren
id|type_from_string_gently
c_func
(paren
id|buffer
comma
id|eol
id|buffer
comma
l_int|1
)paren
OL
l_int|0
)paren
id|ret
op_assign
id|report
c_func
(paren
id|options
comma
op_amp
id|tag-&gt;object
comma
id|FSCK_MSG_BAD_TYPE
comma
l_string|&quot;invalid &squot;type&squot; value&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|done
suffix:semicolon
id|buffer
op_assign
id|eol
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skip_prefix
c_func
(paren
id|buffer
comma
l_string|&quot;tag &quot;
comma
op_amp
id|buffer
)paren
)paren
(brace
id|ret
op_assign
id|report
c_func
(paren
id|options
comma
op_amp
id|tag-&gt;object
comma
id|FSCK_MSG_MISSING_TAG_ENTRY
comma
l_string|&quot;invalid format - expected &squot;tag&squot; line&quot;
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|eol
op_assign
id|strchr
c_func
(paren
id|buffer
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|eol
)paren
(brace
id|ret
op_assign
id|report
c_func
(paren
id|options
comma
op_amp
id|tag-&gt;object
comma
id|FSCK_MSG_MISSING_TAG
comma
l_string|&quot;invalid format - unexpected end after &squot;type&squot; line&quot;
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|strbuf_addf
c_func
(paren
op_amp
id|sb
comma
l_string|&quot;refs/tags/%.*s&quot;
comma
(paren
r_int
)paren
(paren
id|eol
id|buffer
)paren
comma
id|buffer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|check_refname_format
c_func
(paren
id|sb.buf
comma
l_int|0
)paren
)paren
(brace
id|ret
op_assign
id|report
c_func
(paren
id|options
comma
op_amp
id|tag-&gt;object
comma
id|FSCK_MSG_BAD_TAG_NAME
comma
l_string|&quot;invalid &squot;tag&squot; name: %.*s&quot;
comma
(paren
r_int
)paren
(paren
id|eol
id|buffer
)paren
comma
id|buffer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|done
suffix:semicolon
)brace
id|buffer
op_assign
id|eol
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skip_prefix
c_func
(paren
id|buffer
comma
l_string|&quot;tagger &quot;
comma
op_amp
id|buffer
)paren
)paren
(brace
multiline_comment|/* early tags do not contain &squot;tagger&squot; lines; warn only */
id|ret
op_assign
id|report
c_func
(paren
id|options
comma
op_amp
id|tag-&gt;object
comma
id|FSCK_MSG_MISSING_TAGGER_ENTRY
comma
l_string|&quot;invalid format - expected &squot;tagger&squot; line&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|done
suffix:semicolon
)brace
r_else
id|ret
op_assign
id|fsck_ident
c_func
(paren
op_amp
id|buffer
comma
op_amp
id|tag-&gt;object
comma
id|options
)paren
suffix:semicolon
id|done
suffix:colon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
id|free
c_func
(paren
id|to_free
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|fsck_tag
r_static
r_int
id|fsck_tag
c_func
(paren
r_struct
id|tag
op_star
id|tag
comma
r_const
r_char
op_star
id|data
comma
r_int
r_int
id|size
comma
r_struct
id|fsck_options
op_star
id|options
)paren
(brace
r_struct
id|object
op_star
id|tagged
op_assign
id|tag-&gt;tagged
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tagged
)paren
r_return
id|report
c_func
(paren
id|options
comma
op_amp
id|tag-&gt;object
comma
id|FSCK_MSG_BAD_TAG_OBJECT
comma
l_string|&quot;could not load tagged object&quot;
)paren
suffix:semicolon
r_return
id|fsck_tag_buffer
c_func
(paren
id|tag
comma
id|data
comma
id|size
comma
id|options
)paren
suffix:semicolon
)brace
DECL|function|fsck_object
r_int
id|fsck_object
c_func
(paren
r_struct
id|object
op_star
id|obj
comma
r_void
op_star
id|data
comma
r_int
r_int
id|size
comma
r_struct
id|fsck_options
op_star
id|options
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|obj
)paren
r_return
id|report
c_func
(paren
id|options
comma
id|obj
comma
id|FSCK_MSG_BAD_OBJECT_SHA1
comma
l_string|&quot;no valid object to fsck&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|obj-&gt;type
op_eq
id|OBJ_BLOB
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|obj-&gt;type
op_eq
id|OBJ_TREE
)paren
r_return
id|fsck_tree
c_func
(paren
(paren
r_struct
id|tree
op_star
)paren
id|obj
comma
id|options
)paren
suffix:semicolon
r_if
c_cond
(paren
id|obj-&gt;type
op_eq
id|OBJ_COMMIT
)paren
r_return
id|fsck_commit
c_func
(paren
(paren
r_struct
id|commit
op_star
)paren
id|obj
comma
(paren
r_const
r_char
op_star
)paren
id|data
comma
id|size
comma
id|options
)paren
suffix:semicolon
r_if
c_cond
(paren
id|obj-&gt;type
op_eq
id|OBJ_TAG
)paren
r_return
id|fsck_tag
c_func
(paren
(paren
r_struct
id|tag
op_star
)paren
id|obj
comma
(paren
r_const
r_char
op_star
)paren
id|data
comma
id|size
comma
id|options
)paren
suffix:semicolon
r_return
id|report
c_func
(paren
id|options
comma
id|obj
comma
id|FSCK_MSG_UNKNOWN_TYPE
comma
l_string|&quot;unknown type &squot;%d&squot; (internal fsck error)&quot;
comma
id|obj-&gt;type
)paren
suffix:semicolon
)brace
DECL|function|fsck_error_function
r_int
id|fsck_error_function
c_func
(paren
r_struct
id|object
op_star
id|obj
comma
r_int
id|msg_type
comma
r_const
r_char
op_star
id|message
)paren
(brace
r_if
c_cond
(paren
id|msg_type
op_eq
id|FSCK_WARN
)paren
(brace
id|warning
c_func
(paren
l_string|&quot;object %s: %s&quot;
comma
id|oid_to_hex
c_func
(paren
op_amp
id|obj-&gt;oid
)paren
comma
id|message
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|error
c_func
(paren
l_string|&quot;object %s: %s&quot;
comma
id|oid_to_hex
c_func
(paren
op_amp
id|obj-&gt;oid
)paren
comma
id|message
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
eof
