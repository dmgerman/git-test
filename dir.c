multiline_comment|/*&n; * This handles recursive filename detection with exclude&n; * files, index knowledge etc..&n; *&n; * Copyright (C) Linus Torvalds, 2005-2006&n; *&t;&t; Junio Hamano, 2005-2006&n; */
macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;dir.h&quot;
macro_line|#include &quot;refs.h&quot;
DECL|struct|path_simplify
r_struct
id|path_simplify
(brace
DECL|member|len
r_int
id|len
suffix:semicolon
DECL|member|path
r_const
r_char
op_star
id|path
suffix:semicolon
)brace
suffix:semicolon
r_static
r_int
id|read_directory_recursive
c_func
(paren
r_struct
id|dir_struct
op_star
id|dir
comma
r_const
r_char
op_star
id|path
comma
r_int
id|len
comma
r_int
id|check_only
comma
r_const
r_struct
id|path_simplify
op_star
id|simplify
)paren
suffix:semicolon
r_static
r_int
id|get_dtype
c_func
(paren
r_struct
id|dirent
op_star
id|de
comma
r_const
r_char
op_star
id|path
comma
r_int
id|len
)paren
suffix:semicolon
multiline_comment|/* helper string functions with support for the ignore_case flag */
DECL|function|strcmp_icase
r_int
id|strcmp_icase
c_func
(paren
r_const
r_char
op_star
id|a
comma
r_const
r_char
op_star
id|b
)paren
(brace
r_return
id|ignore_case
ques
c_cond
id|strcasecmp
c_func
(paren
id|a
comma
id|b
)paren
suffix:colon
id|strcmp
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
)brace
DECL|function|strncmp_icase
r_int
id|strncmp_icase
c_func
(paren
r_const
r_char
op_star
id|a
comma
r_const
r_char
op_star
id|b
comma
r_int
id|count
)paren
(brace
r_return
id|ignore_case
ques
c_cond
id|strncasecmp
c_func
(paren
id|a
comma
id|b
comma
id|count
)paren
suffix:colon
id|strncmp
c_func
(paren
id|a
comma
id|b
comma
id|count
)paren
suffix:semicolon
)brace
DECL|function|fnmatch_icase
r_int
id|fnmatch_icase
c_func
(paren
r_const
r_char
op_star
id|pattern
comma
r_const
r_char
op_star
id|string
comma
r_int
id|flags
)paren
(brace
r_return
id|fnmatch
c_func
(paren
id|pattern
comma
id|string
comma
id|flags
op_or
(paren
id|ignore_case
ques
c_cond
id|FNM_CASEFOLD
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
)brace
DECL|function|common_prefix_len
r_int
id|common_prefix_len
c_func
(paren
r_const
r_char
op_star
op_star
id|pathspec
)paren
(brace
r_const
r_char
op_star
id|n
comma
op_star
id|first
suffix:semicolon
r_int
id|max
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pathspec
)paren
r_return
id|max
suffix:semicolon
id|first
op_assign
op_star
id|pathspec
suffix:semicolon
r_while
c_loop
(paren
(paren
id|n
op_assign
op_star
id|pathspec
op_increment
)paren
)paren
(brace
r_int
id|i
comma
id|len
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|first
op_eq
id|n
op_logical_or
id|i
OL
id|max
suffix:semicolon
id|i
op_increment
)paren
(brace
r_char
id|c
op_assign
id|n
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
op_logical_or
id|c
op_ne
id|first
(braket
id|i
)braket
op_logical_or
id|is_glob_special
c_func
(paren
id|c
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;/&squot;
)paren
id|len
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|first
op_eq
id|n
op_logical_or
id|len
OL
id|max
)paren
(brace
id|max
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|max
)paren
r_break
suffix:semicolon
)brace
)brace
r_return
id|max
suffix:semicolon
)brace
DECL|function|fill_directory
r_int
id|fill_directory
c_func
(paren
r_struct
id|dir_struct
op_star
id|dir
comma
r_const
r_char
op_star
op_star
id|pathspec
)paren
(brace
r_const
r_char
op_star
id|path
suffix:semicolon
r_int
id|len
suffix:semicolon
multiline_comment|/*&n;&t; * Calculate common prefix for the pathspec, and&n;&t; * use that to optimize the directory walk&n;&t; */
id|len
op_assign
id|common_prefix_len
c_func
(paren
id|pathspec
)paren
suffix:semicolon
id|path
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_if
c_cond
(paren
id|len
)paren
id|path
op_assign
id|xmemdupz
c_func
(paren
op_star
id|pathspec
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* Read the directory and prune it */
id|read_directory
c_func
(paren
id|dir
comma
id|path
comma
id|len
comma
id|pathspec
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|path
)paren
id|free
c_func
(paren
(paren
r_char
op_star
)paren
id|path
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
DECL|function|within_depth
r_int
id|within_depth
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_int
id|namelen
comma
r_int
id|depth
comma
r_int
id|max_depth
)paren
(brace
r_const
r_char
op_star
id|cp
op_assign
id|name
comma
op_star
id|cpe
op_assign
id|name
op_plus
id|namelen
suffix:semicolon
r_while
c_loop
(paren
id|cp
OL
id|cpe
)paren
(brace
r_if
c_cond
(paren
op_star
id|cp
op_increment
op_ne
l_char|&squot;/&squot;
)paren
r_continue
suffix:semicolon
id|depth
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|depth
OG
id|max_depth
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Does &squot;match&squot; match the given name?&n; * A match is found if&n; *&n; * (1) the &squot;match&squot; string is leading directory of &squot;name&squot;, or&n; * (2) the &squot;match&squot; string is a wildcard and matches &squot;name&squot;, or&n; * (3) the &squot;match&squot; string is exactly the same as &squot;name&squot;.&n; *&n; * and the return value tells which case it was.&n; *&n; * It returns 0 when there is no match.&n; */
DECL|function|match_one
r_static
r_int
id|match_one
c_func
(paren
r_const
r_char
op_star
id|match
comma
r_const
r_char
op_star
id|name
comma
r_int
id|namelen
)paren
(brace
r_int
id|matchlen
suffix:semicolon
multiline_comment|/* If the match was just the prefix, we matched */
r_if
c_cond
(paren
op_logical_neg
op_star
id|match
)paren
r_return
id|MATCHED_RECURSIVELY
suffix:semicolon
r_if
c_cond
(paren
id|ignore_case
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
r_char
id|c1
op_assign
id|tolower
c_func
(paren
op_star
id|match
)paren
suffix:semicolon
r_int
r_char
id|c2
op_assign
id|tolower
c_func
(paren
op_star
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c1
op_eq
l_char|&squot;&bslash;0&squot;
op_logical_or
id|is_glob_special
c_func
(paren
id|c1
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|c1
op_ne
id|c2
)paren
r_return
l_int|0
suffix:semicolon
id|match
op_increment
suffix:semicolon
id|name
op_increment
suffix:semicolon
id|namelen
op_decrement
suffix:semicolon
)brace
)brace
r_else
(brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
r_char
id|c1
op_assign
op_star
id|match
suffix:semicolon
r_int
r_char
id|c2
op_assign
op_star
id|name
suffix:semicolon
r_if
c_cond
(paren
id|c1
op_eq
l_char|&squot;&bslash;0&squot;
op_logical_or
id|is_glob_special
c_func
(paren
id|c1
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|c1
op_ne
id|c2
)paren
r_return
l_int|0
suffix:semicolon
id|match
op_increment
suffix:semicolon
id|name
op_increment
suffix:semicolon
id|namelen
op_decrement
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * If we don&squot;t match the matchstring exactly,&n;&t; * we need to match by fnmatch&n;&t; */
id|matchlen
op_assign
id|strlen
c_func
(paren
id|match
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strncmp_icase
c_func
(paren
id|match
comma
id|name
comma
id|matchlen
)paren
)paren
r_return
op_logical_neg
id|fnmatch_icase
c_func
(paren
id|match
comma
id|name
comma
l_int|0
)paren
ques
c_cond
id|MATCHED_FNMATCH
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|namelen
op_eq
id|matchlen
)paren
r_return
id|MATCHED_EXACTLY
suffix:semicolon
r_if
c_cond
(paren
id|match
(braket
id|matchlen
op_minus
l_int|1
)braket
op_eq
l_char|&squot;/&squot;
op_logical_or
id|name
(braket
id|matchlen
)braket
op_eq
l_char|&squot;/&squot;
)paren
r_return
id|MATCHED_RECURSIVELY
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Given a name and a list of pathspecs, see if the name matches&n; * any of the pathspecs.  The caller is also interested in seeing&n; * all pathspec matches some names it calls this function with&n; * (otherwise the user could have mistyped the unmatched pathspec),&n; * and a mark is left in seen[] array for pathspec element that&n; * actually matched anything.&n; */
DECL|function|match_pathspec
r_int
id|match_pathspec
c_func
(paren
r_const
r_char
op_star
op_star
id|pathspec
comma
r_const
r_char
op_star
id|name
comma
r_int
id|namelen
comma
r_int
id|prefix
comma
r_char
op_star
id|seen
)paren
(brace
r_int
id|i
comma
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pathspec
)paren
r_return
l_int|1
suffix:semicolon
id|name
op_add_assign
id|prefix
suffix:semicolon
id|namelen
op_sub_assign
id|prefix
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|pathspec
(braket
id|i
)braket
op_ne
l_int|NULL
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|how
suffix:semicolon
r_const
r_char
op_star
id|match
op_assign
id|pathspec
(braket
id|i
)braket
op_plus
id|prefix
suffix:semicolon
r_if
c_cond
(paren
id|seen
op_logical_and
id|seen
(braket
id|i
)braket
op_eq
id|MATCHED_EXACTLY
)paren
r_continue
suffix:semicolon
id|how
op_assign
id|match_one
c_func
(paren
id|match
comma
id|name
comma
id|namelen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|how
)paren
(brace
r_if
c_cond
(paren
id|retval
OL
id|how
)paren
id|retval
op_assign
id|how
suffix:semicolon
r_if
c_cond
(paren
id|seen
op_logical_and
id|seen
(braket
id|i
)braket
OL
id|how
)paren
id|seen
(braket
id|i
)braket
op_assign
id|how
suffix:semicolon
)brace
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Does &squot;match&squot; match the given name?&n; * A match is found if&n; *&n; * (1) the &squot;match&squot; string is leading directory of &squot;name&squot;, or&n; * (2) the &squot;match&squot; string is a wildcard and matches &squot;name&squot;, or&n; * (3) the &squot;match&squot; string is exactly the same as &squot;name&squot;.&n; *&n; * and the return value tells which case it was.&n; *&n; * It returns 0 when there is no match.&n; */
DECL|function|match_pathspec_item
r_static
r_int
id|match_pathspec_item
c_func
(paren
r_const
r_struct
id|pathspec_item
op_star
id|item
comma
r_int
id|prefix
comma
r_const
r_char
op_star
id|name
comma
r_int
id|namelen
)paren
(brace
multiline_comment|/* name/namelen has prefix cut off by caller */
r_const
r_char
op_star
id|match
op_assign
id|item-&gt;match
op_plus
id|prefix
suffix:semicolon
r_int
id|matchlen
op_assign
id|item-&gt;len
id|prefix
suffix:semicolon
multiline_comment|/* If the match was just the prefix, we matched */
r_if
c_cond
(paren
op_logical_neg
op_star
id|match
)paren
r_return
id|MATCHED_RECURSIVELY
suffix:semicolon
r_if
c_cond
(paren
id|matchlen
op_le
id|namelen
op_logical_and
op_logical_neg
id|strncmp
c_func
(paren
id|match
comma
id|name
comma
id|matchlen
)paren
)paren
(brace
r_if
c_cond
(paren
id|matchlen
op_eq
id|namelen
)paren
r_return
id|MATCHED_EXACTLY
suffix:semicolon
r_if
c_cond
(paren
id|match
(braket
id|matchlen
op_minus
l_int|1
)braket
op_eq
l_char|&squot;/&squot;
op_logical_or
id|name
(braket
id|matchlen
)braket
op_eq
l_char|&squot;/&squot;
)paren
r_return
id|MATCHED_RECURSIVELY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|item-&gt;use_wildcard
op_logical_and
op_logical_neg
id|fnmatch
c_func
(paren
id|match
comma
id|name
comma
l_int|0
)paren
)paren
r_return
id|MATCHED_FNMATCH
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Given a name and a list of pathspecs, see if the name matches&n; * any of the pathspecs.  The caller is also interested in seeing&n; * all pathspec matches some names it calls this function with&n; * (otherwise the user could have mistyped the unmatched pathspec),&n; * and a mark is left in seen[] array for pathspec element that&n; * actually matched anything.&n; */
DECL|function|match_pathspec_depth
r_int
id|match_pathspec_depth
c_func
(paren
r_const
r_struct
id|pathspec
op_star
id|ps
comma
r_const
r_char
op_star
id|name
comma
r_int
id|namelen
comma
r_int
id|prefix
comma
r_char
op_star
id|seen
)paren
(brace
r_int
id|i
comma
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ps-&gt;nr
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ps-&gt;recursive
op_logical_or
id|ps-&gt;max_depth
op_eq
l_int|1
)paren
r_return
id|MATCHED_RECURSIVELY
suffix:semicolon
r_if
c_cond
(paren
id|within_depth
c_func
(paren
id|name
comma
id|namelen
comma
l_int|0
comma
id|ps-&gt;max_depth
)paren
)paren
r_return
id|MATCHED_EXACTLY
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
id|name
op_add_assign
id|prefix
suffix:semicolon
id|namelen
op_sub_assign
id|prefix
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|ps-&gt;nr
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_int
id|how
suffix:semicolon
r_if
c_cond
(paren
id|seen
op_logical_and
id|seen
(braket
id|i
)braket
op_eq
id|MATCHED_EXACTLY
)paren
r_continue
suffix:semicolon
id|how
op_assign
id|match_pathspec_item
c_func
(paren
id|ps-&gt;items
op_plus
id|i
comma
id|prefix
comma
id|name
comma
id|namelen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ps-&gt;recursive
op_logical_and
id|ps-&gt;max_depth
op_ne
l_int|1
op_logical_and
id|how
op_logical_and
id|how
op_ne
id|MATCHED_FNMATCH
)paren
(brace
r_int
id|len
op_assign
id|ps-&gt;items
(braket
id|i
)braket
dot
id|len
suffix:semicolon
r_if
c_cond
(paren
id|name
(braket
id|len
)braket
op_eq
l_char|&squot;/&squot;
)paren
id|len
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|within_depth
c_func
(paren
id|name
op_plus
id|len
comma
id|namelen
op_minus
id|len
comma
l_int|0
comma
id|ps-&gt;max_depth
)paren
)paren
id|how
op_assign
id|MATCHED_EXACTLY
suffix:semicolon
r_else
id|how
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|how
)paren
(brace
r_if
c_cond
(paren
id|retval
OL
id|how
)paren
id|retval
op_assign
id|how
suffix:semicolon
r_if
c_cond
(paren
id|seen
op_logical_and
id|seen
(braket
id|i
)braket
OL
id|how
)paren
id|seen
(braket
id|i
)braket
op_assign
id|how
suffix:semicolon
)brace
)brace
r_return
id|retval
suffix:semicolon
)brace
DECL|function|no_wildcard
r_static
r_int
id|no_wildcard
c_func
(paren
r_const
r_char
op_star
id|string
)paren
(brace
r_return
id|string
(braket
id|strcspn
c_func
(paren
id|string
comma
l_string|&quot;*?[{&bslash;&bslash;&quot;
)paren
)braket
op_eq
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
DECL|function|add_exclude
r_void
id|add_exclude
c_func
(paren
r_const
r_char
op_star
id|string
comma
r_const
r_char
op_star
id|base
comma
r_int
id|baselen
comma
r_struct
id|exclude_list
op_star
id|which
)paren
(brace
r_struct
id|exclude
op_star
id|x
suffix:semicolon
r_int
id|len
suffix:semicolon
r_int
id|to_exclude
op_assign
l_int|1
suffix:semicolon
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_star
id|string
op_eq
l_char|&squot;!&squot;
)paren
(brace
id|to_exclude
op_assign
l_int|0
suffix:semicolon
id|string
op_increment
suffix:semicolon
)brace
id|len
op_assign
id|strlen
c_func
(paren
id|string
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_logical_and
id|string
(braket
id|len
l_int|1
)braket
op_eq
l_char|&squot;/&squot;
)paren
(brace
r_char
op_star
id|s
suffix:semicolon
id|x
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|x
)paren
op_plus
id|len
)paren
suffix:semicolon
id|s
op_assign
(paren
r_char
op_star
)paren
(paren
id|x
op_plus
l_int|1
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|s
comma
id|string
comma
id|len
l_int|1
)paren
suffix:semicolon
id|s
(braket
id|len
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|string
op_assign
id|s
suffix:semicolon
id|x-&gt;pattern
op_assign
id|s
suffix:semicolon
id|flags
op_assign
id|EXC_FLAG_MUSTBEDIR
suffix:semicolon
)brace
r_else
(brace
id|x
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|x
)paren
)paren
suffix:semicolon
id|x-&gt;pattern
op_assign
id|string
suffix:semicolon
)brace
id|x-&gt;to_exclude
op_assign
id|to_exclude
suffix:semicolon
id|x-&gt;patternlen
op_assign
id|strlen
c_func
(paren
id|string
)paren
suffix:semicolon
id|x-&gt;base
op_assign
id|base
suffix:semicolon
id|x-&gt;baselen
op_assign
id|baselen
suffix:semicolon
id|x-&gt;flags
op_assign
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strchr
c_func
(paren
id|string
comma
l_char|&squot;/&squot;
)paren
)paren
id|x-&gt;flags
op_or_assign
id|EXC_FLAG_NODIR
suffix:semicolon
r_if
c_cond
(paren
id|no_wildcard
c_func
(paren
id|string
)paren
)paren
id|x-&gt;flags
op_or_assign
id|EXC_FLAG_NOWILDCARD
suffix:semicolon
r_if
c_cond
(paren
op_star
id|string
op_eq
l_char|&squot;*&squot;
op_logical_and
id|no_wildcard
c_func
(paren
id|string
op_plus
l_int|1
)paren
)paren
id|x-&gt;flags
op_or_assign
id|EXC_FLAG_ENDSWITH
suffix:semicolon
id|ALLOC_GROW
c_func
(paren
id|which-&gt;excludes
comma
id|which-&gt;nr
op_plus
l_int|1
comma
id|which-&gt;alloc
)paren
suffix:semicolon
id|which-&gt;excludes
(braket
id|which-&gt;nr
op_increment
)braket
op_assign
id|x
suffix:semicolon
)brace
DECL|function|read_skip_worktree_file_from_index
r_static
r_void
op_star
id|read_skip_worktree_file_from_index
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_int
op_star
id|size
)paren
(brace
r_int
id|pos
comma
id|len
suffix:semicolon
r_int
r_int
id|sz
suffix:semicolon
r_enum
id|object_type
id|type
suffix:semicolon
r_void
op_star
id|data
suffix:semicolon
r_struct
id|index_state
op_star
id|istate
op_assign
op_amp
id|the_index
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|path
)paren
suffix:semicolon
id|pos
op_assign
id|index_name_pos
c_func
(paren
id|istate
comma
id|path
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ce_skip_worktree
c_func
(paren
id|istate-&gt;cache
(braket
id|pos
)braket
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|data
op_assign
id|read_sha1_file
c_func
(paren
id|istate-&gt;cache
(braket
id|pos
)braket
op_member_access_from_pointer
id|sha1
comma
op_amp
id|type
comma
op_amp
id|sz
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
op_logical_or
id|type
op_ne
id|OBJ_BLOB
)paren
(brace
id|free
c_func
(paren
id|data
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
op_star
id|size
op_assign
id|xsize_t
c_func
(paren
id|sz
)paren
suffix:semicolon
r_return
id|data
suffix:semicolon
)brace
DECL|function|free_excludes
r_void
id|free_excludes
c_func
(paren
r_struct
id|exclude_list
op_star
id|el
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|el-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
id|free
c_func
(paren
id|el-&gt;excludes
(braket
id|i
)braket
)paren
suffix:semicolon
id|free
c_func
(paren
id|el-&gt;excludes
)paren
suffix:semicolon
id|el-&gt;nr
op_assign
l_int|0
suffix:semicolon
id|el-&gt;excludes
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|add_excludes_from_file_to_list
r_int
id|add_excludes_from_file_to_list
c_func
(paren
r_const
r_char
op_star
id|fname
comma
r_const
r_char
op_star
id|base
comma
r_int
id|baselen
comma
r_char
op_star
op_star
id|buf_p
comma
r_struct
id|exclude_list
op_star
id|which
comma
r_int
id|check_index
)paren
(brace
r_struct
id|stat
id|st
suffix:semicolon
r_int
id|fd
comma
id|i
suffix:semicolon
r_int
id|size
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|buf
comma
op_star
id|entry
suffix:semicolon
id|fd
op_assign
id|open
c_func
(paren
id|fname
comma
id|O_RDONLY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
op_logical_or
id|fstat
c_func
(paren
id|fd
comma
op_amp
id|st
)paren
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
l_int|0
op_le
id|fd
)paren
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|check_index
op_logical_or
(paren
id|buf
op_assign
id|read_skip_worktree_file_from_index
c_func
(paren
id|fname
comma
op_amp
id|size
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
(brace
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buf
(braket
id|size
op_minus
l_int|1
)braket
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|buf
op_assign
id|xrealloc
c_func
(paren
id|buf
comma
id|size
op_plus
l_int|1
)paren
suffix:semicolon
id|buf
(braket
id|size
op_increment
)braket
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
)brace
)brace
r_else
(brace
id|size
op_assign
id|xsize_t
c_func
(paren
id|st.st_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
(brace
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|buf
op_assign
id|xmalloc
c_func
(paren
id|size
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_in_full
c_func
(paren
id|fd
comma
id|buf
comma
id|size
)paren
op_ne
id|size
)paren
(brace
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|buf
(braket
id|size
op_increment
)braket
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buf_p
)paren
op_star
id|buf_p
op_assign
id|buf
suffix:semicolon
id|entry
op_assign
id|buf
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|size
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|buf
(braket
id|i
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
r_if
c_cond
(paren
id|entry
op_ne
id|buf
op_plus
id|i
op_logical_and
id|entry
(braket
l_int|0
)braket
op_ne
l_char|&squot;#&squot;
)paren
(brace
id|buf
(braket
id|i
(paren
id|i
op_logical_and
id|buf
(braket
id|i
op_minus
l_int|1
)braket
op_eq
l_char|&squot;&bslash;r&squot;
)paren
)braket
op_assign
l_int|0
suffix:semicolon
id|add_exclude
c_func
(paren
id|entry
comma
id|base
comma
id|baselen
comma
id|which
)paren
suffix:semicolon
)brace
id|entry
op_assign
id|buf
op_plus
id|i
op_plus
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|add_excludes_from_file
r_void
id|add_excludes_from_file
c_func
(paren
r_struct
id|dir_struct
op_star
id|dir
comma
r_const
r_char
op_star
id|fname
)paren
(brace
r_if
c_cond
(paren
id|add_excludes_from_file_to_list
c_func
(paren
id|fname
comma
l_string|&quot;&quot;
comma
l_int|0
comma
l_int|NULL
comma
op_amp
id|dir-&gt;exclude_list
(braket
id|EXC_FILE
)braket
comma
l_int|0
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;cannot use %s as an exclude file&quot;
comma
id|fname
)paren
suffix:semicolon
)brace
DECL|function|prep_exclude
r_static
r_void
id|prep_exclude
c_func
(paren
r_struct
id|dir_struct
op_star
id|dir
comma
r_const
r_char
op_star
id|base
comma
r_int
id|baselen
)paren
(brace
r_struct
id|exclude_list
op_star
id|el
suffix:semicolon
r_struct
id|exclude_stack
op_star
id|stk
op_assign
l_int|NULL
suffix:semicolon
r_int
id|current
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|dir-&gt;exclude_per_dir
)paren
op_logical_or
(paren
id|baselen
op_plus
id|strlen
c_func
(paren
id|dir-&gt;exclude_per_dir
)paren
op_ge
id|PATH_MAX
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* too long a path -- ignore */
multiline_comment|/* Pop the ones that are not the prefix of the path being checked. */
id|el
op_assign
op_amp
id|dir-&gt;exclude_list
(braket
id|EXC_DIRS
)braket
suffix:semicolon
r_while
c_loop
(paren
(paren
id|stk
op_assign
id|dir-&gt;exclude_stack
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|stk-&gt;baselen
op_le
id|baselen
op_logical_and
op_logical_neg
id|strncmp
c_func
(paren
id|dir-&gt;basebuf
comma
id|base
comma
id|stk-&gt;baselen
)paren
)paren
r_break
suffix:semicolon
id|dir-&gt;exclude_stack
op_assign
id|stk-&gt;prev
suffix:semicolon
r_while
c_loop
(paren
id|stk-&gt;exclude_ix
OL
id|el-&gt;nr
)paren
id|free
c_func
(paren
id|el-&gt;excludes
(braket
op_decrement
id|el-&gt;nr
)braket
)paren
suffix:semicolon
id|free
c_func
(paren
id|stk-&gt;filebuf
)paren
suffix:semicolon
id|free
c_func
(paren
id|stk
)paren
suffix:semicolon
)brace
multiline_comment|/* Read from the parent directories and push them down. */
id|current
op_assign
id|stk
ques
c_cond
id|stk-&gt;baselen
suffix:colon
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|current
OL
id|baselen
)paren
(brace
r_struct
id|exclude_stack
op_star
id|stk
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|stk
)paren
)paren
suffix:semicolon
r_const
r_char
op_star
id|cp
suffix:semicolon
r_if
c_cond
(paren
id|current
OL
l_int|0
)paren
(brace
id|cp
op_assign
id|base
suffix:semicolon
id|current
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|cp
op_assign
id|strchr
c_func
(paren
id|base
op_plus
id|current
op_plus
l_int|1
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
id|die
c_func
(paren
l_string|&quot;oops in prep_exclude&quot;
)paren
suffix:semicolon
id|cp
op_increment
suffix:semicolon
)brace
id|stk-&gt;prev
op_assign
id|dir-&gt;exclude_stack
suffix:semicolon
id|stk-&gt;baselen
op_assign
id|cp
id|base
suffix:semicolon
id|stk-&gt;exclude_ix
op_assign
id|el-&gt;nr
suffix:semicolon
id|memcpy
c_func
(paren
id|dir-&gt;basebuf
op_plus
id|current
comma
id|base
op_plus
id|current
comma
id|stk-&gt;baselen
id|current
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|dir-&gt;basebuf
op_plus
id|stk-&gt;baselen
comma
id|dir-&gt;exclude_per_dir
)paren
suffix:semicolon
id|add_excludes_from_file_to_list
c_func
(paren
id|dir-&gt;basebuf
comma
id|dir-&gt;basebuf
comma
id|stk-&gt;baselen
comma
op_amp
id|stk-&gt;filebuf
comma
id|el
comma
l_int|1
)paren
suffix:semicolon
id|dir-&gt;exclude_stack
op_assign
id|stk
suffix:semicolon
id|current
op_assign
id|stk-&gt;baselen
suffix:semicolon
)brace
id|dir-&gt;basebuf
(braket
id|baselen
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
multiline_comment|/* Scan the list and let the last match determine the fate.&n; * Return 1 for exclude, 0 for include and -1 for undecided.&n; */
DECL|function|excluded_from_list
r_int
id|excluded_from_list
c_func
(paren
r_const
r_char
op_star
id|pathname
comma
r_int
id|pathlen
comma
r_const
r_char
op_star
id|basename
comma
r_int
op_star
id|dtype
comma
r_struct
id|exclude_list
op_star
id|el
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|el-&gt;nr
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
id|el-&gt;nr
l_int|1
suffix:semicolon
l_int|0
op_le
id|i
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_struct
id|exclude
op_star
id|x
op_assign
id|el-&gt;excludes
(braket
id|i
)braket
suffix:semicolon
r_const
r_char
op_star
id|exclude
op_assign
id|x-&gt;pattern
suffix:semicolon
r_int
id|to_exclude
op_assign
id|x-&gt;to_exclude
suffix:semicolon
r_if
c_cond
(paren
id|x-&gt;flags
op_amp
id|EXC_FLAG_MUSTBEDIR
)paren
(brace
r_if
c_cond
(paren
op_star
id|dtype
op_eq
id|DT_UNKNOWN
)paren
op_star
id|dtype
op_assign
id|get_dtype
c_func
(paren
l_int|NULL
comma
id|pathname
comma
id|pathlen
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|dtype
op_ne
id|DT_DIR
)paren
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x-&gt;flags
op_amp
id|EXC_FLAG_NODIR
)paren
(brace
multiline_comment|/* match basename */
r_if
c_cond
(paren
id|x-&gt;flags
op_amp
id|EXC_FLAG_NOWILDCARD
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp_icase
c_func
(paren
id|exclude
comma
id|basename
)paren
)paren
r_return
id|to_exclude
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|x-&gt;flags
op_amp
id|EXC_FLAG_ENDSWITH
)paren
(brace
r_if
c_cond
(paren
id|x-&gt;patternlen
l_int|1
op_le
id|pathlen
op_logical_and
op_logical_neg
id|strcmp_icase
c_func
(paren
id|exclude
op_plus
l_int|1
comma
id|pathname
op_plus
id|pathlen
id|x-&gt;patternlen
op_plus
l_int|1
)paren
)paren
r_return
id|to_exclude
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|fnmatch_icase
c_func
(paren
id|exclude
comma
id|basename
comma
l_int|0
)paren
op_eq
l_int|0
)paren
r_return
id|to_exclude
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* match with FNM_PATHNAME:&n;&t;&t;&t;&t; * exclude has base (baselen long) implicitly&n;&t;&t;&t;&t; * in front of it.&n;&t;&t;&t;&t; */
r_int
id|baselen
op_assign
id|x-&gt;baselen
suffix:semicolon
r_if
c_cond
(paren
op_star
id|exclude
op_eq
l_char|&squot;/&squot;
)paren
id|exclude
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|pathlen
OL
id|baselen
op_logical_or
(paren
id|baselen
op_logical_and
id|pathname
(braket
id|baselen
op_minus
l_int|1
)braket
op_ne
l_char|&squot;/&squot;
)paren
op_logical_or
id|strncmp_icase
c_func
(paren
id|pathname
comma
id|x-&gt;base
comma
id|baselen
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|x-&gt;flags
op_amp
id|EXC_FLAG_NOWILDCARD
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp_icase
c_func
(paren
id|exclude
comma
id|pathname
op_plus
id|baselen
)paren
)paren
r_return
id|to_exclude
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|fnmatch_icase
c_func
(paren
id|exclude
comma
id|pathname
op_plus
id|baselen
comma
id|FNM_PATHNAME
)paren
op_eq
l_int|0
)paren
r_return
id|to_exclude
suffix:semicolon
)brace
)brace
)brace
)brace
r_return
l_int|1
suffix:semicolon
multiline_comment|/* undecided */
)brace
DECL|function|excluded
r_int
id|excluded
c_func
(paren
r_struct
id|dir_struct
op_star
id|dir
comma
r_const
r_char
op_star
id|pathname
comma
r_int
op_star
id|dtype_p
)paren
(brace
r_int
id|pathlen
op_assign
id|strlen
c_func
(paren
id|pathname
)paren
suffix:semicolon
r_int
id|st
suffix:semicolon
r_const
r_char
op_star
id|basename
op_assign
id|strrchr
c_func
(paren
id|pathname
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
id|basename
op_assign
(paren
id|basename
)paren
ques
c_cond
id|basename
op_plus
l_int|1
suffix:colon
id|pathname
suffix:semicolon
id|prep_exclude
c_func
(paren
id|dir
comma
id|pathname
comma
id|basename
op_minus
id|pathname
)paren
suffix:semicolon
r_for
c_loop
(paren
id|st
op_assign
id|EXC_CMDL
suffix:semicolon
id|st
op_le
id|EXC_FILE
suffix:semicolon
id|st
op_increment
)paren
(brace
r_switch
c_cond
(paren
id|excluded_from_list
c_func
(paren
id|pathname
comma
id|pathlen
comma
id|basename
comma
id|dtype_p
comma
op_amp
id|dir-&gt;exclude_list
(braket
id|st
)braket
)paren
)paren
(brace
r_case
l_int|0
suffix:colon
r_return
l_int|0
suffix:semicolon
r_case
l_int|1
suffix:colon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|dir_entry_new
r_static
r_struct
id|dir_entry
op_star
id|dir_entry_new
c_func
(paren
r_const
r_char
op_star
id|pathname
comma
r_int
id|len
)paren
(brace
r_struct
id|dir_entry
op_star
id|ent
suffix:semicolon
id|ent
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|ent
)paren
op_plus
id|len
op_plus
l_int|1
)paren
suffix:semicolon
id|ent-&gt;len
op_assign
id|len
suffix:semicolon
id|memcpy
c_func
(paren
id|ent-&gt;name
comma
id|pathname
comma
id|len
)paren
suffix:semicolon
id|ent-&gt;name
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
r_return
id|ent
suffix:semicolon
)brace
DECL|function|dir_add_name
r_static
r_struct
id|dir_entry
op_star
id|dir_add_name
c_func
(paren
r_struct
id|dir_struct
op_star
id|dir
comma
r_const
r_char
op_star
id|pathname
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|cache_name_exists
c_func
(paren
id|pathname
comma
id|len
comma
id|ignore_case
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|ALLOC_GROW
c_func
(paren
id|dir-&gt;entries
comma
id|dir-&gt;nr
op_plus
l_int|1
comma
id|dir-&gt;alloc
)paren
suffix:semicolon
r_return
id|dir-&gt;entries
(braket
id|dir-&gt;nr
op_increment
)braket
op_assign
id|dir_entry_new
c_func
(paren
id|pathname
comma
id|len
)paren
suffix:semicolon
)brace
DECL|function|dir_add_ignored
r_struct
id|dir_entry
op_star
id|dir_add_ignored
c_func
(paren
r_struct
id|dir_struct
op_star
id|dir
comma
r_const
r_char
op_star
id|pathname
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cache_name_is_other
c_func
(paren
id|pathname
comma
id|len
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|ALLOC_GROW
c_func
(paren
id|dir-&gt;ignored
comma
id|dir-&gt;ignored_nr
op_plus
l_int|1
comma
id|dir-&gt;ignored_alloc
)paren
suffix:semicolon
r_return
id|dir-&gt;ignored
(braket
id|dir-&gt;ignored_nr
op_increment
)braket
op_assign
id|dir_entry_new
c_func
(paren
id|pathname
comma
id|len
)paren
suffix:semicolon
)brace
DECL|enum|exist_status
r_enum
id|exist_status
(brace
DECL|enumerator|index_nonexistent
id|index_nonexistent
op_assign
l_int|0
comma
DECL|enumerator|index_directory
id|index_directory
comma
DECL|enumerator|index_gitdir
id|index_gitdir
)brace
suffix:semicolon
multiline_comment|/*&n; * Do not use the alphabetically stored index to look up&n; * the directory name; instead, use the case insensitive&n; * name hash.&n; */
DECL|function|directory_exists_in_index_icase
r_static
r_enum
id|exist_status
id|directory_exists_in_index_icase
c_func
(paren
r_const
r_char
op_star
id|dirname
comma
r_int
id|len
)paren
(brace
r_struct
id|cache_entry
op_star
id|ce
op_assign
id|index_name_exists
c_func
(paren
op_amp
id|the_index
comma
id|dirname
comma
id|len
op_plus
l_int|1
comma
id|ignore_case
)paren
suffix:semicolon
r_int
r_char
id|endchar
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ce
)paren
r_return
id|index_nonexistent
suffix:semicolon
id|endchar
op_assign
id|ce-&gt;name
(braket
id|len
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * The cache_entry structure returned will contain this dirname&n;&t; * and possibly additional path components.&n;&t; */
r_if
c_cond
(paren
id|endchar
op_eq
l_char|&squot;/&squot;
)paren
r_return
id|index_directory
suffix:semicolon
multiline_comment|/*&n;&t; * If there are no additional path components, then this cache_entry&n;&t; * represents a submodule.  Submodules, despite being directories,&n;&t; * are stored in the cache without a closing slash.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|endchar
op_logical_and
id|S_ISGITLINK
c_func
(paren
id|ce-&gt;ce_mode
)paren
)paren
r_return
id|index_gitdir
suffix:semicolon
multiline_comment|/* This should never be hit, but it exists just in case. */
r_return
id|index_nonexistent
suffix:semicolon
)brace
multiline_comment|/*&n; * The index sorts alphabetically by entry name, which&n; * means that a gitlink sorts as &squot;&bslash;0&squot; at the end, while&n; * a directory (which is defined not as an entry, but as&n; * the files it contains) will sort with the &squot;/&squot; at the&n; * end.&n; */
DECL|function|directory_exists_in_index
r_static
r_enum
id|exist_status
id|directory_exists_in_index
c_func
(paren
r_const
r_char
op_star
id|dirname
comma
r_int
id|len
)paren
(brace
r_int
id|pos
suffix:semicolon
r_if
c_cond
(paren
id|ignore_case
)paren
r_return
id|directory_exists_in_index_icase
c_func
(paren
id|dirname
comma
id|len
)paren
suffix:semicolon
id|pos
op_assign
id|cache_name_pos
c_func
(paren
id|dirname
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
l_int|0
)paren
id|pos
op_assign
id|pos
op_minus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|pos
OL
id|active_nr
)paren
(brace
r_struct
id|cache_entry
op_star
id|ce
op_assign
id|active_cache
(braket
id|pos
op_increment
)braket
suffix:semicolon
r_int
r_char
id|endchar
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|ce-&gt;name
comma
id|dirname
comma
id|len
)paren
)paren
r_break
suffix:semicolon
id|endchar
op_assign
id|ce-&gt;name
(braket
id|len
)braket
suffix:semicolon
r_if
c_cond
(paren
id|endchar
OG
l_char|&squot;/&squot;
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|endchar
op_eq
l_char|&squot;/&squot;
)paren
r_return
id|index_directory
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|endchar
op_logical_and
id|S_ISGITLINK
c_func
(paren
id|ce-&gt;ce_mode
)paren
)paren
r_return
id|index_gitdir
suffix:semicolon
)brace
r_return
id|index_nonexistent
suffix:semicolon
)brace
multiline_comment|/*&n; * When we find a directory when traversing the filesystem, we&n; * have three distinct cases:&n; *&n; *  - ignore it&n; *  - see it as a directory&n; *  - recurse into it&n; *&n; * and which one we choose depends on a combination of existing&n; * git index contents and the flags passed into the directory&n; * traversal routine.&n; *&n; * Case 1: If we *already* have entries in the index under that&n; * directory name, we always recurse into the directory to see&n; * all the files.&n; *&n; * Case 2: If we *already* have that directory name as a gitlink,&n; * we always continue to see it as a gitlink, regardless of whether&n; * there is an actual git directory there or not (it might not&n; * be checked out as a subproject!)&n; *&n; * Case 3: if we didn&squot;t have it in the index previously, we&n; * have a few sub-cases:&n; *&n; *  (a) if &quot;show_other_directories&quot; is true, we show it as&n; *      just a directory, unless &quot;hide_empty_directories&quot; is&n; *      also true and the directory is empty, in which case&n; *      we just ignore it entirely.&n; *  (b) if it looks like a git directory, and we don&squot;t have&n; *      &squot;no_gitlinks&squot; set we treat it as a gitlink, and show it&n; *      as a directory.&n; *  (c) otherwise, we recurse into it.&n; */
DECL|enum|directory_treatment
r_enum
id|directory_treatment
(brace
DECL|enumerator|show_directory
id|show_directory
comma
DECL|enumerator|ignore_directory
id|ignore_directory
comma
DECL|enumerator|recurse_into_directory
id|recurse_into_directory
)brace
suffix:semicolon
DECL|function|treat_directory
r_static
r_enum
id|directory_treatment
id|treat_directory
c_func
(paren
r_struct
id|dir_struct
op_star
id|dir
comma
r_const
r_char
op_star
id|dirname
comma
r_int
id|len
comma
r_const
r_struct
id|path_simplify
op_star
id|simplify
)paren
(brace
multiline_comment|/* The &quot;len-1&quot; is to strip the final &squot;/&squot; */
r_switch
c_cond
(paren
id|directory_exists_in_index
c_func
(paren
id|dirname
comma
id|len
op_minus
l_int|1
)paren
)paren
(brace
r_case
id|index_directory
suffix:colon
r_return
id|recurse_into_directory
suffix:semicolon
r_case
id|index_gitdir
suffix:colon
r_if
c_cond
(paren
id|dir-&gt;flags
op_amp
id|DIR_SHOW_OTHER_DIRECTORIES
)paren
r_return
id|ignore_directory
suffix:semicolon
r_return
id|show_directory
suffix:semicolon
r_case
id|index_nonexistent
suffix:colon
r_if
c_cond
(paren
id|dir-&gt;flags
op_amp
id|DIR_SHOW_OTHER_DIRECTORIES
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|dir-&gt;flags
op_amp
id|DIR_NO_GITLINKS
)paren
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_if
c_cond
(paren
id|resolve_gitlink_ref
c_func
(paren
id|dirname
comma
l_string|&quot;HEAD&quot;
comma
id|sha1
)paren
op_eq
l_int|0
)paren
r_return
id|show_directory
suffix:semicolon
)brace
r_return
id|recurse_into_directory
suffix:semicolon
)brace
multiline_comment|/* This is the &quot;show_other_directories&quot; case */
r_if
c_cond
(paren
op_logical_neg
(paren
id|dir-&gt;flags
op_amp
id|DIR_HIDE_EMPTY_DIRECTORIES
)paren
)paren
r_return
id|show_directory
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|read_directory_recursive
c_func
(paren
id|dir
comma
id|dirname
comma
id|len
comma
l_int|1
comma
id|simplify
)paren
)paren
r_return
id|ignore_directory
suffix:semicolon
r_return
id|show_directory
suffix:semicolon
)brace
multiline_comment|/*&n; * This is an inexact early pruning of any recursive directory&n; * reading - if the path cannot possibly be in the pathspec,&n; * return true, and we&squot;ll skip it early.&n; */
DECL|function|simplify_away
r_static
r_int
id|simplify_away
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_int
id|pathlen
comma
r_const
r_struct
id|path_simplify
op_star
id|simplify
)paren
(brace
r_if
c_cond
(paren
id|simplify
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_const
r_char
op_star
id|match
op_assign
id|simplify-&gt;path
suffix:semicolon
r_int
id|len
op_assign
id|simplify-&gt;len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|match
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|pathlen
)paren
id|len
op_assign
id|pathlen
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|path
comma
id|match
comma
id|len
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|simplify
op_increment
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function tells us whether an excluded path matches a&n; * list of &quot;interesting&quot; pathspecs. That is, whether a path matched&n; * by any of the pathspecs could possibly be ignored by excluding&n; * the specified path. This can happen if:&n; *&n; *   1. the path is mentioned explicitly in the pathspec&n; *&n; *   2. the path is a directory prefix of some element in the&n; *      pathspec&n; */
DECL|function|exclude_matches_pathspec
r_static
r_int
id|exclude_matches_pathspec
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_int
id|len
comma
r_const
r_struct
id|path_simplify
op_star
id|simplify
)paren
(brace
r_if
c_cond
(paren
id|simplify
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|simplify-&gt;path
suffix:semicolon
id|simplify
op_increment
)paren
(brace
r_if
c_cond
(paren
id|len
op_eq
id|simplify-&gt;len
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|path
comma
id|simplify-&gt;path
comma
id|len
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
id|simplify-&gt;len
op_logical_and
id|simplify-&gt;path
(braket
id|len
)braket
op_eq
l_char|&squot;/&squot;
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|path
comma
id|simplify-&gt;path
comma
id|len
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|get_index_dtype
r_static
r_int
id|get_index_dtype
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_int
id|len
)paren
(brace
r_int
id|pos
suffix:semicolon
r_struct
id|cache_entry
op_star
id|ce
suffix:semicolon
id|ce
op_assign
id|cache_name_exists
c_func
(paren
id|path
comma
id|len
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ce
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ce_uptodate
c_func
(paren
id|ce
)paren
)paren
r_return
id|DT_UNKNOWN
suffix:semicolon
r_if
c_cond
(paren
id|S_ISGITLINK
c_func
(paren
id|ce-&gt;ce_mode
)paren
)paren
r_return
id|DT_DIR
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Nobody actually cares about the&n;&t;&t; * difference between DT_LNK and DT_REG&n;&t;&t; */
r_return
id|DT_REG
suffix:semicolon
)brace
multiline_comment|/* Try to look it up as a directory */
id|pos
op_assign
id|cache_name_pos
c_func
(paren
id|path
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_ge
l_int|0
)paren
r_return
id|DT_UNKNOWN
suffix:semicolon
id|pos
op_assign
id|pos
op_minus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|pos
OL
id|active_nr
)paren
(brace
id|ce
op_assign
id|active_cache
(braket
id|pos
op_increment
)braket
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|ce-&gt;name
comma
id|path
comma
id|len
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|ce-&gt;name
(braket
id|len
)braket
OG
l_char|&squot;/&squot;
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|ce-&gt;name
(braket
id|len
)braket
OL
l_char|&squot;/&squot;
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ce_uptodate
c_func
(paren
id|ce
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* continue? */
r_return
id|DT_DIR
suffix:semicolon
)brace
r_return
id|DT_UNKNOWN
suffix:semicolon
)brace
DECL|function|get_dtype
r_static
r_int
id|get_dtype
c_func
(paren
r_struct
id|dirent
op_star
id|de
comma
r_const
r_char
op_star
id|path
comma
r_int
id|len
)paren
(brace
r_int
id|dtype
op_assign
id|de
ques
c_cond
id|DTYPE
c_func
(paren
id|de
)paren
suffix:colon
id|DT_UNKNOWN
suffix:semicolon
r_struct
id|stat
id|st
suffix:semicolon
r_if
c_cond
(paren
id|dtype
op_ne
id|DT_UNKNOWN
)paren
r_return
id|dtype
suffix:semicolon
id|dtype
op_assign
id|get_index_dtype
c_func
(paren
id|path
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dtype
op_ne
id|DT_UNKNOWN
)paren
r_return
id|dtype
suffix:semicolon
r_if
c_cond
(paren
id|lstat
c_func
(paren
id|path
comma
op_amp
id|st
)paren
)paren
r_return
id|dtype
suffix:semicolon
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|st.st_mode
)paren
)paren
r_return
id|DT_REG
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|st.st_mode
)paren
)paren
r_return
id|DT_DIR
suffix:semicolon
r_if
c_cond
(paren
id|S_ISLNK
c_func
(paren
id|st.st_mode
)paren
)paren
r_return
id|DT_LNK
suffix:semicolon
r_return
id|dtype
suffix:semicolon
)brace
DECL|enum|path_treatment
r_enum
id|path_treatment
(brace
DECL|enumerator|path_ignored
id|path_ignored
comma
DECL|enumerator|path_handled
id|path_handled
comma
DECL|enumerator|path_recurse
id|path_recurse
)brace
suffix:semicolon
DECL|function|treat_one_path
r_static
r_enum
id|path_treatment
id|treat_one_path
c_func
(paren
r_struct
id|dir_struct
op_star
id|dir
comma
r_char
op_star
id|path
comma
r_int
op_star
id|len
comma
r_const
r_struct
id|path_simplify
op_star
id|simplify
comma
r_int
id|dtype
comma
r_struct
id|dirent
op_star
id|de
)paren
(brace
r_int
id|exclude
op_assign
id|excluded
c_func
(paren
id|dir
comma
id|path
comma
op_amp
id|dtype
)paren
suffix:semicolon
r_if
c_cond
(paren
id|exclude
op_logical_and
(paren
id|dir-&gt;flags
op_amp
id|DIR_COLLECT_IGNORED
)paren
op_logical_and
id|exclude_matches_pathspec
c_func
(paren
id|path
comma
op_star
id|len
comma
id|simplify
)paren
)paren
id|dir_add_ignored
c_func
(paren
id|dir
comma
id|path
comma
op_star
id|len
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Excluded? If we don&squot;t explicitly want to show&n;&t; * ignored files, ignore it&n;&t; */
r_if
c_cond
(paren
id|exclude
op_logical_and
op_logical_neg
(paren
id|dir-&gt;flags
op_amp
id|DIR_SHOW_IGNORED
)paren
)paren
r_return
id|path_ignored
suffix:semicolon
r_if
c_cond
(paren
id|dtype
op_eq
id|DT_UNKNOWN
)paren
id|dtype
op_assign
id|get_dtype
c_func
(paren
id|de
comma
id|path
comma
op_star
id|len
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Do we want to see just the ignored files?&n;&t; * We still need to recurse into directories,&n;&t; * even if we don&squot;t ignore them, since the&n;&t; * directory may contain files that we do..&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|exclude
op_logical_and
(paren
id|dir-&gt;flags
op_amp
id|DIR_SHOW_IGNORED
)paren
)paren
(brace
r_if
c_cond
(paren
id|dtype
op_ne
id|DT_DIR
)paren
r_return
id|path_ignored
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|dtype
)paren
(brace
r_default
suffix:colon
r_return
id|path_ignored
suffix:semicolon
r_case
id|DT_DIR
suffix:colon
id|memcpy
c_func
(paren
id|path
op_plus
op_star
id|len
comma
l_string|&quot;/&quot;
comma
l_int|2
)paren
suffix:semicolon
(paren
op_star
id|len
)paren
op_increment
suffix:semicolon
r_switch
c_cond
(paren
id|treat_directory
c_func
(paren
id|dir
comma
id|path
comma
op_star
id|len
comma
id|simplify
)paren
)paren
(brace
r_case
id|show_directory
suffix:colon
r_if
c_cond
(paren
id|exclude
op_ne
op_logical_neg
op_logical_neg
(paren
id|dir-&gt;flags
op_amp
id|DIR_SHOW_IGNORED
)paren
)paren
r_return
id|path_ignored
suffix:semicolon
r_break
suffix:semicolon
r_case
id|recurse_into_directory
suffix:colon
r_return
id|path_recurse
suffix:semicolon
r_case
id|ignore_directory
suffix:colon
r_return
id|path_ignored
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|DT_REG
suffix:colon
r_case
id|DT_LNK
suffix:colon
r_break
suffix:semicolon
)brace
r_return
id|path_handled
suffix:semicolon
)brace
DECL|function|treat_path
r_static
r_enum
id|path_treatment
id|treat_path
c_func
(paren
r_struct
id|dir_struct
op_star
id|dir
comma
r_struct
id|dirent
op_star
id|de
comma
r_char
op_star
id|path
comma
r_int
id|path_max
comma
r_int
id|baselen
comma
r_const
r_struct
id|path_simplify
op_star
id|simplify
comma
r_int
op_star
id|len
)paren
(brace
r_int
id|dtype
suffix:semicolon
r_if
c_cond
(paren
id|is_dot_or_dotdot
c_func
(paren
id|de-&gt;d_name
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|de-&gt;d_name
comma
l_string|&quot;.git&quot;
)paren
)paren
r_return
id|path_ignored
suffix:semicolon
op_star
id|len
op_assign
id|strlen
c_func
(paren
id|de-&gt;d_name
)paren
suffix:semicolon
multiline_comment|/* Ignore overly long pathnames! */
r_if
c_cond
(paren
op_star
id|len
op_plus
id|baselen
op_plus
l_int|8
OG
id|path_max
)paren
r_return
id|path_ignored
suffix:semicolon
id|memcpy
c_func
(paren
id|path
op_plus
id|baselen
comma
id|de-&gt;d_name
comma
op_star
id|len
op_plus
l_int|1
)paren
suffix:semicolon
op_star
id|len
op_add_assign
id|baselen
suffix:semicolon
r_if
c_cond
(paren
id|simplify_away
c_func
(paren
id|path
comma
op_star
id|len
comma
id|simplify
)paren
)paren
r_return
id|path_ignored
suffix:semicolon
id|dtype
op_assign
id|DTYPE
c_func
(paren
id|de
)paren
suffix:semicolon
r_return
id|treat_one_path
c_func
(paren
id|dir
comma
id|path
comma
id|len
comma
id|simplify
comma
id|dtype
comma
id|de
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Read a directory tree. We currently ignore anything but&n; * directories, regular files and symlinks. That&squot;s because git&n; * doesn&squot;t handle them at all yet. Maybe that will change some&n; * day.&n; *&n; * Also, we ignore the name &quot;.git&quot; (even if it is not a directory).&n; * That likely will not change.&n; */
DECL|function|read_directory_recursive
r_static
r_int
id|read_directory_recursive
c_func
(paren
r_struct
id|dir_struct
op_star
id|dir
comma
r_const
r_char
op_star
id|base
comma
r_int
id|baselen
comma
r_int
id|check_only
comma
r_const
r_struct
id|path_simplify
op_star
id|simplify
)paren
(brace
id|DIR
op_star
id|fdir
op_assign
id|opendir
c_func
(paren
op_star
id|base
ques
c_cond
id|base
suffix:colon
l_string|&quot;.&quot;
)paren
suffix:semicolon
r_int
id|contents
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|fdir
)paren
(brace
r_struct
id|dirent
op_star
id|de
suffix:semicolon
r_char
id|path
(braket
id|PATH_MAX
op_plus
l_int|1
)braket
suffix:semicolon
id|memcpy
c_func
(paren
id|path
comma
id|base
comma
id|baselen
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|de
op_assign
id|readdir
c_func
(paren
id|fdir
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_int
id|len
suffix:semicolon
r_switch
c_cond
(paren
id|treat_path
c_func
(paren
id|dir
comma
id|de
comma
id|path
comma
r_sizeof
(paren
id|path
)paren
comma
id|baselen
comma
id|simplify
comma
op_amp
id|len
)paren
)paren
(brace
r_case
id|path_recurse
suffix:colon
id|contents
op_add_assign
id|read_directory_recursive
(paren
id|dir
comma
id|path
comma
id|len
comma
l_int|0
comma
id|simplify
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
id|path_ignored
suffix:colon
r_continue
suffix:semicolon
r_case
id|path_handled
suffix:colon
r_break
suffix:semicolon
)brace
id|contents
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|check_only
)paren
r_goto
id|exit_early
suffix:semicolon
r_else
id|dir_add_name
c_func
(paren
id|dir
comma
id|path
comma
id|len
)paren
suffix:semicolon
)brace
id|exit_early
suffix:colon
id|closedir
c_func
(paren
id|fdir
)paren
suffix:semicolon
)brace
r_return
id|contents
suffix:semicolon
)brace
DECL|function|cmp_name
r_static
r_int
id|cmp_name
c_func
(paren
r_const
r_void
op_star
id|p1
comma
r_const
r_void
op_star
id|p2
)paren
(brace
r_const
r_struct
id|dir_entry
op_star
id|e1
op_assign
op_star
(paren
r_const
r_struct
id|dir_entry
op_star
op_star
)paren
id|p1
suffix:semicolon
r_const
r_struct
id|dir_entry
op_star
id|e2
op_assign
op_star
(paren
r_const
r_struct
id|dir_entry
op_star
op_star
)paren
id|p2
suffix:semicolon
r_return
id|cache_name_compare
c_func
(paren
id|e1-&gt;name
comma
id|e1-&gt;len
comma
id|e2-&gt;name
comma
id|e2-&gt;len
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Return the length of the &quot;simple&quot; part of a path match limiter.&n; */
DECL|function|simple_length
r_static
r_int
id|simple_length
c_func
(paren
r_const
r_char
op_star
id|match
)paren
(brace
r_int
id|len
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
r_char
id|c
op_assign
op_star
id|match
op_increment
suffix:semicolon
id|len
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;0&squot;
op_logical_or
id|is_glob_special
c_func
(paren
id|c
)paren
)paren
r_return
id|len
suffix:semicolon
)brace
)brace
DECL|function|create_simplify
r_static
r_struct
id|path_simplify
op_star
id|create_simplify
c_func
(paren
r_const
r_char
op_star
op_star
id|pathspec
)paren
(brace
r_int
id|nr
comma
id|alloc
op_assign
l_int|0
suffix:semicolon
r_struct
id|path_simplify
op_star
id|simplify
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pathspec
)paren
r_return
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|nr
op_assign
l_int|0
suffix:semicolon
suffix:semicolon
id|nr
op_increment
)paren
(brace
r_const
r_char
op_star
id|match
suffix:semicolon
r_if
c_cond
(paren
id|nr
op_ge
id|alloc
)paren
(brace
id|alloc
op_assign
id|alloc_nr
c_func
(paren
id|alloc
)paren
suffix:semicolon
id|simplify
op_assign
id|xrealloc
c_func
(paren
id|simplify
comma
id|alloc
op_star
r_sizeof
(paren
op_star
id|simplify
)paren
)paren
suffix:semicolon
)brace
id|match
op_assign
op_star
id|pathspec
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|match
)paren
r_break
suffix:semicolon
id|simplify
(braket
id|nr
)braket
dot
id|path
op_assign
id|match
suffix:semicolon
id|simplify
(braket
id|nr
)braket
dot
id|len
op_assign
id|simple_length
c_func
(paren
id|match
)paren
suffix:semicolon
)brace
id|simplify
(braket
id|nr
)braket
dot
id|path
op_assign
l_int|NULL
suffix:semicolon
id|simplify
(braket
id|nr
)braket
dot
id|len
op_assign
l_int|0
suffix:semicolon
r_return
id|simplify
suffix:semicolon
)brace
DECL|function|free_simplify
r_static
r_void
id|free_simplify
c_func
(paren
r_struct
id|path_simplify
op_star
id|simplify
)paren
(brace
id|free
c_func
(paren
id|simplify
)paren
suffix:semicolon
)brace
DECL|function|treat_leading_path
r_static
r_int
id|treat_leading_path
c_func
(paren
r_struct
id|dir_struct
op_star
id|dir
comma
r_const
r_char
op_star
id|path
comma
r_int
id|len
comma
r_const
r_struct
id|path_simplify
op_star
id|simplify
)paren
(brace
r_char
id|pathbuf
(braket
id|PATH_MAX
)braket
suffix:semicolon
r_int
id|baselen
comma
id|blen
suffix:semicolon
r_const
r_char
op_star
id|cp
suffix:semicolon
r_while
c_loop
(paren
id|len
op_logical_and
id|path
(braket
id|len
l_int|1
)braket
op_eq
l_char|&squot;/&squot;
)paren
id|len
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
r_return
l_int|1
suffix:semicolon
id|baselen
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|cp
op_assign
id|path
op_plus
id|baselen
op_plus
op_logical_neg
op_logical_neg
id|baselen
suffix:semicolon
id|cp
op_assign
id|memchr
c_func
(paren
id|cp
comma
l_char|&squot;/&squot;
comma
id|path
op_plus
id|len
id|cp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
id|baselen
op_assign
id|len
suffix:semicolon
r_else
id|baselen
op_assign
id|cp
id|path
suffix:semicolon
id|memcpy
c_func
(paren
id|pathbuf
comma
id|path
comma
id|baselen
)paren
suffix:semicolon
id|pathbuf
(braket
id|baselen
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_directory
c_func
(paren
id|pathbuf
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|simplify_away
c_func
(paren
id|pathbuf
comma
id|baselen
comma
id|simplify
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|blen
op_assign
id|baselen
suffix:semicolon
r_if
c_cond
(paren
id|treat_one_path
c_func
(paren
id|dir
comma
id|pathbuf
comma
op_amp
id|blen
comma
id|simplify
comma
id|DT_DIR
comma
l_int|NULL
)paren
op_eq
id|path_ignored
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* do not recurse into it */
r_if
c_cond
(paren
id|len
op_le
id|baselen
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* finished checking */
)brace
)brace
DECL|function|read_directory
r_int
id|read_directory
c_func
(paren
r_struct
id|dir_struct
op_star
id|dir
comma
r_const
r_char
op_star
id|path
comma
r_int
id|len
comma
r_const
r_char
op_star
op_star
id|pathspec
)paren
(brace
r_struct
id|path_simplify
op_star
id|simplify
suffix:semicolon
r_if
c_cond
(paren
id|has_symlink_leading_path
c_func
(paren
id|path
comma
id|len
)paren
)paren
r_return
id|dir-&gt;nr
suffix:semicolon
id|simplify
op_assign
id|create_simplify
c_func
(paren
id|pathspec
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
op_logical_or
id|treat_leading_path
c_func
(paren
id|dir
comma
id|path
comma
id|len
comma
id|simplify
)paren
)paren
id|read_directory_recursive
c_func
(paren
id|dir
comma
id|path
comma
id|len
comma
l_int|0
comma
id|simplify
)paren
suffix:semicolon
id|free_simplify
c_func
(paren
id|simplify
)paren
suffix:semicolon
id|qsort
c_func
(paren
id|dir-&gt;entries
comma
id|dir-&gt;nr
comma
r_sizeof
(paren
r_struct
id|dir_entry
op_star
)paren
comma
id|cmp_name
)paren
suffix:semicolon
id|qsort
c_func
(paren
id|dir-&gt;ignored
comma
id|dir-&gt;ignored_nr
comma
r_sizeof
(paren
r_struct
id|dir_entry
op_star
)paren
comma
id|cmp_name
)paren
suffix:semicolon
r_return
id|dir-&gt;nr
suffix:semicolon
)brace
DECL|function|file_exists
r_int
id|file_exists
c_func
(paren
r_const
r_char
op_star
id|f
)paren
(brace
r_struct
id|stat
id|sb
suffix:semicolon
r_return
id|lstat
c_func
(paren
id|f
comma
op_amp
id|sb
)paren
op_eq
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Given two normalized paths (a trailing slash is ok), if subdir is&n; * outside dir, return -1.  Otherwise return the offset in subdir that&n; * can be used as relative path to dir.&n; */
DECL|function|dir_inside_of
r_int
id|dir_inside_of
c_func
(paren
r_const
r_char
op_star
id|subdir
comma
r_const
r_char
op_star
id|dir
)paren
(brace
r_int
id|offset
op_assign
l_int|0
suffix:semicolon
m_assert
(paren
id|dir
op_logical_and
id|subdir
op_logical_and
op_star
id|dir
op_logical_and
op_star
id|subdir
)paren
suffix:semicolon
r_while
c_loop
(paren
op_star
id|dir
op_logical_and
op_star
id|subdir
op_logical_and
op_star
id|dir
op_eq
op_star
id|subdir
)paren
(brace
id|dir
op_increment
suffix:semicolon
id|subdir
op_increment
suffix:semicolon
id|offset
op_increment
suffix:semicolon
)brace
multiline_comment|/* hel[p]/me vs hel[l]/yeah */
r_if
c_cond
(paren
op_star
id|dir
op_logical_and
op_star
id|subdir
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|subdir
)paren
r_return
op_logical_neg
op_star
id|dir
ques
c_cond
id|offset
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* same dir */
multiline_comment|/* foo/[b]ar vs foo/[] */
r_if
c_cond
(paren
id|is_dir_sep
c_func
(paren
id|dir
(braket
l_int|1
)braket
)paren
)paren
r_return
id|is_dir_sep
c_func
(paren
id|subdir
(braket
l_int|1
)braket
)paren
ques
c_cond
id|offset
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* foo[/]bar vs foo[] */
r_return
id|is_dir_sep
c_func
(paren
op_star
id|subdir
)paren
ques
c_cond
id|offset
op_plus
l_int|1
suffix:colon
l_int|1
suffix:semicolon
)brace
DECL|function|is_inside_dir
r_int
id|is_inside_dir
c_func
(paren
r_const
r_char
op_star
id|dir
)paren
(brace
r_char
id|cwd
(braket
id|PATH_MAX
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|getcwd
c_func
(paren
id|cwd
comma
r_sizeof
(paren
id|cwd
)paren
)paren
)paren
id|die_errno
c_func
(paren
l_string|&quot;can&squot;t find the current directory&quot;
)paren
suffix:semicolon
r_return
id|dir_inside_of
c_func
(paren
id|cwd
comma
id|dir
)paren
op_ge
l_int|0
suffix:semicolon
)brace
DECL|function|is_empty_dir
r_int
id|is_empty_dir
c_func
(paren
r_const
r_char
op_star
id|path
)paren
(brace
id|DIR
op_star
id|dir
op_assign
id|opendir
c_func
(paren
id|path
)paren
suffix:semicolon
r_struct
id|dirent
op_star
id|e
suffix:semicolon
r_int
id|ret
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir
)paren
r_return
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|e
op_assign
id|readdir
c_func
(paren
id|dir
)paren
)paren
op_ne
l_int|NULL
)paren
r_if
c_cond
(paren
op_logical_neg
id|is_dot_or_dotdot
c_func
(paren
id|e-&gt;d_name
)paren
)paren
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|closedir
c_func
(paren
id|dir
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|remove_dir_recursively
r_int
id|remove_dir_recursively
c_func
(paren
r_struct
id|strbuf
op_star
id|path
comma
r_int
id|flag
)paren
(brace
id|DIR
op_star
id|dir
suffix:semicolon
r_struct
id|dirent
op_star
id|e
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
comma
id|original_len
op_assign
id|path-&gt;len
comma
id|len
suffix:semicolon
r_int
id|only_empty
op_assign
(paren
id|flag
op_amp
id|REMOVE_DIR_EMPTY_ONLY
)paren
suffix:semicolon
r_int
r_char
id|submodule_head
(braket
l_int|20
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flag
op_amp
id|REMOVE_DIR_KEEP_NESTED_GIT
)paren
op_logical_and
op_logical_neg
id|resolve_gitlink_ref
c_func
(paren
id|path-&gt;buf
comma
l_string|&quot;HEAD&quot;
comma
id|submodule_head
)paren
)paren
multiline_comment|/* Do not descend and nuke a nested git work tree. */
r_return
l_int|0
suffix:semicolon
id|dir
op_assign
id|opendir
c_func
(paren
id|path-&gt;buf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir
)paren
r_return
id|rmdir
c_func
(paren
id|path-&gt;buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|path-&gt;buf
(braket
id|original_len
l_int|1
)braket
op_ne
l_char|&squot;/&squot;
)paren
id|strbuf_addch
c_func
(paren
id|path
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
id|len
op_assign
id|path-&gt;len
suffix:semicolon
r_while
c_loop
(paren
(paren
id|e
op_assign
id|readdir
c_func
(paren
id|dir
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_struct
id|stat
id|st
suffix:semicolon
r_if
c_cond
(paren
id|is_dot_or_dotdot
c_func
(paren
id|e-&gt;d_name
)paren
)paren
r_continue
suffix:semicolon
id|strbuf_setlen
c_func
(paren
id|path
comma
id|len
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
id|path
comma
id|e-&gt;d_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lstat
c_func
(paren
id|path-&gt;buf
comma
op_amp
id|st
)paren
)paren
suffix:semicolon
multiline_comment|/* fall thru */
r_else
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|st.st_mode
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|remove_dir_recursively
c_func
(paren
id|path
comma
id|only_empty
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* happy */
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|only_empty
op_logical_and
op_logical_neg
id|unlink
c_func
(paren
id|path-&gt;buf
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* happy, too */
multiline_comment|/* path too long, stat fails, or non-directory still exists */
id|ret
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|closedir
c_func
(paren
id|dir
)paren
suffix:semicolon
id|strbuf_setlen
c_func
(paren
id|path
comma
id|original_len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
id|rmdir
c_func
(paren
id|path-&gt;buf
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|setup_standard_excludes
r_void
id|setup_standard_excludes
c_func
(paren
r_struct
id|dir_struct
op_star
id|dir
)paren
(brace
r_const
r_char
op_star
id|path
suffix:semicolon
id|dir-&gt;exclude_per_dir
op_assign
l_string|&quot;.gitignore&quot;
suffix:semicolon
id|path
op_assign
id|git_path
c_func
(paren
l_string|&quot;info/exclude&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access
c_func
(paren
id|path
comma
id|R_OK
)paren
)paren
id|add_excludes_from_file
c_func
(paren
id|dir
comma
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|excludes_file
op_logical_and
op_logical_neg
id|access
c_func
(paren
id|excludes_file
comma
id|R_OK
)paren
)paren
id|add_excludes_from_file
c_func
(paren
id|dir
comma
id|excludes_file
)paren
suffix:semicolon
)brace
DECL|function|remove_path
r_int
id|remove_path
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_char
op_star
id|slash
suffix:semicolon
r_if
c_cond
(paren
id|unlink
c_func
(paren
id|name
)paren
op_logical_and
id|errno
op_ne
id|ENOENT
)paren
r_return
l_int|1
suffix:semicolon
id|slash
op_assign
id|strrchr
c_func
(paren
id|name
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slash
)paren
(brace
r_char
op_star
id|dirs
op_assign
id|xstrdup
c_func
(paren
id|name
)paren
suffix:semicolon
id|slash
op_assign
id|dirs
op_plus
(paren
id|slash
id|name
)paren
suffix:semicolon
r_do
(brace
op_star
id|slash
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
r_while
c_loop
(paren
id|rmdir
c_func
(paren
id|dirs
)paren
op_eq
l_int|0
op_logical_and
(paren
id|slash
op_assign
id|strrchr
c_func
(paren
id|dirs
comma
l_char|&squot;/&squot;
)paren
)paren
)paren
suffix:semicolon
id|free
c_func
(paren
id|dirs
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pathspec_item_cmp
r_static
r_int
id|pathspec_item_cmp
c_func
(paren
r_const
r_void
op_star
id|a_
comma
r_const
r_void
op_star
id|b_
)paren
(brace
r_struct
id|pathspec_item
op_star
id|a
comma
op_star
id|b
suffix:semicolon
id|a
op_assign
(paren
r_struct
id|pathspec_item
op_star
)paren
id|a_
suffix:semicolon
id|b
op_assign
(paren
r_struct
id|pathspec_item
op_star
)paren
id|b_
suffix:semicolon
r_return
id|strcmp
c_func
(paren
id|a-&gt;match
comma
id|b-&gt;match
)paren
suffix:semicolon
)brace
DECL|function|init_pathspec
r_int
id|init_pathspec
c_func
(paren
r_struct
id|pathspec
op_star
id|pathspec
comma
r_const
r_char
op_star
op_star
id|paths
)paren
(brace
r_const
r_char
op_star
op_star
id|p
op_assign
id|paths
suffix:semicolon
r_int
id|i
suffix:semicolon
id|memset
c_func
(paren
id|pathspec
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|pathspec
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_return
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_star
id|p
)paren
id|p
op_increment
suffix:semicolon
id|pathspec-&gt;raw
op_assign
id|paths
suffix:semicolon
id|pathspec-&gt;nr
op_assign
id|p
id|paths
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pathspec-&gt;nr
)paren
r_return
l_int|0
suffix:semicolon
id|pathspec-&gt;items
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pathspec_item
)paren
op_star
id|pathspec-&gt;nr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pathspec-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|pathspec_item
op_star
id|item
op_assign
id|pathspec-&gt;items
op_plus
id|i
suffix:semicolon
r_const
r_char
op_star
id|path
op_assign
id|paths
(braket
id|i
)braket
suffix:semicolon
id|item-&gt;match
op_assign
id|path
suffix:semicolon
id|item-&gt;len
op_assign
id|strlen
c_func
(paren
id|path
)paren
suffix:semicolon
id|item-&gt;use_wildcard
op_assign
op_logical_neg
id|no_wildcard
c_func
(paren
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|item-&gt;use_wildcard
)paren
id|pathspec-&gt;has_wildcard
op_assign
l_int|1
suffix:semicolon
)brace
id|qsort
c_func
(paren
id|pathspec-&gt;items
comma
id|pathspec-&gt;nr
comma
r_sizeof
(paren
r_struct
id|pathspec_item
)paren
comma
id|pathspec_item_cmp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|free_pathspec
r_void
id|free_pathspec
c_func
(paren
r_struct
id|pathspec
op_star
id|pathspec
)paren
(brace
id|free
c_func
(paren
id|pathspec-&gt;items
)paren
suffix:semicolon
id|pathspec-&gt;items
op_assign
l_int|NULL
suffix:semicolon
)brace
eof
