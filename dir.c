multiline_comment|/*&n; * This handles recursive filename detection with exclude&n; * files, index knowledge etc..&n; *&n; * See Documentation/technical/api-directory-listing.txt&n; *&n; * Copyright (C) Linus Torvalds, 2005-2006&n; *&t;&t; Junio Hamano, 2005-2006&n; */
macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;dir.h&quot;
macro_line|#include &quot;refs.h&quot;
macro_line|#include &quot;wildmatch.h&quot;
macro_line|#include &quot;pathspec.h&quot;
DECL|struct|path_simplify
r_struct
id|path_simplify
(brace
DECL|member|len
r_int
id|len
suffix:semicolon
DECL|member|path
r_const
r_char
op_star
id|path
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Tells read_directory_recursive how a file or directory should be treated.&n; * Values are ordered by significance, e.g. if a directory contains both&n; * excluded and untracked files, it is listed as untracked because&n; * path_untracked &gt; path_excluded.&n; */
DECL|enum|path_treatment
r_enum
id|path_treatment
(brace
DECL|enumerator|path_none
id|path_none
op_assign
l_int|0
comma
DECL|enumerator|path_recurse
id|path_recurse
comma
DECL|enumerator|path_excluded
id|path_excluded
comma
DECL|enumerator|path_untracked
id|path_untracked
)brace
suffix:semicolon
r_static
r_enum
id|path_treatment
id|read_directory_recursive
c_func
(paren
r_struct
id|dir_struct
op_star
id|dir
comma
r_const
r_char
op_star
id|path
comma
r_int
id|len
comma
r_int
id|check_only
comma
r_const
r_struct
id|path_simplify
op_star
id|simplify
)paren
suffix:semicolon
r_static
r_int
id|get_dtype
c_func
(paren
r_struct
id|dirent
op_star
id|de
comma
r_const
r_char
op_star
id|path
comma
r_int
id|len
)paren
suffix:semicolon
multiline_comment|/* helper string functions with support for the ignore_case flag */
DECL|function|strcmp_icase
r_int
id|strcmp_icase
c_func
(paren
r_const
r_char
op_star
id|a
comma
r_const
r_char
op_star
id|b
)paren
(brace
r_return
id|ignore_case
ques
c_cond
id|strcasecmp
c_func
(paren
id|a
comma
id|b
)paren
suffix:colon
id|strcmp
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
)brace
DECL|function|strncmp_icase
r_int
id|strncmp_icase
c_func
(paren
r_const
r_char
op_star
id|a
comma
r_const
r_char
op_star
id|b
comma
r_int
id|count
)paren
(brace
r_return
id|ignore_case
ques
c_cond
id|strncasecmp
c_func
(paren
id|a
comma
id|b
comma
id|count
)paren
suffix:colon
id|strncmp
c_func
(paren
id|a
comma
id|b
comma
id|count
)paren
suffix:semicolon
)brace
DECL|function|fnmatch_icase
r_int
id|fnmatch_icase
c_func
(paren
r_const
r_char
op_star
id|pattern
comma
r_const
r_char
op_star
id|string
comma
r_int
id|flags
)paren
(brace
r_return
id|wildmatch
c_func
(paren
id|pattern
comma
id|string
comma
id|flags
op_or
(paren
id|ignore_case
ques
c_cond
id|WM_CASEFOLD
suffix:colon
l_int|0
)paren
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|git_fnmatch
r_int
id|git_fnmatch
c_func
(paren
r_const
r_struct
id|pathspec_item
op_star
id|item
comma
r_const
r_char
op_star
id|pattern
comma
r_const
r_char
op_star
id|string
comma
r_int
id|prefix
)paren
(brace
r_if
c_cond
(paren
id|prefix
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ps_strncmp
c_func
(paren
id|item
comma
id|pattern
comma
id|string
comma
id|prefix
)paren
)paren
r_return
id|WM_NOMATCH
suffix:semicolon
id|pattern
op_add_assign
id|prefix
suffix:semicolon
id|string
op_add_assign
id|prefix
suffix:semicolon
)brace
r_if
c_cond
(paren
id|item-&gt;flags
op_amp
id|PATHSPEC_ONESTAR
)paren
(brace
r_int
id|pattern_len
op_assign
id|strlen
c_func
(paren
op_increment
id|pattern
)paren
suffix:semicolon
r_int
id|string_len
op_assign
id|strlen
c_func
(paren
id|string
)paren
suffix:semicolon
r_return
id|string_len
OL
id|pattern_len
op_logical_or
id|ps_strcmp
c_func
(paren
id|item
comma
id|pattern
comma
id|string
op_plus
id|string_len
id|pattern_len
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|item-&gt;magic
op_amp
id|PATHSPEC_GLOB
)paren
r_return
id|wildmatch
c_func
(paren
id|pattern
comma
id|string
comma
id|WM_PATHNAME
op_or
(paren
id|item-&gt;magic
op_amp
id|PATHSPEC_ICASE
ques
c_cond
id|WM_CASEFOLD
suffix:colon
l_int|0
)paren
comma
l_int|NULL
)paren
suffix:semicolon
r_else
multiline_comment|/* wildmatch has not learned no FNM_PATHNAME mode yet */
r_return
id|wildmatch
c_func
(paren
id|pattern
comma
id|string
comma
id|item-&gt;magic
op_amp
id|PATHSPEC_ICASE
ques
c_cond
id|WM_CASEFOLD
suffix:colon
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|fnmatch_icase_mem
r_static
r_int
id|fnmatch_icase_mem
c_func
(paren
r_const
r_char
op_star
id|pattern
comma
r_int
id|patternlen
comma
r_const
r_char
op_star
id|string
comma
r_int
id|stringlen
comma
r_int
id|flags
)paren
(brace
r_int
id|match_status
suffix:semicolon
r_struct
id|strbuf
id|pat_buf
op_assign
id|STRBUF_INIT
suffix:semicolon
r_struct
id|strbuf
id|str_buf
op_assign
id|STRBUF_INIT
suffix:semicolon
r_const
r_char
op_star
id|use_pat
op_assign
id|pattern
suffix:semicolon
r_const
r_char
op_star
id|use_str
op_assign
id|string
suffix:semicolon
r_if
c_cond
(paren
id|pattern
(braket
id|patternlen
)braket
)paren
(brace
id|strbuf_add
c_func
(paren
op_amp
id|pat_buf
comma
id|pattern
comma
id|patternlen
)paren
suffix:semicolon
id|use_pat
op_assign
id|pat_buf.buf
suffix:semicolon
)brace
r_if
c_cond
(paren
id|string
(braket
id|stringlen
)braket
)paren
(brace
id|strbuf_add
c_func
(paren
op_amp
id|str_buf
comma
id|string
comma
id|stringlen
)paren
suffix:semicolon
id|use_str
op_assign
id|str_buf.buf
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ignore_case
)paren
id|flags
op_or_assign
id|WM_CASEFOLD
suffix:semicolon
id|match_status
op_assign
id|wildmatch
c_func
(paren
id|use_pat
comma
id|use_str
comma
id|flags
comma
l_int|NULL
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|pat_buf
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|str_buf
)paren
suffix:semicolon
r_return
id|match_status
suffix:semicolon
)brace
DECL|function|common_prefix_len
r_static
r_int
id|common_prefix_len
c_func
(paren
r_const
r_struct
id|pathspec
op_star
id|pathspec
)paren
(brace
r_int
id|n
suffix:semicolon
r_int
id|max
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * &quot;:(icase)path&quot; is treated as a pathspec full of&n;&t; * wildcard. In other words, only prefix is considered common&n;&t; * prefix. If the pathspec is abc/foo abc/bar, running in&n;&t; * subdir xyz, the common prefix is still xyz, not xuz/abc as&n;&t; * in non-:(icase).&n;&t; */
id|GUARD_PATHSPEC
c_func
(paren
id|pathspec
comma
id|PATHSPEC_FROMTOP
op_or
id|PATHSPEC_MAXDEPTH
op_or
id|PATHSPEC_LITERAL
op_or
id|PATHSPEC_GLOB
op_or
id|PATHSPEC_ICASE
op_or
id|PATHSPEC_EXCLUDE
)paren
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|pathspec-&gt;nr
suffix:semicolon
id|n
op_increment
)paren
(brace
r_int
id|i
op_assign
l_int|0
comma
id|len
op_assign
l_int|0
comma
id|item_len
suffix:semicolon
r_if
c_cond
(paren
id|pathspec-&gt;items
(braket
id|n
)braket
dot
id|magic
op_amp
id|PATHSPEC_EXCLUDE
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|pathspec-&gt;items
(braket
id|n
)braket
dot
id|magic
op_amp
id|PATHSPEC_ICASE
)paren
id|item_len
op_assign
id|pathspec-&gt;items
(braket
id|n
)braket
dot
id|prefix
suffix:semicolon
r_else
id|item_len
op_assign
id|pathspec-&gt;items
(braket
id|n
)braket
dot
id|nowildcard_len
suffix:semicolon
r_while
c_loop
(paren
id|i
OL
id|item_len
op_logical_and
(paren
id|n
op_eq
l_int|0
op_logical_or
id|i
OL
id|max
)paren
)paren
(brace
r_char
id|c
op_assign
id|pathspec-&gt;items
(braket
id|n
)braket
dot
id|match
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|c
op_ne
id|pathspec-&gt;items
(braket
l_int|0
)braket
dot
id|match
(braket
id|i
)braket
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;/&squot;
)paren
id|len
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|n
op_eq
l_int|0
op_logical_or
id|len
OL
id|max
)paren
(brace
id|max
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|max
)paren
r_break
suffix:semicolon
)brace
)brace
r_return
id|max
suffix:semicolon
)brace
multiline_comment|/*&n; * Returns a copy of the longest leading path common among all&n; * pathspecs.&n; */
DECL|function|common_prefix
r_char
op_star
id|common_prefix
c_func
(paren
r_const
r_struct
id|pathspec
op_star
id|pathspec
)paren
(brace
r_int
r_int
id|len
op_assign
id|common_prefix_len
c_func
(paren
id|pathspec
)paren
suffix:semicolon
r_return
id|len
ques
c_cond
id|xmemdupz
c_func
(paren
id|pathspec-&gt;items
(braket
l_int|0
)braket
dot
id|match
comma
id|len
)paren
suffix:colon
l_int|NULL
suffix:semicolon
)brace
DECL|function|fill_directory
r_int
id|fill_directory
c_func
(paren
r_struct
id|dir_struct
op_star
id|dir
comma
r_const
r_struct
id|pathspec
op_star
id|pathspec
)paren
(brace
r_int
id|len
suffix:semicolon
multiline_comment|/*&n;&t; * Calculate common prefix for the pathspec, and&n;&t; * use that to optimize the directory walk&n;&t; */
id|len
op_assign
id|common_prefix_len
c_func
(paren
id|pathspec
)paren
suffix:semicolon
multiline_comment|/* Read the directory and prune it */
id|read_directory
c_func
(paren
id|dir
comma
id|pathspec-&gt;nr
ques
c_cond
id|pathspec-&gt;_raw
(braket
l_int|0
)braket
suffix:colon
l_string|&quot;&quot;
comma
id|len
comma
id|pathspec
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
DECL|function|within_depth
r_int
id|within_depth
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_int
id|namelen
comma
r_int
id|depth
comma
r_int
id|max_depth
)paren
(brace
r_const
r_char
op_star
id|cp
op_assign
id|name
comma
op_star
id|cpe
op_assign
id|name
op_plus
id|namelen
suffix:semicolon
r_while
c_loop
(paren
id|cp
OL
id|cpe
)paren
(brace
r_if
c_cond
(paren
op_star
id|cp
op_increment
op_ne
l_char|&squot;/&squot;
)paren
r_continue
suffix:semicolon
id|depth
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|depth
OG
id|max_depth
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|macro|DO_MATCH_EXCLUDE
mdefine_line|#define DO_MATCH_EXCLUDE   1
DECL|macro|DO_MATCH_DIRECTORY
mdefine_line|#define DO_MATCH_DIRECTORY 2
multiline_comment|/*&n; * Does &squot;match&squot; match the given name?&n; * A match is found if&n; *&n; * (1) the &squot;match&squot; string is leading directory of &squot;name&squot;, or&n; * (2) the &squot;match&squot; string is a wildcard and matches &squot;name&squot;, or&n; * (3) the &squot;match&squot; string is exactly the same as &squot;name&squot;.&n; *&n; * and the return value tells which case it was.&n; *&n; * It returns 0 when there is no match.&n; */
DECL|function|match_pathspec_item
r_static
r_int
id|match_pathspec_item
c_func
(paren
r_const
r_struct
id|pathspec_item
op_star
id|item
comma
r_int
id|prefix
comma
r_const
r_char
op_star
id|name
comma
r_int
id|namelen
comma
r_int
id|flags
)paren
(brace
multiline_comment|/* name/namelen has prefix cut off by caller */
r_const
r_char
op_star
id|match
op_assign
id|item-&gt;match
op_plus
id|prefix
suffix:semicolon
r_int
id|matchlen
op_assign
id|item-&gt;len
id|prefix
suffix:semicolon
multiline_comment|/*&n;&t; * The normal call pattern is:&n;&t; * 1. prefix = common_prefix_len(ps);&n;&t; * 2. prune something, or fill_directory&n;&t; * 3. match_pathspec()&n;&t; *&n;&t; * &squot;prefix&squot; at #1 may be shorter than the command&squot;s prefix and&n;&t; * it&squot;s ok for #2 to match extra files. Those extras will be&n;&t; * trimmed at #3.&n;&t; *&n;&t; * Suppose the pathspec is &squot;foo&squot; and &squot;../bar&squot; running from&n;&t; * subdir &squot;xyz&squot;. The common prefix at #1 will be empty, thanks&n;&t; * to &quot;../&quot;. We may have xyz/foo _and_ XYZ/foo after #2. The&n;&t; * user does not want XYZ/foo, only the &quot;foo&quot; part should be&n;&t; * case-insensitive. We need to filter out XYZ/foo here. In&n;&t; * other words, we do not trust the caller on comparing the&n;&t; * prefix part when :(icase) is involved. We do exact&n;&t; * comparison ourselves.&n;&t; *&n;&t; * Normally the caller (common_prefix_len() in fact) does&n;&t; * _exact_ matching on name[-prefix+1..-1] and we do not need&n;&t; * to check that part. Be defensive and check it anyway, in&n;&t; * case common_prefix_len is changed, or a new caller is&n;&t; * introduced that does not use common_prefix_len.&n;&t; *&n;&t; * If the penalty turns out too high when prefix is really&n;&t; * long, maybe change it to&n;&t; * strncmp(match, name, item-&gt;prefix - prefix)&n;&t; */
r_if
c_cond
(paren
id|item-&gt;prefix
op_logical_and
(paren
id|item-&gt;magic
op_amp
id|PATHSPEC_ICASE
)paren
op_logical_and
id|strncmp
c_func
(paren
id|item-&gt;match
comma
id|name
id|prefix
comma
id|item-&gt;prefix
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* If the match was just the prefix, we matched */
r_if
c_cond
(paren
op_logical_neg
op_star
id|match
)paren
r_return
id|MATCHED_RECURSIVELY
suffix:semicolon
r_if
c_cond
(paren
id|matchlen
op_le
id|namelen
op_logical_and
op_logical_neg
id|ps_strncmp
c_func
(paren
id|item
comma
id|match
comma
id|name
comma
id|matchlen
)paren
)paren
(brace
r_if
c_cond
(paren
id|matchlen
op_eq
id|namelen
)paren
r_return
id|MATCHED_EXACTLY
suffix:semicolon
r_if
c_cond
(paren
id|match
(braket
id|matchlen
op_minus
l_int|1
)braket
op_eq
l_char|&squot;/&squot;
op_logical_or
id|name
(braket
id|matchlen
)braket
op_eq
l_char|&squot;/&squot;
)paren
r_return
id|MATCHED_RECURSIVELY
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|DO_MATCH_DIRECTORY
)paren
op_logical_and
id|match
(braket
id|matchlen
l_int|1
)braket
op_eq
l_char|&squot;/&squot;
op_logical_and
id|namelen
op_eq
id|matchlen
l_int|1
op_logical_and
op_logical_neg
id|ps_strncmp
c_func
(paren
id|item
comma
id|match
comma
id|name
comma
id|namelen
)paren
)paren
r_return
id|MATCHED_EXACTLY
suffix:semicolon
r_if
c_cond
(paren
id|item-&gt;nowildcard_len
OL
id|item-&gt;len
op_logical_and
op_logical_neg
id|git_fnmatch
c_func
(paren
id|item
comma
id|match
comma
id|name
comma
id|item-&gt;nowildcard_len
id|prefix
)paren
)paren
r_return
id|MATCHED_FNMATCH
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Given a name and a list of pathspecs, returns the nature of the&n; * closest (i.e. most specific) match of the name to any of the&n; * pathspecs.&n; *&n; * The caller typically calls this multiple times with the same&n; * pathspec and seen[] array but with different name/namelen&n; * (e.g. entries from the index) and is interested in seeing if and&n; * how each pathspec matches all the names it calls this function&n; * with.  A mark is left in the seen[] array for each pathspec element&n; * indicating the closest type of match that element achieved, so if&n; * seen[n] remains zero after multiple invocations, that means the nth&n; * pathspec did not match any names, which could indicate that the&n; * user mistyped the nth pathspec.&n; */
DECL|function|do_match_pathspec
r_static
r_int
id|do_match_pathspec
c_func
(paren
r_const
r_struct
id|pathspec
op_star
id|ps
comma
r_const
r_char
op_star
id|name
comma
r_int
id|namelen
comma
r_int
id|prefix
comma
r_char
op_star
id|seen
comma
r_int
id|flags
)paren
(brace
r_int
id|i
comma
id|retval
op_assign
l_int|0
comma
id|exclude
op_assign
id|flags
op_amp
id|DO_MATCH_EXCLUDE
suffix:semicolon
id|GUARD_PATHSPEC
c_func
(paren
id|ps
comma
id|PATHSPEC_FROMTOP
op_or
id|PATHSPEC_MAXDEPTH
op_or
id|PATHSPEC_LITERAL
op_or
id|PATHSPEC_GLOB
op_or
id|PATHSPEC_ICASE
op_or
id|PATHSPEC_EXCLUDE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ps-&gt;nr
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ps-&gt;recursive
op_logical_or
op_logical_neg
(paren
id|ps-&gt;magic
op_amp
id|PATHSPEC_MAXDEPTH
)paren
op_logical_or
id|ps-&gt;max_depth
op_eq
l_int|1
)paren
r_return
id|MATCHED_RECURSIVELY
suffix:semicolon
r_if
c_cond
(paren
id|within_depth
c_func
(paren
id|name
comma
id|namelen
comma
l_int|0
comma
id|ps-&gt;max_depth
)paren
)paren
r_return
id|MATCHED_EXACTLY
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
id|name
op_add_assign
id|prefix
suffix:semicolon
id|namelen
op_sub_assign
id|prefix
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|ps-&gt;nr
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_int
id|how
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|exclude
op_logical_and
id|ps-&gt;items
(braket
id|i
)braket
dot
id|magic
op_amp
id|PATHSPEC_EXCLUDE
)paren
op_logical_or
(paren
id|exclude
op_logical_and
op_logical_neg
(paren
id|ps-&gt;items
(braket
id|i
)braket
dot
id|magic
op_amp
id|PATHSPEC_EXCLUDE
)paren
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|seen
op_logical_and
id|seen
(braket
id|i
)braket
op_eq
id|MATCHED_EXACTLY
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Make exclude patterns optional and never report&n;&t;&t; * &quot;pathspec &squot;:(exclude)foo&squot; matches no files&quot;&n;&t;&t; */
r_if
c_cond
(paren
id|seen
op_logical_and
id|ps-&gt;items
(braket
id|i
)braket
dot
id|magic
op_amp
id|PATHSPEC_EXCLUDE
)paren
id|seen
(braket
id|i
)braket
op_assign
id|MATCHED_FNMATCH
suffix:semicolon
id|how
op_assign
id|match_pathspec_item
c_func
(paren
id|ps-&gt;items
op_plus
id|i
comma
id|prefix
comma
id|name
comma
id|namelen
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ps-&gt;recursive
op_logical_and
(paren
id|ps-&gt;magic
op_amp
id|PATHSPEC_MAXDEPTH
)paren
op_logical_and
id|ps-&gt;max_depth
op_ne
l_int|1
op_logical_and
id|how
op_logical_and
id|how
op_ne
id|MATCHED_FNMATCH
)paren
(brace
r_int
id|len
op_assign
id|ps-&gt;items
(braket
id|i
)braket
dot
id|len
suffix:semicolon
r_if
c_cond
(paren
id|name
(braket
id|len
)braket
op_eq
l_char|&squot;/&squot;
)paren
id|len
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|within_depth
c_func
(paren
id|name
op_plus
id|len
comma
id|namelen
op_minus
id|len
comma
l_int|0
comma
id|ps-&gt;max_depth
)paren
)paren
id|how
op_assign
id|MATCHED_EXACTLY
suffix:semicolon
r_else
id|how
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|how
)paren
(brace
r_if
c_cond
(paren
id|retval
OL
id|how
)paren
id|retval
op_assign
id|how
suffix:semicolon
r_if
c_cond
(paren
id|seen
op_logical_and
id|seen
(braket
id|i
)braket
OL
id|how
)paren
id|seen
(braket
id|i
)braket
op_assign
id|how
suffix:semicolon
)brace
)brace
r_return
id|retval
suffix:semicolon
)brace
DECL|function|match_pathspec
r_int
id|match_pathspec
c_func
(paren
r_const
r_struct
id|pathspec
op_star
id|ps
comma
r_const
r_char
op_star
id|name
comma
r_int
id|namelen
comma
r_int
id|prefix
comma
r_char
op_star
id|seen
comma
r_int
id|is_dir
)paren
(brace
r_int
id|positive
comma
id|negative
suffix:semicolon
r_int
id|flags
op_assign
id|is_dir
ques
c_cond
id|DO_MATCH_DIRECTORY
suffix:colon
l_int|0
suffix:semicolon
id|positive
op_assign
id|do_match_pathspec
c_func
(paren
id|ps
comma
id|name
comma
id|namelen
comma
id|prefix
comma
id|seen
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ps-&gt;magic
op_amp
id|PATHSPEC_EXCLUDE
)paren
op_logical_or
op_logical_neg
id|positive
)paren
r_return
id|positive
suffix:semicolon
id|negative
op_assign
id|do_match_pathspec
c_func
(paren
id|ps
comma
id|name
comma
id|namelen
comma
id|prefix
comma
id|seen
comma
id|flags
op_or
id|DO_MATCH_EXCLUDE
)paren
suffix:semicolon
r_return
id|negative
ques
c_cond
l_int|0
suffix:colon
id|positive
suffix:semicolon
)brace
multiline_comment|/*&n; * Return the length of the &quot;simple&quot; part of a path match limiter.&n; */
DECL|function|simple_length
r_int
id|simple_length
c_func
(paren
r_const
r_char
op_star
id|match
)paren
(brace
r_int
id|len
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
r_char
id|c
op_assign
op_star
id|match
op_increment
suffix:semicolon
id|len
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;0&squot;
op_logical_or
id|is_glob_special
c_func
(paren
id|c
)paren
)paren
r_return
id|len
suffix:semicolon
)brace
)brace
DECL|function|no_wildcard
r_int
id|no_wildcard
c_func
(paren
r_const
r_char
op_star
id|string
)paren
(brace
r_return
id|string
(braket
id|simple_length
c_func
(paren
id|string
)paren
)braket
op_eq
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
DECL|function|parse_exclude_pattern
r_void
id|parse_exclude_pattern
c_func
(paren
r_const
r_char
op_star
op_star
id|pattern
comma
r_int
op_star
id|patternlen
comma
r_int
op_star
id|flags
comma
r_int
op_star
id|nowildcardlen
)paren
(brace
r_const
r_char
op_star
id|p
op_assign
op_star
id|pattern
suffix:semicolon
r_int
id|i
comma
id|len
suffix:semicolon
op_star
id|flags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p
op_eq
l_char|&squot;!&squot;
)paren
(brace
op_star
id|flags
op_or_assign
id|EXC_FLAG_NEGATIVE
suffix:semicolon
id|p
op_increment
suffix:semicolon
)brace
id|len
op_assign
id|strlen
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_logical_and
id|p
(braket
id|len
l_int|1
)braket
op_eq
l_char|&squot;/&squot;
)paren
(brace
id|len
op_decrement
suffix:semicolon
op_star
id|flags
op_or_assign
id|EXC_FLAG_MUSTBEDIR
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|p
(braket
id|i
)braket
op_eq
l_char|&squot;/&squot;
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
id|len
)paren
op_star
id|flags
op_or_assign
id|EXC_FLAG_NODIR
suffix:semicolon
op_star
id|nowildcardlen
op_assign
id|simple_length
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * we should have excluded the trailing slash from &squot;p&squot; too,&n;&t; * but that&squot;s one more allocation. Instead just make sure&n;&t; * nowildcardlen does not exceed real patternlen&n;&t; */
r_if
c_cond
(paren
op_star
id|nowildcardlen
OG
id|len
)paren
op_star
id|nowildcardlen
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p
op_eq
l_char|&squot;*&squot;
op_logical_and
id|no_wildcard
c_func
(paren
id|p
op_plus
l_int|1
)paren
)paren
op_star
id|flags
op_or_assign
id|EXC_FLAG_ENDSWITH
suffix:semicolon
op_star
id|pattern
op_assign
id|p
suffix:semicolon
op_star
id|patternlen
op_assign
id|len
suffix:semicolon
)brace
DECL|function|add_exclude
r_void
id|add_exclude
c_func
(paren
r_const
r_char
op_star
id|string
comma
r_const
r_char
op_star
id|base
comma
r_int
id|baselen
comma
r_struct
id|exclude_list
op_star
id|el
comma
r_int
id|srcpos
)paren
(brace
r_struct
id|exclude
op_star
id|x
suffix:semicolon
r_int
id|patternlen
suffix:semicolon
r_int
id|flags
suffix:semicolon
r_int
id|nowildcardlen
suffix:semicolon
id|parse_exclude_pattern
c_func
(paren
op_amp
id|string
comma
op_amp
id|patternlen
comma
op_amp
id|flags
comma
op_amp
id|nowildcardlen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|EXC_FLAG_MUSTBEDIR
)paren
(brace
r_char
op_star
id|s
suffix:semicolon
id|x
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|x
)paren
op_plus
id|patternlen
op_plus
l_int|1
)paren
suffix:semicolon
id|s
op_assign
(paren
r_char
op_star
)paren
(paren
id|x
op_plus
l_int|1
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|s
comma
id|string
comma
id|patternlen
)paren
suffix:semicolon
id|s
(braket
id|patternlen
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|x-&gt;pattern
op_assign
id|s
suffix:semicolon
)brace
r_else
(brace
id|x
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|x
)paren
)paren
suffix:semicolon
id|x-&gt;pattern
op_assign
id|string
suffix:semicolon
)brace
id|x-&gt;patternlen
op_assign
id|patternlen
suffix:semicolon
id|x-&gt;nowildcardlen
op_assign
id|nowildcardlen
suffix:semicolon
id|x-&gt;base
op_assign
id|base
suffix:semicolon
id|x-&gt;baselen
op_assign
id|baselen
suffix:semicolon
id|x-&gt;flags
op_assign
id|flags
suffix:semicolon
id|x-&gt;srcpos
op_assign
id|srcpos
suffix:semicolon
id|ALLOC_GROW
c_func
(paren
id|el-&gt;excludes
comma
id|el-&gt;nr
op_plus
l_int|1
comma
id|el-&gt;alloc
)paren
suffix:semicolon
id|el-&gt;excludes
(braket
id|el-&gt;nr
op_increment
)braket
op_assign
id|x
suffix:semicolon
id|x-&gt;el
op_assign
id|el
suffix:semicolon
)brace
DECL|function|read_skip_worktree_file_from_index
r_static
r_void
op_star
id|read_skip_worktree_file_from_index
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_int
op_star
id|size
)paren
(brace
r_int
id|pos
comma
id|len
suffix:semicolon
r_int
r_int
id|sz
suffix:semicolon
r_enum
id|object_type
id|type
suffix:semicolon
r_void
op_star
id|data
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|path
)paren
suffix:semicolon
id|pos
op_assign
id|cache_name_pos
c_func
(paren
id|path
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ce_skip_worktree
c_func
(paren
id|active_cache
(braket
id|pos
)braket
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|data
op_assign
id|read_sha1_file
c_func
(paren
id|active_cache
(braket
id|pos
)braket
op_member_access_from_pointer
id|sha1
comma
op_amp
id|type
comma
op_amp
id|sz
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
op_logical_or
id|type
op_ne
id|OBJ_BLOB
)paren
(brace
id|free
c_func
(paren
id|data
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
op_star
id|size
op_assign
id|xsize_t
c_func
(paren
id|sz
)paren
suffix:semicolon
r_return
id|data
suffix:semicolon
)brace
multiline_comment|/*&n; * Frees memory within el which was allocated for exclude patterns and&n; * the file buffer.  Does not free el itself.&n; */
DECL|function|clear_exclude_list
r_void
id|clear_exclude_list
c_func
(paren
r_struct
id|exclude_list
op_star
id|el
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|el-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
id|free
c_func
(paren
id|el-&gt;excludes
(braket
id|i
)braket
)paren
suffix:semicolon
id|free
c_func
(paren
id|el-&gt;excludes
)paren
suffix:semicolon
id|free
c_func
(paren
id|el-&gt;filebuf
)paren
suffix:semicolon
id|el-&gt;nr
op_assign
l_int|0
suffix:semicolon
id|el-&gt;excludes
op_assign
l_int|NULL
suffix:semicolon
id|el-&gt;filebuf
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|trim_trailing_spaces
r_static
r_void
id|trim_trailing_spaces
c_func
(paren
r_char
op_star
id|buf
)paren
(brace
r_char
op_star
id|p
comma
op_star
id|last_space
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|buf
suffix:semicolon
op_star
id|p
suffix:semicolon
id|p
op_increment
)paren
r_switch
c_cond
(paren
op_star
id|p
)paren
(brace
r_case
l_char|&squot; &squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|last_space
)paren
id|last_space
op_assign
id|p
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;&bslash;&bslash;&squot;
suffix:colon
id|p
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|p
)paren
r_return
suffix:semicolon
multiline_comment|/* fallthrough */
r_default
suffix:colon
id|last_space
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|last_space
)paren
op_star
id|last_space
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
DECL|function|add_excludes_from_file_to_list
r_int
id|add_excludes_from_file_to_list
c_func
(paren
r_const
r_char
op_star
id|fname
comma
r_const
r_char
op_star
id|base
comma
r_int
id|baselen
comma
r_struct
id|exclude_list
op_star
id|el
comma
r_int
id|check_index
)paren
(brace
r_struct
id|stat
id|st
suffix:semicolon
r_int
id|fd
comma
id|i
comma
id|lineno
op_assign
l_int|1
suffix:semicolon
r_int
id|size
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|buf
comma
op_star
id|entry
suffix:semicolon
id|fd
op_assign
id|open
c_func
(paren
id|fname
comma
id|O_RDONLY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
op_logical_or
id|fstat
c_func
(paren
id|fd
comma
op_amp
id|st
)paren
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|errno
op_ne
id|ENOENT
)paren
id|warn_on_inaccessible
c_func
(paren
id|fname
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_le
id|fd
)paren
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|check_index
op_logical_or
(paren
id|buf
op_assign
id|read_skip_worktree_file_from_index
c_func
(paren
id|fname
comma
op_amp
id|size
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
(brace
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buf
(braket
id|size
op_minus
l_int|1
)braket
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|buf
op_assign
id|xrealloc
c_func
(paren
id|buf
comma
id|size
op_plus
l_int|1
)paren
suffix:semicolon
id|buf
(braket
id|size
op_increment
)braket
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
)brace
)brace
r_else
(brace
id|size
op_assign
id|xsize_t
c_func
(paren
id|st.st_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
(brace
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|buf
op_assign
id|xmalloc
c_func
(paren
id|size
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_in_full
c_func
(paren
id|fd
comma
id|buf
comma
id|size
)paren
op_ne
id|size
)paren
(brace
id|free
c_func
(paren
id|buf
)paren
suffix:semicolon
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|buf
(braket
id|size
op_increment
)braket
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
)brace
id|el-&gt;filebuf
op_assign
id|buf
suffix:semicolon
id|entry
op_assign
id|buf
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|size
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|buf
(braket
id|i
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
r_if
c_cond
(paren
id|entry
op_ne
id|buf
op_plus
id|i
op_logical_and
id|entry
(braket
l_int|0
)braket
op_ne
l_char|&squot;#&squot;
)paren
(brace
id|buf
(braket
id|i
(paren
id|i
op_logical_and
id|buf
(braket
id|i
op_minus
l_int|1
)braket
op_eq
l_char|&squot;&bslash;r&squot;
)paren
)braket
op_assign
l_int|0
suffix:semicolon
id|trim_trailing_spaces
c_func
(paren
id|entry
)paren
suffix:semicolon
id|add_exclude
c_func
(paren
id|entry
comma
id|base
comma
id|baselen
comma
id|el
comma
id|lineno
)paren
suffix:semicolon
)brace
id|lineno
op_increment
suffix:semicolon
id|entry
op_assign
id|buf
op_plus
id|i
op_plus
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|add_exclude_list
r_struct
id|exclude_list
op_star
id|add_exclude_list
c_func
(paren
r_struct
id|dir_struct
op_star
id|dir
comma
r_int
id|group_type
comma
r_const
r_char
op_star
id|src
)paren
(brace
r_struct
id|exclude_list
op_star
id|el
suffix:semicolon
r_struct
id|exclude_list_group
op_star
id|group
suffix:semicolon
id|group
op_assign
op_amp
id|dir-&gt;exclude_list_group
(braket
id|group_type
)braket
suffix:semicolon
id|ALLOC_GROW
c_func
(paren
id|group-&gt;el
comma
id|group-&gt;nr
op_plus
l_int|1
comma
id|group-&gt;alloc
)paren
suffix:semicolon
id|el
op_assign
op_amp
id|group-&gt;el
(braket
id|group-&gt;nr
op_increment
)braket
suffix:semicolon
id|memset
c_func
(paren
id|el
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|el
)paren
)paren
suffix:semicolon
id|el-&gt;src
op_assign
id|src
suffix:semicolon
r_return
id|el
suffix:semicolon
)brace
multiline_comment|/*&n; * Used to set up core.excludesfile and .git/info/exclude lists.&n; */
DECL|function|add_excludes_from_file
r_void
id|add_excludes_from_file
c_func
(paren
r_struct
id|dir_struct
op_star
id|dir
comma
r_const
r_char
op_star
id|fname
)paren
(brace
r_struct
id|exclude_list
op_star
id|el
suffix:semicolon
id|el
op_assign
id|add_exclude_list
c_func
(paren
id|dir
comma
id|EXC_FILE
comma
id|fname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|add_excludes_from_file_to_list
c_func
(paren
id|fname
comma
l_string|&quot;&quot;
comma
l_int|0
comma
id|el
comma
l_int|0
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;cannot use %s as an exclude file&quot;
comma
id|fname
)paren
suffix:semicolon
)brace
DECL|function|match_basename
r_int
id|match_basename
c_func
(paren
r_const
r_char
op_star
id|basename
comma
r_int
id|basenamelen
comma
r_const
r_char
op_star
id|pattern
comma
r_int
id|prefix
comma
r_int
id|patternlen
comma
r_int
id|flags
)paren
(brace
r_if
c_cond
(paren
id|prefix
op_eq
id|patternlen
)paren
(brace
r_if
c_cond
(paren
id|patternlen
op_eq
id|basenamelen
op_logical_and
op_logical_neg
id|strncmp_icase
c_func
(paren
id|pattern
comma
id|basename
comma
id|basenamelen
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|flags
op_amp
id|EXC_FLAG_ENDSWITH
)paren
(brace
multiline_comment|/* &quot;*literal&quot; matching against &quot;fooliteral&quot; */
r_if
c_cond
(paren
id|patternlen
l_int|1
op_le
id|basenamelen
op_logical_and
op_logical_neg
id|strncmp_icase
c_func
(paren
id|pattern
op_plus
l_int|1
comma
id|basename
op_plus
id|basenamelen
(paren
id|patternlen
l_int|1
)paren
comma
id|patternlen
l_int|1
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|fnmatch_icase_mem
c_func
(paren
id|pattern
comma
id|patternlen
comma
id|basename
comma
id|basenamelen
comma
l_int|0
)paren
op_eq
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|match_pathname
r_int
id|match_pathname
c_func
(paren
r_const
r_char
op_star
id|pathname
comma
r_int
id|pathlen
comma
r_const
r_char
op_star
id|base
comma
r_int
id|baselen
comma
r_const
r_char
op_star
id|pattern
comma
r_int
id|prefix
comma
r_int
id|patternlen
comma
r_int
id|flags
)paren
(brace
r_const
r_char
op_star
id|name
suffix:semicolon
r_int
id|namelen
suffix:semicolon
multiline_comment|/*&n;&t; * match with FNM_PATHNAME; the pattern has base implicitly&n;&t; * in front of it.&n;&t; */
r_if
c_cond
(paren
op_star
id|pattern
op_eq
l_char|&squot;/&squot;
)paren
(brace
id|pattern
op_increment
suffix:semicolon
id|patternlen
op_decrement
suffix:semicolon
id|prefix
op_decrement
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * baselen does not count the trailing slash. base[] may or&n;&t; * may not end with a trailing slash though.&n;&t; */
r_if
c_cond
(paren
id|pathlen
OL
id|baselen
op_plus
l_int|1
op_logical_or
(paren
id|baselen
op_logical_and
id|pathname
(braket
id|baselen
)braket
op_ne
l_char|&squot;/&squot;
)paren
op_logical_or
id|strncmp_icase
c_func
(paren
id|pathname
comma
id|base
comma
id|baselen
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|namelen
op_assign
id|baselen
ques
c_cond
id|pathlen
id|baselen
l_int|1
suffix:colon
id|pathlen
suffix:semicolon
id|name
op_assign
id|pathname
op_plus
id|pathlen
id|namelen
suffix:semicolon
r_if
c_cond
(paren
id|prefix
)paren
(brace
multiline_comment|/*&n;&t;&t; * if the non-wildcard part is longer than the&n;&t;&t; * remaining pathname, surely it cannot match.&n;&t;&t; */
r_if
c_cond
(paren
id|prefix
OG
id|namelen
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|strncmp_icase
c_func
(paren
id|pattern
comma
id|name
comma
id|prefix
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|pattern
op_add_assign
id|prefix
suffix:semicolon
id|patternlen
op_sub_assign
id|prefix
suffix:semicolon
id|name
op_add_assign
id|prefix
suffix:semicolon
id|namelen
op_sub_assign
id|prefix
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the whole pattern did not have a wildcard,&n;&t;&t; * then our prefix match is all we need; we&n;&t;&t; * do not need to call fnmatch at all.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|patternlen
op_logical_and
op_logical_neg
id|namelen
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
id|fnmatch_icase_mem
c_func
(paren
id|pattern
comma
id|patternlen
comma
id|name
comma
id|namelen
comma
id|WM_PATHNAME
)paren
op_eq
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Scan the given exclude list in reverse to see whether pathname&n; * should be ignored.  The first match (i.e. the last on the list), if&n; * any, determines the fate.  Returns the exclude_list element which&n; * matched, or NULL for undecided.&n; */
DECL|function|last_exclude_matching_from_list
r_static
r_struct
id|exclude
op_star
id|last_exclude_matching_from_list
c_func
(paren
r_const
r_char
op_star
id|pathname
comma
r_int
id|pathlen
comma
r_const
r_char
op_star
id|basename
comma
r_int
op_star
id|dtype
comma
r_struct
id|exclude_list
op_star
id|el
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|el-&gt;nr
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* undefined */
r_for
c_loop
(paren
id|i
op_assign
id|el-&gt;nr
l_int|1
suffix:semicolon
l_int|0
op_le
id|i
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_struct
id|exclude
op_star
id|x
op_assign
id|el-&gt;excludes
(braket
id|i
)braket
suffix:semicolon
r_const
r_char
op_star
id|exclude
op_assign
id|x-&gt;pattern
suffix:semicolon
r_int
id|prefix
op_assign
id|x-&gt;nowildcardlen
suffix:semicolon
r_if
c_cond
(paren
id|x-&gt;flags
op_amp
id|EXC_FLAG_MUSTBEDIR
)paren
(brace
r_if
c_cond
(paren
op_star
id|dtype
op_eq
id|DT_UNKNOWN
)paren
op_star
id|dtype
op_assign
id|get_dtype
c_func
(paren
l_int|NULL
comma
id|pathname
comma
id|pathlen
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|dtype
op_ne
id|DT_DIR
)paren
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x-&gt;flags
op_amp
id|EXC_FLAG_NODIR
)paren
(brace
r_if
c_cond
(paren
id|match_basename
c_func
(paren
id|basename
comma
id|pathlen
(paren
id|basename
id|pathname
)paren
comma
id|exclude
comma
id|prefix
comma
id|x-&gt;patternlen
comma
id|x-&gt;flags
)paren
)paren
r_return
id|x
suffix:semicolon
r_continue
suffix:semicolon
)brace
m_assert
(paren
id|x-&gt;baselen
op_eq
l_int|0
op_logical_or
id|x-&gt;base
(braket
id|x-&gt;baselen
l_int|1
)braket
op_eq
l_char|&squot;/&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|match_pathname
c_func
(paren
id|pathname
comma
id|pathlen
comma
id|x-&gt;base
comma
id|x-&gt;baselen
ques
c_cond
id|x-&gt;baselen
l_int|1
suffix:colon
l_int|0
comma
id|exclude
comma
id|prefix
comma
id|x-&gt;patternlen
comma
id|x-&gt;flags
)paren
)paren
r_return
id|x
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* undecided */
)brace
multiline_comment|/*&n; * Scan the list and let the last match determine the fate.&n; * Return 1 for exclude, 0 for include and -1 for undecided.&n; */
DECL|function|is_excluded_from_list
r_int
id|is_excluded_from_list
c_func
(paren
r_const
r_char
op_star
id|pathname
comma
r_int
id|pathlen
comma
r_const
r_char
op_star
id|basename
comma
r_int
op_star
id|dtype
comma
r_struct
id|exclude_list
op_star
id|el
)paren
(brace
r_struct
id|exclude
op_star
id|exclude
suffix:semicolon
id|exclude
op_assign
id|last_exclude_matching_from_list
c_func
(paren
id|pathname
comma
id|pathlen
comma
id|basename
comma
id|dtype
comma
id|el
)paren
suffix:semicolon
r_if
c_cond
(paren
id|exclude
)paren
r_return
id|exclude-&gt;flags
op_amp
id|EXC_FLAG_NEGATIVE
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* undecided */
)brace
DECL|function|last_exclude_matching_from_lists
r_static
r_struct
id|exclude
op_star
id|last_exclude_matching_from_lists
c_func
(paren
r_struct
id|dir_struct
op_star
id|dir
comma
r_const
r_char
op_star
id|pathname
comma
r_int
id|pathlen
comma
r_const
r_char
op_star
id|basename
comma
r_int
op_star
id|dtype_p
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_struct
id|exclude_list_group
op_star
id|group
suffix:semicolon
r_struct
id|exclude
op_star
id|exclude
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|EXC_CMDL
suffix:semicolon
id|i
op_le
id|EXC_FILE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|group
op_assign
op_amp
id|dir-&gt;exclude_list_group
(braket
id|i
)braket
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|group-&gt;nr
l_int|1
suffix:semicolon
id|j
op_ge
l_int|0
suffix:semicolon
id|j
op_decrement
)paren
(brace
id|exclude
op_assign
id|last_exclude_matching_from_list
c_func
(paren
id|pathname
comma
id|pathlen
comma
id|basename
comma
id|dtype_p
comma
op_amp
id|group-&gt;el
(braket
id|j
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|exclude
)paren
r_return
id|exclude
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Loads the per-directory exclude list for the substring of base&n; * which has a char length of baselen.&n; */
DECL|function|prep_exclude
r_static
r_void
id|prep_exclude
c_func
(paren
r_struct
id|dir_struct
op_star
id|dir
comma
r_const
r_char
op_star
id|base
comma
r_int
id|baselen
)paren
(brace
r_struct
id|exclude_list_group
op_star
id|group
suffix:semicolon
r_struct
id|exclude_list
op_star
id|el
suffix:semicolon
r_struct
id|exclude_stack
op_star
id|stk
op_assign
l_int|NULL
suffix:semicolon
r_int
id|current
suffix:semicolon
id|group
op_assign
op_amp
id|dir-&gt;exclude_list_group
(braket
id|EXC_DIRS
)braket
suffix:semicolon
multiline_comment|/* Pop the exclude lists from the EXCL_DIRS exclude_list_group&n;&t; * which originate from directories not in the prefix of the&n;&t; * path being checked. */
r_while
c_loop
(paren
(paren
id|stk
op_assign
id|dir-&gt;exclude_stack
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|stk-&gt;baselen
op_le
id|baselen
op_logical_and
op_logical_neg
id|strncmp
c_func
(paren
id|dir-&gt;basebuf
comma
id|base
comma
id|stk-&gt;baselen
)paren
)paren
r_break
suffix:semicolon
id|el
op_assign
op_amp
id|group-&gt;el
(braket
id|dir-&gt;exclude_stack-&gt;exclude_ix
)braket
suffix:semicolon
id|dir-&gt;exclude_stack
op_assign
id|stk-&gt;prev
suffix:semicolon
id|dir-&gt;exclude
op_assign
l_int|NULL
suffix:semicolon
id|free
c_func
(paren
(paren
r_char
op_star
)paren
id|el-&gt;src
)paren
suffix:semicolon
multiline_comment|/* see strdup() below */
id|clear_exclude_list
c_func
(paren
id|el
)paren
suffix:semicolon
id|free
c_func
(paren
id|stk
)paren
suffix:semicolon
id|group-&gt;nr
op_decrement
suffix:semicolon
)brace
multiline_comment|/* Skip traversing into sub directories if the parent is excluded */
r_if
c_cond
(paren
id|dir-&gt;exclude
)paren
r_return
suffix:semicolon
multiline_comment|/* Read from the parent directories and push them down. */
id|current
op_assign
id|stk
ques
c_cond
id|stk-&gt;baselen
suffix:colon
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|current
OL
id|baselen
)paren
(brace
r_const
r_char
op_star
id|cp
suffix:semicolon
id|stk
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|stk
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current
OL
l_int|0
)paren
(brace
id|cp
op_assign
id|base
suffix:semicolon
id|current
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|cp
op_assign
id|strchr
c_func
(paren
id|base
op_plus
id|current
op_plus
l_int|1
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
id|die
c_func
(paren
l_string|&quot;oops in prep_exclude&quot;
)paren
suffix:semicolon
id|cp
op_increment
suffix:semicolon
)brace
id|stk-&gt;prev
op_assign
id|dir-&gt;exclude_stack
suffix:semicolon
id|stk-&gt;baselen
op_assign
id|cp
id|base
suffix:semicolon
id|stk-&gt;exclude_ix
op_assign
id|group-&gt;nr
suffix:semicolon
id|el
op_assign
id|add_exclude_list
c_func
(paren
id|dir
comma
id|EXC_DIRS
comma
l_int|NULL
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|dir-&gt;basebuf
op_plus
id|current
comma
id|base
op_plus
id|current
comma
id|stk-&gt;baselen
id|current
)paren
suffix:semicolon
multiline_comment|/* Abort if the directory is excluded */
r_if
c_cond
(paren
id|stk-&gt;baselen
)paren
(brace
r_int
id|dt
op_assign
id|DT_DIR
suffix:semicolon
id|dir-&gt;basebuf
(braket
id|stk-&gt;baselen
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|dir-&gt;exclude
op_assign
id|last_exclude_matching_from_lists
c_func
(paren
id|dir
comma
id|dir-&gt;basebuf
comma
id|stk-&gt;baselen
l_int|1
comma
id|dir-&gt;basebuf
op_plus
id|current
comma
op_amp
id|dt
)paren
suffix:semicolon
id|dir-&gt;basebuf
(braket
id|stk-&gt;baselen
l_int|1
)braket
op_assign
l_char|&squot;/&squot;
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;exclude
op_logical_and
id|dir-&gt;exclude-&gt;flags
op_amp
id|EXC_FLAG_NEGATIVE
)paren
id|dir-&gt;exclude
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;exclude
)paren
(brace
id|dir-&gt;basebuf
(braket
id|stk-&gt;baselen
)braket
op_assign
l_int|0
suffix:semicolon
id|dir-&gt;exclude_stack
op_assign
id|stk
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* Try to read per-directory file unless path is too long */
r_if
c_cond
(paren
id|dir-&gt;exclude_per_dir
op_logical_and
id|stk-&gt;baselen
op_plus
id|strlen
c_func
(paren
id|dir-&gt;exclude_per_dir
)paren
OL
id|PATH_MAX
)paren
(brace
id|strcpy
c_func
(paren
id|dir-&gt;basebuf
op_plus
id|stk-&gt;baselen
comma
id|dir-&gt;exclude_per_dir
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * dir-&gt;basebuf gets reused by the traversal, but we&n;&t;&t;&t; * need fname to remain unchanged to ensure the src&n;&t;&t;&t; * member of each struct exclude correctly&n;&t;&t;&t; * back-references its source file.  Other invocations&n;&t;&t;&t; * of add_exclude_list provide stable strings, so we&n;&t;&t;&t; * strdup() and free() here in the caller.&n;&t;&t;&t; */
id|el-&gt;src
op_assign
id|strdup
c_func
(paren
id|dir-&gt;basebuf
)paren
suffix:semicolon
id|add_excludes_from_file_to_list
c_func
(paren
id|dir-&gt;basebuf
comma
id|dir-&gt;basebuf
comma
id|stk-&gt;baselen
comma
id|el
comma
l_int|1
)paren
suffix:semicolon
)brace
id|dir-&gt;exclude_stack
op_assign
id|stk
suffix:semicolon
id|current
op_assign
id|stk-&gt;baselen
suffix:semicolon
)brace
id|dir-&gt;basebuf
(braket
id|baselen
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
multiline_comment|/*&n; * Loads the exclude lists for the directory containing pathname, then&n; * scans all exclude lists to determine whether pathname is excluded.&n; * Returns the exclude_list element which matched, or NULL for&n; * undecided.&n; */
DECL|function|last_exclude_matching
r_struct
id|exclude
op_star
id|last_exclude_matching
c_func
(paren
r_struct
id|dir_struct
op_star
id|dir
comma
r_const
r_char
op_star
id|pathname
comma
r_int
op_star
id|dtype_p
)paren
(brace
r_int
id|pathlen
op_assign
id|strlen
c_func
(paren
id|pathname
)paren
suffix:semicolon
r_const
r_char
op_star
id|basename
op_assign
id|strrchr
c_func
(paren
id|pathname
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
id|basename
op_assign
(paren
id|basename
)paren
ques
c_cond
id|basename
op_plus
l_int|1
suffix:colon
id|pathname
suffix:semicolon
id|prep_exclude
c_func
(paren
id|dir
comma
id|pathname
comma
id|basename
op_minus
id|pathname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;exclude
)paren
r_return
id|dir-&gt;exclude
suffix:semicolon
r_return
id|last_exclude_matching_from_lists
c_func
(paren
id|dir
comma
id|pathname
comma
id|pathlen
comma
id|basename
comma
id|dtype_p
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Loads the exclude lists for the directory containing pathname, then&n; * scans all exclude lists to determine whether pathname is excluded.&n; * Returns 1 if true, otherwise 0.&n; */
DECL|function|is_excluded
r_int
id|is_excluded
c_func
(paren
r_struct
id|dir_struct
op_star
id|dir
comma
r_const
r_char
op_star
id|pathname
comma
r_int
op_star
id|dtype_p
)paren
(brace
r_struct
id|exclude
op_star
id|exclude
op_assign
id|last_exclude_matching
c_func
(paren
id|dir
comma
id|pathname
comma
id|dtype_p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|exclude
)paren
r_return
id|exclude-&gt;flags
op_amp
id|EXC_FLAG_NEGATIVE
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|dir_entry_new
r_static
r_struct
id|dir_entry
op_star
id|dir_entry_new
c_func
(paren
r_const
r_char
op_star
id|pathname
comma
r_int
id|len
)paren
(brace
r_struct
id|dir_entry
op_star
id|ent
suffix:semicolon
id|ent
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|ent
)paren
op_plus
id|len
op_plus
l_int|1
)paren
suffix:semicolon
id|ent-&gt;len
op_assign
id|len
suffix:semicolon
id|memcpy
c_func
(paren
id|ent-&gt;name
comma
id|pathname
comma
id|len
)paren
suffix:semicolon
id|ent-&gt;name
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
r_return
id|ent
suffix:semicolon
)brace
DECL|function|dir_add_name
r_static
r_struct
id|dir_entry
op_star
id|dir_add_name
c_func
(paren
r_struct
id|dir_struct
op_star
id|dir
comma
r_const
r_char
op_star
id|pathname
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|cache_file_exists
c_func
(paren
id|pathname
comma
id|len
comma
id|ignore_case
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|ALLOC_GROW
c_func
(paren
id|dir-&gt;entries
comma
id|dir-&gt;nr
op_plus
l_int|1
comma
id|dir-&gt;alloc
)paren
suffix:semicolon
r_return
id|dir-&gt;entries
(braket
id|dir-&gt;nr
op_increment
)braket
op_assign
id|dir_entry_new
c_func
(paren
id|pathname
comma
id|len
)paren
suffix:semicolon
)brace
DECL|function|dir_add_ignored
r_struct
id|dir_entry
op_star
id|dir_add_ignored
c_func
(paren
r_struct
id|dir_struct
op_star
id|dir
comma
r_const
r_char
op_star
id|pathname
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cache_name_is_other
c_func
(paren
id|pathname
comma
id|len
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|ALLOC_GROW
c_func
(paren
id|dir-&gt;ignored
comma
id|dir-&gt;ignored_nr
op_plus
l_int|1
comma
id|dir-&gt;ignored_alloc
)paren
suffix:semicolon
r_return
id|dir-&gt;ignored
(braket
id|dir-&gt;ignored_nr
op_increment
)braket
op_assign
id|dir_entry_new
c_func
(paren
id|pathname
comma
id|len
)paren
suffix:semicolon
)brace
DECL|enum|exist_status
r_enum
id|exist_status
(brace
DECL|enumerator|index_nonexistent
id|index_nonexistent
op_assign
l_int|0
comma
DECL|enumerator|index_directory
id|index_directory
comma
DECL|enumerator|index_gitdir
id|index_gitdir
)brace
suffix:semicolon
multiline_comment|/*&n; * Do not use the alphabetically sorted index to look up&n; * the directory name; instead, use the case insensitive&n; * directory hash.&n; */
DECL|function|directory_exists_in_index_icase
r_static
r_enum
id|exist_status
id|directory_exists_in_index_icase
c_func
(paren
r_const
r_char
op_star
id|dirname
comma
r_int
id|len
)paren
(brace
r_const
r_struct
id|cache_entry
op_star
id|ce
op_assign
id|cache_dir_exists
c_func
(paren
id|dirname
comma
id|len
)paren
suffix:semicolon
r_int
r_char
id|endchar
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ce
)paren
r_return
id|index_nonexistent
suffix:semicolon
id|endchar
op_assign
id|ce-&gt;name
(braket
id|len
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * The cache_entry structure returned will contain this dirname&n;&t; * and possibly additional path components.&n;&t; */
r_if
c_cond
(paren
id|endchar
op_eq
l_char|&squot;/&squot;
)paren
r_return
id|index_directory
suffix:semicolon
multiline_comment|/*&n;&t; * If there are no additional path components, then this cache_entry&n;&t; * represents a submodule.  Submodules, despite being directories,&n;&t; * are stored in the cache without a closing slash.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|endchar
op_logical_and
id|S_ISGITLINK
c_func
(paren
id|ce-&gt;ce_mode
)paren
)paren
r_return
id|index_gitdir
suffix:semicolon
multiline_comment|/* This should never be hit, but it exists just in case. */
r_return
id|index_nonexistent
suffix:semicolon
)brace
multiline_comment|/*&n; * The index sorts alphabetically by entry name, which&n; * means that a gitlink sorts as &squot;&bslash;0&squot; at the end, while&n; * a directory (which is defined not as an entry, but as&n; * the files it contains) will sort with the &squot;/&squot; at the&n; * end.&n; */
DECL|function|directory_exists_in_index
r_static
r_enum
id|exist_status
id|directory_exists_in_index
c_func
(paren
r_const
r_char
op_star
id|dirname
comma
r_int
id|len
)paren
(brace
r_int
id|pos
suffix:semicolon
r_if
c_cond
(paren
id|ignore_case
)paren
r_return
id|directory_exists_in_index_icase
c_func
(paren
id|dirname
comma
id|len
)paren
suffix:semicolon
id|pos
op_assign
id|cache_name_pos
c_func
(paren
id|dirname
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
l_int|0
)paren
id|pos
op_assign
id|pos
op_minus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|pos
OL
id|active_nr
)paren
(brace
r_const
r_struct
id|cache_entry
op_star
id|ce
op_assign
id|active_cache
(braket
id|pos
op_increment
)braket
suffix:semicolon
r_int
r_char
id|endchar
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|ce-&gt;name
comma
id|dirname
comma
id|len
)paren
)paren
r_break
suffix:semicolon
id|endchar
op_assign
id|ce-&gt;name
(braket
id|len
)braket
suffix:semicolon
r_if
c_cond
(paren
id|endchar
OG
l_char|&squot;/&squot;
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|endchar
op_eq
l_char|&squot;/&squot;
)paren
r_return
id|index_directory
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|endchar
op_logical_and
id|S_ISGITLINK
c_func
(paren
id|ce-&gt;ce_mode
)paren
)paren
r_return
id|index_gitdir
suffix:semicolon
)brace
r_return
id|index_nonexistent
suffix:semicolon
)brace
multiline_comment|/*&n; * When we find a directory when traversing the filesystem, we&n; * have three distinct cases:&n; *&n; *  - ignore it&n; *  - see it as a directory&n; *  - recurse into it&n; *&n; * and which one we choose depends on a combination of existing&n; * git index contents and the flags passed into the directory&n; * traversal routine.&n; *&n; * Case 1: If we *already* have entries in the index under that&n; * directory name, we always recurse into the directory to see&n; * all the files.&n; *&n; * Case 2: If we *already* have that directory name as a gitlink,&n; * we always continue to see it as a gitlink, regardless of whether&n; * there is an actual git directory there or not (it might not&n; * be checked out as a subproject!)&n; *&n; * Case 3: if we didn&squot;t have it in the index previously, we&n; * have a few sub-cases:&n; *&n; *  (a) if &quot;show_other_directories&quot; is true, we show it as&n; *      just a directory, unless &quot;hide_empty_directories&quot; is&n; *      also true, in which case we need to check if it contains any&n; *      untracked and / or ignored files.&n; *  (b) if it looks like a git directory, and we don&squot;t have&n; *      &squot;no_gitlinks&squot; set we treat it as a gitlink, and show it&n; *      as a directory.&n; *  (c) otherwise, we recurse into it.&n; */
DECL|function|treat_directory
r_static
r_enum
id|path_treatment
id|treat_directory
c_func
(paren
r_struct
id|dir_struct
op_star
id|dir
comma
r_const
r_char
op_star
id|dirname
comma
r_int
id|len
comma
r_int
id|exclude
comma
r_const
r_struct
id|path_simplify
op_star
id|simplify
)paren
(brace
multiline_comment|/* The &quot;len-1&quot; is to strip the final &squot;/&squot; */
r_switch
c_cond
(paren
id|directory_exists_in_index
c_func
(paren
id|dirname
comma
id|len
op_minus
l_int|1
)paren
)paren
(brace
r_case
id|index_directory
suffix:colon
r_return
id|path_recurse
suffix:semicolon
r_case
id|index_gitdir
suffix:colon
r_return
id|path_none
suffix:semicolon
r_case
id|index_nonexistent
suffix:colon
r_if
c_cond
(paren
id|dir-&gt;flags
op_amp
id|DIR_SHOW_OTHER_DIRECTORIES
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|dir-&gt;flags
op_amp
id|DIR_NO_GITLINKS
)paren
)paren
(brace
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
r_if
c_cond
(paren
id|resolve_gitlink_ref
c_func
(paren
id|dirname
comma
l_string|&quot;HEAD&quot;
comma
id|sha1
)paren
op_eq
l_int|0
)paren
r_return
id|path_untracked
suffix:semicolon
)brace
r_return
id|path_recurse
suffix:semicolon
)brace
multiline_comment|/* This is the &quot;show_other_directories&quot; case */
r_if
c_cond
(paren
op_logical_neg
(paren
id|dir-&gt;flags
op_amp
id|DIR_HIDE_EMPTY_DIRECTORIES
)paren
)paren
r_return
id|exclude
ques
c_cond
id|path_excluded
suffix:colon
id|path_untracked
suffix:semicolon
r_return
id|read_directory_recursive
c_func
(paren
id|dir
comma
id|dirname
comma
id|len
comma
l_int|1
comma
id|simplify
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is an inexact early pruning of any recursive directory&n; * reading - if the path cannot possibly be in the pathspec,&n; * return true, and we&squot;ll skip it early.&n; */
DECL|function|simplify_away
r_static
r_int
id|simplify_away
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_int
id|pathlen
comma
r_const
r_struct
id|path_simplify
op_star
id|simplify
)paren
(brace
r_if
c_cond
(paren
id|simplify
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_const
r_char
op_star
id|match
op_assign
id|simplify-&gt;path
suffix:semicolon
r_int
id|len
op_assign
id|simplify-&gt;len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|match
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|pathlen
)paren
id|len
op_assign
id|pathlen
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|path
comma
id|match
comma
id|len
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|simplify
op_increment
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function tells us whether an excluded path matches a&n; * list of &quot;interesting&quot; pathspecs. That is, whether a path matched&n; * by any of the pathspecs could possibly be ignored by excluding&n; * the specified path. This can happen if:&n; *&n; *   1. the path is mentioned explicitly in the pathspec&n; *&n; *   2. the path is a directory prefix of some element in the&n; *      pathspec&n; */
DECL|function|exclude_matches_pathspec
r_static
r_int
id|exclude_matches_pathspec
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_int
id|len
comma
r_const
r_struct
id|path_simplify
op_star
id|simplify
)paren
(brace
r_if
c_cond
(paren
id|simplify
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|simplify-&gt;path
suffix:semicolon
id|simplify
op_increment
)paren
(brace
r_if
c_cond
(paren
id|len
op_eq
id|simplify-&gt;len
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|path
comma
id|simplify-&gt;path
comma
id|len
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
id|simplify-&gt;len
op_logical_and
id|simplify-&gt;path
(braket
id|len
)braket
op_eq
l_char|&squot;/&squot;
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|path
comma
id|simplify-&gt;path
comma
id|len
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|get_index_dtype
r_static
r_int
id|get_index_dtype
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_int
id|len
)paren
(brace
r_int
id|pos
suffix:semicolon
r_const
r_struct
id|cache_entry
op_star
id|ce
suffix:semicolon
id|ce
op_assign
id|cache_file_exists
c_func
(paren
id|path
comma
id|len
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ce
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ce_uptodate
c_func
(paren
id|ce
)paren
)paren
r_return
id|DT_UNKNOWN
suffix:semicolon
r_if
c_cond
(paren
id|S_ISGITLINK
c_func
(paren
id|ce-&gt;ce_mode
)paren
)paren
r_return
id|DT_DIR
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Nobody actually cares about the&n;&t;&t; * difference between DT_LNK and DT_REG&n;&t;&t; */
r_return
id|DT_REG
suffix:semicolon
)brace
multiline_comment|/* Try to look it up as a directory */
id|pos
op_assign
id|cache_name_pos
c_func
(paren
id|path
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_ge
l_int|0
)paren
r_return
id|DT_UNKNOWN
suffix:semicolon
id|pos
op_assign
id|pos
op_minus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|pos
OL
id|active_nr
)paren
(brace
id|ce
op_assign
id|active_cache
(braket
id|pos
op_increment
)braket
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|ce-&gt;name
comma
id|path
comma
id|len
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|ce-&gt;name
(braket
id|len
)braket
OG
l_char|&squot;/&squot;
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|ce-&gt;name
(braket
id|len
)braket
OL
l_char|&squot;/&squot;
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ce_uptodate
c_func
(paren
id|ce
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* continue? */
r_return
id|DT_DIR
suffix:semicolon
)brace
r_return
id|DT_UNKNOWN
suffix:semicolon
)brace
DECL|function|get_dtype
r_static
r_int
id|get_dtype
c_func
(paren
r_struct
id|dirent
op_star
id|de
comma
r_const
r_char
op_star
id|path
comma
r_int
id|len
)paren
(brace
r_int
id|dtype
op_assign
id|de
ques
c_cond
id|DTYPE
c_func
(paren
id|de
)paren
suffix:colon
id|DT_UNKNOWN
suffix:semicolon
r_struct
id|stat
id|st
suffix:semicolon
r_if
c_cond
(paren
id|dtype
op_ne
id|DT_UNKNOWN
)paren
r_return
id|dtype
suffix:semicolon
id|dtype
op_assign
id|get_index_dtype
c_func
(paren
id|path
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dtype
op_ne
id|DT_UNKNOWN
)paren
r_return
id|dtype
suffix:semicolon
r_if
c_cond
(paren
id|lstat
c_func
(paren
id|path
comma
op_amp
id|st
)paren
)paren
r_return
id|dtype
suffix:semicolon
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|st.st_mode
)paren
)paren
r_return
id|DT_REG
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|st.st_mode
)paren
)paren
r_return
id|DT_DIR
suffix:semicolon
r_if
c_cond
(paren
id|S_ISLNK
c_func
(paren
id|st.st_mode
)paren
)paren
r_return
id|DT_LNK
suffix:semicolon
r_return
id|dtype
suffix:semicolon
)brace
DECL|function|treat_one_path
r_static
r_enum
id|path_treatment
id|treat_one_path
c_func
(paren
r_struct
id|dir_struct
op_star
id|dir
comma
r_struct
id|strbuf
op_star
id|path
comma
r_const
r_struct
id|path_simplify
op_star
id|simplify
comma
r_int
id|dtype
comma
r_struct
id|dirent
op_star
id|de
)paren
(brace
r_int
id|exclude
suffix:semicolon
r_int
id|has_path_in_index
op_assign
op_logical_neg
op_logical_neg
id|cache_file_exists
c_func
(paren
id|path-&gt;buf
comma
id|path-&gt;len
comma
id|ignore_case
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dtype
op_eq
id|DT_UNKNOWN
)paren
id|dtype
op_assign
id|get_dtype
c_func
(paren
id|de
comma
id|path-&gt;buf
comma
id|path-&gt;len
)paren
suffix:semicolon
multiline_comment|/* Always exclude indexed files */
r_if
c_cond
(paren
id|dtype
op_ne
id|DT_DIR
op_logical_and
id|has_path_in_index
)paren
r_return
id|path_none
suffix:semicolon
multiline_comment|/*&n;&t; * When we are looking at a directory P in the working tree,&n;&t; * there are three cases:&n;&t; *&n;&t; * (1) P exists in the index.  Everything inside the directory P in&n;&t; * the working tree needs to go when P is checked out from the&n;&t; * index.&n;&t; *&n;&t; * (2) P does not exist in the index, but there is P/Q in the index.&n;&t; * We know P will stay a directory when we check out the contents&n;&t; * of the index, but we do not know yet if there is a directory&n;&t; * P/Q in the working tree to be killed, so we need to recurse.&n;&t; *&n;&t; * (3) P does not exist in the index, and there is no P/Q in the index&n;&t; * to require P to be a directory, either.  Only in this case, we&n;&t; * know that everything inside P will not be killed without&n;&t; * recursing.&n;&t; */
r_if
c_cond
(paren
(paren
id|dir-&gt;flags
op_amp
id|DIR_COLLECT_KILLED_ONLY
)paren
op_logical_and
(paren
id|dtype
op_eq
id|DT_DIR
)paren
op_logical_and
op_logical_neg
id|has_path_in_index
op_logical_and
(paren
id|directory_exists_in_index
c_func
(paren
id|path-&gt;buf
comma
id|path-&gt;len
)paren
op_eq
id|index_nonexistent
)paren
)paren
r_return
id|path_none
suffix:semicolon
id|exclude
op_assign
id|is_excluded
c_func
(paren
id|dir
comma
id|path-&gt;buf
comma
op_amp
id|dtype
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Excluded? If we don&squot;t explicitly want to show&n;&t; * ignored files, ignore it&n;&t; */
r_if
c_cond
(paren
id|exclude
op_logical_and
op_logical_neg
(paren
id|dir-&gt;flags
op_amp
(paren
id|DIR_SHOW_IGNORED
op_or
id|DIR_SHOW_IGNORED_TOO
)paren
)paren
)paren
r_return
id|path_excluded
suffix:semicolon
r_switch
c_cond
(paren
id|dtype
)paren
(brace
r_default
suffix:colon
r_return
id|path_none
suffix:semicolon
r_case
id|DT_DIR
suffix:colon
id|strbuf_addch
c_func
(paren
id|path
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
r_return
id|treat_directory
c_func
(paren
id|dir
comma
id|path-&gt;buf
comma
id|path-&gt;len
comma
id|exclude
comma
id|simplify
)paren
suffix:semicolon
r_case
id|DT_REG
suffix:colon
r_case
id|DT_LNK
suffix:colon
r_return
id|exclude
ques
c_cond
id|path_excluded
suffix:colon
id|path_untracked
suffix:semicolon
)brace
)brace
DECL|function|treat_path
r_static
r_enum
id|path_treatment
id|treat_path
c_func
(paren
r_struct
id|dir_struct
op_star
id|dir
comma
r_struct
id|dirent
op_star
id|de
comma
r_struct
id|strbuf
op_star
id|path
comma
r_int
id|baselen
comma
r_const
r_struct
id|path_simplify
op_star
id|simplify
)paren
(brace
r_int
id|dtype
suffix:semicolon
r_if
c_cond
(paren
id|is_dot_or_dotdot
c_func
(paren
id|de-&gt;d_name
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|de-&gt;d_name
comma
l_string|&quot;.git&quot;
)paren
)paren
r_return
id|path_none
suffix:semicolon
id|strbuf_setlen
c_func
(paren
id|path
comma
id|baselen
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
id|path
comma
id|de-&gt;d_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|simplify_away
c_func
(paren
id|path-&gt;buf
comma
id|path-&gt;len
comma
id|simplify
)paren
)paren
r_return
id|path_none
suffix:semicolon
id|dtype
op_assign
id|DTYPE
c_func
(paren
id|de
)paren
suffix:semicolon
r_return
id|treat_one_path
c_func
(paren
id|dir
comma
id|path
comma
id|simplify
comma
id|dtype
comma
id|de
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Read a directory tree. We currently ignore anything but&n; * directories, regular files and symlinks. That&squot;s because git&n; * doesn&squot;t handle them at all yet. Maybe that will change some&n; * day.&n; *&n; * Also, we ignore the name &quot;.git&quot; (even if it is not a directory).&n; * That likely will not change.&n; *&n; * Returns the most significant path_treatment value encountered in the scan.&n; */
DECL|function|read_directory_recursive
r_static
r_enum
id|path_treatment
id|read_directory_recursive
c_func
(paren
r_struct
id|dir_struct
op_star
id|dir
comma
r_const
r_char
op_star
id|base
comma
r_int
id|baselen
comma
r_int
id|check_only
comma
r_const
r_struct
id|path_simplify
op_star
id|simplify
)paren
(brace
id|DIR
op_star
id|fdir
suffix:semicolon
r_enum
id|path_treatment
id|state
comma
id|subdir_state
comma
id|dir_state
op_assign
id|path_none
suffix:semicolon
r_struct
id|dirent
op_star
id|de
suffix:semicolon
r_struct
id|strbuf
id|path
op_assign
id|STRBUF_INIT
suffix:semicolon
id|strbuf_add
c_func
(paren
op_amp
id|path
comma
id|base
comma
id|baselen
)paren
suffix:semicolon
id|fdir
op_assign
id|opendir
c_func
(paren
id|path.len
ques
c_cond
id|path.buf
suffix:colon
l_string|&quot;.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fdir
)paren
r_goto
id|out
suffix:semicolon
r_while
c_loop
(paren
(paren
id|de
op_assign
id|readdir
c_func
(paren
id|fdir
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* check how the file or directory should be treated */
id|state
op_assign
id|treat_path
c_func
(paren
id|dir
comma
id|de
comma
op_amp
id|path
comma
id|baselen
comma
id|simplify
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state
OG
id|dir_state
)paren
id|dir_state
op_assign
id|state
suffix:semicolon
multiline_comment|/* recurse into subdir if instructed by treat_path */
r_if
c_cond
(paren
id|state
op_eq
id|path_recurse
)paren
(brace
id|subdir_state
op_assign
id|read_directory_recursive
c_func
(paren
id|dir
comma
id|path.buf
comma
id|path.len
comma
id|check_only
comma
id|simplify
)paren
suffix:semicolon
r_if
c_cond
(paren
id|subdir_state
OG
id|dir_state
)paren
id|dir_state
op_assign
id|subdir_state
suffix:semicolon
)brace
r_if
c_cond
(paren
id|check_only
)paren
(brace
multiline_comment|/* abort early if maximum state has been reached */
r_if
c_cond
(paren
id|dir_state
op_eq
id|path_untracked
)paren
r_break
suffix:semicolon
multiline_comment|/* skip the dir_add_* part */
r_continue
suffix:semicolon
)brace
multiline_comment|/* add the path to the appropriate result list */
r_switch
c_cond
(paren
id|state
)paren
(brace
r_case
id|path_excluded
suffix:colon
r_if
c_cond
(paren
id|dir-&gt;flags
op_amp
id|DIR_SHOW_IGNORED
)paren
id|dir_add_name
c_func
(paren
id|dir
comma
id|path.buf
comma
id|path.len
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|dir-&gt;flags
op_amp
id|DIR_SHOW_IGNORED_TOO
)paren
op_logical_or
(paren
(paren
id|dir-&gt;flags
op_amp
id|DIR_COLLECT_IGNORED
)paren
op_logical_and
id|exclude_matches_pathspec
c_func
(paren
id|path.buf
comma
id|path.len
comma
id|simplify
)paren
)paren
)paren
id|dir_add_ignored
c_func
(paren
id|dir
comma
id|path.buf
comma
id|path.len
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|path_untracked
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|dir-&gt;flags
op_amp
id|DIR_SHOW_IGNORED
)paren
)paren
id|dir_add_name
c_func
(paren
id|dir
comma
id|path.buf
comma
id|path.len
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
id|closedir
c_func
(paren
id|fdir
)paren
suffix:semicolon
id|out
suffix:colon
id|strbuf_release
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
r_return
id|dir_state
suffix:semicolon
)brace
DECL|function|cmp_name
r_static
r_int
id|cmp_name
c_func
(paren
r_const
r_void
op_star
id|p1
comma
r_const
r_void
op_star
id|p2
)paren
(brace
r_const
r_struct
id|dir_entry
op_star
id|e1
op_assign
op_star
(paren
r_const
r_struct
id|dir_entry
op_star
op_star
)paren
id|p1
suffix:semicolon
r_const
r_struct
id|dir_entry
op_star
id|e2
op_assign
op_star
(paren
r_const
r_struct
id|dir_entry
op_star
op_star
)paren
id|p2
suffix:semicolon
r_return
id|cache_name_compare
c_func
(paren
id|e1-&gt;name
comma
id|e1-&gt;len
comma
id|e2-&gt;name
comma
id|e2-&gt;len
)paren
suffix:semicolon
)brace
DECL|function|create_simplify
r_static
r_struct
id|path_simplify
op_star
id|create_simplify
c_func
(paren
r_const
r_char
op_star
op_star
id|pathspec
)paren
(brace
r_int
id|nr
comma
id|alloc
op_assign
l_int|0
suffix:semicolon
r_struct
id|path_simplify
op_star
id|simplify
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pathspec
)paren
r_return
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|nr
op_assign
l_int|0
suffix:semicolon
suffix:semicolon
id|nr
op_increment
)paren
(brace
r_const
r_char
op_star
id|match
suffix:semicolon
id|ALLOC_GROW
c_func
(paren
id|simplify
comma
id|nr
op_plus
l_int|1
comma
id|alloc
)paren
suffix:semicolon
id|match
op_assign
op_star
id|pathspec
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|match
)paren
r_break
suffix:semicolon
id|simplify
(braket
id|nr
)braket
dot
id|path
op_assign
id|match
suffix:semicolon
id|simplify
(braket
id|nr
)braket
dot
id|len
op_assign
id|simple_length
c_func
(paren
id|match
)paren
suffix:semicolon
)brace
id|simplify
(braket
id|nr
)braket
dot
id|path
op_assign
l_int|NULL
suffix:semicolon
id|simplify
(braket
id|nr
)braket
dot
id|len
op_assign
l_int|0
suffix:semicolon
r_return
id|simplify
suffix:semicolon
)brace
DECL|function|free_simplify
r_static
r_void
id|free_simplify
c_func
(paren
r_struct
id|path_simplify
op_star
id|simplify
)paren
(brace
id|free
c_func
(paren
id|simplify
)paren
suffix:semicolon
)brace
DECL|function|treat_leading_path
r_static
r_int
id|treat_leading_path
c_func
(paren
r_struct
id|dir_struct
op_star
id|dir
comma
r_const
r_char
op_star
id|path
comma
r_int
id|len
comma
r_const
r_struct
id|path_simplify
op_star
id|simplify
)paren
(brace
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|baselen
comma
id|rc
op_assign
l_int|0
suffix:semicolon
r_const
r_char
op_star
id|cp
suffix:semicolon
r_int
id|old_flags
op_assign
id|dir-&gt;flags
suffix:semicolon
r_while
c_loop
(paren
id|len
op_logical_and
id|path
(braket
id|len
l_int|1
)braket
op_eq
l_char|&squot;/&squot;
)paren
id|len
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
r_return
l_int|1
suffix:semicolon
id|baselen
op_assign
l_int|0
suffix:semicolon
id|dir-&gt;flags
op_and_assign
op_complement
id|DIR_SHOW_OTHER_DIRECTORIES
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|cp
op_assign
id|path
op_plus
id|baselen
op_plus
op_logical_neg
op_logical_neg
id|baselen
suffix:semicolon
id|cp
op_assign
id|memchr
c_func
(paren
id|cp
comma
l_char|&squot;/&squot;
comma
id|path
op_plus
id|len
id|cp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
id|baselen
op_assign
id|len
suffix:semicolon
r_else
id|baselen
op_assign
id|cp
id|path
suffix:semicolon
id|strbuf_setlen
c_func
(paren
op_amp
id|sb
comma
l_int|0
)paren
suffix:semicolon
id|strbuf_add
c_func
(paren
op_amp
id|sb
comma
id|path
comma
id|baselen
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_directory
c_func
(paren
id|sb.buf
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|simplify_away
c_func
(paren
id|sb.buf
comma
id|sb.len
comma
id|simplify
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|treat_one_path
c_func
(paren
id|dir
comma
op_amp
id|sb
comma
id|simplify
comma
id|DT_DIR
comma
l_int|NULL
)paren
op_eq
id|path_none
)paren
r_break
suffix:semicolon
multiline_comment|/* do not recurse into it */
r_if
c_cond
(paren
id|len
op_le
id|baselen
)paren
(brace
id|rc
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* finished checking */
)brace
)brace
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
id|dir-&gt;flags
op_assign
id|old_flags
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|read_directory
r_int
id|read_directory
c_func
(paren
r_struct
id|dir_struct
op_star
id|dir
comma
r_const
r_char
op_star
id|path
comma
r_int
id|len
comma
r_const
r_struct
id|pathspec
op_star
id|pathspec
)paren
(brace
r_struct
id|path_simplify
op_star
id|simplify
suffix:semicolon
multiline_comment|/*&n;&t; * Check out create_simplify()&n;&t; */
r_if
c_cond
(paren
id|pathspec
)paren
id|GUARD_PATHSPEC
c_func
(paren
id|pathspec
comma
id|PATHSPEC_FROMTOP
op_or
id|PATHSPEC_MAXDEPTH
op_or
id|PATHSPEC_LITERAL
op_or
id|PATHSPEC_GLOB
op_or
id|PATHSPEC_ICASE
op_or
id|PATHSPEC_EXCLUDE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|has_symlink_leading_path
c_func
(paren
id|path
comma
id|len
)paren
)paren
r_return
id|dir-&gt;nr
suffix:semicolon
multiline_comment|/*&n;&t; * exclude patterns are treated like positive ones in&n;&t; * create_simplify. Usually exclude patterns should be a&n;&t; * subset of positive ones, which has no impacts on&n;&t; * create_simplify().&n;&t; */
id|simplify
op_assign
id|create_simplify
c_func
(paren
id|pathspec
ques
c_cond
id|pathspec-&gt;_raw
suffix:colon
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
op_logical_or
id|treat_leading_path
c_func
(paren
id|dir
comma
id|path
comma
id|len
comma
id|simplify
)paren
)paren
id|read_directory_recursive
c_func
(paren
id|dir
comma
id|path
comma
id|len
comma
l_int|0
comma
id|simplify
)paren
suffix:semicolon
id|free_simplify
c_func
(paren
id|simplify
)paren
suffix:semicolon
id|qsort
c_func
(paren
id|dir-&gt;entries
comma
id|dir-&gt;nr
comma
r_sizeof
(paren
r_struct
id|dir_entry
op_star
)paren
comma
id|cmp_name
)paren
suffix:semicolon
id|qsort
c_func
(paren
id|dir-&gt;ignored
comma
id|dir-&gt;ignored_nr
comma
r_sizeof
(paren
r_struct
id|dir_entry
op_star
)paren
comma
id|cmp_name
)paren
suffix:semicolon
r_return
id|dir-&gt;nr
suffix:semicolon
)brace
DECL|function|file_exists
r_int
id|file_exists
c_func
(paren
r_const
r_char
op_star
id|f
)paren
(brace
r_struct
id|stat
id|sb
suffix:semicolon
r_return
id|lstat
c_func
(paren
id|f
comma
op_amp
id|sb
)paren
op_eq
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Given two normalized paths (a trailing slash is ok), if subdir is&n; * outside dir, return -1.  Otherwise return the offset in subdir that&n; * can be used as relative path to dir.&n; */
DECL|function|dir_inside_of
r_int
id|dir_inside_of
c_func
(paren
r_const
r_char
op_star
id|subdir
comma
r_const
r_char
op_star
id|dir
)paren
(brace
r_int
id|offset
op_assign
l_int|0
suffix:semicolon
m_assert
(paren
id|dir
op_logical_and
id|subdir
op_logical_and
op_star
id|dir
op_logical_and
op_star
id|subdir
)paren
suffix:semicolon
r_while
c_loop
(paren
op_star
id|dir
op_logical_and
op_star
id|subdir
op_logical_and
op_star
id|dir
op_eq
op_star
id|subdir
)paren
(brace
id|dir
op_increment
suffix:semicolon
id|subdir
op_increment
suffix:semicolon
id|offset
op_increment
suffix:semicolon
)brace
multiline_comment|/* hel[p]/me vs hel[l]/yeah */
r_if
c_cond
(paren
op_star
id|dir
op_logical_and
op_star
id|subdir
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|subdir
)paren
r_return
op_logical_neg
op_star
id|dir
ques
c_cond
id|offset
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* same dir */
multiline_comment|/* foo/[b]ar vs foo/[] */
r_if
c_cond
(paren
id|is_dir_sep
c_func
(paren
id|dir
(braket
l_int|1
)braket
)paren
)paren
r_return
id|is_dir_sep
c_func
(paren
id|subdir
(braket
l_int|1
)braket
)paren
ques
c_cond
id|offset
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* foo[/]bar vs foo[] */
r_return
id|is_dir_sep
c_func
(paren
op_star
id|subdir
)paren
ques
c_cond
id|offset
op_plus
l_int|1
suffix:colon
l_int|1
suffix:semicolon
)brace
DECL|function|is_inside_dir
r_int
id|is_inside_dir
c_func
(paren
r_const
r_char
op_star
id|dir
)paren
(brace
r_char
id|cwd
(braket
id|PATH_MAX
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|getcwd
c_func
(paren
id|cwd
comma
r_sizeof
(paren
id|cwd
)paren
)paren
)paren
id|die_errno
c_func
(paren
l_string|&quot;can&squot;t find the current directory&quot;
)paren
suffix:semicolon
r_return
id|dir_inside_of
c_func
(paren
id|cwd
comma
id|dir
)paren
op_ge
l_int|0
suffix:semicolon
)brace
DECL|function|is_empty_dir
r_int
id|is_empty_dir
c_func
(paren
r_const
r_char
op_star
id|path
)paren
(brace
id|DIR
op_star
id|dir
op_assign
id|opendir
c_func
(paren
id|path
)paren
suffix:semicolon
r_struct
id|dirent
op_star
id|e
suffix:semicolon
r_int
id|ret
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir
)paren
r_return
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|e
op_assign
id|readdir
c_func
(paren
id|dir
)paren
)paren
op_ne
l_int|NULL
)paren
r_if
c_cond
(paren
op_logical_neg
id|is_dot_or_dotdot
c_func
(paren
id|e-&gt;d_name
)paren
)paren
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|closedir
c_func
(paren
id|dir
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|remove_dir_recurse
r_static
r_int
id|remove_dir_recurse
c_func
(paren
r_struct
id|strbuf
op_star
id|path
comma
r_int
id|flag
comma
r_int
op_star
id|kept_up
)paren
(brace
id|DIR
op_star
id|dir
suffix:semicolon
r_struct
id|dirent
op_star
id|e
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
comma
id|original_len
op_assign
id|path-&gt;len
comma
id|len
comma
id|kept_down
op_assign
l_int|0
suffix:semicolon
r_int
id|only_empty
op_assign
(paren
id|flag
op_amp
id|REMOVE_DIR_EMPTY_ONLY
)paren
suffix:semicolon
r_int
id|keep_toplevel
op_assign
(paren
id|flag
op_amp
id|REMOVE_DIR_KEEP_TOPLEVEL
)paren
suffix:semicolon
r_int
r_char
id|submodule_head
(braket
l_int|20
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flag
op_amp
id|REMOVE_DIR_KEEP_NESTED_GIT
)paren
op_logical_and
op_logical_neg
id|resolve_gitlink_ref
c_func
(paren
id|path-&gt;buf
comma
l_string|&quot;HEAD&quot;
comma
id|submodule_head
)paren
)paren
(brace
multiline_comment|/* Do not descend and nuke a nested git work tree. */
r_if
c_cond
(paren
id|kept_up
)paren
op_star
id|kept_up
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|flag
op_and_assign
op_complement
id|REMOVE_DIR_KEEP_TOPLEVEL
suffix:semicolon
id|dir
op_assign
id|opendir
c_func
(paren
id|path-&gt;buf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir
)paren
(brace
r_if
c_cond
(paren
id|errno
op_eq
id|ENOENT
)paren
r_return
id|keep_toplevel
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|errno
op_eq
id|EACCES
op_logical_and
op_logical_neg
id|keep_toplevel
)paren
multiline_comment|/*&n;&t;&t;&t; * An empty dir could be removable even if it&n;&t;&t;&t; * is unreadable:&n;&t;&t;&t; */
r_return
id|rmdir
c_func
(paren
id|path-&gt;buf
)paren
suffix:semicolon
r_else
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|path-&gt;buf
(braket
id|original_len
l_int|1
)braket
op_ne
l_char|&squot;/&squot;
)paren
id|strbuf_addch
c_func
(paren
id|path
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
id|len
op_assign
id|path-&gt;len
suffix:semicolon
r_while
c_loop
(paren
(paren
id|e
op_assign
id|readdir
c_func
(paren
id|dir
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_struct
id|stat
id|st
suffix:semicolon
r_if
c_cond
(paren
id|is_dot_or_dotdot
c_func
(paren
id|e-&gt;d_name
)paren
)paren
r_continue
suffix:semicolon
id|strbuf_setlen
c_func
(paren
id|path
comma
id|len
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
id|path
comma
id|e-&gt;d_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lstat
c_func
(paren
id|path-&gt;buf
comma
op_amp
id|st
)paren
)paren
(brace
r_if
c_cond
(paren
id|errno
op_eq
id|ENOENT
)paren
multiline_comment|/*&n;&t;&t;&t;&t; * file disappeared, which is what we&n;&t;&t;&t;&t; * wanted anyway&n;&t;&t;&t;&t; */
r_continue
suffix:semicolon
multiline_comment|/* fall thru */
)brace
r_else
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|st.st_mode
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|remove_dir_recurse
c_func
(paren
id|path
comma
id|flag
comma
op_amp
id|kept_down
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* happy */
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|only_empty
op_logical_and
(paren
op_logical_neg
id|unlink
c_func
(paren
id|path-&gt;buf
)paren
op_logical_or
id|errno
op_eq
id|ENOENT
)paren
)paren
(brace
r_continue
suffix:semicolon
multiline_comment|/* happy, too */
)brace
multiline_comment|/* path too long, stat fails, or non-directory still exists */
id|ret
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|closedir
c_func
(paren
id|dir
)paren
suffix:semicolon
id|strbuf_setlen
c_func
(paren
id|path
comma
id|original_len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
op_logical_and
op_logical_neg
id|keep_toplevel
op_logical_and
op_logical_neg
id|kept_down
)paren
id|ret
op_assign
(paren
op_logical_neg
id|rmdir
c_func
(paren
id|path-&gt;buf
)paren
op_logical_or
id|errno
op_eq
id|ENOENT
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|kept_up
)paren
multiline_comment|/*&n;&t;&t; * report the uplevel that it is not an error that we&n;&t;&t; * did not rmdir() our directory.&n;&t;&t; */
op_star
id|kept_up
op_assign
op_logical_neg
id|ret
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|remove_dir_recursively
r_int
id|remove_dir_recursively
c_func
(paren
r_struct
id|strbuf
op_star
id|path
comma
r_int
id|flag
)paren
(brace
r_return
id|remove_dir_recurse
c_func
(paren
id|path
comma
id|flag
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|setup_standard_excludes
r_void
id|setup_standard_excludes
c_func
(paren
r_struct
id|dir_struct
op_star
id|dir
)paren
(brace
r_const
r_char
op_star
id|path
suffix:semicolon
r_char
op_star
id|xdg_path
suffix:semicolon
id|dir-&gt;exclude_per_dir
op_assign
l_string|&quot;.gitignore&quot;
suffix:semicolon
id|path
op_assign
id|git_path
c_func
(paren
l_string|&quot;info/exclude&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|excludes_file
)paren
(brace
id|home_config_paths
c_func
(paren
l_int|NULL
comma
op_amp
id|xdg_path
comma
l_string|&quot;ignore&quot;
)paren
suffix:semicolon
id|excludes_file
op_assign
id|xdg_path
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|access_or_warn
c_func
(paren
id|path
comma
id|R_OK
comma
l_int|0
)paren
)paren
id|add_excludes_from_file
c_func
(paren
id|dir
comma
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|excludes_file
op_logical_and
op_logical_neg
id|access_or_warn
c_func
(paren
id|excludes_file
comma
id|R_OK
comma
l_int|0
)paren
)paren
id|add_excludes_from_file
c_func
(paren
id|dir
comma
id|excludes_file
)paren
suffix:semicolon
)brace
DECL|function|remove_path
r_int
id|remove_path
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_char
op_star
id|slash
suffix:semicolon
r_if
c_cond
(paren
id|unlink
c_func
(paren
id|name
)paren
op_logical_and
id|errno
op_ne
id|ENOENT
op_logical_and
id|errno
op_ne
id|ENOTDIR
)paren
r_return
l_int|1
suffix:semicolon
id|slash
op_assign
id|strrchr
c_func
(paren
id|name
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slash
)paren
(brace
r_char
op_star
id|dirs
op_assign
id|xstrdup
c_func
(paren
id|name
)paren
suffix:semicolon
id|slash
op_assign
id|dirs
op_plus
(paren
id|slash
id|name
)paren
suffix:semicolon
r_do
(brace
op_star
id|slash
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
r_while
c_loop
(paren
id|rmdir
c_func
(paren
id|dirs
)paren
op_eq
l_int|0
op_logical_and
(paren
id|slash
op_assign
id|strrchr
c_func
(paren
id|dirs
comma
l_char|&squot;/&squot;
)paren
)paren
)paren
suffix:semicolon
id|free
c_func
(paren
id|dirs
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Frees memory within dir which was allocated for exclude lists and&n; * the exclude_stack.  Does not free dir itself.&n; */
DECL|function|clear_directory
r_void
id|clear_directory
c_func
(paren
r_struct
id|dir_struct
op_star
id|dir
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_struct
id|exclude_list_group
op_star
id|group
suffix:semicolon
r_struct
id|exclude_list
op_star
id|el
suffix:semicolon
r_struct
id|exclude_stack
op_star
id|stk
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|EXC_CMDL
suffix:semicolon
id|i
op_le
id|EXC_FILE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|group
op_assign
op_amp
id|dir-&gt;exclude_list_group
(braket
id|i
)braket
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|group-&gt;nr
suffix:semicolon
id|j
op_increment
)paren
(brace
id|el
op_assign
op_amp
id|group-&gt;el
(braket
id|j
)braket
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|EXC_DIRS
)paren
id|free
c_func
(paren
(paren
r_char
op_star
)paren
id|el-&gt;src
)paren
suffix:semicolon
id|clear_exclude_list
c_func
(paren
id|el
)paren
suffix:semicolon
)brace
id|free
c_func
(paren
id|group-&gt;el
)paren
suffix:semicolon
)brace
id|stk
op_assign
id|dir-&gt;exclude_stack
suffix:semicolon
r_while
c_loop
(paren
id|stk
)paren
(brace
r_struct
id|exclude_stack
op_star
id|prev
op_assign
id|stk-&gt;prev
suffix:semicolon
id|free
c_func
(paren
id|stk
)paren
suffix:semicolon
id|stk
op_assign
id|prev
suffix:semicolon
)brace
)brace
eof
