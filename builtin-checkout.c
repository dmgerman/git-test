macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;builtin.h&quot;
macro_line|#include &quot;parse-options.h&quot;
macro_line|#include &quot;refs.h&quot;
macro_line|#include &quot;commit.h&quot;
macro_line|#include &quot;tree.h&quot;
macro_line|#include &quot;tree-walk.h&quot;
macro_line|#include &quot;cache-tree.h&quot;
macro_line|#include &quot;unpack-trees.h&quot;
macro_line|#include &quot;dir.h&quot;
macro_line|#include &quot;run-command.h&quot;
macro_line|#include &quot;merge-recursive.h&quot;
macro_line|#include &quot;branch.h&quot;
macro_line|#include &quot;diff.h&quot;
macro_line|#include &quot;revision.h&quot;
macro_line|#include &quot;remote.h&quot;
macro_line|#include &quot;blob.h&quot;
macro_line|#include &quot;xdiff-interface.h&quot;
macro_line|#include &quot;ll-merge.h&quot;
DECL|variable|checkout_usage
r_static
r_const
r_char
op_star
r_const
id|checkout_usage
(braket
)braket
op_assign
(brace
l_string|&quot;git checkout [options] &lt;branch&gt;&quot;
comma
l_string|&quot;git checkout [options] [&lt;branch&gt;] -- &lt;file&gt;...&quot;
comma
l_int|NULL
comma
)brace
suffix:semicolon
DECL|struct|checkout_opts
r_struct
id|checkout_opts
(brace
DECL|member|quiet
r_int
id|quiet
suffix:semicolon
DECL|member|merge
r_int
id|merge
suffix:semicolon
DECL|member|force
r_int
id|force
suffix:semicolon
DECL|member|writeout_stage
r_int
id|writeout_stage
suffix:semicolon
DECL|member|writeout_error
r_int
id|writeout_error
suffix:semicolon
DECL|member|new_branch
r_const
r_char
op_star
id|new_branch
suffix:semicolon
DECL|member|new_branch_log
r_int
id|new_branch_log
suffix:semicolon
DECL|member|track
r_enum
id|branch_track
id|track
suffix:semicolon
)brace
suffix:semicolon
DECL|function|post_checkout_hook
r_static
r_int
id|post_checkout_hook
c_func
(paren
r_struct
id|commit
op_star
id|old
comma
r_struct
id|commit
op_star
r_new
comma
r_int
id|changed
)paren
(brace
r_return
id|run_hook
c_func
(paren
l_int|NULL
comma
l_string|&quot;post-checkout&quot;
comma
id|sha1_to_hex
c_func
(paren
id|old
ques
c_cond
id|old-&gt;object.sha1
suffix:colon
id|null_sha1
)paren
comma
id|sha1_to_hex
c_func
(paren
r_new
ques
c_cond
r_new
op_member_access_from_pointer
id|object.sha1
suffix:colon
id|null_sha1
)paren
comma
id|changed
ques
c_cond
l_string|&quot;1&quot;
suffix:colon
l_string|&quot;0&quot;
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* &quot;new&quot; can be NULL when checking out from the index before&n;&t;   a commit exists. */
)brace
DECL|function|update_some
r_static
r_int
id|update_some
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
comma
r_const
r_char
op_star
id|base
comma
r_int
id|baselen
comma
r_const
r_char
op_star
id|pathname
comma
r_int
id|mode
comma
r_int
id|stage
comma
r_void
op_star
id|context
)paren
(brace
r_int
id|len
suffix:semicolon
r_struct
id|cache_entry
op_star
id|ce
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|mode
)paren
)paren
r_return
id|READ_TREE_RECURSIVE
suffix:semicolon
id|len
op_assign
id|baselen
op_plus
id|strlen
c_func
(paren
id|pathname
)paren
suffix:semicolon
id|ce
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
id|cache_entry_size
c_func
(paren
id|len
)paren
)paren
suffix:semicolon
id|hashcpy
c_func
(paren
id|ce-&gt;sha1
comma
id|sha1
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ce-&gt;name
comma
id|base
comma
id|baselen
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ce-&gt;name
op_plus
id|baselen
comma
id|pathname
comma
id|len
id|baselen
)paren
suffix:semicolon
id|ce-&gt;ce_flags
op_assign
id|create_ce_flags
c_func
(paren
id|len
comma
l_int|0
)paren
suffix:semicolon
id|ce-&gt;ce_mode
op_assign
id|create_ce_mode
c_func
(paren
id|mode
)paren
suffix:semicolon
id|add_cache_entry
c_func
(paren
id|ce
comma
id|ADD_CACHE_OK_TO_ADD
op_or
id|ADD_CACHE_OK_TO_REPLACE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|read_tree_some
r_static
r_int
id|read_tree_some
c_func
(paren
r_struct
id|tree
op_star
id|tree
comma
r_const
r_char
op_star
op_star
id|pathspec
)paren
(brace
id|read_tree_recursive
c_func
(paren
id|tree
comma
l_string|&quot;&quot;
comma
l_int|0
comma
l_int|0
comma
id|pathspec
comma
id|update_some
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* update the index with the given tree&squot;s info&n;&t; * for all args, expanding wildcards, and exit&n;&t; * with any non-zero return code.&n;&t; */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|skip_same_name
r_static
r_int
id|skip_same_name
c_func
(paren
r_struct
id|cache_entry
op_star
id|ce
comma
r_int
id|pos
)paren
(brace
r_while
c_loop
(paren
op_increment
id|pos
OL
id|active_nr
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|active_cache
(braket
id|pos
)braket
op_member_access_from_pointer
id|name
comma
id|ce-&gt;name
)paren
)paren
suffix:semicolon
multiline_comment|/* skip */
r_return
id|pos
suffix:semicolon
)brace
DECL|function|check_stage
r_static
r_int
id|check_stage
c_func
(paren
r_int
id|stage
comma
r_struct
id|cache_entry
op_star
id|ce
comma
r_int
id|pos
)paren
(brace
r_while
c_loop
(paren
id|pos
OL
id|active_nr
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|active_cache
(braket
id|pos
)braket
op_member_access_from_pointer
id|name
comma
id|ce-&gt;name
)paren
)paren
(brace
r_if
c_cond
(paren
id|ce_stage
c_func
(paren
id|active_cache
(braket
id|pos
)braket
)paren
op_eq
id|stage
)paren
r_return
l_int|0
suffix:semicolon
id|pos
op_increment
suffix:semicolon
)brace
r_return
id|error
c_func
(paren
l_string|&quot;path &squot;%s&squot; does not have %s version&quot;
comma
id|ce-&gt;name
comma
(paren
id|stage
op_eq
l_int|2
)paren
ques
c_cond
l_string|&quot;our&quot;
suffix:colon
l_string|&quot;their&quot;
)paren
suffix:semicolon
)brace
DECL|function|check_all_stages
r_static
r_int
id|check_all_stages
c_func
(paren
r_struct
id|cache_entry
op_star
id|ce
comma
r_int
id|pos
)paren
(brace
r_if
c_cond
(paren
id|ce_stage
c_func
(paren
id|ce
)paren
op_ne
l_int|1
op_logical_or
id|active_nr
op_le
id|pos
op_plus
l_int|2
op_logical_or
id|strcmp
c_func
(paren
id|active_cache
(braket
id|pos
op_plus
l_int|1
)braket
op_member_access_from_pointer
id|name
comma
id|ce-&gt;name
)paren
op_logical_or
id|ce_stage
c_func
(paren
id|active_cache
(braket
id|pos
op_plus
l_int|1
)braket
)paren
op_ne
l_int|2
op_logical_or
id|strcmp
c_func
(paren
id|active_cache
(braket
id|pos
op_plus
l_int|2
)braket
op_member_access_from_pointer
id|name
comma
id|ce-&gt;name
)paren
op_logical_or
id|ce_stage
c_func
(paren
id|active_cache
(braket
id|pos
op_plus
l_int|2
)braket
)paren
op_ne
l_int|3
)paren
r_return
id|error
c_func
(paren
l_string|&quot;path &squot;%s&squot; does not have all three versions&quot;
comma
id|ce-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|checkout_stage
r_static
r_int
id|checkout_stage
c_func
(paren
r_int
id|stage
comma
r_struct
id|cache_entry
op_star
id|ce
comma
r_int
id|pos
comma
r_struct
id|checkout
op_star
id|state
)paren
(brace
r_while
c_loop
(paren
id|pos
OL
id|active_nr
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|active_cache
(braket
id|pos
)braket
op_member_access_from_pointer
id|name
comma
id|ce-&gt;name
)paren
)paren
(brace
r_if
c_cond
(paren
id|ce_stage
c_func
(paren
id|active_cache
(braket
id|pos
)braket
)paren
op_eq
id|stage
)paren
r_return
id|checkout_entry
c_func
(paren
id|active_cache
(braket
id|pos
)braket
comma
id|state
comma
l_int|NULL
)paren
suffix:semicolon
id|pos
op_increment
suffix:semicolon
)brace
r_return
id|error
c_func
(paren
l_string|&quot;path &squot;%s&squot; does not have %s version&quot;
comma
id|ce-&gt;name
comma
(paren
id|stage
op_eq
l_int|2
)paren
ques
c_cond
l_string|&quot;our&quot;
suffix:colon
l_string|&quot;their&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* NEEDSWORK: share with merge-recursive */
DECL|function|fill_mm
r_static
r_void
id|fill_mm
c_func
(paren
r_const
r_int
r_char
op_star
id|sha1
comma
id|mmfile_t
op_star
id|mm
)paren
(brace
r_int
r_int
id|size
suffix:semicolon
r_enum
id|object_type
id|type
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hashcmp
c_func
(paren
id|sha1
comma
id|null_sha1
)paren
)paren
(brace
id|mm-&gt;ptr
op_assign
id|xstrdup
c_func
(paren
l_string|&quot;&quot;
)paren
suffix:semicolon
id|mm-&gt;size
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
id|mm-&gt;ptr
op_assign
id|read_sha1_file
c_func
(paren
id|sha1
comma
op_amp
id|type
comma
op_amp
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mm-&gt;ptr
op_logical_or
id|type
op_ne
id|OBJ_BLOB
)paren
id|die
c_func
(paren
l_string|&quot;unable to read blob object %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|sha1
)paren
)paren
suffix:semicolon
id|mm-&gt;size
op_assign
id|size
suffix:semicolon
)brace
DECL|function|checkout_merged
r_static
r_int
id|checkout_merged
c_func
(paren
r_int
id|pos
comma
r_struct
id|checkout
op_star
id|state
)paren
(brace
r_struct
id|cache_entry
op_star
id|ce
op_assign
id|active_cache
(braket
id|pos
)braket
suffix:semicolon
r_const
r_char
op_star
id|path
op_assign
id|ce-&gt;name
suffix:semicolon
id|mmfile_t
id|ancestor
comma
id|ours
comma
id|theirs
suffix:semicolon
r_int
id|status
suffix:semicolon
r_int
r_char
id|sha1
(braket
l_int|20
)braket
suffix:semicolon
id|mmbuffer_t
id|result_buf
suffix:semicolon
r_if
c_cond
(paren
id|ce_stage
c_func
(paren
id|ce
)paren
op_ne
l_int|1
op_logical_or
id|active_nr
op_le
id|pos
op_plus
l_int|2
op_logical_or
id|strcmp
c_func
(paren
id|active_cache
(braket
id|pos
op_plus
l_int|1
)braket
op_member_access_from_pointer
id|name
comma
id|path
)paren
op_logical_or
id|ce_stage
c_func
(paren
id|active_cache
(braket
id|pos
op_plus
l_int|1
)braket
)paren
op_ne
l_int|2
op_logical_or
id|strcmp
c_func
(paren
id|active_cache
(braket
id|pos
op_plus
l_int|2
)braket
op_member_access_from_pointer
id|name
comma
id|path
)paren
op_logical_or
id|ce_stage
c_func
(paren
id|active_cache
(braket
id|pos
op_plus
l_int|2
)braket
)paren
op_ne
l_int|3
)paren
r_return
id|error
c_func
(paren
l_string|&quot;path &squot;%s&squot; does not have all 3 versions&quot;
comma
id|path
)paren
suffix:semicolon
id|fill_mm
c_func
(paren
id|active_cache
(braket
id|pos
)braket
op_member_access_from_pointer
id|sha1
comma
op_amp
id|ancestor
)paren
suffix:semicolon
id|fill_mm
c_func
(paren
id|active_cache
(braket
id|pos
op_plus
l_int|1
)braket
op_member_access_from_pointer
id|sha1
comma
op_amp
id|ours
)paren
suffix:semicolon
id|fill_mm
c_func
(paren
id|active_cache
(braket
id|pos
op_plus
l_int|2
)braket
op_member_access_from_pointer
id|sha1
comma
op_amp
id|theirs
)paren
suffix:semicolon
id|status
op_assign
id|ll_merge
c_func
(paren
op_amp
id|result_buf
comma
id|path
comma
op_amp
id|ancestor
comma
op_amp
id|ours
comma
l_string|&quot;ours&quot;
comma
op_amp
id|theirs
comma
l_string|&quot;theirs&quot;
comma
l_int|1
)paren
suffix:semicolon
id|free
c_func
(paren
id|ancestor.ptr
)paren
suffix:semicolon
id|free
c_func
(paren
id|ours.ptr
)paren
suffix:semicolon
id|free
c_func
(paren
id|theirs.ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
op_logical_or
op_logical_neg
id|result_buf.ptr
)paren
(brace
id|free
c_func
(paren
id|result_buf.ptr
)paren
suffix:semicolon
r_return
id|error
c_func
(paren
l_string|&quot;path &squot;%s&squot;: cannot merge&quot;
comma
id|path
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * NEEDSWORK:&n;&t; * There is absolutely no reason to write this as a blob object&n;&t; * and create a phony cache entry just to leak.  This hack is&n;&t; * primarily to get to the write_entry() machinery that massages&n;&t; * the contents to work-tree format and writes out which only&n;&t; * allows it for a cache entry.  The code in write_entry() needs&n;&t; * to be refactored to allow us to feed a &lt;buffer, size, mode&gt;&n;&t; * instead of a cache entry.  Such a refactoring would help&n;&t; * merge_recursive as well (it also writes the merge result to the&n;&t; * object database even when it may contain conflicts).&n;&t; */
r_if
c_cond
(paren
id|write_sha1_file
c_func
(paren
id|result_buf.ptr
comma
id|result_buf.size
comma
id|blob_type
comma
id|sha1
)paren
)paren
id|die
c_func
(paren
l_string|&quot;Unable to add merge result for &squot;%s&squot;&quot;
comma
id|path
)paren
suffix:semicolon
id|ce
op_assign
id|make_cache_entry
c_func
(paren
id|create_ce_mode
c_func
(paren
id|active_cache
(braket
id|pos
op_plus
l_int|1
)braket
op_member_access_from_pointer
id|ce_mode
)paren
comma
id|sha1
comma
id|path
comma
l_int|2
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ce
)paren
id|die
c_func
(paren
l_string|&quot;make_cache_entry failed for path &squot;%s&squot;&quot;
comma
id|path
)paren
suffix:semicolon
id|status
op_assign
id|checkout_entry
c_func
(paren
id|ce
comma
id|state
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
DECL|function|checkout_paths
r_static
r_int
id|checkout_paths
c_func
(paren
r_struct
id|tree
op_star
id|source_tree
comma
r_const
r_char
op_star
op_star
id|pathspec
comma
r_struct
id|checkout_opts
op_star
id|opts
)paren
(brace
r_int
id|pos
suffix:semicolon
r_struct
id|checkout
id|state
suffix:semicolon
r_static
r_char
op_star
id|ps_matched
suffix:semicolon
r_int
r_char
id|rev
(braket
l_int|20
)braket
suffix:semicolon
r_int
id|flag
suffix:semicolon
r_struct
id|commit
op_star
id|head
suffix:semicolon
r_int
id|errs
op_assign
l_int|0
suffix:semicolon
r_int
id|stage
op_assign
id|opts-&gt;writeout_stage
suffix:semicolon
r_int
id|merge
op_assign
id|opts-&gt;merge
suffix:semicolon
r_int
id|newfd
suffix:semicolon
r_struct
id|lock_file
op_star
id|lock_file
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|lock_file
)paren
)paren
suffix:semicolon
id|newfd
op_assign
id|hold_locked_index
c_func
(paren
id|lock_file
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_cache_preload
c_func
(paren
id|pathspec
)paren
OL
l_int|0
)paren
r_return
id|error
c_func
(paren
l_string|&quot;corrupt index file&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|source_tree
)paren
id|read_tree_some
c_func
(paren
id|source_tree
comma
id|pathspec
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pos
op_assign
l_int|0
suffix:semicolon
id|pathspec
(braket
id|pos
)braket
suffix:semicolon
id|pos
op_increment
)paren
suffix:semicolon
id|ps_matched
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
id|pos
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pos
op_assign
l_int|0
suffix:semicolon
id|pos
OL
id|active_nr
suffix:semicolon
id|pos
op_increment
)paren
(brace
r_struct
id|cache_entry
op_star
id|ce
op_assign
id|active_cache
(braket
id|pos
)braket
suffix:semicolon
id|match_pathspec
c_func
(paren
id|pathspec
comma
id|ce-&gt;name
comma
id|ce_namelen
c_func
(paren
id|ce
)paren
comma
l_int|0
comma
id|ps_matched
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|report_path_error
c_func
(paren
id|ps_matched
comma
id|pathspec
comma
l_int|0
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Any unmerged paths? */
r_for
c_loop
(paren
id|pos
op_assign
l_int|0
suffix:semicolon
id|pos
OL
id|active_nr
suffix:semicolon
id|pos
op_increment
)paren
(brace
r_struct
id|cache_entry
op_star
id|ce
op_assign
id|active_cache
(braket
id|pos
)braket
suffix:semicolon
r_if
c_cond
(paren
id|match_pathspec
c_func
(paren
id|pathspec
comma
id|ce-&gt;name
comma
id|ce_namelen
c_func
(paren
id|ce
)paren
comma
l_int|0
comma
l_int|NULL
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ce_stage
c_func
(paren
id|ce
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|opts-&gt;force
)paren
(brace
id|warning
c_func
(paren
l_string|&quot;path &squot;%s&squot; is unmerged&quot;
comma
id|ce-&gt;name
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|stage
)paren
(brace
id|errs
op_or_assign
id|check_stage
c_func
(paren
id|stage
comma
id|ce
comma
id|pos
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|opts-&gt;merge
)paren
(brace
id|errs
op_or_assign
id|check_all_stages
c_func
(paren
id|ce
comma
id|pos
)paren
suffix:semicolon
)brace
r_else
(brace
id|errs
op_assign
l_int|1
suffix:semicolon
id|error
c_func
(paren
l_string|&quot;path &squot;%s&squot; is unmerged&quot;
comma
id|ce-&gt;name
)paren
suffix:semicolon
)brace
id|pos
op_assign
id|skip_same_name
c_func
(paren
id|ce
comma
id|pos
)paren
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|errs
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Now we are committed to check them out */
id|memset
c_func
(paren
op_amp
id|state
comma
l_int|0
comma
r_sizeof
(paren
id|state
)paren
)paren
suffix:semicolon
id|state.force
op_assign
l_int|1
suffix:semicolon
id|state.refresh_cache
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|pos
op_assign
l_int|0
suffix:semicolon
id|pos
OL
id|active_nr
suffix:semicolon
id|pos
op_increment
)paren
(brace
r_struct
id|cache_entry
op_star
id|ce
op_assign
id|active_cache
(braket
id|pos
)braket
suffix:semicolon
r_if
c_cond
(paren
id|match_pathspec
c_func
(paren
id|pathspec
comma
id|ce-&gt;name
comma
id|ce_namelen
c_func
(paren
id|ce
)paren
comma
l_int|0
comma
l_int|NULL
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ce_stage
c_func
(paren
id|ce
)paren
)paren
(brace
id|errs
op_or_assign
id|checkout_entry
c_func
(paren
id|ce
comma
op_amp
id|state
comma
l_int|NULL
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stage
)paren
id|errs
op_or_assign
id|checkout_stage
c_func
(paren
id|stage
comma
id|ce
comma
id|pos
comma
op_amp
id|state
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|merge
)paren
id|errs
op_or_assign
id|checkout_merged
c_func
(paren
id|pos
comma
op_amp
id|state
)paren
suffix:semicolon
id|pos
op_assign
id|skip_same_name
c_func
(paren
id|ce
comma
id|pos
)paren
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|write_cache
c_func
(paren
id|newfd
comma
id|active_cache
comma
id|active_nr
)paren
op_logical_or
id|commit_locked_index
c_func
(paren
id|lock_file
)paren
)paren
id|die
c_func
(paren
l_string|&quot;unable to write new index file&quot;
)paren
suffix:semicolon
id|resolve_ref
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|rev
comma
l_int|0
comma
op_amp
id|flag
)paren
suffix:semicolon
id|head
op_assign
id|lookup_commit_reference_gently
c_func
(paren
id|rev
comma
l_int|1
)paren
suffix:semicolon
id|errs
op_or_assign
id|post_checkout_hook
c_func
(paren
id|head
comma
id|head
comma
l_int|0
)paren
suffix:semicolon
r_return
id|errs
suffix:semicolon
)brace
DECL|function|show_local_changes
r_static
r_void
id|show_local_changes
c_func
(paren
r_struct
id|object
op_star
id|head
)paren
(brace
r_struct
id|rev_info
id|rev
suffix:semicolon
multiline_comment|/* I think we want full paths, even if we&squot;re in a subdirectory. */
id|init_revisions
c_func
(paren
op_amp
id|rev
comma
l_int|NULL
)paren
suffix:semicolon
id|rev.abbrev
op_assign
l_int|0
suffix:semicolon
id|rev.diffopt.output_format
op_or_assign
id|DIFF_FORMAT_NAME_STATUS
suffix:semicolon
r_if
c_cond
(paren
id|diff_setup_done
c_func
(paren
op_amp
id|rev.diffopt
)paren
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;diff_setup_done failed&quot;
)paren
suffix:semicolon
id|add_pending_object
c_func
(paren
op_amp
id|rev
comma
id|head
comma
l_int|NULL
)paren
suffix:semicolon
id|run_diff_index
c_func
(paren
op_amp
id|rev
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|describe_detached_head
r_static
r_void
id|describe_detached_head
c_func
(paren
r_char
op_star
id|msg
comma
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
r_struct
id|pretty_print_context
id|ctx
op_assign
(brace
l_int|0
)brace
suffix:semicolon
id|parse_commit
c_func
(paren
id|commit
)paren
suffix:semicolon
id|pretty_print_commit
c_func
(paren
id|CMIT_FMT_ONELINE
comma
id|commit
comma
op_amp
id|sb
comma
op_amp
id|ctx
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s %s... %s&bslash;n&quot;
comma
id|msg
comma
id|find_unique_abbrev
c_func
(paren
id|commit-&gt;object.sha1
comma
id|DEFAULT_ABBREV
)paren
comma
id|sb.buf
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
)brace
DECL|function|reset_tree
r_static
r_int
id|reset_tree
c_func
(paren
r_struct
id|tree
op_star
id|tree
comma
r_struct
id|checkout_opts
op_star
id|o
comma
r_int
id|worktree
)paren
(brace
r_struct
id|unpack_trees_options
id|opts
suffix:semicolon
r_struct
id|tree_desc
id|tree_desc
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|opts
comma
l_int|0
comma
r_sizeof
(paren
id|opts
)paren
)paren
suffix:semicolon
id|opts.head_idx
op_assign
l_int|1
suffix:semicolon
id|opts.update
op_assign
id|worktree
suffix:semicolon
id|opts.skip_unmerged
op_assign
op_logical_neg
id|worktree
suffix:semicolon
id|opts.reset
op_assign
l_int|1
suffix:semicolon
id|opts.merge
op_assign
l_int|1
suffix:semicolon
id|opts.fn
op_assign
id|oneway_merge
suffix:semicolon
id|opts.verbose_update
op_assign
op_logical_neg
id|o-&gt;quiet
suffix:semicolon
id|opts.src_index
op_assign
op_amp
id|the_index
suffix:semicolon
id|opts.dst_index
op_assign
op_amp
id|the_index
suffix:semicolon
id|parse_tree
c_func
(paren
id|tree
)paren
suffix:semicolon
id|init_tree_desc
c_func
(paren
op_amp
id|tree_desc
comma
id|tree-&gt;buffer
comma
id|tree-&gt;size
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|unpack_trees
c_func
(paren
l_int|1
comma
op_amp
id|tree_desc
comma
op_amp
id|opts
)paren
)paren
(brace
r_case
l_int|2
suffix:colon
id|o-&gt;writeout_error
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We return 0 nevertheless, as the index is all right&n;&t;&t; * and more importantly we have made best efforts to&n;&t;&t; * update paths in the work tree, and we cannot revert&n;&t;&t; * them.&n;&t;&t; */
r_case
l_int|0
suffix:colon
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
r_return
l_int|128
suffix:semicolon
)brace
)brace
DECL|struct|branch_info
r_struct
id|branch_info
(brace
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
multiline_comment|/* The short name used */
DECL|member|path
r_const
r_char
op_star
id|path
suffix:semicolon
multiline_comment|/* The full name of a real branch */
DECL|member|commit
r_struct
id|commit
op_star
id|commit
suffix:semicolon
multiline_comment|/* The named commit */
)brace
suffix:semicolon
DECL|function|setup_branch_path
r_static
r_void
id|setup_branch_path
c_func
(paren
r_struct
id|branch_info
op_star
id|branch
)paren
(brace
r_struct
id|strbuf
id|buf
op_assign
id|STRBUF_INIT
suffix:semicolon
id|strbuf_branchname
c_func
(paren
op_amp
id|buf
comma
id|branch-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|buf.buf
comma
id|branch-&gt;name
)paren
)paren
id|branch-&gt;name
op_assign
id|xstrdup
c_func
(paren
id|buf.buf
)paren
suffix:semicolon
id|strbuf_splice
c_func
(paren
op_amp
id|buf
comma
l_int|0
comma
l_int|0
comma
l_string|&quot;refs/heads/&quot;
comma
l_int|11
)paren
suffix:semicolon
id|branch-&gt;path
op_assign
id|strbuf_detach
c_func
(paren
op_amp
id|buf
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|merge_working_tree
r_static
r_int
id|merge_working_tree
c_func
(paren
r_struct
id|checkout_opts
op_star
id|opts
comma
r_struct
id|branch_info
op_star
id|old
comma
r_struct
id|branch_info
op_star
r_new
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|lock_file
op_star
id|lock_file
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|lock_file
)paren
)paren
suffix:semicolon
r_int
id|newfd
op_assign
id|hold_locked_index
c_func
(paren
id|lock_file
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_cache_preload
c_func
(paren
l_int|NULL
)paren
OL
l_int|0
)paren
r_return
id|error
c_func
(paren
l_string|&quot;corrupt index file&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opts-&gt;force
)paren
(brace
id|ret
op_assign
id|reset_tree
c_func
(paren
r_new
op_member_access_from_pointer
id|commit-&gt;tree
comma
id|opts
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
)brace
r_else
(brace
r_struct
id|tree_desc
id|trees
(braket
l_int|2
)braket
suffix:semicolon
r_struct
id|tree
op_star
id|tree
suffix:semicolon
r_struct
id|unpack_trees_options
id|topts
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|topts
comma
l_int|0
comma
r_sizeof
(paren
id|topts
)paren
)paren
suffix:semicolon
id|topts.head_idx
op_assign
l_int|1
suffix:semicolon
id|topts.src_index
op_assign
op_amp
id|the_index
suffix:semicolon
id|topts.dst_index
op_assign
op_amp
id|the_index
suffix:semicolon
id|topts.msgs.not_uptodate_file
op_assign
l_string|&quot;You have local changes to &squot;%s&squot;; cannot switch branches.&quot;
suffix:semicolon
id|refresh_cache
c_func
(paren
id|REFRESH_QUIET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unmerged_cache
c_func
(paren
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;you need to resolve your current index first&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* 2-way merge to the new branch */
id|topts.initial_checkout
op_assign
id|is_cache_unborn
c_func
(paren
)paren
suffix:semicolon
id|topts.update
op_assign
l_int|1
suffix:semicolon
id|topts.merge
op_assign
l_int|1
suffix:semicolon
id|topts.gently
op_assign
id|opts-&gt;merge
op_logical_and
id|old-&gt;commit
suffix:semicolon
id|topts.verbose_update
op_assign
op_logical_neg
id|opts-&gt;quiet
suffix:semicolon
id|topts.fn
op_assign
id|twoway_merge
suffix:semicolon
id|topts.dir
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|topts.dir
)paren
)paren
suffix:semicolon
id|topts.dir-&gt;flags
op_or_assign
id|DIR_SHOW_IGNORED
suffix:semicolon
id|topts.dir-&gt;exclude_per_dir
op_assign
l_string|&quot;.gitignore&quot;
suffix:semicolon
id|tree
op_assign
id|parse_tree_indirect
c_func
(paren
id|old-&gt;commit
ques
c_cond
id|old-&gt;commit-&gt;object.sha1
suffix:colon
(paren
r_int
r_char
op_star
)paren
id|EMPTY_TREE_SHA1_BIN
)paren
suffix:semicolon
id|init_tree_desc
c_func
(paren
op_amp
id|trees
(braket
l_int|0
)braket
comma
id|tree-&gt;buffer
comma
id|tree-&gt;size
)paren
suffix:semicolon
id|tree
op_assign
id|parse_tree_indirect
c_func
(paren
r_new
op_member_access_from_pointer
id|commit-&gt;object.sha1
)paren
suffix:semicolon
id|init_tree_desc
c_func
(paren
op_amp
id|trees
(braket
l_int|1
)braket
comma
id|tree-&gt;buffer
comma
id|tree-&gt;size
)paren
suffix:semicolon
id|ret
op_assign
id|unpack_trees
c_func
(paren
l_int|2
comma
id|trees
comma
op_amp
id|topts
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Unpack couldn&squot;t do a trivial merge; either&n;&t;&t;&t; * give up or do a real merge, depending on&n;&t;&t;&t; * whether the merge flag was used.&n;&t;&t;&t; */
r_struct
id|tree
op_star
id|result
suffix:semicolon
r_struct
id|tree
op_star
id|work
suffix:semicolon
r_struct
id|merge_options
id|o
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|opts-&gt;merge
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Without old-&gt;commit, the below is the same as&n;&t;&t;&t; * the two-tree unpack we already tried and failed.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|old-&gt;commit
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Do more real merge */
multiline_comment|/*&n;&t;&t;&t; * We update the index fully, then write the&n;&t;&t;&t; * tree from the index, then merge the new&n;&t;&t;&t; * branch with the current tree, with the old&n;&t;&t;&t; * branch as the base. Then we reset the index&n;&t;&t;&t; * (but not the working tree) to the new&n;&t;&t;&t; * branch, leaving the working tree as the&n;&t;&t;&t; * merged version, but skipping unmerged&n;&t;&t;&t; * entries in the index.&n;&t;&t;&t; */
id|add_files_to_cache
c_func
(paren
l_int|NULL
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|init_merge_options
c_func
(paren
op_amp
id|o
)paren
suffix:semicolon
id|o.verbosity
op_assign
l_int|0
suffix:semicolon
id|work
op_assign
id|write_tree_from_memory
c_func
(paren
op_amp
id|o
)paren
suffix:semicolon
id|ret
op_assign
id|reset_tree
c_func
(paren
r_new
op_member_access_from_pointer
id|commit-&gt;tree
comma
id|opts
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
id|o.branch1
op_assign
r_new
op_member_access_from_pointer
id|name
suffix:semicolon
id|o.branch2
op_assign
l_string|&quot;local&quot;
suffix:semicolon
id|merge_trees
c_func
(paren
op_amp
id|o
comma
r_new
op_member_access_from_pointer
id|commit-&gt;tree
comma
id|work
comma
id|old-&gt;commit-&gt;tree
comma
op_amp
id|result
)paren
suffix:semicolon
id|ret
op_assign
id|reset_tree
c_func
(paren
r_new
op_member_access_from_pointer
id|commit-&gt;tree
comma
id|opts
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|write_cache
c_func
(paren
id|newfd
comma
id|active_cache
comma
id|active_nr
)paren
op_logical_or
id|commit_locked_index
c_func
(paren
id|lock_file
)paren
)paren
id|die
c_func
(paren
l_string|&quot;unable to write new index file&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|opts-&gt;force
op_logical_and
op_logical_neg
id|opts-&gt;quiet
)paren
id|show_local_changes
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|commit-&gt;object
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|report_tracking
r_static
r_void
id|report_tracking
c_func
(paren
r_struct
id|branch_info
op_star
r_new
)paren
(brace
r_struct
id|strbuf
id|sb
op_assign
id|STRBUF_INIT
suffix:semicolon
r_struct
id|branch
op_star
id|branch
op_assign
id|branch_get
c_func
(paren
r_new
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|format_tracking_info
c_func
(paren
id|branch
comma
op_amp
id|sb
)paren
)paren
r_return
suffix:semicolon
id|fputs
c_func
(paren
id|sb.buf
comma
id|stdout
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|sb
)paren
suffix:semicolon
)brace
DECL|function|update_refs_for_switch
r_static
r_void
id|update_refs_for_switch
c_func
(paren
r_struct
id|checkout_opts
op_star
id|opts
comma
r_struct
id|branch_info
op_star
id|old
comma
r_struct
id|branch_info
op_star
r_new
)paren
(brace
r_struct
id|strbuf
id|msg
op_assign
id|STRBUF_INIT
suffix:semicolon
r_const
r_char
op_star
id|old_desc
suffix:semicolon
r_if
c_cond
(paren
id|opts-&gt;new_branch
)paren
(brace
id|create_branch
c_func
(paren
id|old-&gt;name
comma
id|opts-&gt;new_branch
comma
r_new
op_member_access_from_pointer
id|name
comma
l_int|0
comma
id|opts-&gt;new_branch_log
comma
id|opts-&gt;track
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|name
op_assign
id|opts-&gt;new_branch
suffix:semicolon
id|setup_branch_path
c_func
(paren
r_new
)paren
suffix:semicolon
)brace
id|old_desc
op_assign
id|old-&gt;name
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|old_desc
op_logical_and
id|old-&gt;commit
)paren
id|old_desc
op_assign
id|sha1_to_hex
c_func
(paren
id|old-&gt;commit-&gt;object.sha1
)paren
suffix:semicolon
id|strbuf_addf
c_func
(paren
op_amp
id|msg
comma
l_string|&quot;checkout: moving from %s to %s&quot;
comma
id|old_desc
ques
c_cond
id|old_desc
suffix:colon
l_string|&quot;(invalid)&quot;
comma
r_new
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
r_new
op_member_access_from_pointer
id|path
)paren
(brace
id|create_symref
c_func
(paren
l_string|&quot;HEAD&quot;
comma
r_new
op_member_access_from_pointer
id|path
comma
id|msg.buf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|opts-&gt;quiet
)paren
(brace
r_if
c_cond
(paren
id|old-&gt;path
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
r_new
op_member_access_from_pointer
id|path
comma
id|old-&gt;path
)paren
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Already on &squot;%s&squot;&bslash;n&quot;
comma
r_new
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
r_else
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Switched to%s branch &squot;%s&squot;&bslash;n&quot;
comma
id|opts-&gt;new_branch
ques
c_cond
l_string|&quot; a new&quot;
suffix:colon
l_string|&quot;&quot;
comma
r_new
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
r_new
op_member_access_from_pointer
id|name
comma
l_string|&quot;HEAD&quot;
)paren
)paren
(brace
id|update_ref
c_func
(paren
id|msg.buf
comma
l_string|&quot;HEAD&quot;
comma
r_new
op_member_access_from_pointer
id|commit-&gt;object.sha1
comma
l_int|NULL
comma
id|REF_NODEREF
comma
id|DIE_ON_ERR
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|opts-&gt;quiet
)paren
(brace
r_if
c_cond
(paren
id|old-&gt;path
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Note: moving to &squot;%s&squot; which isn&squot;t a local branch&bslash;nIf you want to create a new branch from this checkout, you may do so&bslash;n(now or later) by using -b with the checkout command again. Example:&bslash;n  git checkout -b &lt;new_branch_name&gt;&bslash;n&quot;
comma
r_new
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
id|describe_detached_head
c_func
(paren
l_string|&quot;HEAD is now at&quot;
comma
r_new
op_member_access_from_pointer
id|commit
)paren
suffix:semicolon
)brace
)brace
id|remove_branch_state
c_func
(paren
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|msg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|opts-&gt;quiet
op_logical_and
(paren
r_new
op_member_access_from_pointer
id|path
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
r_new
op_member_access_from_pointer
id|name
comma
l_string|&quot;HEAD&quot;
)paren
)paren
)paren
id|report_tracking
c_func
(paren
r_new
)paren
suffix:semicolon
)brace
DECL|function|switch_branches
r_static
r_int
id|switch_branches
c_func
(paren
r_struct
id|checkout_opts
op_star
id|opts
comma
r_struct
id|branch_info
op_star
r_new
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_struct
id|branch_info
id|old
suffix:semicolon
r_int
r_char
id|rev
(braket
l_int|20
)braket
suffix:semicolon
r_int
id|flag
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|old
comma
l_int|0
comma
r_sizeof
(paren
id|old
)paren
)paren
suffix:semicolon
id|old.path
op_assign
id|resolve_ref
c_func
(paren
l_string|&quot;HEAD&quot;
comma
id|rev
comma
l_int|0
comma
op_amp
id|flag
)paren
suffix:semicolon
id|old.commit
op_assign
id|lookup_commit_reference_gently
c_func
(paren
id|rev
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flag
op_amp
id|REF_ISSYMREF
)paren
)paren
id|old.path
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|old.path
op_logical_and
op_logical_neg
id|prefixcmp
c_func
(paren
id|old.path
comma
l_string|&quot;refs/heads/&quot;
)paren
)paren
id|old.name
op_assign
id|old.path
op_plus
id|strlen
c_func
(paren
l_string|&quot;refs/heads/&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
op_member_access_from_pointer
id|name
)paren
(brace
r_new
op_member_access_from_pointer
id|name
op_assign
l_string|&quot;HEAD&quot;
suffix:semicolon
r_new
op_member_access_from_pointer
id|commit
op_assign
id|old.commit
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
op_member_access_from_pointer
id|commit
)paren
id|die
c_func
(paren
l_string|&quot;You are on a branch yet to be born&quot;
)paren
suffix:semicolon
id|parse_commit
c_func
(paren
r_new
op_member_access_from_pointer
id|commit
)paren
suffix:semicolon
)brace
id|ret
op_assign
id|merge_working_tree
c_func
(paren
id|opts
comma
op_amp
id|old
comma
r_new
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
multiline_comment|/*&n;&t; * If we were on a detached HEAD, but have now moved to&n;&t; * a new commit, we want to mention the old commit once more&n;&t; * to remind the user that it might be lost.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|opts-&gt;quiet
op_logical_and
op_logical_neg
id|old.path
op_logical_and
id|old.commit
op_logical_and
r_new
op_member_access_from_pointer
id|commit
op_ne
id|old.commit
)paren
id|describe_detached_head
c_func
(paren
l_string|&quot;Previous HEAD position was&quot;
comma
id|old.commit
)paren
suffix:semicolon
id|update_refs_for_switch
c_func
(paren
id|opts
comma
op_amp
id|old
comma
r_new
)paren
suffix:semicolon
id|ret
op_assign
id|post_checkout_hook
c_func
(paren
id|old.commit
comma
r_new
op_member_access_from_pointer
id|commit
comma
l_int|1
)paren
suffix:semicolon
r_return
id|ret
op_logical_or
id|opts-&gt;writeout_error
suffix:semicolon
)brace
DECL|function|git_checkout_config
r_static
r_int
id|git_checkout_config
c_func
(paren
r_const
r_char
op_star
id|var
comma
r_const
r_char
op_star
id|value
comma
r_void
op_star
id|cb
)paren
(brace
r_return
id|git_xmerge_config
c_func
(paren
id|var
comma
id|value
comma
id|cb
)paren
suffix:semicolon
)brace
DECL|function|interactive_checkout
r_static
r_int
id|interactive_checkout
c_func
(paren
r_const
r_char
op_star
id|revision
comma
r_const
r_char
op_star
op_star
id|pathspec
comma
r_struct
id|checkout_opts
op_star
id|opts
)paren
(brace
r_return
id|run_add_interactive
c_func
(paren
id|revision
comma
l_string|&quot;--patch=checkout&quot;
comma
id|pathspec
)paren
suffix:semicolon
)brace
DECL|struct|tracking_name_data
r_struct
id|tracking_name_data
(brace
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
DECL|member|remote
r_char
op_star
id|remote
suffix:semicolon
DECL|member|unique
r_int
id|unique
suffix:semicolon
)brace
suffix:semicolon
DECL|function|check_tracking_name
r_static
r_int
id|check_tracking_name
c_func
(paren
r_const
r_char
op_star
id|refname
comma
r_const
r_int
r_char
op_star
id|sha1
comma
r_int
id|flags
comma
r_void
op_star
id|cb_data
)paren
(brace
r_struct
id|tracking_name_data
op_star
id|cb
op_assign
id|cb_data
suffix:semicolon
r_const
r_char
op_star
id|slash
suffix:semicolon
r_if
c_cond
(paren
id|prefixcmp
c_func
(paren
id|refname
comma
l_string|&quot;refs/remotes/&quot;
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|slash
op_assign
id|strchr
c_func
(paren
id|refname
op_plus
l_int|13
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|slash
op_logical_or
id|strcmp
c_func
(paren
id|slash
op_plus
l_int|1
comma
id|cb-&gt;name
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cb-&gt;remote
)paren
(brace
id|cb-&gt;unique
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|cb-&gt;remote
op_assign
id|xstrdup
c_func
(paren
id|refname
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|unique_tracking_name
r_static
r_const
r_char
op_star
id|unique_tracking_name
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|tracking_name_data
id|cb_data
op_assign
(brace
id|name
comma
l_int|NULL
comma
l_int|1
)brace
suffix:semicolon
id|for_each_ref
c_func
(paren
id|check_tracking_name
comma
op_amp
id|cb_data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cb_data.unique
)paren
r_return
id|cb_data.remote
suffix:semicolon
id|free
c_func
(paren
id|cb_data.remote
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|cmd_checkout
r_int
id|cmd_checkout
c_func
(paren
r_int
id|argc
comma
r_const
r_char
op_star
op_star
id|argv
comma
r_const
r_char
op_star
id|prefix
)paren
(brace
r_struct
id|checkout_opts
id|opts
suffix:semicolon
r_int
r_char
id|rev
(braket
l_int|20
)braket
suffix:semicolon
r_const
r_char
op_star
id|arg
suffix:semicolon
r_struct
id|branch_info
r_new
suffix:semicolon
r_struct
id|tree
op_star
id|source_tree
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
id|conflict_style
op_assign
l_int|NULL
suffix:semicolon
r_int
id|patch_mode
op_assign
l_int|0
suffix:semicolon
r_int
id|dwim_new_local_branch
op_assign
l_int|1
suffix:semicolon
r_struct
id|option
id|options
(braket
)braket
op_assign
(brace
id|OPT__QUIET
c_func
(paren
op_amp
id|opts.quiet
)paren
comma
id|OPT_STRING
c_func
(paren
l_char|&squot;b&squot;
comma
l_int|NULL
comma
op_amp
id|opts.new_branch
comma
l_string|&quot;new branch&quot;
comma
l_string|&quot;branch&quot;
)paren
comma
id|OPT_BOOLEAN
c_func
(paren
l_char|&squot;l&squot;
comma
l_int|NULL
comma
op_amp
id|opts.new_branch_log
comma
l_string|&quot;log for new branch&quot;
)paren
comma
id|OPT_SET_INT
c_func
(paren
l_char|&squot;t&squot;
comma
l_string|&quot;track&quot;
comma
op_amp
id|opts.track
comma
l_string|&quot;track&quot;
comma
id|BRANCH_TRACK_EXPLICIT
)paren
comma
id|OPT_SET_INT
c_func
(paren
l_char|&squot;2&squot;
comma
l_string|&quot;ours&quot;
comma
op_amp
id|opts.writeout_stage
comma
l_string|&quot;stage&quot;
comma
l_int|2
)paren
comma
id|OPT_SET_INT
c_func
(paren
l_char|&squot;3&squot;
comma
l_string|&quot;theirs&quot;
comma
op_amp
id|opts.writeout_stage
comma
l_string|&quot;stage&quot;
comma
l_int|3
)paren
comma
id|OPT_BOOLEAN
c_func
(paren
l_char|&squot;f&squot;
comma
l_string|&quot;force&quot;
comma
op_amp
id|opts.force
comma
l_string|&quot;force&quot;
)paren
comma
id|OPT_BOOLEAN
c_func
(paren
l_char|&squot;m&squot;
comma
l_string|&quot;merge&quot;
comma
op_amp
id|opts.merge
comma
l_string|&quot;merge&quot;
)paren
comma
id|OPT_STRING
c_func
(paren
l_int|0
comma
l_string|&quot;conflict&quot;
comma
op_amp
id|conflict_style
comma
l_string|&quot;style&quot;
comma
l_string|&quot;conflict style (merge or diff3)&quot;
)paren
comma
id|OPT_BOOLEAN
c_func
(paren
l_char|&squot;p&squot;
comma
l_string|&quot;patch&quot;
comma
op_amp
id|patch_mode
comma
l_string|&quot;select hunks interactively&quot;
)paren
comma
(brace
id|OPTION_BOOLEAN
comma
l_int|0
comma
l_string|&quot;guess&quot;
comma
op_amp
id|dwim_new_local_branch
comma
l_int|NULL
comma
l_string|&quot;second guess &squot;git checkout no-such-branch&squot;&quot;
comma
id|PARSE_OPT_NOARG
op_or
id|PARSE_OPT_HIDDEN
)brace
comma
id|OPT_END
c_func
(paren
)paren
comma
)brace
suffix:semicolon
r_int
id|has_dash_dash
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|opts
comma
l_int|0
comma
r_sizeof
(paren
id|opts
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
r_new
comma
l_int|0
comma
r_sizeof
(paren
r_new
)paren
)paren
suffix:semicolon
id|git_config
c_func
(paren
id|git_checkout_config
comma
l_int|NULL
)paren
suffix:semicolon
id|opts.track
op_assign
id|BRANCH_TRACK_UNSPECIFIED
suffix:semicolon
id|argc
op_assign
id|parse_options
c_func
(paren
id|argc
comma
id|argv
comma
id|prefix
comma
id|options
comma
id|checkout_usage
comma
id|PARSE_OPT_KEEP_DASHDASH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|patch_mode
op_logical_and
(paren
id|opts.track
OG
l_int|0
op_logical_or
id|opts.new_branch
op_logical_or
id|opts.new_branch_log
op_logical_or
id|opts.merge
op_logical_or
id|opts.force
)paren
)paren
id|die
(paren
l_string|&quot;--patch is incompatible with all other options&quot;
)paren
suffix:semicolon
multiline_comment|/* --track without -b should DWIM */
r_if
c_cond
(paren
l_int|0
OL
id|opts.track
op_logical_and
op_logical_neg
id|opts.new_branch
)paren
(brace
r_const
r_char
op_star
id|argv0
op_assign
id|argv
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|argc
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|argv0
comma
l_string|&quot;--&quot;
)paren
)paren
id|die
(paren
l_string|&quot;--track needs a branch name&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|argv0
comma
l_string|&quot;refs/&quot;
)paren
)paren
id|argv0
op_add_assign
l_int|5
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|argv0
comma
l_string|&quot;remotes/&quot;
)paren
)paren
id|argv0
op_add_assign
l_int|8
suffix:semicolon
id|argv0
op_assign
id|strchr
c_func
(paren
id|argv0
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|argv0
op_logical_or
op_logical_neg
id|argv0
(braket
l_int|1
)braket
)paren
id|die
(paren
l_string|&quot;Missing branch name; try -b&quot;
)paren
suffix:semicolon
id|opts.new_branch
op_assign
id|argv0
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|conflict_style
)paren
(brace
id|opts.merge
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* implied */
id|git_xmerge_config
c_func
(paren
l_string|&quot;merge.conflictstyle&quot;
comma
id|conflict_style
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|opts.force
op_logical_and
id|opts.merge
)paren
id|die
c_func
(paren
l_string|&quot;git checkout: -f and -m are incompatible&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * case 1: git checkout &lt;ref&gt; -- [&lt;paths&gt;]&n;&t; *&n;&t; *   &lt;ref&gt; must be a valid tree, everything after the &squot;--&squot; must be&n;&t; *   a path.&n;&t; *&n;&t; * case 2: git checkout -- [&lt;paths&gt;]&n;&t; *&n;&t; *   everything after the &squot;--&squot; must be paths.&n;&t; *&n;&t; * case 3: git checkout &lt;something&gt; [&lt;paths&gt;]&n;&t; *&n;&t; *   With no paths, if &lt;something&gt; is a commit, that is to&n;&t; *   switch to the branch or detach HEAD at it.  As a special case,&n;&t; *   if &lt;something&gt; is A...B (missing A or B means HEAD but you can&n;&t; *   omit at most one side), and if there is a unique merge base&n;&t; *   between A and B, A...B names that merge base.&n;&t; *&n;&t; *   With no paths, if &lt;something&gt; is _not_ a commit, no -t nor -b&n;&t; *   was given, and there is a tracking branch whose name is&n;&t; *   &lt;something&gt; in one and only one remote, then this is a short-hand&n;&t; *   to fork local &lt;something&gt; from that remote tracking branch.&n;&t; *&n;&t; *   Otherwise &lt;something&gt; shall not be ambiguous.&n;&t; *   - If it&squot;s *only* a reference, treat it like case (1).&n;&t; *   - If it&squot;s only a path, treat it like case (2).&n;&t; *   - else: fail.&n;&t; *&n;&t; */
r_if
c_cond
(paren
id|argc
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|argv
(braket
l_int|0
)braket
comma
l_string|&quot;--&quot;
)paren
)paren
(brace
multiline_comment|/* case (2) */
id|argv
op_increment
suffix:semicolon
id|argc
op_decrement
suffix:semicolon
r_goto
id|no_reference
suffix:semicolon
)brace
id|arg
op_assign
id|argv
(braket
l_int|0
)braket
suffix:semicolon
id|has_dash_dash
op_assign
(paren
id|argc
OG
l_int|1
)paren
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
l_string|&quot;--&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|arg
comma
l_string|&quot;-&quot;
)paren
)paren
id|arg
op_assign
l_string|&quot;@{-1}&quot;
suffix:semicolon
r_if
c_cond
(paren
id|get_sha1_mb
c_func
(paren
id|arg
comma
id|rev
)paren
)paren
(brace
r_if
c_cond
(paren
id|has_dash_dash
)paren
multiline_comment|/* case (1) */
id|die
c_func
(paren
l_string|&quot;invalid reference: %s&quot;
comma
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|patch_mode
op_logical_and
id|dwim_new_local_branch
op_logical_and
id|opts.track
op_eq
id|BRANCH_TRACK_UNSPECIFIED
op_logical_and
op_logical_neg
id|opts.new_branch
op_logical_and
op_logical_neg
id|check_filename
c_func
(paren
l_int|NULL
comma
id|arg
)paren
op_logical_and
id|argc
op_eq
l_int|1
)paren
(brace
r_const
r_char
op_star
id|remote
op_assign
id|unique_tracking_name
c_func
(paren
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|remote
op_logical_or
id|get_sha1
c_func
(paren
id|remote
comma
id|rev
)paren
)paren
r_goto
id|no_reference
suffix:semicolon
id|opts.new_branch
op_assign
id|arg
suffix:semicolon
id|arg
op_assign
id|remote
suffix:semicolon
multiline_comment|/* DWIMmed to create local branch */
)brace
r_else
r_goto
id|no_reference
suffix:semicolon
)brace
multiline_comment|/* we can&squot;t end up being in (2) anymore, eat the argument */
id|argv
op_increment
suffix:semicolon
id|argc
op_decrement
suffix:semicolon
r_new
dot
id|name
op_assign
id|arg
suffix:semicolon
r_if
c_cond
(paren
(paren
r_new
dot
id|commit
op_assign
id|lookup_commit_reference_gently
c_func
(paren
id|rev
comma
l_int|1
)paren
)paren
)paren
(brace
id|setup_branch_path
c_func
(paren
op_amp
r_new
)paren
suffix:semicolon
r_if
c_cond
(paren
id|resolve_ref
c_func
(paren
r_new
dot
id|path
comma
id|rev
comma
l_int|1
comma
l_int|NULL
)paren
)paren
r_new
dot
id|commit
op_assign
id|lookup_commit_reference
c_func
(paren
id|rev
)paren
suffix:semicolon
r_else
r_new
dot
id|path
op_assign
l_int|NULL
suffix:semicolon
id|parse_commit
c_func
(paren
r_new
dot
id|commit
)paren
suffix:semicolon
id|source_tree
op_assign
r_new
dot
id|commit-&gt;tree
suffix:semicolon
)brace
r_else
id|source_tree
op_assign
id|parse_tree_indirect
c_func
(paren
id|rev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|source_tree
)paren
multiline_comment|/* case (1): want a tree */
id|die
c_func
(paren
l_string|&quot;reference is not a tree: %s&quot;
comma
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|has_dash_dash
)paren
(brace
multiline_comment|/* case (3 -&gt; 1) */
multiline_comment|/*&n;&t;&t;&t; * Do not complain the most common case&n;&t;&t;&t; *&t;git checkout branch&n;&t;&t;&t; * even if there happen to be a file called &squot;branch&squot;;&n;&t;&t;&t; * it would be extremely annoying.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|argc
)paren
id|verify_non_filename
c_func
(paren
l_int|NULL
comma
id|arg
)paren
suffix:semicolon
)brace
r_else
(brace
id|argv
op_increment
suffix:semicolon
id|argc
op_decrement
suffix:semicolon
)brace
)brace
id|no_reference
suffix:colon
r_if
c_cond
(paren
id|opts.track
op_eq
id|BRANCH_TRACK_UNSPECIFIED
)paren
id|opts.track
op_assign
id|git_branch_track
suffix:semicolon
r_if
c_cond
(paren
id|argc
)paren
(brace
r_const
r_char
op_star
op_star
id|pathspec
op_assign
id|get_pathspec
c_func
(paren
id|prefix
comma
id|argv
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pathspec
)paren
id|die
c_func
(paren
l_string|&quot;invalid path specification&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|patch_mode
)paren
r_return
id|interactive_checkout
c_func
(paren
r_new
dot
id|name
comma
id|pathspec
comma
op_amp
id|opts
)paren
suffix:semicolon
multiline_comment|/* Checkout paths */
r_if
c_cond
(paren
id|opts.new_branch
)paren
(brace
r_if
c_cond
(paren
id|argc
op_eq
l_int|1
)paren
(brace
id|die
c_func
(paren
l_string|&quot;git checkout: updating paths is incompatible with switching branches.&bslash;nDid you intend to checkout &squot;%s&squot; which can not be resolved as commit?&quot;
comma
id|argv
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
id|die
c_func
(paren
l_string|&quot;git checkout: updating paths is incompatible with switching branches.&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
l_int|1
OL
op_logical_neg
op_logical_neg
id|opts.writeout_stage
op_plus
op_logical_neg
op_logical_neg
id|opts.force
op_plus
op_logical_neg
op_logical_neg
id|opts.merge
)paren
id|die
c_func
(paren
l_string|&quot;git checkout: --ours/--theirs, --force and --merge are incompatible when&bslash;nchecking out of the index.&quot;
)paren
suffix:semicolon
r_return
id|checkout_paths
c_func
(paren
id|source_tree
comma
id|pathspec
comma
op_amp
id|opts
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|patch_mode
)paren
r_return
id|interactive_checkout
c_func
(paren
r_new
dot
id|name
comma
l_int|NULL
comma
op_amp
id|opts
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opts.new_branch
)paren
(brace
r_struct
id|strbuf
id|buf
op_assign
id|STRBUF_INIT
suffix:semicolon
r_if
c_cond
(paren
id|strbuf_check_branch_ref
c_func
(paren
op_amp
id|buf
comma
id|opts.new_branch
)paren
)paren
id|die
c_func
(paren
l_string|&quot;git checkout: we do not like &squot;%s&squot; as a branch name.&quot;
comma
id|opts.new_branch
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|get_sha1
c_func
(paren
id|buf.buf
comma
id|rev
)paren
)paren
id|die
c_func
(paren
l_string|&quot;git checkout: branch %s already exists&quot;
comma
id|opts.new_branch
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|buf
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
r_new
dot
id|name
op_logical_and
op_logical_neg
r_new
dot
id|commit
)paren
(brace
id|die
c_func
(paren
l_string|&quot;Cannot switch branch to a non-commit.&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|opts.writeout_stage
)paren
id|die
c_func
(paren
l_string|&quot;--ours/--theirs is incompatible with switching branches.&quot;
)paren
suffix:semicolon
r_return
id|switch_branches
c_func
(paren
op_amp
id|opts
comma
op_amp
r_new
)paren
suffix:semicolon
)brace
eof
