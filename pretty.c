macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;commit.h&quot;
macro_line|#include &quot;utf8.h&quot;
macro_line|#include &quot;diff.h&quot;
macro_line|#include &quot;revision.h&quot;
macro_line|#include &quot;string-list.h&quot;
macro_line|#include &quot;mailmap.h&quot;
DECL|variable|user_format
r_static
r_char
op_star
id|user_format
suffix:semicolon
DECL|function|get_commit_format
r_void
id|get_commit_format
c_func
(paren
r_const
r_char
op_star
id|arg
comma
r_struct
id|rev_info
op_star
id|rev
)paren
(brace
r_int
id|i
suffix:semicolon
r_static
r_struct
id|cmt_fmt_map
(brace
r_const
r_char
op_star
id|n
suffix:semicolon
r_int
id|cmp_len
suffix:semicolon
r_enum
id|cmit_fmt
id|v
suffix:semicolon
)brace
id|cmt_fmts
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;raw&quot;
comma
l_int|1
comma
id|CMIT_FMT_RAW
)brace
comma
(brace
l_string|&quot;medium&quot;
comma
l_int|1
comma
id|CMIT_FMT_MEDIUM
)brace
comma
(brace
l_string|&quot;short&quot;
comma
l_int|1
comma
id|CMIT_FMT_SHORT
)brace
comma
(brace
l_string|&quot;email&quot;
comma
l_int|1
comma
id|CMIT_FMT_EMAIL
)brace
comma
(brace
l_string|&quot;full&quot;
comma
l_int|5
comma
id|CMIT_FMT_FULL
)brace
comma
(brace
l_string|&quot;fuller&quot;
comma
l_int|5
comma
id|CMIT_FMT_FULLER
)brace
comma
(brace
l_string|&quot;oneline&quot;
comma
l_int|1
comma
id|CMIT_FMT_ONELINE
)brace
comma
)brace
suffix:semicolon
id|rev-&gt;use_terminator
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
op_logical_or
op_logical_neg
op_star
id|arg
)paren
(brace
id|rev-&gt;commit_format
op_assign
id|CMIT_FMT_DEFAULT
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;format:&quot;
)paren
op_logical_or
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;tformat:&quot;
)paren
)paren
(brace
r_const
r_char
op_star
id|cp
op_assign
id|strchr
c_func
(paren
id|arg
comma
l_char|&squot;:&squot;
)paren
op_plus
l_int|1
suffix:semicolon
id|free
c_func
(paren
id|user_format
)paren
suffix:semicolon
id|user_format
op_assign
id|xstrdup
c_func
(paren
id|cp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arg
(braket
l_int|0
)braket
op_eq
l_char|&squot;t&squot;
)paren
id|rev-&gt;use_terminator
op_assign
l_int|1
suffix:semicolon
id|rev-&gt;commit_format
op_assign
id|CMIT_FMT_USERFORMAT
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|cmt_fmts
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|arg
comma
id|cmt_fmts
(braket
id|i
)braket
dot
id|n
comma
id|cmt_fmts
(braket
id|i
)braket
dot
id|cmp_len
)paren
op_logical_and
op_logical_neg
id|strncmp
c_func
(paren
id|arg
comma
id|cmt_fmts
(braket
id|i
)braket
dot
id|n
comma
id|strlen
c_func
(paren
id|arg
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|cmt_fmts
(braket
id|i
)braket
dot
id|v
op_eq
id|CMIT_FMT_ONELINE
)paren
id|rev-&gt;use_terminator
op_assign
l_int|1
suffix:semicolon
id|rev-&gt;commit_format
op_assign
id|cmt_fmts
(braket
id|i
)braket
dot
id|v
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|die
c_func
(paren
l_string|&quot;invalid --pretty format: %s&quot;
comma
id|arg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Generic support for pretty-printing the header&n; */
DECL|function|get_one_line
r_static
r_int
id|get_one_line
c_func
(paren
r_const
r_char
op_star
id|msg
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_char
id|c
op_assign
op_star
id|msg
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
r_break
suffix:semicolon
id|ret
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* High bit set, or ISO-2022-INT */
DECL|function|non_ascii
r_int
id|non_ascii
c_func
(paren
r_int
id|ch
)paren
(brace
id|ch
op_assign
(paren
id|ch
op_amp
l_int|0xff
)paren
suffix:semicolon
r_return
(paren
(paren
id|ch
op_amp
l_int|0x80
)paren
op_logical_or
(paren
id|ch
op_eq
l_int|0x1b
)paren
)paren
suffix:semicolon
)brace
DECL|function|is_rfc2047_special
r_static
r_int
id|is_rfc2047_special
c_func
(paren
r_char
id|ch
)paren
(brace
r_return
(paren
id|non_ascii
c_func
(paren
id|ch
)paren
op_logical_or
(paren
id|ch
op_eq
l_char|&squot;=&squot;
)paren
op_logical_or
(paren
id|ch
op_eq
l_char|&squot;?&squot;
)paren
op_logical_or
(paren
id|ch
op_eq
l_char|&squot;_&squot;
)paren
)paren
suffix:semicolon
)brace
DECL|function|add_rfc2047
r_static
r_void
id|add_rfc2047
c_func
(paren
r_struct
id|strbuf
op_star
id|sb
comma
r_const
r_char
op_star
id|line
comma
r_int
id|len
comma
r_const
r_char
op_star
id|encoding
)paren
(brace
r_int
id|i
comma
id|last
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|ch
op_assign
id|line
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|non_ascii
c_func
(paren
id|ch
)paren
)paren
r_goto
id|needquote
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_plus
l_int|1
OL
id|len
)paren
op_logical_and
(paren
id|ch
op_eq
l_char|&squot;=&squot;
op_logical_and
id|line
(braket
id|i
op_plus
l_int|1
)braket
op_eq
l_char|&squot;?&squot;
)paren
)paren
r_goto
id|needquote
suffix:semicolon
)brace
id|strbuf_add
c_func
(paren
id|sb
comma
id|line
comma
id|len
)paren
suffix:semicolon
r_return
suffix:semicolon
id|needquote
suffix:colon
id|strbuf_grow
c_func
(paren
id|sb
comma
id|len
op_star
l_int|3
op_plus
id|strlen
c_func
(paren
id|encoding
)paren
op_plus
l_int|100
)paren
suffix:semicolon
id|strbuf_addf
c_func
(paren
id|sb
comma
l_string|&quot;=?%s?q?&quot;
comma
id|encoding
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|last
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|ch
op_assign
id|line
(braket
id|i
)braket
op_amp
l_int|0xFF
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We encode &squot; &squot; using &squot;=20&squot; even though rfc2047&n;&t;&t; * allows using &squot;_&squot; for readability.  Unfortunately,&n;&t;&t; * many programs do not understand this and just&n;&t;&t; * leave the underscore in place.&n;&t;&t; */
r_if
c_cond
(paren
id|is_rfc2047_special
c_func
(paren
id|ch
)paren
op_logical_or
id|ch
op_eq
l_char|&squot; &squot;
)paren
(brace
id|strbuf_add
c_func
(paren
id|sb
comma
id|line
op_plus
id|last
comma
id|i
id|last
)paren
suffix:semicolon
id|strbuf_addf
c_func
(paren
id|sb
comma
l_string|&quot;=%02X&quot;
comma
id|ch
)paren
suffix:semicolon
id|last
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
)brace
)brace
id|strbuf_add
c_func
(paren
id|sb
comma
id|line
op_plus
id|last
comma
id|len
id|last
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
id|sb
comma
l_string|&quot;?=&quot;
)paren
suffix:semicolon
)brace
DECL|function|pp_user_info
r_void
id|pp_user_info
c_func
(paren
r_const
r_char
op_star
id|what
comma
r_enum
id|cmit_fmt
id|fmt
comma
r_struct
id|strbuf
op_star
id|sb
comma
r_const
r_char
op_star
id|line
comma
r_enum
id|date_mode
id|dmode
comma
r_const
r_char
op_star
id|encoding
)paren
(brace
r_char
op_star
id|date
suffix:semicolon
r_int
id|namelen
suffix:semicolon
r_int
r_int
id|time
suffix:semicolon
r_int
id|tz
suffix:semicolon
r_const
r_char
op_star
id|filler
op_assign
l_string|&quot;    &quot;
suffix:semicolon
r_if
c_cond
(paren
id|fmt
op_eq
id|CMIT_FMT_ONELINE
)paren
r_return
suffix:semicolon
id|date
op_assign
id|strchr
c_func
(paren
id|line
comma
l_char|&squot;&gt;&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|date
)paren
r_return
suffix:semicolon
id|namelen
op_assign
op_increment
id|date
id|line
suffix:semicolon
id|time
op_assign
id|strtoul
c_func
(paren
id|date
comma
op_amp
id|date
comma
l_int|10
)paren
suffix:semicolon
id|tz
op_assign
id|strtol
c_func
(paren
id|date
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fmt
op_eq
id|CMIT_FMT_EMAIL
)paren
(brace
r_char
op_star
id|name_tail
op_assign
id|strchr
c_func
(paren
id|line
comma
l_char|&squot;&lt;&squot;
)paren
suffix:semicolon
r_int
id|display_name_length
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|name_tail
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
id|line
OL
id|name_tail
op_logical_and
id|isspace
c_func
(paren
id|name_tail
(braket
l_int|1
)braket
)paren
)paren
id|name_tail
op_decrement
suffix:semicolon
id|display_name_length
op_assign
id|name_tail
id|line
suffix:semicolon
id|filler
op_assign
l_string|&quot;&quot;
suffix:semicolon
id|strbuf_addstr
c_func
(paren
id|sb
comma
l_string|&quot;From: &quot;
)paren
suffix:semicolon
id|add_rfc2047
c_func
(paren
id|sb
comma
id|line
comma
id|display_name_length
comma
id|encoding
)paren
suffix:semicolon
id|strbuf_add
c_func
(paren
id|sb
comma
id|name_tail
comma
id|namelen
id|display_name_length
)paren
suffix:semicolon
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|strbuf_addf
c_func
(paren
id|sb
comma
l_string|&quot;%s: %.*s%.*s&bslash;n&quot;
comma
id|what
comma
(paren
id|fmt
op_eq
id|CMIT_FMT_FULLER
)paren
ques
c_cond
l_int|4
suffix:colon
l_int|0
comma
id|filler
comma
id|namelen
comma
id|line
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|fmt
)paren
(brace
r_case
id|CMIT_FMT_MEDIUM
suffix:colon
id|strbuf_addf
c_func
(paren
id|sb
comma
l_string|&quot;Date:   %s&bslash;n&quot;
comma
id|show_date
c_func
(paren
id|time
comma
id|tz
comma
id|dmode
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CMIT_FMT_EMAIL
suffix:colon
id|strbuf_addf
c_func
(paren
id|sb
comma
l_string|&quot;Date: %s&bslash;n&quot;
comma
id|show_date
c_func
(paren
id|time
comma
id|tz
comma
id|DATE_RFC2822
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CMIT_FMT_FULLER
suffix:colon
id|strbuf_addf
c_func
(paren
id|sb
comma
l_string|&quot;%sDate: %s&bslash;n&quot;
comma
id|what
comma
id|show_date
c_func
(paren
id|time
comma
id|tz
comma
id|dmode
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* notin&squot; */
r_break
suffix:semicolon
)brace
)brace
DECL|function|is_empty_line
r_static
r_int
id|is_empty_line
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_int
op_star
id|len_p
)paren
(brace
r_int
id|len
op_assign
op_star
id|len_p
suffix:semicolon
r_while
c_loop
(paren
id|len
op_logical_and
id|isspace
c_func
(paren
id|line
(braket
id|len
op_minus
l_int|1
)braket
)paren
)paren
id|len
op_decrement
suffix:semicolon
op_star
id|len_p
op_assign
id|len
suffix:semicolon
r_return
op_logical_neg
id|len
suffix:semicolon
)brace
DECL|function|add_merge_info
r_static
r_void
id|add_merge_info
c_func
(paren
r_enum
id|cmit_fmt
id|fmt
comma
r_struct
id|strbuf
op_star
id|sb
comma
r_const
r_struct
id|commit
op_star
id|commit
comma
r_int
id|abbrev
)paren
(brace
r_struct
id|commit_list
op_star
id|parent
op_assign
id|commit-&gt;parents
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fmt
op_eq
id|CMIT_FMT_ONELINE
)paren
op_logical_or
(paren
id|fmt
op_eq
id|CMIT_FMT_EMAIL
)paren
op_logical_or
op_logical_neg
id|parent
op_logical_or
op_logical_neg
id|parent-&gt;next
)paren
r_return
suffix:semicolon
id|strbuf_addstr
c_func
(paren
id|sb
comma
l_string|&quot;Merge:&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|parent
)paren
(brace
r_struct
id|commit
op_star
id|p
op_assign
id|parent-&gt;item
suffix:semicolon
r_const
r_char
op_star
id|hex
op_assign
l_int|NULL
suffix:semicolon
r_const
r_char
op_star
id|dots
suffix:semicolon
r_if
c_cond
(paren
id|abbrev
)paren
id|hex
op_assign
id|find_unique_abbrev
c_func
(paren
id|p-&gt;object.sha1
comma
id|abbrev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hex
)paren
id|hex
op_assign
id|sha1_to_hex
c_func
(paren
id|p-&gt;object.sha1
)paren
suffix:semicolon
id|dots
op_assign
(paren
id|abbrev
op_logical_and
id|strlen
c_func
(paren
id|hex
)paren
op_ne
l_int|40
)paren
ques
c_cond
l_string|&quot;...&quot;
suffix:colon
l_string|&quot;&quot;
suffix:semicolon
id|parent
op_assign
id|parent-&gt;next
suffix:semicolon
id|strbuf_addf
c_func
(paren
id|sb
comma
l_string|&quot; %s%s&quot;
comma
id|hex
comma
id|dots
)paren
suffix:semicolon
)brace
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
DECL|function|get_header
r_static
r_char
op_star
id|get_header
c_func
(paren
r_const
r_struct
id|commit
op_star
id|commit
comma
r_const
r_char
op_star
id|key
)paren
(brace
r_int
id|key_len
op_assign
id|strlen
c_func
(paren
id|key
)paren
suffix:semicolon
r_const
r_char
op_star
id|line
op_assign
id|commit-&gt;buffer
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_const
r_char
op_star
id|eol
op_assign
id|strchr
c_func
(paren
id|line
comma
l_char|&squot;&bslash;n&squot;
)paren
comma
op_star
id|next
suffix:semicolon
r_if
c_cond
(paren
id|line
op_eq
id|eol
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|eol
)paren
(brace
id|eol
op_assign
id|line
op_plus
id|strlen
c_func
(paren
id|line
)paren
suffix:semicolon
id|next
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
id|next
op_assign
id|eol
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|eol
id|line
OG
id|key_len
op_logical_and
op_logical_neg
id|strncmp
c_func
(paren
id|line
comma
id|key
comma
id|key_len
)paren
op_logical_and
id|line
(braket
id|key_len
)braket
op_eq
l_char|&squot; &squot;
)paren
(brace
r_return
id|xmemdupz
c_func
(paren
id|line
op_plus
id|key_len
op_plus
l_int|1
comma
id|eol
id|line
id|key_len
l_int|1
)paren
suffix:semicolon
)brace
id|line
op_assign
id|next
suffix:semicolon
)brace
)brace
DECL|function|replace_encoding_header
r_static
r_char
op_star
id|replace_encoding_header
c_func
(paren
r_char
op_star
id|buf
comma
r_const
r_char
op_star
id|encoding
)paren
(brace
r_struct
id|strbuf
id|tmp
suffix:semicolon
r_int
id|start
comma
id|len
suffix:semicolon
r_char
op_star
id|cp
op_assign
id|buf
suffix:semicolon
multiline_comment|/* guess if there is an encoding header before a &bslash;n&bslash;n */
r_while
c_loop
(paren
id|strncmp
c_func
(paren
id|cp
comma
l_string|&quot;encoding &quot;
comma
id|strlen
c_func
(paren
l_string|&quot;encoding &quot;
)paren
)paren
)paren
(brace
id|cp
op_assign
id|strchr
c_func
(paren
id|cp
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
op_logical_or
op_star
op_increment
id|cp
op_eq
l_char|&squot;&bslash;n&squot;
)paren
r_return
id|buf
suffix:semicolon
)brace
id|start
op_assign
id|cp
id|buf
suffix:semicolon
id|cp
op_assign
id|strchr
c_func
(paren
id|cp
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_return
id|buf
suffix:semicolon
multiline_comment|/* should not happen but be defensive */
id|len
op_assign
id|cp
op_plus
l_int|1
(paren
id|buf
op_plus
id|start
)paren
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|tmp
comma
l_int|0
)paren
suffix:semicolon
id|strbuf_attach
c_func
(paren
op_amp
id|tmp
comma
id|buf
comma
id|strlen
c_func
(paren
id|buf
)paren
comma
id|strlen
c_func
(paren
id|buf
)paren
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_encoding_utf8
c_func
(paren
id|encoding
)paren
)paren
(brace
multiline_comment|/* we have re-coded to UTF-8; drop the header */
id|strbuf_remove
c_func
(paren
op_amp
id|tmp
comma
id|start
comma
id|len
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* just replaces XXXX in &squot;encoding XXXX&bslash;n&squot; */
id|strbuf_splice
c_func
(paren
op_amp
id|tmp
comma
id|start
op_plus
id|strlen
c_func
(paren
l_string|&quot;encoding &quot;
)paren
comma
id|len
id|strlen
c_func
(paren
l_string|&quot;encoding &bslash;n&quot;
)paren
comma
id|encoding
comma
id|strlen
c_func
(paren
id|encoding
)paren
)paren
suffix:semicolon
)brace
r_return
id|strbuf_detach
c_func
(paren
op_amp
id|tmp
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|logmsg_reencode
r_static
r_char
op_star
id|logmsg_reencode
c_func
(paren
r_const
r_struct
id|commit
op_star
id|commit
comma
r_const
r_char
op_star
id|output_encoding
)paren
(brace
r_static
r_const
r_char
op_star
id|utf8
op_assign
l_string|&quot;utf-8&quot;
suffix:semicolon
r_const
r_char
op_star
id|use_encoding
suffix:semicolon
r_char
op_star
id|encoding
suffix:semicolon
r_char
op_star
id|out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|output_encoding
)paren
r_return
l_int|NULL
suffix:semicolon
id|encoding
op_assign
id|get_header
c_func
(paren
id|commit
comma
l_string|&quot;encoding&quot;
)paren
suffix:semicolon
id|use_encoding
op_assign
id|encoding
ques
c_cond
id|encoding
suffix:colon
id|utf8
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|use_encoding
comma
id|output_encoding
)paren
)paren
r_if
c_cond
(paren
id|encoding
)paren
multiline_comment|/* we&squot;ll strip encoding header later */
id|out
op_assign
id|xstrdup
c_func
(paren
id|commit-&gt;buffer
)paren
suffix:semicolon
r_else
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* nothing to do */
r_else
id|out
op_assign
id|reencode_string
c_func
(paren
id|commit-&gt;buffer
comma
id|output_encoding
comma
id|use_encoding
)paren
suffix:semicolon
r_if
c_cond
(paren
id|out
)paren
id|out
op_assign
id|replace_encoding_header
c_func
(paren
id|out
comma
id|output_encoding
)paren
suffix:semicolon
id|free
c_func
(paren
id|encoding
)paren
suffix:semicolon
r_return
id|out
suffix:semicolon
)brace
DECL|function|mailmap_name
r_static
r_int
id|mailmap_name
c_func
(paren
r_struct
id|strbuf
op_star
id|sb
comma
r_const
r_char
op_star
id|email
)paren
(brace
r_static
r_struct
id|string_list
op_star
id|mail_map
suffix:semicolon
r_char
id|buffer
(braket
l_int|1024
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mail_map
)paren
(brace
id|mail_map
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|mail_map
)paren
)paren
suffix:semicolon
id|read_mailmap
c_func
(paren
id|mail_map
comma
l_string|&quot;.mailmap&quot;
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|mail_map-&gt;nr
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|map_email
c_func
(paren
id|mail_map
comma
id|email
comma
id|buffer
comma
r_sizeof
(paren
id|buffer
)paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|buffer
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|format_person_part
r_static
r_int
id|format_person_part
c_func
(paren
r_struct
id|strbuf
op_star
id|sb
comma
r_char
id|part
comma
r_const
r_char
op_star
id|msg
comma
r_int
id|len
)paren
(brace
multiline_comment|/* currently all placeholders have same length */
r_const
r_int
id|placeholder_len
op_assign
l_int|2
suffix:semicolon
r_int
id|start
comma
id|end
comma
id|tz
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|date
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|ep
suffix:semicolon
multiline_comment|/* advance &squot;end&squot; to point to email start delimiter */
r_for
c_loop
(paren
id|end
op_assign
l_int|0
suffix:semicolon
id|end
OL
id|len
op_logical_and
id|msg
(braket
id|end
)braket
op_ne
l_char|&squot;&lt;&squot;
suffix:semicolon
id|end
op_increment
)paren
suffix:semicolon
multiline_comment|/* do nothing */
multiline_comment|/*&n;&t; * When end points at the &squot;&lt;&squot; that we found, it should have&n;&t; * matching &squot;&gt;&squot; later, which means &squot;end&squot; must be strictly&n;&t; * below len - 1.&n;&t; */
r_if
c_cond
(paren
id|end
op_ge
id|len
l_int|2
)paren
r_goto
id|skip
suffix:semicolon
r_if
c_cond
(paren
id|part
op_eq
l_char|&squot;n&squot;
op_logical_or
id|part
op_eq
l_char|&squot;N&squot;
)paren
(brace
multiline_comment|/* name */
r_while
c_loop
(paren
id|end
OG
l_int|0
op_logical_and
id|isspace
c_func
(paren
id|msg
(braket
id|end
l_int|1
)braket
)paren
)paren
id|end
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|part
op_ne
l_char|&squot;N&squot;
op_logical_or
op_logical_neg
id|msg
(braket
id|end
)braket
op_logical_or
op_logical_neg
id|msg
(braket
id|end
op_plus
l_int|1
)braket
op_logical_or
id|mailmap_name
c_func
(paren
id|sb
comma
id|msg
op_plus
id|end
op_plus
l_int|2
)paren
OL
l_int|0
)paren
id|strbuf_add
c_func
(paren
id|sb
comma
id|msg
comma
id|end
)paren
suffix:semicolon
r_return
id|placeholder_len
suffix:semicolon
)brace
id|start
op_assign
op_increment
id|end
suffix:semicolon
multiline_comment|/* save email start position */
multiline_comment|/* advance &squot;end&squot; to point to email end delimiter */
r_for
c_loop
(paren
suffix:semicolon
id|end
OL
id|len
op_logical_and
id|msg
(braket
id|end
)braket
op_ne
l_char|&squot;&gt;&squot;
suffix:semicolon
id|end
op_increment
)paren
suffix:semicolon
multiline_comment|/* do nothing */
r_if
c_cond
(paren
id|end
op_ge
id|len
)paren
r_goto
id|skip
suffix:semicolon
r_if
c_cond
(paren
id|part
op_eq
l_char|&squot;e&squot;
)paren
(brace
multiline_comment|/* email */
id|strbuf_add
c_func
(paren
id|sb
comma
id|msg
op_plus
id|start
comma
id|end
id|start
)paren
suffix:semicolon
r_return
id|placeholder_len
suffix:semicolon
)brace
multiline_comment|/* advance &squot;start&squot; to point to date start delimiter */
r_for
c_loop
(paren
id|start
op_assign
id|end
op_plus
l_int|1
suffix:semicolon
id|start
OL
id|len
op_logical_and
id|isspace
c_func
(paren
id|msg
(braket
id|start
)braket
)paren
suffix:semicolon
id|start
op_increment
)paren
suffix:semicolon
multiline_comment|/* do nothing */
r_if
c_cond
(paren
id|start
op_ge
id|len
)paren
r_goto
id|skip
suffix:semicolon
id|date
op_assign
id|strtoul
c_func
(paren
id|msg
op_plus
id|start
comma
op_amp
id|ep
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg
op_plus
id|start
op_eq
id|ep
)paren
r_goto
id|skip
suffix:semicolon
r_if
c_cond
(paren
id|part
op_eq
l_char|&squot;t&squot;
)paren
(brace
multiline_comment|/* date, UNIX timestamp */
id|strbuf_add
c_func
(paren
id|sb
comma
id|msg
op_plus
id|start
comma
id|ep
(paren
id|msg
op_plus
id|start
)paren
)paren
suffix:semicolon
r_return
id|placeholder_len
suffix:semicolon
)brace
multiline_comment|/* parse tz */
r_for
c_loop
(paren
id|start
op_assign
id|ep
id|msg
op_plus
l_int|1
suffix:semicolon
id|start
OL
id|len
op_logical_and
id|isspace
c_func
(paren
id|msg
(braket
id|start
)braket
)paren
suffix:semicolon
id|start
op_increment
)paren
suffix:semicolon
multiline_comment|/* do nothing */
r_if
c_cond
(paren
id|start
op_plus
l_int|1
OL
id|len
)paren
(brace
id|tz
op_assign
id|strtoul
c_func
(paren
id|msg
op_plus
id|start
op_plus
l_int|1
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg
(braket
id|start
)braket
op_eq
l_char|&squot;-&squot;
)paren
id|tz
op_assign
id|tz
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|part
)paren
(brace
r_case
l_char|&squot;d&squot;
suffix:colon
multiline_comment|/* date */
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|show_date
c_func
(paren
id|date
comma
id|tz
comma
id|DATE_NORMAL
)paren
)paren
suffix:semicolon
r_return
id|placeholder_len
suffix:semicolon
r_case
l_char|&squot;D&squot;
suffix:colon
multiline_comment|/* date, RFC2822 style */
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|show_date
c_func
(paren
id|date
comma
id|tz
comma
id|DATE_RFC2822
)paren
)paren
suffix:semicolon
r_return
id|placeholder_len
suffix:semicolon
r_case
l_char|&squot;r&squot;
suffix:colon
multiline_comment|/* date, relative */
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|show_date
c_func
(paren
id|date
comma
id|tz
comma
id|DATE_RELATIVE
)paren
)paren
suffix:semicolon
r_return
id|placeholder_len
suffix:semicolon
r_case
l_char|&squot;i&squot;
suffix:colon
multiline_comment|/* date, ISO 8601 */
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|show_date
c_func
(paren
id|date
comma
id|tz
comma
id|DATE_ISO8601
)paren
)paren
suffix:semicolon
r_return
id|placeholder_len
suffix:semicolon
)brace
id|skip
suffix:colon
multiline_comment|/*&n;&t; * bogus commit, &squot;sb&squot; cannot be updated, but we still need to&n;&t; * compute a valid return value.&n;&t; */
r_if
c_cond
(paren
id|part
op_eq
l_char|&squot;n&squot;
op_logical_or
id|part
op_eq
l_char|&squot;e&squot;
op_logical_or
id|part
op_eq
l_char|&squot;t&squot;
op_logical_or
id|part
op_eq
l_char|&squot;d&squot;
op_logical_or
id|part
op_eq
l_char|&squot;D&squot;
op_logical_or
id|part
op_eq
l_char|&squot;r&squot;
op_logical_or
id|part
op_eq
l_char|&squot;i&squot;
)paren
r_return
id|placeholder_len
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* unknown placeholder */
)brace
DECL|struct|chunk
r_struct
id|chunk
(brace
DECL|member|off
r_int
id|off
suffix:semicolon
DECL|member|len
r_int
id|len
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|format_commit_context
r_struct
id|format_commit_context
(brace
DECL|member|commit
r_const
r_struct
id|commit
op_star
id|commit
suffix:semicolon
multiline_comment|/* These offsets are relative to the start of the commit message. */
DECL|member|commit_header_parsed
r_int
id|commit_header_parsed
suffix:semicolon
DECL|member|subject
r_struct
id|chunk
id|subject
suffix:semicolon
DECL|member|author
r_struct
id|chunk
id|author
suffix:semicolon
DECL|member|committer
r_struct
id|chunk
id|committer
suffix:semicolon
DECL|member|encoding
r_struct
id|chunk
id|encoding
suffix:semicolon
DECL|member|body_off
r_int
id|body_off
suffix:semicolon
multiline_comment|/* The following ones are relative to the result struct strbuf. */
DECL|member|abbrev_commit_hash
r_struct
id|chunk
id|abbrev_commit_hash
suffix:semicolon
DECL|member|abbrev_tree_hash
r_struct
id|chunk
id|abbrev_tree_hash
suffix:semicolon
DECL|member|abbrev_parent_hashes
r_struct
id|chunk
id|abbrev_parent_hashes
suffix:semicolon
)brace
suffix:semicolon
DECL|function|add_again
r_static
r_int
id|add_again
c_func
(paren
r_struct
id|strbuf
op_star
id|sb
comma
r_struct
id|chunk
op_star
id|chunk
)paren
(brace
r_if
c_cond
(paren
id|chunk-&gt;len
)paren
(brace
id|strbuf_adddup
c_func
(paren
id|sb
comma
id|chunk-&gt;off
comma
id|chunk-&gt;len
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We haven&squot;t seen this chunk before.  Our caller is surely&n;&t; * going to add it the hard way now.  Remember the most likely&n;&t; * start of the to-be-added chunk: the current end of the&n;&t; * struct strbuf.&n;&t; */
id|chunk-&gt;off
op_assign
id|sb-&gt;len
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|parse_commit_header
r_static
r_void
id|parse_commit_header
c_func
(paren
r_struct
id|format_commit_context
op_star
id|context
)paren
(brace
r_const
r_char
op_star
id|msg
op_assign
id|context-&gt;commit-&gt;buffer
suffix:semicolon
r_int
id|i
suffix:semicolon
r_enum
(brace
id|HEADER
comma
id|SUBJECT
comma
id|BODY
)brace
id|state
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|state
op_assign
id|HEADER
suffix:semicolon
id|msg
(braket
id|i
)braket
op_logical_and
id|state
OL
id|BODY
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|eol
suffix:semicolon
r_for
c_loop
(paren
id|eol
op_assign
id|i
suffix:semicolon
id|msg
(braket
id|eol
)braket
op_logical_and
id|msg
(braket
id|eol
)braket
op_ne
l_char|&squot;&bslash;n&squot;
suffix:semicolon
id|eol
op_increment
)paren
suffix:semicolon
multiline_comment|/* do nothing */
r_if
c_cond
(paren
id|state
op_eq
id|SUBJECT
)paren
(brace
id|context-&gt;subject.off
op_assign
id|i
suffix:semicolon
id|context-&gt;subject.len
op_assign
id|eol
id|i
suffix:semicolon
id|i
op_assign
id|eol
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
id|eol
)paren
(brace
id|state
op_increment
suffix:semicolon
multiline_comment|/* strip empty lines */
r_while
c_loop
(paren
id|msg
(braket
id|eol
)braket
op_eq
l_char|&squot;&bslash;n&squot;
op_logical_and
id|msg
(braket
id|eol
op_plus
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|eol
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|msg
op_plus
id|i
comma
l_string|&quot;author &quot;
)paren
)paren
(brace
id|context-&gt;author.off
op_assign
id|i
op_plus
l_int|7
suffix:semicolon
id|context-&gt;author.len
op_assign
id|eol
id|i
l_int|7
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|msg
op_plus
id|i
comma
l_string|&quot;committer &quot;
)paren
)paren
(brace
id|context-&gt;committer.off
op_assign
id|i
op_plus
l_int|10
suffix:semicolon
id|context-&gt;committer.len
op_assign
id|eol
id|i
l_int|10
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|msg
op_plus
id|i
comma
l_string|&quot;encoding &quot;
)paren
)paren
(brace
id|context-&gt;encoding.off
op_assign
id|i
op_plus
l_int|9
suffix:semicolon
id|context-&gt;encoding.len
op_assign
id|eol
id|i
l_int|9
suffix:semicolon
)brace
id|i
op_assign
id|eol
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|msg
(braket
id|i
)braket
)paren
r_break
suffix:semicolon
)brace
id|context-&gt;body_off
op_assign
id|i
suffix:semicolon
id|context-&gt;commit_header_parsed
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|format_commit_item
r_static
r_int
id|format_commit_item
c_func
(paren
r_struct
id|strbuf
op_star
id|sb
comma
r_const
r_char
op_star
id|placeholder
comma
r_void
op_star
id|context
)paren
(brace
r_struct
id|format_commit_context
op_star
id|c
op_assign
id|context
suffix:semicolon
r_const
r_struct
id|commit
op_star
id|commit
op_assign
id|c-&gt;commit
suffix:semicolon
r_const
r_char
op_star
id|msg
op_assign
id|commit-&gt;buffer
suffix:semicolon
r_struct
id|commit_list
op_star
id|p
suffix:semicolon
r_int
id|h1
comma
id|h2
suffix:semicolon
multiline_comment|/* these are independent of the commit */
r_switch
c_cond
(paren
id|placeholder
(braket
l_int|0
)braket
)paren
(brace
r_case
l_char|&squot;C&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|placeholder
op_plus
l_int|1
comma
l_string|&quot;red&quot;
)paren
)paren
(brace
id|strbuf_addstr
c_func
(paren
id|sb
comma
l_string|&quot;&bslash;033[31m&quot;
)paren
suffix:semicolon
r_return
l_int|4
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|placeholder
op_plus
l_int|1
comma
l_string|&quot;green&quot;
)paren
)paren
(brace
id|strbuf_addstr
c_func
(paren
id|sb
comma
l_string|&quot;&bslash;033[32m&quot;
)paren
suffix:semicolon
r_return
l_int|6
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|placeholder
op_plus
l_int|1
comma
l_string|&quot;blue&quot;
)paren
)paren
(brace
id|strbuf_addstr
c_func
(paren
id|sb
comma
l_string|&quot;&bslash;033[34m&quot;
)paren
suffix:semicolon
r_return
l_int|5
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|placeholder
op_plus
l_int|1
comma
l_string|&quot;reset&quot;
)paren
)paren
(brace
id|strbuf_addstr
c_func
(paren
id|sb
comma
l_string|&quot;&bslash;033[m&quot;
)paren
suffix:semicolon
r_return
l_int|6
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
r_case
l_char|&squot;n&squot;
suffix:colon
multiline_comment|/* newline */
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_case
l_char|&squot;x&squot;
suffix:colon
multiline_comment|/* %x00 == NUL, %x0a == LF, etc. */
r_if
c_cond
(paren
l_int|0
op_le
(paren
id|h1
op_assign
id|hexval_table
(braket
l_int|0xff
op_amp
id|placeholder
(braket
l_int|1
)braket
)braket
)paren
op_logical_and
id|h1
op_le
l_int|16
op_logical_and
l_int|0
op_le
(paren
id|h2
op_assign
id|hexval_table
(braket
l_int|0xff
op_amp
id|placeholder
(braket
l_int|2
)braket
)braket
)paren
op_logical_and
id|h2
op_le
l_int|16
)paren
(brace
id|strbuf_addch
c_func
(paren
id|sb
comma
(paren
id|h1
op_lshift
l_int|4
)paren
op_or
id|h2
)paren
suffix:semicolon
r_return
l_int|3
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* these depend on the commit */
r_if
c_cond
(paren
op_logical_neg
id|commit-&gt;object.parsed
)paren
id|parse_object
c_func
(paren
id|commit-&gt;object.sha1
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|placeholder
(braket
l_int|0
)braket
)paren
(brace
r_case
l_char|&squot;H&squot;
suffix:colon
multiline_comment|/* commit hash */
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|sha1_to_hex
c_func
(paren
id|commit-&gt;object.sha1
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_case
l_char|&squot;h&squot;
suffix:colon
multiline_comment|/* abbreviated commit hash */
r_if
c_cond
(paren
id|add_again
c_func
(paren
id|sb
comma
op_amp
id|c-&gt;abbrev_commit_hash
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|find_unique_abbrev
c_func
(paren
id|commit-&gt;object.sha1
comma
id|DEFAULT_ABBREV
)paren
)paren
suffix:semicolon
id|c-&gt;abbrev_commit_hash.len
op_assign
id|sb-&gt;len
id|c-&gt;abbrev_commit_hash.off
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_case
l_char|&squot;T&squot;
suffix:colon
multiline_comment|/* tree hash */
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|sha1_to_hex
c_func
(paren
id|commit-&gt;tree-&gt;object.sha1
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_case
l_char|&squot;t&squot;
suffix:colon
multiline_comment|/* abbreviated tree hash */
r_if
c_cond
(paren
id|add_again
c_func
(paren
id|sb
comma
op_amp
id|c-&gt;abbrev_tree_hash
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|find_unique_abbrev
c_func
(paren
id|commit-&gt;tree-&gt;object.sha1
comma
id|DEFAULT_ABBREV
)paren
)paren
suffix:semicolon
id|c-&gt;abbrev_tree_hash.len
op_assign
id|sb-&gt;len
id|c-&gt;abbrev_tree_hash.off
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_case
l_char|&squot;P&squot;
suffix:colon
multiline_comment|/* parent hashes */
r_for
c_loop
(paren
id|p
op_assign
id|commit-&gt;parents
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|p
op_ne
id|commit-&gt;parents
)paren
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|sha1_to_hex
c_func
(paren
id|p-&gt;item-&gt;object.sha1
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
r_case
l_char|&squot;p&squot;
suffix:colon
multiline_comment|/* abbreviated parent hashes */
r_if
c_cond
(paren
id|add_again
c_func
(paren
id|sb
comma
op_amp
id|c-&gt;abbrev_parent_hashes
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|commit-&gt;parents
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|p
op_ne
id|commit-&gt;parents
)paren
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|find_unique_abbrev
c_func
(paren
id|p-&gt;item-&gt;object.sha1
comma
id|DEFAULT_ABBREV
)paren
)paren
suffix:semicolon
)brace
id|c-&gt;abbrev_parent_hashes.len
op_assign
id|sb-&gt;len
id|c-&gt;abbrev_parent_hashes.off
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_case
l_char|&squot;m&squot;
suffix:colon
multiline_comment|/* left/right/bottom */
id|strbuf_addch
c_func
(paren
id|sb
comma
(paren
id|commit-&gt;object.flags
op_amp
id|BOUNDARY
)paren
ques
c_cond
l_char|&squot;-&squot;
suffix:colon
(paren
id|commit-&gt;object.flags
op_amp
id|SYMMETRIC_LEFT
)paren
ques
c_cond
l_char|&squot;&lt;&squot;
suffix:colon
l_char|&squot;&gt;&squot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* For the rest we have to parse the commit header. */
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;commit_header_parsed
)paren
id|parse_commit_header
c_func
(paren
id|c
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|placeholder
(braket
l_int|0
)braket
)paren
(brace
r_case
l_char|&squot;s&squot;
suffix:colon
multiline_comment|/* subject */
id|strbuf_add
c_func
(paren
id|sb
comma
id|msg
op_plus
id|c-&gt;subject.off
comma
id|c-&gt;subject.len
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_case
l_char|&squot;a&squot;
suffix:colon
multiline_comment|/* author ... */
r_return
id|format_person_part
c_func
(paren
id|sb
comma
id|placeholder
(braket
l_int|1
)braket
comma
id|msg
op_plus
id|c-&gt;author.off
comma
id|c-&gt;author.len
)paren
suffix:semicolon
r_case
l_char|&squot;c&squot;
suffix:colon
multiline_comment|/* committer ... */
r_return
id|format_person_part
c_func
(paren
id|sb
comma
id|placeholder
(braket
l_int|1
)braket
comma
id|msg
op_plus
id|c-&gt;committer.off
comma
id|c-&gt;committer.len
)paren
suffix:semicolon
r_case
l_char|&squot;e&squot;
suffix:colon
multiline_comment|/* encoding */
id|strbuf_add
c_func
(paren
id|sb
comma
id|msg
op_plus
id|c-&gt;encoding.off
comma
id|c-&gt;encoding.len
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_case
l_char|&squot;b&squot;
suffix:colon
multiline_comment|/* body */
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|msg
op_plus
id|c-&gt;body_off
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* unknown placeholder */
)brace
DECL|function|format_commit_message
r_void
id|format_commit_message
c_func
(paren
r_const
r_struct
id|commit
op_star
id|commit
comma
r_const
r_void
op_star
id|format
comma
r_struct
id|strbuf
op_star
id|sb
)paren
(brace
r_struct
id|format_commit_context
id|context
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|context
comma
l_int|0
comma
r_sizeof
(paren
id|context
)paren
)paren
suffix:semicolon
id|context.commit
op_assign
id|commit
suffix:semicolon
id|strbuf_expand
c_func
(paren
id|sb
comma
id|format
comma
id|format_commit_item
comma
op_amp
id|context
)paren
suffix:semicolon
)brace
DECL|function|pp_header
r_static
r_void
id|pp_header
c_func
(paren
r_enum
id|cmit_fmt
id|fmt
comma
r_int
id|abbrev
comma
r_enum
id|date_mode
id|dmode
comma
r_const
r_char
op_star
id|encoding
comma
r_const
r_struct
id|commit
op_star
id|commit
comma
r_const
r_char
op_star
op_star
id|msg_p
comma
r_struct
id|strbuf
op_star
id|sb
)paren
(brace
r_int
id|parents_shown
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_const
r_char
op_star
id|line
op_assign
op_star
id|msg_p
suffix:semicolon
r_int
id|linelen
op_assign
id|get_one_line
c_func
(paren
op_star
id|msg_p
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|linelen
)paren
r_return
suffix:semicolon
op_star
id|msg_p
op_add_assign
id|linelen
suffix:semicolon
r_if
c_cond
(paren
id|linelen
op_eq
l_int|1
)paren
multiline_comment|/* End of header */
r_return
suffix:semicolon
r_if
c_cond
(paren
id|fmt
op_eq
id|CMIT_FMT_RAW
)paren
(brace
id|strbuf_add
c_func
(paren
id|sb
comma
id|line
comma
id|linelen
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|line
comma
l_string|&quot;parent &quot;
comma
l_int|7
)paren
)paren
(brace
r_if
c_cond
(paren
id|linelen
op_ne
l_int|48
)paren
id|die
c_func
(paren
l_string|&quot;bad parent line in commit&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|parents_shown
)paren
(brace
r_struct
id|commit_list
op_star
id|parent
suffix:semicolon
r_int
id|num
suffix:semicolon
r_for
c_loop
(paren
id|parent
op_assign
id|commit-&gt;parents
comma
id|num
op_assign
l_int|0
suffix:semicolon
id|parent
suffix:semicolon
id|parent
op_assign
id|parent-&gt;next
comma
id|num
op_increment
)paren
suffix:semicolon
multiline_comment|/* with enough slop */
id|strbuf_grow
c_func
(paren
id|sb
comma
id|num
op_star
l_int|50
op_plus
l_int|20
)paren
suffix:semicolon
id|add_merge_info
c_func
(paren
id|fmt
comma
id|sb
comma
id|commit
comma
id|abbrev
)paren
suffix:semicolon
id|parents_shown
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * MEDIUM == DEFAULT shows only author with dates.&n;&t;&t; * FULL shows both authors but not dates.&n;&t;&t; * FULLER shows both authors and dates.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|line
comma
l_string|&quot;author &quot;
comma
l_int|7
)paren
)paren
(brace
id|strbuf_grow
c_func
(paren
id|sb
comma
id|linelen
op_plus
l_int|80
)paren
suffix:semicolon
id|pp_user_info
c_func
(paren
l_string|&quot;Author&quot;
comma
id|fmt
comma
id|sb
comma
id|line
op_plus
l_int|7
comma
id|dmode
comma
id|encoding
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|line
comma
l_string|&quot;committer &quot;
comma
l_int|10
)paren
op_logical_and
(paren
id|fmt
op_eq
id|CMIT_FMT_FULL
op_logical_or
id|fmt
op_eq
id|CMIT_FMT_FULLER
)paren
)paren
(brace
id|strbuf_grow
c_func
(paren
id|sb
comma
id|linelen
op_plus
l_int|80
)paren
suffix:semicolon
id|pp_user_info
c_func
(paren
l_string|&quot;Commit&quot;
comma
id|fmt
comma
id|sb
comma
id|line
op_plus
l_int|10
comma
id|dmode
comma
id|encoding
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|pp_title_line
r_void
id|pp_title_line
c_func
(paren
r_enum
id|cmit_fmt
id|fmt
comma
r_const
r_char
op_star
op_star
id|msg_p
comma
r_struct
id|strbuf
op_star
id|sb
comma
r_const
r_char
op_star
id|subject
comma
r_const
r_char
op_star
id|after_subject
comma
r_const
r_char
op_star
id|encoding
comma
r_int
id|need_8bit_cte
)paren
(brace
r_struct
id|strbuf
id|title
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|title
comma
l_int|80
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_const
r_char
op_star
id|line
op_assign
op_star
id|msg_p
suffix:semicolon
r_int
id|linelen
op_assign
id|get_one_line
c_func
(paren
id|line
)paren
suffix:semicolon
op_star
id|msg_p
op_add_assign
id|linelen
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|linelen
op_logical_or
id|is_empty_line
c_func
(paren
id|line
comma
op_amp
id|linelen
)paren
)paren
r_break
suffix:semicolon
id|strbuf_grow
c_func
(paren
op_amp
id|title
comma
id|linelen
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|title.len
)paren
(brace
r_if
c_cond
(paren
id|fmt
op_eq
id|CMIT_FMT_EMAIL
)paren
(brace
id|strbuf_addch
c_func
(paren
op_amp
id|title
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
id|strbuf_addch
c_func
(paren
op_amp
id|title
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
)brace
id|strbuf_add
c_func
(paren
op_amp
id|title
comma
id|line
comma
id|linelen
)paren
suffix:semicolon
)brace
id|strbuf_grow
c_func
(paren
id|sb
comma
id|title.len
op_plus
l_int|1024
)paren
suffix:semicolon
r_if
c_cond
(paren
id|subject
)paren
(brace
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|subject
)paren
suffix:semicolon
id|add_rfc2047
c_func
(paren
id|sb
comma
id|title.buf
comma
id|title.len
comma
id|encoding
)paren
suffix:semicolon
)brace
r_else
(brace
id|strbuf_addbuf
c_func
(paren
id|sb
comma
op_amp
id|title
)paren
suffix:semicolon
)brace
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|need_8bit_cte
OG
l_int|0
)paren
(brace
r_const
r_char
op_star
id|header_fmt
op_assign
l_string|&quot;MIME-Version: 1.0&bslash;n&quot;
l_string|&quot;Content-Type: text/plain; charset=%s&bslash;n&quot;
l_string|&quot;Content-Transfer-Encoding: 8bit&bslash;n&quot;
suffix:semicolon
id|strbuf_addf
c_func
(paren
id|sb
comma
id|header_fmt
comma
id|encoding
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|after_subject
)paren
(brace
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|after_subject
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fmt
op_eq
id|CMIT_FMT_EMAIL
)paren
(brace
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
id|strbuf_release
c_func
(paren
op_amp
id|title
)paren
suffix:semicolon
)brace
DECL|function|pp_remainder
r_void
id|pp_remainder
c_func
(paren
r_enum
id|cmit_fmt
id|fmt
comma
r_const
r_char
op_star
op_star
id|msg_p
comma
r_struct
id|strbuf
op_star
id|sb
comma
r_int
id|indent
)paren
(brace
r_int
id|first
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_const
r_char
op_star
id|line
op_assign
op_star
id|msg_p
suffix:semicolon
r_int
id|linelen
op_assign
id|get_one_line
c_func
(paren
id|line
)paren
suffix:semicolon
op_star
id|msg_p
op_add_assign
id|linelen
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|linelen
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|is_empty_line
c_func
(paren
id|line
comma
op_amp
id|linelen
)paren
)paren
(brace
r_if
c_cond
(paren
id|first
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|fmt
op_eq
id|CMIT_FMT_SHORT
)paren
r_break
suffix:semicolon
)brace
id|first
op_assign
l_int|0
suffix:semicolon
id|strbuf_grow
c_func
(paren
id|sb
comma
id|linelen
op_plus
id|indent
op_plus
l_int|20
)paren
suffix:semicolon
r_if
c_cond
(paren
id|indent
)paren
(brace
id|memset
c_func
(paren
id|sb-&gt;buf
op_plus
id|sb-&gt;len
comma
l_char|&squot; &squot;
comma
id|indent
)paren
suffix:semicolon
id|strbuf_setlen
c_func
(paren
id|sb
comma
id|sb-&gt;len
op_plus
id|indent
)paren
suffix:semicolon
)brace
id|strbuf_add
c_func
(paren
id|sb
comma
id|line
comma
id|linelen
)paren
suffix:semicolon
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
)brace
DECL|function|pretty_print_commit
r_void
id|pretty_print_commit
c_func
(paren
r_enum
id|cmit_fmt
id|fmt
comma
r_const
r_struct
id|commit
op_star
id|commit
comma
r_struct
id|strbuf
op_star
id|sb
comma
r_int
id|abbrev
comma
r_const
r_char
op_star
id|subject
comma
r_const
r_char
op_star
id|after_subject
comma
r_enum
id|date_mode
id|dmode
comma
r_int
id|need_8bit_cte
)paren
(brace
r_int
r_int
id|beginning_of_body
suffix:semicolon
r_int
id|indent
op_assign
l_int|4
suffix:semicolon
r_const
r_char
op_star
id|msg
op_assign
id|commit-&gt;buffer
suffix:semicolon
r_char
op_star
id|reencoded
suffix:semicolon
r_const
r_char
op_star
id|encoding
suffix:semicolon
r_if
c_cond
(paren
id|fmt
op_eq
id|CMIT_FMT_USERFORMAT
)paren
(brace
id|format_commit_message
c_func
(paren
id|commit
comma
id|user_format
comma
id|sb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|encoding
op_assign
(paren
id|git_log_output_encoding
ques
c_cond
id|git_log_output_encoding
suffix:colon
id|git_commit_encoding
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|encoding
)paren
id|encoding
op_assign
l_string|&quot;utf-8&quot;
suffix:semicolon
id|reencoded
op_assign
id|logmsg_reencode
c_func
(paren
id|commit
comma
id|encoding
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reencoded
)paren
(brace
id|msg
op_assign
id|reencoded
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fmt
op_eq
id|CMIT_FMT_ONELINE
op_logical_or
id|fmt
op_eq
id|CMIT_FMT_EMAIL
)paren
id|indent
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * We need to check and emit Content-type: to mark it&n;&t; * as 8-bit if we haven&squot;t done so.&n;&t; */
r_if
c_cond
(paren
id|fmt
op_eq
id|CMIT_FMT_EMAIL
op_logical_and
id|need_8bit_cte
op_eq
l_int|0
)paren
(brace
r_int
id|i
comma
id|ch
comma
id|in_body
suffix:semicolon
r_for
c_loop
(paren
id|in_body
op_assign
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|ch
op_assign
id|msg
(braket
id|i
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|in_body
)paren
(brace
multiline_comment|/* author could be non 7-bit ASCII but&n;&t;&t;&t;&t; * the log may be so; skip over the&n;&t;&t;&t;&t; * header part first.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;&bslash;n&squot;
op_logical_and
id|msg
(braket
id|i
op_plus
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|in_body
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|non_ascii
c_func
(paren
id|ch
)paren
)paren
(brace
id|need_8bit_cte
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
id|pp_header
c_func
(paren
id|fmt
comma
id|abbrev
comma
id|dmode
comma
id|encoding
comma
id|commit
comma
op_amp
id|msg
comma
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fmt
op_ne
id|CMIT_FMT_ONELINE
op_logical_and
op_logical_neg
id|subject
)paren
(brace
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Skip excess blank lines at the beginning of body, if any... */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|linelen
op_assign
id|get_one_line
c_func
(paren
id|msg
)paren
suffix:semicolon
r_int
id|ll
op_assign
id|linelen
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|linelen
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_empty_line
c_func
(paren
id|msg
comma
op_amp
id|ll
)paren
)paren
r_break
suffix:semicolon
id|msg
op_add_assign
id|linelen
suffix:semicolon
)brace
multiline_comment|/* These formats treat the title line specially. */
r_if
c_cond
(paren
id|fmt
op_eq
id|CMIT_FMT_ONELINE
op_logical_or
id|fmt
op_eq
id|CMIT_FMT_EMAIL
)paren
id|pp_title_line
c_func
(paren
id|fmt
comma
op_amp
id|msg
comma
id|sb
comma
id|subject
comma
id|after_subject
comma
id|encoding
comma
id|need_8bit_cte
)paren
suffix:semicolon
id|beginning_of_body
op_assign
id|sb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|fmt
op_ne
id|CMIT_FMT_ONELINE
)paren
id|pp_remainder
c_func
(paren
id|fmt
comma
op_amp
id|msg
comma
id|sb
comma
id|indent
)paren
suffix:semicolon
id|strbuf_rtrim
c_func
(paren
id|sb
)paren
suffix:semicolon
multiline_comment|/* Make sure there is an EOLN for the non-oneline case */
r_if
c_cond
(paren
id|fmt
op_ne
id|CMIT_FMT_ONELINE
)paren
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The caller may append additional body text in e-mail&n;&t; * format.  Make sure we did not strip the blank line&n;&t; * between the header and the body.&n;&t; */
r_if
c_cond
(paren
id|fmt
op_eq
id|CMIT_FMT_EMAIL
op_logical_and
id|sb-&gt;len
op_le
id|beginning_of_body
)paren
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|free
c_func
(paren
id|reencoded
)paren
suffix:semicolon
)brace
eof
