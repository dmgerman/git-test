macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;commit.h&quot;
macro_line|#include &quot;utf8.h&quot;
macro_line|#include &quot;diff.h&quot;
macro_line|#include &quot;revision.h&quot;
DECL|struct|cmt_fmt_map
r_static
r_struct
id|cmt_fmt_map
(brace
DECL|member|n
r_const
r_char
op_star
id|n
suffix:semicolon
DECL|member|cmp_len
r_int
id|cmp_len
suffix:semicolon
DECL|member|v
r_enum
id|cmit_fmt
id|v
suffix:semicolon
DECL|variable|cmt_fmts
)brace
id|cmt_fmts
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;raw&quot;
comma
l_int|1
comma
id|CMIT_FMT_RAW
)brace
comma
(brace
l_string|&quot;medium&quot;
comma
l_int|1
comma
id|CMIT_FMT_MEDIUM
)brace
comma
(brace
l_string|&quot;short&quot;
comma
l_int|1
comma
id|CMIT_FMT_SHORT
)brace
comma
(brace
l_string|&quot;email&quot;
comma
l_int|1
comma
id|CMIT_FMT_EMAIL
)brace
comma
(brace
l_string|&quot;full&quot;
comma
l_int|5
comma
id|CMIT_FMT_FULL
)brace
comma
(brace
l_string|&quot;fuller&quot;
comma
l_int|5
comma
id|CMIT_FMT_FULLER
)brace
comma
(brace
l_string|&quot;oneline&quot;
comma
l_int|1
comma
id|CMIT_FMT_ONELINE
)brace
comma
(brace
l_string|&quot;format:&quot;
comma
l_int|7
comma
id|CMIT_FMT_USERFORMAT
)brace
comma
)brace
suffix:semicolon
DECL|variable|user_format
r_static
r_char
op_star
id|user_format
suffix:semicolon
DECL|function|get_commit_format
r_enum
id|cmit_fmt
id|get_commit_format
c_func
(paren
r_const
r_char
op_star
id|arg
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
op_logical_or
op_logical_neg
op_star
id|arg
)paren
r_return
id|CMIT_FMT_DEFAULT
suffix:semicolon
r_if
c_cond
(paren
op_star
id|arg
op_eq
l_char|&squot;=&squot;
)paren
id|arg
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;format:&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|user_format
)paren
id|free
c_func
(paren
id|user_format
)paren
suffix:semicolon
id|user_format
op_assign
id|xstrdup
c_func
(paren
id|arg
op_plus
l_int|7
)paren
suffix:semicolon
r_return
id|CMIT_FMT_USERFORMAT
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|cmt_fmts
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|arg
comma
id|cmt_fmts
(braket
id|i
)braket
dot
id|n
comma
id|cmt_fmts
(braket
id|i
)braket
dot
id|cmp_len
)paren
op_logical_and
op_logical_neg
id|strncmp
c_func
(paren
id|arg
comma
id|cmt_fmts
(braket
id|i
)braket
dot
id|n
comma
id|strlen
c_func
(paren
id|arg
)paren
)paren
)paren
r_return
id|cmt_fmts
(braket
id|i
)braket
dot
id|v
suffix:semicolon
)brace
id|die
c_func
(paren
l_string|&quot;invalid --pretty format: %s&quot;
comma
id|arg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Generic support for pretty-printing the header&n; */
DECL|function|get_one_line
r_static
r_int
id|get_one_line
c_func
(paren
r_const
r_char
op_star
id|msg
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_char
id|c
op_assign
op_star
id|msg
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
r_break
suffix:semicolon
id|ret
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* High bit set, or ISO-2022-INT */
DECL|function|non_ascii
r_int
id|non_ascii
c_func
(paren
r_int
id|ch
)paren
(brace
id|ch
op_assign
(paren
id|ch
op_amp
l_int|0xff
)paren
suffix:semicolon
r_return
(paren
(paren
id|ch
op_amp
l_int|0x80
)paren
op_logical_or
(paren
id|ch
op_eq
l_int|0x1b
)paren
)paren
suffix:semicolon
)brace
DECL|function|is_rfc2047_special
r_static
r_int
id|is_rfc2047_special
c_func
(paren
r_char
id|ch
)paren
(brace
r_return
(paren
id|non_ascii
c_func
(paren
id|ch
)paren
op_logical_or
(paren
id|ch
op_eq
l_char|&squot;=&squot;
)paren
op_logical_or
(paren
id|ch
op_eq
l_char|&squot;?&squot;
)paren
op_logical_or
(paren
id|ch
op_eq
l_char|&squot;_&squot;
)paren
)paren
suffix:semicolon
)brace
DECL|function|add_rfc2047
r_static
r_void
id|add_rfc2047
c_func
(paren
r_struct
id|strbuf
op_star
id|sb
comma
r_const
r_char
op_star
id|line
comma
r_int
id|len
comma
r_const
r_char
op_star
id|encoding
)paren
(brace
r_int
id|i
comma
id|last
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|ch
op_assign
id|line
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|non_ascii
c_func
(paren
id|ch
)paren
)paren
r_goto
id|needquote
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_plus
l_int|1
OL
id|len
)paren
op_logical_and
(paren
id|ch
op_eq
l_char|&squot;=&squot;
op_logical_and
id|line
(braket
id|i
op_plus
l_int|1
)braket
op_eq
l_char|&squot;?&squot;
)paren
)paren
r_goto
id|needquote
suffix:semicolon
)brace
id|strbuf_add
c_func
(paren
id|sb
comma
id|line
comma
id|len
)paren
suffix:semicolon
r_return
suffix:semicolon
id|needquote
suffix:colon
id|strbuf_grow
c_func
(paren
id|sb
comma
id|len
op_star
l_int|3
op_plus
id|strlen
c_func
(paren
id|encoding
)paren
op_plus
l_int|100
)paren
suffix:semicolon
id|strbuf_addf
c_func
(paren
id|sb
comma
l_string|&quot;=?%s?q?&quot;
comma
id|encoding
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|last
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|ch
op_assign
id|line
(braket
id|i
)braket
op_amp
l_int|0xFF
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We encode &squot; &squot; using &squot;=20&squot; even though rfc2047&n;&t;&t; * allows using &squot;_&squot; for readability.  Unfortunately,&n;&t;&t; * many programs do not understand this and just&n;&t;&t; * leave the underscore in place.&n;&t;&t; */
r_if
c_cond
(paren
id|is_rfc2047_special
c_func
(paren
id|ch
)paren
op_logical_or
id|ch
op_eq
l_char|&squot; &squot;
)paren
(brace
id|strbuf_add
c_func
(paren
id|sb
comma
id|line
op_plus
id|last
comma
id|i
id|last
)paren
suffix:semicolon
id|strbuf_addf
c_func
(paren
id|sb
comma
l_string|&quot;=%02X&quot;
comma
id|ch
)paren
suffix:semicolon
id|last
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
)brace
)brace
id|strbuf_add
c_func
(paren
id|sb
comma
id|line
op_plus
id|last
comma
id|len
id|last
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
id|sb
comma
l_string|&quot;?=&quot;
)paren
suffix:semicolon
)brace
DECL|function|add_user_info
r_static
r_void
id|add_user_info
c_func
(paren
r_const
r_char
op_star
id|what
comma
r_enum
id|cmit_fmt
id|fmt
comma
r_struct
id|strbuf
op_star
id|sb
comma
r_const
r_char
op_star
id|line
comma
r_enum
id|date_mode
id|dmode
comma
r_const
r_char
op_star
id|encoding
)paren
(brace
r_char
op_star
id|date
suffix:semicolon
r_int
id|namelen
suffix:semicolon
r_int
r_int
id|time
suffix:semicolon
r_int
id|tz
suffix:semicolon
r_const
r_char
op_star
id|filler
op_assign
l_string|&quot;    &quot;
suffix:semicolon
r_if
c_cond
(paren
id|fmt
op_eq
id|CMIT_FMT_ONELINE
)paren
r_return
suffix:semicolon
id|date
op_assign
id|strchr
c_func
(paren
id|line
comma
l_char|&squot;&gt;&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|date
)paren
r_return
suffix:semicolon
id|namelen
op_assign
op_increment
id|date
id|line
suffix:semicolon
id|time
op_assign
id|strtoul
c_func
(paren
id|date
comma
op_amp
id|date
comma
l_int|10
)paren
suffix:semicolon
id|tz
op_assign
id|strtol
c_func
(paren
id|date
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fmt
op_eq
id|CMIT_FMT_EMAIL
)paren
(brace
r_char
op_star
id|name_tail
op_assign
id|strchr
c_func
(paren
id|line
comma
l_char|&squot;&lt;&squot;
)paren
suffix:semicolon
r_int
id|display_name_length
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|name_tail
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
id|line
OL
id|name_tail
op_logical_and
id|isspace
c_func
(paren
id|name_tail
(braket
l_int|1
)braket
)paren
)paren
id|name_tail
op_decrement
suffix:semicolon
id|display_name_length
op_assign
id|name_tail
id|line
suffix:semicolon
id|filler
op_assign
l_string|&quot;&quot;
suffix:semicolon
id|strbuf_addstr
c_func
(paren
id|sb
comma
l_string|&quot;From: &quot;
)paren
suffix:semicolon
id|add_rfc2047
c_func
(paren
id|sb
comma
id|line
comma
id|display_name_length
comma
id|encoding
)paren
suffix:semicolon
id|strbuf_add
c_func
(paren
id|sb
comma
id|name_tail
comma
id|namelen
id|display_name_length
)paren
suffix:semicolon
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|strbuf_addf
c_func
(paren
id|sb
comma
l_string|&quot;%s: %.*s%.*s&bslash;n&quot;
comma
id|what
comma
(paren
id|fmt
op_eq
id|CMIT_FMT_FULLER
)paren
ques
c_cond
l_int|4
suffix:colon
l_int|0
comma
id|filler
comma
id|namelen
comma
id|line
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|fmt
)paren
(brace
r_case
id|CMIT_FMT_MEDIUM
suffix:colon
id|strbuf_addf
c_func
(paren
id|sb
comma
l_string|&quot;Date:   %s&bslash;n&quot;
comma
id|show_date
c_func
(paren
id|time
comma
id|tz
comma
id|dmode
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CMIT_FMT_EMAIL
suffix:colon
id|strbuf_addf
c_func
(paren
id|sb
comma
l_string|&quot;Date: %s&bslash;n&quot;
comma
id|show_date
c_func
(paren
id|time
comma
id|tz
comma
id|DATE_RFC2822
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CMIT_FMT_FULLER
suffix:colon
id|strbuf_addf
c_func
(paren
id|sb
comma
l_string|&quot;%sDate: %s&bslash;n&quot;
comma
id|what
comma
id|show_date
c_func
(paren
id|time
comma
id|tz
comma
id|dmode
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* notin&squot; */
r_break
suffix:semicolon
)brace
)brace
DECL|function|is_empty_line
r_static
r_int
id|is_empty_line
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_int
op_star
id|len_p
)paren
(brace
r_int
id|len
op_assign
op_star
id|len_p
suffix:semicolon
r_while
c_loop
(paren
id|len
op_logical_and
id|isspace
c_func
(paren
id|line
(braket
id|len
op_minus
l_int|1
)braket
)paren
)paren
id|len
op_decrement
suffix:semicolon
op_star
id|len_p
op_assign
id|len
suffix:semicolon
r_return
op_logical_neg
id|len
suffix:semicolon
)brace
DECL|function|add_merge_info
r_static
r_void
id|add_merge_info
c_func
(paren
r_enum
id|cmit_fmt
id|fmt
comma
r_struct
id|strbuf
op_star
id|sb
comma
r_const
r_struct
id|commit
op_star
id|commit
comma
r_int
id|abbrev
)paren
(brace
r_struct
id|commit_list
op_star
id|parent
op_assign
id|commit-&gt;parents
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fmt
op_eq
id|CMIT_FMT_ONELINE
)paren
op_logical_or
(paren
id|fmt
op_eq
id|CMIT_FMT_EMAIL
)paren
op_logical_or
op_logical_neg
id|parent
op_logical_or
op_logical_neg
id|parent-&gt;next
)paren
r_return
suffix:semicolon
id|strbuf_addstr
c_func
(paren
id|sb
comma
l_string|&quot;Merge:&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|parent
)paren
(brace
r_struct
id|commit
op_star
id|p
op_assign
id|parent-&gt;item
suffix:semicolon
r_const
r_char
op_star
id|hex
op_assign
l_int|NULL
suffix:semicolon
r_const
r_char
op_star
id|dots
suffix:semicolon
r_if
c_cond
(paren
id|abbrev
)paren
id|hex
op_assign
id|find_unique_abbrev
c_func
(paren
id|p-&gt;object.sha1
comma
id|abbrev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hex
)paren
id|hex
op_assign
id|sha1_to_hex
c_func
(paren
id|p-&gt;object.sha1
)paren
suffix:semicolon
id|dots
op_assign
(paren
id|abbrev
op_logical_and
id|strlen
c_func
(paren
id|hex
)paren
op_ne
l_int|40
)paren
ques
c_cond
l_string|&quot;...&quot;
suffix:colon
l_string|&quot;&quot;
suffix:semicolon
id|parent
op_assign
id|parent-&gt;next
suffix:semicolon
id|strbuf_addf
c_func
(paren
id|sb
comma
l_string|&quot; %s%s&quot;
comma
id|hex
comma
id|dots
)paren
suffix:semicolon
)brace
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
DECL|function|get_header
r_static
r_char
op_star
id|get_header
c_func
(paren
r_const
r_struct
id|commit
op_star
id|commit
comma
r_const
r_char
op_star
id|key
)paren
(brace
r_int
id|key_len
op_assign
id|strlen
c_func
(paren
id|key
)paren
suffix:semicolon
r_const
r_char
op_star
id|line
op_assign
id|commit-&gt;buffer
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_const
r_char
op_star
id|eol
op_assign
id|strchr
c_func
(paren
id|line
comma
l_char|&squot;&bslash;n&squot;
)paren
comma
op_star
id|next
suffix:semicolon
r_if
c_cond
(paren
id|line
op_eq
id|eol
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|eol
)paren
(brace
id|eol
op_assign
id|line
op_plus
id|strlen
c_func
(paren
id|line
)paren
suffix:semicolon
id|next
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
id|next
op_assign
id|eol
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|eol
id|line
OG
id|key_len
op_logical_and
op_logical_neg
id|strncmp
c_func
(paren
id|line
comma
id|key
comma
id|key_len
)paren
op_logical_and
id|line
(braket
id|key_len
)braket
op_eq
l_char|&squot; &squot;
)paren
(brace
r_return
id|xmemdupz
c_func
(paren
id|line
op_plus
id|key_len
op_plus
l_int|1
comma
id|eol
id|line
id|key_len
l_int|1
)paren
suffix:semicolon
)brace
id|line
op_assign
id|next
suffix:semicolon
)brace
)brace
DECL|function|replace_encoding_header
r_static
r_char
op_star
id|replace_encoding_header
c_func
(paren
r_char
op_star
id|buf
comma
r_const
r_char
op_star
id|encoding
)paren
(brace
r_struct
id|strbuf
id|tmp
suffix:semicolon
r_int
id|start
comma
id|len
suffix:semicolon
r_char
op_star
id|cp
op_assign
id|buf
suffix:semicolon
multiline_comment|/* guess if there is an encoding header before a &bslash;n&bslash;n */
r_while
c_loop
(paren
id|strncmp
c_func
(paren
id|cp
comma
l_string|&quot;encoding &quot;
comma
id|strlen
c_func
(paren
l_string|&quot;encoding &quot;
)paren
)paren
)paren
(brace
id|cp
op_assign
id|strchr
c_func
(paren
id|cp
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
op_logical_or
op_star
op_increment
id|cp
op_eq
l_char|&squot;&bslash;n&squot;
)paren
r_return
id|buf
suffix:semicolon
)brace
id|start
op_assign
id|cp
id|buf
suffix:semicolon
id|cp
op_assign
id|strchr
c_func
(paren
id|cp
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_return
id|buf
suffix:semicolon
multiline_comment|/* should not happen but be defensive */
id|len
op_assign
id|cp
op_plus
l_int|1
(paren
id|buf
op_plus
id|start
)paren
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|tmp
comma
l_int|0
)paren
suffix:semicolon
id|strbuf_attach
c_func
(paren
op_amp
id|tmp
comma
id|buf
comma
id|strlen
c_func
(paren
id|buf
)paren
comma
id|strlen
c_func
(paren
id|buf
)paren
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_encoding_utf8
c_func
(paren
id|encoding
)paren
)paren
(brace
multiline_comment|/* we have re-coded to UTF-8; drop the header */
id|strbuf_remove
c_func
(paren
op_amp
id|tmp
comma
id|start
comma
id|len
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* just replaces XXXX in &squot;encoding XXXX&bslash;n&squot; */
id|strbuf_splice
c_func
(paren
op_amp
id|tmp
comma
id|start
op_plus
id|strlen
c_func
(paren
l_string|&quot;encoding &quot;
)paren
comma
id|len
id|strlen
c_func
(paren
l_string|&quot;encoding &bslash;n&quot;
)paren
comma
id|encoding
comma
id|strlen
c_func
(paren
id|encoding
)paren
)paren
suffix:semicolon
)brace
r_return
id|strbuf_detach
c_func
(paren
op_amp
id|tmp
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|logmsg_reencode
r_static
r_char
op_star
id|logmsg_reencode
c_func
(paren
r_const
r_struct
id|commit
op_star
id|commit
comma
r_const
r_char
op_star
id|output_encoding
)paren
(brace
r_static
r_const
r_char
op_star
id|utf8
op_assign
l_string|&quot;utf-8&quot;
suffix:semicolon
r_const
r_char
op_star
id|use_encoding
suffix:semicolon
r_char
op_star
id|encoding
suffix:semicolon
r_char
op_star
id|out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|output_encoding
)paren
r_return
l_int|NULL
suffix:semicolon
id|encoding
op_assign
id|get_header
c_func
(paren
id|commit
comma
l_string|&quot;encoding&quot;
)paren
suffix:semicolon
id|use_encoding
op_assign
id|encoding
ques
c_cond
id|encoding
suffix:colon
id|utf8
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|use_encoding
comma
id|output_encoding
)paren
)paren
r_if
c_cond
(paren
id|encoding
)paren
multiline_comment|/* we&squot;ll strip encoding header later */
id|out
op_assign
id|xstrdup
c_func
(paren
id|commit-&gt;buffer
)paren
suffix:semicolon
r_else
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* nothing to do */
r_else
id|out
op_assign
id|reencode_string
c_func
(paren
id|commit-&gt;buffer
comma
id|output_encoding
comma
id|use_encoding
)paren
suffix:semicolon
r_if
c_cond
(paren
id|out
)paren
id|out
op_assign
id|replace_encoding_header
c_func
(paren
id|out
comma
id|output_encoding
)paren
suffix:semicolon
id|free
c_func
(paren
id|encoding
)paren
suffix:semicolon
r_return
id|out
suffix:semicolon
)brace
DECL|function|format_person_part
r_static
r_void
id|format_person_part
c_func
(paren
r_struct
id|strbuf
op_star
id|sb
comma
r_char
id|part
comma
r_const
r_char
op_star
id|msg
comma
r_int
id|len
)paren
(brace
r_int
id|start
comma
id|end
comma
id|tz
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|date
suffix:semicolon
r_char
op_star
id|ep
suffix:semicolon
multiline_comment|/* parse name */
r_for
c_loop
(paren
id|end
op_assign
l_int|0
suffix:semicolon
id|end
OL
id|len
op_logical_and
id|msg
(braket
id|end
)braket
op_ne
l_char|&squot;&lt;&squot;
suffix:semicolon
id|end
op_increment
)paren
suffix:semicolon
multiline_comment|/* do nothing */
id|start
op_assign
id|end
op_plus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|end
OG
l_int|0
op_logical_and
id|isspace
c_func
(paren
id|msg
(braket
id|end
l_int|1
)braket
)paren
)paren
id|end
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|part
op_eq
l_char|&squot;n&squot;
)paren
(brace
multiline_comment|/* name */
id|strbuf_add
c_func
(paren
id|sb
comma
id|msg
comma
id|end
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|start
op_ge
id|len
)paren
r_return
suffix:semicolon
multiline_comment|/* parse email */
r_for
c_loop
(paren
id|end
op_assign
id|start
op_plus
l_int|1
suffix:semicolon
id|end
OL
id|len
op_logical_and
id|msg
(braket
id|end
)braket
op_ne
l_char|&squot;&gt;&squot;
suffix:semicolon
id|end
op_increment
)paren
suffix:semicolon
multiline_comment|/* do nothing */
r_if
c_cond
(paren
id|end
op_ge
id|len
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|part
op_eq
l_char|&squot;e&squot;
)paren
(brace
multiline_comment|/* email */
id|strbuf_add
c_func
(paren
id|sb
comma
id|msg
op_plus
id|start
comma
id|end
id|start
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* parse date */
r_for
c_loop
(paren
id|start
op_assign
id|end
op_plus
l_int|1
suffix:semicolon
id|start
OL
id|len
op_logical_and
id|isspace
c_func
(paren
id|msg
(braket
id|start
)braket
)paren
suffix:semicolon
id|start
op_increment
)paren
suffix:semicolon
multiline_comment|/* do nothing */
r_if
c_cond
(paren
id|start
op_ge
id|len
)paren
r_return
suffix:semicolon
id|date
op_assign
id|strtoul
c_func
(paren
id|msg
op_plus
id|start
comma
op_amp
id|ep
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg
op_plus
id|start
op_eq
id|ep
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|part
op_eq
l_char|&squot;t&squot;
)paren
(brace
multiline_comment|/* date, UNIX timestamp */
id|strbuf_add
c_func
(paren
id|sb
comma
id|msg
op_plus
id|start
comma
id|ep
(paren
id|msg
op_plus
id|start
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* parse tz */
r_for
c_loop
(paren
id|start
op_assign
id|ep
id|msg
op_plus
l_int|1
suffix:semicolon
id|start
OL
id|len
op_logical_and
id|isspace
c_func
(paren
id|msg
(braket
id|start
)braket
)paren
suffix:semicolon
id|start
op_increment
)paren
suffix:semicolon
multiline_comment|/* do nothing */
r_if
c_cond
(paren
id|start
op_plus
l_int|1
OL
id|len
)paren
(brace
id|tz
op_assign
id|strtoul
c_func
(paren
id|msg
op_plus
id|start
op_plus
l_int|1
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg
(braket
id|start
)braket
op_eq
l_char|&squot;-&squot;
)paren
id|tz
op_assign
id|tz
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|part
)paren
(brace
r_case
l_char|&squot;d&squot;
suffix:colon
multiline_comment|/* date */
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|show_date
c_func
(paren
id|date
comma
id|tz
comma
id|DATE_NORMAL
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_char|&squot;D&squot;
suffix:colon
multiline_comment|/* date, RFC2822 style */
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|show_date
c_func
(paren
id|date
comma
id|tz
comma
id|DATE_RFC2822
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_char|&squot;r&squot;
suffix:colon
multiline_comment|/* date, relative */
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|show_date
c_func
(paren
id|date
comma
id|tz
comma
id|DATE_RELATIVE
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_char|&squot;i&squot;
suffix:colon
multiline_comment|/* date, ISO 8601 */
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|show_date
c_func
(paren
id|date
comma
id|tz
comma
id|DATE_ISO8601
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
DECL|struct|chunk
r_struct
id|chunk
(brace
DECL|member|off
r_int
id|off
suffix:semicolon
DECL|member|len
r_int
id|len
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|format_commit_context
r_struct
id|format_commit_context
(brace
DECL|member|commit
r_const
r_struct
id|commit
op_star
id|commit
suffix:semicolon
multiline_comment|/* These offsets are relative to the start of the commit message. */
DECL|member|commit_header_parsed
r_int
id|commit_header_parsed
suffix:semicolon
DECL|member|subject
r_struct
id|chunk
id|subject
suffix:semicolon
DECL|member|author
r_struct
id|chunk
id|author
suffix:semicolon
DECL|member|committer
r_struct
id|chunk
id|committer
suffix:semicolon
DECL|member|encoding
r_struct
id|chunk
id|encoding
suffix:semicolon
DECL|member|body_off
r_int
id|body_off
suffix:semicolon
)brace
suffix:semicolon
DECL|function|parse_commit_header
r_static
r_void
id|parse_commit_header
c_func
(paren
r_struct
id|format_commit_context
op_star
id|context
)paren
(brace
r_const
r_char
op_star
id|msg
op_assign
id|context-&gt;commit-&gt;buffer
suffix:semicolon
r_int
id|i
suffix:semicolon
r_enum
(brace
id|HEADER
comma
id|SUBJECT
comma
id|BODY
)brace
id|state
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|state
op_assign
id|HEADER
suffix:semicolon
id|msg
(braket
id|i
)braket
op_logical_and
id|state
OL
id|BODY
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|eol
suffix:semicolon
r_for
c_loop
(paren
id|eol
op_assign
id|i
suffix:semicolon
id|msg
(braket
id|eol
)braket
op_logical_and
id|msg
(braket
id|eol
)braket
op_ne
l_char|&squot;&bslash;n&squot;
suffix:semicolon
id|eol
op_increment
)paren
suffix:semicolon
multiline_comment|/* do nothing */
r_if
c_cond
(paren
id|state
op_eq
id|SUBJECT
)paren
(brace
id|context-&gt;subject.off
op_assign
id|i
suffix:semicolon
id|context-&gt;subject.len
op_assign
id|eol
id|i
suffix:semicolon
id|i
op_assign
id|eol
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
id|eol
)paren
(brace
id|state
op_increment
suffix:semicolon
multiline_comment|/* strip empty lines */
r_while
c_loop
(paren
id|msg
(braket
id|eol
op_plus
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|eol
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|msg
op_plus
id|i
comma
l_string|&quot;author &quot;
)paren
)paren
(brace
id|context-&gt;author.off
op_assign
id|i
op_plus
l_int|7
suffix:semicolon
id|context-&gt;author.len
op_assign
id|eol
id|i
l_int|7
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|msg
op_plus
id|i
comma
l_string|&quot;committer &quot;
)paren
)paren
(brace
id|context-&gt;committer.off
op_assign
id|i
op_plus
l_int|10
suffix:semicolon
id|context-&gt;committer.len
op_assign
id|eol
id|i
l_int|10
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|msg
op_plus
id|i
comma
l_string|&quot;encoding &quot;
)paren
)paren
(brace
id|context-&gt;encoding.off
op_assign
id|i
op_plus
l_int|9
suffix:semicolon
id|context-&gt;encoding.len
op_assign
id|eol
id|i
l_int|9
suffix:semicolon
)brace
id|i
op_assign
id|eol
suffix:semicolon
)brace
id|context-&gt;body_off
op_assign
id|i
suffix:semicolon
id|context-&gt;commit_header_parsed
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|format_commit_item
r_static
r_void
id|format_commit_item
c_func
(paren
r_struct
id|strbuf
op_star
id|sb
comma
r_const
r_char
op_star
id|placeholder
comma
r_void
op_star
id|context
)paren
(brace
r_struct
id|format_commit_context
op_star
id|c
op_assign
id|context
suffix:semicolon
r_const
r_struct
id|commit
op_star
id|commit
op_assign
id|c-&gt;commit
suffix:semicolon
r_const
r_char
op_star
id|msg
op_assign
id|commit-&gt;buffer
suffix:semicolon
r_struct
id|commit_list
op_star
id|p
suffix:semicolon
multiline_comment|/* these are independent of the commit */
r_switch
c_cond
(paren
id|placeholder
(braket
l_int|0
)braket
)paren
(brace
r_case
l_char|&squot;C&squot;
suffix:colon
r_switch
c_cond
(paren
id|placeholder
(braket
l_int|3
)braket
)paren
(brace
r_case
l_char|&squot;d&squot;
suffix:colon
multiline_comment|/* red */
id|strbuf_addstr
c_func
(paren
id|sb
comma
l_string|&quot;&bslash;033[31m&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_char|&squot;e&squot;
suffix:colon
multiline_comment|/* green */
id|strbuf_addstr
c_func
(paren
id|sb
comma
l_string|&quot;&bslash;033[32m&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_char|&squot;u&squot;
suffix:colon
multiline_comment|/* blue */
id|strbuf_addstr
c_func
(paren
id|sb
comma
l_string|&quot;&bslash;033[34m&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_char|&squot;s&squot;
suffix:colon
multiline_comment|/* reset color */
id|strbuf_addstr
c_func
(paren
id|sb
comma
l_string|&quot;&bslash;033[m&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_case
l_char|&squot;n&squot;
suffix:colon
multiline_comment|/* newline */
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* these depend on the commit */
r_if
c_cond
(paren
op_logical_neg
id|commit-&gt;object.parsed
)paren
id|parse_object
c_func
(paren
id|commit-&gt;object.sha1
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|placeholder
(braket
l_int|0
)braket
)paren
(brace
r_case
l_char|&squot;H&squot;
suffix:colon
multiline_comment|/* commit hash */
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|sha1_to_hex
c_func
(paren
id|commit-&gt;object.sha1
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_char|&squot;h&squot;
suffix:colon
multiline_comment|/* abbreviated commit hash */
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|find_unique_abbrev
c_func
(paren
id|commit-&gt;object.sha1
comma
id|DEFAULT_ABBREV
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_char|&squot;T&squot;
suffix:colon
multiline_comment|/* tree hash */
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|sha1_to_hex
c_func
(paren
id|commit-&gt;tree-&gt;object.sha1
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_char|&squot;t&squot;
suffix:colon
multiline_comment|/* abbreviated tree hash */
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|find_unique_abbrev
c_func
(paren
id|commit-&gt;tree-&gt;object.sha1
comma
id|DEFAULT_ABBREV
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_char|&squot;P&squot;
suffix:colon
multiline_comment|/* parent hashes */
r_for
c_loop
(paren
id|p
op_assign
id|commit-&gt;parents
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|p
op_ne
id|commit-&gt;parents
)paren
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|sha1_to_hex
c_func
(paren
id|p-&gt;item-&gt;object.sha1
)paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
r_case
l_char|&squot;p&squot;
suffix:colon
multiline_comment|/* abbreviated parent hashes */
r_for
c_loop
(paren
id|p
op_assign
id|commit-&gt;parents
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|p
op_ne
id|commit-&gt;parents
)paren
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|find_unique_abbrev
c_func
(paren
id|p-&gt;item-&gt;object.sha1
comma
id|DEFAULT_ABBREV
)paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
r_case
l_char|&squot;m&squot;
suffix:colon
multiline_comment|/* left/right/bottom */
id|strbuf_addch
c_func
(paren
id|sb
comma
(paren
id|commit-&gt;object.flags
op_amp
id|BOUNDARY
)paren
ques
c_cond
l_char|&squot;-&squot;
suffix:colon
(paren
id|commit-&gt;object.flags
op_amp
id|SYMMETRIC_LEFT
)paren
ques
c_cond
l_char|&squot;&lt;&squot;
suffix:colon
l_char|&squot;&gt;&squot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* For the rest we have to parse the commit header. */
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;commit_header_parsed
)paren
id|parse_commit_header
c_func
(paren
id|c
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|placeholder
(braket
l_int|0
)braket
)paren
(brace
r_case
l_char|&squot;s&squot;
suffix:colon
id|strbuf_add
c_func
(paren
id|sb
comma
id|msg
op_plus
id|c-&gt;subject.off
comma
id|c-&gt;subject.len
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_char|&squot;a&squot;
suffix:colon
id|format_person_part
c_func
(paren
id|sb
comma
id|placeholder
(braket
l_int|1
)braket
comma
id|msg
op_plus
id|c-&gt;author.off
comma
id|c-&gt;author.len
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_char|&squot;c&squot;
suffix:colon
id|format_person_part
c_func
(paren
id|sb
comma
id|placeholder
(braket
l_int|1
)braket
comma
id|msg
op_plus
id|c-&gt;committer.off
comma
id|c-&gt;committer.len
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_char|&squot;e&squot;
suffix:colon
id|strbuf_add
c_func
(paren
id|sb
comma
id|msg
op_plus
id|c-&gt;encoding.off
comma
id|c-&gt;encoding.len
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_char|&squot;b&squot;
suffix:colon
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|msg
op_plus
id|c-&gt;body_off
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
DECL|function|format_commit_message
r_void
id|format_commit_message
c_func
(paren
r_const
r_struct
id|commit
op_star
id|commit
comma
r_const
r_void
op_star
id|format
comma
r_struct
id|strbuf
op_star
id|sb
)paren
(brace
r_const
r_char
op_star
id|placeholders
(braket
)braket
op_assign
(brace
l_string|&quot;H&quot;
comma
multiline_comment|/* commit hash */
l_string|&quot;h&quot;
comma
multiline_comment|/* abbreviated commit hash */
l_string|&quot;T&quot;
comma
multiline_comment|/* tree hash */
l_string|&quot;t&quot;
comma
multiline_comment|/* abbreviated tree hash */
l_string|&quot;P&quot;
comma
multiline_comment|/* parent hashes */
l_string|&quot;p&quot;
comma
multiline_comment|/* abbreviated parent hashes */
l_string|&quot;an&quot;
comma
multiline_comment|/* author name */
l_string|&quot;ae&quot;
comma
multiline_comment|/* author email */
l_string|&quot;ad&quot;
comma
multiline_comment|/* author date */
l_string|&quot;aD&quot;
comma
multiline_comment|/* author date, RFC2822 style */
l_string|&quot;ar&quot;
comma
multiline_comment|/* author date, relative */
l_string|&quot;at&quot;
comma
multiline_comment|/* author date, UNIX timestamp */
l_string|&quot;ai&quot;
comma
multiline_comment|/* author date, ISO 8601 */
l_string|&quot;cn&quot;
comma
multiline_comment|/* committer name */
l_string|&quot;ce&quot;
comma
multiline_comment|/* committer email */
l_string|&quot;cd&quot;
comma
multiline_comment|/* committer date */
l_string|&quot;cD&quot;
comma
multiline_comment|/* committer date, RFC2822 style */
l_string|&quot;cr&quot;
comma
multiline_comment|/* committer date, relative */
l_string|&quot;ct&quot;
comma
multiline_comment|/* committer date, UNIX timestamp */
l_string|&quot;ci&quot;
comma
multiline_comment|/* committer date, ISO 8601 */
l_string|&quot;e&quot;
comma
multiline_comment|/* encoding */
l_string|&quot;s&quot;
comma
multiline_comment|/* subject */
l_string|&quot;b&quot;
comma
multiline_comment|/* body */
l_string|&quot;Cred&quot;
comma
multiline_comment|/* red */
l_string|&quot;Cgreen&quot;
comma
multiline_comment|/* green */
l_string|&quot;Cblue&quot;
comma
multiline_comment|/* blue */
l_string|&quot;Creset&quot;
comma
multiline_comment|/* reset color */
l_string|&quot;n&quot;
comma
multiline_comment|/* newline */
l_string|&quot;m&quot;
comma
multiline_comment|/* left/right/bottom */
l_int|NULL
)brace
suffix:semicolon
r_struct
id|format_commit_context
id|context
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|context
comma
l_int|0
comma
r_sizeof
(paren
id|context
)paren
)paren
suffix:semicolon
id|context.commit
op_assign
id|commit
suffix:semicolon
id|strbuf_expand
c_func
(paren
id|sb
comma
id|format
comma
id|placeholders
comma
id|format_commit_item
comma
op_amp
id|context
)paren
suffix:semicolon
)brace
DECL|function|pp_header
r_static
r_void
id|pp_header
c_func
(paren
r_enum
id|cmit_fmt
id|fmt
comma
r_int
id|abbrev
comma
r_enum
id|date_mode
id|dmode
comma
r_const
r_char
op_star
id|encoding
comma
r_const
r_struct
id|commit
op_star
id|commit
comma
r_const
r_char
op_star
op_star
id|msg_p
comma
r_struct
id|strbuf
op_star
id|sb
)paren
(brace
r_int
id|parents_shown
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_const
r_char
op_star
id|line
op_assign
op_star
id|msg_p
suffix:semicolon
r_int
id|linelen
op_assign
id|get_one_line
c_func
(paren
op_star
id|msg_p
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|linelen
)paren
r_return
suffix:semicolon
op_star
id|msg_p
op_add_assign
id|linelen
suffix:semicolon
r_if
c_cond
(paren
id|linelen
op_eq
l_int|1
)paren
multiline_comment|/* End of header */
r_return
suffix:semicolon
r_if
c_cond
(paren
id|fmt
op_eq
id|CMIT_FMT_RAW
)paren
(brace
id|strbuf_add
c_func
(paren
id|sb
comma
id|line
comma
id|linelen
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|line
comma
l_string|&quot;parent &quot;
comma
l_int|7
)paren
)paren
(brace
r_if
c_cond
(paren
id|linelen
op_ne
l_int|48
)paren
id|die
c_func
(paren
l_string|&quot;bad parent line in commit&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|parents_shown
)paren
(brace
r_struct
id|commit_list
op_star
id|parent
suffix:semicolon
r_int
id|num
suffix:semicolon
r_for
c_loop
(paren
id|parent
op_assign
id|commit-&gt;parents
comma
id|num
op_assign
l_int|0
suffix:semicolon
id|parent
suffix:semicolon
id|parent
op_assign
id|parent-&gt;next
comma
id|num
op_increment
)paren
suffix:semicolon
multiline_comment|/* with enough slop */
id|strbuf_grow
c_func
(paren
id|sb
comma
id|num
op_star
l_int|50
op_plus
l_int|20
)paren
suffix:semicolon
id|add_merge_info
c_func
(paren
id|fmt
comma
id|sb
comma
id|commit
comma
id|abbrev
)paren
suffix:semicolon
id|parents_shown
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * MEDIUM == DEFAULT shows only author with dates.&n;&t;&t; * FULL shows both authors but not dates.&n;&t;&t; * FULLER shows both authors and dates.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|line
comma
l_string|&quot;author &quot;
comma
l_int|7
)paren
)paren
(brace
id|strbuf_grow
c_func
(paren
id|sb
comma
id|linelen
op_plus
l_int|80
)paren
suffix:semicolon
id|add_user_info
c_func
(paren
l_string|&quot;Author&quot;
comma
id|fmt
comma
id|sb
comma
id|line
op_plus
l_int|7
comma
id|dmode
comma
id|encoding
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|line
comma
l_string|&quot;committer &quot;
comma
l_int|10
)paren
op_logical_and
(paren
id|fmt
op_eq
id|CMIT_FMT_FULL
op_logical_or
id|fmt
op_eq
id|CMIT_FMT_FULLER
)paren
)paren
(brace
id|strbuf_grow
c_func
(paren
id|sb
comma
id|linelen
op_plus
l_int|80
)paren
suffix:semicolon
id|add_user_info
c_func
(paren
l_string|&quot;Commit&quot;
comma
id|fmt
comma
id|sb
comma
id|line
op_plus
l_int|10
comma
id|dmode
comma
id|encoding
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|pp_title_line
r_static
r_void
id|pp_title_line
c_func
(paren
r_enum
id|cmit_fmt
id|fmt
comma
r_const
r_char
op_star
op_star
id|msg_p
comma
r_struct
id|strbuf
op_star
id|sb
comma
r_const
r_char
op_star
id|subject
comma
r_const
r_char
op_star
id|after_subject
comma
r_const
r_char
op_star
id|encoding
comma
r_int
id|plain_non_ascii
)paren
(brace
r_struct
id|strbuf
id|title
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|title
comma
l_int|80
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_const
r_char
op_star
id|line
op_assign
op_star
id|msg_p
suffix:semicolon
r_int
id|linelen
op_assign
id|get_one_line
c_func
(paren
id|line
)paren
suffix:semicolon
op_star
id|msg_p
op_add_assign
id|linelen
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|linelen
op_logical_or
id|is_empty_line
c_func
(paren
id|line
comma
op_amp
id|linelen
)paren
)paren
r_break
suffix:semicolon
id|strbuf_grow
c_func
(paren
op_amp
id|title
comma
id|linelen
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|title.len
)paren
(brace
r_if
c_cond
(paren
id|fmt
op_eq
id|CMIT_FMT_EMAIL
)paren
(brace
id|strbuf_addch
c_func
(paren
op_amp
id|title
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
id|strbuf_addch
c_func
(paren
op_amp
id|title
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
)brace
id|strbuf_add
c_func
(paren
op_amp
id|title
comma
id|line
comma
id|linelen
)paren
suffix:semicolon
)brace
id|strbuf_grow
c_func
(paren
id|sb
comma
id|title.len
op_plus
l_int|1024
)paren
suffix:semicolon
r_if
c_cond
(paren
id|subject
)paren
(brace
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|subject
)paren
suffix:semicolon
id|add_rfc2047
c_func
(paren
id|sb
comma
id|title.buf
comma
id|title.len
comma
id|encoding
)paren
suffix:semicolon
)brace
r_else
(brace
id|strbuf_addbuf
c_func
(paren
id|sb
comma
op_amp
id|title
)paren
suffix:semicolon
)brace
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|plain_non_ascii
)paren
(brace
r_const
r_char
op_star
id|header_fmt
op_assign
l_string|&quot;MIME-Version: 1.0&bslash;n&quot;
l_string|&quot;Content-Type: text/plain; charset=%s&bslash;n&quot;
l_string|&quot;Content-Transfer-Encoding: 8bit&bslash;n&quot;
suffix:semicolon
id|strbuf_addf
c_func
(paren
id|sb
comma
id|header_fmt
comma
id|encoding
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|after_subject
)paren
(brace
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|after_subject
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fmt
op_eq
id|CMIT_FMT_EMAIL
)paren
(brace
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
id|strbuf_release
c_func
(paren
op_amp
id|title
)paren
suffix:semicolon
)brace
DECL|function|pp_remainder
r_static
r_void
id|pp_remainder
c_func
(paren
r_enum
id|cmit_fmt
id|fmt
comma
r_const
r_char
op_star
op_star
id|msg_p
comma
r_struct
id|strbuf
op_star
id|sb
comma
r_int
id|indent
)paren
(brace
r_int
id|first
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_const
r_char
op_star
id|line
op_assign
op_star
id|msg_p
suffix:semicolon
r_int
id|linelen
op_assign
id|get_one_line
c_func
(paren
id|line
)paren
suffix:semicolon
op_star
id|msg_p
op_add_assign
id|linelen
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|linelen
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|is_empty_line
c_func
(paren
id|line
comma
op_amp
id|linelen
)paren
)paren
(brace
r_if
c_cond
(paren
id|first
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|fmt
op_eq
id|CMIT_FMT_SHORT
)paren
r_break
suffix:semicolon
)brace
id|first
op_assign
l_int|0
suffix:semicolon
id|strbuf_grow
c_func
(paren
id|sb
comma
id|linelen
op_plus
id|indent
op_plus
l_int|20
)paren
suffix:semicolon
r_if
c_cond
(paren
id|indent
)paren
(brace
id|memset
c_func
(paren
id|sb-&gt;buf
op_plus
id|sb-&gt;len
comma
l_char|&squot; &squot;
comma
id|indent
)paren
suffix:semicolon
id|strbuf_setlen
c_func
(paren
id|sb
comma
id|sb-&gt;len
op_plus
id|indent
)paren
suffix:semicolon
)brace
id|strbuf_add
c_func
(paren
id|sb
comma
id|line
comma
id|linelen
)paren
suffix:semicolon
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
)brace
DECL|function|pretty_print_commit
r_void
id|pretty_print_commit
c_func
(paren
r_enum
id|cmit_fmt
id|fmt
comma
r_const
r_struct
id|commit
op_star
id|commit
comma
r_struct
id|strbuf
op_star
id|sb
comma
r_int
id|abbrev
comma
r_const
r_char
op_star
id|subject
comma
r_const
r_char
op_star
id|after_subject
comma
r_enum
id|date_mode
id|dmode
comma
r_int
id|plain_non_ascii
)paren
(brace
r_int
r_int
id|beginning_of_body
suffix:semicolon
r_int
id|indent
op_assign
l_int|4
suffix:semicolon
r_const
r_char
op_star
id|msg
op_assign
id|commit-&gt;buffer
suffix:semicolon
r_char
op_star
id|reencoded
suffix:semicolon
r_const
r_char
op_star
id|encoding
suffix:semicolon
r_if
c_cond
(paren
id|fmt
op_eq
id|CMIT_FMT_USERFORMAT
)paren
(brace
id|format_commit_message
c_func
(paren
id|commit
comma
id|user_format
comma
id|sb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|encoding
op_assign
(paren
id|git_log_output_encoding
ques
c_cond
id|git_log_output_encoding
suffix:colon
id|git_commit_encoding
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|encoding
)paren
id|encoding
op_assign
l_string|&quot;utf-8&quot;
suffix:semicolon
id|reencoded
op_assign
id|logmsg_reencode
c_func
(paren
id|commit
comma
id|encoding
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reencoded
)paren
(brace
id|msg
op_assign
id|reencoded
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fmt
op_eq
id|CMIT_FMT_ONELINE
op_logical_or
id|fmt
op_eq
id|CMIT_FMT_EMAIL
)paren
id|indent
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* After-subject is used to pass in Content-Type: multipart&n;&t; * MIME header; in that case we do not have to do the&n;&t; * plaintext content type even if the commit message has&n;&t; * non 7-bit ASCII character.  Otherwise, check if we need&n;&t; * to say this is not a 7-bit ASCII.&n;&t; */
r_if
c_cond
(paren
id|fmt
op_eq
id|CMIT_FMT_EMAIL
op_logical_and
op_logical_neg
id|after_subject
)paren
(brace
r_int
id|i
comma
id|ch
comma
id|in_body
suffix:semicolon
r_for
c_loop
(paren
id|in_body
op_assign
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|ch
op_assign
id|msg
(braket
id|i
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|in_body
)paren
(brace
multiline_comment|/* author could be non 7-bit ASCII but&n;&t;&t;&t;&t; * the log may be so; skip over the&n;&t;&t;&t;&t; * header part first.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;&bslash;n&squot;
op_logical_and
id|msg
(braket
id|i
op_plus
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|in_body
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|non_ascii
c_func
(paren
id|ch
)paren
)paren
(brace
id|plain_non_ascii
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
id|pp_header
c_func
(paren
id|fmt
comma
id|abbrev
comma
id|dmode
comma
id|encoding
comma
id|commit
comma
op_amp
id|msg
comma
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fmt
op_ne
id|CMIT_FMT_ONELINE
op_logical_and
op_logical_neg
id|subject
)paren
(brace
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Skip excess blank lines at the beginning of body, if any... */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|linelen
op_assign
id|get_one_line
c_func
(paren
id|msg
)paren
suffix:semicolon
r_int
id|ll
op_assign
id|linelen
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|linelen
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_empty_line
c_func
(paren
id|msg
comma
op_amp
id|ll
)paren
)paren
r_break
suffix:semicolon
id|msg
op_add_assign
id|linelen
suffix:semicolon
)brace
multiline_comment|/* These formats treat the title line specially. */
r_if
c_cond
(paren
id|fmt
op_eq
id|CMIT_FMT_ONELINE
op_logical_or
id|fmt
op_eq
id|CMIT_FMT_EMAIL
)paren
id|pp_title_line
c_func
(paren
id|fmt
comma
op_amp
id|msg
comma
id|sb
comma
id|subject
comma
id|after_subject
comma
id|encoding
comma
id|plain_non_ascii
)paren
suffix:semicolon
id|beginning_of_body
op_assign
id|sb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|fmt
op_ne
id|CMIT_FMT_ONELINE
)paren
id|pp_remainder
c_func
(paren
id|fmt
comma
op_amp
id|msg
comma
id|sb
comma
id|indent
)paren
suffix:semicolon
id|strbuf_rtrim
c_func
(paren
id|sb
)paren
suffix:semicolon
multiline_comment|/* Make sure there is an EOLN for the non-oneline case */
r_if
c_cond
(paren
id|fmt
op_ne
id|CMIT_FMT_ONELINE
)paren
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The caller may append additional body text in e-mail&n;&t; * format.  Make sure we did not strip the blank line&n;&t; * between the header and the body.&n;&t; */
r_if
c_cond
(paren
id|fmt
op_eq
id|CMIT_FMT_EMAIL
op_logical_and
id|sb-&gt;len
op_le
id|beginning_of_body
)paren
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|free
c_func
(paren
id|reencoded
)paren
suffix:semicolon
)brace
eof
