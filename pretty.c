macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;commit.h&quot;
macro_line|#include &quot;utf8.h&quot;
macro_line|#include &quot;diff.h&quot;
macro_line|#include &quot;revision.h&quot;
macro_line|#include &quot;string-list.h&quot;
macro_line|#include &quot;mailmap.h&quot;
macro_line|#include &quot;log-tree.h&quot;
macro_line|#include &quot;notes.h&quot;
macro_line|#include &quot;color.h&quot;
macro_line|#include &quot;reflog-walk.h&quot;
macro_line|#include &quot;gpg-interface.h&quot;
DECL|variable|user_format
r_static
r_char
op_star
id|user_format
suffix:semicolon
DECL|struct|cmt_fmt_map
r_static
r_struct
id|cmt_fmt_map
(brace
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
DECL|member|format
r_enum
id|cmit_fmt
id|format
suffix:semicolon
DECL|member|is_tformat
r_int
id|is_tformat
suffix:semicolon
DECL|member|is_alias
r_int
id|is_alias
suffix:semicolon
DECL|member|user_format
r_const
r_char
op_star
id|user_format
suffix:semicolon
DECL|variable|commit_formats
)brace
op_star
id|commit_formats
suffix:semicolon
DECL|variable|builtin_formats_len
r_static
r_int
id|builtin_formats_len
suffix:semicolon
DECL|variable|commit_formats_len
r_static
r_int
id|commit_formats_len
suffix:semicolon
DECL|variable|commit_formats_alloc
r_static
r_int
id|commit_formats_alloc
suffix:semicolon
r_static
r_struct
id|cmt_fmt_map
op_star
id|find_commit_format
c_func
(paren
r_const
r_char
op_star
id|sought
)paren
suffix:semicolon
DECL|function|save_user_format
r_static
r_void
id|save_user_format
c_func
(paren
r_struct
id|rev_info
op_star
id|rev
comma
r_const
r_char
op_star
id|cp
comma
r_int
id|is_tformat
)paren
(brace
id|free
c_func
(paren
id|user_format
)paren
suffix:semicolon
id|user_format
op_assign
id|xstrdup
c_func
(paren
id|cp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_tformat
)paren
id|rev-&gt;use_terminator
op_assign
l_int|1
suffix:semicolon
id|rev-&gt;commit_format
op_assign
id|CMIT_FMT_USERFORMAT
suffix:semicolon
)brace
DECL|function|git_pretty_formats_config
r_static
r_int
id|git_pretty_formats_config
c_func
(paren
r_const
r_char
op_star
id|var
comma
r_const
r_char
op_star
id|value
comma
r_void
op_star
id|cb
)paren
(brace
r_struct
id|cmt_fmt_map
op_star
id|commit_format
op_assign
l_int|NULL
suffix:semicolon
r_const
r_char
op_star
id|name
suffix:semicolon
r_const
r_char
op_star
id|fmt
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|prefixcmp
c_func
(paren
id|var
comma
l_string|&quot;pretty.&quot;
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|name
op_assign
id|var
op_plus
id|strlen
c_func
(paren
l_string|&quot;pretty.&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|builtin_formats_len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|commit_formats
(braket
id|i
)braket
dot
id|name
comma
id|name
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
id|builtin_formats_len
suffix:semicolon
id|i
OL
id|commit_formats_len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|commit_formats
(braket
id|i
)braket
dot
id|name
comma
id|name
)paren
)paren
(brace
id|commit_format
op_assign
op_amp
id|commit_formats
(braket
id|i
)braket
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|commit_format
)paren
(brace
id|ALLOC_GROW
c_func
(paren
id|commit_formats
comma
id|commit_formats_len
op_plus
l_int|1
comma
id|commit_formats_alloc
)paren
suffix:semicolon
id|commit_format
op_assign
op_amp
id|commit_formats
(braket
id|commit_formats_len
)braket
suffix:semicolon
id|memset
c_func
(paren
id|commit_format
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|commit_format
)paren
)paren
suffix:semicolon
id|commit_formats_len
op_increment
suffix:semicolon
)brace
id|commit_format-&gt;name
op_assign
id|xstrdup
c_func
(paren
id|name
)paren
suffix:semicolon
id|commit_format-&gt;format
op_assign
id|CMIT_FMT_USERFORMAT
suffix:semicolon
id|git_config_string
c_func
(paren
op_amp
id|fmt
comma
id|var
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|fmt
comma
l_string|&quot;format:&quot;
)paren
op_logical_or
op_logical_neg
id|prefixcmp
c_func
(paren
id|fmt
comma
l_string|&quot;tformat:&quot;
)paren
)paren
(brace
id|commit_format-&gt;is_tformat
op_assign
id|fmt
(braket
l_int|0
)braket
op_eq
l_char|&squot;t&squot;
suffix:semicolon
id|fmt
op_assign
id|strchr
c_func
(paren
id|fmt
comma
l_char|&squot;:&squot;
)paren
op_plus
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strchr
c_func
(paren
id|fmt
comma
l_char|&squot;%&squot;
)paren
)paren
id|commit_format-&gt;is_tformat
op_assign
l_int|1
suffix:semicolon
r_else
id|commit_format-&gt;is_alias
op_assign
l_int|1
suffix:semicolon
id|commit_format-&gt;user_format
op_assign
id|fmt
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|setup_commit_formats
r_static
r_void
id|setup_commit_formats
c_func
(paren
r_void
)paren
(brace
r_struct
id|cmt_fmt_map
id|builtin_formats
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;raw&quot;
comma
id|CMIT_FMT_RAW
comma
l_int|0
)brace
comma
(brace
l_string|&quot;medium&quot;
comma
id|CMIT_FMT_MEDIUM
comma
l_int|0
)brace
comma
(brace
l_string|&quot;short&quot;
comma
id|CMIT_FMT_SHORT
comma
l_int|0
)brace
comma
(brace
l_string|&quot;email&quot;
comma
id|CMIT_FMT_EMAIL
comma
l_int|0
)brace
comma
(brace
l_string|&quot;fuller&quot;
comma
id|CMIT_FMT_FULLER
comma
l_int|0
)brace
comma
(brace
l_string|&quot;full&quot;
comma
id|CMIT_FMT_FULL
comma
l_int|0
)brace
comma
(brace
l_string|&quot;oneline&quot;
comma
id|CMIT_FMT_ONELINE
comma
l_int|1
)brace
)brace
suffix:semicolon
id|commit_formats_len
op_assign
id|ARRAY_SIZE
c_func
(paren
id|builtin_formats
)paren
suffix:semicolon
id|builtin_formats_len
op_assign
id|commit_formats_len
suffix:semicolon
id|ALLOC_GROW
c_func
(paren
id|commit_formats
comma
id|commit_formats_len
comma
id|commit_formats_alloc
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|commit_formats
comma
id|builtin_formats
comma
r_sizeof
(paren
op_star
id|builtin_formats
)paren
op_star
id|ARRAY_SIZE
c_func
(paren
id|builtin_formats
)paren
)paren
suffix:semicolon
id|git_config
c_func
(paren
id|git_pretty_formats_config
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|find_commit_format_recursive
r_static
r_struct
id|cmt_fmt_map
op_star
id|find_commit_format_recursive
c_func
(paren
r_const
r_char
op_star
id|sought
comma
r_const
r_char
op_star
id|original
comma
r_int
id|num_redirections
)paren
(brace
r_struct
id|cmt_fmt_map
op_star
id|found
op_assign
l_int|NULL
suffix:semicolon
r_int
id|found_match_len
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|num_redirections
op_ge
id|commit_formats_len
)paren
id|die
c_func
(paren
l_string|&quot;invalid --pretty format: &quot;
l_string|&quot;&squot;%s&squot; references an alias which points to itself&quot;
comma
id|original
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|commit_formats_len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|match_len
suffix:semicolon
r_if
c_cond
(paren
id|prefixcmp
c_func
(paren
id|commit_formats
(braket
id|i
)braket
dot
id|name
comma
id|sought
)paren
)paren
r_continue
suffix:semicolon
id|match_len
op_assign
id|strlen
c_func
(paren
id|commit_formats
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|found
op_eq
l_int|NULL
op_logical_or
id|found_match_len
OG
id|match_len
)paren
(brace
id|found
op_assign
op_amp
id|commit_formats
(braket
id|i
)braket
suffix:semicolon
id|found_match_len
op_assign
id|match_len
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|found
op_logical_and
id|found-&gt;is_alias
)paren
(brace
id|found
op_assign
id|find_commit_format_recursive
c_func
(paren
id|found-&gt;user_format
comma
id|original
comma
id|num_redirections
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_return
id|found
suffix:semicolon
)brace
DECL|function|find_commit_format
r_static
r_struct
id|cmt_fmt_map
op_star
id|find_commit_format
c_func
(paren
r_const
r_char
op_star
id|sought
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|commit_formats
)paren
id|setup_commit_formats
c_func
(paren
)paren
suffix:semicolon
r_return
id|find_commit_format_recursive
c_func
(paren
id|sought
comma
id|sought
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|get_commit_format
r_void
id|get_commit_format
c_func
(paren
r_const
r_char
op_star
id|arg
comma
r_struct
id|rev_info
op_star
id|rev
)paren
(brace
r_struct
id|cmt_fmt_map
op_star
id|commit_format
suffix:semicolon
id|rev-&gt;use_terminator
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
op_logical_or
op_logical_neg
op_star
id|arg
)paren
(brace
id|rev-&gt;commit_format
op_assign
id|CMIT_FMT_DEFAULT
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;format:&quot;
)paren
op_logical_or
op_logical_neg
id|prefixcmp
c_func
(paren
id|arg
comma
l_string|&quot;tformat:&quot;
)paren
)paren
(brace
id|save_user_format
c_func
(paren
id|rev
comma
id|strchr
c_func
(paren
id|arg
comma
l_char|&squot;:&squot;
)paren
op_plus
l_int|1
comma
id|arg
(braket
l_int|0
)braket
op_eq
l_char|&squot;t&squot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strchr
c_func
(paren
id|arg
comma
l_char|&squot;%&squot;
)paren
)paren
(brace
id|save_user_format
c_func
(paren
id|rev
comma
id|arg
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|commit_format
op_assign
id|find_commit_format
c_func
(paren
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|commit_format
)paren
id|die
c_func
(paren
l_string|&quot;invalid --pretty format: %s&quot;
comma
id|arg
)paren
suffix:semicolon
id|rev-&gt;commit_format
op_assign
id|commit_format-&gt;format
suffix:semicolon
id|rev-&gt;use_terminator
op_assign
id|commit_format-&gt;is_tformat
suffix:semicolon
r_if
c_cond
(paren
id|commit_format-&gt;format
op_eq
id|CMIT_FMT_USERFORMAT
)paren
(brace
id|save_user_format
c_func
(paren
id|rev
comma
id|commit_format-&gt;user_format
comma
id|commit_format-&gt;is_tformat
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Generic support for pretty-printing the header&n; */
DECL|function|get_one_line
r_static
r_int
id|get_one_line
c_func
(paren
r_const
r_char
op_star
id|msg
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_char
id|c
op_assign
op_star
id|msg
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
r_break
suffix:semicolon
id|ret
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* High bit set, or ISO-2022-INT */
DECL|function|non_ascii
r_static
r_int
id|non_ascii
c_func
(paren
r_int
id|ch
)paren
(brace
r_return
op_logical_neg
id|isascii
c_func
(paren
id|ch
)paren
op_logical_or
id|ch
op_eq
l_char|&squot;&bslash;033&squot;
suffix:semicolon
)brace
DECL|function|has_non_ascii
r_int
id|has_non_ascii
c_func
(paren
r_const
r_char
op_star
id|s
)paren
(brace
r_int
id|ch
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s
)paren
r_return
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ch
op_assign
op_star
id|s
op_increment
)paren
op_ne
l_char|&squot;&bslash;0&squot;
)paren
(brace
r_if
c_cond
(paren
id|non_ascii
c_func
(paren
id|ch
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|is_rfc822_special
r_static
r_int
id|is_rfc822_special
c_func
(paren
r_char
id|ch
)paren
(brace
r_switch
c_cond
(paren
id|ch
)paren
(brace
r_case
l_char|&squot;(&squot;
suffix:colon
r_case
l_char|&squot;)&squot;
suffix:colon
r_case
l_char|&squot;&lt;&squot;
suffix:colon
r_case
l_char|&squot;&gt;&squot;
suffix:colon
r_case
l_char|&squot;[&squot;
suffix:colon
r_case
l_char|&squot;]&squot;
suffix:colon
r_case
l_char|&squot;:&squot;
suffix:colon
r_case
l_char|&squot;;&squot;
suffix:colon
r_case
l_char|&squot;@&squot;
suffix:colon
r_case
l_char|&squot;,&squot;
suffix:colon
r_case
l_char|&squot;.&squot;
suffix:colon
r_case
l_char|&squot;&quot;&squot;
suffix:colon
r_case
l_char|&squot;&bslash;&bslash;&squot;
suffix:colon
r_return
l_int|1
suffix:semicolon
r_default
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|needs_rfc822_quoting
r_static
r_int
id|needs_rfc822_quoting
c_func
(paren
r_const
r_char
op_star
id|s
comma
r_int
id|len
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|is_rfc822_special
c_func
(paren
id|s
(braket
id|i
)braket
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|last_line_length
r_static
r_int
id|last_line_length
c_func
(paren
r_struct
id|strbuf
op_star
id|sb
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* How many bytes are already used on the last line? */
r_for
c_loop
(paren
id|i
op_assign
id|sb-&gt;len
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
r_if
c_cond
(paren
id|sb-&gt;buf
(braket
id|i
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
r_break
suffix:semicolon
r_return
id|sb-&gt;len
(paren
id|i
op_plus
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|add_rfc822_quoted
r_static
r_void
id|add_rfc822_quoted
c_func
(paren
r_struct
id|strbuf
op_star
id|out
comma
r_const
r_char
op_star
id|s
comma
r_int
id|len
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* just a guess, we may have to also backslash-quote */
id|strbuf_grow
c_func
(paren
id|out
comma
id|len
op_plus
l_int|2
)paren
suffix:semicolon
id|strbuf_addch
c_func
(paren
id|out
comma
l_char|&squot;&quot;&squot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_switch
c_cond
(paren
id|s
(braket
id|i
)braket
)paren
(brace
r_case
l_char|&squot;&quot;&squot;
suffix:colon
r_case
l_char|&squot;&bslash;&bslash;&squot;
suffix:colon
id|strbuf_addch
c_func
(paren
id|out
comma
l_char|&squot;&bslash;&bslash;&squot;
)paren
suffix:semicolon
multiline_comment|/* fall through */
r_default
suffix:colon
id|strbuf_addch
c_func
(paren
id|out
comma
id|s
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
id|strbuf_addch
c_func
(paren
id|out
comma
l_char|&squot;&quot;&squot;
)paren
suffix:semicolon
)brace
DECL|enum|rfc2047_type
r_enum
id|rfc2047_type
(brace
DECL|enumerator|RFC2047_SUBJECT
id|RFC2047_SUBJECT
comma
DECL|enumerator|RFC2047_ADDRESS
id|RFC2047_ADDRESS
comma
)brace
suffix:semicolon
DECL|function|is_rfc2047_special
r_static
r_int
id|is_rfc2047_special
c_func
(paren
r_char
id|ch
comma
r_enum
id|rfc2047_type
id|type
)paren
(brace
multiline_comment|/*&n;&t; * rfc2047, section 4.2:&n;&t; *&n;&t; *    8-bit values which correspond to printable ASCII characters other&n;&t; *    than &quot;=&quot;, &quot;?&quot;, and &quot;_&quot; (underscore), MAY be represented as those&n;&t; *    characters.  (But see section 5 for restrictions.)  In&n;&t; *    particular, SPACE and TAB MUST NOT be represented as themselves&n;&t; *    within encoded words.&n;&t; */
multiline_comment|/*&n;&t; * rule out non-ASCII characters and non-printable characters (the&n;&t; * non-ASCII check should be redundant as isprint() is not localized&n;&t; * and only knows about ASCII, but be defensive about that)&n;&t; */
r_if
c_cond
(paren
id|non_ascii
c_func
(paren
id|ch
)paren
op_logical_or
op_logical_neg
id|isprint
c_func
(paren
id|ch
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * rule out special printable characters (&squot; &squot; should be the only&n;&t; * whitespace character considered printable, but be defensive and use&n;&t; * isspace())&n;&t; */
r_if
c_cond
(paren
id|isspace
c_func
(paren
id|ch
)paren
op_logical_or
id|ch
op_eq
l_char|&squot;=&squot;
op_logical_or
id|ch
op_eq
l_char|&squot;?&squot;
op_logical_or
id|ch
op_eq
l_char|&squot;_&squot;
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * rfc2047, section 5.3:&n;&t; *&n;&t; *    As a replacement for a &squot;word&squot; entity within a &squot;phrase&squot;, for example,&n;&t; *    one that precedes an address in a From, To, or Cc header.  The ABNF&n;&t; *    definition for &squot;phrase&squot; from RFC 822 thus becomes:&n;&t; *&n;&t; *    phrase = 1*( encoded-word / word )&n;&t; *&n;&t; *    In this case the set of characters that may be used in a &quot;Q&quot;-encoded&n;&t; *    &squot;encoded-word&squot; is restricted to: &lt;upper and lower case ASCII&n;&t; *    letters, decimal digits, &quot;!&quot;, &quot;*&quot;, &quot;+&quot;, &quot;-&quot;, &quot;/&quot;, &quot;=&quot;, and &quot;_&quot;&n;&t; *    (underscore, ASCII 95.)&gt;.  An &squot;encoded-word&squot; that appears within a&n;&t; *    &squot;phrase&squot; MUST be separated from any adjacent &squot;word&squot;, &squot;text&squot; or&n;&t; *    &squot;special&squot; by &squot;linear-white-space&squot;.&n;&t; */
r_if
c_cond
(paren
id|type
op_ne
id|RFC2047_ADDRESS
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* &squot;=&squot; and &squot;_&squot; are special cases and have been checked above */
r_return
op_logical_neg
(paren
id|isalnum
c_func
(paren
id|ch
)paren
op_logical_or
id|ch
op_eq
l_char|&squot;!&squot;
op_logical_or
id|ch
op_eq
l_char|&squot;*&squot;
op_logical_or
id|ch
op_eq
l_char|&squot;+&squot;
op_logical_or
id|ch
op_eq
l_char|&squot;-&squot;
op_logical_or
id|ch
op_eq
l_char|&squot;/&squot;
)paren
suffix:semicolon
)brace
DECL|function|needs_rfc2047_encoding
r_static
r_int
id|needs_rfc2047_encoding
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_int
id|len
comma
r_enum
id|rfc2047_type
id|type
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|ch
op_assign
id|line
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|non_ascii
c_func
(paren
id|ch
)paren
op_logical_or
id|ch
op_eq
l_char|&squot;&bslash;n&squot;
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_plus
l_int|1
OL
id|len
)paren
op_logical_and
(paren
id|ch
op_eq
l_char|&squot;=&squot;
op_logical_and
id|line
(braket
id|i
op_plus
l_int|1
)braket
op_eq
l_char|&squot;?&squot;
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|add_rfc2047
r_static
r_void
id|add_rfc2047
c_func
(paren
r_struct
id|strbuf
op_star
id|sb
comma
r_const
r_char
op_star
id|line
comma
r_int
id|len
comma
r_const
r_char
op_star
id|encoding
comma
r_enum
id|rfc2047_type
id|type
)paren
(brace
r_static
r_const
r_int
id|max_encoded_length
op_assign
l_int|76
suffix:semicolon
multiline_comment|/* per rfc2047 */
r_int
id|i
suffix:semicolon
r_int
id|line_len
op_assign
id|last_line_length
c_func
(paren
id|sb
)paren
suffix:semicolon
id|strbuf_grow
c_func
(paren
id|sb
comma
id|len
op_star
l_int|3
op_plus
id|strlen
c_func
(paren
id|encoding
)paren
op_plus
l_int|100
)paren
suffix:semicolon
id|strbuf_addf
c_func
(paren
id|sb
comma
l_string|&quot;=?%s?q?&quot;
comma
id|encoding
)paren
suffix:semicolon
id|line_len
op_add_assign
id|strlen
c_func
(paren
id|encoding
)paren
op_plus
l_int|5
suffix:semicolon
multiline_comment|/* 5 for =??q? */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|ch
op_assign
id|line
(braket
id|i
)braket
op_amp
l_int|0xFF
suffix:semicolon
r_int
id|is_special
op_assign
id|is_rfc2047_special
c_func
(paren
id|ch
comma
id|type
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * According to RFC 2047, we could encode the special character&n;&t;&t; * &squot; &squot; (space) with &squot;_&squot; (underscore) for readability. But many&n;&t;&t; * programs do not understand this and just leave the&n;&t;&t; * underscore in place. Thus, we do nothing special here, which&n;&t;&t; * causes &squot; &squot; to be encoded as &squot;=20&squot;, avoiding this problem.&n;&t;&t; */
r_if
c_cond
(paren
id|line_len
op_plus
l_int|2
op_plus
(paren
id|is_special
ques
c_cond
l_int|3
suffix:colon
l_int|1
)paren
OG
id|max_encoded_length
)paren
(brace
id|strbuf_addf
c_func
(paren
id|sb
comma
l_string|&quot;?=&bslash;n =?%s?q?&quot;
comma
id|encoding
)paren
suffix:semicolon
id|line_len
op_assign
id|strlen
c_func
(paren
id|encoding
)paren
op_plus
l_int|5
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* =??q? plus SP */
)brace
r_if
c_cond
(paren
id|is_special
)paren
(brace
id|strbuf_addf
c_func
(paren
id|sb
comma
l_string|&quot;=%02X&quot;
comma
id|ch
)paren
suffix:semicolon
id|line_len
op_add_assign
l_int|3
suffix:semicolon
)brace
r_else
(brace
id|strbuf_addch
c_func
(paren
id|sb
comma
id|ch
)paren
suffix:semicolon
id|line_len
op_increment
suffix:semicolon
)brace
)brace
id|strbuf_addstr
c_func
(paren
id|sb
comma
l_string|&quot;?=&quot;
)paren
suffix:semicolon
)brace
DECL|function|pp_user_info
r_void
id|pp_user_info
c_func
(paren
r_const
r_struct
id|pretty_print_context
op_star
id|pp
comma
r_const
r_char
op_star
id|what
comma
r_struct
id|strbuf
op_star
id|sb
comma
r_const
r_char
op_star
id|line
comma
r_const
r_char
op_star
id|encoding
)paren
(brace
r_struct
id|strbuf
id|name
suffix:semicolon
r_struct
id|strbuf
id|mail
suffix:semicolon
r_struct
id|ident_split
id|ident
suffix:semicolon
r_int
id|linelen
suffix:semicolon
r_char
op_star
id|line_end
comma
op_star
id|date
suffix:semicolon
r_const
r_char
op_star
id|mailbuf
comma
op_star
id|namebuf
suffix:semicolon
r_int
id|namelen
comma
id|maillen
suffix:semicolon
r_int
id|max_length
op_assign
l_int|78
suffix:semicolon
multiline_comment|/* per rfc2822 */
r_int
r_int
id|time
suffix:semicolon
r_int
id|tz
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;fmt
op_eq
id|CMIT_FMT_ONELINE
)paren
r_return
suffix:semicolon
id|line_end
op_assign
id|strchr
c_func
(paren
id|line
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|line_end
)paren
(brace
id|line_end
op_assign
id|strchr
c_func
(paren
id|line
comma
l_char|&squot;&bslash;0&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|line_end
)paren
r_return
suffix:semicolon
)brace
id|linelen
op_assign
op_increment
id|line_end
id|line
suffix:semicolon
r_if
c_cond
(paren
id|split_ident_line
c_func
(paren
op_amp
id|ident
comma
id|line
comma
id|linelen
)paren
)paren
r_return
suffix:semicolon
id|mailbuf
op_assign
id|ident.mail_begin
suffix:semicolon
id|maillen
op_assign
id|ident.mail_end
id|ident.mail_begin
suffix:semicolon
id|namebuf
op_assign
id|ident.name_begin
suffix:semicolon
id|namelen
op_assign
id|ident.name_end
id|ident.name_begin
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;mailmap
)paren
id|map_user
c_func
(paren
id|pp-&gt;mailmap
comma
op_amp
id|mailbuf
comma
op_amp
id|maillen
comma
op_amp
id|namebuf
comma
op_amp
id|namelen
)paren
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|mail
comma
l_int|0
)paren
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|name
comma
l_int|0
)paren
suffix:semicolon
id|strbuf_add
c_func
(paren
op_amp
id|mail
comma
id|mailbuf
comma
id|maillen
)paren
suffix:semicolon
id|strbuf_add
c_func
(paren
op_amp
id|name
comma
id|namebuf
comma
id|namelen
)paren
suffix:semicolon
id|namelen
op_assign
id|name.len
op_plus
id|mail.len
op_plus
l_int|3
suffix:semicolon
multiline_comment|/* &squot; &squot; + &squot;&lt;&squot; + &squot;&gt;&squot; */
id|time
op_assign
id|strtoul
c_func
(paren
id|ident.date_begin
comma
op_amp
id|date
comma
l_int|10
)paren
suffix:semicolon
id|tz
op_assign
id|strtol
c_func
(paren
id|date
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;fmt
op_eq
id|CMIT_FMT_EMAIL
)paren
(brace
id|strbuf_addstr
c_func
(paren
id|sb
comma
l_string|&quot;From: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|needs_rfc2047_encoding
c_func
(paren
id|name.buf
comma
id|name.len
comma
id|RFC2047_ADDRESS
)paren
)paren
(brace
id|add_rfc2047
c_func
(paren
id|sb
comma
id|name.buf
comma
id|name.len
comma
id|encoding
comma
id|RFC2047_ADDRESS
)paren
suffix:semicolon
id|max_length
op_assign
l_int|76
suffix:semicolon
multiline_comment|/* per rfc2047 */
)brace
r_else
r_if
c_cond
(paren
id|needs_rfc822_quoting
c_func
(paren
id|name.buf
comma
id|name.len
)paren
)paren
(brace
r_struct
id|strbuf
id|quoted
op_assign
id|STRBUF_INIT
suffix:semicolon
id|add_rfc822_quoted
c_func
(paren
op_amp
id|quoted
comma
id|name.buf
comma
id|name.len
)paren
suffix:semicolon
id|strbuf_add_wrapped_bytes
c_func
(paren
id|sb
comma
id|quoted.buf
comma
id|quoted.len
comma
l_int|6
comma
l_int|1
comma
id|max_length
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|quoted
)paren
suffix:semicolon
)brace
r_else
(brace
id|strbuf_add_wrapped_bytes
c_func
(paren
id|sb
comma
id|name.buf
comma
id|name.len
comma
l_int|6
comma
l_int|1
comma
id|max_length
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|namelen
id|name.len
op_plus
id|last_line_length
c_func
(paren
id|sb
)paren
OG
id|max_length
)paren
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|strbuf_addf
c_func
(paren
id|sb
comma
l_string|&quot; &lt;%s&gt;&bslash;n&quot;
comma
id|mail.buf
)paren
suffix:semicolon
)brace
r_else
(brace
id|strbuf_addf
c_func
(paren
id|sb
comma
l_string|&quot;%s: %.*s%s &lt;%s&gt;&bslash;n&quot;
comma
id|what
comma
(paren
id|pp-&gt;fmt
op_eq
id|CMIT_FMT_FULLER
)paren
ques
c_cond
l_int|4
suffix:colon
l_int|0
comma
l_string|&quot;    &quot;
comma
id|name.buf
comma
id|mail.buf
)paren
suffix:semicolon
)brace
id|strbuf_release
c_func
(paren
op_amp
id|mail
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|name
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|pp-&gt;fmt
)paren
(brace
r_case
id|CMIT_FMT_MEDIUM
suffix:colon
id|strbuf_addf
c_func
(paren
id|sb
comma
l_string|&quot;Date:   %s&bslash;n&quot;
comma
id|show_date
c_func
(paren
id|time
comma
id|tz
comma
id|pp-&gt;date_mode
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CMIT_FMT_EMAIL
suffix:colon
id|strbuf_addf
c_func
(paren
id|sb
comma
l_string|&quot;Date: %s&bslash;n&quot;
comma
id|show_date
c_func
(paren
id|time
comma
id|tz
comma
id|DATE_RFC2822
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CMIT_FMT_FULLER
suffix:colon
id|strbuf_addf
c_func
(paren
id|sb
comma
l_string|&quot;%sDate: %s&bslash;n&quot;
comma
id|what
comma
id|show_date
c_func
(paren
id|time
comma
id|tz
comma
id|pp-&gt;date_mode
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* notin&squot; */
r_break
suffix:semicolon
)brace
)brace
DECL|function|is_empty_line
r_static
r_int
id|is_empty_line
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_int
op_star
id|len_p
)paren
(brace
r_int
id|len
op_assign
op_star
id|len_p
suffix:semicolon
r_while
c_loop
(paren
id|len
op_logical_and
id|isspace
c_func
(paren
id|line
(braket
id|len
op_minus
l_int|1
)braket
)paren
)paren
id|len
op_decrement
suffix:semicolon
op_star
id|len_p
op_assign
id|len
suffix:semicolon
r_return
op_logical_neg
id|len
suffix:semicolon
)brace
DECL|function|skip_empty_lines
r_static
r_const
r_char
op_star
id|skip_empty_lines
c_func
(paren
r_const
r_char
op_star
id|msg
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|linelen
op_assign
id|get_one_line
c_func
(paren
id|msg
)paren
suffix:semicolon
r_int
id|ll
op_assign
id|linelen
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|linelen
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_empty_line
c_func
(paren
id|msg
comma
op_amp
id|ll
)paren
)paren
r_break
suffix:semicolon
id|msg
op_add_assign
id|linelen
suffix:semicolon
)brace
r_return
id|msg
suffix:semicolon
)brace
DECL|function|add_merge_info
r_static
r_void
id|add_merge_info
c_func
(paren
r_const
r_struct
id|pretty_print_context
op_star
id|pp
comma
r_struct
id|strbuf
op_star
id|sb
comma
r_const
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_struct
id|commit_list
op_star
id|parent
op_assign
id|commit-&gt;parents
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pp-&gt;fmt
op_eq
id|CMIT_FMT_ONELINE
)paren
op_logical_or
(paren
id|pp-&gt;fmt
op_eq
id|CMIT_FMT_EMAIL
)paren
op_logical_or
op_logical_neg
id|parent
op_logical_or
op_logical_neg
id|parent-&gt;next
)paren
r_return
suffix:semicolon
id|strbuf_addstr
c_func
(paren
id|sb
comma
l_string|&quot;Merge:&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|parent
)paren
(brace
r_struct
id|commit
op_star
id|p
op_assign
id|parent-&gt;item
suffix:semicolon
r_const
r_char
op_star
id|hex
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;abbrev
)paren
id|hex
op_assign
id|find_unique_abbrev
c_func
(paren
id|p-&gt;object.sha1
comma
id|pp-&gt;abbrev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hex
)paren
id|hex
op_assign
id|sha1_to_hex
c_func
(paren
id|p-&gt;object.sha1
)paren
suffix:semicolon
id|parent
op_assign
id|parent-&gt;next
suffix:semicolon
id|strbuf_addf
c_func
(paren
id|sb
comma
l_string|&quot; %s&quot;
comma
id|hex
)paren
suffix:semicolon
)brace
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
DECL|function|get_header
r_static
r_char
op_star
id|get_header
c_func
(paren
r_const
r_struct
id|commit
op_star
id|commit
comma
r_const
r_char
op_star
id|msg
comma
r_const
r_char
op_star
id|key
)paren
(brace
r_int
id|key_len
op_assign
id|strlen
c_func
(paren
id|key
)paren
suffix:semicolon
r_const
r_char
op_star
id|line
op_assign
id|msg
suffix:semicolon
r_while
c_loop
(paren
id|line
)paren
(brace
r_const
r_char
op_star
id|eol
op_assign
id|strchr
c_func
(paren
id|line
comma
l_char|&squot;&bslash;n&squot;
)paren
comma
op_star
id|next
suffix:semicolon
r_if
c_cond
(paren
id|line
op_eq
id|eol
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|eol
)paren
(brace
id|warning
c_func
(paren
l_string|&quot;malformed commit (header is missing newline): %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|commit-&gt;object.sha1
)paren
)paren
suffix:semicolon
id|eol
op_assign
id|line
op_plus
id|strlen
c_func
(paren
id|line
)paren
suffix:semicolon
id|next
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
id|next
op_assign
id|eol
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|eol
id|line
OG
id|key_len
op_logical_and
op_logical_neg
id|strncmp
c_func
(paren
id|line
comma
id|key
comma
id|key_len
)paren
op_logical_and
id|line
(braket
id|key_len
)braket
op_eq
l_char|&squot; &squot;
)paren
(brace
r_return
id|xmemdupz
c_func
(paren
id|line
op_plus
id|key_len
op_plus
l_int|1
comma
id|eol
id|line
id|key_len
l_int|1
)paren
suffix:semicolon
)brace
id|line
op_assign
id|next
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|replace_encoding_header
r_static
r_char
op_star
id|replace_encoding_header
c_func
(paren
r_char
op_star
id|buf
comma
r_const
r_char
op_star
id|encoding
)paren
(brace
r_struct
id|strbuf
id|tmp
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|start
comma
id|len
suffix:semicolon
r_char
op_star
id|cp
op_assign
id|buf
suffix:semicolon
multiline_comment|/* guess if there is an encoding header before a &bslash;n&bslash;n */
r_while
c_loop
(paren
id|strncmp
c_func
(paren
id|cp
comma
l_string|&quot;encoding &quot;
comma
id|strlen
c_func
(paren
l_string|&quot;encoding &quot;
)paren
)paren
)paren
(brace
id|cp
op_assign
id|strchr
c_func
(paren
id|cp
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
op_logical_or
op_star
op_increment
id|cp
op_eq
l_char|&squot;&bslash;n&squot;
)paren
r_return
id|buf
suffix:semicolon
)brace
id|start
op_assign
id|cp
id|buf
suffix:semicolon
id|cp
op_assign
id|strchr
c_func
(paren
id|cp
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_return
id|buf
suffix:semicolon
multiline_comment|/* should not happen but be defensive */
id|len
op_assign
id|cp
op_plus
l_int|1
(paren
id|buf
op_plus
id|start
)paren
suffix:semicolon
id|strbuf_attach
c_func
(paren
op_amp
id|tmp
comma
id|buf
comma
id|strlen
c_func
(paren
id|buf
)paren
comma
id|strlen
c_func
(paren
id|buf
)paren
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_encoding_utf8
c_func
(paren
id|encoding
)paren
)paren
(brace
multiline_comment|/* we have re-coded to UTF-8; drop the header */
id|strbuf_remove
c_func
(paren
op_amp
id|tmp
comma
id|start
comma
id|len
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* just replaces XXXX in &squot;encoding XXXX&bslash;n&squot; */
id|strbuf_splice
c_func
(paren
op_amp
id|tmp
comma
id|start
op_plus
id|strlen
c_func
(paren
l_string|&quot;encoding &quot;
)paren
comma
id|len
id|strlen
c_func
(paren
l_string|&quot;encoding &bslash;n&quot;
)paren
comma
id|encoding
comma
id|strlen
c_func
(paren
id|encoding
)paren
)paren
suffix:semicolon
)brace
r_return
id|strbuf_detach
c_func
(paren
op_amp
id|tmp
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|logmsg_reencode
r_char
op_star
id|logmsg_reencode
c_func
(paren
r_const
r_struct
id|commit
op_star
id|commit
comma
r_const
r_char
op_star
id|output_encoding
)paren
(brace
r_static
r_const
r_char
op_star
id|utf8
op_assign
l_string|&quot;UTF-8&quot;
suffix:semicolon
r_const
r_char
op_star
id|use_encoding
suffix:semicolon
r_char
op_star
id|encoding
suffix:semicolon
r_char
op_star
id|msg
op_assign
id|commit-&gt;buffer
suffix:semicolon
r_char
op_star
id|out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|msg
)paren
(brace
r_enum
id|object_type
id|type
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
id|msg
op_assign
id|read_sha1_file
c_func
(paren
id|commit-&gt;object.sha1
comma
op_amp
id|type
comma
op_amp
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|msg
)paren
id|die
c_func
(paren
l_string|&quot;Cannot read commit object %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|commit-&gt;object.sha1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
id|OBJ_COMMIT
)paren
id|die
c_func
(paren
l_string|&quot;Expected commit for &squot;%s&squot;, got %s&quot;
comma
id|sha1_to_hex
c_func
(paren
id|commit-&gt;object.sha1
)paren
comma
r_typename
(paren
id|type
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|output_encoding
op_logical_or
op_logical_neg
op_star
id|output_encoding
)paren
r_return
id|msg
suffix:semicolon
id|encoding
op_assign
id|get_header
c_func
(paren
id|commit
comma
id|msg
comma
l_string|&quot;encoding&quot;
)paren
suffix:semicolon
id|use_encoding
op_assign
id|encoding
ques
c_cond
id|encoding
suffix:colon
id|utf8
suffix:semicolon
r_if
c_cond
(paren
id|same_encoding
c_func
(paren
id|use_encoding
comma
id|output_encoding
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * No encoding work to be done. If we have no encoding header&n;&t;&t; * at all, then there&squot;s nothing to do, and we can return the&n;&t;&t; * message verbatim (whether newly allocated or not).&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|encoding
)paren
r_return
id|msg
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Otherwise, we still want to munge the encoding header in the&n;&t;&t; * result, which will be done by modifying the buffer. If we&n;&t;&t; * are using a fresh copy, we can reuse it. But if we are using&n;&t;&t; * the cached copy from commit-&gt;buffer, we need to duplicate it&n;&t;&t; * to avoid munging commit-&gt;buffer.&n;&t;&t; */
id|out
op_assign
id|msg
suffix:semicolon
r_if
c_cond
(paren
id|out
op_eq
id|commit-&gt;buffer
)paren
id|out
op_assign
id|xstrdup
c_func
(paren
id|out
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * There&squot;s actual encoding work to do. Do the reencoding, which&n;&t;&t; * still leaves the header to be replaced in the next step. At&n;&t;&t; * this point, we are done with msg. If we allocated a fresh&n;&t;&t; * copy, we can free it.&n;&t;&t; */
id|out
op_assign
id|reencode_string
c_func
(paren
id|msg
comma
id|output_encoding
comma
id|use_encoding
)paren
suffix:semicolon
r_if
c_cond
(paren
id|out
op_logical_and
id|msg
op_ne
id|commit-&gt;buffer
)paren
id|free
c_func
(paren
id|msg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * This replacement actually consumes the buffer we hand it, so we do&n;&t; * not have to worry about freeing the old &quot;out&quot; here.&n;&t; */
r_if
c_cond
(paren
id|out
)paren
id|out
op_assign
id|replace_encoding_header
c_func
(paren
id|out
comma
id|output_encoding
)paren
suffix:semicolon
id|free
c_func
(paren
id|encoding
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the re-encoding failed, out might be NULL here; in that&n;&t; * case we just return the commit message verbatim.&n;&t; */
r_return
id|out
ques
c_cond
id|out
suffix:colon
id|msg
suffix:semicolon
)brace
DECL|function|logmsg_free
r_void
id|logmsg_free
c_func
(paren
r_char
op_star
id|msg
comma
r_const
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_if
c_cond
(paren
id|msg
op_ne
id|commit-&gt;buffer
)paren
id|free
c_func
(paren
id|msg
)paren
suffix:semicolon
)brace
DECL|function|mailmap_name
r_static
r_int
id|mailmap_name
c_func
(paren
r_const
r_char
op_star
op_star
id|email
comma
r_int
op_star
id|email_len
comma
r_const
r_char
op_star
op_star
id|name
comma
r_int
op_star
id|name_len
)paren
(brace
r_static
r_struct
id|string_list
op_star
id|mail_map
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mail_map
)paren
(brace
id|mail_map
op_assign
id|xcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|mail_map
)paren
)paren
suffix:semicolon
id|read_mailmap
c_func
(paren
id|mail_map
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_return
id|mail_map-&gt;nr
op_logical_and
id|map_user
c_func
(paren
id|mail_map
comma
id|email
comma
id|email_len
comma
id|name
comma
id|name_len
)paren
suffix:semicolon
)brace
DECL|function|format_person_part
r_static
r_int
id|format_person_part
c_func
(paren
r_struct
id|strbuf
op_star
id|sb
comma
r_char
id|part
comma
r_const
r_char
op_star
id|msg
comma
r_int
id|len
comma
r_enum
id|date_mode
id|dmode
)paren
(brace
multiline_comment|/* currently all placeholders have same length */
r_const
r_int
id|placeholder_len
op_assign
l_int|2
suffix:semicolon
r_int
id|tz
suffix:semicolon
r_int
r_int
id|date
op_assign
l_int|0
suffix:semicolon
r_struct
id|ident_split
id|s
suffix:semicolon
r_const
r_char
op_star
id|name
comma
op_star
id|mail
suffix:semicolon
r_int
id|maillen
comma
id|namelen
suffix:semicolon
r_if
c_cond
(paren
id|split_ident_line
c_func
(paren
op_amp
id|s
comma
id|msg
comma
id|len
)paren
OL
l_int|0
)paren
r_goto
id|skip
suffix:semicolon
id|name
op_assign
id|s.name_begin
suffix:semicolon
id|namelen
op_assign
id|s.name_end
id|s.name_begin
suffix:semicolon
id|mail
op_assign
id|s.mail_begin
suffix:semicolon
id|maillen
op_assign
id|s.mail_end
id|s.mail_begin
suffix:semicolon
r_if
c_cond
(paren
id|part
op_eq
l_char|&squot;N&squot;
op_logical_or
id|part
op_eq
l_char|&squot;E&squot;
)paren
multiline_comment|/* mailmap lookup */
id|mailmap_name
c_func
(paren
op_amp
id|mail
comma
op_amp
id|maillen
comma
op_amp
id|name
comma
op_amp
id|namelen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|part
op_eq
l_char|&squot;n&squot;
op_logical_or
id|part
op_eq
l_char|&squot;N&squot;
)paren
(brace
multiline_comment|/* name */
id|strbuf_add
c_func
(paren
id|sb
comma
id|name
comma
id|namelen
)paren
suffix:semicolon
r_return
id|placeholder_len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|part
op_eq
l_char|&squot;e&squot;
op_logical_or
id|part
op_eq
l_char|&squot;E&squot;
)paren
(brace
multiline_comment|/* email */
id|strbuf_add
c_func
(paren
id|sb
comma
id|mail
comma
id|maillen
)paren
suffix:semicolon
r_return
id|placeholder_len
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|s.date_begin
)paren
r_goto
id|skip
suffix:semicolon
id|date
op_assign
id|strtoul
c_func
(paren
id|s.date_begin
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|part
op_eq
l_char|&squot;t&squot;
)paren
(brace
multiline_comment|/* date, UNIX timestamp */
id|strbuf_add
c_func
(paren
id|sb
comma
id|s.date_begin
comma
id|s.date_end
id|s.date_begin
)paren
suffix:semicolon
r_return
id|placeholder_len
suffix:semicolon
)brace
multiline_comment|/* parse tz */
id|tz
op_assign
id|strtoul
c_func
(paren
id|s.tz_begin
op_plus
l_int|1
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|s.tz_begin
op_eq
l_char|&squot;-&squot;
)paren
id|tz
op_assign
id|tz
suffix:semicolon
r_switch
c_cond
(paren
id|part
)paren
(brace
r_case
l_char|&squot;d&squot;
suffix:colon
multiline_comment|/* date */
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|show_date
c_func
(paren
id|date
comma
id|tz
comma
id|dmode
)paren
)paren
suffix:semicolon
r_return
id|placeholder_len
suffix:semicolon
r_case
l_char|&squot;D&squot;
suffix:colon
multiline_comment|/* date, RFC2822 style */
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|show_date
c_func
(paren
id|date
comma
id|tz
comma
id|DATE_RFC2822
)paren
)paren
suffix:semicolon
r_return
id|placeholder_len
suffix:semicolon
r_case
l_char|&squot;r&squot;
suffix:colon
multiline_comment|/* date, relative */
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|show_date
c_func
(paren
id|date
comma
id|tz
comma
id|DATE_RELATIVE
)paren
)paren
suffix:semicolon
r_return
id|placeholder_len
suffix:semicolon
r_case
l_char|&squot;i&squot;
suffix:colon
multiline_comment|/* date, ISO 8601 */
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|show_date
c_func
(paren
id|date
comma
id|tz
comma
id|DATE_ISO8601
)paren
)paren
suffix:semicolon
r_return
id|placeholder_len
suffix:semicolon
)brace
id|skip
suffix:colon
multiline_comment|/*&n;&t; * reading from either a bogus commit, or a reflog entry with&n;&t; * %gn, %ge, etc.; &squot;sb&squot; cannot be updated, but we still need&n;&t; * to compute a valid return value.&n;&t; */
r_if
c_cond
(paren
id|part
op_eq
l_char|&squot;n&squot;
op_logical_or
id|part
op_eq
l_char|&squot;e&squot;
op_logical_or
id|part
op_eq
l_char|&squot;t&squot;
op_logical_or
id|part
op_eq
l_char|&squot;d&squot;
op_logical_or
id|part
op_eq
l_char|&squot;D&squot;
op_logical_or
id|part
op_eq
l_char|&squot;r&squot;
op_logical_or
id|part
op_eq
l_char|&squot;i&squot;
)paren
r_return
id|placeholder_len
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* unknown placeholder */
)brace
DECL|struct|chunk
r_struct
id|chunk
(brace
DECL|member|off
r_int
id|off
suffix:semicolon
DECL|member|len
r_int
id|len
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|format_commit_context
r_struct
id|format_commit_context
(brace
DECL|member|commit
r_const
r_struct
id|commit
op_star
id|commit
suffix:semicolon
DECL|member|pretty_ctx
r_const
r_struct
id|pretty_print_context
op_star
id|pretty_ctx
suffix:semicolon
DECL|member|commit_header_parsed
r_int
id|commit_header_parsed
suffix:colon
l_int|1
suffix:semicolon
DECL|member|commit_message_parsed
r_int
id|commit_message_parsed
suffix:colon
l_int|1
suffix:semicolon
DECL|member|commit_signature_parsed
r_int
id|commit_signature_parsed
suffix:colon
l_int|1
suffix:semicolon
r_struct
(brace
DECL|member|gpg_output
r_char
op_star
id|gpg_output
suffix:semicolon
DECL|member|gpg_status
r_char
op_star
id|gpg_status
suffix:semicolon
DECL|member|good_bad
r_char
id|good_bad
suffix:semicolon
DECL|member|signer
r_char
op_star
id|signer
suffix:semicolon
DECL|member|key
r_char
op_star
id|key
suffix:semicolon
DECL|member|signature
)brace
id|signature
suffix:semicolon
DECL|member|message
r_char
op_star
id|message
suffix:semicolon
DECL|member|width
DECL|member|indent1
DECL|member|indent2
r_int
id|width
comma
id|indent1
comma
id|indent2
suffix:semicolon
multiline_comment|/* These offsets are relative to the start of the commit message. */
DECL|member|author
r_struct
id|chunk
id|author
suffix:semicolon
DECL|member|committer
r_struct
id|chunk
id|committer
suffix:semicolon
DECL|member|encoding
r_struct
id|chunk
id|encoding
suffix:semicolon
DECL|member|message_off
r_int
id|message_off
suffix:semicolon
DECL|member|subject_off
r_int
id|subject_off
suffix:semicolon
DECL|member|body_off
r_int
id|body_off
suffix:semicolon
multiline_comment|/* The following ones are relative to the result struct strbuf. */
DECL|member|abbrev_commit_hash
r_struct
id|chunk
id|abbrev_commit_hash
suffix:semicolon
DECL|member|abbrev_tree_hash
r_struct
id|chunk
id|abbrev_tree_hash
suffix:semicolon
DECL|member|abbrev_parent_hashes
r_struct
id|chunk
id|abbrev_parent_hashes
suffix:semicolon
DECL|member|wrap_start
r_int
id|wrap_start
suffix:semicolon
)brace
suffix:semicolon
DECL|function|add_again
r_static
r_int
id|add_again
c_func
(paren
r_struct
id|strbuf
op_star
id|sb
comma
r_struct
id|chunk
op_star
id|chunk
)paren
(brace
r_if
c_cond
(paren
id|chunk-&gt;len
)paren
(brace
id|strbuf_adddup
c_func
(paren
id|sb
comma
id|chunk-&gt;off
comma
id|chunk-&gt;len
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We haven&squot;t seen this chunk before.  Our caller is surely&n;&t; * going to add it the hard way now.  Remember the most likely&n;&t; * start of the to-be-added chunk: the current end of the&n;&t; * struct strbuf.&n;&t; */
id|chunk-&gt;off
op_assign
id|sb-&gt;len
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|parse_commit_header
r_static
r_void
id|parse_commit_header
c_func
(paren
r_struct
id|format_commit_context
op_star
id|context
)paren
(brace
r_const
r_char
op_star
id|msg
op_assign
id|context-&gt;message
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|msg
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|eol
suffix:semicolon
r_for
c_loop
(paren
id|eol
op_assign
id|i
suffix:semicolon
id|msg
(braket
id|eol
)braket
op_logical_and
id|msg
(braket
id|eol
)braket
op_ne
l_char|&squot;&bslash;n&squot;
suffix:semicolon
id|eol
op_increment
)paren
suffix:semicolon
multiline_comment|/* do nothing */
r_if
c_cond
(paren
id|i
op_eq
id|eol
)paren
(brace
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|msg
op_plus
id|i
comma
l_string|&quot;author &quot;
)paren
)paren
(brace
id|context-&gt;author.off
op_assign
id|i
op_plus
l_int|7
suffix:semicolon
id|context-&gt;author.len
op_assign
id|eol
id|i
l_int|7
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|msg
op_plus
id|i
comma
l_string|&quot;committer &quot;
)paren
)paren
(brace
id|context-&gt;committer.off
op_assign
id|i
op_plus
l_int|10
suffix:semicolon
id|context-&gt;committer.len
op_assign
id|eol
id|i
l_int|10
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|msg
op_plus
id|i
comma
l_string|&quot;encoding &quot;
)paren
)paren
(brace
id|context-&gt;encoding.off
op_assign
id|i
op_plus
l_int|9
suffix:semicolon
id|context-&gt;encoding.len
op_assign
id|eol
id|i
l_int|9
suffix:semicolon
)brace
id|i
op_assign
id|eol
suffix:semicolon
)brace
id|context-&gt;message_off
op_assign
id|i
suffix:semicolon
id|context-&gt;commit_header_parsed
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|istitlechar
r_static
r_int
id|istitlechar
c_func
(paren
r_char
id|c
)paren
(brace
r_return
(paren
id|c
op_ge
l_char|&squot;a&squot;
op_logical_and
id|c
op_le
l_char|&squot;z&squot;
)paren
op_logical_or
(paren
id|c
op_ge
l_char|&squot;A&squot;
op_logical_and
id|c
op_le
l_char|&squot;Z&squot;
)paren
op_logical_or
(paren
id|c
op_ge
l_char|&squot;0&squot;
op_logical_and
id|c
op_le
l_char|&squot;9&squot;
)paren
op_logical_or
id|c
op_eq
l_char|&squot;.&squot;
op_logical_or
id|c
op_eq
l_char|&squot;_&squot;
suffix:semicolon
)brace
DECL|function|format_sanitized_subject
r_static
r_void
id|format_sanitized_subject
c_func
(paren
r_struct
id|strbuf
op_star
id|sb
comma
r_const
r_char
op_star
id|msg
)paren
(brace
r_int
id|trimlen
suffix:semicolon
r_int
id|start_len
op_assign
id|sb-&gt;len
suffix:semicolon
r_int
id|space
op_assign
l_int|2
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
op_star
id|msg
op_logical_and
op_star
id|msg
op_ne
l_char|&squot;&bslash;n&squot;
suffix:semicolon
id|msg
op_increment
)paren
(brace
r_if
c_cond
(paren
id|istitlechar
c_func
(paren
op_star
id|msg
)paren
)paren
(brace
r_if
c_cond
(paren
id|space
op_eq
l_int|1
)paren
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot;-&squot;
)paren
suffix:semicolon
id|space
op_assign
l_int|0
suffix:semicolon
id|strbuf_addch
c_func
(paren
id|sb
comma
op_star
id|msg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|msg
op_eq
l_char|&squot;.&squot;
)paren
r_while
c_loop
(paren
op_star
(paren
id|msg
op_plus
l_int|1
)paren
op_eq
l_char|&squot;.&squot;
)paren
id|msg
op_increment
suffix:semicolon
)brace
r_else
id|space
op_or_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* trim any trailing &squot;.&squot; or &squot;-&squot; characters */
id|trimlen
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|sb-&gt;len
id|trimlen
OG
id|start_len
op_logical_and
(paren
id|sb-&gt;buf
(braket
id|sb-&gt;len
l_int|1
id|trimlen
)braket
op_eq
l_char|&squot;.&squot;
op_logical_or
id|sb-&gt;buf
(braket
id|sb-&gt;len
l_int|1
id|trimlen
)braket
op_eq
l_char|&squot;-&squot;
)paren
)paren
id|trimlen
op_increment
suffix:semicolon
id|strbuf_remove
c_func
(paren
id|sb
comma
id|sb-&gt;len
id|trimlen
comma
id|trimlen
)paren
suffix:semicolon
)brace
DECL|function|format_subject
r_const
r_char
op_star
id|format_subject
c_func
(paren
r_struct
id|strbuf
op_star
id|sb
comma
r_const
r_char
op_star
id|msg
comma
r_const
r_char
op_star
id|line_separator
)paren
(brace
r_int
id|first
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_const
r_char
op_star
id|line
op_assign
id|msg
suffix:semicolon
r_int
id|linelen
op_assign
id|get_one_line
c_func
(paren
id|line
)paren
suffix:semicolon
id|msg
op_add_assign
id|linelen
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|linelen
op_logical_or
id|is_empty_line
c_func
(paren
id|line
comma
op_amp
id|linelen
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sb
)paren
r_continue
suffix:semicolon
id|strbuf_grow
c_func
(paren
id|sb
comma
id|linelen
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|first
)paren
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|line_separator
)paren
suffix:semicolon
id|strbuf_add
c_func
(paren
id|sb
comma
id|line
comma
id|linelen
)paren
suffix:semicolon
id|first
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|msg
suffix:semicolon
)brace
DECL|function|parse_commit_message
r_static
r_void
id|parse_commit_message
c_func
(paren
r_struct
id|format_commit_context
op_star
id|c
)paren
(brace
r_const
r_char
op_star
id|msg
op_assign
id|c-&gt;message
op_plus
id|c-&gt;message_off
suffix:semicolon
r_const
r_char
op_star
id|start
op_assign
id|c-&gt;message
suffix:semicolon
id|msg
op_assign
id|skip_empty_lines
c_func
(paren
id|msg
)paren
suffix:semicolon
id|c-&gt;subject_off
op_assign
id|msg
id|start
suffix:semicolon
id|msg
op_assign
id|format_subject
c_func
(paren
l_int|NULL
comma
id|msg
comma
l_int|NULL
)paren
suffix:semicolon
id|msg
op_assign
id|skip_empty_lines
c_func
(paren
id|msg
)paren
suffix:semicolon
id|c-&gt;body_off
op_assign
id|msg
id|start
suffix:semicolon
id|c-&gt;commit_message_parsed
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|format_decoration
r_static
r_void
id|format_decoration
c_func
(paren
r_struct
id|strbuf
op_star
id|sb
comma
r_const
r_struct
id|commit
op_star
id|commit
)paren
(brace
r_struct
id|name_decoration
op_star
id|d
suffix:semicolon
r_const
r_char
op_star
id|prefix
op_assign
l_string|&quot; (&quot;
suffix:semicolon
id|load_ref_decorations
c_func
(paren
id|DECORATE_SHORT_REFS
)paren
suffix:semicolon
id|d
op_assign
id|lookup_decoration
c_func
(paren
op_amp
id|name_decoration
comma
op_amp
id|commit-&gt;object
)paren
suffix:semicolon
r_while
c_loop
(paren
id|d
)paren
(brace
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|prefix
)paren
suffix:semicolon
id|prefix
op_assign
l_string|&quot;, &quot;
suffix:semicolon
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|d-&gt;name
)paren
suffix:semicolon
id|d
op_assign
id|d-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|prefix
(braket
l_int|0
)braket
op_eq
l_char|&squot;,&squot;
)paren
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot;)&squot;
)paren
suffix:semicolon
)brace
DECL|function|strbuf_wrap
r_static
r_void
id|strbuf_wrap
c_func
(paren
r_struct
id|strbuf
op_star
id|sb
comma
r_int
id|pos
comma
r_int
id|width
comma
r_int
id|indent1
comma
r_int
id|indent2
)paren
(brace
r_struct
id|strbuf
id|tmp
op_assign
id|STRBUF_INIT
suffix:semicolon
r_if
c_cond
(paren
id|pos
)paren
id|strbuf_add
c_func
(paren
op_amp
id|tmp
comma
id|sb-&gt;buf
comma
id|pos
)paren
suffix:semicolon
id|strbuf_add_wrapped_text
c_func
(paren
op_amp
id|tmp
comma
id|sb-&gt;buf
op_plus
id|pos
comma
(paren
r_int
)paren
id|indent1
comma
(paren
r_int
)paren
id|indent2
comma
(paren
r_int
)paren
id|width
)paren
suffix:semicolon
id|strbuf_swap
c_func
(paren
op_amp
id|tmp
comma
id|sb
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|tmp
)paren
suffix:semicolon
)brace
DECL|function|rewrap_message_tail
r_static
r_void
id|rewrap_message_tail
c_func
(paren
r_struct
id|strbuf
op_star
id|sb
comma
r_struct
id|format_commit_context
op_star
id|c
comma
r_int
id|new_width
comma
r_int
id|new_indent1
comma
r_int
id|new_indent2
)paren
(brace
r_if
c_cond
(paren
id|c-&gt;width
op_eq
id|new_width
op_logical_and
id|c-&gt;indent1
op_eq
id|new_indent1
op_logical_and
id|c-&gt;indent2
op_eq
id|new_indent2
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;wrap_start
OL
id|sb-&gt;len
)paren
id|strbuf_wrap
c_func
(paren
id|sb
comma
id|c-&gt;wrap_start
comma
id|c-&gt;width
comma
id|c-&gt;indent1
comma
id|c-&gt;indent2
)paren
suffix:semicolon
id|c-&gt;wrap_start
op_assign
id|sb-&gt;len
suffix:semicolon
id|c-&gt;width
op_assign
id|new_width
suffix:semicolon
id|c-&gt;indent1
op_assign
id|new_indent1
suffix:semicolon
id|c-&gt;indent2
op_assign
id|new_indent2
suffix:semicolon
)brace
r_static
r_struct
(brace
DECL|member|result
r_char
id|result
suffix:semicolon
DECL|member|check
r_const
r_char
op_star
id|check
suffix:semicolon
DECL|variable|signature_check
)brace
id|signature_check
(braket
)braket
op_assign
(brace
(brace
l_char|&squot;G&squot;
comma
l_string|&quot;&bslash;n[GNUPG:] GOODSIG &quot;
)brace
comma
(brace
l_char|&squot;B&squot;
comma
l_string|&quot;&bslash;n[GNUPG:] BADSIG &quot;
)brace
comma
)brace
suffix:semicolon
DECL|function|parse_signature_lines
r_static
r_void
id|parse_signature_lines
c_func
(paren
r_struct
id|format_commit_context
op_star
id|ctx
)paren
(brace
r_const
r_char
op_star
id|buf
op_assign
id|ctx-&gt;signature.gpg_status
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|signature_check
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_char
op_star
id|found
op_assign
id|strstr
c_func
(paren
id|buf
comma
id|signature_check
(braket
id|i
)braket
dot
id|check
)paren
suffix:semicolon
r_const
r_char
op_star
id|next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
r_continue
suffix:semicolon
id|ctx-&gt;signature.good_bad
op_assign
id|signature_check
(braket
id|i
)braket
dot
id|result
suffix:semicolon
id|found
op_add_assign
id|strlen
c_func
(paren
id|signature_check
(braket
id|i
)braket
dot
id|check
)paren
suffix:semicolon
id|ctx-&gt;signature.key
op_assign
id|xmemdupz
c_func
(paren
id|found
comma
l_int|16
)paren
suffix:semicolon
id|found
op_add_assign
l_int|17
suffix:semicolon
id|next
op_assign
id|strchrnul
c_func
(paren
id|found
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|ctx-&gt;signature.signer
op_assign
id|xmemdupz
c_func
(paren
id|found
comma
id|next
id|found
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|function|parse_commit_signature
r_static
r_void
id|parse_commit_signature
c_func
(paren
r_struct
id|format_commit_context
op_star
id|ctx
)paren
(brace
r_struct
id|strbuf
id|payload
op_assign
id|STRBUF_INIT
suffix:semicolon
r_struct
id|strbuf
id|signature
op_assign
id|STRBUF_INIT
suffix:semicolon
r_struct
id|strbuf
id|gpg_output
op_assign
id|STRBUF_INIT
suffix:semicolon
r_struct
id|strbuf
id|gpg_status
op_assign
id|STRBUF_INIT
suffix:semicolon
r_int
id|status
suffix:semicolon
id|ctx-&gt;commit_signature_parsed
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|parse_signed_commit
c_func
(paren
id|ctx-&gt;commit-&gt;object.sha1
comma
op_amp
id|payload
comma
op_amp
id|signature
)paren
op_le
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|status
op_assign
id|verify_signed_buffer
c_func
(paren
id|payload.buf
comma
id|payload.len
comma
id|signature.buf
comma
id|signature.len
comma
op_amp
id|gpg_output
comma
op_amp
id|gpg_status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_logical_and
op_logical_neg
id|gpg_output.len
)paren
r_goto
id|out
suffix:semicolon
id|ctx-&gt;signature.gpg_output
op_assign
id|strbuf_detach
c_func
(paren
op_amp
id|gpg_output
comma
l_int|NULL
)paren
suffix:semicolon
id|ctx-&gt;signature.gpg_status
op_assign
id|strbuf_detach
c_func
(paren
op_amp
id|gpg_status
comma
l_int|NULL
)paren
suffix:semicolon
id|parse_signature_lines
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|out
suffix:colon
id|strbuf_release
c_func
(paren
op_amp
id|gpg_status
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|gpg_output
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|payload
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|signature
)paren
suffix:semicolon
)brace
DECL|function|format_reflog_person
r_static
r_int
id|format_reflog_person
c_func
(paren
r_struct
id|strbuf
op_star
id|sb
comma
r_char
id|part
comma
r_struct
id|reflog_walk_info
op_star
id|log
comma
r_enum
id|date_mode
id|dmode
)paren
(brace
r_const
r_char
op_star
id|ident
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|log
)paren
r_return
l_int|2
suffix:semicolon
id|ident
op_assign
id|get_reflog_ident
c_func
(paren
id|log
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ident
)paren
r_return
l_int|2
suffix:semicolon
r_return
id|format_person_part
c_func
(paren
id|sb
comma
id|part
comma
id|ident
comma
id|strlen
c_func
(paren
id|ident
)paren
comma
id|dmode
)paren
suffix:semicolon
)brace
DECL|function|format_commit_one
r_static
r_int
id|format_commit_one
c_func
(paren
r_struct
id|strbuf
op_star
id|sb
comma
r_const
r_char
op_star
id|placeholder
comma
r_void
op_star
id|context
)paren
(brace
r_struct
id|format_commit_context
op_star
id|c
op_assign
id|context
suffix:semicolon
r_const
r_struct
id|commit
op_star
id|commit
op_assign
id|c-&gt;commit
suffix:semicolon
r_const
r_char
op_star
id|msg
op_assign
id|c-&gt;message
suffix:semicolon
r_struct
id|commit_list
op_star
id|p
suffix:semicolon
r_int
id|h1
comma
id|h2
suffix:semicolon
multiline_comment|/* these are independent of the commit */
r_switch
c_cond
(paren
id|placeholder
(braket
l_int|0
)braket
)paren
(brace
r_case
l_char|&squot;C&squot;
suffix:colon
r_if
c_cond
(paren
id|placeholder
(braket
l_int|1
)braket
op_eq
l_char|&squot;(&squot;
)paren
(brace
r_const
r_char
op_star
id|begin
op_assign
id|placeholder
op_plus
l_int|2
suffix:semicolon
r_const
r_char
op_star
id|end
op_assign
id|strchr
c_func
(paren
id|begin
comma
l_char|&squot;)&squot;
)paren
suffix:semicolon
r_char
id|color
(braket
id|COLOR_MAXLEN
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|end
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|begin
comma
l_string|&quot;auto,&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|want_color
c_func
(paren
id|c-&gt;pretty_ctx-&gt;color
)paren
)paren
r_return
id|end
id|placeholder
op_plus
l_int|1
suffix:semicolon
id|begin
op_add_assign
l_int|5
suffix:semicolon
)brace
id|color_parse_mem
c_func
(paren
id|begin
comma
id|end
id|begin
comma
l_string|&quot;--pretty format&quot;
comma
id|color
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|color
)paren
suffix:semicolon
r_return
id|end
id|placeholder
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|placeholder
op_plus
l_int|1
comma
l_string|&quot;red&quot;
)paren
)paren
(brace
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|GIT_COLOR_RED
)paren
suffix:semicolon
r_return
l_int|4
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|placeholder
op_plus
l_int|1
comma
l_string|&quot;green&quot;
)paren
)paren
(brace
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|GIT_COLOR_GREEN
)paren
suffix:semicolon
r_return
l_int|6
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|placeholder
op_plus
l_int|1
comma
l_string|&quot;blue&quot;
)paren
)paren
(brace
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|GIT_COLOR_BLUE
)paren
suffix:semicolon
r_return
l_int|5
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|placeholder
op_plus
l_int|1
comma
l_string|&quot;reset&quot;
)paren
)paren
(brace
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|GIT_COLOR_RESET
)paren
suffix:semicolon
r_return
l_int|6
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
r_case
l_char|&squot;n&squot;
suffix:colon
multiline_comment|/* newline */
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_case
l_char|&squot;x&squot;
suffix:colon
multiline_comment|/* %x00 == NUL, %x0a == LF, etc. */
r_if
c_cond
(paren
l_int|0
op_le
(paren
id|h1
op_assign
id|hexval_table
(braket
l_int|0xff
op_amp
id|placeholder
(braket
l_int|1
)braket
)braket
)paren
op_logical_and
id|h1
op_le
l_int|16
op_logical_and
l_int|0
op_le
(paren
id|h2
op_assign
id|hexval_table
(braket
l_int|0xff
op_amp
id|placeholder
(braket
l_int|2
)braket
)braket
)paren
op_logical_and
id|h2
op_le
l_int|16
)paren
(brace
id|strbuf_addch
c_func
(paren
id|sb
comma
(paren
id|h1
op_lshift
l_int|4
)paren
op_or
id|h2
)paren
suffix:semicolon
r_return
l_int|3
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
r_case
l_char|&squot;w&squot;
suffix:colon
r_if
c_cond
(paren
id|placeholder
(braket
l_int|1
)braket
op_eq
l_char|&squot;(&squot;
)paren
(brace
r_int
r_int
id|width
op_assign
l_int|0
comma
id|indent1
op_assign
l_int|0
comma
id|indent2
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|next
suffix:semicolon
r_const
r_char
op_star
id|start
op_assign
id|placeholder
op_plus
l_int|2
suffix:semicolon
r_const
r_char
op_star
id|end
op_assign
id|strchr
c_func
(paren
id|start
comma
l_char|&squot;)&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|end
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|end
OG
id|start
)paren
(brace
id|width
op_assign
id|strtoul
c_func
(paren
id|start
comma
op_amp
id|next
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|next
op_eq
l_char|&squot;,&squot;
)paren
(brace
id|indent1
op_assign
id|strtoul
c_func
(paren
id|next
op_plus
l_int|1
comma
op_amp
id|next
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|next
op_eq
l_char|&squot;,&squot;
)paren
(brace
id|indent2
op_assign
id|strtoul
c_func
(paren
id|next
op_plus
l_int|1
comma
op_amp
id|next
comma
l_int|10
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_star
id|next
op_ne
l_char|&squot;)&squot;
)paren
r_return
l_int|0
suffix:semicolon
)brace
id|rewrap_message_tail
c_func
(paren
id|sb
comma
id|c
comma
id|width
comma
id|indent1
comma
id|indent2
)paren
suffix:semicolon
r_return
id|end
id|placeholder
op_plus
l_int|1
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* these depend on the commit */
r_if
c_cond
(paren
op_logical_neg
id|commit-&gt;object.parsed
)paren
id|parse_object
c_func
(paren
id|commit-&gt;object.sha1
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|placeholder
(braket
l_int|0
)braket
)paren
(brace
r_case
l_char|&squot;H&squot;
suffix:colon
multiline_comment|/* commit hash */
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|sha1_to_hex
c_func
(paren
id|commit-&gt;object.sha1
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_case
l_char|&squot;h&squot;
suffix:colon
multiline_comment|/* abbreviated commit hash */
r_if
c_cond
(paren
id|add_again
c_func
(paren
id|sb
comma
op_amp
id|c-&gt;abbrev_commit_hash
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|find_unique_abbrev
c_func
(paren
id|commit-&gt;object.sha1
comma
id|c-&gt;pretty_ctx-&gt;abbrev
)paren
)paren
suffix:semicolon
id|c-&gt;abbrev_commit_hash.len
op_assign
id|sb-&gt;len
id|c-&gt;abbrev_commit_hash.off
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_case
l_char|&squot;T&squot;
suffix:colon
multiline_comment|/* tree hash */
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|sha1_to_hex
c_func
(paren
id|commit-&gt;tree-&gt;object.sha1
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_case
l_char|&squot;t&squot;
suffix:colon
multiline_comment|/* abbreviated tree hash */
r_if
c_cond
(paren
id|add_again
c_func
(paren
id|sb
comma
op_amp
id|c-&gt;abbrev_tree_hash
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|find_unique_abbrev
c_func
(paren
id|commit-&gt;tree-&gt;object.sha1
comma
id|c-&gt;pretty_ctx-&gt;abbrev
)paren
)paren
suffix:semicolon
id|c-&gt;abbrev_tree_hash.len
op_assign
id|sb-&gt;len
id|c-&gt;abbrev_tree_hash.off
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_case
l_char|&squot;P&squot;
suffix:colon
multiline_comment|/* parent hashes */
r_for
c_loop
(paren
id|p
op_assign
id|commit-&gt;parents
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|p
op_ne
id|commit-&gt;parents
)paren
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|sha1_to_hex
c_func
(paren
id|p-&gt;item-&gt;object.sha1
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
r_case
l_char|&squot;p&squot;
suffix:colon
multiline_comment|/* abbreviated parent hashes */
r_if
c_cond
(paren
id|add_again
c_func
(paren
id|sb
comma
op_amp
id|c-&gt;abbrev_parent_hashes
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|commit-&gt;parents
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|p
op_ne
id|commit-&gt;parents
)paren
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|find_unique_abbrev
c_func
(paren
id|p-&gt;item-&gt;object.sha1
comma
id|c-&gt;pretty_ctx-&gt;abbrev
)paren
)paren
suffix:semicolon
)brace
id|c-&gt;abbrev_parent_hashes.len
op_assign
id|sb-&gt;len
id|c-&gt;abbrev_parent_hashes.off
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_case
l_char|&squot;m&squot;
suffix:colon
multiline_comment|/* left/right/bottom */
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|get_revision_mark
c_func
(paren
l_int|NULL
comma
id|commit
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_case
l_char|&squot;d&squot;
suffix:colon
id|format_decoration
c_func
(paren
id|sb
comma
id|commit
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_case
l_char|&squot;g&squot;
suffix:colon
multiline_comment|/* reflog info */
r_switch
c_cond
(paren
id|placeholder
(braket
l_int|1
)braket
)paren
(brace
r_case
l_char|&squot;d&squot;
suffix:colon
multiline_comment|/* reflog selector */
r_case
l_char|&squot;D&squot;
suffix:colon
r_if
c_cond
(paren
id|c-&gt;pretty_ctx-&gt;reflog_info
)paren
id|get_reflog_selector
c_func
(paren
id|sb
comma
id|c-&gt;pretty_ctx-&gt;reflog_info
comma
id|c-&gt;pretty_ctx-&gt;date_mode
comma
id|c-&gt;pretty_ctx-&gt;date_mode_explicit
comma
(paren
id|placeholder
(braket
l_int|1
)braket
op_eq
l_char|&squot;d&squot;
)paren
)paren
suffix:semicolon
r_return
l_int|2
suffix:semicolon
r_case
l_char|&squot;s&squot;
suffix:colon
multiline_comment|/* reflog message */
r_if
c_cond
(paren
id|c-&gt;pretty_ctx-&gt;reflog_info
)paren
id|get_reflog_message
c_func
(paren
id|sb
comma
id|c-&gt;pretty_ctx-&gt;reflog_info
)paren
suffix:semicolon
r_return
l_int|2
suffix:semicolon
r_case
l_char|&squot;n&squot;
suffix:colon
r_case
l_char|&squot;N&squot;
suffix:colon
r_case
l_char|&squot;e&squot;
suffix:colon
r_case
l_char|&squot;E&squot;
suffix:colon
r_return
id|format_reflog_person
c_func
(paren
id|sb
comma
id|placeholder
(braket
l_int|1
)braket
comma
id|c-&gt;pretty_ctx-&gt;reflog_info
comma
id|c-&gt;pretty_ctx-&gt;date_mode
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* unknown %g placeholder */
r_case
l_char|&squot;N&squot;
suffix:colon
r_if
c_cond
(paren
id|c-&gt;pretty_ctx-&gt;notes_message
)paren
(brace
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|c-&gt;pretty_ctx-&gt;notes_message
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|placeholder
(braket
l_int|0
)braket
op_eq
l_char|&squot;G&squot;
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;commit_signature_parsed
)paren
id|parse_commit_signature
c_func
(paren
id|c
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|placeholder
(braket
l_int|1
)braket
)paren
(brace
r_case
l_char|&squot;G&squot;
suffix:colon
r_if
c_cond
(paren
id|c-&gt;signature.gpg_output
)paren
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|c-&gt;signature.gpg_output
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;?&squot;
suffix:colon
r_switch
c_cond
(paren
id|c-&gt;signature.good_bad
)paren
(brace
r_case
l_char|&squot;G&squot;
suffix:colon
r_case
l_char|&squot;B&squot;
suffix:colon
id|strbuf_addch
c_func
(paren
id|sb
comma
id|c-&gt;signature.good_bad
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;S&squot;
suffix:colon
r_if
c_cond
(paren
id|c-&gt;signature.signer
)paren
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|c-&gt;signature.signer
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;K&squot;
suffix:colon
r_if
c_cond
(paren
id|c-&gt;signature.key
)paren
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|c-&gt;signature.key
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
l_int|2
suffix:semicolon
)brace
multiline_comment|/* For the rest we have to parse the commit header. */
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;commit_header_parsed
)paren
id|parse_commit_header
c_func
(paren
id|c
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|placeholder
(braket
l_int|0
)braket
)paren
(brace
r_case
l_char|&squot;a&squot;
suffix:colon
multiline_comment|/* author ... */
r_return
id|format_person_part
c_func
(paren
id|sb
comma
id|placeholder
(braket
l_int|1
)braket
comma
id|msg
op_plus
id|c-&gt;author.off
comma
id|c-&gt;author.len
comma
id|c-&gt;pretty_ctx-&gt;date_mode
)paren
suffix:semicolon
r_case
l_char|&squot;c&squot;
suffix:colon
multiline_comment|/* committer ... */
r_return
id|format_person_part
c_func
(paren
id|sb
comma
id|placeholder
(braket
l_int|1
)braket
comma
id|msg
op_plus
id|c-&gt;committer.off
comma
id|c-&gt;committer.len
comma
id|c-&gt;pretty_ctx-&gt;date_mode
)paren
suffix:semicolon
r_case
l_char|&squot;e&squot;
suffix:colon
multiline_comment|/* encoding */
id|strbuf_add
c_func
(paren
id|sb
comma
id|msg
op_plus
id|c-&gt;encoding.off
comma
id|c-&gt;encoding.len
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_case
l_char|&squot;B&squot;
suffix:colon
multiline_comment|/* raw body */
multiline_comment|/* message_off is always left at the initial newline */
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|msg
op_plus
id|c-&gt;message_off
op_plus
l_int|1
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Now we need to parse the commit message. */
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;commit_message_parsed
)paren
id|parse_commit_message
c_func
(paren
id|c
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|placeholder
(braket
l_int|0
)braket
)paren
(brace
r_case
l_char|&squot;s&squot;
suffix:colon
multiline_comment|/* subject */
id|format_subject
c_func
(paren
id|sb
comma
id|msg
op_plus
id|c-&gt;subject_off
comma
l_string|&quot; &quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_case
l_char|&squot;f&squot;
suffix:colon
multiline_comment|/* sanitized subject */
id|format_sanitized_subject
c_func
(paren
id|sb
comma
id|msg
op_plus
id|c-&gt;subject_off
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_case
l_char|&squot;b&squot;
suffix:colon
multiline_comment|/* body */
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|msg
op_plus
id|c-&gt;body_off
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* unknown placeholder */
)brace
DECL|function|format_commit_item
r_static
r_int
id|format_commit_item
c_func
(paren
r_struct
id|strbuf
op_star
id|sb
comma
r_const
r_char
op_star
id|placeholder
comma
r_void
op_star
id|context
)paren
(brace
r_int
id|consumed
suffix:semicolon
r_int
id|orig_len
suffix:semicolon
r_enum
(brace
id|NO_MAGIC
comma
id|ADD_LF_BEFORE_NON_EMPTY
comma
id|DEL_LF_BEFORE_EMPTY
comma
id|ADD_SP_BEFORE_NON_EMPTY
)brace
id|magic
op_assign
id|NO_MAGIC
suffix:semicolon
r_switch
c_cond
(paren
id|placeholder
(braket
l_int|0
)braket
)paren
(brace
r_case
l_char|&squot;-&squot;
suffix:colon
id|magic
op_assign
id|DEL_LF_BEFORE_EMPTY
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;+&squot;
suffix:colon
id|magic
op_assign
id|ADD_LF_BEFORE_NON_EMPTY
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot; &squot;
suffix:colon
id|magic
op_assign
id|ADD_SP_BEFORE_NON_EMPTY
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|magic
op_ne
id|NO_MAGIC
)paren
id|placeholder
op_increment
suffix:semicolon
id|orig_len
op_assign
id|sb-&gt;len
suffix:semicolon
id|consumed
op_assign
id|format_commit_one
c_func
(paren
id|sb
comma
id|placeholder
comma
id|context
)paren
suffix:semicolon
r_if
c_cond
(paren
id|magic
op_eq
id|NO_MAGIC
)paren
r_return
id|consumed
suffix:semicolon
r_if
c_cond
(paren
(paren
id|orig_len
op_eq
id|sb-&gt;len
)paren
op_logical_and
id|magic
op_eq
id|DEL_LF_BEFORE_EMPTY
)paren
(brace
r_while
c_loop
(paren
id|sb-&gt;len
op_logical_and
id|sb-&gt;buf
(braket
id|sb-&gt;len
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|strbuf_setlen
c_func
(paren
id|sb
comma
id|sb-&gt;len
l_int|1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|orig_len
op_ne
id|sb-&gt;len
)paren
(brace
r_if
c_cond
(paren
id|magic
op_eq
id|ADD_LF_BEFORE_NON_EMPTY
)paren
id|strbuf_insert
c_func
(paren
id|sb
comma
id|orig_len
comma
l_string|&quot;&bslash;n&quot;
comma
l_int|1
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|magic
op_eq
id|ADD_SP_BEFORE_NON_EMPTY
)paren
id|strbuf_insert
c_func
(paren
id|sb
comma
id|orig_len
comma
l_string|&quot; &quot;
comma
l_int|1
)paren
suffix:semicolon
)brace
r_return
id|consumed
op_plus
l_int|1
suffix:semicolon
)brace
DECL|function|userformat_want_item
r_static
r_int
id|userformat_want_item
c_func
(paren
r_struct
id|strbuf
op_star
id|sb
comma
r_const
r_char
op_star
id|placeholder
comma
r_void
op_star
id|context
)paren
(brace
r_struct
id|userformat_want
op_star
id|w
op_assign
id|context
suffix:semicolon
r_if
c_cond
(paren
op_star
id|placeholder
op_eq
l_char|&squot;+&squot;
op_logical_or
op_star
id|placeholder
op_eq
l_char|&squot;-&squot;
op_logical_or
op_star
id|placeholder
op_eq
l_char|&squot; &squot;
)paren
id|placeholder
op_increment
suffix:semicolon
r_switch
c_cond
(paren
op_star
id|placeholder
)paren
(brace
r_case
l_char|&squot;N&squot;
suffix:colon
id|w-&gt;notes
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|userformat_find_requirements
r_void
id|userformat_find_requirements
c_func
(paren
r_const
r_char
op_star
id|fmt
comma
r_struct
id|userformat_want
op_star
id|w
)paren
(brace
r_struct
id|strbuf
id|dummy
op_assign
id|STRBUF_INIT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fmt
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|user_format
)paren
r_return
suffix:semicolon
id|fmt
op_assign
id|user_format
suffix:semicolon
)brace
id|strbuf_expand
c_func
(paren
op_amp
id|dummy
comma
id|fmt
comma
id|userformat_want_item
comma
id|w
)paren
suffix:semicolon
id|strbuf_release
c_func
(paren
op_amp
id|dummy
)paren
suffix:semicolon
)brace
DECL|function|format_commit_message
r_void
id|format_commit_message
c_func
(paren
r_const
r_struct
id|commit
op_star
id|commit
comma
r_const
r_char
op_star
id|format
comma
r_struct
id|strbuf
op_star
id|sb
comma
r_const
r_struct
id|pretty_print_context
op_star
id|pretty_ctx
)paren
(brace
r_struct
id|format_commit_context
id|context
suffix:semicolon
r_const
r_char
op_star
id|output_enc
op_assign
id|pretty_ctx-&gt;output_encoding
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|context
comma
l_int|0
comma
r_sizeof
(paren
id|context
)paren
)paren
suffix:semicolon
id|context.commit
op_assign
id|commit
suffix:semicolon
id|context.pretty_ctx
op_assign
id|pretty_ctx
suffix:semicolon
id|context.wrap_start
op_assign
id|sb-&gt;len
suffix:semicolon
id|context.message
op_assign
id|logmsg_reencode
c_func
(paren
id|commit
comma
id|output_enc
)paren
suffix:semicolon
id|strbuf_expand
c_func
(paren
id|sb
comma
id|format
comma
id|format_commit_item
comma
op_amp
id|context
)paren
suffix:semicolon
id|rewrap_message_tail
c_func
(paren
id|sb
comma
op_amp
id|context
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|logmsg_free
c_func
(paren
id|context.message
comma
id|commit
)paren
suffix:semicolon
id|free
c_func
(paren
id|context.signature.gpg_output
)paren
suffix:semicolon
id|free
c_func
(paren
id|context.signature.signer
)paren
suffix:semicolon
)brace
DECL|function|pp_header
r_static
r_void
id|pp_header
c_func
(paren
r_const
r_struct
id|pretty_print_context
op_star
id|pp
comma
r_const
r_char
op_star
id|encoding
comma
r_const
r_struct
id|commit
op_star
id|commit
comma
r_const
r_char
op_star
op_star
id|msg_p
comma
r_struct
id|strbuf
op_star
id|sb
)paren
(brace
r_int
id|parents_shown
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_const
r_char
op_star
id|line
op_assign
op_star
id|msg_p
suffix:semicolon
r_int
id|linelen
op_assign
id|get_one_line
c_func
(paren
op_star
id|msg_p
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|linelen
)paren
r_return
suffix:semicolon
op_star
id|msg_p
op_add_assign
id|linelen
suffix:semicolon
r_if
c_cond
(paren
id|linelen
op_eq
l_int|1
)paren
multiline_comment|/* End of header */
r_return
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;fmt
op_eq
id|CMIT_FMT_RAW
)paren
(brace
id|strbuf_add
c_func
(paren
id|sb
comma
id|line
comma
id|linelen
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|line
comma
l_string|&quot;parent &quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|linelen
op_ne
l_int|48
)paren
id|die
c_func
(paren
l_string|&quot;bad parent line in commit&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|parents_shown
)paren
(brace
r_struct
id|commit_list
op_star
id|parent
suffix:semicolon
r_int
id|num
suffix:semicolon
r_for
c_loop
(paren
id|parent
op_assign
id|commit-&gt;parents
comma
id|num
op_assign
l_int|0
suffix:semicolon
id|parent
suffix:semicolon
id|parent
op_assign
id|parent-&gt;next
comma
id|num
op_increment
)paren
suffix:semicolon
multiline_comment|/* with enough slop */
id|strbuf_grow
c_func
(paren
id|sb
comma
id|num
op_star
l_int|50
op_plus
l_int|20
)paren
suffix:semicolon
id|add_merge_info
c_func
(paren
id|pp
comma
id|sb
comma
id|commit
)paren
suffix:semicolon
id|parents_shown
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * MEDIUM == DEFAULT shows only author with dates.&n;&t;&t; * FULL shows both authors but not dates.&n;&t;&t; * FULLER shows both authors and dates.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|line
comma
l_string|&quot;author &quot;
)paren
)paren
(brace
id|strbuf_grow
c_func
(paren
id|sb
comma
id|linelen
op_plus
l_int|80
)paren
suffix:semicolon
id|pp_user_info
c_func
(paren
id|pp
comma
l_string|&quot;Author&quot;
comma
id|sb
comma
id|line
op_plus
l_int|7
comma
id|encoding
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|prefixcmp
c_func
(paren
id|line
comma
l_string|&quot;committer &quot;
)paren
op_logical_and
(paren
id|pp-&gt;fmt
op_eq
id|CMIT_FMT_FULL
op_logical_or
id|pp-&gt;fmt
op_eq
id|CMIT_FMT_FULLER
)paren
)paren
(brace
id|strbuf_grow
c_func
(paren
id|sb
comma
id|linelen
op_plus
l_int|80
)paren
suffix:semicolon
id|pp_user_info
c_func
(paren
id|pp
comma
l_string|&quot;Commit&quot;
comma
id|sb
comma
id|line
op_plus
l_int|10
comma
id|encoding
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|pp_title_line
r_void
id|pp_title_line
c_func
(paren
r_const
r_struct
id|pretty_print_context
op_star
id|pp
comma
r_const
r_char
op_star
op_star
id|msg_p
comma
r_struct
id|strbuf
op_star
id|sb
comma
r_const
r_char
op_star
id|encoding
comma
r_int
id|need_8bit_cte
)paren
(brace
r_static
r_const
r_int
id|max_length
op_assign
l_int|78
suffix:semicolon
multiline_comment|/* per rfc2047 */
r_struct
id|strbuf
id|title
suffix:semicolon
id|strbuf_init
c_func
(paren
op_amp
id|title
comma
l_int|80
)paren
suffix:semicolon
op_star
id|msg_p
op_assign
id|format_subject
c_func
(paren
op_amp
id|title
comma
op_star
id|msg_p
comma
id|pp-&gt;preserve_subject
ques
c_cond
l_string|&quot;&bslash;n&quot;
suffix:colon
l_string|&quot; &quot;
)paren
suffix:semicolon
id|strbuf_grow
c_func
(paren
id|sb
comma
id|title.len
op_plus
l_int|1024
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;subject
)paren
(brace
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|pp-&gt;subject
)paren
suffix:semicolon
r_if
c_cond
(paren
id|needs_rfc2047_encoding
c_func
(paren
id|title.buf
comma
id|title.len
comma
id|RFC2047_SUBJECT
)paren
)paren
id|add_rfc2047
c_func
(paren
id|sb
comma
id|title.buf
comma
id|title.len
comma
id|encoding
comma
id|RFC2047_SUBJECT
)paren
suffix:semicolon
r_else
id|strbuf_add_wrapped_bytes
c_func
(paren
id|sb
comma
id|title.buf
comma
id|title.len
comma
id|last_line_length
c_func
(paren
id|sb
)paren
comma
l_int|1
comma
id|max_length
)paren
suffix:semicolon
)brace
r_else
(brace
id|strbuf_addbuf
c_func
(paren
id|sb
comma
op_amp
id|title
)paren
suffix:semicolon
)brace
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|need_8bit_cte
OG
l_int|0
)paren
(brace
r_const
r_char
op_star
id|header_fmt
op_assign
l_string|&quot;MIME-Version: 1.0&bslash;n&quot;
l_string|&quot;Content-Type: text/plain; charset=%s&bslash;n&quot;
l_string|&quot;Content-Transfer-Encoding: 8bit&bslash;n&quot;
suffix:semicolon
id|strbuf_addf
c_func
(paren
id|sb
comma
id|header_fmt
comma
id|encoding
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pp-&gt;after_subject
)paren
(brace
id|strbuf_addstr
c_func
(paren
id|sb
comma
id|pp-&gt;after_subject
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pp-&gt;fmt
op_eq
id|CMIT_FMT_EMAIL
)paren
(brace
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
id|strbuf_release
c_func
(paren
op_amp
id|title
)paren
suffix:semicolon
)brace
DECL|function|pp_remainder
r_void
id|pp_remainder
c_func
(paren
r_const
r_struct
id|pretty_print_context
op_star
id|pp
comma
r_const
r_char
op_star
op_star
id|msg_p
comma
r_struct
id|strbuf
op_star
id|sb
comma
r_int
id|indent
)paren
(brace
r_int
id|first
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_const
r_char
op_star
id|line
op_assign
op_star
id|msg_p
suffix:semicolon
r_int
id|linelen
op_assign
id|get_one_line
c_func
(paren
id|line
)paren
suffix:semicolon
op_star
id|msg_p
op_add_assign
id|linelen
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|linelen
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|is_empty_line
c_func
(paren
id|line
comma
op_amp
id|linelen
)paren
)paren
(brace
r_if
c_cond
(paren
id|first
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;fmt
op_eq
id|CMIT_FMT_SHORT
)paren
r_break
suffix:semicolon
)brace
id|first
op_assign
l_int|0
suffix:semicolon
id|strbuf_grow
c_func
(paren
id|sb
comma
id|linelen
op_plus
id|indent
op_plus
l_int|20
)paren
suffix:semicolon
r_if
c_cond
(paren
id|indent
)paren
(brace
id|memset
c_func
(paren
id|sb-&gt;buf
op_plus
id|sb-&gt;len
comma
l_char|&squot; &squot;
comma
id|indent
)paren
suffix:semicolon
id|strbuf_setlen
c_func
(paren
id|sb
comma
id|sb-&gt;len
op_plus
id|indent
)paren
suffix:semicolon
)brace
id|strbuf_add
c_func
(paren
id|sb
comma
id|line
comma
id|linelen
)paren
suffix:semicolon
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
)brace
DECL|function|pretty_print_commit
r_void
id|pretty_print_commit
c_func
(paren
r_const
r_struct
id|pretty_print_context
op_star
id|pp
comma
r_const
r_struct
id|commit
op_star
id|commit
comma
r_struct
id|strbuf
op_star
id|sb
)paren
(brace
r_int
r_int
id|beginning_of_body
suffix:semicolon
r_int
id|indent
op_assign
l_int|4
suffix:semicolon
r_const
r_char
op_star
id|msg
suffix:semicolon
r_char
op_star
id|reencoded
suffix:semicolon
r_const
r_char
op_star
id|encoding
suffix:semicolon
r_int
id|need_8bit_cte
op_assign
id|pp-&gt;need_8bit_cte
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;fmt
op_eq
id|CMIT_FMT_USERFORMAT
)paren
(brace
id|format_commit_message
c_func
(paren
id|commit
comma
id|user_format
comma
id|sb
comma
id|pp
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|encoding
op_assign
id|get_log_output_encoding
c_func
(paren
)paren
suffix:semicolon
id|msg
op_assign
id|reencoded
op_assign
id|logmsg_reencode
c_func
(paren
id|commit
comma
id|encoding
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;fmt
op_eq
id|CMIT_FMT_ONELINE
op_logical_or
id|pp-&gt;fmt
op_eq
id|CMIT_FMT_EMAIL
)paren
id|indent
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * We need to check and emit Content-type: to mark it&n;&t; * as 8-bit if we haven&squot;t done so.&n;&t; */
r_if
c_cond
(paren
id|pp-&gt;fmt
op_eq
id|CMIT_FMT_EMAIL
op_logical_and
id|need_8bit_cte
op_eq
l_int|0
)paren
(brace
r_int
id|i
comma
id|ch
comma
id|in_body
suffix:semicolon
r_for
c_loop
(paren
id|in_body
op_assign
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|ch
op_assign
id|msg
(braket
id|i
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|in_body
)paren
(brace
multiline_comment|/* author could be non 7-bit ASCII but&n;&t;&t;&t;&t; * the log may be so; skip over the&n;&t;&t;&t;&t; * header part first.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;&bslash;n&squot;
op_logical_and
id|msg
(braket
id|i
op_plus
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|in_body
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|non_ascii
c_func
(paren
id|ch
)paren
)paren
(brace
id|need_8bit_cte
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
id|pp_header
c_func
(paren
id|pp
comma
id|encoding
comma
id|commit
comma
op_amp
id|msg
comma
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;fmt
op_ne
id|CMIT_FMT_ONELINE
op_logical_and
op_logical_neg
id|pp-&gt;subject
)paren
(brace
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Skip excess blank lines at the beginning of body, if any... */
id|msg
op_assign
id|skip_empty_lines
c_func
(paren
id|msg
)paren
suffix:semicolon
multiline_comment|/* These formats treat the title line specially. */
r_if
c_cond
(paren
id|pp-&gt;fmt
op_eq
id|CMIT_FMT_ONELINE
op_logical_or
id|pp-&gt;fmt
op_eq
id|CMIT_FMT_EMAIL
)paren
id|pp_title_line
c_func
(paren
id|pp
comma
op_amp
id|msg
comma
id|sb
comma
id|encoding
comma
id|need_8bit_cte
)paren
suffix:semicolon
id|beginning_of_body
op_assign
id|sb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;fmt
op_ne
id|CMIT_FMT_ONELINE
)paren
id|pp_remainder
c_func
(paren
id|pp
comma
op_amp
id|msg
comma
id|sb
comma
id|indent
)paren
suffix:semicolon
id|strbuf_rtrim
c_func
(paren
id|sb
)paren
suffix:semicolon
multiline_comment|/* Make sure there is an EOLN for the non-oneline case */
r_if
c_cond
(paren
id|pp-&gt;fmt
op_ne
id|CMIT_FMT_ONELINE
)paren
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The caller may append additional body text in e-mail&n;&t; * format.  Make sure we did not strip the blank line&n;&t; * between the header and the body.&n;&t; */
r_if
c_cond
(paren
id|pp-&gt;fmt
op_eq
id|CMIT_FMT_EMAIL
op_logical_and
id|sb-&gt;len
op_le
id|beginning_of_body
)paren
id|strbuf_addch
c_func
(paren
id|sb
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|logmsg_free
c_func
(paren
id|reencoded
comma
id|commit
)paren
suffix:semicolon
)brace
DECL|function|pp_commit_easy
r_void
id|pp_commit_easy
c_func
(paren
r_enum
id|cmit_fmt
id|fmt
comma
r_const
r_struct
id|commit
op_star
id|commit
comma
r_struct
id|strbuf
op_star
id|sb
)paren
(brace
r_struct
id|pretty_print_context
id|pp
op_assign
(brace
l_int|0
)brace
suffix:semicolon
id|pp.fmt
op_assign
id|fmt
suffix:semicolon
id|pretty_print_commit
c_func
(paren
op_amp
id|pp
comma
id|commit
comma
id|sb
)paren
suffix:semicolon
)brace
eof
