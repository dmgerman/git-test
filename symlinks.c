macro_line|#include &quot;cache.h&quot;
DECL|struct|pathname
r_struct
id|pathname
(brace
DECL|member|len
r_int
id|len
suffix:semicolon
DECL|member|path
r_char
id|path
(braket
id|PATH_MAX
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Return matching pathname prefix length, or zero if not matching */
DECL|function|match_pathname
r_static
r_inline
r_int
id|match_pathname
c_func
(paren
r_int
id|len
comma
r_const
r_char
op_star
id|name
comma
r_struct
id|pathname
op_star
id|match
)paren
(brace
r_int
id|match_len
op_assign
id|match-&gt;len
suffix:semicolon
r_return
(paren
id|len
OG
id|match_len
op_logical_and
id|name
(braket
id|match_len
)braket
op_eq
l_char|&squot;/&squot;
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|name
comma
id|match-&gt;path
comma
id|match_len
)paren
)paren
ques
c_cond
id|match_len
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|function|set_pathname
r_static
r_inline
r_void
id|set_pathname
c_func
(paren
r_int
id|len
comma
r_const
r_char
op_star
id|name
comma
r_struct
id|pathname
op_star
id|match
)paren
(brace
r_if
c_cond
(paren
id|len
OL
id|PATH_MAX
)paren
(brace
id|match-&gt;len
op_assign
id|len
suffix:semicolon
id|memcpy
c_func
(paren
id|match-&gt;path
comma
id|name
comma
id|len
)paren
suffix:semicolon
id|match-&gt;path
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|has_symlink_leading_path
r_int
id|has_symlink_leading_path
c_func
(paren
r_int
id|len
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_static
r_struct
id|pathname
id|link
comma
id|nonlink
suffix:semicolon
r_char
id|path
(braket
id|PATH_MAX
)braket
suffix:semicolon
r_struct
id|stat
id|st
suffix:semicolon
r_char
op_star
id|sp
suffix:semicolon
r_int
id|known_dir
suffix:semicolon
multiline_comment|/*&n;&t; * See if the last known symlink cache matches.&n;&t; */
r_if
c_cond
(paren
id|match_pathname
c_func
(paren
id|len
comma
id|name
comma
op_amp
id|link
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Get rid of the last known directory part&n;&t; */
id|known_dir
op_assign
id|match_pathname
c_func
(paren
id|len
comma
id|name
comma
op_amp
id|nonlink
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|sp
op_assign
id|strchr
c_func
(paren
id|name
op_plus
id|known_dir
op_plus
l_int|1
comma
l_char|&squot;/&squot;
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_int
id|thislen
op_assign
id|sp
id|name
suffix:semicolon
id|memcpy
c_func
(paren
id|path
comma
id|name
comma
id|thislen
)paren
suffix:semicolon
id|path
(braket
id|thislen
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|lstat
c_func
(paren
id|path
comma
op_amp
id|st
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|st.st_mode
)paren
)paren
(brace
id|set_pathname
c_func
(paren
id|thislen
comma
id|path
comma
op_amp
id|nonlink
)paren
suffix:semicolon
id|known_dir
op_assign
id|thislen
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|S_ISLNK
c_func
(paren
id|st.st_mode
)paren
)paren
(brace
id|set_pathname
c_func
(paren
id|thislen
comma
id|path
comma
op_amp
id|link
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
