macro_line|#include &quot;cache.h&quot;
DECL|struct|cache_def
r_static
r_struct
id|cache_def
(brace
DECL|member|path
r_char
id|path
(braket
id|PATH_MAX
)braket
suffix:semicolon
DECL|member|len
r_int
id|len
suffix:semicolon
DECL|member|flags
r_int
id|flags
suffix:semicolon
DECL|variable|cache
)brace
id|cache
suffix:semicolon
multiline_comment|/*&n; * Returns the length (on a path component basis) of the longest&n; * common prefix match of &squot;name&squot; and the cached path string.&n; */
DECL|function|longest_match_lstat_cache
r_static
r_inline
r_int
id|longest_match_lstat_cache
c_func
(paren
r_int
id|len
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_int
id|max_len
comma
id|match_len
op_assign
l_int|0
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|max_len
op_assign
id|len
OL
id|cache.len
ques
c_cond
id|len
suffix:colon
id|cache.len
suffix:semicolon
r_while
c_loop
(paren
id|i
OL
id|max_len
op_logical_and
id|name
(braket
id|i
)braket
op_eq
id|cache.path
(braket
id|i
)braket
)paren
(brace
r_if
c_cond
(paren
id|name
(braket
id|i
)braket
op_eq
l_char|&squot;/&squot;
)paren
id|match_len
op_assign
id|i
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
multiline_comment|/* Is the cached path string a substring of &squot;name&squot;? */
r_if
c_cond
(paren
id|i
op_eq
id|cache.len
op_logical_and
id|cache.len
OL
id|len
op_logical_and
id|name
(braket
id|cache.len
)braket
op_eq
l_char|&squot;/&squot;
)paren
id|match_len
op_assign
id|cache.len
suffix:semicolon
multiline_comment|/* Is &squot;name&squot; a substring of the cached path string? */
r_else
r_if
c_cond
(paren
(paren
id|i
op_eq
id|len
op_logical_and
id|len
OL
id|cache.len
op_logical_and
id|cache.path
(braket
id|len
)braket
op_eq
l_char|&squot;/&squot;
)paren
op_logical_or
(paren
id|i
op_eq
id|len
op_logical_and
id|len
op_eq
id|cache.len
)paren
)paren
id|match_len
op_assign
id|len
suffix:semicolon
r_return
id|match_len
suffix:semicolon
)brace
DECL|function|reset_lstat_cache
r_static
r_inline
r_void
id|reset_lstat_cache
c_func
(paren
r_void
)paren
(brace
id|cache.path
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|cache.len
op_assign
l_int|0
suffix:semicolon
id|cache.flags
op_assign
l_int|0
suffix:semicolon
)brace
DECL|macro|FL_DIR
mdefine_line|#define FL_DIR      (1 &lt;&lt; 0)
DECL|macro|FL_SYMLINK
mdefine_line|#define FL_SYMLINK  (1 &lt;&lt; 1)
DECL|macro|FL_LSTATERR
mdefine_line|#define FL_LSTATERR (1 &lt;&lt; 2)
DECL|macro|FL_ERR
mdefine_line|#define FL_ERR      (1 &lt;&lt; 3)
multiline_comment|/*&n; * Check if name &squot;name&squot; of length &squot;len&squot; has a symlink leading&n; * component, or if the directory exists and is real.&n; *&n; * To speed up the check, some information is allowed to be cached.&n; * This can be indicated by the &squot;track_flags&squot; argument.&n; */
DECL|function|lstat_cache
r_static
r_int
id|lstat_cache
c_func
(paren
r_int
id|len
comma
r_const
r_char
op_star
id|name
comma
r_int
id|track_flags
)paren
(brace
r_int
id|match_len
comma
id|last_slash
comma
id|last_slash_dir
suffix:semicolon
r_int
id|match_flags
comma
id|ret_flags
comma
id|save_flags
comma
id|max_len
suffix:semicolon
r_struct
id|stat
id|st
suffix:semicolon
multiline_comment|/*&n;&t; * Check to see if we have a match from the cache for the&n;&t; * symlink path type.&n;&t; */
id|match_len
op_assign
id|last_slash
op_assign
id|longest_match_lstat_cache
c_func
(paren
id|len
comma
id|name
)paren
suffix:semicolon
id|match_flags
op_assign
id|cache.flags
op_amp
id|track_flags
op_amp
id|FL_SYMLINK
suffix:semicolon
r_if
c_cond
(paren
id|match_flags
op_logical_and
id|match_len
op_eq
id|cache.len
)paren
r_return
id|match_flags
suffix:semicolon
multiline_comment|/*&n;&t; * If we now have match_len &gt; 0, we would know that the&n;&t; * matched part will always be a directory.&n;&t; *&n;&t; * Also, if we are tracking directories and &squot;name&squot; is a&n;&t; * substring of the cache on a path component basis, we can&n;&t; * return immediately.&n;&t; */
id|match_flags
op_assign
id|track_flags
op_amp
id|FL_DIR
suffix:semicolon
r_if
c_cond
(paren
id|match_flags
op_logical_and
id|len
op_eq
id|match_len
)paren
r_return
id|match_flags
suffix:semicolon
multiline_comment|/*&n;&t; * Okay, no match from the cache so far, so now we have to&n;&t; * check the rest of the path components.&n;&t; */
id|ret_flags
op_assign
id|FL_DIR
suffix:semicolon
id|last_slash_dir
op_assign
id|last_slash
suffix:semicolon
id|max_len
op_assign
id|len
OL
id|PATH_MAX
ques
c_cond
id|len
suffix:colon
id|PATH_MAX
suffix:semicolon
r_while
c_loop
(paren
id|match_len
OL
id|max_len
)paren
(brace
r_do
(brace
id|cache.path
(braket
id|match_len
)braket
op_assign
id|name
(braket
id|match_len
)braket
suffix:semicolon
id|match_len
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|match_len
OL
id|max_len
op_logical_and
id|name
(braket
id|match_len
)braket
op_ne
l_char|&squot;/&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|match_len
op_ge
id|max_len
)paren
r_break
suffix:semicolon
id|last_slash
op_assign
id|match_len
suffix:semicolon
id|cache.path
(braket
id|last_slash
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|lstat
c_func
(paren
id|cache.path
comma
op_amp
id|st
)paren
)paren
(brace
id|ret_flags
op_assign
id|FL_LSTATERR
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|st.st_mode
)paren
)paren
(brace
id|last_slash_dir
op_assign
id|last_slash
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISLNK
c_func
(paren
id|st.st_mode
)paren
)paren
(brace
id|ret_flags
op_assign
id|FL_SYMLINK
suffix:semicolon
)brace
r_else
(brace
id|ret_flags
op_assign
id|FL_ERR
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * At the end update the cache.  Note that max 2 different&n;&t; * path types, FL_SYMLINK and FL_DIR, can be cached for the&n;&t; * moment!&n;&t; */
id|save_flags
op_assign
id|ret_flags
op_amp
id|track_flags
op_amp
id|FL_SYMLINK
suffix:semicolon
r_if
c_cond
(paren
id|save_flags
op_logical_and
id|last_slash
OG
l_int|0
op_logical_and
id|last_slash
OL
id|PATH_MAX
)paren
(brace
id|cache.path
(braket
id|last_slash
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|cache.len
op_assign
id|last_slash
suffix:semicolon
id|cache.flags
op_assign
id|save_flags
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|track_flags
op_amp
id|FL_DIR
op_logical_and
id|last_slash_dir
OG
l_int|0
op_logical_and
id|last_slash_dir
OL
id|PATH_MAX
)paren
(brace
multiline_comment|/*&n;&t;&t; * We have a separate test for the directory case,&n;&t;&t; * since it could be that we have found a symlink and&n;&t;&t; * the track_flags says that we cannot cache this&n;&t;&t; * fact, so the cache would then have been left empty&n;&t;&t; * in this case.&n;&t;&t; *&n;&t;&t; * But if we are allowed to track real directories, we&n;&t;&t; * can still cache the path components before the last&n;&t;&t; * one (the found symlink component).&n;&t;&t; */
id|cache.path
(braket
id|last_slash_dir
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|cache.len
op_assign
id|last_slash_dir
suffix:semicolon
id|cache.flags
op_assign
id|FL_DIR
suffix:semicolon
)brace
r_else
(brace
id|reset_lstat_cache
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|ret_flags
suffix:semicolon
)brace
multiline_comment|/*&n; * Return non-zero if path &squot;name&squot; has a leading symlink component&n; */
DECL|function|has_symlink_leading_path
r_int
id|has_symlink_leading_path
c_func
(paren
r_int
id|len
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_return
id|lstat_cache
c_func
(paren
id|len
comma
id|name
comma
id|FL_SYMLINK
op_or
id|FL_DIR
)paren
op_amp
id|FL_SYMLINK
suffix:semicolon
)brace
eof
