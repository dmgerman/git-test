multiline_comment|/*&n; * This file has been copied from commit e7ac713d^ in the GNU grep git&n; * repository. A few small changes have been made to adapt the code to&n; * Git.&n; */
multiline_comment|/* kwset.c - search for any of a set of keywords.&n;   Copyright 1989, 1998, 2000, 2005 Free Software Foundation, Inc.&n;&n;   This program is free software; you can redistribute it and/or modify&n;   it under the terms of the GNU General Public License as published by&n;   the Free Software Foundation; either version 2, or (at your option)&n;   any later version.&n;&n;   This program is distributed in the hope that it will be useful,&n;   but WITHOUT ANY WARRANTY; without even the implied warranty of&n;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n;   GNU General Public License for more details.&n;&n;   You should have received a copy of the GNU General Public License&n;   along with this program; if not, write to the Free Software&n;   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA&n;   02110-1301, USA.  */
multiline_comment|/* Written August 1989 by Mike Haertel.&n;   The author may be reached (Email) at the address mike@ai.mit.edu,&n;   or (US mail) as Mike Haertel c/o Free Software Foundation. */
multiline_comment|/* The algorithm implemented by these routines bears a startling resemblence&n;   to one discovered by Beate Commentz-Walter, although it is not identical.&n;   See &quot;A String Matching Algorithm Fast on the Average,&quot; Technical Report,&n;   IBM-Germany, Scientific Center Heidelberg, Tiergartenstrasse 15, D-6900&n;   Heidelberg, Germany.  See also Aho, A.V., and M. Corasick, &quot;Efficient&n;   String Matching:  An Aid to Bibliographic Search,&quot; CACM June 1975,&n;   Vol. 18, No. 6, which describes the failure function used below. */
macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;kwset.h&quot;
macro_line|#include &quot;obstack.h&quot;
DECL|macro|NCHAR
mdefine_line|#define NCHAR (UCHAR_MAX + 1)
DECL|macro|obstack_chunk_alloc
mdefine_line|#define obstack_chunk_alloc xmalloc
DECL|macro|obstack_chunk_free
mdefine_line|#define obstack_chunk_free free
DECL|macro|U
mdefine_line|#define U(c) ((unsigned char) (c))
multiline_comment|/* Balanced tree of edges and labels leaving a given trie node. */
DECL|struct|tree
r_struct
id|tree
(brace
DECL|member|llink
r_struct
id|tree
op_star
id|llink
suffix:semicolon
multiline_comment|/* Left link; MUST be first field. */
DECL|member|rlink
r_struct
id|tree
op_star
id|rlink
suffix:semicolon
multiline_comment|/* Right link (to larger labels). */
DECL|member|trie
r_struct
id|trie
op_star
id|trie
suffix:semicolon
multiline_comment|/* Trie node pointed to by this edge. */
DECL|member|label
r_int
r_char
id|label
suffix:semicolon
multiline_comment|/* Label on this edge. */
DECL|member|balance
r_char
id|balance
suffix:semicolon
multiline_comment|/* Difference in depths of subtrees. */
)brace
suffix:semicolon
multiline_comment|/* Node of a trie representing a set of reversed keywords. */
DECL|struct|trie
r_struct
id|trie
(brace
DECL|member|accepting
r_int
r_int
id|accepting
suffix:semicolon
multiline_comment|/* Word index of accepted word, or zero. */
DECL|member|links
r_struct
id|tree
op_star
id|links
suffix:semicolon
multiline_comment|/* Tree of edges leaving this node. */
DECL|member|parent
r_struct
id|trie
op_star
id|parent
suffix:semicolon
multiline_comment|/* Parent of this node. */
DECL|member|next
r_struct
id|trie
op_star
id|next
suffix:semicolon
multiline_comment|/* List of all trie nodes in level order. */
DECL|member|fail
r_struct
id|trie
op_star
id|fail
suffix:semicolon
multiline_comment|/* Aho-Corasick failure function. */
DECL|member|depth
r_int
id|depth
suffix:semicolon
multiline_comment|/* Depth of this node from the root. */
DECL|member|shift
r_int
id|shift
suffix:semicolon
multiline_comment|/* Shift function for search failures. */
DECL|member|maxshift
r_int
id|maxshift
suffix:semicolon
multiline_comment|/* Max shift of self and descendents. */
)brace
suffix:semicolon
multiline_comment|/* Structure returned opaquely to the caller, containing everything. */
DECL|struct|kwset
r_struct
id|kwset
(brace
DECL|member|obstack
r_struct
id|obstack
id|obstack
suffix:semicolon
multiline_comment|/* Obstack for node allocation. */
DECL|member|words
r_int
id|words
suffix:semicolon
multiline_comment|/* Number of words in the trie. */
DECL|member|trie
r_struct
id|trie
op_star
id|trie
suffix:semicolon
multiline_comment|/* The trie itself. */
DECL|member|mind
r_int
id|mind
suffix:semicolon
multiline_comment|/* Minimum depth of an accepting node. */
DECL|member|maxd
r_int
id|maxd
suffix:semicolon
multiline_comment|/* Maximum depth of any node. */
DECL|member|delta
r_int
r_char
id|delta
(braket
id|NCHAR
)braket
suffix:semicolon
multiline_comment|/* Delta table for rapid search. */
DECL|member|next
r_struct
id|trie
op_star
id|next
(braket
id|NCHAR
)braket
suffix:semicolon
multiline_comment|/* Table of children of the root. */
DECL|member|target
r_char
op_star
id|target
suffix:semicolon
multiline_comment|/* Target string if there&squot;s only one. */
DECL|member|mind2
r_int
id|mind2
suffix:semicolon
multiline_comment|/* Used in Boyer-Moore search for one string. */
DECL|member|trans
r_char
r_const
op_star
id|trans
suffix:semicolon
multiline_comment|/* Character translation table. */
)brace
suffix:semicolon
multiline_comment|/* Allocate and initialize a keyword set object, returning an opaque&n;   pointer to it.  Return NULL if memory is not available. */
id|kwset_t
DECL|function|kwsalloc
id|kwsalloc
(paren
r_char
r_const
op_star
id|trans
)paren
(brace
r_struct
id|kwset
op_star
id|kwset
suffix:semicolon
id|kwset
op_assign
(paren
r_struct
id|kwset
op_star
)paren
id|xmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|kwset
)paren
)paren
suffix:semicolon
id|obstack_init
c_func
(paren
op_amp
id|kwset-&gt;obstack
)paren
suffix:semicolon
id|kwset-&gt;words
op_assign
l_int|0
suffix:semicolon
id|kwset-&gt;trie
op_assign
(paren
r_struct
id|trie
op_star
)paren
id|obstack_alloc
c_func
(paren
op_amp
id|kwset-&gt;obstack
comma
r_sizeof
(paren
r_struct
id|trie
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kwset-&gt;trie
)paren
(brace
id|kwsfree
c_func
(paren
(paren
id|kwset_t
)paren
id|kwset
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|kwset-&gt;trie-&gt;accepting
op_assign
l_int|0
suffix:semicolon
id|kwset-&gt;trie-&gt;links
op_assign
l_int|NULL
suffix:semicolon
id|kwset-&gt;trie-&gt;parent
op_assign
l_int|NULL
suffix:semicolon
id|kwset-&gt;trie-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|kwset-&gt;trie-&gt;fail
op_assign
l_int|NULL
suffix:semicolon
id|kwset-&gt;trie-&gt;depth
op_assign
l_int|0
suffix:semicolon
id|kwset-&gt;trie-&gt;shift
op_assign
l_int|0
suffix:semicolon
id|kwset-&gt;mind
op_assign
id|INT_MAX
suffix:semicolon
id|kwset-&gt;maxd
op_assign
l_int|1
suffix:semicolon
id|kwset-&gt;target
op_assign
l_int|NULL
suffix:semicolon
id|kwset-&gt;trans
op_assign
id|trans
suffix:semicolon
r_return
(paren
id|kwset_t
)paren
id|kwset
suffix:semicolon
)brace
multiline_comment|/* This upper bound is valid for CHAR_BIT &gt;= 4 and&n;   exact for CHAR_BIT in { 4..11, 13, 15, 17, 19 }. */
DECL|macro|DEPTH_SIZE
mdefine_line|#define DEPTH_SIZE (CHAR_BIT + CHAR_BIT/2)
multiline_comment|/* Add the given string to the contents of the keyword set.  Return NULL&n;   for success, an error message otherwise. */
r_const
r_char
op_star
DECL|function|kwsincr
id|kwsincr
(paren
id|kwset_t
id|kws
comma
r_char
r_const
op_star
id|text
comma
r_int
id|len
)paren
(brace
r_struct
id|kwset
op_star
id|kwset
suffix:semicolon
r_register
r_struct
id|trie
op_star
id|trie
suffix:semicolon
r_register
r_int
r_char
id|label
suffix:semicolon
r_register
r_struct
id|tree
op_star
id|link
suffix:semicolon
r_register
r_int
id|depth
suffix:semicolon
r_struct
id|tree
op_star
id|links
(braket
id|DEPTH_SIZE
)braket
suffix:semicolon
r_enum
(brace
id|L
comma
id|R
)brace
id|dirs
(braket
id|DEPTH_SIZE
)braket
suffix:semicolon
r_struct
id|tree
op_star
id|t
comma
op_star
id|r
comma
op_star
id|l
comma
op_star
id|rl
comma
op_star
id|lr
suffix:semicolon
id|kwset
op_assign
(paren
r_struct
id|kwset
op_star
)paren
id|kws
suffix:semicolon
id|trie
op_assign
id|kwset-&gt;trie
suffix:semicolon
id|text
op_add_assign
id|len
suffix:semicolon
multiline_comment|/* Descend the trie (built of reversed keywords) character-by-character,&n;     installing new nodes when necessary. */
r_while
c_loop
(paren
id|len
op_decrement
)paren
(brace
id|label
op_assign
id|kwset-&gt;trans
ques
c_cond
id|kwset-&gt;trans
(braket
id|U
c_func
(paren
op_star
op_decrement
id|text
)paren
)braket
suffix:colon
op_star
op_decrement
id|text
suffix:semicolon
multiline_comment|/* Descend the tree of outgoing links for this trie node,&n;&t; looking for the current character and keeping track&n;&t; of the path followed. */
id|link
op_assign
id|trie-&gt;links
suffix:semicolon
id|links
(braket
l_int|0
)braket
op_assign
(paren
r_struct
id|tree
op_star
)paren
op_amp
id|trie-&gt;links
suffix:semicolon
id|dirs
(braket
l_int|0
)braket
op_assign
id|L
suffix:semicolon
id|depth
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|link
op_logical_and
id|label
op_ne
id|link-&gt;label
)paren
(brace
id|links
(braket
id|depth
)braket
op_assign
id|link
suffix:semicolon
r_if
c_cond
(paren
id|label
OL
id|link-&gt;label
)paren
id|dirs
(braket
id|depth
op_increment
)braket
op_assign
id|L
comma
id|link
op_assign
id|link-&gt;llink
suffix:semicolon
r_else
id|dirs
(braket
id|depth
op_increment
)braket
op_assign
id|R
comma
id|link
op_assign
id|link-&gt;rlink
suffix:semicolon
)brace
multiline_comment|/* The current character doesn&squot;t have an outgoing link at&n;&t; this trie node, so build a new trie node and install&n;&t; a link in the current trie node&squot;s tree. */
r_if
c_cond
(paren
op_logical_neg
id|link
)paren
(brace
id|link
op_assign
(paren
r_struct
id|tree
op_star
)paren
id|obstack_alloc
c_func
(paren
op_amp
id|kwset-&gt;obstack
comma
r_sizeof
(paren
r_struct
id|tree
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|link
)paren
r_return
l_string|&quot;memory exhausted&quot;
suffix:semicolon
id|link-&gt;llink
op_assign
l_int|NULL
suffix:semicolon
id|link-&gt;rlink
op_assign
l_int|NULL
suffix:semicolon
id|link-&gt;trie
op_assign
(paren
r_struct
id|trie
op_star
)paren
id|obstack_alloc
c_func
(paren
op_amp
id|kwset-&gt;obstack
comma
r_sizeof
(paren
r_struct
id|trie
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|link-&gt;trie
)paren
(brace
id|obstack_free
c_func
(paren
op_amp
id|kwset-&gt;obstack
comma
id|link
)paren
suffix:semicolon
r_return
l_string|&quot;memory exhausted&quot;
suffix:semicolon
)brace
id|link-&gt;trie-&gt;accepting
op_assign
l_int|0
suffix:semicolon
id|link-&gt;trie-&gt;links
op_assign
l_int|NULL
suffix:semicolon
id|link-&gt;trie-&gt;parent
op_assign
id|trie
suffix:semicolon
id|link-&gt;trie-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|link-&gt;trie-&gt;fail
op_assign
l_int|NULL
suffix:semicolon
id|link-&gt;trie-&gt;depth
op_assign
id|trie-&gt;depth
op_plus
l_int|1
suffix:semicolon
id|link-&gt;trie-&gt;shift
op_assign
l_int|0
suffix:semicolon
id|link-&gt;label
op_assign
id|label
suffix:semicolon
id|link-&gt;balance
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Install the new tree node in its parent. */
r_if
c_cond
(paren
id|dirs
(braket
op_decrement
id|depth
)braket
op_eq
id|L
)paren
id|links
(braket
id|depth
)braket
op_member_access_from_pointer
id|llink
op_assign
id|link
suffix:semicolon
r_else
id|links
(braket
id|depth
)braket
op_member_access_from_pointer
id|rlink
op_assign
id|link
suffix:semicolon
multiline_comment|/* Back up the tree fixing the balance flags. */
r_while
c_loop
(paren
id|depth
op_logical_and
op_logical_neg
id|links
(braket
id|depth
)braket
op_member_access_from_pointer
id|balance
)paren
(brace
r_if
c_cond
(paren
id|dirs
(braket
id|depth
)braket
op_eq
id|L
)paren
op_decrement
id|links
(braket
id|depth
)braket
op_member_access_from_pointer
id|balance
suffix:semicolon
r_else
op_increment
id|links
(braket
id|depth
)braket
op_member_access_from_pointer
id|balance
suffix:semicolon
op_decrement
id|depth
suffix:semicolon
)brace
multiline_comment|/* Rebalance the tree by pointer rotations if necessary. */
r_if
c_cond
(paren
id|depth
op_logical_and
(paren
(paren
id|dirs
(braket
id|depth
)braket
op_eq
id|L
op_logical_and
op_decrement
id|links
(braket
id|depth
)braket
op_member_access_from_pointer
id|balance
)paren
op_logical_or
(paren
id|dirs
(braket
id|depth
)braket
op_eq
id|R
op_logical_and
op_increment
id|links
(braket
id|depth
)braket
op_member_access_from_pointer
id|balance
)paren
)paren
)paren
(brace
r_switch
c_cond
(paren
id|links
(braket
id|depth
)braket
op_member_access_from_pointer
id|balance
)paren
(brace
r_case
(paren
r_char
)paren
l_int|2
suffix:colon
r_switch
c_cond
(paren
id|dirs
(braket
id|depth
op_plus
l_int|1
)braket
)paren
(brace
r_case
id|L
suffix:colon
id|r
op_assign
id|links
(braket
id|depth
)braket
comma
id|t
op_assign
id|r-&gt;llink
comma
id|rl
op_assign
id|t-&gt;rlink
suffix:semicolon
id|t-&gt;rlink
op_assign
id|r
comma
id|r-&gt;llink
op_assign
id|rl
suffix:semicolon
id|t-&gt;balance
op_assign
id|r-&gt;balance
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|R
suffix:colon
id|r
op_assign
id|links
(braket
id|depth
)braket
comma
id|l
op_assign
id|r-&gt;llink
comma
id|t
op_assign
id|l-&gt;rlink
suffix:semicolon
id|rl
op_assign
id|t-&gt;rlink
comma
id|lr
op_assign
id|t-&gt;llink
suffix:semicolon
id|t-&gt;llink
op_assign
id|l
comma
id|l-&gt;rlink
op_assign
id|lr
comma
id|t-&gt;rlink
op_assign
id|r
comma
id|r-&gt;llink
op_assign
id|rl
suffix:semicolon
id|l-&gt;balance
op_assign
id|t-&gt;balance
op_ne
l_int|1
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
id|r-&gt;balance
op_assign
id|t-&gt;balance
op_ne
(paren
r_char
)paren
l_int|1
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
id|t-&gt;balance
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
m_abort
(paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
r_switch
c_cond
(paren
id|dirs
(braket
id|depth
op_plus
l_int|1
)braket
)paren
(brace
r_case
id|R
suffix:colon
id|l
op_assign
id|links
(braket
id|depth
)braket
comma
id|t
op_assign
id|l-&gt;rlink
comma
id|lr
op_assign
id|t-&gt;llink
suffix:semicolon
id|t-&gt;llink
op_assign
id|l
comma
id|l-&gt;rlink
op_assign
id|lr
suffix:semicolon
id|t-&gt;balance
op_assign
id|l-&gt;balance
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|L
suffix:colon
id|l
op_assign
id|links
(braket
id|depth
)braket
comma
id|r
op_assign
id|l-&gt;rlink
comma
id|t
op_assign
id|r-&gt;llink
suffix:semicolon
id|lr
op_assign
id|t-&gt;llink
comma
id|rl
op_assign
id|t-&gt;rlink
suffix:semicolon
id|t-&gt;llink
op_assign
id|l
comma
id|l-&gt;rlink
op_assign
id|lr
comma
id|t-&gt;rlink
op_assign
id|r
comma
id|r-&gt;llink
op_assign
id|rl
suffix:semicolon
id|l-&gt;balance
op_assign
id|t-&gt;balance
op_ne
l_int|1
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
id|r-&gt;balance
op_assign
id|t-&gt;balance
op_ne
(paren
r_char
)paren
l_int|1
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
id|t-&gt;balance
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
m_abort
(paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
m_abort
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dirs
(braket
id|depth
l_int|1
)braket
op_eq
id|L
)paren
id|links
(braket
id|depth
l_int|1
)braket
op_member_access_from_pointer
id|llink
op_assign
id|t
suffix:semicolon
r_else
id|links
(braket
id|depth
l_int|1
)braket
op_member_access_from_pointer
id|rlink
op_assign
id|t
suffix:semicolon
)brace
)brace
id|trie
op_assign
id|link-&gt;trie
suffix:semicolon
)brace
multiline_comment|/* Mark the node we finally reached as accepting, encoding the&n;     index number of this word in the keyword set so far. */
r_if
c_cond
(paren
op_logical_neg
id|trie-&gt;accepting
)paren
id|trie-&gt;accepting
op_assign
l_int|1
op_plus
l_int|2
op_star
id|kwset-&gt;words
suffix:semicolon
op_increment
id|kwset-&gt;words
suffix:semicolon
multiline_comment|/* Keep track of the longest and shortest string of the keyword set. */
r_if
c_cond
(paren
id|trie-&gt;depth
OL
id|kwset-&gt;mind
)paren
id|kwset-&gt;mind
op_assign
id|trie-&gt;depth
suffix:semicolon
r_if
c_cond
(paren
id|trie-&gt;depth
OG
id|kwset-&gt;maxd
)paren
id|kwset-&gt;maxd
op_assign
id|trie-&gt;depth
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Enqueue the trie nodes referenced from the given tree in the&n;   given queue. */
r_static
r_void
DECL|function|enqueue
id|enqueue
(paren
r_struct
id|tree
op_star
id|tree
comma
r_struct
id|trie
op_star
op_star
id|last
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tree
)paren
r_return
suffix:semicolon
id|enqueue
c_func
(paren
id|tree-&gt;llink
comma
id|last
)paren
suffix:semicolon
id|enqueue
c_func
(paren
id|tree-&gt;rlink
comma
id|last
)paren
suffix:semicolon
(paren
op_star
id|last
)paren
op_assign
(paren
op_star
id|last
)paren
op_member_access_from_pointer
id|next
op_assign
id|tree-&gt;trie
suffix:semicolon
)brace
multiline_comment|/* Compute the Aho-Corasick failure function for the trie nodes referenced&n;   from the given tree, given the failure function for their parent as&n;   well as a last resort failure node. */
r_static
r_void
DECL|function|treefails
id|treefails
(paren
r_register
r_struct
id|tree
r_const
op_star
id|tree
comma
r_struct
id|trie
r_const
op_star
id|fail
comma
r_struct
id|trie
op_star
id|recourse
)paren
(brace
r_register
r_struct
id|tree
op_star
id|link
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tree
)paren
r_return
suffix:semicolon
id|treefails
c_func
(paren
id|tree-&gt;llink
comma
id|fail
comma
id|recourse
)paren
suffix:semicolon
id|treefails
c_func
(paren
id|tree-&gt;rlink
comma
id|fail
comma
id|recourse
)paren
suffix:semicolon
multiline_comment|/* Find, in the chain of fails going back to the root, the first&n;     node that has a descendent on the current label. */
r_while
c_loop
(paren
id|fail
)paren
(brace
id|link
op_assign
id|fail-&gt;links
suffix:semicolon
r_while
c_loop
(paren
id|link
op_logical_and
id|tree-&gt;label
op_ne
id|link-&gt;label
)paren
r_if
c_cond
(paren
id|tree-&gt;label
OL
id|link-&gt;label
)paren
id|link
op_assign
id|link-&gt;llink
suffix:semicolon
r_else
id|link
op_assign
id|link-&gt;rlink
suffix:semicolon
r_if
c_cond
(paren
id|link
)paren
(brace
id|tree-&gt;trie-&gt;fail
op_assign
id|link-&gt;trie
suffix:semicolon
r_return
suffix:semicolon
)brace
id|fail
op_assign
id|fail-&gt;fail
suffix:semicolon
)brace
id|tree-&gt;trie-&gt;fail
op_assign
id|recourse
suffix:semicolon
)brace
multiline_comment|/* Set delta entries for the links of the given tree such that&n;   the preexisting delta value is larger than the current depth. */
r_static
r_void
DECL|function|treedelta
id|treedelta
(paren
r_register
r_struct
id|tree
r_const
op_star
id|tree
comma
r_register
r_int
r_int
id|depth
comma
r_int
r_char
id|delta
(braket
)braket
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tree
)paren
r_return
suffix:semicolon
id|treedelta
c_func
(paren
id|tree-&gt;llink
comma
id|depth
comma
id|delta
)paren
suffix:semicolon
id|treedelta
c_func
(paren
id|tree-&gt;rlink
comma
id|depth
comma
id|delta
)paren
suffix:semicolon
r_if
c_cond
(paren
id|depth
OL
id|delta
(braket
id|tree-&gt;label
)braket
)paren
id|delta
(braket
id|tree-&gt;label
)braket
op_assign
id|depth
suffix:semicolon
)brace
multiline_comment|/* Return true if A has every label in B. */
r_static
r_int
DECL|function|hasevery
id|hasevery
(paren
r_register
r_struct
id|tree
r_const
op_star
id|a
comma
r_register
r_struct
id|tree
r_const
op_star
id|b
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|b
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hasevery
c_func
(paren
id|a
comma
id|b-&gt;llink
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hasevery
c_func
(paren
id|a
comma
id|b-&gt;rlink
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|a
op_logical_and
id|b-&gt;label
op_ne
id|a-&gt;label
)paren
r_if
c_cond
(paren
id|b-&gt;label
OL
id|a-&gt;label
)paren
id|a
op_assign
id|a-&gt;llink
suffix:semicolon
r_else
id|a
op_assign
id|a-&gt;rlink
suffix:semicolon
r_return
op_logical_neg
op_logical_neg
id|a
suffix:semicolon
)brace
multiline_comment|/* Compute a vector, indexed by character code, of the trie nodes&n;   referenced from the given tree. */
r_static
r_void
DECL|function|treenext
id|treenext
(paren
r_struct
id|tree
r_const
op_star
id|tree
comma
r_struct
id|trie
op_star
id|next
(braket
)braket
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tree
)paren
r_return
suffix:semicolon
id|treenext
c_func
(paren
id|tree-&gt;llink
comma
id|next
)paren
suffix:semicolon
id|treenext
c_func
(paren
id|tree-&gt;rlink
comma
id|next
)paren
suffix:semicolon
id|next
(braket
id|tree-&gt;label
)braket
op_assign
id|tree-&gt;trie
suffix:semicolon
)brace
multiline_comment|/* Compute the shift for each trie node, as well as the delta&n;   table and next cache for the given keyword set. */
r_const
r_char
op_star
DECL|function|kwsprep
id|kwsprep
(paren
id|kwset_t
id|kws
)paren
(brace
r_register
r_struct
id|kwset
op_star
id|kwset
suffix:semicolon
r_register
r_int
id|i
suffix:semicolon
r_register
r_struct
id|trie
op_star
id|curr
suffix:semicolon
r_register
r_char
r_const
op_star
id|trans
suffix:semicolon
r_int
r_char
id|delta
(braket
id|NCHAR
)braket
suffix:semicolon
id|kwset
op_assign
(paren
r_struct
id|kwset
op_star
)paren
id|kws
suffix:semicolon
multiline_comment|/* Initial values for the delta table; will be changed later.  The&n;     delta entry for a given character is the smallest depth of any&n;     node at which an outgoing edge is labeled by that character. */
id|memset
c_func
(paren
id|delta
comma
id|kwset-&gt;mind
OL
id|UCHAR_MAX
ques
c_cond
id|kwset-&gt;mind
suffix:colon
id|UCHAR_MAX
comma
id|NCHAR
)paren
suffix:semicolon
multiline_comment|/* Check if we can use the simple boyer-moore algorithm, instead&n;     of the hairy commentz-walter algorithm. */
r_if
c_cond
(paren
id|kwset-&gt;words
op_eq
l_int|1
op_logical_and
id|kwset-&gt;trans
op_eq
l_int|NULL
)paren
(brace
r_char
id|c
suffix:semicolon
multiline_comment|/* Looking for just one string.  Extract it from the trie. */
id|kwset-&gt;target
op_assign
id|obstack_alloc
c_func
(paren
op_amp
id|kwset-&gt;obstack
comma
id|kwset-&gt;mind
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kwset-&gt;target
)paren
r_return
l_string|&quot;memory exhausted&quot;
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|kwset-&gt;mind
l_int|1
comma
id|curr
op_assign
id|kwset-&gt;trie
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
op_decrement
id|i
)paren
(brace
id|kwset-&gt;target
(braket
id|i
)braket
op_assign
id|curr-&gt;links-&gt;label
suffix:semicolon
id|curr
op_assign
id|curr-&gt;links-&gt;trie
suffix:semicolon
)brace
multiline_comment|/* Build the Boyer Moore delta.  Boy that&squot;s easy compared to CW. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|kwset-&gt;mind
suffix:semicolon
op_increment
id|i
)paren
id|delta
(braket
id|U
c_func
(paren
id|kwset-&gt;target
(braket
id|i
)braket
)paren
)braket
op_assign
id|kwset-&gt;mind
(paren
id|i
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Find the minimal delta2 shift that we might make after&n;&t; a backwards match has failed. */
id|c
op_assign
id|kwset-&gt;target
(braket
id|kwset-&gt;mind
l_int|1
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|kwset-&gt;mind
l_int|2
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
op_decrement
id|i
)paren
r_if
c_cond
(paren
id|kwset-&gt;target
(braket
id|i
)braket
op_eq
id|c
)paren
r_break
suffix:semicolon
id|kwset-&gt;mind2
op_assign
id|kwset-&gt;mind
(paren
id|i
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
r_register
r_struct
id|trie
op_star
id|fail
suffix:semicolon
r_struct
id|trie
op_star
id|last
comma
op_star
id|next
(braket
id|NCHAR
)braket
suffix:semicolon
multiline_comment|/* Traverse the nodes of the trie in level order, simultaneously&n;&t; computing the delta table, failure function, and shift function. */
r_for
c_loop
(paren
id|curr
op_assign
id|last
op_assign
id|kwset-&gt;trie
suffix:semicolon
id|curr
suffix:semicolon
id|curr
op_assign
id|curr-&gt;next
)paren
(brace
multiline_comment|/* Enqueue the immediate descendents in the level order queue. */
id|enqueue
c_func
(paren
id|curr-&gt;links
comma
op_amp
id|last
)paren
suffix:semicolon
id|curr-&gt;shift
op_assign
id|kwset-&gt;mind
suffix:semicolon
id|curr-&gt;maxshift
op_assign
id|kwset-&gt;mind
suffix:semicolon
multiline_comment|/* Update the delta table for the descendents of this node. */
id|treedelta
c_func
(paren
id|curr-&gt;links
comma
id|curr-&gt;depth
comma
id|delta
)paren
suffix:semicolon
multiline_comment|/* Compute the failure function for the decendents of this node. */
id|treefails
c_func
(paren
id|curr-&gt;links
comma
id|curr-&gt;fail
comma
id|kwset-&gt;trie
)paren
suffix:semicolon
multiline_comment|/* Update the shifts at each node in the current node&squot;s chain&n;&t;     of fails back to the root. */
r_for
c_loop
(paren
id|fail
op_assign
id|curr-&gt;fail
suffix:semicolon
id|fail
suffix:semicolon
id|fail
op_assign
id|fail-&gt;fail
)paren
(brace
multiline_comment|/* If the current node has some outgoing edge that the fail&n;&t;&t; doesn&squot;t, then the shift at the fail should be no larger&n;&t;&t; than the difference of their depths. */
r_if
c_cond
(paren
op_logical_neg
id|hasevery
c_func
(paren
id|fail-&gt;links
comma
id|curr-&gt;links
)paren
)paren
r_if
c_cond
(paren
id|curr-&gt;depth
id|fail-&gt;depth
OL
id|fail-&gt;shift
)paren
id|fail-&gt;shift
op_assign
id|curr-&gt;depth
id|fail-&gt;depth
suffix:semicolon
multiline_comment|/* If the current node is accepting then the shift at the&n;&t;&t; fail and its descendents should be no larger than the&n;&t;&t; difference of their depths. */
r_if
c_cond
(paren
id|curr-&gt;accepting
op_logical_and
id|fail-&gt;maxshift
OG
id|curr-&gt;depth
id|fail-&gt;depth
)paren
id|fail-&gt;maxshift
op_assign
id|curr-&gt;depth
id|fail-&gt;depth
suffix:semicolon
)brace
)brace
multiline_comment|/* Traverse the trie in level order again, fixing up all nodes whose&n;&t; shift exceeds their inherited maxshift. */
r_for
c_loop
(paren
id|curr
op_assign
id|kwset-&gt;trie-&gt;next
suffix:semicolon
id|curr
suffix:semicolon
id|curr
op_assign
id|curr-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|curr-&gt;maxshift
OG
id|curr-&gt;parent-&gt;maxshift
)paren
id|curr-&gt;maxshift
op_assign
id|curr-&gt;parent-&gt;maxshift
suffix:semicolon
r_if
c_cond
(paren
id|curr-&gt;shift
OG
id|curr-&gt;maxshift
)paren
id|curr-&gt;shift
op_assign
id|curr-&gt;maxshift
suffix:semicolon
)brace
multiline_comment|/* Create a vector, indexed by character code, of the outgoing links&n;&t; from the root node. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NCHAR
suffix:semicolon
op_increment
id|i
)paren
id|next
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|treenext
c_func
(paren
id|kwset-&gt;trie-&gt;links
comma
id|next
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|trans
op_assign
id|kwset-&gt;trans
)paren
op_ne
l_int|NULL
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NCHAR
suffix:semicolon
op_increment
id|i
)paren
id|kwset-&gt;next
(braket
id|i
)braket
op_assign
id|next
(braket
id|U
c_func
(paren
id|trans
(braket
id|i
)braket
)paren
)braket
suffix:semicolon
r_else
id|memcpy
c_func
(paren
id|kwset-&gt;next
comma
id|next
comma
id|NCHAR
op_star
r_sizeof
(paren
r_struct
id|trie
op_star
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Fix things up for any translation table. */
r_if
c_cond
(paren
(paren
id|trans
op_assign
id|kwset-&gt;trans
)paren
op_ne
l_int|NULL
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NCHAR
suffix:semicolon
op_increment
id|i
)paren
id|kwset-&gt;delta
(braket
id|i
)braket
op_assign
id|delta
(braket
id|U
c_func
(paren
id|trans
(braket
id|i
)braket
)paren
)braket
suffix:semicolon
r_else
id|memcpy
c_func
(paren
id|kwset-&gt;delta
comma
id|delta
comma
id|NCHAR
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Fast boyer-moore search. */
r_static
r_int
DECL|function|bmexec
id|bmexec
(paren
id|kwset_t
id|kws
comma
r_char
r_const
op_star
id|text
comma
r_int
id|size
)paren
(brace
r_struct
id|kwset
r_const
op_star
id|kwset
suffix:semicolon
r_register
r_int
r_char
r_const
op_star
id|d1
suffix:semicolon
r_register
r_char
r_const
op_star
id|ep
comma
op_star
id|sp
comma
op_star
id|tp
suffix:semicolon
r_register
r_int
id|d
comma
id|gc
comma
id|i
comma
id|len
comma
id|md2
suffix:semicolon
id|kwset
op_assign
(paren
r_struct
id|kwset
r_const
op_star
)paren
id|kws
suffix:semicolon
id|len
op_assign
id|kwset-&gt;mind
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|size
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
l_int|1
)paren
(brace
id|tp
op_assign
id|memchr
(paren
id|text
comma
id|kwset-&gt;target
(braket
l_int|0
)braket
comma
id|size
)paren
suffix:semicolon
r_return
id|tp
ques
c_cond
id|tp
id|text
suffix:colon
l_int|1
suffix:semicolon
)brace
id|d1
op_assign
id|kwset-&gt;delta
suffix:semicolon
id|sp
op_assign
id|kwset-&gt;target
op_plus
id|len
suffix:semicolon
id|gc
op_assign
id|U
c_func
(paren
id|sp
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|md2
op_assign
id|kwset-&gt;mind2
suffix:semicolon
id|tp
op_assign
id|text
op_plus
id|len
suffix:semicolon
multiline_comment|/* Significance of 12: 1 (initial offset) + 10 (skip loop) + 1 (md2). */
r_if
c_cond
(paren
id|size
OG
l_int|12
op_star
id|len
)paren
multiline_comment|/* 11 is not a bug, the initial offset happens only once. */
r_for
c_loop
(paren
id|ep
op_assign
id|text
op_plus
id|size
l_int|11
op_star
id|len
suffix:semicolon
suffix:semicolon
)paren
(brace
r_while
c_loop
(paren
id|tp
op_le
id|ep
)paren
(brace
id|d
op_assign
id|d1
(braket
id|U
c_func
(paren
id|tp
(braket
l_int|1
)braket
)paren
)braket
comma
id|tp
op_add_assign
id|d
suffix:semicolon
id|d
op_assign
id|d1
(braket
id|U
c_func
(paren
id|tp
(braket
l_int|1
)braket
)paren
)braket
comma
id|tp
op_add_assign
id|d
suffix:semicolon
r_if
c_cond
(paren
id|d
op_eq
l_int|0
)paren
r_goto
id|found
suffix:semicolon
id|d
op_assign
id|d1
(braket
id|U
c_func
(paren
id|tp
(braket
l_int|1
)braket
)paren
)braket
comma
id|tp
op_add_assign
id|d
suffix:semicolon
id|d
op_assign
id|d1
(braket
id|U
c_func
(paren
id|tp
(braket
l_int|1
)braket
)paren
)braket
comma
id|tp
op_add_assign
id|d
suffix:semicolon
id|d
op_assign
id|d1
(braket
id|U
c_func
(paren
id|tp
(braket
l_int|1
)braket
)paren
)braket
comma
id|tp
op_add_assign
id|d
suffix:semicolon
r_if
c_cond
(paren
id|d
op_eq
l_int|0
)paren
r_goto
id|found
suffix:semicolon
id|d
op_assign
id|d1
(braket
id|U
c_func
(paren
id|tp
(braket
l_int|1
)braket
)paren
)braket
comma
id|tp
op_add_assign
id|d
suffix:semicolon
id|d
op_assign
id|d1
(braket
id|U
c_func
(paren
id|tp
(braket
l_int|1
)braket
)paren
)braket
comma
id|tp
op_add_assign
id|d
suffix:semicolon
id|d
op_assign
id|d1
(braket
id|U
c_func
(paren
id|tp
(braket
l_int|1
)braket
)paren
)braket
comma
id|tp
op_add_assign
id|d
suffix:semicolon
r_if
c_cond
(paren
id|d
op_eq
l_int|0
)paren
r_goto
id|found
suffix:semicolon
id|d
op_assign
id|d1
(braket
id|U
c_func
(paren
id|tp
(braket
l_int|1
)braket
)paren
)braket
comma
id|tp
op_add_assign
id|d
suffix:semicolon
id|d
op_assign
id|d1
(braket
id|U
c_func
(paren
id|tp
(braket
l_int|1
)braket
)paren
)braket
comma
id|tp
op_add_assign
id|d
suffix:semicolon
)brace
r_break
suffix:semicolon
id|found
suffix:colon
r_if
c_cond
(paren
id|U
c_func
(paren
id|tp
(braket
l_int|2
)braket
)paren
op_eq
id|gc
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|3
suffix:semicolon
id|i
op_le
id|len
op_logical_and
id|U
c_func
(paren
id|tp
(braket
id|i
)braket
)paren
op_eq
id|U
c_func
(paren
id|sp
(braket
id|i
)braket
)paren
suffix:semicolon
op_increment
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
id|len
)paren
r_return
id|tp
id|len
id|text
suffix:semicolon
)brace
id|tp
op_add_assign
id|md2
suffix:semicolon
)brace
multiline_comment|/* Now we have only a few characters left to search.  We&n;     carefully avoid ever producing an out-of-bounds pointer. */
id|ep
op_assign
id|text
op_plus
id|size
suffix:semicolon
id|d
op_assign
id|d1
(braket
id|U
c_func
(paren
id|tp
(braket
l_int|1
)braket
)paren
)braket
suffix:semicolon
r_while
c_loop
(paren
id|d
op_le
id|ep
id|tp
)paren
(brace
id|d
op_assign
id|d1
(braket
id|U
c_func
(paren
(paren
id|tp
op_add_assign
id|d
)paren
(braket
l_int|1
)braket
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
id|d
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|U
c_func
(paren
id|tp
(braket
l_int|2
)braket
)paren
op_eq
id|gc
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|3
suffix:semicolon
id|i
op_le
id|len
op_logical_and
id|U
c_func
(paren
id|tp
(braket
id|i
)braket
)paren
op_eq
id|U
c_func
(paren
id|sp
(braket
id|i
)braket
)paren
suffix:semicolon
op_increment
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
id|len
)paren
r_return
id|tp
id|len
id|text
suffix:semicolon
)brace
id|d
op_assign
id|md2
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Hairy multiple string search. */
r_static
r_int
DECL|function|cwexec
id|cwexec
(paren
id|kwset_t
id|kws
comma
r_char
r_const
op_star
id|text
comma
r_int
id|len
comma
r_struct
id|kwsmatch
op_star
id|kwsmatch
)paren
(brace
r_struct
id|kwset
r_const
op_star
id|kwset
suffix:semicolon
r_struct
id|trie
op_star
r_const
op_star
id|next
suffix:semicolon
r_struct
id|trie
r_const
op_star
id|trie
suffix:semicolon
r_struct
id|trie
r_const
op_star
id|accept
suffix:semicolon
r_char
r_const
op_star
id|beg
comma
op_star
id|lim
comma
op_star
id|mch
comma
op_star
id|lmch
suffix:semicolon
r_register
r_int
r_char
id|c
suffix:semicolon
r_register
r_int
r_char
r_const
op_star
id|delta
suffix:semicolon
r_register
r_int
id|d
suffix:semicolon
r_register
r_char
r_const
op_star
id|end
comma
op_star
id|qlim
suffix:semicolon
r_register
r_struct
id|tree
r_const
op_star
id|tree
suffix:semicolon
r_register
r_char
r_const
op_star
id|trans
suffix:semicolon
id|accept
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Initialize register copies and look for easy ways out. */
id|kwset
op_assign
(paren
r_struct
id|kwset
op_star
)paren
id|kws
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
id|kwset-&gt;mind
)paren
r_return
l_int|1
suffix:semicolon
id|next
op_assign
id|kwset-&gt;next
suffix:semicolon
id|delta
op_assign
id|kwset-&gt;delta
suffix:semicolon
id|trans
op_assign
id|kwset-&gt;trans
suffix:semicolon
id|lim
op_assign
id|text
op_plus
id|len
suffix:semicolon
id|end
op_assign
id|text
suffix:semicolon
r_if
c_cond
(paren
(paren
id|d
op_assign
id|kwset-&gt;mind
)paren
op_ne
l_int|0
)paren
id|mch
op_assign
l_int|NULL
suffix:semicolon
r_else
(brace
id|mch
op_assign
id|text
comma
id|accept
op_assign
id|kwset-&gt;trie
suffix:semicolon
r_goto
id|match
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
op_ge
l_int|4
op_star
id|kwset-&gt;mind
)paren
id|qlim
op_assign
id|lim
l_int|4
op_star
id|kwset-&gt;mind
suffix:semicolon
r_else
id|qlim
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|lim
id|end
op_ge
id|d
)paren
(brace
r_if
c_cond
(paren
id|qlim
op_logical_and
id|end
op_le
id|qlim
)paren
(brace
id|end
op_add_assign
id|d
l_int|1
suffix:semicolon
r_while
c_loop
(paren
(paren
id|d
op_assign
id|delta
(braket
id|c
op_assign
op_star
id|end
)braket
)paren
op_logical_and
id|end
OL
id|qlim
)paren
(brace
id|end
op_add_assign
id|d
suffix:semicolon
id|end
op_add_assign
id|delta
(braket
id|U
c_func
(paren
op_star
id|end
)paren
)braket
suffix:semicolon
id|end
op_add_assign
id|delta
(braket
id|U
c_func
(paren
op_star
id|end
)paren
)braket
suffix:semicolon
)brace
op_increment
id|end
suffix:semicolon
)brace
r_else
id|d
op_assign
id|delta
(braket
id|c
op_assign
(paren
id|end
op_add_assign
id|d
)paren
(braket
l_int|1
)braket
)braket
suffix:semicolon
r_if
c_cond
(paren
id|d
)paren
r_continue
suffix:semicolon
id|beg
op_assign
id|end
l_int|1
suffix:semicolon
id|trie
op_assign
id|next
(braket
id|c
)braket
suffix:semicolon
r_if
c_cond
(paren
id|trie-&gt;accepting
)paren
(brace
id|mch
op_assign
id|beg
suffix:semicolon
id|accept
op_assign
id|trie
suffix:semicolon
)brace
id|d
op_assign
id|trie-&gt;shift
suffix:semicolon
r_while
c_loop
(paren
id|beg
OG
id|text
)paren
(brace
id|c
op_assign
id|trans
ques
c_cond
id|trans
(braket
id|U
c_func
(paren
op_star
op_decrement
id|beg
)paren
)braket
suffix:colon
op_star
op_decrement
id|beg
suffix:semicolon
id|tree
op_assign
id|trie-&gt;links
suffix:semicolon
r_while
c_loop
(paren
id|tree
op_logical_and
id|c
op_ne
id|tree-&gt;label
)paren
r_if
c_cond
(paren
id|c
OL
id|tree-&gt;label
)paren
id|tree
op_assign
id|tree-&gt;llink
suffix:semicolon
r_else
id|tree
op_assign
id|tree-&gt;rlink
suffix:semicolon
r_if
c_cond
(paren
id|tree
)paren
(brace
id|trie
op_assign
id|tree-&gt;trie
suffix:semicolon
r_if
c_cond
(paren
id|trie-&gt;accepting
)paren
(brace
id|mch
op_assign
id|beg
suffix:semicolon
id|accept
op_assign
id|trie
suffix:semicolon
)brace
)brace
r_else
r_break
suffix:semicolon
id|d
op_assign
id|trie-&gt;shift
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mch
)paren
r_goto
id|match
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
id|match
suffix:colon
multiline_comment|/* Given a known match, find the longest possible match anchored&n;     at or before its starting point.  This is nearly a verbatim&n;     copy of the preceding main search loops. */
r_if
c_cond
(paren
id|lim
id|mch
OG
id|kwset-&gt;maxd
)paren
id|lim
op_assign
id|mch
op_plus
id|kwset-&gt;maxd
suffix:semicolon
id|lmch
op_assign
l_int|0
suffix:semicolon
id|d
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|lim
id|end
op_ge
id|d
)paren
(brace
r_if
c_cond
(paren
(paren
id|d
op_assign
id|delta
(braket
id|c
op_assign
(paren
id|end
op_add_assign
id|d
)paren
(braket
l_int|1
)braket
)braket
)paren
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
id|beg
op_assign
id|end
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|trie
op_assign
id|next
(braket
id|c
)braket
)paren
)paren
(brace
id|d
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|trie-&gt;accepting
op_logical_and
id|beg
op_le
id|mch
)paren
(brace
id|lmch
op_assign
id|beg
suffix:semicolon
id|accept
op_assign
id|trie
suffix:semicolon
)brace
id|d
op_assign
id|trie-&gt;shift
suffix:semicolon
r_while
c_loop
(paren
id|beg
OG
id|text
)paren
(brace
id|c
op_assign
id|trans
ques
c_cond
id|trans
(braket
id|U
c_func
(paren
op_star
op_decrement
id|beg
)paren
)braket
suffix:colon
op_star
op_decrement
id|beg
suffix:semicolon
id|tree
op_assign
id|trie-&gt;links
suffix:semicolon
r_while
c_loop
(paren
id|tree
op_logical_and
id|c
op_ne
id|tree-&gt;label
)paren
r_if
c_cond
(paren
id|c
OL
id|tree-&gt;label
)paren
id|tree
op_assign
id|tree-&gt;llink
suffix:semicolon
r_else
id|tree
op_assign
id|tree-&gt;rlink
suffix:semicolon
r_if
c_cond
(paren
id|tree
)paren
(brace
id|trie
op_assign
id|tree-&gt;trie
suffix:semicolon
r_if
c_cond
(paren
id|trie-&gt;accepting
op_logical_and
id|beg
op_le
id|mch
)paren
(brace
id|lmch
op_assign
id|beg
suffix:semicolon
id|accept
op_assign
id|trie
suffix:semicolon
)brace
)brace
r_else
r_break
suffix:semicolon
id|d
op_assign
id|trie-&gt;shift
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lmch
)paren
(brace
id|mch
op_assign
id|lmch
suffix:semicolon
r_goto
id|match
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|d
)paren
id|d
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|kwsmatch
)paren
(brace
id|kwsmatch-&gt;index
op_assign
id|accept-&gt;accepting
op_div
l_int|2
suffix:semicolon
id|kwsmatch-&gt;offset
(braket
l_int|0
)braket
op_assign
id|mch
id|text
suffix:semicolon
id|kwsmatch-&gt;size
(braket
l_int|0
)braket
op_assign
id|accept-&gt;depth
suffix:semicolon
)brace
r_return
id|mch
id|text
suffix:semicolon
)brace
multiline_comment|/* Search through the given text for a match of any member of the&n;   given keyword set.  Return a pointer to the first character of&n;   the matching substring, or NULL if no match is found.  If FOUNDLEN&n;   is non-NULL store in the referenced location the length of the&n;   matching substring.  Similarly, if FOUNDIDX is non-NULL, store&n;   in the referenced location the index number of the particular&n;   keyword matched. */
r_int
DECL|function|kwsexec
id|kwsexec
(paren
id|kwset_t
id|kws
comma
r_char
r_const
op_star
id|text
comma
r_int
id|size
comma
r_struct
id|kwsmatch
op_star
id|kwsmatch
)paren
(brace
r_struct
id|kwset
r_const
op_star
id|kwset
op_assign
(paren
r_struct
id|kwset
op_star
)paren
id|kws
suffix:semicolon
r_if
c_cond
(paren
id|kwset-&gt;words
op_eq
l_int|1
op_logical_and
id|kwset-&gt;trans
op_eq
l_int|NULL
)paren
(brace
r_int
id|ret
op_assign
id|bmexec
(paren
id|kws
comma
id|text
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kwsmatch
op_ne
l_int|NULL
op_logical_and
id|ret
op_ne
(paren
r_int
)paren
l_int|1
)paren
(brace
id|kwsmatch-&gt;index
op_assign
l_int|0
suffix:semicolon
id|kwsmatch-&gt;offset
(braket
l_int|0
)braket
op_assign
id|ret
suffix:semicolon
id|kwsmatch-&gt;size
(braket
l_int|0
)braket
op_assign
id|kwset-&gt;mind
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
r_else
r_return
id|cwexec
c_func
(paren
id|kws
comma
id|text
comma
id|size
comma
id|kwsmatch
)paren
suffix:semicolon
)brace
multiline_comment|/* Free the components of the given keyword set. */
r_void
DECL|function|kwsfree
id|kwsfree
(paren
id|kwset_t
id|kws
)paren
(brace
r_struct
id|kwset
op_star
id|kwset
suffix:semicolon
id|kwset
op_assign
(paren
r_struct
id|kwset
op_star
)paren
id|kws
suffix:semicolon
id|obstack_free
c_func
(paren
op_amp
id|kwset-&gt;obstack
comma
l_int|NULL
)paren
suffix:semicolon
id|free
c_func
(paren
id|kws
)paren
suffix:semicolon
)brace
eof
