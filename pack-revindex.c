macro_line|#include &quot;cache.h&quot;
macro_line|#include &quot;pack-revindex.h&quot;
multiline_comment|/*&n; * Pack index for existing packs give us easy access to the offsets into&n; * corresponding pack file where each object&squot;s data starts, but the entries&n; * do not store the size of the compressed representation (uncompressed&n; * size is easily available by examining the pack entry header).  It is&n; * also rather expensive to find the sha1 for an object given its offset.&n; *&n; * We build a hashtable of existing packs (pack_revindex), and keep reverse&n; * index here -- pack index file is sorted by object name mapping to offset;&n; * this pack_revindex[].revindex array is a list of offset/index_nr pairs&n; * ordered by offset, so if you know the offset of an object, next offset&n; * is where its packed representation ends and the index_nr can be used to&n; * get the object sha1 from the main index.&n; */
DECL|struct|pack_revindex
r_struct
id|pack_revindex
(brace
DECL|member|p
r_struct
id|packed_git
op_star
id|p
suffix:semicolon
DECL|member|revindex
r_struct
id|revindex_entry
op_star
id|revindex
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|pack_revindex
r_static
r_struct
id|pack_revindex
op_star
id|pack_revindex
suffix:semicolon
DECL|variable|pack_revindex_hashsz
r_static
r_int
id|pack_revindex_hashsz
suffix:semicolon
DECL|function|pack_revindex_ix
r_static
r_int
id|pack_revindex_ix
c_func
(paren
r_struct
id|packed_git
op_star
id|p
)paren
(brace
r_int
r_int
id|ui
op_assign
(paren
r_int
r_int
)paren
id|p
suffix:semicolon
r_int
id|i
suffix:semicolon
id|ui
op_assign
id|ui
op_xor
(paren
id|ui
op_rshift
l_int|16
)paren
suffix:semicolon
multiline_comment|/* defeat structure alignment */
id|i
op_assign
(paren
r_int
)paren
(paren
id|ui
op_mod
id|pack_revindex_hashsz
)paren
suffix:semicolon
r_while
c_loop
(paren
id|pack_revindex
(braket
id|i
)braket
dot
id|p
)paren
(brace
r_if
c_cond
(paren
id|pack_revindex
(braket
id|i
)braket
dot
id|p
op_eq
id|p
)paren
r_return
id|i
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|i
op_eq
id|pack_revindex_hashsz
)paren
id|i
op_assign
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
id|i
suffix:semicolon
)brace
DECL|function|init_pack_revindex
r_static
r_void
id|init_pack_revindex
c_func
(paren
r_void
)paren
(brace
r_int
id|num
suffix:semicolon
r_struct
id|packed_git
op_star
id|p
suffix:semicolon
r_for
c_loop
(paren
id|num
op_assign
l_int|0
comma
id|p
op_assign
id|packed_git
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
id|num
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|num
)paren
r_return
suffix:semicolon
id|pack_revindex_hashsz
op_assign
id|num
op_star
l_int|11
suffix:semicolon
id|pack_revindex
op_assign
id|xcalloc
c_func
(paren
r_sizeof
(paren
op_star
id|pack_revindex
)paren
comma
id|pack_revindex_hashsz
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|packed_git
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
id|num
op_assign
id|pack_revindex_ix
c_func
(paren
id|p
)paren
suffix:semicolon
id|num
op_assign
l_int|1
id|num
suffix:semicolon
id|pack_revindex
(braket
id|num
)braket
dot
id|p
op_assign
id|p
suffix:semicolon
)brace
multiline_comment|/* revindex elements are lazily initialized */
)brace
multiline_comment|/*&n; * This is a least-significant-digit radix sort.&n; *&n; * It sorts each of the &quot;n&quot; items in &quot;entries&quot; by its offset field. The &quot;max&quot;&n; * parameter must be at least as large as the largest offset in the array,&n; * and lets us quit the sort early.&n; */
DECL|function|sort_revindex
r_static
r_void
id|sort_revindex
c_func
(paren
r_struct
id|revindex_entry
op_star
id|entries
comma
r_int
id|n
comma
id|off_t
id|max
)paren
(brace
multiline_comment|/*&n;&t; * We use a &quot;digit&quot; size of 16 bits. That keeps our memory&n;&t; * usage reasonable, and we can generally (for a 4G or smaller&n;&t; * packfile) quit after two rounds of radix-sorting.&n;&t; */
DECL|macro|DIGIT_SIZE
mdefine_line|#define DIGIT_SIZE (16)
DECL|macro|BUCKETS
mdefine_line|#define BUCKETS (1 &lt;&lt; DIGIT_SIZE)
multiline_comment|/*&n;&t; * We want to know the bucket that a[i] will go into when we are using&n;&t; * the digit that is N bits from the (least significant) end.&n;&t; */
DECL|macro|BUCKET_FOR
mdefine_line|#define BUCKET_FOR(a, i, bits) (((a)[(i)].offset &gt;&gt; (bits)) &amp; (BUCKETS-1))
multiline_comment|/*&n;&t; * We need O(n) temporary storage. Rather than do an extra copy of the&n;&t; * partial results into &quot;entries&quot;, we sort back and forth between the&n;&t; * real array and temporary storage. In each iteration of the loop, we&n;&t; * keep track of them with alias pointers, always sorting from &quot;from&quot;&n;&t; * to &quot;to&quot;.&n;&t; */
r_struct
id|revindex_entry
op_star
id|tmp
op_assign
id|xmalloc
c_func
(paren
id|n
op_star
r_sizeof
(paren
op_star
id|tmp
)paren
)paren
suffix:semicolon
r_struct
id|revindex_entry
op_star
id|from
op_assign
id|entries
comma
op_star
id|to
op_assign
id|tmp
suffix:semicolon
r_int
id|bits
suffix:semicolon
r_int
op_star
id|pos
op_assign
id|xmalloc
c_func
(paren
id|BUCKETS
op_star
r_sizeof
(paren
op_star
id|pos
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If (max &gt;&gt; bits) is zero, then we know that the radix digit we are&n;&t; * on (and any higher) will be zero for all entries, and our loop will&n;&t; * be a no-op, as everybody lands in the same zero-th bucket.&n;&t; */
r_for
c_loop
(paren
id|bits
op_assign
l_int|0
suffix:semicolon
id|max
op_rshift
id|bits
suffix:semicolon
id|bits
op_add_assign
id|DIGIT_SIZE
)paren
(brace
r_struct
id|revindex_entry
op_star
id|swap
suffix:semicolon
r_int
id|i
suffix:semicolon
id|memset
c_func
(paren
id|pos
comma
l_int|0
comma
id|BUCKETS
op_star
r_sizeof
(paren
op_star
id|pos
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We want pos[i] to store the index of the last element that&n;&t;&t; * will go in bucket &quot;i&quot; (actually one past the last element).&n;&t;&t; * To do this, we first count the items that will go in each&n;&t;&t; * bucket, which gives us a relative offset from the last&n;&t;&t; * bucket. We can then cumulatively add the index from the&n;&t;&t; * previous bucket to get the true index.&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
id|pos
(braket
id|BUCKET_FOR
c_func
(paren
id|from
comma
id|i
comma
id|bits
)paren
)braket
op_increment
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|BUCKETS
suffix:semicolon
id|i
op_increment
)paren
id|pos
(braket
id|i
)braket
op_add_assign
id|pos
(braket
id|i
op_minus
l_int|1
)braket
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Now we can drop the elements into their correct buckets (in&n;&t;&t; * our temporary array).  We iterate the pos counter backwards&n;&t;&t; * to avoid using an extra index to count up. And since we are&n;&t;&t; * going backwards there, we must also go backwards through the&n;&t;&t; * array itself, to keep the sort stable.&n;&t;&t; *&n;&t;&t; * Note that we use an unsigned iterator to make sure we can&n;&t;&t; * handle 2^32-1 objects, even on a 32-bit system. But this&n;&t;&t; * means we cannot use the more obvious &quot;i &gt;= 0&quot; loop condition&n;&t;&t; * for counting backwards, and must instead check for&n;&t;&t; * wrap-around with UINT_MAX.&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
id|n
l_int|1
suffix:semicolon
id|i
op_ne
id|UINT_MAX
suffix:semicolon
id|i
op_decrement
)paren
id|to
(braket
op_decrement
id|pos
(braket
id|BUCKET_FOR
c_func
(paren
id|from
comma
id|i
comma
id|bits
)paren
)braket
)braket
op_assign
id|from
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Now &quot;to&quot; contains the most sorted list, so we swap &quot;from&quot; and&n;&t;&t; * &quot;to&quot; for the next iteration.&n;&t;&t; */
id|swap
op_assign
id|from
suffix:semicolon
id|from
op_assign
id|to
suffix:semicolon
id|to
op_assign
id|swap
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we ended with our data in the original array, great. If not,&n;&t; * we have to move it back from the temporary storage.&n;&t; */
r_if
c_cond
(paren
id|from
op_ne
id|entries
)paren
id|memcpy
c_func
(paren
id|entries
comma
id|tmp
comma
id|n
op_star
r_sizeof
(paren
op_star
id|entries
)paren
)paren
suffix:semicolon
id|free
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|free
c_func
(paren
id|pos
)paren
suffix:semicolon
DECL|macro|BUCKET_FOR
macro_line|#undef BUCKET_FOR
DECL|macro|BUCKETS
macro_line|#undef BUCKETS
DECL|macro|DIGIT_SIZE
macro_line|#undef DIGIT_SIZE
)brace
multiline_comment|/*&n; * Ordered list of offsets of objects in the pack.&n; */
DECL|function|create_pack_revindex
r_static
r_void
id|create_pack_revindex
c_func
(paren
r_struct
id|pack_revindex
op_star
id|rix
)paren
(brace
r_struct
id|packed_git
op_star
id|p
op_assign
id|rix-&gt;p
suffix:semicolon
r_int
id|num_ent
op_assign
id|p-&gt;num_objects
suffix:semicolon
r_int
id|i
suffix:semicolon
r_const
r_char
op_star
id|index
op_assign
id|p-&gt;index_data
suffix:semicolon
id|rix-&gt;revindex
op_assign
id|xmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|rix-&gt;revindex
)paren
op_star
(paren
id|num_ent
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|index
op_add_assign
l_int|4
op_star
l_int|256
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;index_version
OG
l_int|1
)paren
(brace
r_const
r_uint32
op_star
id|off_32
op_assign
(paren
r_uint32
op_star
)paren
(paren
id|index
op_plus
l_int|8
op_plus
id|p-&gt;num_objects
op_star
(paren
l_int|20
op_plus
l_int|4
)paren
)paren
suffix:semicolon
r_const
r_uint32
op_star
id|off_64
op_assign
id|off_32
op_plus
id|p-&gt;num_objects
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_ent
suffix:semicolon
id|i
op_increment
)paren
(brace
r_uint32
id|off
op_assign
id|ntohl
c_func
(paren
op_star
id|off_32
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|off
op_amp
l_int|0x80000000
)paren
)paren
(brace
id|rix-&gt;revindex
(braket
id|i
)braket
dot
id|offset
op_assign
id|off
suffix:semicolon
)brace
r_else
(brace
id|rix-&gt;revindex
(braket
id|i
)braket
dot
id|offset
op_assign
(paren
(paren
r_uint64
)paren
id|ntohl
c_func
(paren
op_star
id|off_64
op_increment
)paren
)paren
op_lshift
l_int|32
suffix:semicolon
id|rix-&gt;revindex
(braket
id|i
)braket
dot
id|offset
op_or_assign
id|ntohl
c_func
(paren
op_star
id|off_64
op_increment
)paren
suffix:semicolon
)brace
id|rix-&gt;revindex
(braket
id|i
)braket
dot
id|nr
op_assign
id|i
suffix:semicolon
)brace
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_ent
suffix:semicolon
id|i
op_increment
)paren
(brace
r_uint32
id|hl
op_assign
op_star
(paren
(paren
r_uint32
op_star
)paren
(paren
id|index
op_plus
l_int|24
op_star
id|i
)paren
)paren
suffix:semicolon
id|rix-&gt;revindex
(braket
id|i
)braket
dot
id|offset
op_assign
id|ntohl
c_func
(paren
id|hl
)paren
suffix:semicolon
id|rix-&gt;revindex
(braket
id|i
)braket
dot
id|nr
op_assign
id|i
suffix:semicolon
)brace
)brace
multiline_comment|/* This knows the pack format -- the 20-byte trailer&n;&t; * follows immediately after the last object data.&n;&t; */
id|rix-&gt;revindex
(braket
id|num_ent
)braket
dot
id|offset
op_assign
id|p-&gt;pack_size
l_int|20
suffix:semicolon
id|rix-&gt;revindex
(braket
id|num_ent
)braket
dot
id|nr
op_assign
l_int|1
suffix:semicolon
id|sort_revindex
c_func
(paren
id|rix-&gt;revindex
comma
id|num_ent
comma
id|p-&gt;pack_size
)paren
suffix:semicolon
)brace
DECL|function|find_pack_revindex
r_struct
id|revindex_entry
op_star
id|find_pack_revindex
c_func
(paren
r_struct
id|packed_git
op_star
id|p
comma
id|off_t
id|ofs
)paren
(brace
r_int
id|num
suffix:semicolon
r_int
id|lo
comma
id|hi
suffix:semicolon
r_struct
id|pack_revindex
op_star
id|rix
suffix:semicolon
r_struct
id|revindex_entry
op_star
id|revindex
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pack_revindex_hashsz
)paren
id|init_pack_revindex
c_func
(paren
)paren
suffix:semicolon
id|num
op_assign
id|pack_revindex_ix
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|num
OL
l_int|0
)paren
id|die
c_func
(paren
l_string|&quot;internal error: pack revindex fubar&quot;
)paren
suffix:semicolon
id|rix
op_assign
op_amp
id|pack_revindex
(braket
id|num
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rix-&gt;revindex
)paren
id|create_pack_revindex
c_func
(paren
id|rix
)paren
suffix:semicolon
id|revindex
op_assign
id|rix-&gt;revindex
suffix:semicolon
id|lo
op_assign
l_int|0
suffix:semicolon
id|hi
op_assign
id|p-&gt;num_objects
op_plus
l_int|1
suffix:semicolon
r_do
(brace
r_int
id|mi
op_assign
id|lo
op_plus
(paren
id|hi
id|lo
)paren
op_div
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|revindex
(braket
id|mi
)braket
dot
id|offset
op_eq
id|ofs
)paren
(brace
r_return
id|revindex
op_plus
id|mi
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ofs
OL
id|revindex
(braket
id|mi
)braket
dot
id|offset
)paren
id|hi
op_assign
id|mi
suffix:semicolon
r_else
id|lo
op_assign
id|mi
op_plus
l_int|1
suffix:semicolon
)brace
r_while
c_loop
(paren
id|lo
OL
id|hi
)paren
suffix:semicolon
id|error
c_func
(paren
l_string|&quot;bad offset for revindex&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|discard_revindex
r_void
id|discard_revindex
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|pack_revindex_hashsz
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pack_revindex_hashsz
suffix:semicolon
id|i
op_increment
)paren
id|free
c_func
(paren
id|pack_revindex
(braket
id|i
)braket
dot
id|revindex
)paren
suffix:semicolon
id|free
c_func
(paren
id|pack_revindex
)paren
suffix:semicolon
id|pack_revindex_hashsz
op_assign
l_int|0
suffix:semicolon
)brace
)brace
eof
